const { Op, col } = require("sequelize");
const db = require("../../models");
const HttpCodes = require("http-codes");
const { ApiError } = require("../../middlewares/ApiError");
const dayjs = require("dayjs");
const isoWeek = require("dayjs/plugin/isoWeek");
const dayOfYear = require("dayjs/plugin/dayOfYear");
const isLeapYear = require("dayjs/plugin/isLeapYear");
   
dayjs.extend(isoWeek);
dayjs.extend(dayOfYear);
dayjs.extend(isLeapYear);
const utc = require("dayjs/plugin/utc");
dayjs.extend(utc);
const localizedFormat = require("dayjs/plugin/localizedFormat");
dayjs.extend(localizedFormat);

const moment = require("moment");
const momenttimezone = require('moment-timezone');
const customParseFormat = require("dayjs/plugin/customParseFormat");
const duration = require("dayjs/plugin/duration");
dayjs.extend(customParseFormat);
dayjs.extend(duration);
const sprintf = require("sprintf-js").sprintf;
const isSameOrBefore = require("dayjs/plugin/isSameOrBefore");
dayjs.extend(isSameOrBefore);

const weekday = require("dayjs/plugin/weekday");
dayjs.extend(weekday);

const weekOfYear = require("dayjs/plugin/weekOfYear");
dayjs.extend(weekOfYear);

const advancedFormat = require("dayjs/plugin/advancedFormat");
dayjs.extend(advancedFormat);

require("moment-duration-format");

require("moment-precise-range-plugin");
const math = require("mathjs");
const momentBase = require("moment");
const axios = require("axios");
const qs = require("qs");
const { factorial } = require("mathjs"); // Ensure mathjs is installed
const { DateTime } = require("luxon"); // use luxon or native Date for date handling
// class AgeCalculator {
//   constructor() {
//     this.age = 0;
//   }
//     calculateAge(timestamp) {
//       const birthDate = new Date(timestamp);
//       const today = new Date();

//       let age = today.getFullYear() - birthDate.getFullYear();
//       const monthDiff = today.getMonth() - birthDate.getMonth();
//       const dayDiff = today.getDate() - birthDate.getDate();

//       if (monthDiff < 0 || (monthDiff === 0 && dayDiff < 0)) {
//         age--;
//       }

//       this.age = age;
//     }

//     getAge() {
//       return this.age;
//     }

//     getRank(age) {
//       return age + 1; // Simulating the get_rank logic
//     }

//   }

class AgeCalculator {
  constructor() {
    this.age = 0;
  }

  calculateAge(timestamp) {
    const birthDate = new Date(timestamp);
    const today = new Date();

    let age = today.getFullYear() - birthDate.getFullYear();
    const monthDiff = today.getMonth() - birthDate.getMonth();
    const dayDiff = today.getDate() - birthDate.getDate();

    if (monthDiff < 0 || (monthDiff === 0 && dayDiff < 0)) {
      age--;
    }

    this.age = age;
  }

  getAge() {
    return this.age;
  }

  getRank(age) {
    return age + 1; // Example rank logic
  }
}

class CalculatorsServices {
  /**
   * getCalculationCatAgeCalculator: Service Method
   * POST: /api/calculators-lol/cat-age-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCatAgeCalculator(body) {
    const petYear = parseFloat(body.tech_Year);
    const petMonth = parseFloat(body.tech_Month);
    const conversionMethod = parseInt(body.tech_Method);
    // return [petYear , petMonth];
    let response = {};

    if (!isNaN(petYear) || !isNaN(petMonth)) {
      let age = 0;

      if (!isNaN(petYear)) {
        age = petYear;
      }

      if (!isNaN(petMonth) && petMonth !== 0) {
        age += petMonth / 12;
      }

      let ans;

      if (conversionMethod === 1) {
        // Human → Cat age conversion
        if (age >= 6) {
          ans = Math.round(40 + 4 * (age - 6));
        } else {
          ans = Math.round(6.6666 * age + 0.066666667);
        }
      } else if (conversionMethod === 2) {
        // Cat → Human age conversion
        if (age >= 40) {
          ans = Math.round(0.25 * age - 4);
        } else {
          ans = Math.round((age - 0.066666667) / 6.6666);
        }
      }

      response = {
        success: true,
        tech_ans: ans,
      };
    } else {
      response = {
        error: "Please! Check Your Inputs",
      };
    }

    return response;
  }

  /**
   * getCalculationSquareInchesCalculator: Service Method
   * POST: /api/calculators-lol/square-inches-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSquareInchesCalculator(body) {
    const dimensionLength = parseFloat(body.dimensionLength) || 0;
    const dimensionLengthUnit = body.dimensionLengthUnit?.trim() || "in";
    const dimensionWidth = parseFloat(body.dimensionWidth) || 0;
    const dimensionWidthUnit = body.dimensionWidthUnit?.trim() || "in";
    const costPerUnit = parseFloat(body.costPerUnit) || 0;

    const convertToInches = (value, unit) => {
      switch (unit) {
        case "ft":
          return value * 12;
        case "in":
          return value;
        case "yd":
          return value * 36;
        case "cm":
          return value / 2.54;
        case "m":
          return value * 39.37;
        case "mi":
          return value * 63360; // corrected!
        case "km":
          return value * 39370;
        default:
          return 0;
      }
    };

    const convertedLength = convertToInches(
      dimensionLength,
      dimensionLengthUnit
    );
    const convertedWidth = convertToInches(dimensionWidth, dimensionWidthUnit);
    const squareInches = convertedLength * convertedWidth;

    const response = {
      status: 1,
      areaInSquareInches: squareInches,
      calculatedCost: squareInches * costPerUnit,
    };

    return response;
  }

  /**
   * getCalculationClassWidthCalculator: Service Method
   * POST: /api/calculators-lol/class-width-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationClassWidthCalculator(body) {
    const lowerBound = parseFloat(body.tech_lowerBound?.toString().trim()); // Changed from "minimum"
    const upperBound = parseFloat(body.tech_upperBound?.toString().trim()); // Changed from "maximum"
    const totalParts = parseFloat(body.tech_totalParts?.toString().trim()); // Changed from "number"

    const response = {};

    if (!isNaN(lowerBound) && !isNaN(upperBound) && !isNaN(totalParts)) {
      if (lowerBound < upperBound) {
        const width = (upperBound - lowerBound) / totalParts;
        const answer = Math.abs(width);

        response.tech_answer = answer;
        response.tech_lowerBound = lowerBound;
        response.tech_upperBound = upperBound;
        response.tech_totalParts = totalParts;
      } else {
        response.error =
          "The upper bound value must be greater than the lower bound value.";
      }
    } else {
      response.error = "Please! Check Your Input";
    }

    return response;
  }

  /**
   * getCalculationBondOrderCalculator: Service Method
   * POST: /api/calculators-lol/bond-order-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationBondOrderCalculator(body) {
    const calculationType = body.tech_calculationType;
    const firstInput = parseFloat(body.tech_firstInput);
    const secondInput = parseFloat(body.tech_secondInput);

    let response = {};

    if (!isNaN(firstInput) && !isNaN(secondInput)) {
      let result;

      if (calculationType === "1") {
        result = 0.5 * (firstInput - secondInput);
      } else if (calculationType === "2") {
        result = 2 * firstInput + secondInput;
      } else {
        result = (firstInput * 2 - secondInput) * -1;
      }

      response = {
        tech_calculatedAnswer: result,
        tech_firstInput: firstInput,
        tech_secondInput: secondInput,
      };
    } else {
      response = {
        error: "Please! Check Your Input.",
      };
    }

    return response;
  }

  /**
   * getCalculationWavePeriodCalculator: Service Method
   * POST: /api/calculators-lol/wave-period-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationWavePeriodCalculator(body) {
    const calculationType = body.calculationType; // sim_adv
    const frequencyValue = parseFloat(body.frequency); // frequency
    const frequencyInSeconds = parseFloat(body.frequencyInSeconds); // frequency_sec
    const waveLength = parseFloat(body.waveLength); // wavelength
    const waveSpeed = parseFloat(body.waveSpeed); // wave_speed

    let response = {};

    if (calculationType === "simple") {
      if (!isNaN(frequencyValue)) {
        if (frequencyValue > 0) {
          const wavePeriod = 1 / frequencyValue;
          response.wavePeriod = wavePeriod;
          response.calculationType = calculationType;
        } else {
          response.error = "Frequency must be greater than zero.";
        }
      } else {
        response.error = "Please! Check Your Input.";
      }
    } else if (calculationType === "advanced") {
      if (!isNaN(waveLength) && !isNaN(waveSpeed)) {
        const wavePeriod = waveLength / waveSpeed;
        response.wavePeriod = wavePeriod;
        response.calculationType = calculationType;
      } else {
        response.error = "Please! Check Your Input.";
      }
    }

    return response;
  }

  /**
   * getCalculationwaterBillCalculator: Service Method
   * POST: /api/calculators-lol/water-bill-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationwaterBillCalculator(body) {
    // Extract water rate and gallon usage from the body
    const waterRate = parseFloat(body.waterRate); // Renaming $water to waterRate
    const gallonUsage = parseFloat(body.gallonUsage); // Renaming $gallon to gallonUsage

    // Initialize an object to hold the response
    let result = {};

    // Check if both water rate and gallon usage are valid numbers
    if (!isNaN(waterRate) && !isNaN(gallonUsage)) {
      // Calculate the bill
      const billAmount = waterRate * gallonUsage;
      // Prepare the response with the calculated bill

      result.totalBill = billAmount; // Renamed 'bill' to 'totalBill'

      result.status = 1; // Renamed 'RESULT' to 'status'
    } else {
      // If inputs are not valid, add an error message to the response
      result.error = "Please! Check Your Input";
    }

    // Return the result object
    return result;
  }

  /**
   * getCalculationLoveCalculator: Service Method
   * POST: /api/calculators-lol/love-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationLoveCalculator(body) {
    // Extracting names from the body
    const yourName = body.yourName; // Renaming 'you' to 'yourName'
    const partnerName = body.partnerName; // Renaming 'lover' to 'partnerName'

    // Initialize an object to store the response
    let result = {};

    // Check if both names are provided
    if (!yourName || !partnerName) {
      // Handle missing names with appropriate messages
      if (!yourName && !partnerName) {
        result.error =
          "Both your name and your partner's name are required to proceed.";
      } else if (!yourName) {
        result.error = "Your name is necessary to calculate the love score.";
      } else {
        result.error =
          "Your partner's name is required to calculate the love score.";
      }
      return result;
    }

    // Generate a random love score between 20 and 100
    const loveScore = Math.floor(Math.random() * (100 - 20 + 1)) + 20; // Changed from 'rand' to 'Math.random()'

    // Add the result to the response object
    result.loveScore = loveScore; // Changed 'RESULT' to 'loveScore'
    return result;
  }

  /**
   * getCalculationPercentErrorCalculator: Service Method
   * POST: /api/calculators-lol/percent-error-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPercentErrorCalculator(body) {
    // Extract values from the body
    const actualValue = parseFloat(body.actualValue); // Renaming 'av' to 'actualValue'
    const originalValue = parseFloat(body.originalValue); // Renaming 'ov' to 'originalValue'

    // Initialize an object to hold the response
    let result = {};

    // Check if both values are valid numbers
    if (!isNaN(originalValue) && !isNaN(actualValue)) {
      // Calculate the percent error
      const percentError = ((originalValue - actualValue) / actualValue) * 100;
      console.log(percentError);
      // Round the result to two decimal places
      result.errorPercentage = percentError.toFixed(2); // Renaming 'own_error' to match the original logic
      result.status = 1;
    } else {
      // If either value is not a valid number, set an error message
      result.error = "Please Check Your Input.";
    }

    // Return the result object
    return result;
  }

  /**
   * getCalculationBenchPressCalculator: Service Method
   * POST: /api/calculators-lol/bench-press-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBenchPressCalculator(body) {
    // Extract and sanitize inputs from body
    const inputWeight = parseFloat(body.inputWeight?.toString().trim());
    const unitType = body.unitType?.toString().trim();
    const repetitions = parseInt(body.repetitions?.toString().trim(), 10);
    const conversionTable = body.conversionTable?.toString().trim(); // If needed later

    let response = {};

    let weightInPounds = inputWeight;

    // Convert input weight to pounds if necessary
    if (unitType === "kg") {
      weightInPounds = inputWeight * 2.20462;
    } else if (unitType === "stone") {
      weightInPounds = inputWeight * 14;
    }

    // Calculate the one-rep max using standard formula
    let estimatedMax = weightInPounds * (1 + repetitions / 30);

    // Convert the result back to original unit
    if (unitType === "kg") {
      estimatedMax = estimatedMax / 2.20462;
    } else if (unitType === "stone") {
      estimatedMax = estimatedMax / 14;
    }

    // Build response
    response.maxLiftEstimate = estimatedMax;
    response.status = 1;

    return response;
  }

  /**
   * getCalculationDogPregnancyCalculator: Service Method
   * POST: /api/calculators-lol/dog-pregnancy-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDogPregnancyCalculator(body) {
    const e_date = body.tech_e_date; // format: YYYY-MM-DD

    const din = 63;
    const startDate = new Date(e_date);

    // Step 1: Main due date after 63 days
    const dueDate = new Date(startDate);
    dueDate.setDate(dueDate.getDate() + din);

    const formattedDueDate = dueDate.toLocaleDateString("en-US", {
      weekday: "long",
      month: "short",
      day: "2-digit",
      year: "numeric",
    });

    // Step 2: Weekly Ranges
    let e_date2 = new Date(startDate);
    e_date2.setDate(e_date2.getDate() + 1);

    let e_date3 = new Date(e_date2);
    e_date3.setDate(e_date3.getDate() + 6);

    let firstDates = [];
    let secondDates = [];

    for (let i = 0; i < 8; i++) {
      e_date2.setDate(e_date2.getDate() + 7);
      firstDates.push(new Date(e_date2));

      e_date3.setDate(e_date3.getDate() + 7);
      secondDates.push(new Date(e_date3));
    }

    const last1 = new Date(firstDates[7]);
    last1.setDate(last1.getDate() + 7);

    const last2 = new Date(secondDates[7]);
    last2.setDate(last2.getDate() + 7);

    const formatDate = (date) =>
      date.toLocaleDateString("en-US", {
        month: "short",
        day: "2-digit",
        year: "numeric",
      });

    const formatRange = (d1, d2) => `${formatDate(d1)} - ${formatDate(d2)}`;

    return {
      tech_date: formattedDueDate,
      tech_line: formatRange(firstDates[7], secondDates[7]),
      tech_line0: formatRange(firstDates[0], secondDates[0]),
      tech_line1: formatRange(firstDates[1], secondDates[1]),
      tech_line2: formatRange(firstDates[2], secondDates[2]),
      tech_line3: formatRange(firstDates[3], secondDates[3]),
      tech_line4: formatRange(firstDates[4], secondDates[4]),
      tech_line5: formatRange(firstDates[5], secondDates[5]),
      tech_line6: formatRange(firstDates[6], secondDates[6]),
      tech_line7: formatRange(firstDates[7], secondDates[7]),
      tech_line_l: formatRange(last1, last2),
    };
  }

  /**
   * getCalculationBenadrylForDogsCalculator: Service Method
   * POST: /api/calculators-lol/benadryl-for-dogs-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBenadrylForDogsCalculator(body) {
    const dogWeight = body.dog_weight;
    let weightUnitMultiplier = body.weight_unit;

    // Convert weight unit to appropriate multiplier
    if (weightUnitMultiplier === "g") {
      weightUnitMultiplier = 0.0022046;
    } else if (weightUnitMultiplier === "dag") {
      weightUnitMultiplier = 0.022046;
    } else if (weightUnitMultiplier === "kg") {
      weightUnitMultiplier = 2.2046;
    } else if (weightUnitMultiplier === "oz") {
      weightUnitMultiplier = 0.0625;
    } else if (weightUnitMultiplier === "lbs") {
      weightUnitMultiplier = 1;
    } else if (weightUnitMultiplier === "stone") {
      weightUnitMultiplier = 14;
    }

    if (isNaN(dogWeight)) {
      return {
        errorMessage: "Please check your input.",
        resultCode: 0,
      };
    }

    if (dogWeight < 0) {
      return {
        errorMessage: "The dog's weight should be more than 0",
        resultCode: 0,
      };
    }

    // Calculate the dosage values
    const weightInPounds = dogWeight * weightUnitMultiplier;
    const benadrylDose = weightInPounds * 1;
    const liquidDose = weightInPounds / 2.5;

    return {
      benadrylDosage: benadrylDose,
      liquidDosage: liquidDose,
    };
  }

  /**
   * getCalculationCatCaloieCalculator: Service Method
   * POST: /api/calculators-lol/cat-calorie-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCatCaloieCalculator(body) {
    let catWeight = body.tech_cat_weight;
    let catWeightUnit = body.tech_unit;
    let catCondition = body.tech_cat_condition;
    // Convert weight into kilograms
    if (catWeightUnit) {
      if (catWeightUnit === "kg") {
        catWeight = catWeight;
      } else if (catWeightUnit === "oz") {
        catWeight = catWeight / 35.274;
      } else if (catWeightUnit === "lbs") {
        catWeight = catWeight / 2.2046;
      }
    }

    let energyFactor = 0;

    if (catCondition) {
      switch (catCondition) {
        case "Neutered adult":
          energyFactor = 1.6;
          break;
        case "Non-neutered adult":
          energyFactor = 1.8;
          break;
        case "Weight loss":
          energyFactor = 1;
          break;
        case "Weight gain":
          energyFactor = 1.7;
          break;
        case "0-4 months old kitten":
          energyFactor = 3;
          break;
        case "4 months to adult cat":
          energyFactor = 2;
          break;
      }
    }
    if (!isNaN(catWeight)) {
      const weightInKg = catWeight;
      const restingCalories = Math.pow(weightInKg, 0.75) * 70;
      const totalMaintenanceCalories = restingCalories * energyFactor;
      return {
        tech_resting_energy: restingCalories,
        tech_maintenance_energy: totalMaintenanceCalories,
      };
    } else {
      return {
        error_message: "Please! Check your input.",
        result_code: 0,
      };
    }
  }

  /**
   * getCalculationPuppyWeigthCalculator: Service Method
   * POST: /api/calculators-lol/puppy-weight-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPuppyWeigthCalculator(body) {
    const {
      dogWeight,
      weightChoice,
      dogAge,
      ageChoice,
      dogType,
      breedSelection,
    } = body;

    function get_value(breed) {
      let assign_one = "";
      let assign_two = "";

      if (breed == "Affenpinscher") {
        assign_one = "7-10 pounds";
        assign_two = "1";
      } else if (breed == "Afghan Hound") {
        assign_one = "50-60 pounds";
        assign_two = "1";
      } else if (breed == "Airedale Terrier") {
        assign_one = "50-70 pounds";
        assign_two = "1";
      } else if (breed == "Akita") {
        assign_one = "100-130 pounds";
        assign_two = "70-100 pounds";
      } else if (breed == "Alaskan Malamute") {
        assign_one = "85 pounds";
        assign_two = "75 pounds";
      } else if (breed == "American Cocker Spaniel") {
        assign_one = "45-65 pounds";
        assign_two = "1";
      } else if (breed == "American Eskimo Dog (toy)") {
        assign_one = "6-10 pounds";
        assign_two = "1";
      } else if (breed == "American Esmiko Dog (miniature)") {
        assign_one = "10-20 pounds";
        assign_two = "1";
      } else if (breed == "American Esmiko Dog") {
        assign_one = "25-35 pounds";
        assign_two = "1";
      } else if (breed == "American Foxhound") {
        assign_one = "65-70 pounds";
        assign_two = "60-65 pounds";
      } else if (breed == "American Hairless Terrier") {
        assign_one = "12-16 pounds";
        assign_two = "1";
      } else if (breed == "American Staffordshire Terrier") {
        assign_one = "50-70 pounds";
        assign_two = "40-55";
      } else if (breed == "Anatolian Shepherd Dog") {
        assign_one = "110-150 pounds";
        assign_two = "80-120 pounds";
      } else if (breed == "Australian Cattle Dog") {
        assign_one = "35-50 pounds";
        assign_two = "1";
      } else if (breed == "Australian Shepherd") {
        assign_one = "50-65 pounds";
        assign_two = "40-55 pounds";
      } else if (breed == "Basenji") {
        assign_one = "24 pounds";
        assign_two = "22 pounds";
      } else if (breed == "Basset Hound") {
        assign_one = "40-65 pounds";
        assign_two = "1";
      } else if (breed == "Beagle") {
        assign_one = "20-30 pounds";
        assign_two = "1";
      } else if (breed == "Bearded Collie") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Beauceron") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Belgian Shepherd") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Bedlington Terrier") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Belgian Shepherd Malinois") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Bernese Mountain Dog") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Bichon Frise") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Black and Tan Coonhound") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Black Russian Terrier") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Bloodhound") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Bluetick Coonhound") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Border Collie") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Border Terrier") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Borzoi") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Boston Terrier") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Briard") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Bouvier des Flandres") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Boxer") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Boykin Spaniel") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Brittany") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Bull Terrier") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Bulldog") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Bullmastiff") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Cairn Terrier") {
        assign_one = "14 pounds";
        assign_two = "13 pounds";
      } else if (breed == "Canaan Dog") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Cane Corso") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Cavalier King Charles Spaniel") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Cesky Terrier") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Chesapeake Bay Retriever") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Chihuahua") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Chinese Crested Dog") {
        assign_one = "8-12 pounds";
        assign_two = "1";
      } else if (breed == "Chinese Shar-Pei") {
        assign_one = "45-60 pounds";
        assign_two = "1";
      } else if (breed == "Chinook") {
        assign_one = "55-90 pounds";
        assign_two = "50-65";
      } else if (breed == "Chow Chow") {
        assign_one = "45-70 pounds";
        assign_two = "1";
      } else if (breed == "Collie") {
        assign_one = "60-75 pounds";
        assign_two = "50-65 pounds";
      } else if (breed == "Coton de Tulear") {
        assign_one = "9-15 pounds";
        assign_two = "8-13 pounds";
      } else if (breed == "Dachshund (miniature)") {
        assign_one = "up to 11 pounds";
        assign_two = "1";
      } else if (breed == "Dachshund") {
        assign_one = "16-32 pounds";
        assign_two = "1";
      } else if (breed == "Dalmatian") {
        assign_one = "45-70 pounds";
        assign_two = "1";
      } else if (breed == "Dandie Dinmont Terrier") {
        assign_one = "18-24 pounds";
        assign_two = "1";
      } else if (breed == "Doberman Pinscher") {
        assign_one = "16-32 pounds";
        assign_two = "1";
      } else if (breed == "Dogue de Bordeaux") {
        assign_one = "75-100 pounds";
        assign_two = "60-90";
      } else if (breed == "English Foxhound") {
        assign_one = "60-75 pounds";
        assign_two = "1";
      } else if (breed == "English Toy Spaniel") {
        assign_one = "8-14 pounds";
        assign_two = "1";
      } else if (breed == "Entlebucher Mountain Dog") {
        assign_one = "55-65 pounds";
        assign_two = "1";
      } else if (breed == "Finnish Lapphund") {
        assign_one = "33-53 pounds";
        assign_two = "1";
      } else if (breed == "Finnish Spitz") {
        assign_one = "25-33 pounds";
        assign_two = "20-28";
      } else if (breed == "French Bulldog") {
        assign_one = "under 28 pounds";
        assign_two = "1";
      } else if (breed == "German Pinscher") {
        assign_one = "25-45 pounds";
        assign_two = "1";
      } else if (breed == "German Shepherd Dog") {
        assign_one = "65-90 pounds";
        assign_two = "50-70 pounds";
      } else if (breed == "Giant Schnauzer") {
        assign_one = "60-85 pounds";
        assign_two = "55-75 pounds";
      } else if (breed == "Glen of Imaal Terrier") {
        assign_one = "32-40 pounds";
        assign_two = "1";
      } else if (breed == "Great Dane") {
        assign_one = "140-175 pounds";
        assign_two = "110-140 pounds";
      } else if (breed == "Great Pyrenee") {
        assign_one = "100 pounds or more";
        assign_two = "85 pounds or more";
      } else if (breed == "Greater Swiss Mountain Dog") {
        assign_one = "115-140 pounds";
        assign_two = "85-110 pounds";
      } else if (breed == "Greyhound") {
        assign_one = "65-70 pounds";
        assign_two = "60-65 pounds";
      } else if (breed == "Harrier") {
        assign_one = "45-60 pounds";
        assign_two = "1";
      } else if (breed == "Havanese") {
        assign_one = "7-13 pounds";
        assign_two = "1";
      } else if (breed == "Ibizan Hound") {
        assign_one = "50 pounds";
        assign_two = "45 pounds";
      } else if (breed == "Icelandic Sheepdog") {
        assign_one = "30 pounds";
        assign_two = "25 pounds";
      } else if (breed == "Irish Terrier") {
        assign_one = "27 pounds";
        assign_two = "25 pounds";
      } else if (breed == "Irish Wolfhound") {
        assign_one = "120 pounds";
        assign_two = "105 pounds";
      } else if (breed == "Italian Greyhound") {
        assign_one = "7-14 pounds";
        assign_two = "1";
      } else if (breed == "Japanese Chin") {
        assign_one = "7-11 pounds";
        assign_two = "1";
      } else if (breed == "Keeshonden") {
        assign_one = "34-45 pounds";
        assign_two = "1";
      } else if (breed == "Kerry Blue Terrier") {
        assign_one = "33-40 pounds";
        assign_two = "30-37 pounds";
      } else if (breed == "Komondorok") {
        assign_one = "100 pounds or more";
        assign_two = "30-37 pounds";
      } else if (breed == "Kuvaszok") {
        assign_one = "100-115 pounds";
        assign_two = "70-90 pounds";
      } else if (breed == "Lagottto Romagnoli") {
        assign_one = "28.5-35 pounds";
        assign_two = "24-31 pounds";
      } else if (breed == "Lakeland Terrier") {
        assign_one = "17 pounds";
        assign_two = "16 pounds";
      } else if (breed == "Leonberger") {
        assign_one = "110-170 pounds";
        assign_two = "90-140 pounds";
      } else if (breed == "Lhasa Apso") {
        assign_one = "12-18 pounds";
        assign_two = "1";
      } else if (breed == "Lowchen") {
        assign_one = "15 pounds";
        assign_two = "1";
      } else if (breed == "Maltese") {
        assign_one = "under 7 pounds";
        assign_two = "1";
      } else if (breed == "Manchester Terrier (Toy)") {
        assign_one = "under 7 pounds";
        assign_two = "1";
      } else if (breed == "Manchester Terrier") {
        assign_one = "12-22 pounds";
        assign_two = "1";
      } else if (breed == "Mastiff") {
        assign_one = "160-230 pounds";
        assign_two = "120-170 pounds";
      } else if (breed == "Miniature Pinscher") {
        assign_one = "8-10 pounds";
        assign_two = "1";
      } else if (breed == "Miniature Bull Terrier") {
        assign_one = "18-28 pounds";
        assign_two = "1";
      } else if (breed == "Miniature Schnauzer") {
        assign_one = "11-20 pounds";
        assign_two = "1";
      } else if (breed == "Neapolitan Mastiff") {
        assign_one = "150 pounds";
        assign_two = "110 pounds";
      } else if (breed == "Newfoundland") {
        assign_one = "130-150 pounds";
        assign_two = "100-120 pounds";
      } else if (breed == "Norfolk Terrier") {
        assign_one = "11-12 pounds";
        assign_two = "1";
      } else if (breed == "Norwegian Buhund") {
        assign_one = "31-40 pounds";
        assign_two = "26-35 pounds";
      } else if (breed == "Norwegian Elkhound") {
        assign_one = "55 pounds";
        assign_two = "48 pounds";
      } else if (breed == "Norwegian Lundehund") {
        assign_one = "20-30 pounds";
        assign_two = "1";
      } else if (breed == "Norwich Terrier") {
        assign_one = "12 pounds";
        assign_two = "1";
      } else if (breed == "Old English Sheepdog") {
        assign_one = "60-100 pounds";
        assign_two = "1";
      } else if (breed == "Otterhound") {
        assign_one = "115 pounds";
        assign_two = "80 pounds";
      } else if (breed == "Papillon") {
        assign_one = "5-10 pounds";
        assign_two = "1";
      } else if (breed == "Parson Russell Terrier") {
        assign_one = "13-17 pounds";
        assign_two = "1";
      } else if (breed == "Pekingese") {
        assign_one = "up to 14 pounds";
        assign_two = "1";
      } else if (breed == "Pembroke Welsh Corgi") {
        assign_one = "up to 30 pounds";
        assign_two = "up to 28 pounds";
      } else if (breed == "Petit Basset Griffon Vendeen") {
        assign_one = "25-40 pounds";
        assign_two = "1";
      } else if (breed == "Pharaoh Hound") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Plott") {
        assign_one = "50-60 pounds";
        assign_two = "40-55 pounds";
      } else if (breed == "Polish Lowland Sheepdog") {
        assign_one = "30-50 pounds";
        assign_two = "1";
      } else if (breed == "Pomeranian") {
        assign_one = "3-7 pounds";
        $assign_two = "1";
      } else if (breed == "Poodle") {
        assign_one = "60-70 pounds";
        $assign_two = "40-50";
      } else if (breed == "Portuguese Water Dog") {
        assign_one = "60-70 pounds";
        $assign_two = "40-50";
      } else if (breed == "Pug") {
        assign_one = "42-60 pounds";
        $assign_two = "35-50 pounds";
      } else if (breed == "Pulik") {
        assign_one = "25-35 pounds";
        assign_two = "1";
      } else if (breed == "Redbone Coonhound") {
        assign_one = "25-35 pounds";
        assign_two = "1";
      } else if (breed == "Retreiver (Chesapeake Bay)") {
        assign_one = "65-80 pounds";
        assign_two = "55-70 pounds";
      } else if (breed == "Retreiver (Curly Coated)") {
        assign_one = "60-95 pounds";
        assign_two = "1 pounds";
      } else if (breed == "Retreiver (Flat Coated)") {
        assign_one = "60-70 pounds";
        assign_two = "1";
      } else if (breed == "Retreiver (Golden)") {
        assign_one = "65-75 pounds";
        assign_two = "55-65 pounds";
      } else if (breed == "Retreiver (Labrador)") {
        assign_one = "65-80 pounds";
        assign_two = "55-70 pounds";
      } else if (breed == "Rhodesian Ridgeback") {
        assign_one = "85 pounds";
        assign_two = "70 pounds";
      } else if (breed == "Rottweiler") {
        assign_one = "95-135 pounds";
        assign_two = "80-100 pounds";
      } else if (breed == "Russel Terrier") {
        assign_one = "9-15 pounds";
        assign_two = "1";
      } else if (breed == "Saluki") {
        assign_one = "40-65 pounds";
        assign_two = "1";
      } else if (breed == "Samoyed") {
        assign_one = "45-65 pounds";
        assign_two = "35-50 pounds";
      } else if (breed == "Schipperke") {
        assign_one = "10-16 pounds";
        assign_two = "1";
      } else if (breed == "Scottish Deerhound") {
        assign_one = "85-110 pounds";
        assign_two = "75-95";
      } else if (breed == "Scottish Terrier") {
        assign_one = "19-22 pounds";
        assign_two = "18-21 pounds";
      } else if (breed == "Sealyham Terrier") {
        assign_one = "23-24 pounds";
        assign_two = "20-23 pounds";
      } else if (breed == "Setter (English)") {
        assign_one = "65-80 pounds";
        assign_two = "45-55 pounds";
      } else if (breed == "Setter (Gordon)") {
        assign_one = "55-80 pounds";
        assign_two = "45-70 pounds";
      } else if (breed == "Setter (Irish Red and White)") {
        assign_one = "42-60 pounds";
        assign_two = "35-50 pounds";
      } else if (breed == "Setter (Irish)") {
        assign_one = "70 pounds";
        assign_two = "60 pounds";
      } else if (breed == "Shedland Sheepdog") {
        assign_one = "15-25 pounds";
        assign_two = "1";
      } else if (breed == "Shiba Inu") {
        assign_one = "23 pounds";
        assign_two = "17 pounds";
      } else if (breed == "Shih Tzu") {
        assign_one = "9-16 pounds";
        assign_two = "1";
      } else if (breed == "Siberian Huskie") {
        assign_one = "45-60 pounds";
        assign_two = "35-50 pounds";
      } else if (breed == "Silky Terrier") {
        assign_one = "8-10 pounds";
        assign_two = "1";
      } else if (breed == "Syke Terrier") {
        assign_one = "35-45 pounds";
        assign_two = "30-40 pounds";
      } else if (breed == "Sloughi") {
        assign_one = "35-50 pounds";
        assign_two = "1";
      } else if (breed == "Soft Coated Wheaten Terrier") {
        assign_one = "35-50 pounds";
        assign_two = "1";
      } else if (breed == "Spaniel (American Water)") {
        assign_one = "35-40 pounds";
        assign_two = "30-35 pounds";
      } else if (breed == "Spaniel (Boykin)") {
        assign_one = "30-40 pounds";
        assign_two = "25-35 pounds";
      } else if (breed == "Spaniel (Clumber)") {
        assign_one = "70-85 pounds";
        assign_two = "55-70 pounds";
      } else if (breed == "Spaniel (English Cocker)") {
        assign_one = "28-34 pounds";
        assign_two = "26-32 pounds";
      } else if (breed == "Spaniel (English Springer)") {
        assign_one = "50 pounds";
        assign_two = "40 pounds";
      } else if (breed == "Spaniel (Field)") {
        assign_one = "35-50 pounds";
        assign_two = "1";
      } else if (breed == "Spaniel (Irish Water)") {
        assign_one = "55-68 pounds";
        assign_two = "45-58";
      } else if (breed == "Spaniel (Sussex)") {
        assign_one = "35-50 pounds";
        assign_two = "1";
      } else if (breed == "Spaniel (Welsh Springer)") {
        assign_one = "35-45 pounds";
        assign_two = "1";
      } else if (breed == "Spaniel Water Dog") {
        assign_one = "35-45 pounds";
        assign_two = "1";
      } else if (breed == "Spinoni Italiani") {
        assign_one = "40-49 pounds";
        assign_two = "31-40 pounds";
      } else if (breed == "St. Bernard") {
        assign_one = "140-180 pounds";
        assign_two = "120-140 pounds";
      } else if (breed == "Staffordshire Bull Terrier") {
        assign_one = "28-38 pounds";
        assign_two = "24-34 pounds";
      } else if (breed == "Spinoni Italiani") {
        assign_one = "55-60 pounds";
        assign_two = "1";
      } else if (breed == "Standard Schnauzer") {
        assign_one = "35-50 pounds";
        assign_two = "30-45 pounds";
      } else if (breed == "Swedish Vallhund") {
        assign_one = "20-35 pounds";
        assign_two = "1";
      } else if (breed == "Tibetan Mastiff") {
        assign_one = "90-150 pounds";
        assign_two = "70-120 pounds";
      } else if (breed == "Tibetan Terrier") {
        assign_one = "18-30 pounds";
        assign_two = "15-25 pounds";
      } else if (breed == "Tibetan Spaniel") {
        assign_one = "18-30 pounds";
        assign_two = "15-25 pounds";
      } else if (breed == "Toy Fox Terrier") {
        assign_one = "9-15 pounds";
        assign_two = "1";
      } else if (breed == "Treeing Walker Coonhound") {
        assign_one = "50-70 pounds";
        assign_two = "1";
      } else if (breed == "Vizsla") {
        assign_one = "55-60 pounds";
        assign_two = "44-55 pounds";
      } else if (breed == "Weimaraner") {
        assign_one = "70-90 pounds";
        assign_two = "55-75 pounds";
      } else if (breed == "Welsh Terrier") {
        assign_one = "20 pounds";
        assign_two = "18-20 pounds";
      } else if (breed == "West Highland White Terrier") {
        assign_one = "15-20 pounds";
        assign_two = "1";
      } else if (breed == "Whippet") {
        assign_one = "25-40 pounds";
        assign_two = "1";
      } else if (breed == "Wirehaired Pointing Griffon") {
        assign_one = "50-70 pounds";
        assign_two = "35-50 pounds";
      } else if (breed == "Wirehaired Vizsla") {
        assign_one = "55-65 pounds";
        assign_two = "1";
      } else if (breed == "Xoloitzcuintli") {
        assign_one = "30-55 pounds";
        assign_two = "1";
      } else if (breed == "Yorkshire Terrier") {
        assign_one = "7 pounds";
        assign_two = "1";
      }
      return [assign_one, assign_two];
    }

    const names = get_value(breedSelection);

    if (dogType === "first" || dogType === "second") {
      if (isNaN(dogWeight) || isNaN(dogAge)) {
        return { error: "Please! Check Your Input" };
      }

      let age_calculation;
      if (ageChoice === "wks") {
        if (dogAge > 52) {
          return {
            error: "Dogs above 12 months of age are considered adults!",
          };
        } else if (dogAge < 0) {
          return { error: "Age must be greater than zero" };
        } else {
          age_calculation = dogAge * 1;
        }
      } else if (ageChoice === "days") {
        if (dogAge > 365) {
          return {
            error: "Dogs above 12 months of age are considered adults!",
          };
        } else if (dogAge < 0) {
          return { error: "Age must be greater than zero" };
        } else {
          age_calculation = dogAge * 0.14286;
        }
      } else if (ageChoice === "mon") {
        if (dogAge > 13) {
          return {
            error: "Dogs above 12 months of age are considered adults!",
          };
        } else if (dogAge < 0) {
          return { error: "Age must be greater than zero" };
        } else {
          age_calculation = dogAge * 4.348;
        }
      }

      let convert;
      if (dogWeight > 0) {
        switch (weightChoice) {
          case "g":
            convert = dogWeight / 1000;
            break;
          case "dag":
            convert = dogWeight / 100;
            break;
          case "kg":
            convert = dogWeight;
            break;
          case "oz":
            convert = dogWeight / 35.274;
            break;
          case "lb":
            convert = dogWeight / 2.205;
            break;
          case "stone":
            convert = dogWeight * 6.35;
            break;
          default:
            return { error: "Invalid weight selection" };
        }
      } else {
        return { error: "Weight must be greater than zero" };
      }

      const calculation = (convert / age_calculation) * 52;
      const calculate2 = calculation / 10;
      const cal3 = calculation + calculate2;
      const cal4 = calculation - calculate2;

      if (calculation >= 156.5) {
        return {
          error:
            "The heaviest dog ever weighed exactly 345 lb (156.5 kg). Try not to exceed it!",
        };
      }

      let h1 = "",
        h2 = "",
        h3 = "",
        h4 = "",
        h5 = "";
      if (calculation < 5.4) {
        h1 = "bg-gradient text-white";
      } else if (calculation >= 5.4 && calculation <= 10) {
        h2 = "bg-gradient text-white";
      } else if (calculation > 10 && calculation <= 25.9) {
        h3 = "bg-gradient text-white";
      } else if (calculation > 25.9 && calculation <= 44.9) {
        h4 = "bg-gradient text-white";
      } else if (calculation >= 44.9) {
        h5 = "bg-gradient text-white";
      }

      const calculation2 = calculation;
      const calculation3 = calculation * 2.20462;

      return {
        tech_h1: h1,
        tech_h2: h2,
        tech_h3: h3,
        tech_h4: h4,
        tech_h5: h5,
        tech_puppy1: calculation2,
        tech_puppy2: calculation3,
        tech_cal3: cal3,
        tech_cal4: cal4,
        tech_type: dogType,
        tech_select_breed: breedSelection,
        tech_names_zero: names[0],
        tech_names_one: names[1],
      };
    }

    return { error: "Invalid type selection" };
  }

  /**
   * getCalculationPearsonAgeCalculator: Service Method
   * POST: /api/calculators-lol/pearson-age-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPearsonAgeCalculator(body) {
    const dob = body.tech_date1;
    const date = body.tech_date;

    if (!dob || !date) {
      return { error: "Please Select Your Date of Birth." };
    }

    const dobParts = dob.split("-");
    const dateParts = date.split("-");

    const bday = moment(
      `${dobParts[2]}.${dobParts[1]}.${dobParts[0]}`,
      "DD.MM.YYYY"
    );
    const today = moment(
      `${dateParts[2]}.${dateParts[1]}.${dateParts[0]}`,
      "DD.MM.YYYY"
    );
    const diff = moment.duration(today.diff(bday));

    const age_years = today.diff(bday, "years");
    bday.add(age_years, "years");
    const age_months = today.diff(bday, "months");
    bday.add(age_months, "months");
    const age_days = today.diff(bday, "days");

    const now = moment();
    const dobMoment = moment(dob, "YYYY-MM-DD");

    const d1 = dobMoment.unix();
    const d2 = now.unix();

    if (d2 - d1 <= 0) {
      return { error: "Invalid Date of Birth." };
    }

    const obj = new AgeCalculator();
    obj.calculateAge(d1 * 1000);
    const age = obj.getAge();
    const rank = obj.getRank(age);

    const Totalyears = Math.floor((d2 - d1) / 31536000);
    const Total_months = Math.floor((d2 - d1) / 2628000);
    const Total_weeks = Math.floor((d2 - d1) / 604800);
    const Total_days = Math.floor((d2 - d1) / 86400);
    const Total_hours = Math.floor((d2 - d1) / 3600);
    const Total_minuts = Math.floor((d2 - d1) / 60);
    const Total_seconds = d2 - d1;

    // ✅ Correct Next Birthday Calculation
    const birthDay = parseInt(dobParts[2], 10);
    const birthMonth = parseInt(dobParts[1], 10);

    let nextBirthdayYear = now.year();
    if (
      now.month() + 1 > birthMonth ||
      (now.month() + 1 === birthMonth && now.date() > birthDay)
    ) {
      nextBirthdayYear++;
    }

    const nextBirthday = moment(
      `${nextBirthdayYear}-${dobParts[1]}-${dobParts[2]}`,
      "YYYY-MM-DD"
    );
    const remaining = moment.duration(nextBirthday.diff(now));
    const N_r_months = Math.floor(remaining.asMonths());
    const N_r_days = nextBirthday.diff(
      now.clone().add(N_r_months, "months"),
      "days"
    );

    return {
      tech_Age: age,
      tech_Age_years: age_years,
      tech_Age_months: age_months,
      tech_Age_days: age_days,
      tech_birth_month: dobParts[1],
      tech_N_r_months: N_r_months,
      tech_N_r_days: N_r_days,
      tech_Years: Totalyears,
      tech_Months: Total_months,
      tech_Weeks: Total_weeks,
      tech_Days: Total_days,
      tech_Hours: Total_hours,
      tech_Min: Total_minuts,
      tech_Sec: Total_seconds,
    };
  }

  /**
   * getCalculationDogAgeCalculator: Service Method
   * POST: /api/calculators-lol/dog-age-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDogAgeCalculator(body) {
    const tech_operations = body.tech_operations;
    const tech_brd = body.tech_brd;
    const tech_size = body.tech_size;
    const tech_age = parseFloat(body.tech_age);
    const tech_dogAge = parseFloat(body.tech_dogAge);
    const tech_dogBreed = body.tech_dogBreed;
    const tech_a = parseFloat(body.tech_a);
    const tech_b = parseFloat(body.tech_b);
    const tech_c = parseFloat(body.tech_c);

    let param = {};

    if (tech_operations === "1") {
      if (tech_brd === "1") {
        if (tech_age > 0 && tech_age < 20) {
          const f_ans = 16 * Math.log(tech_age);
          var answer = f_ans + 31;
        } else {
          param.error = "Please enter age between 1 and 20.";
          return param;
        }
      } else if (tech_brd === "2") {
        const kuty = [
          [0, 0, 0],
          [15, 15, 15],
          [24, 24, 24],
          [28, 28, 28],
          [32, 32, 32],
          [36, 36, 36],
          [40, 42, 45],
          [44, 47, 50],
          [48, 51, 55],
          [52, 56, 61],
          [56, 60, 66],
          [60, 65, 72],
          [64, 69, 77],
          [68, 74, 82],
          [72, 78, 88],
          [76, 83, 93],
          [80, 87, 120],
          [84, 92, 120],
          [88, 96, 120],
          [92, 101, 120],
        ];

        if (tech_age > 0 && tech_age < 20) {
          const parts = tech_age.toString().split(".");
          const index = parseInt(parts[0]);

          const calculateAge = (idx) => {
            const dogi_age1 = kuty[idx];
            const dogi_age2 = kuty[idx + 1];
            const show_baz1 = dogi_age1[tech_size - 1];
            const show_baz2 = dogi_age2[tech_size - 1];
            const percent = parseFloat("0." + parts[1]) * 100;
            const diff = show_baz2 - show_baz1;
            return show_baz1 + (diff / 100) * percent;
          };

          if (parts.length === 1) {
            answer = kuty[index][tech_size - 1];
          } else {
            answer = calculateAge(index);
          }
        } else {
          param.error = "Please enter age between 1 and 20.";
          return param;
        }
      }

      if (answer) {
        param.tech_answer = Number(answer).toFixed(answer % 1 === 0 ? 0 : 3);
      }
    } else if (tech_operations === "2") {
      if (!tech_dogAge || tech_dogAge <= 0) {
        param.error = "Please select Dog Age.";
        return param;
      }

      if (!tech_dogBreed || tech_dogBreed === "0") {
        param.error = "Please select Dog Breed.";
        return param;
      }

      if (!(tech_a >= 1)) {
        param.error = "Please enter First Year Aging greater than 0.";
        return param;
      }

      if (!(tech_b >= 1)) {
        param.error = "Please enter Second Year Aging greater than 0.";
        return param;
      }

      if (!(tech_c >= 1)) {
        param.error = "Please enter Human Life Expectancy greater than 0.";
        return param;
      }

      const [dogBreed1, dogBreed2] = tech_dogBreed.split("&&");
      const breeds = [
        [
          "Affenpinscher",
          12,
          14,
          "affenpinscher",
          "Small rodent hunting",
          "Families",
          "Moderate",
          "12-14 years",
          "25-27 cm",
          "3-4 kg",
          "Curious, Playful, Active",
          "Yes",
          "Black, gray, silver, Black and Tan",
        ],
        [
          "Afghan Hound",
          12,
          14,
          "afghan_hound",
          "Coursing and hunting",
          "Singles & Families",
          "High",
          "12-14 years",
          "63-68 cm",
          "25-29 kg",
          "Aloof, Happy, Independent",
          "Yes",
          "Black, Red, Cream",
        ],
        [
          "Airedale Terrier",
          10,
          12,
          "airedale_terrier",
          "Terrier Dogs",
          "Small Families",
          "High",
          "10-14 years",
          "58-61 cm",
          "23-29 kg",
          "Active, Intelligent, Loyal, Hard-Working, Athletic, Confident, Proud",
          "No",
          "Black, Grey, White, Tan",
        ],
        [
          "Akita",
          11,
          15,
          "akita",
          "Working Dogs",
          "Small Families, singles",
          "High",
          "11-15 years",
          "61-70 cm",
          "38-54 kg",
          "Active, loyal, willful, bold, courageous, intelligent, alert",
          "No",
          "Red, brindle, black, black brindle, blue brindle, brown, brown brindle, fawn, fawn brindle",
        ],
        [
          "Alaskan Malamute",
          13,
          16,
          "alaskan_malamute",
          "Working Dogs",
          "Families",
          "Medium",
          "12-16 years",
          "58-63 cm",
          "36-43 kg",
          "Intelligent, Active, Affectionate, Gentle, Independent",
          "No",
          "Black, white",
        ],
        [
          "American Cocker Spaniel",
          12,
          15,
          "american_cocker_spaniel",
          "Sporting Group",
          "Families, children",
          "Medium",
          "12-15 years",
          "37-39 cm",
          "11-14 kg",
          "Merry, Outgoing, Joyful, Trusing",
          "No",
          "Black, Red, Brown, Silver and Tan",
        ],
        [
          "American Eskimo Dog",
          13,
          15,
          "american_eskimo",
          "Circus performer",
          "Families & Friends",
          "High",
          "13-15 years",
          "38-48 cm",
          "8.2-16 kg",
          "Intelligent, Protective, Reserved, Alert",
          "No",
          "White, Biscuit",
        ],
        [
          "American Foxhound",
          10,
          12,
          "american_foxhound",
          "Hound Group",
          "Families",
          "Low",
          "10-12 years",
          "56-64 cm",
          "29-34 kg",
          "Kind, Loyal, Loving, Independent",
          "No",
          "White, White & cream, Red, Tri-color",
        ],
        [
          "American Staffordshire Terrier",
          10,
          12,
          "american_staffordshire_terrier",
          "Terrier Group",
          "Families and children",
          "Low",
          "12-16 years",
          "46-48 cm",
          "23-32 kg",
          "Attentive, Devoted, Courageous, Loyal",
          "No",
          "Sable, Black, Blue, Brown",
        ],
        [
          "American Water Spaniel",
          13,
          15,
          "default",
          "Bird flushing and retrieving",
          "Waterfowl hunters",
          "Low",
          "13-15 years",
          "38-46 cm",
          "14-20 kg",
          "Energetic, Intelligent, Protective",
          "No",
          "Solid liver, brown, dark chocolate",
        ],
        [
          "Anatolian Shepherd Dog",
          13,
          15,
          "default",
          "Working Group",
          "Families and Small children",
          "Low",
          "10-13 years",
          "74-81 cm",
          "41-68 kg",
          "Steady, Bold, Confident, Proud",
          "No",
          "Blue Fawn, Red Fawn, White, Brindle",
        ],
        [
          "Australian Cattle Dog",
          13,
          15,
          "australian_cattle_dog",
          "Herding Dogs",
          "Families with older children",
          "High",
          "12-15 years",
          "43-51 cm",
          "18-22 kg",
          "Loyal, Active",
          "No",
          "Red, Black, Chocolate, Blue, Grey",
        ],
        [
          "Australian Shepherd",
          13,
          15,
          "australian_shepherd",
          "Herding Dogs",
          "Families",
          "Medium",
          "13-15 years",
          "50 – 58 cm",
          "20 to 29kg",
          "Affectionate, Intelligent, Protective, Good-natured, Active",
          "No",
          "Red merles,Black Tricolor",
        ],
        [
          "Australian Silky Terrier",
          12,
          15,
          "australian_silky_terrier",
          "Terrier Group",
          "Person who wants adventure on a small scale",
          "Moderate Maintenance",
          "14 – 16 years",
          "23 – 26cm",
          "3 – 5kg",
          "Active, Lively, Stubborn, Mischievous",
          "Yes",
          "Black, Black and Tan, Blue, Blue and Tan, Blue Silver and tan, Cream, Grey, Fawn, Grey and Tan, Silver black and Tan, Silver and Platinum",
        ],
        [
          "Australian Terrier",
          12,
          15,
          "australian_terrier",
          "Terrier Dogs",
          "Singles, families",
          "Medium",
          "Up to 15 years",
          "23 – 28 cm",
          "5.5 to 7 kg",
          "Alert, Loyal, Spirited",
          "Yes",
          "Blue & Tan, Red, Sand",
        ],
        [
          "Basenji",
          12,
          16,
          "basenji",
          "Hound Dogs",
          "Couples and singles",
          "Low",
          "10-12 years",
          "Up to 45cm",
          "12 kg",
          "Alert, Playful, Energetic, Quiet",
          "Yes",
          "Black, Sand, Red, Tan",
        ],
        [
          "Basset Hound",
          10,
          12,
          "basset_hound",
          "Hound Dogs",
          "Families, singles",
          "Medium",
          "11-12 years",
          "30-38 cm",
          "18-27 kg",
          "Intelligent, independent, social, sharp-tempered, excited",
          "No",
          "Black, white, brown, red",
        ],
        [
          "Beagle",
          12,
          15,
          "beagle",
          "Hound Dogs",
          "Families",
          "Medium",
          "12-15 years",
          "33-41 cm",
          "8-14 kg",
          "Loyal, Gentle",
          "Yes",
          "White/brown",
        ],
        [
          "Bearded Collie",
          14,
          15,
          "bearded_collie",
          "Working Dog",
          "Families",
          "High Maintenance",
          "12 – 14 years",
          "50 – 56 cm",
          "20 – 25 kg",
          "Self-confidence, Hardy, Lively, Alert, Intelligent, Active",
          "No",
          "Black, Blue, Brown, Fawn",
        ],
        [
          "Beauceron",
          10,
          12,
          "default",
          "Boar herding, hunting, guarding",
          "Families and strangers",
          "Low",
          "10-12 years",
          "63-66 cm",
          "32-45 kg",
          "Calm, Protective, Fearless",
          "No",
          "Harlequin, Black with tan. Black, black and white",
        ],
        [
          "Belgian Shepherd",
          10,
          14,
          "belgian_shepherd",
          "Herding Group",
          "Families",
          "High",
          "10-14 years",
          "61-66 cm",
          "25-30 kg",
          "Powerful, Intelligent, Affectionate",
          "No",
          "Fawn or grey with black overlay and a black mask",
        ],
        [
          "Bedlington Terrier",
          12,
          14,
          "bedlington_terrier",
          "Killing rat, badger, other vermin",
          "Families",
          "High",
          " 12-14 years",
          "41-44 cm",
          "7.7-10 kg",
          "Loyal, energetic, friendly, headstrong",
          "Yes",
          "Sandy, Sandy & Tan, liver",
        ],
        [
          "Belgian Shepherd Malinois",
          12,
          14,
          "default",
          "Herding Group",
          "Families and Strangers",
          "High",
          "10-14 years",
          "61-66 cm",
          "25-30 kg",
          "Watchful, Hard-Working, Confident, Active",
          "No",
          "Mathogany, Tan, Black-tipped Fawn",
        ],
        [
          "Bernese Mountain Dog",
          7,
          8,
          "bernese_mountain_dog",
          "Working Dogs",
          "Families, singles",
          "Medium",
          "6-8 years",
          "61-70 cm",
          "45-53 kg",
          "Friendly, Easy-going, loving, alert, affectionate",
          "No",
          "Black, white",
        ],
        [
          "Bichon Frise",
          12,
          15,
          "bichon_frise",
          "Companion Dogs",
          "Singles, small families",
          "High",
          "12 to 15 years",
          "23 – 30 cm",
          "3 – 6 kg",
          "Playful, Gentle, Cheerful, Sensitive",
          "Yes",
          "White, White & Apricot, White & Buff",
        ],
        [
          "Black and Tan Coonhound",
          10,
          12,
          "default",
          "Hunting raccoons, night hunting",
          "Families and friendly",
          "Low",
          "10 – 12 years",
          "64–69 cm",
          "29 – 34 kg",
          "Even Tempered, Adaptable, Trusting, Easygoing",
          "No",
          "Black and tan",
        ],
        [
          "Black Russian Terrier",
          10,
          11,
          "black_russian_terrier",
          "Working Group",
          "Families and Singles",
          "Low",
          "10-11 years",
          "66-72 cm",
          "50-60 kg",
          "Stable, Confident, Energetic, Brave",
          "No",
          "Black, Salt & Pepper",
        ],
        [
          "Bloodhound",
          10,
          12,
          "bloodhound",
          "Trailing",
          "Children",
          "High",
          "10-12 years",
          "64-69 cm",
          "33-50 kg",
          "Stubborn, Affectionate, Even Tempered",
          "No",
          "Black and Tan, Liver and Tan, Red",
        ],
        [
          "Bluetick Coonhound",
          11,
          12,
          "default",
          "Hound",
          "Children",
          "Low",
          "11-12 years",
          "56-69 cm",
          "25-36 kg",
          "Intelligent, Active, Friendly",
          "No",
          "Bluetick",
        ],
        [
          "Border Collie",
          13,
          16,
          "border_collie",
          "Herding Dogs",
          "Families",
          "Medium-High",
          "13-16 years",
          "48-56 cm",
          "17-20 kg",
          "Intelligent, Obedient, Active",
          "No",
          "Red, Black, Chocolate, White, Merle",
        ],
        [
          "Border Terrier",
          12,
          15,
          "border_terrier",
          "Terrier Dogs",
          "Families, excellent with young kids",
          "Medium",
          "12-15 years",
          "33 – 41 cm",
          "5 -7 kg",
          "Intelligent, Alert, Fearless, Obedient",
          "Yes",
          "Blue & Tan, Red, Wheaten",
        ],
        [
          "Borzoi",
          7,
          10,
          "borzoi",
          "Hound Group",
          "Families",
          "Moderate",
          "7-10 years",
          "81-86 cm",
          "34-47 kg",
          "Quiet, Intelligent, Athletic, Respectful",
          "No",
          "Any color permissible",
        ],
        [
          "Boston Terrier",
          13,
          15,
          "boston_terrier",
          "Companion Dogs",
          "Families",
          "Medium-Low",
          "13-15 years",
          "40 – 45 cm",
          "6 to 11 kg",
          "Friendly, Intelligent, Lively",
          "No",
          "Seal & White, Black & White",
        ],
        [
          "Briard",
          10,
          12,
          "briard",
          "Herding, guarding sheep",
          "Families and Children",
          "High",
          "10-12 years",
          "58-69 cm",
          "27-41 kg",
          "Faithful, Intelligent, Obedient",
          "No",
          "Tawny, Grey, Black & grey",
        ],
        [
          "Bouvier des Flandres",
          10,
          12,
          "default",
          "Cattle herding",
          "Families",
          "High",
          "10-12 years",
          "62-68 cm",
          "35-40 kg",
          "Rational, Familial, Protective",
          "Yes",
          "Fawn, Black, Gray, Brindle",
        ],
        [
          "Boxer",
          10,
          12,
          "boxer",
          "Working Dogs",
          "Families",
          "Medium",
          "10-12 years",
          "53-60 cm",
          "30-32 kg",
          "Affectionate, active, watchful, alert, self-assured",
          "No",
          "Brown, red, white, black",
        ],
        [
          "Boykin Spaniel",
          14,
          16,
          "default",
          "Miscellaneous Class",
          "Families and hunters",
          "Moderate",
          "14-16 years",
          "39-46 cm",
          "14-18 kg",
          "Eager, Trainable, Companionable",
          "No",
          "Liver, Brown, Chocolate",
        ],
        [
          "Brittany",
          14,
          15,
          "brittany_spaniel",
          "Sporting Group",
          "Families",
          "Moderate",
          "12-15 years",
          "47-52 cm",
          "16-19 kg",
          "Attentive, Agile, Quick",
          "No",
          "Tri-color, Orange & White, Liver & White",
        ],
        [
          "Bull Terrier",
          11,
          14,
          "bull_terrier",
          "Terrier Dogs",
          "Families with older children",
          "Medium",
          "10-14 years",
          "51-60 cm",
          "20-33 kg",
          "Affectionate, active, loyal, stubborn",
          "No",
          "Brown, white, black, red",
        ],
        [
          "Bulldog",
          8,
          12,
          "default",
          "Non-Sporting Group",
          "Families and Children",
          "Low",
          "8-10 years",
          "31-40 cm",
          "18-23 kg",
          "Docile, Willful, Friendly",
          "No",
          "Piebald, White, Fawn and White",
        ],
        [
          "Bullmastiff",
          8,
          10,
          "bullmastiff",
          "Working Dogs",
          "Families with older children",
          "Medium",
          "8-10 years",
          "63-69 cm",
          "50-60 kg",
          "Loyal, stubborn, fearless, confident, independent",
          "Yes",
          "Fawn, brindle with markings on head",
        ],
        [
          "Cairn Terrier",
          12,
          15,
          "cairn_terrier",
          "Terrier Dogs",
          "Families",
          "Low – medium",
          "13-14 years",
          "25 to 33 cm",
          "6 to 8 kg",
          "Active, Hardy, Fearless, Gay, Intelligent",
          "Yes",
          "Black, Grey, Wheaten, Red",
        ],
        [
          "Canaan Dog",
          12,
          15,
          "canaan_dog",
          "Herding Group",
          "Children",
          "Low",
          "12-15 years",
          "51-61 cm",
          "18-25 kg",
          "Quick, Devoted, Alert, Intelligent",
          "No",
          "Black, Tan, Golden, Liver",
        ],
        [
          "Cane Corso",
          10,
          11,
          "cane_corso",
          "Working Dogs",
          "Families with young children",
          "High",
          "10-11 years",
          "64-68 cm",
          "45-50 kg",
          "Loyal, independent, Well-rounded, agile, energetic",
          "No",
          "black, grey and black, brindle",
        ],
        [
          "Cavalier King Charles Spaniel",
          9,
          14,
          "cavalier_king_charles_spaniel",
          "Companion Dogs",
          "Families",
          "Low – medium",
          "9-14 years",
          "30 to 33 cm",
          "5 to 8 kgs",
          "Playful, Gentle, Fearless, Patient, Adaptable",
          "No",
          "Black & Tan, Ruby, Tri-color",
        ],
        [
          "Cesky Terrier",
          12,
          15,
          "default",
          "Miscellaneous Class",
          "Families & Children",
          "High",
          "12-15 years",
          "10 to 13 in",
          "5.9 – 10 kg",
          "Cheerful, Calm, Reserved, Quiet",
          "Yes",
          "Grey blue, Light Cofee brown",
        ],
        [
          "Chesapeake Bay Retriever",
          10,
          12,
          "default",
          "Sporting Group",
          "Families and Children",
          "Moderate",
          "10-12 years",
          "58-66 cm",
          "29-36 kg",
          "Dominant, Happy, Affectionate, Quiet",
          "No",
          "Light Brown, Dark Brown, Deadgrass, Tan, Sedge",
        ],
        [
          "Chihuahua",
          10,
          18,
          "chihuahua",
          "Companion Dogs",
          "Singles, families with older Kids",
          "Medium",
          "10-18 years",
          "15 – 23 cm",
          "1.5 – 3 kg",
          "Devoted, Lively, Quick, Alert",
          "No",
          "Black, White, Fawn, Cream, Gold",
        ],
        [
          "Chinese Crested Dog",
          13,
          15,
          "chinese_crested_dog",
          "Toy dog",
          "Children",
          "High",
          "13-15 years",
          "28-33 cm",
          "3.2-5.4 kg",
          "Sweet-Tempered, Lively, Happy, Playful",
          "Yes",
          "Tri-color, Chocolate, Apricot",
        ],
        [
          "Chow Chow",
          9,
          12,
          "chow_chow",
          "Working Dogs",
          "Singles, small families",
          "Medium",
          "9-12 years",
          "43-50 cm",
          "25-32 kg",
          "Loyal, protective, reserved, aloof, dignified, stubborn, intelligent",
          "No",
          "black, blue, red faun, white coats",
        ],
        [
          "Clumber Spaniel",
          10,
          12,
          "default",
          "Sporting Group",
          "Families",
          "Moderate",
          "10-12 years",
          "46-51 cm",
          "25-39 kg",
          "Dignified, Great-hearted, Affectionate",
          "No",
          "White, Lemon & White",
        ],
        [
          "Curly Coated Retriever",
          9,
          14,
          "default",
          "Sporting Group",
          "Families, Children",
          "High",
          "9-14 years",
          "64-69 cm",
          "32-41 kg",
          "Clever, Intelligent, Sensitive, Trainable",
          "No",
          "Black, Liver",
        ],
        [
          "Dachshund",
          14,
          17,
          "dachshund",
          "Hound Dogs",
          "Singles, families",
          "Medium",
          "14-16 years",
          "20 – 27 cm",
          "4 – 5 kg",
          "Clever, Devoted, Active, Playful",
          "No",
          "Black, Black & Tan, Blue & Tan, Chocolate & Tan",
        ],
        [
          "Dalmatian",
          10,
          13,
          "dalmatian",
          "Companion Dogs",
          "Families with older children, Singles",
          "Medium-high",
          "10-13 years",
          "50-55 cm",
          "23-25 kg",
          "Energetic, Playful, Loyal",
          "Yes",
          "White with black spotted coat, brindle, mosaic, orange/lemon",
        ],
        [
          "Dandie Dinmont Terrier",
          12,
          15,
          "dandie_dinmont_terrier",
          "Terrier Group",
          "Children",
          "Moderate",
          "12-15 years",
          "8-11 ins",
          "8.2-11 kg",
          "Fun-loving, Determined, Independent, Lively",
          "Yes",
          "Pepper, Mustard",
        ],
        [
          "Doberman Pinscher",
          10,
          11,
          "doberman_pinscher",
          "Working Dogs",
          "Families",
          "Low",
          "10 – 13 years",
          "60 – 70 cm",
          "35 – 42kg",
          "Intelligent, Obedient, Fearless, Alert, Energetic, Loyal, Confident",
          "No",
          "White, Fawn, Black, Blue, Red, Black & Rust, Fawn",
        ],
        [
          "Dogue de Bordeaux",
          10,
          12,
          "default",
          "Working Dogs",
          "Families",
          "Medium",
          "10-12 years",
          "65-70 cm",
          "60-68 kg",
          "Intelligent, loyal, Sensitive, Active",
          "No",
          "Dark red, Fawn, mahogany, golden fawn",
        ],
        [
          "English Bulldog",
          8,
          12,
          "english_bulldog",
          "Companion Dogs",
          "Families",
          "Medium",
          "8 to 12 years",
          "31 – 40cm",
          "0–25 kg",
          "Gentle, affectionate, stubborn , Friendly. Docile. Devoted.",
          "No",
          "White, Fawn, Piebald, Brindle & White, Fawn & White, Red, Red Brindle, Red & White",
        ],
        [
          "English Cocker Spaniel",
          12,
          15,
          "english_cocker_spaniel",
          "Sporting Group",
          "Families",
          "High",
          "12-15 years",
          "38-43 cm",
          "13-14 kg",
          "Affectionate, Friendly, Quiet, Faithful",
          "No",
          "Orange Roan, Liver Roan, Blue Roan, Black",
        ],
        [
          "English Coonhound",
          11,
          12,
          "default",
          "Scenthound",
          "Families",
          "Low",
          "11-12 years",
          "56-69 cm",
          "18-30 kg",
          "High-Strung, Loyal, Energetic, Intelligent",
          "No",
          "Redtick, Red & White, Bluetick, Tricolor Ticked",
        ],
        [
          "English Foxhound",
          10,
          13,
          "default",
          "Hound Group",
          "Hunters and Families",
          "Low",
          "10-13 years",
          "56-63 cm",
          "29-34 kg",
          "Tolerant, Sociable, Gentle, Friendly",
          "No",
          "Tricolor, Lemon & White, White",
        ],
        [
          "English Mastiff",
          10,
          12,
          "english_mastiff",
          "Working Group",
          "Children",
          "Moderate",
          "6-12 years",
          "70-91 cm",
          "73-100 kg",
          "Good-natured, Dignified, Courageous, Calm",
          "No",
          "Fawn, Brindle, Apricot",
        ],
        [
          "English Setter",
          10,
          12,
          "english_setter",
          "Sporting Group",
          "Children",
          "High",
          "10-12 years",
          "25 to 27 in",
          "65 to 80 pounds",
          "Strong Willed, Eager, Hard-Working, Gentle",
          "No",
          "Blue Belton, Tricolor, Orange Belton, Liver Belton",
        ],
        [
          "English Springer Spaniel",
          12,
          14,
          "english_springer_spaniel",
          "Spaniel group",
          "Families",
          "Moderate",
          "12-14 years",
          "48-56 cm",
          "20-25 kg",
          "Affectionate, Attentive, Alert",
          "No",
          "Liver & White, Tricolor",
        ],
        [
          "Entlebucher Mountain Dog",
          11,
          15,
          "default",
          "Foundation Stock Service Program",
          "Children",
          "High",
          "11-15 years",
          "44-52 cm",
          "20-30 kg",
          "Self-confidence, Agile, Independent, Loyal",
          "No",
          "Tri-color",
        ],
        [
          "Field Spaniel",
          10,
          12,
          "default",
          "Sporting Group, Bird flushing, retrieving",
          "Families",
          "Moderate",
          "10-12 years",
          "17-18 in",
          "16-20 kg",
          "Adaptable, Sensitive, Sociable, Familial",
          "No",
          "Black, Blue Roan, Liver Roan, Liver",
        ],
        [
          "Finnish Lapphund",
          12,
          14,
          "default",
          "Foundation Stock Service Program",
          "Families",
          "Low",
          "12-14 years",
          "46-52 cm",
          "15-24 kg",
          "Keen, Courageous, Faithful, Calm",
          "No",
          "Black, White, Wolf-Sable, Sable, Brown",
        ],
        [
          "Finnish Spitz",
          12,
          14,
          "default",
          "Non-Sporting Group, Hunting birds, small mammals",
          "Families and Children",
          "Moderate",
          "12-14 years",
          "44-50 cm",
          "12-14 kg",
          "Vocal, Independent, Playful, Happy",
          "No",
          "Gold, Red Gold, Red",
        ],
        [
          "Flat-Coated Retriever",
          8,
          10,
          "default",
          "Sporting Group, Water retrieving",
          "Families",
          "Low",
          "8-14 years",
          "59-62 cm",
          "27-36 kg",
          "Outgoing, Optimistic, Confident, Friendly",
          "No",
          "Black, Liver",
        ],
        [
          "French Bulldog",
          10,
          12,
          "french_bulldog",
          "Companion Dogs",
          "Singles, families",
          "Medium",
          "10-15 years",
          "28-30 cm",
          "10 – 13kgs",
          "Playful, Lively, Affectionate, Bright, Keen, Athletic, Alert, Sociable, Patient, Easygoing",
          "No",
          "Brindle, Fawn, Pied",
        ],
        [
          "German Pinscher",
          12,
          14,
          "default",
          "Working Group",
          "Children",
          "High",
          "12-14 years",
          "25-30 cm",
          "11-20 kg",
          "Spirited, Intelligent, Even Tempered",
          "No",
          "Black, Brown, Red, Blue",
        ],
        [
          "German Shepherd",
          9,
          13,
          "german_shepherd",
          "Herding Dogs",
          "Families",
          "Medium",
          "12-14 years",
          "60-65 cm",
          "30-40 kg",
          "Intelligent, loyal, patient, active, aloof, reserved, protective",
          "No",
          "Mixture of gold and black",
        ],
        [
          "German Shorthaired Pointer",
          12,
          14,
          "german_shorthaired_pointer",
          "General hunting, Sporting Group",
          "Hunters",
          "Low",
          "12-14 years",
          "58-64 cm",
          "25-32 kg",
          "Boisterous, Affectionate, Bold, Cooperative",
          "No",
          "Liver Roan, Liver, Black & White, White & Chocolate",
        ],
        [
          "German Wirehaired Pointer",
          12,
          14,
          "german_wirehaired_pointer",
          "Sporting Group, General hunting, watch dog",
          "Gun Dog",
          "Moderate",
          "12-14 years",
          "61-68 cm",
          "27-32 kg",
          "Willful, Intelligent, Loyal, Active",
          "No",
          "Liver, Black & White, Roan, Liver & White",
        ],
        [
          "Giant Schnauzer",
          12,
          15,
          "giant_schnauzer",
          "Working Group, Herding, guarding",
          "Herding Dog",
          "Moderate",
          "12-15 years",
          "65-70 cm",
          "27-48 kg",
          "King, Dominant, Loyal, Powerful, Strong Willed",
          "Yes",
          "Salt & Pepper, Black",
        ],
        [
          "Glen of Imaal Terrier",
          13,
          14,
          "default",
          "Terrier Group",
          "Children",
          "High",
          "10-14 years",
          "13-i4 in",
          "15-16 kg",
          "Agile, Spirited, Loyal, Active",
          "No",
          "Blue Brindle, Wheaten",
        ],
        [
          "Golden Retriever",
          10,
          12,
          "golden_retriever",
          "Sporting Dogs",
          "Families",
          "Medium",
          "11-12 years",
          "58-61 cm",
          "29-34 kg",
          "Intelligent, Gentle, Friendly",
          "No",
          "Gold, cream",
        ],
        [
          "Gordon Setter",
          10,
          12,
          "gordon_setter",
          "Sporting Group",
          "Families and Children",
          "Low",
          "10-12 years",
          "61-69 cm",
          "25-36 kg",
          "Gay. Fearless, Confident, Active",
          "No",
          "Black & Tan",
        ],
        [
          "Great Dane",
          6,
          8,
          "great_dane",
          "Working Dogs",
          "Families",
          "Medium",
          "6-8 years",
          "76-86 cm",
          "54-91 kg",
          "Devoted, Reserved, Loving, Gentle, Friendly, Confident",
          "No",
          "Brindle, Fawn, Black, Mantle, Blue, Harlequin",
        ],
        [
          "Great Pyrenees",
          10,
          12,
          "great_pyrenees",
          "Sheep guardian, Working Group",
          "Families and Childrens",
          "Moderate",
          "10-12 years",
          "70-82 cm",
          "45-73 kg",
          "Gentle, Strong Willed, Patient, Fearless",
          "No",
          "Tan, White, Bedger, White",
        ],
        [
          "Greater Swiss Mountain Dog",
          10,
          11,
          "greater_swiss",
          "Working Group",
          "Childrens",
          "Low",
          "10-11 years",
          "65-72 cm",
          "55-65 kg",
          "Self-confidence, Loyal, Devoted, Fearless",
          "No",
          "Tri-color",
        ],
        [
          "Greyhound",
          10,
          12,
          "greyhound",
          "Lapdog, Hound Group",
          "Families",
          "Low",
          "10-14 years",
          "71-76 cm",
          "27-40 kg",
          "Even Tempered, Affectionate, Quiet, Intelligent",
          "No",
          "Brindle, Black, White, Fawn, Blue, Red",
        ],
        [
          "Griffon Bruxellois",
          12,
          15,
          "griffon_bruxellois",
          "Toy Dog",
          "Kids",
          "Low",
          "10-15 years",
          "9-11 inches",
          "8-10 pounds",
          "Sensitive, Companionable, Watchful, Alert",
          "Yes",
          "Black, Black & Tan, Blue, Blege, Brown",
        ],
        [
          "Harrier",
          10,
          12,
          "default",
          "Hound Group",
          "Childrens, Families",
          "Low",
          "10-12 years",
          "19-21 inches",
          "20-30 kg",
          "Outgoing, Cheerful, Active, Friendly",
          "No",
          "Lemon & white, Tri-color, White, Black & Tan",
        ],
        [
          "Havanese",
          13,
          15,
          "havanese",
          "Companion Dogs",
          "Families",
          "Low-medium",
          "13 – 15 years",
          "23 – 27 cm",
          "4.5 – 7.3 kg",
          "Playful, Gentle, Intelligent, Responsive, Affectionate, Companionable",
          "Yes",
          "Black, White, Tobacco, Fawn",
        ],
        [
          "Ibizan Hound",
          10,
          12,
          "ibizan_hound",
          "Coursing rabbits, Hound Group",
          "Families",
          "Low",
          "10-12 years",
          "66-72 cm",
          "20-30 kg",
          "Clownish, Stubborn, Independent, Active",
          "No",
          "White, Fawn, White & Red, Red",
        ],
        [
          "Icelandic Sheepdog",
          12,
          15,
          "icelandic_sheepdog",
          "Miscellaneous Class",
          "Childrens",
          "High",
          "12-15 years",
          "16.5-18 inches",
          "9.1-14 kg",
          "Cheerful, Hardy, Agile, Alert",
          "No",
          "White & black, White & Cream, Gold & White, Grey & White",
        ],
        [
          "Irish Red and White Setter",
          10,
          13,
          "default",
          "Sporting Group",
          "Small Kids",
          "High",
          "10-13 years",
          "62-66 cm",
          "25-34 kg",
          "Affectionate, Devoted, Loyal, Reliable",
          "No",
          "Red & White",
        ],
        [
          "Irish Setter",
          12,
          15,
          "irish_setter",
          "Sporting Dogs",
          "Families",
          "High",
          "10-14 years",
          "63-70 cm",
          "29-34 kg",
          "Fun, Playful, Outgoing, Loving, Sporty",
          "No",
          "Mahogany and chestnut",
        ],
        [
          "Irish Soft-coated Wheaten Terrier",
          12,
          15,
          "default",
          "Terrier Group",
          "Families",
          "High",
          "12-15 years",
          "46-48 cm",
          "16-20 kg",
          "Intelligent, Affectionate, Playful, Energetic, Spirited",
          "Yes",
          "Wheaten",
        ],
        [
          "Irish Terrier",
          13,
          15,
          "irish_terrier",
          "Terrier Dogs",
          "Families, Singles",
          "Low-Medium",
          "12-15 years",
          "40-46 cm",
          "10-12 kg",
          "Lively, Gentle",
          "Yes",
          "Bright red, golden red, red wheaten, solid wheaten",
        ],
        [
          "Irish Water Spaniel",
          10,
          12,
          "default",
          "Water retrieving, Sporting Group",
          "Families and Childrens",
          "high",
          "10-12 years",
          "56-61 cm",
          "25-30 kg",
          "Clownish, Quick, Intelligent, Alert, Active",
          "Yes",
          "Liver",
        ],
        [
          "Irish Wolfhound",
          6,
          10,
          "irish_wolfhound",
          "Coursing wolves, elk, Hound Group",
          "Childrens",
          "Moderate",
          "6-10 years",
          "30-32 inches",
          "120-155 lbs",
          "Sweet-Tempered, Thoughtful, Loyal, Dignified, Genrous",
          "No",
          "Black, White, Brindle, Fawn, Grey",
        ],
        [
          "Italian Greyhound",
          12,
          15,
          "italian_greyhound",
          "Companion Dogs",
          "Families with older kids",
          "Medium – low",
          "12-15 years",
          "30 to 40 cm",
          "3 – 5 kg",
          "Intelligent, Agile, Affectionate, Companionable, Athletic, Mischievous",
          "Yes",
          "Black, Fawn, Chocolate, Blue Fawn, Slate Grey, Red Fawn, Red, Blue, Tan, Sable, Yellow, Grey",
        ],
        [
          "Jack Russell Terrier",
          13,
          16,
          "jack_russell_terrier",
          "Terrier Dogs",
          "Families with older children",
          "Medium",
          "13-16 years",
          "25 to 38cm",
          "6 to 8kgs",
          "Stubborn, Fearless, Intelligent, Athletic, Energetic, Vocal",
          "No",
          "White, Black & White, White & Tan",
        ],
        [
          "Japanese Chin",
          12,
          14,
          "japanese_chin",
          "Lapdog, Toy Dog",
          "Childrens",
          "Moderate",
          "12-14 years",
          "8-11 inches",
          "1.4-8.6 kg",
          "Cat-like, Alert, Loyal, Intelligent, Independent",
          "No",
          "Tri-color, Black & White, Lemon & White, Sable & White",
        ],
        [
          "Keeshond",
          13,
          15,
          "keeshounds",
          "Barge watchdog, Non-Sporting Group",
          "Families & Childrens",
          "High",
          "13-15 years",
          "17-18 inches",
          "14-18 kg",
          "Bright, Agile, Playful, Obedient",
          "No",
          "Black, Grey, Black & Silver, Silver",
        ],
        [
          "Kerry Blue Terrier",
          13,
          15,
          "kerry_blue_terriers",
          "Kerry Blue Terrier",
          "Childrens",
          "High",
          "13-15 years",
          "46-51 cm",
          "15-18 kg",
          "Strong Willed, Alert, Loyal, Spirited",
          "Yes",
          "Black, Blue, Silver, Grey",
        ],
        [
          "King Charles Spaniel",
          12,
          14,
          "king_charles_spaniel",
          "Flushing small birds, companion, Toy Dog",
          "Childrens, Families and Strangers",
          "High",
          "9-14 years",
          "12-13 inches",
          "5.9-9.2 kg",
          "Playful, Sociable, Gentle, Affectionate, Patient",
          "No",
          "Black & Tan, Tri-color, Ruby",
        ],
        [
          "Komondor",
          10,
          12,
          "default",
          "Sheep guardian, Working Group",
          "Families",
          "High",
          "10-12 years",
          "71-76 cm",
          "50-60 kg",
          "Steady, Affectionate, fearless, Gentle",
          "No",
          "White, Black, Red, Green",
        ],
        [
          "Kuvasz",
          10,
          12,
          "default",
          "Guardian, hunting large game, Working Group",
          "Families",
          "Moderate",
          "10-12 years",
          "70-76 cm",
          "45-52 kg",
          "Protective, Intelligent, Patient, Loyal",
          "No",
          "White, Black, Blue, Brown, Pink",
        ],
        [
          "Labrador Retriever",
          12,
          13,
          "labrador_retriever",
          "Water retrieving, Sporting Group",
          "Kids and Families",
          "Low",
          "10-12 years",
          "57-62 cm",
          "29-36 kg",
          "Outgoing, Kind, Even Tempered, Agile",
          "No",
          "Black, Yellow, Chocolate",
        ],
        [
          "Lakeland Terrier",
          12,
          16,
          "lakeland_terrier",
          "Terrier Group",
          "Kids & Families",
          "Moderate",
          "12-16 years",
          "13.5-15 inches",
          "7-8 kg",
          "Intelligent, Friendly, Independent, Bold",
          "Yes",
          "Black, Grizzle & Tan, Black & Tan, Wheaten",
        ],
        [
          "Leonberger",
          8,
          9,
          "leonberger",
          "Guardian, appearance, Miscellaneous Class",
          "Kids",
          "High",
          "8-9 years",
          "72-80 cm",
          "48-75 kg",
          "Fearless, Loyal, Loving, Obedient",
          "No",
          "Red, Sandy, Yellow",
        ],
        [
          "Lhasa Apso",
          12,
          14,
          "lhasa_apso",
          "Companion Dogs",
          "Singles, families",
          "High",
          "13-15 years",
          "25 – 28 cm",
          "6 – 7 kg",
          "Playful, Lively, Obedient, Devoted, Fearless, Intelligent, Spirited, Alert, Assertive, Energetic, Friendly, Steady",
          "Yes",
          "black, white, black and tan",
        ],
        [
          "Lowchen",
          12,
          14,
          "default",
          "Non-Sporting Group",
          "Families and Childrens",
          "Low",
          "12-14 years",
          "33-36 cm",
          "5-8 kg",
          "Playful, Happy, Active, Intelligent",
          "Yes",
          "Black, Silver & Black, Cream, Black & Tan",
        ],
        [
          "Maltese",
          12,
          15,
          "maltese_dog",
          "Companion Dogs",
          "Singles, families with older children",
          "Low – medium",
          "12-15 years",
          "21 – 25 cm",
          "3 – 4 kg",
          "Playful, Lively, Affectionate, Docile, Fearless",
          "Yes",
          "White, Black, Blue, Red, Green, Yellow",
        ],
        [
          "Manchester Terrier",
          14,
          16,
          "default",
          "Terrier Group",
          "Families",
          "Low",
          "14-16 years",
          "15-16 inches",
          "5.4-10 kg",
          "Discerming, Keen, Active, Devoted",
          "No",
          "Black, Black & Tan, Tan, Blue",
        ],
        [
          "Mexican Hairless Dog",
          12,
          15,
          "mexican_hairless",
          " hairless Chinese, Foundation Stock Service Program",
          "Families, Old Childrens",
          "Low",
          "12-15 years",
          "28-33 cm",
          "4-25 kg",
          "Cheerful, Calm, Alert, Intelligent, Protective",
          "Yes",
          "Black, Brindle, Brown, Fawn",
        ],
        [
          "Miniature Pinscher",
          14,
          15,
          "miniature_pinscher",
          "Companion Dogs",
          "Families",
          "Medium-high",
          "10 to 14 years",
          "25–30 cm",
          "4–5 kg",
          "Playful, Outgoing, Responsive, Energetic, Friendly, Clever",
          "No",
          "Stag Red, Chocolate & Rust, Black & Tan, Red, Black & Rust, Chocolate & Tan",
        ],
        [
          "Miniature Schnauzer",
          12,
          15,
          "mininature_schnauzer",
          "Ratting, Terrier Group",
          "Childrens",
          "Moderate",
          "12-15 years",
          "30-36 cm",
          "5.4-9.1 kg",
          "Intelligent, Fearless, Obedient, Friendly",
          "Yes",
          "Black, Salt & Pepper, White",
        ],
        [
          "Neapolitan Mastiff",
          8,
          10,
          "default",
          "Working Group",
          "Old Childrens",
          "Low",
          "8-10 years",
          "63-77 cm",
          "60-70 kg",
          "Stubborn, Obedient, Dominant, Protective, Fearless",
          "No",
          "Black, Brindle, Tawny, Blue",
        ],
        [
          "Newfoundland",
          8,
          12,
          "newfoundland",
          "Working Dogs",
          "Families",
          "Medium",
          "8-10 years",
          "69 to 74cm",
          "65 to 69kgs",
          "Trainable, Sweet-Tempered, Gentle",
          "No",
          "Black, Black & White, Brown, Grey",
        ],
        [
          "Norfolk Terrier",
          12,
          15,
          "default",
          "Ratting, fox bolting, Terrier Group",
          "Childrens",
          "Moderate",
          "12-15 years",
          "9-10 inches",
          "5-5.4 kg",
          "Lovable, Fearless, Spirited, Happy",
          "Yes",
          "Grizzle, Black & Tan, Wheaten, Red",
        ],
        [
          "Norwegian Buhund",
          13,
          15,
          "default",
          "Miscellaneous Class",
          "Families",
          "Low",
          "13-15 years",
          "43-47 cm",
          "14-18 kg",
          "Fun-loving, Friendly, Courageous, Energetic, Agile",
          "No",
          "Black, Red Wheaten, Wheaten",
        ],
        [
          "Norwegian Elkhound",
          12,
          15,
          "default",
          "Hunting elk, Hound Group",
          "Kids",
          "Moderate",
          "12-15 years",
          "19-21 inches",
          "22-25 kg",
          "Hardy, Bold, Loyal, Alert, Strong Willed",
          "No",
          "Grey, Silver",
        ],
        [
          "Norwegian Lundehund",
          12,
          14,
          "default",
          "Northern Breed Group",
          "Kids",
          "Low",
          "12-14 years",
          "33-38 cm",
          "6-9 kg",
          "Energetic, loyal, Protective, Alert",
          "No",
          "Black, White, Sable & White, Grey, Red",
        ],
        [
          "Norwich Terrier",
          12,
          14,
          "norwich_terrier",
          "Ratting, fox bolting",
          "Families and Childrens",
          "Moderate",
          "12-14 years",
          "8-10 inches",
          "5-5.4 kg",
          "Hardy, Intelligent, Sensitive, Affectionate",
          "Yes",
          "Grizzle, Black & Tan, Red, Tan",
        ],
        [
          "Nova Scotia Duck Tolling Retriever",
          12,
          14,
          "nova_scotia_duck_tolling_retriever",
          "Sporting Group",
          "Childrens",
          "Low",
          "10-14 years",
          "45-54 cm",
          "20-23 kg",
          "Intelligent, Alert, Loving",
          "No",
          "Copper, Red, Red Golden",
        ],
        [
          "Old English Sheepdog",
          10,
          12,
          "old_english_sheepdog",
          "Herding Group",
          "Families",
          "Medium – high",
          "10-12 years",
          "56 – 61cm",
          "38 – 45kg",
          "Active, Intelligent, Loyal, Hard-Working, Athletic, Confident, Proud",
          "No",
          "Blue Merle, Blue, Grey, Grizzle",
        ],
        [
          "Otterhound",
          10,
          13,
          "default",
          "Hound Group",
          "Small Childrens and Families",
          "High",
          "10-13 years",
          "24-27 inches",
          "41-50 kg",
          "Amiable, Even Tempered, Boisterous",
          "No",
          "Black, Liver & Tan, Wheaten, Grey",
        ],
        [
          "Papillon",
          13,
          15,
          "papillon",
          "Companion Dogs",
          "Families",
          "Medium",
          "13-15 Years",
          "Up to 28 cm",
          "Up to 5 kg",
          "Intelligent, active",
          "No",
          "White and Brown",
        ],
        [
          "Parson Russell Terrier",
          13,
          15,
          "default",
          "Terrier Group",
          "Childrens",
          "Low",
          "13-15 years",
          "34-38 cm",
          "5.9-7.7 kg",
          "Energetic, Bold, Obedient, Intelligent",
          "No",
          "White & Tan, Tri-color, Black & White",
        ],
        [
          "Pekingese",
          12,
          15,
          "pekingese",
          "Companion Dogs",
          "Couples and singles",
          "High",
          "13-15 Years",
          "Up to 25 cm",
          "Up to 6 kg",
          "Confident, stubborn, Tough, Affectionate",
          "No",
          "Gold, sable, red, cream, tan, white",
        ],
        [
          "Pembroke Welsh Corgi",
          12,
          14,
          "pembroke_welsh_corgi",
          "Herding Group, Cattle drover",
          "children",
          "Low",
          "12-15 Years",
          "25-30 cm",
          "10-14 kg",
          "Tanacious, Friendly, Playful, Outgoing, Bold",
          "No",
          "Fawn, Black & White, Red, Black & Tan",
        ],
        [
          "Petit Basset Griffon Vendeen",
          12,
          14,
          "default",
          "Hound Group",
          "Childrens and families",
          "High",
          "12-14 years",
          "13.5-15 inches",
          "15-20 kg",
          "Extroverted, Lively, Independent, Friendly",
          "No",
          "Tri-color, Black & Tan, Fawn & White",
        ],
        [
          "Pharaoh Hound",
          11,
          14,
          "default",
          "Hunting rabbits, Hound Group",
          "Childrens",
          "Low",
          "11-14 years",
          "55-63 cm",
          "18-27 kg",
          "Affectionate, Sociable, Playful, Intelligent",
          "No",
          "Rich Tan, Tan, Red Golden",
        ],
        [
          "Plott Hound",
          12,
          14,
          "default",
          "Hound Group",
          "Childrens And Families",
          "High",
          "12-14 years",
          "50-71 cm",
          "23-27 kg",
          "Intelligent, Alert, Bold, Loyal",
          "No",
          "Black, Brown Brindle, Tan Brindle",
        ],
        [
          "Pointer",
          12,
          14,
          "default",
          "Sporting Group, General hunting, watch dog General hunting, watch dog",
          "Childrens",
          "Moderate",
          "12-17 years",
          "56-70 cm",
          "25-34 kg",
          "Even Tempered, Affectionate, Loyal, Amiable",
          "No",
          "Black, Orange & White, Black & White, Liver",
        ],
        [
          "Polish Lowland Sheepdog",
          12,
          15,
          "polish_lowland_sheepdog",
          "Herding Group",
          "Families",
          "High",
          "12-15 years",
          "45-50 cm",
          "18-23 kg",
          "Even Tempered, Lively, Self-confidence",
          "Yes",
          "Black, Tri-color, Black & White, Beige",
        ],
        [
          "Pomeranian",
          12,
          16,
          "pomeranian",
          "Companion Dogs",
          "Families and singles",
          "Medium",
          "12 – 16 Years",
          "13-28 cm",
          "Up to 4 kg",
          "Independent, Friendly",
          "No",
          "white, orange",
        ],
        [
          "Poodle",
          12,
          15,
          "poodle",
          "Companion Dogs",
          "Families",
          "Medium-high",
          "12-15 Years",
          "45-60 cm",
          "20-32 kg",
          "Trainable, Intelligent, Faithful, Alert, Instinctual, Active",
          "Yes",
          "Apricot, Black, White, Black & Tan, Cream, Black & White, Red, Silver, Blue, Brown, Sable, Grey",
        ],
        [
          "Portuguese Water Dog",
          12,
          15,
          "portuguese_water_dog",
          "Fishing aid, Working Group",
          "Families, Childrens",
          "High",
          "12-15 years",
          "50-57 cm",
          "18-27 kg",
          "Intelligent, Docile, Obedient, Brave, Impetuous",
          "Yes",
          "Black, White, White and Chocolate",
        ],
        [
          "Pug",
          12,
          15,
          "pug",
          "Companion Dogs",
          "Families and singles",
          "Low",
          "10-12 years",
          "30-36 cm",
          "6-9 kg",
          "Playful, Loyal",
          "Yes",
          "Black, Apricot, Fawn",
        ],
        [
          "Puli",
          12,
          16,
          "default",
          "Herding",
          "Childrens",
          "High",
          "12-16 years",
          "39-45 cm",
          "10-11 kg",
          "Intelligent, Loyal, Agile, Obedient",
          "Yes",
          "Black, White, Brindle, Cream",
        ],
        [
          "Pyrenean Shepherd",
          15,
          17,
          "default",
          "Miscellaneous Class",
          "Childrens",
          "High",
          "15-17 years",
          "40-50 cm",
          "20-25 kg",
          "Dedicated, Watchful, Bossy, Clever",
          "No",
          "Black, White, Merle, Brindle, Fawn",
        ],
        [
          "Redbone Coonhound",
          11,
          12,
          "default",
          "Miscellaneous Class",
          "Families",
          "High",
          "11-12 years",
          "56-68 cm",
          "20-32 kg",
          "Unflappable, Energetic, Companionable, Affectionate, Independent",
          "No",
          "Red & White, Red",
        ],
        [
          "Rhodesian Ridgeback",
          10,
          12,
          "rhodesian_ridgeback",
          "Hound Dogs",
          "Families with older children",
          "Medium – high",
          "10 – 12 years",
          "63–69 cm",
          "36–41 kg",
          "Strong Willed, Intelligent, Mischievous, Loyal, Dignified, Sensitive",
          "No",
          "Red Wheaten, Wheaten, Light Wheaten",
        ],
        [
          "Rottweiler",
          9,
          10,
          "rottweiler",
          "Working Dogs",
          "Families",
          "Medium",
          "8 – 10 years",
          "61 – 69 cm",
          "42 and 50 kg",
          "Obedient, Devoted, Fearless, Courageous, Alert, Self-assured, Good-natured, Calm, Steady, Confident",
          "No",
          "Black, Tan, Mahogany",
        ],
        [
          "Rough Collie",
          14,
          16,
          "default",
          "Herding, agility training, Herding Group",
          "Childrens",
          "Minimal—brushing once a week, bathing once a month, and twice a year they will blow their coat and need a little extra brushing during this time",
          "14-16 years",
          "56-61 cm",
          "20-34 kg",
          "Intelligent, Loyal, Active, Gentle, Friendly",
          "No",
          "White, Blue Merle, Tri0-color, Sable Merle",
        ],
        [
          "Saluki",
          12,
          14,
          "saluki",
          "Coursing gazelle and hare, Hound Group",
          "Childrens",
          "Moderate",
          "12-14 years",
          "23-28 inches",
          "18-27 kg",
          "Aloof, Intelligent, Quiet, Reserved",
          "No",
          "White, Cream, Gold, Tan, Red",
        ],
        [
          "Samoyed",
          12,
          14,
          "samoyed_huskey",
          "Working Dogs",
          "Families",
          "Medium",
          "12 – 13 years",
          "48 – 60 cm",
          "20–30 kg",
          "Playful, Stubborn, Lively, Alert, Friendly, Sociable",
          "Yes",
          "White, Cream",
        ],
        [
          "Schipperke",
          13,
          15,
          "default",
          "Coursing deer, Non-Sporting Group",
          "Childrens and Families",
          "Low",
          "13-15 years",
          "28-33 cm",
          "3-9 kg",
          "Curious, Fearless, Agile, Confident",
          "No",
          "Black, Apricot, Chocolate, Cream",
        ],
        [
          "Scottish Deerhound",
          8,
          11,
          "default",
          "Coursing deer, Hound Group",
          "Older Childrens",
          "Low",
          "8-11 years",
          "30-32 inches",
          "40-50 kg",
          "Dignified, Docile, Gentle, Friendly",
          "No",
          "Brindle, Fawn, Red Fawn, Grey",
        ],
        [
          "Scottish Terrier",
          12,
          15,
          "scottish_terrier",
          "Terrier Dogs",
          "Families with older children, singles",
          "Medium",
          "11-13 years",
          "up to 25 cm",
          "8-10 kg",
          "Independent, Intelligent",
          "No",
          "Dark grey, bringle, black, brown, near-white, blonde",
        ],
        [
          "Sealyham Terrier",
          12,
          14,
          "sealyham_terrier",
          "Terrier Group",
          "Families, older Childrens",
          "Low",
          "12-14 years",
          "28-30 cm",
          "8-9 kg",
          "Even Tempered, Fearless, Alert, Friendly",
          "Yes",
          "White, White & Chocolate, Badger & White",
        ],
        [
          "Shar Pei",
          9,
          11,
          "shar_pei",
          "Working Dogs",
          "Families with older children",
          "Medium",
          "9-11 years",
          "45-51 cm",
          "25-29 kg",
          "Active, independent, happy",
          "No",
          "Black, red, Red-fawn, fawn, black-pointed cream, blue, sable",
        ],
        [
          "Shetland Sheepdog",
          12,
          13,
          "shetland_sheepdog",
          "Herding Dogs",
          "Families",
          "Medium-High",
          "12-14 years",
          "33-41 cm",
          "8-12 kg",
          "Active, Loyal, Independent, Happy",
          "No",
          "Blue Merle, Sable, Tri-colour",
        ],
        [
          "Shiba Inu",
          12,
          15,
          "shiba_inu",
          "Non-Sporting Group",
          "Families",
          "Low",
          "12-15 years",
          "35-43 cm",
          "8-10 kg",
          "Charming, Keen, Confident, Fearless",
          "No",
          "Red Sesame, Black Sesame, Black & Tan",
        ],
        [
          "Shih Tzu",
          10,
          16,
          "shih_tzu",
          "Companion Dogs",
          "Families",
          "Medium-High",
          "10-16 years",
          "20.3-27.9 cm",
          "4-7.5 kg",
          "Intelligent",
          "No",
          "Black, Brown, Gold, Grey and Mixture",
        ],
        [
          "Siberian Huskie",
          12,
          15,
          "siberian_husky",
          "Working Dogs",
          "Singles, families with older children",
          "Medium",
          "12 to 15 years",
          "54–60 cm",
          "18–25 kg",
          "Intelligent, Alert,Outgoing, Gentle, Friendly",
          "No",
          "Black, Agouti, Sable, Piebald, Black & Tan, Grey, Black & White, Splash, Brown, Red, Silver, Copper",
        ],
        [
          "Skye Terrier",
          12,
          15,
          "skye_terrier",
          "Vermin hunting, Terrier group",
          "Families, Childrens and Strangers",
          "Moderate",
          "12-15 years",
          "24-25 cm",
          "16-18 kg",
          "Good-Tempered, Friendly, Loyal, Intelligent",
          "No",
          "Black, Fawn, Blue, Light Grey",
        ],
        [
          "Smooth Fox Terrier",
          12,
          15,
          "smooth_fox_terrier",
          "Fox bolting, Terrier Group",
          "Families",
          "High",
          "12-15 years",
          "36-41 cm",
          "6.8-8.6 kg",
          "Playful, Fearless, Affectionate, Active",
          "No",
          "White, White & Tan, Black & White, Tri-color",
        ],
        [
          "Spinone Italiano",
          12,
          14,
          "default",
          "Sporting Group",
          "Families and Childrens",
          "Low",
          "12-14 years",
          "60-70 cm",
          "34-39 kg",
          "Patient, Docile, Friendly, Gentle",
          "No",
          "Orange & White, Orange Roan, Brown Roan",
        ],
        [
          "St. Bernard",
          8,
          10,
          "saint_bernard",
          "Working Group",
          "Families",
          "High",
          "8-10 years",
          "70-90 cm",
          "64-82 kg",
          "Friendly, Gentle, Loyal, Calm",
          "No",
          "Red & White, Brownish-yellow, Reddish-brown-Mantle",
        ],
        [
          "Staffordshire Bull Terrier",
          12,
          14,
          "default",
          "Bull Terrier",
          "Childrens and Families",
          "Low",
          "12-14 years",
          "36-41 cm",
          "12-17 kg",
          "Fearless, Reliable, Courageous, Loyal, Bold",
          "No",
          "Black, White, Brindle, Fawn & White",
        ],
        [
          "Standard Schnauzer",
          12,
          14,
          "standard_schnnauzer",
          "Working Group, Ratting, guarding",
          "Childrens",
          "High",
          "13-16 years",
          "47-50 cm",
          "14-20 kg",
          "Trainable, Devoted, Good-natured, Lively",
          "Yes",
          "Black, Salt & Pepper",
        ],
        [
          "Sussex Spaniel",
          12,
          15,
          "default",
          "Sporting Group",
          "Families",
          "High",
          "12-15 years",
          "38-41 cm",
          "16-20 kg",
          "Cheerful, Devoted, Calm, Friendly",
          "No",
          "Golden Liver",
        ],
        [
          "Swedish Vallhund",
          12,
          14,
          "swedish_vallhund",
          "Herding Group",
          "Kids, Families and Strangers",
          "Low",
          "12-15 years",
          "32-34 cm",
          "9-14 kg",
          "Intelligent, Watchful, Fearless, Alert",
          "No",
          "Greyish Brown, Mahogany, Blue, Greyish Yellow",
        ],
        [
          "Tibetan Mastiff",
          10,
          12,
          "tibetian_mastiff",
          "Working Group",
          "Childrens",
          "Moderate",
          "12-15 years",
          "66-76 cm",
          "41-68 kg",
          "Stubborn, Active, Strong Willed, Intelligent",
          "No",
          "Black, Brown & Tan, Blue Grey",
        ],
        [
          "Tibetan Spaniel",
          12,
          15,
          "tibetan_spaniel",
          "Non-Sporting Group, Watchdog",
          "Childrens",
          "Moderate",
          "12-15 years",
          "9-10 inches",
          "4.1-6.8 kg",
          "Assertive, Willful, Intelligent, Playful",
          "No",
          "Sable, Black, White, Red, Black & Tan",
        ],
        [
          "Tibetan Terrier",
          12,
          15,
          "tibetan_terrier",
          "Non-Sporting Group",
          "Families",
          "Moderate",
          "12-15 years",
          "14-16 inches",
          "8-14 kg",
          "Amiable, Energetic, Reserved, Sensitive, Gentle",
          "Yes",
          "Piebald, Black, White, Brindle, Tri-color",
        ],
        [
          "Toy Fox Terrier",
          13,
          14,
          "toy_fox_terrier",
          "Terrier Group, Toy Dog",
          "Small Childrens",
          "Low",
          "13-14 years",
          "8.5-11.5 inches",
          "3.5-7 pounds",
          "Intelligent, Spirited, Loyal, Friendly, Playful",
          "No",
          "White & chocolate, White & Tan, Tri-color",
        ],
        [
          "Treeing Walker Coonhound",
          12,
          13,
          "default",
          "Foundation Stock Service Program, Hunters",
          "Childrens",
          "Low",
          "12-13 years",
          "56-69 cm",
          "23-32 kg",
          "Trainable, Confident, Affectionate, Clever",
          "No",
          "Black, White, Tri-color",
        ],
        [
          "Tervuren",
          12,
          14,
          "default",
          "Herding Group",
          "Childrens",
          "Low",
          "12-14 years",
          "60-66 cm",
          "25-29 kg",
          "Attentive, Loyal, Active, Protective",
          "No",
          "Black, Black & Cream, Fawn & Black, Brindle",
        ],
        [
          "Vizsla",
          12,
          15,
          "vizsla",
          "Sporting Group, Pointing and trailing",
          "Families and small Children",
          "High",
          "12-15 years",
          "56-64 cm",
          "20-30 kg",
          "Quiet, Energetic, Loyal, Affectionate",
          "No",
          "Golden Rust, Red Golden, Golden",
        ],
        [
          "Weimaraner",
          10,
          12,
          "weimaraner",
          "Sporting Dogs",
          "Families",
          "Medium",
          "10 – 12 years",
          "64 – 69 cm",
          "32 – 36 kgs",
          "Stubborn, Intelligent, Aloof, Alert, Energetic, Steady, Fast, Powerful",
          "No",
          "Mouse-gray, Silver, Silver-gray",
        ],
        [
          "Welsh Springer Spaniel",
          12,
          15,
          "default",
          "Flushing and retrieving birds, Sporting Group",
          "Families and strangers",
          "Moderate",
          "12-15 years",
          "46-48 cm",
          "16-20 kg",
          "Active, Stubborn, Playful, Loyal",
          "No",
          "White & Red",
        ],
        [
          "Welsh Terrier",
          12,
          15,
          "welsh_terrier",
          "Terrier Dogs",
          "Families & Singles",
          "Low",
          "10 to 14 years",
          "30 – 40 cm",
          "upto 9kg",
          "Intelligent, Alert, Friendly, Spirited",
          "Yes",
          "Black & Tan, Grizzle & Tan",
        ],
        [
          "West Highland White Terrier",
          12,
          16,
          "west_highland_white_terrier",
          "Terrier Group",
          "Families and Children",
          "Low",
          "12-16 years",
          "25-30 cm",
          "6.8-9.1 kg",
          "Intelligent, Courageous, Active, Alert, Loyal",
          "Yes",
          "Pink, Red, Blue, Black, White",
        ],
        [
          "Whippet",
          12,
          15,
          "whippet",
          "Hound Dogs",
          "Families",
          "Medium",
          "12-15 years",
          "47 – 56 cm",
          "10 to 13 kgs",
          "Lively, Quiet, Friendly",
          "No",
          "Black, Brindle, White, Fawn",
        ],
        [
          "Wire Hair Fox Terrier",
          13,
          14,
          "default",
          "Terrier Group",
          "Families and young Children",
          "High",
          "13-14 years",
          "36-41 cm",
          "7-9.5 kg",
          "Keen, Fearless, Active, Bold",
          "Yes",
          "White, White & Tan, Black & White, Tricolor",
        ],
        [
          "Wirehaired Pointing Griffon",
          10,
          12,
          "default",
          "Sporting Group",
          "Children",
          "High",
          "10-12 years",
          "55-60 cm",
          "23-27 kg",
          "Proud, Trainable, Vigilant, Loyal",
          "Yes",
          ";Grey & Tan, White & Chocolate, Chestnut, Liver",
        ],
        [
          "Xoloitzcuintle ",
          12,
          15,
          "xoloitzcuintli",
          "Non-Sporting Group",
          "Families",
          "Moderate",
          "12-15 years",
          "10-14 inches",
          "4-25 kg",
          "Aloof, Cheerful, Active, Calm",
          "Yes",
          "Black, Dark Brown, Brindle, Cooper & White",
        ],
        [
          "Yorkshire Terrier",
          13,
          16,
          "yorkshire_terrier",
          "Companion Dogs",
          "Families, Singles",
          "Low-Medium",
          "12-15 years",
          "15-17.5 cm",
          "Up to 3.2 kg",
          "Loyal, Active",
          "Yes, medium shedding",
          "Blue and tan",
        ],
      ];

      const data = breeds[parseInt(dogBreed1) - 1];

      const firstYearAge = tech_a;
      const secondYearAge = tech_b;
      const restHumanAge = tech_c;
      const dogAverageAge = (data[1] + data[2]) / 2;

      let dogHumanAge = 0;
      if (tech_dogAge > 2) {
        dogHumanAge =
          firstYearAge +
          secondYearAge +
          (tech_dogAge - 2) * (restHumanAge / (dogAverageAge - 2));
      } else if (tech_dogAge > 1) {
        dogHumanAge = firstYearAge + (tech_dogAge - 1) * secondYearAge;
      } else {
        dogHumanAge = tech_dogAge * firstYearAge;
      }

      let type = "";
      if (dogHumanAge > 44) {
        type = " a Senior dog";
      } else if (dogHumanAge > 18) {
        type = " an Adult dog";
      } else {
        type = " a Puppy dog";
      }

      param = {
        tech_dogHumanAge: dogHumanAge,
        tech_type: type,
        tech_data: data,
        tech_name: data[0],
        tech_dogAge: tech_dogAge,
        tech_a: tech_a,
        tech_b: tech_b,
        tech_c: tech_c,
        tech_images: data[3],
        tech_f1: data[4],
        tech_f2: data[5],
        tech_f3: data[6],
        tech_f4: data[7],
        tech_f5: data[8],
        tech_f6: data[9],
        tech_f7: data[10],
        tech_f8: data[11],
        tech_f9: data[12],
      };
    }

    param.tech_operations = tech_operations;
    return param;
  }

  /**
   * getCalculationDogCreateSizeCalculator: Service Method
   * POST: /api/calculators-lol/dog-crate-size-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDogCreateSizeCalculator(body) {
    const extraLength = parseFloat(body.tech_extra_lenght?.toString().trim());
    let dogHeight = parseFloat(body.tech_height?.toString().trim());
    let dogHeightUnit = body.tech_h_units?.toString().trim();
    let dogLength = parseFloat(body.tech_length?.toString().trim());
    let dogLengthUnit = body.tech_l_units?.toString().trim();

    const result = {};

    function convertToCm(value, unit) {
      if (unit === "m") {
        return value * 100;
      } else if (unit === "in") {
        return value * 2.54;
      } else if (unit === "ft") {
        return value * 30.48;
      }
      return value;
    }

    if (!isNaN(dogHeight) && !isNaN(dogLength)) {
      if (dogLengthUnit) {
        dogLength = convertToCm(dogLength, dogLengthUnit);
      }
      if (dogHeightUnit) {
        dogHeight = convertToCm(dogHeight, dogHeightUnit);
      }

      const crateHeight = dogHeight + extraLength;
      const crateLength = dogLength + extraLength;

      result.tech_c_height = crateHeight;
      result.tech_c_lenght = crateLength;
      result.success = true;
    } else {
      result.error = "Please! Check your inputs.";
      result.success = false;
    }

    return result;
  }

  /**
   * getCalculationDogFoodCalculator: Service Method
   * POST: /api/calculators-lol/dog-food-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDogFoodCalculator(body) {
    const result = {};
    const dogType = body.tech_type_unit?.trim();
    let dogWeight = parseFloat(body.tech_weight);
    const weightUnit = body.tech_weight_unit?.trim();

    if (isNaN(dogWeight) || dogWeight <= 0) {
      result.error =
        "The 's weight must be a numeric value greater than zero. 🐕‍🦺";
      return result;
    }

    // Convert weight to kilograms
    switch (weightUnit) {
      case "g":
        dogWeight = dogWeight / 1000;
        break;
      case "dag":
        dogWeight = dogWeight / 100;
        break;
      case "kg":
        break; // already in kg
      case "lb":
        dogWeight = dogWeight / 2.20462;
        break;
      default:
        result.error = "Invalid weight unit";
        return result;
    }

    // Calculate Resting Energy Requirement
    const RER = 70 * Math.pow(dogWeight, 0.75);

    // Map dog type to multiplication factor
    const factorMap = {
      "Puppy - 0 to 4 months": 3.0,
      "Puppy - 4 months to adult": 2.0,
      "Dog - inactive or obese prone": 1.2,
      "Dog (neutered/spayed) - average activity": 1.6,
      "Dog (intact) - average activity": 1.8,
      "Dog - weight loss needed": 1.0,
      "Dog - weight gain needed": 1.7,
      "Working dog - light work": 2.0,
      "Working dog - moderate work": 3.0,
      "Working dog - heavy work": 5.0,
      "Senior dog": 1.1,
    };

    // Check if dogType exists in the map
    const factor = factorMap[dogType];
    if (typeof factor === "undefined") {
      result.error = "Unsupported dog type. Kindly select a valid option.🐶";
      return result;
    }

    const answer = RER * factor;

    result.payload = {
      tech_answer: parseFloat(answer.toFixed(2)),
    };

    return result;
  }

  /**
   * getCalculationDateCalculator: Service Method
   * POST: /api/calculators-lol/date-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDateCalculator(body) {
    console.log(body);
    const result = {};
    let ans = [];
    if (body.locale && body.locale !== "en") {
      const { dateTypes, s_date_duration, e_date_duration, checkbox_duration } =
        body;
    } else {
      // If language is English
      const {
        add_date,
        method,
        years = 0,
        months = 0,
        weeks = 0,
        days = 0,
        repeat = 1,
        add_hrs_f = 0,
        add_min_f = 0,
        add_sec_f = 0,
        add_hrs_s = 0,
        add_min_s = 0,
        add_sec_s = 0,
      } = body;

      if (!add_date || !method) {
        return { error: "Please! Check Your Input." };
      }

      // Create initial moment date object with time if available
      let date = moment(
        `${add_date} ${String(add_hrs_f).padStart(2, "0")}:${String(
          add_min_f
        ).padStart(2, "0")}:${String(add_sec_f).padStart(2, "0")}`,
        "YYYY-MM-DD HH:mm:ss"
      );

      const isTimeIncluded = [
        add_hrs_f,
        add_min_f,
        add_sec_f,
        add_hrs_s,
        add_min_s,
        add_sec_s,
      ].some((val) => parseInt(val) > 0);

      result.from = isTimeIncluded
        ? date.format("dddd, MMM DD, YYYY hh:mm:ss A")
        : date.format("dddd, MMM DD, YYYY");

      for (let i = 0; i < repeat; i++) {
        if (method === "add") {
          date = date
            .add(parseInt(years), "years")
            .add(parseInt(months), "months")
            .add(parseInt(weeks), "weeks")
            .add(parseInt(days), "days");

          if (isTimeIncluded) {
            date = date
              .add(parseInt(add_hrs_s), "hours")
              .add(parseInt(add_min_s), "minutes")
              .add(parseInt(add_sec_s), "seconds");
          }
        } else {
          date = date
            .subtract(parseInt(years), "years")
            .subtract(parseInt(months), "months")
            .subtract(parseInt(weeks), "weeks")
            .subtract(parseInt(days), "days");

          if (isTimeIncluded) {
            date = date
              .subtract(parseInt(add_hrs_s), "hours")
              .subtract(parseInt(add_min_s), "minutes")
              .subtract(parseInt(add_sec_s), "seconds");
          }
        }

        ans.push(
          isTimeIncluded
            ? date.format("dddd, MMM DD, YYYY hh:mm:ss A")
            : date.format("dddd, MMM DD, YYYY")
        );
      }

      result.method = method;
      result.years = String(years).padStart(2, "0");
      result.months = String(months).padStart(2, "0");
      result.weeks = String(weeks).padStart(2, "0");
      result.days = String(days).padStart(2, "0");
      result.add_hrs_f = String(add_hrs_f).padStart(2, "0");
      result.add_min_f = String(add_min_f).padStart(2, "0");
      result.add_sec_f = String(add_sec_f).padStart(2, "0");
      result.add_hrs_s = String(add_hrs_s).padStart(2, "0");
      result.add_min_s = String(add_min_s).padStart(2, "0");
      result.add_sec_s = String(add_sec_s).padStart(2, "0");
      result.ans = ans;
      result.repeat = repeat;
      result.RESULT = 1;

      return result;
    }
  }

  /**
   * getCalculationDaysSinceDateCalculator: Service Method
   * POST: /api/calculators-lol/days-since-date-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDaysSinceDateCalculator(body) {
    // Destructuring inputs from the request body
    const { day, month, year, day1, month1, year1 } = body;

    // Creating two date objects using moment.js
    const date1 = moment([year, month - 1, day]); // month in moment.js is 0-based
    const date2 = moment([year1, month1 - 1, day1]);

    // Getting the total difference in days
    const totalDays = date2.diff(date1, "days");

    let workingDays = 0;
    let holidays = 0;
    let currentDate = date1.clone(); // Clone the date to avoid modifying the original

    // Looping through each date from date1 to date2
    while (currentDate.isBefore(date2) || currentDate.isSame(date2)) {
      if (currentDate.isoWeekday() === 6 || currentDate.isoWeekday() === 7) {
        // If the day is Saturday (6) or Sunday (7), it's a holiday
        holidays++;
      } else {
        // Otherwise, it's a working day
        workingDays++;
      }
      currentDate.add(1, "days");
    }

    holidays = totalDays - workingDays;

    // Returning the result
    return {
      workingDays,
      holidays,
      totalDays,
    };
  }

  /**
   * getCalculationRoundtoTheNearestCentCalculator: Service Method
   * POST: /api/calculators-lol/round-to-the-nearest-cent
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRoundtoTheNearestCentCalculator(body) {
    const value = body.tech_round;

    if (typeof value === "number" && !isNaN(value)) {
      const result = Math.round(value * 100) / 100; // Round to 2 decimal places
      return {
        tech_result: result,
      };
    } else {
      return {
        error: "Please Check Your Input.",
      };
    }
  }

  /**
   * getCalculationSquereRootCurveCalculator: Service Method
   * POST: /api/calculators-lol/square-root-curve-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSquereRootCurveCalculator(body) {
    const percentage = body.tech_percentage;

    if (typeof percentage === "number" && !isNaN(percentage)) {
      if (percentage <= 0) {
        return {
          error:
            "Number of percentage grade value cannot be equal to or less than zero.",
        };
      }

      const answer = Math.sqrt(percentage) * 10;

      return {
        tech_answer: answer,
        tech_percentage: percentage,
      };
    } else {
      return {
        error: "Please Check Your Input.",
      };
    }
  }

  /**
   * getCalculationAbsoluteChangeCalculator: Service Method
   * POST: /api/calculators-lol/absolute-change-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAbsoluteChangeCalculator(body) {
    const initial = body.tech_initial;
    const final = body.tech_final;

    if (typeof initial === "number" && typeof final === "number") {
      const answer = final - initial;

      return {
        tech_answer: answer,
        tech_initial: initial,
        tech_final: final,
      };
    } else {
      return {
        error: "Please Check Your Input.",
      };
    }
  }

  /**
   * getCalculationLogBase2Calculator: Service Method
   * POST: /api/calculators-lol/log-base-2-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLogBase2Calculator(body) {
    const input = body.tech_input;

    if (typeof input === "number") {
      const answer = Math.log2(input);

      return {
        tech_answer: answer,
      };
    } else {
      return {
        error: "Please Check Your Input.",
      };
    }
  }

  /**
   * getCalculationComparingDecimalCalculator: Service Method
   * POST: /api/calculators-lol/comparing-decimals-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationComparingDecimalCalculator(body) {
    const first = body.tech_first;
    const second = body.tech_second;

    // Check if both values are numeric
    if (!isNaN(first) && !isNaN(second)) {
      return {
        tech_first: first,
        tech_second: second,
      };
    } else {
      return {
        error: "Please Check Your Input.",
      };
    }
  }

  /**
   * getCalculationDoublingtimeCalculator: Service Method
   * POST: /api/calculators-lol/doubling-time-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDoublingtimeCalculator(body) {
    const x = parseFloat(body.tech_x); // The percentage value
    const want = parseInt(body.tech_want); // The want value (1 or other)

    // Check if both x and want are numeric
    if (!isNaN(x) && !isNaN(want)) {
      let ans;

      if (want === 1) {
        // Doubling time formula for want = 1
        ans = Math.log(2) / Math.log(1 + x / 100);
      } else {
        // Doubling time formula for other values of want
        ans = Math.log(2) / x;
        ans = Math.pow(Math.E, ans) - 1;
        ans = ans * 100;
      }
      return {
        tech_ans: ans,
      };
    } else {
      return {
        error: "Please Check Your Input.",
      };
    }
  }

  /**
   * getCalculationVariationCalculator: Service Method
   * POST: /api/calculators-lol/variation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationVariationCalculator(body) {
    const x = parseFloat(body.tech_x); // The first numeric value
    const y = parseFloat(body.tech_y); // The second numeric value
    const select = body.tech_select; // The selection for the operation

    // Check if both x and y are numeric
    if (!isNaN(x) && !isNaN(y)) {
      let ans;

      switch (select) {
        case "1":
          ans = y / x;
          break;
        case "2":
          ans = y * x;
          break;
        case "3":
          ans = y / Math.pow(x, 2);
          break;
        case "4":
          ans = y / Math.pow(x, 3);
          break;
        case "5":
          ans = y / Math.sqrt(x);
          break;
        case "6":
          ans = y * Math.pow(x, 2);
          break;
        case "7":
          ans = y * Math.pow(x, 3);
          break;
        case "8":
          ans = y * Math.sqrt(x);
          break;
        default:
          return { error: "Invalid selection option." };
      }

      return {
        tech_ans: ans,
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /**
   * getCalculationFibonacciCalculator: Service Method
   * POST: /api/calculators-lol/variation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationFibonacciCalculator(body) {
    const n = parseFloat(body.tech_n);
    const units = body.tech_units;
    const first_term = parseInt(body.tech_first_term);
    const second_term = parseInt(body.tech_second_term);

    // Helper function to generate Fibonacci sequence
    function generateFibonacci(start, end) {
      const fibonacci = [0, 1];
      for (let i = 2; i <= end; i++) {
        fibonacci[i] = fibonacci[i - 1] + fibonacci[i - 2];
      }
      return fibonacci.slice(start, end + 1);
    }

    let result = {};

    if (units === "A Sequence") {
      if (isNaN(first_term) || isNaN(second_term) || first_term > second_term) {
        result.error = "Please Check Your Input.";
        return result;
      }

      const fibonacci_sequence = generateFibonacci(first_term, second_term);
      result.tech_fibonacci_sequence = fibonacci_sequence;
      return result;
    } else {
      if (!isNaN(n)) {
        if (n < -250) {
          return { error: "n Value is less than -250" };
        }
        if (n >= 251) {
          return { error: "n Value is greater than or equal to 250" };
        }

        const phi = (1 + Math.sqrt(5)) / 2;
        const psi = 1 - phi;
        const answer = (Math.pow(phi, n) - Math.pow(psi, n)) / Math.sqrt(5);
        result.tech_answer = answer;
        return result;
      } else {
        return { error: "Please Check Your Input." };
      }
    }
  }

  /**
   * getCalculationCircumferenceToDiameterCalculator: Service Method
   * POST: /api/calculators-lol/circumference-to-diameter-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCircumferenceToDiameterCalculator(body) {
    const conversionType = body.tech_conversionType;
    let value = parseFloat(body.tech_value);
    const unit = body.tech_unit;

    function convert_unit(unit, value) {
      if (unit === "cm") {
        return value;
      } else if (unit === "mm") {
        return value * 10;
      } else if (unit === "m") {
        return value * 0.01;
      } else if (unit === "km") {
        return value * 0.00001;
      } else if (unit === "in") {
        return value * 0.3937;
      } else if (unit === "ft") {
        return value * 0.0328084;
      } else if (unit === "yd") {
        return value * 0.0109361;
      } else if (unit === "mi") {
        return value * 0.0000062137;
      } else {
        return value;
      }
    }

    if (!isNaN(value)) {
      value = convert_unit(unit, value);
      let result;

      if (conversionType === "circumferenceToDiameter") {
        result = value / Math.PI;
      } else {
        result = value * Math.PI;
      }

      return {
        tech_result: result,
        tech_unit: unit,
      };
    } else {
      return {
        error: "Please Check Your Input.",
      };
    }
  }

  /**
   * getCalculationVolumeOfSquareCalculator: Service Method
   * POST: /api/calculators-lol/volume-of-square
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationVolumeOfSquareCalculator(body) {
    let {
      tech_length,
      tech_length_unit,
      tech_height,
      tech_height_unit,
      tech_width,
      tech_width_unit,
    } = body;

    tech_length = parseFloat(tech_length);
    tech_height = parseFloat(tech_height);
    tech_width = parseFloat(tech_width);

    function convertToInches(unit, value) {
      switch (unit) {
        case "mm":
          return value / 25.4;
        case "cm":
          return value / 2.54;
        case "m":
          return value * 39.37;
        case "km":
          return value * 39370;
        case "in":
          return value;
        case "ft":
          return value * 12;
        case "yd":
          return value * 36;
        case "mi":
          return value * 63360;
        default:
          return value;
      }
    }

    if (!isNaN(tech_length) && !isNaN(tech_height) && !isNaN(tech_width)) {
      const convertedLength = convertToInches(tech_length_unit, tech_length);
      const convertedHeight = convertToInches(tech_height_unit, tech_height);
      const convertedWidth = convertToInches(tech_width_unit, tech_width);

      const answer = convertedLength * convertedHeight * convertedWidth;

      return {
        tech_answer: answer,
      };
    } else {
      return {
        error: "Please Check Your Input.",
      };
    }
  }

  /**
   * getCalculationBinCreatinineRatioCalculator: Service Method
   * POST: /api/calculators-lol/bun-creatinine-ratio-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationBinCreatinineRatioCalculator(body) {
    let { tech_bun, tech_bun_unit, tech_serum, tech_serum_unit } = body;

    tech_bun = parseFloat(tech_bun);
    tech_serum = parseFloat(tech_serum);

    // Convert BUN unit to mg/dL
    let bunMultiplier = tech_bun_unit === "mmol/L" ? 2.778 : 1;

    // Convert Serum Creatinine unit to mg/dL
    let serumMultiplier = tech_serum_unit === "μmol/L" ? 0.011312 : 1;

    if (!isNaN(tech_bun) && !isNaN(tech_serum)) {
      if (tech_bun > 0 && tech_serum > 0) {
        const bv = tech_bun * bunMultiplier;
        const sv = tech_serum * serumMultiplier;
        const ans = bv / sv;

        return {
          tech_ans: ans,
        };
      } else {
        return {
          error: "Please! Enter Positive Value.",
        };
      }
    } else {
      return {
        error: "Please! Check your input.",
      };
    }
  }

  /**
   * getCalculationGramsTocaloriesCalculator: Service Method
   * POST: /api/calculators-lol/grams-to-calories-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationGramsTocaloriesCalculator(body) {
    let {
      tech_carbohydrate,
      tech_carbo_unit,
      tech_protein,
      tech_protein_unit,
      tech_fat,
      tech_fat_unit,
    } = body;

    tech_carbohydrate = parseFloat(tech_carbohydrate);
    tech_protein = parseFloat(tech_protein);
    tech_fat = parseFloat(tech_fat);

    const unitConversion = (unit) => {
      switch (unit) {
        case "dag":
          return 10;
        case "oz":
          return 28.35;
        default:
          return 1; // 'g' or fallback
      }
    };

    const carboMultiplier = unitConversion(tech_carbo_unit);
    const proteinMultiplier = unitConversion(tech_protein_unit);
    const fatMultiplier = unitConversion(tech_fat_unit);

    if (!isNaN(tech_carbohydrate) && !isNaN(tech_protein) && !isNaN(tech_fat)) {
      const tech_cv = tech_carbohydrate * carboMultiplier;
      const tech_pv = tech_protein * proteinMultiplier;
      const tech_fv = tech_fat * fatMultiplier;

      const tech_carbs = tech_cv * 4;
      const tech_pr = tech_pv * 4;
      const tech_cf = tech_fv * 9;
      const tech_tc = tech_carbs + tech_pr + tech_cf;

      return {
        tech_cv,
        tech_pv,
        tech_fv,
        tech_carbs,
        tech_pr,
        tech_cf,
        tech_tc,
      };
    } else {
      return {
        error: "Please! Check your input.",
      };
    }
  }

  /**
   * getCalculationMapCalculator: Service Method
   * POST: /api/calculators-lol/map-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMapCalculator(body) {
    const tech_sbp = parseFloat(body.tech_sbp);
    const tech_dbp = parseFloat(body.tech_dbp);

    if (!isNaN(tech_sbp) && !isNaN(tech_dbp)) {
      if (tech_sbp < 70) {
        return {
          tech_error:
            "Systolic Blood Pressure > 70 for normal person. Contact your doctor for further description.",
        };
      } else if (tech_dbp < 40) {
        return {
          tech_error:
            "Diastolic blood pressure > 40 for normal persons. Contact your doctor for further description.",
        };
      } else if (tech_dbp >= tech_sbp) {
        return {
          tech_error:
            "Diastolic blood pressure cannot be higher than systolic blood pressure.",
        };
      } else {
        const tech_map = (1 / 3) * tech_sbp + (2 / 3) * tech_dbp;
        const tech_pr = tech_sbp - tech_dbp;

        return {
          tech_sbp,
          tech_dbp,
          tech_map,
          tech_pr,
          tech_RESULT: 1,
        };
      }
    } else {
      return {
        error: "Please! Check your input.",
      };
    }
  }

  /**
   * getCalculationMapCalculator: Service Method
   * POST: /api/calculators-lol/one-rep-max-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationOneRepMaxCalculator(body) {
    let tech_weight = parseFloat(body.tech_weight);
    let tech_weight_unit = (body.tech_weight_unit || "").trim().toLowerCase();
    let tech_rep = parseFloat(body.tech_rep);

    if (!isNaN(tech_weight) && !isNaN(tech_rep)) {
      // Convert weight from lbs to kg
      if (tech_weight_unit === "lbs") {
        tech_weight = tech_weight * 0.4536;
      }

      // Calculate 1RM
      let tech_ans = tech_weight * tech_rep * 0.0333 + tech_weight;

      // Convert back to lbs if original input was in lbs
      if (tech_weight_unit === "lbs") {
        tech_ans = tech_ans * 2.2046;
      }

      return {
        tech_ans,
        tech_request: body,
      };
    } else {
      return {
        error: "Please! Check your input.",
      };
    }
  }

  /**
   * getCalculationSVRCalculator: Service Method
   * POST: /api/calculators-lol/svr-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSVRCalculator(body) {
    let tech_map = parseFloat(body.tech_map);
    let tech_map_unit = (body.tech_map_unit || "").trim();
    let tech_cvp = parseFloat(body.tech_cvp);
    let tech_cvp_unit = (body.tech_cvp_unit || "").trim();
    let tech_co = parseFloat(body.tech_co);
    let tech_co_unit = (body.tech_co_unit || "").trim();

    const convertUnit = (unit, type) => {
      if (type === "pressure") {
        switch (unit) {
          case "cmH2O":
            return 0.735559;
          case "kPa":
            return 7.50062;
          case "atm":
            return 760;
          case "psi":
            return 51.7149;
          default:
            return 1; // mmHg
        }
      }
      if (type === "flow") {
        return unit === "mL/min" ? 1000 : 1; // L/min default
      }
      return 1;
    };

    let tech_map_unit_val = convertUnit(tech_map_unit, "pressure");
    let tech_cvp_unit_val = convertUnit(tech_cvp_unit, "pressure");
    let tech_co_unit_val = convertUnit(tech_co_unit, "flow");

    if (
      !isNaN(tech_map) &&
      !isNaN(tech_cvp) &&
      !isNaN(tech_co) &&
      tech_map > 0 &&
      tech_cvp > 0 &&
      tech_co > 0
    ) {
      const tech_map_value = tech_map * tech_map_unit_val;
      const tech_cvp_value = tech_cvp * tech_cvp_unit_val;
      const tech_co_value = tech_co * tech_co_unit_val;

      const tech_cal1 = tech_map_value - tech_cvp_value;
      const tech_cal2 = tech_cal1 / tech_co_value;
      const tech_svr = 80 * tech_cal2;

      return {
        tech_svr,
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /**
   * getCalculationTacoBarCalculator: Service Method
   * POST: /api/calculators-lol/taco-bar-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTacoBarCalculator(body) {
    const first = parseFloat(body.tech_first);
    const second = parseFloat(body.tech_second);

    if (!isNaN(first)) {
      if (first > 0) {
        const result = {
          tech_meat_mass: first * second,
          tech_cheddar_cheese: 35.44 * first,
          tech_monterey_cheese: 21.262 * first,
          tech_sour_cream: 56.7 * first,
          tech_guacamole: 51.03 * first,
          tech_taco_sauce: 65.02 * first,
          tech_pico_de_gallo: 45.36 * first,
          tech_lettuce: 36.854 * first,
          tech_onions: 25.515 * first,
          tech_beans: 31.184 * first,
          tech_refried_beans: 62.37 * first,
          tech_tomatoes: 51.03 * first,
          tech_olives: 22.62 * first,
          tech_bell_pepper: 56.7 * first,
          tech_taco_shells: 2 * first,
          tech_tortillas: first,
          tech_rice: 70.87 * first,
        };
        return result;
      } else {
        return { error: "Number of people must be greater than 0." };
      }
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /**
   * getCalculationWaterIntakeCalculator: Service Method
   * POST: /api/calculators-lol/water-intake-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationWaterIntakeCalculator(body) {
    let { tech_gender, tech_weight, tech_weather, tech_unit, tech_activity } =
      body;

    tech_weight = parseFloat(tech_weight);
    tech_weather = parseFloat(tech_weather);
    tech_activity = parseFloat(tech_activity);

    if (!isNaN(tech_weight)) {
      if (tech_unit === "kg") {
        tech_weight = tech_weight * 2.205;
      }

      let tdee = 0;
      if (tech_gender === "Female") {
        tdee = Math.round(tech_weight * 0.45 * 10) / 10;
      } else if (tech_gender === "Male") {
        tdee = Math.round(tech_weight * 0.5 * 10) / 10;
      }

      let add = 0;
      if (tech_activity !== 0) {
        const plus = Math.round(tdee * tech_activity * 10) / 10;
        add += plus;
      }

      if (tech_weather !== 0) {
        const plus = Math.round(tdee * tech_weather * 10) / 10;
        add += plus;
      }

      tdee = Math.round((tdee + add) * 10) / 10;

      const im_ounce = Math.round(tdee * 1.04084 * 10) / 10;
      const us_ounce = tdee;
      const tdee_ml = Math.round(tdee * 29.5735 * 10) / 10;
      const cups = Math.round((tdee_ml / 237) * 10) / 10;
      const liter = Math.round((tdee_ml / 1000) * 10) / 10;

      return {
        tech_water: tdee_ml,
        tech_us_ounce: us_ounce + 1,
        tech_im_ounce: im_ounce,
        tech_cups: cups + 1,
        tech_liter: liter,
      };
    } else {
      return { error: "Please Fill All The Fields." };
    }
  }

  /**
   * getCalculationIdiCalculator: Service Method
   * POST: /api/calculators-lol/ldl-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationIdiCalculator(body) {
    const {
      tech_total,
      tech_total_unit,
      tech_high,
      tech_high_unit,
      tech_triglycerides,
      tech_triglycerides_unit,
    } = body;

    function unitConvert(unit, value) {
      value = parseFloat(value);
      if (unit === "mg/dL") {
        return value * 0.02586;
      } else if (unit === "mmol/L") {
        return value;
      }
      return null;
    }

    const totalConverted = unitConvert(tech_total_unit, tech_total);
    const highConverted = unitConvert(tech_high_unit, tech_high);
    const triglyceridesConverted = unitConvert(
      tech_triglycerides_unit,
      tech_triglycerides
    );

    if (
      !isNaN(totalConverted) &&
      !isNaN(highConverted) &&
      !isNaN(triglyceridesConverted)
    ) {
      const ldl_mmoll =
        totalConverted - highConverted - 0.2 * triglyceridesConverted;
      const ldl_mgdL = ldl_mmoll * 38.7;

      return {
        tech_ldl_mmoll: parseFloat(ldl_mmoll.toFixed(2)),
        tech_ldl_mgdL: parseFloat(ldl_mgdL.toFixed(2)),
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /**
   * getCalculationA1cCalculator: Service Method
   * POST: /api/calculators-lol/a1c-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationA1cCalculator(body) {
    const { tech_solve, tech_input, tech_unit1, tech_unit2 } = body;

    let unit1Mapped =
      tech_unit1 === "%" ? "1" : tech_unit1 === "mmol/mol" ? "2" : null;
    let unit2Mapped =
      tech_unit2 === "mmol/L" ? "1" : tech_unit2 === "mg/dL" ? "2" : null;

    function acUnit(unit, value) {
      if (unit === "1") {
        return value;
      } else {
        return value * 0.09148 + 2.152;
      }
    }

    function bloodUnit(unit, value) {
      if (unit === "1") {
        return value * 18.016;
      } else {
        return value;
      }
    }

    if (!isNaN(tech_input)) {
      let jawab, percent;

      if (tech_solve === "1") {
        const adjustedInput = acUnit(unit1Mapped, parseFloat(tech_input));
        jawab = 28.7 * adjustedInput - 46.7;
        percent = adjustedInput;
      } else {
        const adjustedInput = bloodUnit(unit2Mapped, parseFloat(tech_input));
        jawab = (adjustedInput + 46.7) / 28.7;
        percent = jawab;
      }

      return {
        tech_percent: parseFloat(percent.toFixed(2)),
        tech_jawab: parseFloat(jawab.toFixed(2)),
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /**
   * getCalculationIncidenceRateCalculator: Service Method
   * POST: /api/calculators-lol/incidence-rate-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationIncidenceRateCalculator(body) {
    const cases = body.tech_cases?.toString().trim();
    const risk = body.tech_risk?.toString().trim();
    const different_unit = body.tech_different_unit?.toString().trim();
    const population = body.tech_population?.toString().trim();
    const per = body.tech_per?.toString().trim();

    let result = {};

    const isNumeric = (val) => !isNaN(parseFloat(val)) && isFinite(val);

    if (different_unit === "Yes") {
      if (isNumeric(cases) && isNumeric(risk) && isNumeric(population)) {
        const answer =
          (parseFloat(cases) / parseFloat(risk)) * parseFloat(population);
        result.tech_answer = answer;
        result.tech_cases = cases;
        result.tech_risk = risk;
      } else {
        result.error = "Please! Check Your Input.";
      }
    } else if (different_unit === "No") {
      if (isNumeric(cases) && isNumeric(risk) && isNumeric(per)) {
        const answer = (parseFloat(cases) / parseFloat(risk)) * parseFloat(per);
        result.tech_answer = answer;
        result.tech_cases = cases;
        result.tech_risk = risk;
      } else {
        result.error = "Please! Check Your Input.";
      }
    } else {
      result.error = "Invalid 'different_unit' value.";
    }

    return result;
  }

  /**
   * getCalculationItRatioCalculator: Service Method
   * POST: /api/calculators-lol/it-ratio
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationItRatioCalculator(body) {
    const f_input = body.tech_f_input;
    const s_input = body.tech_s_input;

    const isNumeric = (val) => !isNaN(parseFloat(val)) && isFinite(val);

    let results = {};

    if (isNumeric(f_input) && isNumeric(s_input)) {
      const answer = parseFloat(f_input) / parseFloat(s_input);

      // Store the answer in the results object
      results.tech_answer = answer;
    } else {
      results.error = "Please! Check Your Input.";
    }

    return results;
  }

  /**
   * getCalculationMaxHeartRateCalculator: Service Method
   * POST: /api/calculators-lol/max-heart-rate-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMaxHeartRateCalculator(body) {
    const formula = body.formula;
    const age = body.age;

    const isNumeric = (val) => !isNaN(parseFloat(val)) && isFinite(val);

    let results = {};

    if (isNumeric(age)) {
      let answer;

      // Calculate answer based on the formula selected
      if (formula === "1") {
        answer = 205.8 - 0.685 * age;
      } else if (formula === "2") {
        answer = 220 - age;
      } else if (formula === "3") {
        answer = 211 - 0.64 * age;
      } else if (formula === "4") {
        answer = 192 - 0.007 * Math.pow(age, 2);
      } else if (formula === "5") {
        answer = 208 - 0.07 * age;
      }

      // Store the answer in the results object
      results.answer = answer;
    } else {
      results.error = "Please! Check Your Input.";
    }

    return results;
  }

  /**
   * getCalculationPackYearCalculator: Service Method
   * POST: /api/calculators-lol/pack-year-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPackYearCalculator(body) {
    const cigarettes = body.tech_cigarettes;
    const size = body.tech_size;
    const years = body.tech_years;

    const isNumeric = (val) => !isNaN(parseFloat(val)) && isFinite(val);

    let results = {};

    if (isNumeric(cigarettes) && isNumeric(size) && isNumeric(years)) {
      // Calculate the values for PY, PL, and CL
      const PY = (cigarettes / size) * years;
      const PL = cigarettes * 365.24 * years;
      const CL = (cigarettes / size) * 365.24 * years;

      // Store the results in the response object
      results.tech_PY = PY;
      results.tech_PL = PL;
      results.tech_CL = CL;
    } else {
      results.error = "Please! Check Your Input.";
    }

    return results;
  }

  /**
   * getCalculationRuckingCaloriesCalculator: Service Method
   * POST: /api/calculators-lol/rucking-calorie-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRuckingCaloriesCalculator(body) {
    const activities = body.tech_activities;
    const weight = body.tech_weight;
    const time = body.tech_time;

    const isNumeric = (val) => !isNaN(parseFloat(val)) && isFinite(val);

    let results = {};

    if (isNumeric(activities) && isNumeric(weight) && isNumeric(time)) {
      // Convert weight from pounds to kilograms
      const weightInKg = weight / 2.205;

      // Calculate the calories
      const calories = activities * weightInKg * time;

      // Store the results
      results.tech_calories = Math.round(calories);
    } else {
      results.error = "Please! Check Your Input.";
    }

    return results;
  }

  /**
   * getCalculationEbitCalculator: Service Method
   * POST: /api/calculators-lol/ebit-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationEbitCalculator(body) {
    const x = body.tech_x;
    const y = body.tech_y;

    const isNumeric = (val) => !isNaN(parseFloat(val)) && isFinite(val);

    let results = {};

    if (isNumeric(x) && isNumeric(y)) {
      // Calculate EBIT
      const ebit = x - y;

      // Store the results
      results.tech_ebit = ebit;
    } else {
      results.error = "Please fill all fields.";
    }

    return results;
  }

  /**
   * getCalculationStampDutyCalculator: Service Method
   * POST: /api/calculators-lol/stamp-duty-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationStampDutyCalculator(body) {
    let param = {};
    let { tech_unit_type, value, tech_uk_method } = body;

    const ausval = Number(body.tech_ausval);
    let aus_a;
    let aus_b;
    let aus_c;
    let aus_d;
    let v;
    if (tech_unit_type === "uk") {
      value = parseFloat(value);
      if (!isNaN(value)) {
        let a = 0,
          b = 0,
          c = 0,
          d = 0,
          e = 0;
        let as = 0,
          bs = 0,
          cs = 0,
          ds = 0,
          es = 0;
        let stamp_duty = 0;

        if (tech_uk_method === "single") {
          if (value < 125000) {
            param.error = "You don't need to pay stamp duty.";
            return param;
          }
          if (value <= 250000 && value > 125000) {
            bs = value - 125000;
            b = bs * 0.02;
            stamp_duty = b;
          }
          if (value > 250000) {
            b = 2500;
            bs = 125000;
          }
          if (value <= 925000 && value > 250000) {
            cs = value - 250000;
            c = cs * 0.05;
            stamp_duty = c + b;
          }
          if (value > 925000) {
            c = 33750;
            cs = 675000;
          }
          if (value <= 1500000 && value > 925000) {
            ds = value - 925000;
            d = ds * 0.1;
            stamp_duty = d + c + b;
          }
          if (value > 1500000) {
            d = 57500;
            ds = 575000;
            es = value - 1500000;
            e = es * 0.12;
            stamp_duty = e + d + c + b;
          }
        }

        if (tech_uk_method === "add") {
          if (value <= 125000) {
            as = value;
            a = as * 0.03;
            stamp_duty = a;
          }
          if (value > 125000) {
            a = 3750;
            as = 125000;
          }
          if (value <= 250000 && value > 125000) {
            bs = value - 125000;
            b = bs * 0.05;
            stamp_duty = b + a;
          }
          if (value > 250000) {
            b = 6250;
            bs = 125000;
          }
          if (value <= 925000 && value > 250000) {
            cs = value - 250000;
            c = cs * 0.08;
            stamp_duty = c + b + a;
          }
          if (value > 925000) {
            c = 54000;
            cs = 675000;
          }
          if (value <= 1500000 && value > 925000) {
            ds = value - 925000;
            d = ds * 0.13;
            stamp_duty = d + c + b + a;
          }
          if (value > 1500000) {
            d = 74750;
            ds = 575000;
            es = value - 1500000;
            e = es * 0.15;
            stamp_duty = e + d + c + b + a;
          }
        }

        if (tech_uk_method === "first") {
          if (value <= 300000) {
            param.error = "You don't need to pay stamp duty.";
            return param;
          }
          if (value > 500000) {
            a = 5000;
            as = 175000;
          }
          if (value <= 500000 && value > 300000) {
            bs = value - 300000;
            b = bs * 0.05;
            stamp_duty = b + a;
          }
          if (value > 500000) {
            b = 10000;
            bs = 200000;
          }
          if (value <= 925000 && value > 500000) {
            cs = value - 500000;
            c = cs * 0.05;
            stamp_duty = c + b + a;
          }
          if (value > 925000) {
            c = 21250;
            cs = 425000;
          }
          if (value <= 1500000 && value > 925000) {
            ds = value - 925000;
            d = ds * 0.1;
            stamp_duty = d + c + b + a;
          }
          if (value > 1500000) {
            d = 57500;
            ds = 575000;
            es = value - 1500000;
            e = es * 0.12;
            stamp_duty = e + d + c + b + a;
          }
        }

        const percent = ((stamp_duty / value) * 100).toFixed(2);

        param = {
          a: a.toFixed(2),
          as: as.toFixed(2),
          b: b.toFixed(2),
          bs: bs.toFixed(2),
          c: c.toFixed(2),
          cs: cs.toFixed(2),
          d: d.toFixed(2),
          ds: ds.toFixed(2),
          e: e.toFixed(2),
          es: es.toFixed(2),
          percent,
          stamp_duty: stamp_duty.toFixed(2),
          Add: "active",
        };
        return param;
      } else {
        return { error: "Please Fill the Field." };
      }
    }
    if (tech_unit_type === "aus") {
      // Leave this block empty for now as requested
      if (ausval != "") {
        if (body.tech_aus_method === "nsw") {
          let value = ausval;

          if (
            body.tech_first === "no" ||
            body.tech_property === "invest" ||
            body.tech_property === "land" ||
            value > 800000 ||
            body.tech_property === "live"
          ) {
            if (value <= 14000) {
              aus_a = (value / 100) * 1.25;
            } else if (value <= 30000) {
              aus_a = ((value - 14000) / 100) * 1.5 + 175;
            } else if (value <= 81000) {
              aus_a = ((value - 30000) / 100) * 1.75 + 415;
            } else if (value <= 304000) {
              aus_a = ((value - 81000) / 100) * 3.5 + 1307;
            } else if (value <= 1013000) {
              aus_a = ((value - 304000) / 100) * 4.5 + 9112;
            } else if (value < 3040000) {
              aus_a = ((value - 1013000) / 100) * 5.5 + 41017;
            } else {
              aus_a = ((value - 3040000) / 100) * 7.0 + 152502;
            }
          }

          if (
            body.tech_first === "yes" &&
            body.tech_property === "live" &&
            ausval < 800000
          ) {
            if (ausval <= 650000) {
              aus_a = 0;
            } else if (ausval < 800000) {
              aus_a = ausval * (21 / 100) - 136510;
            }
          }

          const aus_b = 219;
          const aus_c = 109.5;
          const aus_d = aus_a + aus_b + aus_c;

          param["tech_aus_a"] = aus_a.toFixed(2);
          param["tech_aus_b"] = aus_b.toFixed(2);
          param["tech_aus_c"] = aus_c.toFixed(2);
          param["tech_aus_d"] = aus_d.toFixed(2);
          param["RESULT"] = 1;
          param["tech_sub"] = "active";
          return param;
        }
        if (body.tech_aus_method === "vic") {
          value = body.tech_ausval;
          if (
            body.tech_first === "no" ||
            body.tech_property === "invest" ||
            body.tech_property === "land" ||
            value > 750000
          ) {
            if (value <= 25000) {
              aus_a = (value / 100) * 1.4;
            }
            if (value <= 130000 && value > 25000) {
              value = value - 25000;
              aus_a = (value / 100) * 2.4;
              aus_a = aus_a + 350;
            }
            if (value <= 960000 && value > 130000) {
              value = value - 130000;
              aus_a = (value / 100) * 6;
              aus_a = aus_a + 2870;
            }
            if (value > 960000) {
              aus_a = (value / 100) * 5.5;
            }
          }
          if (body.tech_property === "live" && body.tech_first === "no") {
            if (value <= 25000) {
              aus_a = (value / 100) * 1.4;
            }
            if (value <= 130000 && value > 25000) {
              value = value - 25000;
              aus_a = (value / 100) * 2.4;
              aus_a = aus_a + 350;
            }
            if (value <= 440000 && value > 130000) {
              value = value - 130000;
              aus_a = (value / 100) * 5;
              aus_a = aus_a + 2870;
            }
            if (value <= 550000 && value > 440000) {
              value = value - 440000;
              aus_a = (value / 100) * 6;
              aus_a = aus_a + 18370;
            }
            if (value <= 960000 && value > 550000) {
              value = value - 550000;
              aus_a = (value / 100) * 6;
              aus_a = aus_a + 28070;
            }
            if (value > 960000) {
              aus_a = (value / 100) * 5.5;
            }
          }
          if (body.tech_first === "yes" && body.tech_property === "live") {
            if (value <= 600000) {
              aus_a = 0;
            }
            if (value > 600000 && value < 605000) {
              aus_a = (value - 600000) * 0.209;
            }
            if (value === 605000) {
              aus_a = 1045;
            }
            if (value > 605000 && value < 610000) {
              value = value - 605000;
              aus_a = value * 0.2129 + 1045;
            }
            if (value === 610000) {
              aus_a = (value - 600000) * 0.2111;
            }
            if (value > 610000 && value < 615000) {
              value = value - 610000;
              aus_a = value * 0.2129 + 2111.33;
            }
            if (value === 615000) {
              aus_a = (value - 600000) * 0.2131;
            }
            if (value > 615000 && value < 620000) {
              value = value - 615000;
              aus_a = value * 0.2195 + 3197.0;
            }
            if (value === 620000) {
              aus_a = 4302.67;
            }
            if (value > 620000 && value < 625000) {
              value = value - 620000;
              aus_a = value * 0.2195 + 4302.67;
            }
            if (value === 625000) {
              aus_a = 5428;
            }
            if (value > 625000 && value < 630000) {
              value = value - 625000;
              aus_a = value * 0.228 + 5428;
            }
            if (value === 630000) {
              aus_a = 6574.0;
            }
            if (value > 630000 && value < 635000) {
              value = value - 630000;
              aus_a = value * 0.232 + 6574;
            }
            if (value === 635000) {
              aus_a = 7739.67;
            }
            if (value > 635000 && value < 640000) {
              value = value - 635000;
              aus_a = value * 0.236 + 7739.67;
            }
            if (value === 640000) {
              aus_a = 8925.33;
            }
            if (value > 640000 && value < 645000) {
              value = value - 640000;
              aus_a = value * 0.2403 + 8925.33;
            }
            if (value === 645000) {
              aus_a = 10131;
            }
            if (value > 645000 && value < 650000) {
              value = value - 645000;
              aus_a = value * 0.2443 + 10131;
            }
            if (value === 650000) {
              aus_a = 11357;
            }
            if (value > 650000 && value < 655000) {
              value = value - 650000;
              aus_a = value * 0.2482 + 11357;
            }
            if (value === 655000) {
              aus_a = 12602.33;
            }
            if (value > 655000 && value < 660000) {
              value = value - 655000;
              aus_a = value * 0.2523 + 12602.33;
            }
            if (value === 660000) {
              aus_a = 13868.0;
            }
            if (value > 660000 && value < 665000) {
              value = value - 660000;
              aus_a = value * 0.2563 + 13868.0;
            }
            if (value === 665000) {
              aus_a = 15153.67;
            }
            if (value > 665000 && value < 670000) {
              value = value - 665000;
              aus_a = value * 0.2603 + 15153.67;
            }
            if (value === 670000) {
              aus_a = 16459.33;
            }
            if (value > 670000 && value < 675000) {
              value = value - 670000;
              aus_a = value * 0.2643 + 16459.33;
            }
            if (value === 675000) {
              aus_a = 17785.0;
            }
            if (value > 675000 && value < 680000) {
              value = value - 675000;
              aus_a = value * 0.2683 + 17785.0;
            }
            if (value === 680000) {
              aus_a = 19130.67;
            }
            if (value > 680000 && value < 685000) {
              value = value - 680000;
              aus_a = value * 0.2723 + 19130.67;
            }
            if (value === 685000) {
              aus_a = 20496.33;
            }
            if (value > 685000 && value < 690000) {
              value = value - 685000;
              aus_a = value * 0.2763 + 20496.33;
            }
            if (value === 690000) {
              aus_a = 21882.0;
            }
            if (value > 690000 && value < 695000) {
              value = value - 690000;
              aus_a = value * 0.2803 + 21882.0;
            }
            if (value === 695000) {
              aus_a = 23287.67;
            }
            if (value > 695000 && value < 700000) {
              value = value - 695000;
              aus_a = value * 0.2843 + 23287.67;
            }
            if (value === 700000) {
              aus_a = 24713.33;
            }
            if (value > 700000 && value < 705000) {
              value = value - 700000;
              aus_a = value * 0.2883 + 24713.33;
            }
            if (value === 705000) {
              aus_a = 26159.0;
            }
            if (value > 705000 && value < 710000) {
              value = value - 705000;
              aus_a = value * 0.2923 + 26159.0;
            }
            if (value === 710000) {
              aus_a = 27624.67;
            }
            if (value > 710000 && value < 715000) {
              value = value - 710000;
              aus_a = value * 0.2963 + 27624.67;
            }
            if (value === 715000) {
              aus_a = 29110.33;
            }
            if (value > 715000 && value < 720000) {
              value = value - 715000;
              aus_a = value * 0.3003 + 29110.33;
            }
            if (value === 720000) {
              aus_a = 30616.0;
            }
            if (value > 720000 && value < 725000) {
              value = value - 720000;
              aus_a = value * 0.3043 + 30616.0;
            }
            if (value === 725000) {
              aus_a = 32141.67;
            }
            if (value > 725000 && value < 730000) {
              value = value - 725000;
              aus_a = value * 0.3083 + 32141.67;
            }
            if (value === 730000) {
              aus_a = 33687.33;
            }
            if (value > 730000 && value < 735000) {
              value = value - 730000;
              aus_a = value * 0.3123 + 33687.33;
            }
            if (value === 735000) {
              aus_a = 35253.0;
            }
            if (value > 735000 && value < 740000) {
              value = value - 735000;
              aus_a = value * 0.3163 + 35253.0;
            }
            if (value === 740000) {
              aus_a = 36838.67;
            }
            if (value > 740000 && value < 745000) {
              value = value - 740000;
              aus_a = value * 0.3203 + 36838.67;
            }
            if (value === 745000) {
              aus_a = 38444.33;
            }
            if (value > 745000 && value < 750000) {
              value = value - 745000;
              aus_a = value * 0.3243 + 38444.33;
            }
            if (value === 750000) {
              aus_a = 40070;
            }
          }
          aus_b = (body.tech_ausval / 1000) * 2.34 + 96.1;
          if (aus_b > 3606) {
            aus_b = 3606;
          }
          aus_c = 116.8;
          aus_d = aus_a + aus_b + aus_c;

          param["tech_aus_a"] = aus_a.toFixed(2);
          param["tech_aus_b"] = aus_b.toFixed(2);
          param["tech_aus_c"] = aus_c.toFixed(2);
          param["tech_aus_d"] = aus_d.toFixed(2);
          param["RESULT"] = 1;
          param["tech_sub"] = "active";
          return param;
        }
        if (body.tech_aus_method === "qld") {
          aus_b = 192;
          if (body.tech_ausval > 180000) {
            aus_b = aus_b + (body.tech_ausval - 180000) * 0.0036;
          }
          aus_c = 192;
          value = body.tech_ausval;
          if (body.tech_property === "live") {
            if (value <= 350000) {
              aus_a = (value / 100) * 1;
            }
            if (value > 350000 && value <= 540000) {
              value = value - 350000;
              aus_a = (value / 100) * 3.5 + 3500;
            }
            if (value > 540000 && value <= 1000000) {
              value = value - 540000;
              aus_a = (value / 100) * 4.5 + 10150;
            }
            if (value > 1000000) {
              value = value - 1000000;
              aus_a = (value / 100) * 5.75 + 30850;
            }
          }
          if (
            body.tech_property === "invest" ||
            body.tech_property === "land"
          ) {
            if (value <= 5000) {
              aus_a = 0;
            }
            if (value > 5000 && value <= 75000) {
              value = value - 5000;
              aus_a = (value / 100) * 1.5;
            }
            if (value > 75000 && value <= 540000) {
              value = value - 75000;
              aus_a = (value / 100) * 3.5 + 1050;
            }
            if (value > 540000 && value <= 1000000) {
              value = value - 540000;
              aus_a = (value / 100) * 4.5 + 17325;
            }
            if (value > 1000000) {
              value = value - 1000000;
              aus_a = (value / 100) * 5.75 + 38025;
            }
          }
          if (body.tech_first === "yes" && body.tech_property === "live") {
            if (aus_a < 8925) {
              aus_a = 0;
            }
            if (aus_a >= 8925 && aus_a < 9100) {
              aus_a = aus_a - 7875;
            }
            if (aus_a >= 9100 && aus_a < 9275) {
              aus_a = aus_a - 7000;
            }
            if (aus_a >= 9275 && aus_a < 9450) {
              aus_a = aus_a - 6125;
            }
            if (aus_a >= 9450 && aus_a < 9625) {
              aus_a = aus_a - 5250;
            }
            if (aus_a >= 9625 && aus_a < 9800) {
              aus_a = aus_a - 4375;
            }
            if (aus_a >= 9800 && aus_a < 9975) {
              aus_a = aus_a - 3500;
            }
            if (aus_a >= 9975 && aus_a < 10150) {
              aus_a = aus_a - 2625;
            }
            if (aus_a >= 10150 && aus_a < 10375) {
              aus_a = aus_a - 1750;
            }
            if (aus_a >= 10375 && aus_a < 10600) {
              aus_a = aus_a - 875;
            }
            if (aus_a >= 10600) {
              aus_a = aus_a - 0;
            }
          }
          aus_d = aus_a + aus_b + aus_c;
          param["tech_aus_a"] = aus_a.toFixed(2);
          param["tech_aus_b"] = aus_b.toFixed(2);
          param["tech_aus_c"] = aus_c.toFixed(2);
          param["tech_aus_d"] = aus_d.toFixed(2);
          param["RESULT"] = 1;
          param["tech_sub"] = "active";
          return param;
        }
        if (body.tech_aus_method === "wa") {
          value = body.tech_ausval;
          if (body.tech_property === "land") {
            if (value <= 80000) {
              aus_a = (value / 100) * 1.9;
            }
            if (value > 80000 && value <= 100000) {
              value = value - 80000;
              aus_a = (value / 100) * 2.85 + 1520;
            }
            if (value > 100000 && value <= 250000) {
              value = value - 100000;
              aus_a = (value / 100) * 3.8 + 2090;
            }
            if (value > 250000 && value <= 500000) {
              value = value - 250000;
              aus_a = (value / 100) * 4.75 + 7790;
            }
            if (value > 500000) {
              value = value - 500000;
              aus_a = (value / 100) * 5.15 + 19665;
            }
          }
          if (
            body.tech_property === "live" ||
            body.tech_property === "invest"
          ) {
            if (value <= 120000) {
              aus_a = (value / 100) * 1.9;
            }
            if (value > 120000 && value <= 150000) {
              value = value - 120000;
              aus_a = (value / 100) * 2.85 + 2280;
            }
            if (value > 150000 && value <= 360000) {
              aus_a = ((value - 150000) / 100) * 3.8 + 3135;
            }
            if (value > 360000 && value <= 725000) {
              aus_a = ((value - 360000) / 100) * 4.75 + 11115;
            }
            if (value > 725000) {
              aus_a = ((value - 725000) / 100) * 5.15 + 28453;
            }
          }
          if (body.tech_first === "yes" && body.tech_property === "live") {
            value = body.tech_ausval;
            if (value <= 430000) {
              aus_a = 0;
            }
            if (value > 430000 && value <= 530000) {
              aus_a = ((value - 430000) / 100) * 19.19;
            }
          }
          if (body.tech_first === "yes" && body.tech_property === "land") {
            value = body.tech_ausval;
            if (value <= 300000) {
              aus_a = 0;
            }
            if (value > 300000 && value <= 400000) {
              aus_a = ((value - 300000) / 100) * 13.01;
            }
          }
          if (body.tech_ausval <= 85000) {
            aus_b = 174.7;
          }
          if (body.tech_ausval > 85000 && body.tech_ausval <= 120000) {
            aus_b = 184.7;
          }
          if (body.tech_ausval > 120000 && body.tech_ausval <= 200000) {
            aus_b = 204.7;
          }
          if (body.tech_ausval > 200000) {
            aus_b = ((body.tech_ausval - 200000) / 100000) * 20 + 204.7;
          }
          aus_c = 174.7;
          aus_d = aus_a + aus_b + aus_c;
          param["tech_aus_a"] = aus_a.toFixed(2);
          param["tech_aus_b"] = aus_b.toFixed(2);
          param["tech_aus_c"] = aus_c.toFixed(2);
          param["tech_aus_d"] = aus_d.toFixed(2);

          param["RESULT"] = 1;
          param["tech_sub"] = "active";
          return param;
        }
        if (body.tech_aus_method === "sa") {
          value = body.tech_ausval;
          if (value <= 12000) {
            aus_a = (value / 100) * 1.0;
          }
          if (value > 12000 && value <= 30000) {
            aus_a = ((value - 12000) / 100) * 2.0 + 120;
          }
          if (value > 30000 && value <= 50000) {
            aus_a = ((value - 30000) / 100) * 3.0 + 480;
          }
          if (value > 50000 && value <= 100000) {
            aus_a = ((value - 50000) / 100) * 3.5 + 1080;
          }
          if (value > 100000 && value <= 200000) {
            aus_a = ((value - 100000) / 100) * 4.0 + 2830;
          }
          if (value > 200000 && value <= 250000) {
            aus_a = ((value - 200000) / 100) * 4.25 + 6830;
          }
          if (value > 250000 && value <= 300000) {
            aus_a = ((value - 250000) / 100) * 4.75 + 8955;
          }
          if (value > 300000 && value <= 500000) {
            aus_a = ((value - 300000) / 100) * 5.0 + 11330;
          }
          if (value > 500000) {
            aus_a = ((value - 500000) / 100) * 5.5 + 21330;
          }
          if (body.tech_first === "yes" && body.tech_property === "live") {
            if (value <= 430000) {
              aus_a = 0;
            }
            if (value > 430000 && value <= 530000) {
              aus_a = ((value - 430000) / 100) * 19.19;
            }
          }
          if (body.tech_first === "yes" && body.tech_property === "land") {
            if (value <= 300000) {
              aus_a = 0;
            }
            if (value > 300000 && value <= 400000) {
              aus_a = ((value - 300000) / 100) * 13.01;
            }
          }
          if (body.tech_ausval <= 5000) {
            aus_b = 163;
          }
          if (body.tech_ausval > 5000 && body.tech_ausval <= 20000) {
            aus_b = 182;
          }
          if (body.tech_ausval > 20000 && body.tech_ausval <= 40000) {
            aus_b = 199;
          }
          if (body.tech_ausval > 40000) {
            val = body.tech_ausval - 500000;
            if (val >= 0) {
              aus_b = (val / 1000) * 82.5 + 280;
            } else {
              aus_b = 280;
            }
          }
          aus_c = 163;
          aus_d = aus_a + aus_b + aus_c;
          param["tech_aus_a"] = aus_a.toFixed(2);
          param["tech_aus_b"] = aus_b.toFixed(2);
          param["tech_aus_c"] = aus_c.toFixed(2);
          param["tech_aus_d"] = aus_d.toFixed(2);
          param["RESULT"] = 1;
          param["tech_sub"] = "active";
          return param;
        }
        if (body.tech_aus_method === "nt") {
          value = body.tech_ausval;
          if (value <= 525000) {
            v = value / 1000;
            aus_a = 0.06571441 * v * v + 15 * v;
          }
          if (value > 525000 && value <= 2999999) {
            aus_a = (value / 100) * 4.95;
          }
          if (value >= 3000000 && value < 5000000) {
            aus_a = (value / 100) * 5.75;
          }
          if (value >= 5000000) {
            aus_a = (value / 100) * 5.95;
          }
          aus_b = aus_c = 149;
          aus_d = aus_a + aus_b + aus_c;
          param["tech_aus_a"] = aus_a.toFixed(2);
          param["tech_aus_b"] = aus_b.toFixed(2);
          param["tech_aus_c"] = aus_c.toFixed(2);
          param["tech_aus_d"] = aus_d.toFixed(2);
          param["RESULT"] = 1;
          param["tech_sub"] = "active";
          return param;
        }
        if (body.tech_aus_method === "act") {
          value = body.tech_ausval;
          if (value <= 200000) {
            aus_a = (value / 100) * 1.3;
          }
          if (value > 200000 && value <= 300000) {
            aus_a = ((value - 200000) / 100) * 2.3 + 2600;
          }
          if (value > 300000 && value <= 500000) {
            aus_a = ((value - 300000) / 100) * 3.6 + 4900;
          }
          if (value > 500000 && value <= 750000) {
            aus_a = ((value - 500000) / 100) * 4.56 + 12100;
          }
          if (value > 750000 && value <= 1000000) {
            aus_a = ((value - 750000) / 100) * 6.1 + 23500;
          }
          if (value > 1000000 && value <= 1455000) {
            aus_a = ((value - 1000000) / 100) * 6.6 + 38750;
          }
          if (value > 1455000) {
            aus_a = (value / 100) * 4.73;
          }
          if (body.tech_first === "yes" && body.tech_property === "live") {
            if (value <= 470000) {
              aus_a = 0;
            }
            if (value > 470000 && value <= 607000) {
              aus_a = ((value - 470000) / 100) * 12.35;
            }
          }
          if (body.tech_first === "yes" && body.tech_property === "land") {
            if (value <= 281200) {
              aus_a = 0;
            }
            if (value > 281200 && value <= 329500) {
              aus_a = ((value - 281200) / 100) * 12.3;
            }
          }
          aus_b = 409.0;
          aus_c = 153.0;
          aus_d = aus_a + aus_b + aus_c;
          param["tech_aus_a"] = aus_a.toFixed(2);
          param["tech_aus_b"] = aus_b.toFixed(2);
          param["tech_aus_c"] = aus_c.toFixed(2);
          param["tech_aus_d"] = aus_d.toFixed(2);
          param["RESULT"] = 1;
          param["tech_sub"] = "active";
          return param;
        }
        if (body.tech_aus_method === "tas") {
          value = body.tech_ausval;
          if (value <= 3000) {
            aus_a = 50;
          }
          if (value > 3000 && value <= 25000) {
            aus_a = ((value - 3000) / 100) * 1.75 + 50;
          }
          if (value > 25000 && value <= 75000) {
            aus_a = ((value - 25000) / 100) * 2.25 + 435;
          }
          if (value > 75000 && value <= 200000) {
            aus_a = ((value - 75000) / 100) * 3.5 + 1560;
          }
          if (value > 200000 && value <= 375000) {
            aus_a = ((value - 200000) / 100) * 4 + 5935;
          }
          if (value > 375000 && value <= 725000) {
            aus_a = ((value - 375000) / 100) * 4.25 + 12935;
          }
          if (value > 725000) {
            aus_a = ((value - 725000) / 100) * 4.5 + 27810;
          }
          aus_b = 212.22;
          aus_c = 138.51;
          aus_d = aus_a + aus_b + aus_c;
          param["tech_aus_a"] = aus_a.toFixed(2);
          param["tech_aus_b"] = aus_b.toFixed(2);
          param["tech_aus_c"] = aus_c.toFixed(2);
          param["tech_aus_d"] = aus_d.toFixed(2);
          param["tech_sub"] = "active";
          return param;
        }
      } else {
        return { error: "Please Enter Purchase Price." };
      }
    }
  }

  /**
   * getCalculationCTRCalculator: Service Method
   * POST: /api/calculators-lol/ctr-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCTRCalculator(body) {
    const impression = body.tech_impression;
    const clicks = body.tech_clicks;
    const param = {};

    if (!isNaN(impression) && !isNaN(clicks)) {
      const ctr = clicks / impression;
      param.tech_ctr = ctr;
      param.tech_impression = impression;
      param.tech_clicks = clicks;
    } else {
      param.error = "Please check your input.";
    }

    return param;
  }

  /**
   * getCalculationContributionMarginCalculator: Service Method
   * POST: /api/calculators-lol/contribution-margin-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationContributionMarginCalculator(body) {
    const selling_price = parseFloat(body.tech_selling_price);
    const variable_cost = parseFloat(body.tech_variable_cost);
    const number_units = parseFloat(body.tech_number_units);
    const fixed_cost = parseFloat(body.tech_fixed_cost);

    const param = {};

    // Validate numeric input
    if (
      !isNaN(selling_price) &&
      !isNaN(variable_cost) &&
      !isNaN(number_units) &&
      !isNaN(fixed_cost)
    ) {
      const contribution_margin =
        selling_price * number_units - variable_cost * number_units;
      const contribution_margin_ratio =
        contribution_margin / (selling_price * number_units);
      const profit = contribution_margin - fixed_cost;

      param.tech_contribution_margin = contribution_margin;
      param.tech_contribution_margin_ratio = contribution_margin_ratio * 100; // in percentage
      param.tech_profit = profit;
    } else {
      param.error = "Please check your input.";
    }

    return param;
  }

  /**
   * getCalculationYoutubeRevenueCalculator: Service Method
   * POST: /api/calculators-lol/youtube-revenue-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationYoutubeRevenueCalculator(body) {
    const video = parseFloat(body.tech_video);
    const average = parseFloat(body.tech_average);
    const click = parseFloat(body.tech_click);

    const param = {};

    if (!isNaN(video) && !isNaN(average) && !isNaN(click)) {
      const averageClicks = video * (click / 100);
      const averageRevenue = averageClicks * average;

      param.tech_averageClicks = averageClicks;
      param.tech_averageRevenue = averageRevenue;
    } else {
      param.error = "Please check your input.";
    }

    return param;
  }

  /**
   * getCalculationBookValueCalculator: Service Method
   * POST: /api/calculators-lol/book-value-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationBookValueCalculator(body) {
    const acquisition = parseFloat(body.tech_acquisition);
    const depreciation = parseFloat(body.tech_depreciation);

    const param = {};

    if (!isNaN(acquisition) && !isNaN(depreciation)) {
      const book = acquisition - depreciation;

      param.tech_book = book;
      param.tech_acquisition = acquisition;
      param.tech_depreciation = depreciation;
    } else {
      param.error = "Please check your input.";
    }

    return param;
  }

  /**
   * getCalculationCostOfGoodsSoldCalculator: Service Method
   * POST: /api/calculators-lol/cost-of-goods-sold-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCostOfGoodsSoldCalculator(body) {
    const inventory = parseFloat(body.tech_inventory);
    const purchases = parseFloat(body.tech_purchases);
    const e_inventory = parseFloat(body.tech_e_inventory);

    const param = {};

    if (!isNaN(inventory) && !isNaN(purchases) && !isNaN(e_inventory)) {
      const COGS = inventory + purchases - e_inventory;
      param.tech_COGS = COGS;
      param.tech_inventory = inventory;
      param.tech_purchases = purchases;
      param.tech_e_inventory = e_inventory;
    } else {
      param.error = "Please check your input.";
    }

    return param;
  }

  /**
   * getCalculationRentIncreaseCalculator: Service Method
   * POST: /api/calculators-lol/rent-increase-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationRentIncreaseCalculator(body) {
    const rent = parseFloat(body.tech_rent);
    const year = parseFloat(body.tech_year);
    let numbers = parseFloat(body.tech_numbers);
    const numbers_unit = (body.tech_numbers_unit || "").trim();

    const param = {};

    // Convert time units to years
    if (numbers_unit === "wks") {
      numbers = numbers / 52.143;
    } else if (numbers_unit === "mos") {
      numbers = numbers / 12;
    }

    if (!isNaN(rent) && !isNaN(year) && !isNaN(numbers)) {
      if (rent === 0) {
        param.error = "Current Annual Rent value cannot be equal to zero.";
        return param;
      }
      if (year === 0) {
        param.error =
          "Average Rent Change Per Year value cannot be equal to zero.";
        return param;
      }
      if (numbers === 0) {
        param.error = "Number Of Years value cannot be equal to zero.";
        return param;
      }

      const years = year / 100;
      const answer = rent * Math.pow(1 + years, numbers);

      param.tech_answer = answer;
      param.tech_rent = rent;
      param.tech_year = year;
      param.tech_numbers = body.tech_numbers;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationPercentOfSaleCalculator: Service Method
   * POST: /api/calculators-lol/percent-of-sales-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPercentOfSaleCalculator(body) {
    const item = parseFloat((body.tech_item || "").toString().trim());
    const sale = parseFloat((body.tech_sale || "").toString().trim());

    const param = {};

    if (!isNaN(item) && !isNaN(sale)) {
      if (sale === 0) {
        param.error = "Total Sales value cannot be equal to zero.";
        return param;
      }

      const answer = (item / sale) * 100;

      param.tech_answer = answer;
      param.tech_item = item;
      param.tech_sale = sale;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationSalvageValueCalculator: Service Method
   * POST: /api/calculators-lol/salvage-value-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationSalvageValueCalculator(body) {
    const original = parseFloat((body.tech_original || "").toString().trim());
    const rate = parseFloat((body.tech_rate || "").toString().trim());
    const year = parseFloat((body.tech_year || "").toString().trim());

    const param = {};

    if (!isNaN(original) && !isNaN(rate) && !isNaN(year)) {
      const rates = rate / 100;
      const answer = original * Math.pow(1 - rates, year);

      param.tech_answer = answer;
      param.tech_original = original;
      param.tech_rate = rate;
      param.tech_year = year;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationRealEstateCommissionCalculator: Service Method
   * POST: /api/calculators-lol/real-estate-commission-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationRealEstateCommissionCalculator(body) {
    const housePrice = parseFloat(
      (body.tech_housePrice || "").toString().trim()
    );
    const commissionRate = parseFloat(
      (body.tech_commissionRate || "").toString().trim()
    );

    const param = {};

    if (!isNaN(housePrice) && !isNaN(commissionRate)) {
      const commissionAmount = (commissionRate / 100) * housePrice;
      const ownerReceives = housePrice - commissionAmount;

      param.tech_commissionAmount = commissionAmount;
      param.tech_ownerReceives = ownerReceives;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationGdpPerCapitaCalculator: Service Method
   * POST: /api/calculators-lol/gdp-per-capita-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationGdpPerCapitaCalculator(body) {
    const real = parseFloat((body.tech_real || "").toString().trim());
    const real_unit = (body.tech_real_unit || "")
      .toString()
      .trim()
      .toLowerCase();
    const population = parseFloat(
      (body.tech_population || "").toString().trim()
    );
    const population_unit = (body.tech_population_unit || "")
      .toString()
      .trim()
      .toLowerCase();

    const param = {};

    function capital(value, unit) {
      switch (unit) {
        case "thousand":
          return value * 1;
        case "million":
          return value * 1000;
        case "billion":
          return value * 1000000;
        default:
          return value;
      }
    }

    if (!isNaN(real) && !isNaN(population)) {
      if (population === 0) {
        param.error = "Please! Check Your Input";
        return param;
      }

      const convertedReal = capital(real, real_unit);
      const convertedPopulation = capital(population, population_unit);

      const answer = convertedReal / convertedPopulation;

      param.tech_answer = answer;
      param.tech_real = real;
      param.tech_real_unit = real_unit;
      param.tech_population = population;
      param.tech_population_unit = population_unit;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationPriceCalculator: Service Method
   * POST: /api/calculators-lol/price-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPriceCalculator(body) {
    const price = parseFloat(body.tech_price);
    const gross = parseFloat(body.tech_gross);
    const param = {};

    if (!isNaN(price) && !isNaN(gross)) {
      if (gross < 0 || gross > 100) {
        param.error = "Enter Margin 0% to 100%";
        return param;
      }

      const grossDecimal = gross / 100;
      const revenue = price / (1 - grossDecimal);
      const gross_profit = revenue * grossDecimal;
      const mark_up = (gross_profit / price) * 100;

      param.tech_revenue = parseFloat(revenue.toFixed(2));
      param.tech_gross_profit = parseFloat(gross_profit.toFixed(2));
      param.tech_mark_up = parseFloat(mark_up.toFixed(2));
      param.tech_price = price;
      param.tech_gross = gross;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationBuyingPowereCalculator: Service Method
   * POST: /api/calculators-lol/buying-power-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBuyingPowereCalculator(body) {
    const amount = parseFloat(body.tech_amount);
    const reference = parseInt(body.tech_reference);
    const target = parseInt(body.tech_target);
    const param = {};

    const data = {
      1913: 9.9,
      1914: 10,
      1915: 10.1,
      1916: 10.9,
      1917: 12.8,
      1918: 15.1,
      1919: 17.3,
      1920: 20,
      1921: 17.9,
      1922: 16.8,
      1923: 17.1,
      1924: 17.1,
      1925: 17.5,
      1926: 17.7,
      1927: 17.4,
      1928: 17.1,
      1929: 17.1,
      1930: 16.7,
      1931: 15.2,
      1932: 13.7,
      1933: 13,
      1934: 13.4,
      1935: 13.7,
      1936: 13.9,
      1937: 14.4,
      1938: 14.1,
      1939: 13.9,
      1940: 14,
      1941: 14.7,
      1942: 16.3,
      1943: 17.3,
      1944: 17.6,
      1945: 18,
      1946: 19.5,
      1947: 22.3,
      1948: 24.1,
      1949: 23.8,
      1950: 24.1,
      1951: 26,
      1952: 26.5,
      1953: 26.7,
      1954: 26.9,
      1955: 26.8,
      1956: 27.2,
      1957: 28.1,
      1958: 28.9,
      1959: 29.1,
      1960: 29.6,
      1961: 29.9,
      1962: 30.2,
      1963: 30.6,
      1964: 31,
      1965: 31.5,
      1966: 32.4,
      1967: 33.4,
      1968: 34.8,
      1969: 36.7,
      1970: 38.8,
      1971: 40.5,
      1972: 41.8,
      1973: 44.4,
      1974: 49.3,
      1975: 53.8,
      1976: 56.9,
      1977: 60.6,
      1978: 65.2,
      1979: 72.6,
      1980: 82.4,
      1981: 90.9,
      1982: 96.5,
      1983: 99.6,
      1984: 103.9,
      1985: 107.6,
      1986: 109.6,
      1987: 113.6,
      1988: 118.3,
      1989: 124,
      1990: 130.7,
      1991: 136.2,
      1992: 140.3,
      1993: 144.5,
      1994: 148.2,
      1995: 152.4,
      1996: 156.9,
      1997: 160.5,
      1998: 163,
      1999: 166.6,
      2000: 172.2,
      2001: 177.1,
      2002: 179.9,
      2003: 184,
      2004: 188.9,
      2005: 195.3,
      2006: 201.6,
      2007: 207.3,
      2008: 215.303,
      2009: 214.537,
      2010: 218.056,
      2011: 224.939,
      2012: 229.594,
      2013: 232.957,
      2014: 236.736,
      2015: 237.017,
      2016: 240.007,
      2017: 245.12,
      2018: 251.107,
      2019: 255.657,
      2020: 258.811,
      2021: 270.97,
    };

    if (!isNaN(amount) && !isNaN(reference) && !isNaN(target)) {
      if (reference < 1913 || reference > 2021) {
        param.error = "The reference year should be between 1913 and 2021.";
        return param;
      }
      if (target < 1913 || target > 2021) {
        param.error = "The target year should be between 1913 and 2021.";
        return param;
      }

      const result = amount * (data[target] / data[reference]);
      param.tech_result = parseFloat(result.toFixed(2));
    } else {
      param.error = "Please! Check Your Input.";
    }

    return param;
  }

  /**
   * getCalculationCrossPriceElasticityCalculator: Service Method
   * POST: /api/calculators-lol/cross-price-elasticity-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCrossPriceElasticityCalculator(body) {
    const { tech_first, tech_second, tech_third, tech_four } = body;

    if (
      !isNaN(tech_first) &&
      isFinite(tech_first) &&
      !isNaN(tech_second) &&
      isFinite(tech_second) &&
      !isNaN(tech_third) &&
      isFinite(tech_third) &&
      !isNaN(tech_four) &&
      isFinite(tech_four)
    ) {
      const lamda_a = tech_first - tech_third;
      const lamda_b = tech_second - tech_four;

      const elasticity =
        ((tech_first + tech_third) / (tech_second + tech_four)) *
        (lamda_b / lamda_a);

      return {
        tech_elasticity: parseFloat(elasticity.toFixed(2)),
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /**
   * getCalculationActualCashValueCalculator: Service Method
   * POST: /api/calculators-lol/cross-price-elasticity-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationActualCashValueCalculator(body) {
    const { tech_price, tech_expected, tech_current } = body;

    if (
      !isNaN(tech_price) &&
      isFinite(tech_price) &&
      !isNaN(tech_expected) &&
      isFinite(tech_expected) &&
      !isNaN(tech_current) &&
      isFinite(tech_current)
    ) {
      if (tech_current > tech_expected) {
        return {
          error:
            "Current life of the item cannot be larger than the expected life of the item.",
        };
      }

      const acv = (tech_price * (tech_expected - tech_current)) / tech_expected;

      return {
        tech_acv: parseFloat(acv.toFixed(2)),
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /**
   * getCalculationNetWorthCalculator: Service Method
   * POST: /api/calculators-lol/net-worth-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationNetWorthCalculator(body) {
    const {
      tech_as_real,
      tech_as_check,
      tech_as_saving,
      tech_as_retire,
      tech_as_car,
      tech_as_other,
      tech_li_real,
      tech_li_card,
      tech_li_loan,
      tech_li_stload,
      tech_li_car,
      tech_li_other,
      res_link,
    } = body;

    // Validate all inputs are numeric
    const allValues = [
      tech_as_real,
      tech_as_check,
      tech_as_saving,
      tech_as_retire,
      tech_as_car,
      tech_as_other,
      tech_li_real,
      tech_li_card,
      tech_li_loan,
      tech_li_stload,
      tech_li_car,
      tech_li_other,
    ];

    const allAreNumeric = allValues.every(
      (value) => !isNaN(value) && isFinite(value)
    );

    if (allAreNumeric) {
      const assets =
        +tech_as_real +
        +tech_as_check +
        +tech_as_saving +
        +tech_as_retire +
        +tech_as_car +
        +tech_as_other;
      const liabilities =
        +tech_li_real +
        +tech_li_card +
        +tech_li_loan +
        +tech_li_stload +
        +tech_li_car +
        +tech_li_other;
      const net_worth = assets - liabilities;

      return {
        tech_assets: parseFloat(assets.toFixed(2)),
        tech_liabilities: parseFloat(liabilities.toFixed(2)),
        tech_net_worth: parseFloat(net_worth.toFixed(2)),
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /**
   * getCalculationCostBasisCalculator: Service Method
   * POST: /api/calculators-lol/cost-basis-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCostBasisCalculator(body) {
    const { tech_stock, tech_shares, tech_prices } = body;

    const shares_values = [];
    const prices_values = [];
    const upr = [];

    if (Array.isArray(tech_shares) && Array.isArray(tech_prices)) {
      for (let i = 0; i < tech_shares.length; i++) {
        const share = tech_shares[i];
        const price = tech_prices[i];

        if (
          isFinite(share) &&
          isFinite(price) &&
          share !== null &&
          price !== null
        ) {
          shares_values.push(Number(share));
          prices_values.push(Number(price));
          upr.push(share * price);
        }
      }

      if (shares_values.length >= 2 && prices_values.length >= 2) {
        const total_shares = shares_values.reduce((a, b) => a + b, 0);
        const cost_basis = upr.reduce((a, b) => a + b, 0) / total_shares;
        const stock_profit = (tech_stock - cost_basis) * total_shares;
        const percentage = ((tech_stock - cost_basis) / cost_basis) * 100;

        return {
          tech_cost_basis: +cost_basis.toFixed(2),
          tech_stock_profit: +stock_profit.toFixed(2),
          tech_percentage: +percentage.toFixed(2),
          total_shares,
          shares_values,
          prices_values,
          tech_arrayLengthshere: shares_values.length + 1,
          tech_arrayLengthprice: prices_values.length + 1,
        };
      } else {
        return {
          error: "At least two stock purchases are required.",
          tech_shares: tech_shares,
          tech_prices: tech_prices,
        };
      }
    } else {
      return {
        error: "Shares and prices must be arrays.",
      };
    }
  }

  /**
   * getCalculationComparativeAdvantageCalculator: Service Method
   * POST: /api/calculators-lol/comparative-advantage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationComparativeAdvantageCalculator(body) {
    const { tech_first, tech_second, tech_third, tech_four } = body;

    if (isFinite(tech_first) && isFinite(tech_second) && isFinite(tech_third)) {
      const tech_X_A = +(tech_second / tech_first).toFixed(2);
      const tech_X_B = +(tech_first / tech_second).toFixed(2);
      const tech_Y_A = +(tech_four / tech_third).toFixed(2);
      const tech_Y_B = +(tech_third / tech_four).toFixed(2);

      return {
        tech_X_A,
        tech_X_B,
        tech_Y_A,
        tech_Y_B,
        tech_first,
        tech_second,
        tech_third,
        tech_four,
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /**
   * getCalculationCurrentRationCalculator: Service Method
   * POST: /api/calculators-lol/current-ratio-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCurrentRationCalculator(body) {
    const tech_assets = Number(body.tech_assets);
    const tech_liabilities = Number(body.tech_liabilities);

    if (isFinite(tech_assets) && isFinite(tech_liabilities)) {
      const tech_answer = tech_assets / tech_liabilities;
      return {
        tech_answer,
        tech_assets,
        tech_liabilities,
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /**
   * getCalculationDeadWeightLossCalculator: Service Method
   * POST: /api/calculators-lol/deadweight-loss-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDeadWeightLossCalculator(body) {
    const tech_original_price = Number(body.tech_original_price);
    const tech_new_price = Number(body.tech_new_price);
    const tech_original_quantity = Number(body.tech_original_quantity);
    const tech_new_quantity = Number(body.tech_new_quantity);

    if (
      isFinite(tech_original_price) &&
      isFinite(tech_new_price) &&
      isFinite(tech_original_quantity) &&
      isFinite(tech_new_quantity)
    ) {
      const tech_total_price = tech_new_price - tech_original_price;
      const tech_total_quantity = tech_original_quantity - tech_new_quantity;
      const tech_dead = tech_total_price * tech_total_quantity;
      const tech_deadweight = tech_dead / 2;

      return {
        tech_deadweight,
        tech_dead,
        tech_total_price,
        tech_total_quantity,
        tech_original_price,
        tech_new_price,
        tech_original_quantity,
        tech_new_quantity,
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /**
   * getCalculationReverSaleTaxCalculator: Service Method
   * POST: /api/calculators-lol/reverse-sales-tax-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationReverSaleTaxCalculator(body) {
    const tech_final = Number(body.tech_final);
    const tech_sale = Number(body.tech_sale);

    if (isFinite(tech_final) && isFinite(tech_sale)) {
      const tech_sales = tech_sale / 100;
      const tech_reverse = tech_final / (1 + tech_sales);

      return {
        tech_reverse,
        tech_final,
        tech_sale,
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /**
   * getCalculationMarginalRevenueCalculator: Service Method
   * POST: /api/calculators-lol/marginal-revenue-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMarginalRevenueCalculator(body) {
    const tech_initial_re = Number(body.tech_initial_re);
    const tech_initial_qu = Number(body.tech_initial_qu);
    const tech_final_re = Number(body.tech_final_re);
    const tech_final_qu = Number(body.tech_final_qu);

    if (
      isFinite(tech_initial_re) &&
      isFinite(tech_initial_qu) &&
      isFinite(tech_final_re) &&
      isFinite(tech_final_qu)
    ) {
      const tech_total_rev = tech_final_re - tech_initial_re;
      const tech_quantity = tech_final_qu - tech_initial_qu;

      // Avoid division by zero
      if (tech_quantity === 0) {
        return {
          error: "Quantity change cannot be zero.",
        };
      }

      const tech_marginal_rev = tech_total_rev / tech_quantity;

      return {
        tech_total_rev,
        tech_quantity,
        tech_marginal_rev,
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /**
   * getCalculationCashBackCalculator: Service Method
   * POST: /api/calculators-lol/cash-back-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCashBackCalculator(body) {
    const tech_purchase = Number(body.tech_purchase);
    const tech_cash = Number(body.tech_cash);

    if (isFinite(tech_purchase) && isFinite(tech_cash)) {
      const tech_answer = tech_purchase * (tech_cash / 100);
      return {
        tech_answer,
        tech_purchase,
        tech_cash,
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /**
   * getCalculationEarningPerShareCalculator: Service Method
   * POST: /api/calculators-lol/earnings-per-share-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationEarningPerShareCalculator(body) {
    const tech_net_income = Number(body.tech_net_income);
    const tech_dividends = Number(body.tech_dividends);
    const tech_common_shares = Number(body.tech_common_shares);

    if (
      isFinite(tech_net_income) &&
      isFinite(tech_dividends) &&
      isFinite(tech_common_shares)
    ) {
      if (tech_common_shares <= 0) {
        return {
          error: "Number of common shares should be an integer greater than 0.",
        };
      }

      const share_income = tech_net_income - tech_dividends;
      const tech_share_dividends = share_income / tech_common_shares;

      return {
        tech_share_dividends,
        tech_net_income,
        tech_dividends,
        tech_common_shares,
      };
    } else {
      return {
        error: "Please! Check Your Input",
      };
    }
  }

  /**
   * getCalculationOptionProfitCalculator: Service Method
   * POST: /api/calculators-lol/earnings-per-share-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationOptionProfitCalculator(body) {
    const tech_ot = String(body.tech_ot).trim().toLowerCase();
    const tech_sp = Number(body.tech_sp);
    const tech_op = Number(body.tech_op);
    const tech_stp = Number(body.tech_stp);
    const tech_nc = Number(body.tech_nc);

    if (
      tech_ot &&
      isFinite(tech_sp) &&
      isFinite(tech_op) &&
      isFinite(tech_stp) &&
      isFinite(tech_nc) &&
      tech_sp >= 0 &&
      tech_op >= 0 &&
      tech_stp >= 0 &&
      tech_nc >= 0
    ) {
      const tech_ec = tech_nc * 100;
      let tech_ans;

      if (tech_ot === "c") {
        tech_ans = (tech_sp - tech_stp - tech_op) * tech_ec;
      } else if (tech_ot === "p") {
        tech_ans = (tech_stp - (tech_sp + tech_op)) * tech_ec;
      } else {
        return {
          error: 'Invalid option type. Use "c" for call or "p" for put.',
        };
      }

      return {
        tech_ans,
        tech_ot,
        tech_sp,
        tech_op,
        tech_stp,
        tech_nc,
        tech_ec,
      };
    } else {
      return {
        error: "Please! Check Your Input",
      };
    }
  }

  /**
   * getCalculationDividendYieldCalculator: Service Method
   * POST: /api/calculators-lol/dividend-yield-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDividendYieldCalculator(body) {
    const tech_first = Number(body.tech_first); // Dividends per period
    const tech_operations = String(body.tech_operations); // 1=Annual, 2=Semi-Annual, 3=Quarterly, 4=Monthly
    const tech_second = Number(body.tech_second); // Share price

    if (isFinite(tech_first) && isFinite(tech_second)) {
      if (tech_first < 0) {
        return { error: "Dividends per period should not be negative." };
      }

      if (tech_second < 0) {
        return { error: "Share price should not be negative." };
      }

      let tech_annual_div = 0;

      switch (tech_operations) {
        case "1":
          tech_annual_div = tech_first;
          break;
        case "2":
          tech_annual_div = tech_first * 2;
          break;
        case "3":
          tech_annual_div = tech_first * 4;
          break;
        case "4":
          tech_annual_div = tech_first * 12;
          break;
        default:
          return { error: "Invalid operation type. Use 1, 2, 3, or 4." };
      }

      const tech_divide = tech_annual_div / tech_second;
      const tech_dividend_yield = tech_divide * 100;

      return {
        tech_annual_div,
        tech_dividend_yield,
      };
    } else {
      return { error: "Please! Check Your Input" };
    }
  }

  /**
   * getCalculationMarkdownCalculator: Service Method
   * POST: /api/calculators-lol/markdown-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMarkdownCalculator(body) {
    const tech_osp = Number(body.tech_osp); // Original Selling Price
    const tech_asp = Number(body.tech_asp); // Actual Selling Price

    if (
      isFinite(tech_osp) &&
      isFinite(tech_asp) &&
      tech_osp > 0 &&
      tech_asp > 0
    ) {
      if (tech_asp < tech_osp) {
        const tech_markdown = tech_osp - tech_asp;
        const tech_markdown_percent = (tech_markdown / tech_asp) * 100;

        return {
          tech_markdown,
          tech_markdown_percent: parseFloat(tech_markdown_percent.toFixed(2)),
        };
      } else {
        return {
          error: "Original Selling Price > Actual Selling Price",
        };
      }
    } else {
      return {
        error: "Please! Check Your Input",
      };
    }
  }

  /**
   * getCalculationAGICalculator: Service Method
   * POST: /api/calculators-lol/agi-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationAGICalculator(body) {
    // Collect and parse all 24 inputs
    const inputs = [];
    for (let i = 1; i <= 24; i++) {
      const key = `tech_input${i}`;
      const value = Number(body[key]);
      if (!isFinite(value)) {
        return {
          error: "Please! Check Your Input",
        };
      }
      inputs.push(value);
    }

    // Calculate add1 (sum of input1 to input13)
    const tech_add1 = inputs.slice(0, 13).reduce((sum, val) => sum + val, 0);
    // Calculate add2 (sum of input14 to input24)
    const tech_add2 = inputs.slice(13).reduce((sum, val) => sum + val, 0);
    // Subtract
    const tech_minus = tech_add1 - tech_add2;

    return {
      tech_add1,
      tech_add2,
      tech_minus,
    };
  }

  /**
   * getCalculationMPCCalculator: Service Method
   * POST: /api/calculators-lol/mpc-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMPCCalculator(body) {
    const param = {};
    const income = Number(body.tech_income);
    const save = Number(body.tech_save);

    function setVeri(inss, sv) {
      return isFinite(inss) && isFinite(sv);
    }

    function getAns(income, save) {
      if (income === 0) {
        throw new Error("Division by zero.");
      }
      return save / income;
    }

    try {
      if (setVeri(income, save)) {
        const ans = getAns(income, save);
        param.tech_ans = parseFloat(ans.toFixed(4));
        return param;
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }
    } catch (e) {
      param.error = "Please! Check Your Input";
      return param;
    }
  }

  /**
   * getCalculationMaximumProfitCalculator: Service Method
   * POST: /api/calculators-lol/maximum-profit-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMaximumProfitCalculator(body) {
    const param = {};
    const p = Number(body.tech_p);
    const Q = Number(body.tech_Q);
    const C = Number(body.tech_C);

    if (isFinite(p) && isFinite(Q) && isFinite(C)) {
      const R = p * Q;
      const cost = C * p;
      const profit = R - cost;

      param.tech_R = R;
      param.tech_profit = profit;
      return param;
    } else {
      param.error = "Please! Check Your Input";
      return param;
    }
  }

  /**
   * getCalculationIncomeElasticityOfDemandCalculator: Service Method
   * POST: /api/calculators-lol/income-elasticity-of-demand-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationIncomeElasticityOfDemandCalculator(body) {
    const param = {};
    const { tech_i_p, tech_n_p, tech_i_q, tech_n_q } = body;

    // Helper function to round numbers
    const round = (num, dec = 2) => {
      return Math.round(num * Math.pow(10, dec)) / Math.pow(10, dec);
    };

    // Validate if all inputs are numbers
    if (
      isFinite(tech_i_p) &&
      isFinite(tech_n_p) &&
      isFinite(tech_i_q) &&
      isFinite(tech_n_q)
    ) {
      const pi = (tech_n_q - tech_i_q) / tech_i_q;
      const pq = (tech_n_p - tech_i_p) / tech_i_p;
      const eq = (tech_n_q - tech_i_q) / (tech_n_q + tech_i_q);
      const ep = (tech_n_p - tech_i_p) / (tech_n_p + tech_i_p);
      const ie = eq / ep;
      const ir = tech_i_p * tech_i_q;
      const fr = tech_n_p * tech_n_q;
      const R = round(tech_i_p * tech_i_q - tech_n_p * tech_n_q, 2);

      let rs = "";
      if (R > 0) {
        rs = "Elastic Demand";
      } else if (R === 1) {
        rs = "Unitary Elastic";
      } else if (R < 1) {
        rs = "Inelastic Demand";
      } else if (R === 0) {
        rs = "Perfectly Inelastic";
      } else {
        rs = "Perfectly Elastic";
      }

      const rin = round(((fr - ir) / ir) * 100, 2);
      const cq = round(pi, 2);
      const cp = round(pq, 2);

      param.ie = ie;
      param.ir = ir;
      param.fr = fr;
      param.sr = rs;
      param.cq = cq;
      param.cp = cp;
      param.rin = rin;

      return param;
    } else {
      param.error = "Please fill all fields.";
      return param;
    }
  }

  /**
   * getCalculationProfitMarginCalculator: Service Method
   * POST: /api/calculators-lol/profit-margin-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationProfitMarginCalculator(body) {
    const param = {};
    const { tech_x, tech_y, tech_method } = body;

    if (typeof tech_x === "number" && typeof tech_y === "number") {
      if (tech_method === "Gross") {
        const margin = parseFloat(
          ((100 * (tech_y - tech_x)) / tech_y).toFixed(2)
        );
        const profit = tech_y - tech_x;
        const mark = parseFloat(((profit / tech_x) * 100).toFixed(2));

        param.tech_margin = `${margin} %`;
        param.tech_profit = `${profit}`;
        param.tech_mark = `${mark} %`;

        return param;
      }

      if (tech_method === "Net") {
        const margin = parseFloat(((tech_y / tech_x) * 100).toFixed(2));
        param.tech_margin = `${margin} %`;
        return param;
      }

      if (tech_method === "Operating") {
        const margin = parseFloat(((tech_y / tech_x) * 100).toFixed(2));
        param.tech_operating = `${margin} %`;
        return param;
      }
    } else {
      param.error = "Please fill all fields.";
      return param;
    }
  }

  /**
   * getCalculationEnterpriseValueCalculator: Service Method
   * POST: /api/calculators-lol/enterprise-value-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationEnterpriseValueCalculator(body) {
    const param = {};
    const { tech_cs, tech_ps, tech_mvd, tech_mi, tech_ce } = body;

    if (
      typeof tech_cs === "number" &&
      typeof tech_ps === "number" &&
      typeof tech_mvd === "number" &&
      typeof tech_mi === "number" &&
      typeof tech_ce === "number"
    ) {
      const EV = tech_cs + tech_ps + tech_mvd + tech_mi - tech_ce;
      param.tech_ev = EV.toLocaleString(); // Format the result as a number with commas
      return param;
    } else {
      param.error = "Please fill all fields.";
      return param;
    }
  }

  /**
   * getCalculationCPCalculator: Service Method
   * POST: /api/calculators-lol/cpc-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCPCalculator(body) {
    const param = {};
    const { tech_method, tech_x, tech_y } = body;

    if (
      tech_method &&
      typeof tech_x === "number" &&
      typeof tech_y === "number"
    ) {
      let cpc;
      if (tech_method === "cpc") {
        cpc = tech_x / tech_y;
        param.ans = `${cpc}`;
      } else if (tech_method === "cost") {
        cpc = tech_x * tech_y;
        param.ans = `${cpc}`;
      } else if (tech_method === "click") {
        cpc = tech_x / tech_y;
        param.ans = cpc;
      }
      return param;
    } else {
      param.error = "Please fill all fields.";
      return param;
    }
  }

  /**
   * getCalculationOutTheDoorPriceCalculator: Service Method
   * POST: /api/calculators-lol/out-the-door-price-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationOutTheDoorPriceCalculator(body) {
    const param = {};
    const { tech_car, tech_dealership, tech_taxes } = body;

    if (
      typeof tech_car === "number" &&
      typeof tech_dealership === "number" &&
      typeof tech_taxes === "number"
    ) {
      const answer = tech_car + tech_dealership + tech_taxes;
      param.tech_answer = answer;
      param.tech_car = tech_car;
      param.tech_dealership = tech_dealership;
      param.tech_taxes = tech_taxes;
      return param;
    } else {
      param.error = "Please! Check Your Input";
      return param;
    }
  }

  /**
   * getCalculationSalaryCalculator: Service Method
   * POST: /api/calculators-lol/salary-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSalaryCalculator(body) {
    const param = {};

    const salary = parseFloat(body.salary);
    const week_hours = parseFloat(body.hours);
    const week_day = parseFloat(body.days);
    const holidays = parseFloat(body.holidays) || 0;
    const vacation = parseFloat(body.vacation) || 0;
    const total_leaves = holidays + vacation;

    if (!isNaN(salary) && !isNaN(week_hours)) {
      const yearly_hours = week_hours * 52;
      const daily_hours = week_hours / week_day;

      let hourly, daily, week, bi_week, yearly, monthly, sami_month, quarterly;
      let a_hourly,
        a_daily,
        a_week,
        a_bi_week,
        a_monthly,
        a_sami_month,
        a_quarterly,
        a_yearly;

      if (body.per === "Hourly") {
        hourly = salary;
        daily = +(salary * daily_hours).toFixed(2);
        week = +(week_hours * salary).toFixed(2);
        bi_week = +(week * 2).toFixed(2);
        yearly = +(yearly_hours * salary).toFixed(2);
        monthly = +(yearly / 12).toFixed(2);
        sami_month = +(monthly / 2).toFixed(2);
        quarterly = +(yearly / 4).toFixed(2);
      } else if (body.per === "Daily") {
        daily = salary;
        hourly = +(salary / daily_hours).toFixed(2);
        week = +(week_hours * hourly).toFixed(2);
        bi_week = +(week * 2).toFixed(2);
        yearly = +(yearly_hours * hourly).toFixed(2);
        monthly = +(yearly / 12).toFixed(2);
        sami_month = +(monthly / 2).toFixed(2);
        quarterly = +(yearly / 4).toFixed(2);
      } else if (body.per === "Weekly") {
        a_week = salary;
        a_hourly = +(a_week / week_hours).toFixed(2);
        a_daily = +(a_hourly * daily_hours).toFixed(2);
        a_bi_week = +(a_week * 2).toFixed(2);
        a_yearly = +(yearly_hours * a_hourly).toFixed(2);
        a_monthly = +(a_yearly / 12).toFixed(2);
        a_sami_month = +(a_monthly / 2).toFixed(2);
        a_quarterly = +(a_yearly / 4).toFixed(2);
      } else if (body.per === "Bi-Weekly") {
        a_bi_week = salary;
        a_week = +(a_bi_week * 2).toFixed(2);
        a_hourly = +(a_week / week_hours).toFixed(2);
        a_daily = +(a_hourly * daily_hours).toFixed(2);
        a_yearly = +(yearly_hours * a_hourly).toFixed(2);
        a_monthly = +(a_yearly / 12).toFixed(2);
        a_sami_month = +(a_monthly / 2).toFixed(2);
        a_quarterly = +(a_yearly / 4).toFixed(2);
      } else if (body.per === "Semi-Monthly") {
        a_sami_month = salary;
        a_monthly = +(a_sami_month * 2).toFixed(2);
        a_yearly = +(a_monthly * 12).toFixed(2);
        a_quarterly = +(a_yearly / 4).toFixed(2);
        a_hourly = +(a_yearly / yearly_hours).toFixed(2);
        a_daily = +(a_hourly * daily_hours).toFixed(2);
        a_week = +(week_hours * a_daily).toFixed(2);
        a_bi_week = +(a_week * 2).toFixed(2);
      } else if (body.per === "Monthly") {
        a_yearly = +(salary * 12).toFixed(2);
        a_quarterly = +(a_yearly / 4).toFixed(2);
        a_sami_month = +(salary / 2).toFixed(2);
        a_hourly = +(a_yearly / yearly_hours).toFixed(2);
        a_week = +(week_hours * a_hourly).toFixed(2);
        a_bi_week = +(a_week * 2).toFixed(2);
        a_daily = +(a_hourly * daily_hours).toFixed(2);
        a_monthly = salary;
      } else if (body.per === "Quarterly") {
        a_quarterly = salary;
        a_yearly = +(a_quarterly * 4).toFixed(2);
        a_hourly = +(a_yearly / yearly_hours).toFixed(2);
        a_daily = +(a_hourly * daily_hours).toFixed(2);
        a_week = +(week_hours * a_daily).toFixed(2);
        a_bi_week = +(a_week / 2).toFixed(2);
        a_monthly = +(a_yearly / 12).toFixed(2);
        a_sami_month = +(a_monthly / 2).toFixed(2);
      } else if (body.per === "Annual") {
        a_yearly = salary;
        a_hourly = +(a_yearly / yearly_hours).toFixed(2);
        a_daily = +(a_hourly * daily_hours).toFixed(2);
        a_week = +(week_hours * a_hourly).toFixed(2);
        a_bi_week = +(a_week * 2).toFixed(2);
        a_monthly = +(a_yearly / 12).toFixed(2);
        a_sami_month = +(a_monthly / 2).toFixed(2);
        a_quarterly = +(a_yearly * 4).toFixed(2);
      }
      if (total_leaves !== 0) {
        if (body.per === "Hourly" || body.per === "Daily") {
          const sub_salary = daily * total_leaves;
          a_yearly = +(yearly - sub_salary).toFixed(2);
          a_hourly = +(a_yearly / yearly_hours).toFixed(2);
          a_quarterly = +(a_yearly / 4).toFixed(2);
          a_monthly = +(a_yearly / 12).toFixed(2);
          a_sami_month = +(a_monthly / 2).toFixed(2);
          a_daily = +(a_hourly * daily_hours).toFixed(2);
          a_week = +(week_hours * a_hourly).toFixed(2);
          a_bi_week = +(a_week * 2).toFixed(2);
        } else {
          const hh = (260 - total_leaves) / 5;
          hourly = +(a_monthly / ((hh / 12) * week_hours)).toFixed(2);
          yearly = +(hourly * yearly_hours).toFixed(2);
          quarterly = +(yearly / 4).toFixed(2);
          monthly = +(yearly / 12).toFixed(2);
          sami_month = +(monthly / 2).toFixed(2);
          daily = +(hourly * daily_hours).toFixed(2);
          week = +(week_hours * hourly).toFixed(2);
          bi_week = +(week * 2).toFixed(2);
        }
      } else {
        if (body.per === "Hourly" || body.per === "Daily") {
          a_yearly = yearly;
          a_quarterly = quarterly;
          a_monthly = monthly;
          a_sami_month = sami_month;
          a_bi_week = bi_week;
          a_week = week;
          a_daily = daily;
          a_hourly = hourly;
        } else {
          yearly = a_yearly;
          quarterly = a_quarterly;
          monthly = a_monthly;
          sami_month = a_sami_month;
          bi_week = a_bi_week;
          week = a_week;
          daily = a_daily;
          hourly = a_hourly;
        }
      }

      let tax;
      if (!isNaN(body.tax)) {
        if (body.are === 1) {
          tax = body.tax / 100;
        } else {
          tax = 1 - body.tax / 100;
        }
      }

      Object.assign(param, {
        Hourly: +hourly.toFixed(2),
        Daily: daily,
        Week: week,
        Bi_week: bi_week,
        Monthly: monthly,
        Sami_month: sami_month,
        Quarterly: quarterly,
        Yearly: yearly,
        a_Hourly: +a_hourly.toFixed(2),
        a_Daily: a_daily,
        a_Week: a_week,
        a_Bi_week: a_bi_week,
        a_Monthly: a_monthly,
        a_Sami_month: a_sami_month,
        a_Quarterly: a_quarterly,
        a_Yearly: a_yearly,
        RESULT: 1,
      });

      if (typeof tax !== "undefined") {
        param.tax = tax;
      }

      return param;
    } else {
      return {
        error: "Please fill all fields.",
      };
    }
  }

  /**
   * getCalculationIBMCalculator: Service Method
   * POST: /api/calculators-lol/bmi-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationIBMCalculator(body) {
    // const { age, height_cm, ft_in, weight, stage, gender, unit_type } = body;

    let age = body.tech_age;
    let height_cm = body.tech_height_cm;
    let ft_in = body.tech_ft_in;
    let weight = body.tech_weight;
    let stage = body.tech_stage;
    let gender = body.tech_gender;
    let unit_type = body.tech_unit_type;

    let param = {};
    let result = {};
    let height_in;

    if (isNaN(weight)) {
      param.error = "Please Check Your Input.";
      return param;
    }

    if (age > 20) {
      param.error = "Age value Must be less than or equal to 20 ";
      return param;
    }

    let heightInCm = height_cm;

    if (unit_type === "lbs") {
      if (!ft_in) {
        param.error = "Please Select Height";
        return param;
      }
      heightInCm = ft_in * 2.54;
    } else {
      if (!height_cm) {
        param.error = "Please Enter Height";
        return param;
      }
      weight = weight * 2.205; // Convert weight to lbs
    }

    const heightInInches = Math.round(heightInCm / 2.54);
    const bmi = (weight * 703) / (heightInInches * heightInInches);
    const roundBmi = Math.round(bmi * 100) / 100;

    if (stage == "child") {
      const n = [
        50, 50.399, 50.798, 51.197, 51.595, 51.994, 52.392, 52.79, 53.188,
        53.586, 53.983, 54.38, 54.776, 55.172, 55.567, 55.962, 56.356, 56.749,
        57.142, 57.535, 57.926, 58.317, 58.706, 59.095, 59.483, 59.871, 60.257,
        60.642, 61.026, 61.409, 61.791, 62.172, 62.552, 62.93, 63.307, 63.683,
        64.058, 64.431, 64.803, 65.173, 65.542, 65.91, 66.276, 66.64, 67.003,
        67.364, 67.724, 68.082, 68.439, 68.793, 69.146, 69.497, 69.847, 70.194,
        70.54, 70.884, 71.226, 71.566, 71.904, 72.24, 72.575, 72.907, 73.237,
        73.565, 73.891, 74.215, 74.537, 74.857, 75.175, 75.49, 75.804, 76.115,
        76.424, 76.73, 77.035, 77.337, 77.637, 77.935, 78.23, 78.524, 78.814,
        79.103, 79.389, 79.673, 79.955, 80.234, 80.511, 80.785, 81.057, 81.327,
        81.594, 81.859, 82.121, 82.381, 82.639, 82.894, 83.147, 83.398, 83.646,
        83.891, 84.134, 84.375, 84.614, 84.849, 85.083, 85.314, 85.543, 85.769,
        85.993, 86.214, 86.433, 86.65, 86.864, 87.076, 87.286, 87.493, 87.698,
        87.9, 88.1, 88.298, 88.493, 88.686, 88.877, 89.065, 89.251, 89.435,
        89.617, 89.796, 89.973, 90.147, 90.32, 90.49, 90.658, 90.824, 90.988,
        91.149, 91.308, 91.466, 91.621, 91.774, 91.924, 92.073, 92.22, 92.364,
        92.507, 92.647, 92.785, 92.922, 93.056, 93.189, 93.319, 93.448, 93.574,
        93.699, 93.822, 93.943, 94.062, 94.179, 94.295, 94.408, 94.52, 94.63,
        94.738, 94.845, 94.95, 95.053, 95.154, 95.254, 95.352, 95.449, 95.543,
        95.637, 95.728, 95.818, 95.907, 95.994, 96.08, 96.164, 96.246, 96.327,
        96.407, 96.485, 96.562, 96.638, 96.712, 96.784, 96.856, 96.926, 96.995,
        97.062, 97.128, 97.193, 97.257, 97.32, 97.381, 97.441, 97.5, 97.558,
        97.615, 97.67, 97.725, 97.778, 97.831, 97.882, 97.932, 97.982, 98.03,
        98.077, 98.124, 98.169, 98.214, 98.257, 98.3, 98.341, 98.382, 98.422,
        98.461, 98.5, 98.537, 98.574, 98.61, 98.645, 98.679, 98.713, 98.745,
        98.778, 98.809, 98.84, 98.87, 98.899, 98.928, 98.956, 98.983, 99.01,
        99.036, 99.061, 99.086, 99.111, 99.134, 99.158, 99.18, 99.202, 99.224,
        99.245, 99.266, 99.286, 99.305, 99.324, 99.343, 99.361, 99.379, 99.396,
        99.413, 99.43, 99.446, 99.461, 99.477, 99.492, 99.506, 99.52, 99.534,
        99.547, 99.56, 99.573, 99.585, 99.598, 99.609, 99.621, 99.632, 99.643,
        99.653, 99.664, 99.674, 99.683, 99.693, 99.702, 99.711, 99.72, 99.728,
        99.736, 99.744, 99.752, 99.76, 99.767, 99.774, 99.781, 99.788, 99.795,
        99.801, 99.807, 99.813, 99.819, 99.825, 99.831, 99.836, 99.841, 99.846,
        99.851, 99.856, 99.861, 99.865, 99.869, 99.874, 99.878, 99.882, 99.886,
        99.889, 99.893, 99.896, 99.9,
      ];

      let L, M, S, zScore, thisPercentile;

      const ageMonths = age * 12;

      if (gender == "Male") {
        if (ageMonths >= 24 && ageMonths < 25) {
          L = -1.982373595;
          M = 16.54777487;
          S = 0.080127429;
        } else if (ageMonths >= 25 && ageMonths < 26) {
          L = -1.924100169;
          M = 16.49442763;
          S = 0.079233994;
        } else if (ageMonths >= 26 && ageMonths < 27) {
          L = -1.86549793;
          M = 16.44259552;
          S = 0.078389356;
        } else if (ageMonths >= 27 && ageMonths < 28) {
          L = -1.807261899;
          M = 16.3922434;
          S = 0.077593501;
        } else if (ageMonths >= 28 && ageMonths < 29) {
          L = -1.750118905;
          M = 16.34333654;
          S = 0.076846462;
        } else if (ageMonths >= 29 && ageMonths < 30) {
          L = -1.69481584;
          M = 16.29584097;
          S = 0.076148308;
        } else if (ageMonths >= 30 && ageMonths < 31) {
          L = -1.642106779;
          M = 16.24972371;
          S = 0.075499126;
        } else if (ageMonths >= 31 && ageMonths < 32) {
          L = -1.592744414;
          M = 16.20495268;
          S = 0.074898994;
        } else if (ageMonths >= 32 && ageMonths < 33) {
          L = -1.547442391;
          M = 16.16149871;
          S = 0.074347997;
        } else if (ageMonths >= 33 && ageMonths < 34) {
          L = -1.506902601;
          M = 16.11933258;
          S = 0.073846139;
        } else if (ageMonths >= 34 && ageMonths < 35) {
          L = -1.471770047;
          M = 16.07842758;
          S = 0.07339337;
        } else if (ageMonths >= 35 && ageMonths < 36) {
          L = -1.442628957;
          M = 16.03875896;
          S = 0.072989551;
        } else if (ageMonths >= 36 && ageMonths < 37) {
          L = -1.419991255;
          M = 16.00030401;
          S = 0.072634432;
        } else if (ageMonths >= 37 && ageMonths < 38) {
          L = -1.404277619;
          M = 15.96304277;
          S = 0.072327649;
        } else if (ageMonths >= 38 && ageMonths < 39) {
          L = -1.39586317;
          M = 15.92695418;
          S = 0.07206864;
        } else if (ageMonths >= 39 && ageMonths < 40) {
          L = -1.394935252;
          M = 15.89202582;
          S = 0.071856805;
        } else if (ageMonths >= 40 && ageMonths < 41) {
          L = -1.401671596;
          M = 15.85824093;
          S = 0.071691278;
        } else if (ageMonths >= 41 && ageMonths < 42) {
          L = -1.416100312;
          M = 15.82558822;
          S = 0.071571093;
        } else if (ageMonths >= 42 && ageMonths < 43) {
          L = -1.438164899;
          M = 15.79405728;
          S = 0.071495113;
        } else if (ageMonths >= 43 && ageMonths < 44) {
          L = -1.467669032;
          M = 15.76364255;
          S = 0.071462106;
        } else if (ageMonths >= 44 && ageMonths < 45) {
          L = -1.504376347;
          M = 15.73433668;
          S = 0.071470646;
        } else if (ageMonths >= 45 && ageMonths < 46) {
          L = -1.547942838;
          M = 15.70613566;
          S = 0.071519218;
        } else if (ageMonths >= 46 && ageMonths < 47) {
          L = -1.597896397;
          M = 15.67904062;
          S = 0.071606277;
        } else if (ageMonths >= 47 && ageMonths < 48) {
          L = -1.653732283;
          M = 15.65305192;
          S = 0.071730167;
        } else if (ageMonths >= 48 && ageMonths < 49) {
          L = -1.714869347;
          M = 15.62817269;
          S = 0.071889214;
        } else if (ageMonths >= 49 && ageMonths < 50) {
          L = -1.780673181;
          M = 15.604408;
          S = 0.072081737;
        } else if (ageMonths >= 50 && ageMonths < 51) {
          L = -1.850468473;
          M = 15.58176458;
          S = 0.072306081;
        } else if (ageMonths >= 51 && ageMonths < 52) {
          L = -1.923551865;
          M = 15.56025067;
          S = 0.072560637;
        } else if (ageMonths >= 52 && ageMonths < 53) {
          L = -1.999220429;
          M = 15.5398746;
          S = 0.07284384;
        } else if (ageMonths >= 53 && ageMonths < 54) {
          L = -2.076707178;
          M = 15.52064993;
          S = 0.073154324;
        } else if (ageMonths >= 54 && ageMonths < 55) {
          L = -2.155348017;
          M = 15.50258427;
          S = 0.073490667;
        } else if (ageMonths >= 55 && ageMonths < 56) {
          L = -2.234438552;
          M = 15.48568973;
          S = 0.073851672;
        } else if (ageMonths >= 56 && ageMonths < 57) {
          L = -2.313321723;
          M = 15.46997718;
          S = 0.074236235;
        } else if (ageMonths >= 57 && ageMonths < 58) {
          L = -2.391381273;
          M = 15.45545692;
          S = 0.074643374;
        } else if (ageMonths >= 58 && ageMonths < 59) {
          L = -2.468032491;
          M = 15.44213961;
          S = 0.075072264;
        } else if (ageMonths >= 59 && ageMonths < 60) {
          L = -2.542781541;
          M = 15.43003207;
          S = 0.075522104;
        } else if (ageMonths >= 60 && ageMonths < 61) {
          L = -2.61516595;
          M = 15.41914163;
          S = 0.07599225;
        } else if (ageMonths >= 61 && ageMonths < 62) {
          L = -2.684789516;
          M = 15.40947356;
          S = 0.076482128;
        } else if (ageMonths >= 62 && ageMonths < 63) {
          L = -2.751316949;
          M = 15.40103139;
          S = 0.076991232;
        } else if (ageMonths >= 63 && ageMonths < 64) {
          L = -2.81445945;
          M = 15.39381785;
          S = 0.077519149;
        } else if (ageMonths >= 64 && ageMonths < 65) {
          L = -2.87402476;
          M = 15.38783094;
          S = 0.07806539;
        } else if (ageMonths >= 65 && ageMonths < 66) {
          L = -2.92984048;
          M = 15.38306945;
          S = 0.078629592;
        } else if (ageMonths >= 66 && ageMonths < 67) {
          L = -2.981796828;
          M = 15.37952958;
          S = 0.079211369;
        } else if (ageMonths >= 67 && ageMonths < 68) {
          L = -3.029831343;
          M = 15.37720582;
          S = 0.079810334;
        } else if (ageMonths >= 68 && ageMonths < 69) {
          L = -3.073924224;
          M = 15.37609107;
          S = 0.080426086;
        } else if (ageMonths >= 69 && ageMonths < 70) {
          L = -3.114093476;
          M = 15.37617677;
          S = 0.081058206;
        } else if (ageMonths >= 70 && ageMonths < 71) {
          L = -3.15039004;
          M = 15.37745304;
          S = 0.081706249;
        } else if (ageMonths >= 71 && ageMonths < 72) {
          L = -3.182893018;
          M = 15.37990886;
          S = 0.082369741;
        } else if (ageMonths >= 72 && ageMonths < 73) {
          L = -3.21170511;
          M = 15.38353217;
          S = 0.083048178;
        } else if (ageMonths >= 73 && ageMonths < 74) {
          L = -3.23694834;
          M = 15.38831005;
          S = 0.083741021;
        } else if (ageMonths >= 74 && ageMonths < 75) {
          L = -3.25876011;
          M = 15.39422883;
          S = 0.0844477;
        } else if (ageMonths >= 75 && ageMonths < 76) {
          L = -3.277281546;
          M = 15.40127496;
          S = 0.085167651;
        } else if (ageMonths >= 76 && ageMonths < 77) {
          L = -3.292683774;
          M = 15.40943252;
          S = 0.085900184;
        } else if (ageMonths >= 77 && ageMonths < 78) {
          L = -3.305124073;
          M = 15.41868691;
          S = 0.086644667;
        } else if (ageMonths >= 78 && ageMonths < 79) {
          L = -3.314768951;
          M = 15.42902273;
          S = 0.087400421;
        } else if (ageMonths >= 79 && ageMonths < 80) {
          L = -3.321785992;
          M = 15.44042439;
          S = 0.088166744;
        } else if (ageMonths >= 80 && ageMonths < 81) {
          L = -3.326345795;
          M = 15.45287581;
          S = 0.088942897;
        } else if (ageMonths >= 81 && ageMonths < 82) {
          L = -3.328602731;
          M = 15.46636218;
          S = 0.089728202;
        } else if (ageMonths >= 82 && ageMonths < 83) {
          L = -3.328725277;
          M = 15.48086704;
          S = 0.090521875;
        } else if (ageMonths >= 83 && ageMonths < 84) {
          L = -3.32687018;
          M = 15.49637465;
          S = 0.091323162;
        } else if (ageMonths >= 84 && ageMonths < 85) {
          L = -3.323188896;
          M = 15.51286936;
          S = 0.092131305;
        } else if (ageMonths >= 85 && ageMonths < 86) {
          L = -3.317827016;
          M = 15.53033563;
          S = 0.092945544;
        } else if (ageMonths >= 86 && ageMonths < 87) {
          L = -3.310923871;
          M = 15.54875807;
          S = 0.093765118;
        } else if (ageMonths >= 87 && ageMonths < 88) {
          L = -3.302612272;
          M = 15.56812143;
          S = 0.09458927;
        } else if (ageMonths >= 88 && ageMonths < 89) {
          L = -3.293018361;
          M = 15.58841065;
          S = 0.095417247;
        } else if (ageMonths >= 89 && ageMonths < 90) {
          L = -3.282260813;
          M = 15.60961101;
          S = 0.096248301;
        } else if (ageMonths >= 90 && ageMonths < 91) {
          L = -3.270454609;
          M = 15.63170735;
          S = 0.097081694;
        } else if (ageMonths >= 91 && ageMonths < 92) {
          L = -3.257703616;
          M = 15.65468563;
          S = 0.097916698;
        } else if (ageMonths >= 92 && ageMonths < 93) {
          L = -3.244108214;
          M = 15.67853139;
          S = 0.098752593;
        } else if (ageMonths >= 93 && ageMonths < 94) {
          L = -3.229761713;
          M = 15.70323052;
          S = 0.099588675;
        } else if (ageMonths >= 94 && ageMonths < 95) {
          L = -3.214751287;
          M = 15.72876911;
          S = 0.100424251;
        } else if (ageMonths >= 95 && ageMonths < 96) {
          L = -3.199158184;
          M = 15.75513347;
          S = 0.101258643;
        } else if (ageMonths >= 96 && ageMonths < 97) {
          L = -3.18305795;
          M = 15.78231007;
          S = 0.102091189;
        } else if (ageMonths >= 97 && ageMonths < 98) {
          L = -3.166520664;
          M = 15.8102856;
          S = 0.102921245;
        } else if (ageMonths >= 98 && ageMonths < 99) {
          L = -3.1496103;
          M = 15.83904708;
          S = 0.103748189;
        } else if (ageMonths >= 99 && ageMonths < 100) {
          L = -3.132389637;
          M = 15.86858123;
          S = 0.104571386;
        } else if (ageMonths >= 100 && ageMonths < 101) {
          L = -3.114911153;
          M = 15.89887562;
          S = 0.105390269;
        } else if (ageMonths >= 101 && ageMonths < 102) {
          L = -3.097226399;
          M = 15.92991765;
          S = 0.106204258;
        } else if (ageMonths >= 102 && ageMonths < 103) {
          L = -3.079383079;
          M = 15.96169481;
          S = 0.107012788;
        } else if (ageMonths >= 103 && ageMonths < 104) {
          L = -3.061423765;
          M = 15.99419489;
          S = 0.107815327;
        } else if (ageMonths >= 104 && ageMonths < 105) {
          L = -3.043386071;
          M = 16.02740607;
          S = 0.108611374;
        } else if (ageMonths >= 105 && ageMonths < 106) {
          L = -3.025310003;
          M = 16.0613159;
          S = 0.109400388;
        } else if (ageMonths >= 106 && ageMonths < 107) {
          L = -3.007225737;
          M = 16.09591292;
          S = 0.110181915;
        } else if (ageMonths >= 107 && ageMonths < 108) {
          L = -2.989164598;
          M = 16.13118532;
          S = 0.110955478;
        } else if (ageMonths >= 108 && ageMonths < 109) {
          L = -2.971148225;
          M = 16.16712234;
          S = 0.111720691;
        } else if (ageMonths >= 109 && ageMonths < 110) {
          L = -2.953208047;
          M = 16.20371168;
          S = 0.112477059;
        } else if (ageMonths >= 110 && ageMonths < 111) {
          L = -2.935363951;
          M = 16.24094239;
          S = 0.1132242;
        } else if (ageMonths >= 111 && ageMonths < 112) {
          L = -2.917635157;
          M = 16.27880346;
          S = 0.113961734;
        } else if (ageMonths >= 112 && ageMonths < 113) {
          L = -2.900039803;
          M = 16.31728385;
          S = 0.114689291;
        } else if (ageMonths >= 113 && ageMonths < 114) {
          L = -2.882593796;
          M = 16.35637267;
          S = 0.115406523;
        } else if (ageMonths >= 114 && ageMonths < 115) {
          L = -2.865311266;
          M = 16.39605916;
          S = 0.116113097;
        } else if (ageMonths >= 115 && ageMonths < 116) {
          L = -2.848204697;
          M = 16.43633265;
          S = 0.116808702;
        } else if (ageMonths >= 116 && ageMonths < 117) {
          L = -2.831285052;
          M = 16.47718256;
          S = 0.117493042;
        } else if (ageMonths >= 117 && ageMonths < 118) {
          L = -2.81456189;
          M = 16.51859843;
          S = 0.11816584;
        } else if (ageMonths >= 118 && ageMonths < 119) {
          L = -2.79804347;
          M = 16.56056987;
          S = 0.118826835;
        } else if (ageMonths >= 119 && ageMonths < 120) {
          L = -2.781736856;
          M = 16.60308661;
          S = 0.119475785;
        } else if (ageMonths >= 120 && ageMonths < 121) {
          L = -2.765648008;
          M = 16.64613844;
          S = 0.120112464;
        } else if (ageMonths >= 121 && ageMonths < 122) {
          L = -2.749782197;
          M = 16.68971518;
          S = 0.120736656;
        } else if (ageMonths >= 122 && ageMonths < 123) {
          L = -2.734142443;
          M = 16.73380695;
          S = 0.121348181;
        } else if (ageMonths >= 123 && ageMonths < 124) {
          L = -2.718732873;
          M = 16.77840363;
          S = 0.121946849;
        } else if (ageMonths >= 124 && ageMonths < 125) {
          L = -2.703555506;
          M = 16.82349538;
          S = 0.122532501;
        } else if (ageMonths >= 125 && ageMonths < 126) {
          L = -2.688611957;
          M = 16.86907238;
          S = 0.123104991;
        } else if (ageMonths >= 126 && ageMonths < 127) {
          L = -2.673903164;
          M = 16.91512487;
          S = 0.123664186;
        } else if (ageMonths >= 127 && ageMonths < 128) {
          L = -2.659429443;
          M = 16.96164317;
          S = 0.124209969;
        } else if (ageMonths >= 128 && ageMonths < 129) {
          L = -2.645190534;
          M = 17.00861766;
          S = 0.124742239;
        } else if (ageMonths >= 129 && ageMonths < 130) {
          L = -2.631185649;
          M = 17.05603879;
          S = 0.125260905;
        } else if (ageMonths >= 130 && ageMonths < 131) {
          L = -2.617413511;
          M = 17.10389705;
          S = 0.125765895;
        } else if (ageMonths >= 131 && ageMonths < 132) {
          L = -2.603872392;
          M = 17.15218302;
          S = 0.126257147;
        } else if (ageMonths >= 132 && ageMonths < 133) {
          L = -2.590560148;
          M = 17.20088732;
          S = 0.126734613;
        } else if (ageMonths >= 133 && ageMonths < 134) {
          L = -2.577474253;
          M = 17.25000062;
          S = 0.12719826;
        } else if (ageMonths >= 134 && ageMonths < 135) {
          L = -2.564611831;
          M = 17.29951367;
          S = 0.127648067;
        } else if (ageMonths >= 135 && ageMonths < 136) {
          L = -2.551969684;
          M = 17.34941726;
          S = 0.128084023;
        } else if (ageMonths >= 136 && ageMonths < 137) {
          L = -2.539539972;
          M = 17.39970308;
          S = 0.128506192;
        } else if (ageMonths >= 137 && ageMonths < 138) {
          L = -2.527325681;
          M = 17.45036072;
          S = 0.128914497;
        } else if (ageMonths >= 138 && ageMonths < 139) {
          L = -2.515320235;
          M = 17.50138161;
          S = 0.129309001;
        } else if (ageMonths >= 139 && ageMonths < 140) {
          L = -2.503519447;
          M = 17.55275674;
          S = 0.129689741;
        } else if (ageMonths >= 140 && ageMonths < 141) {
          L = -2.491918934;
          M = 17.60447714;
          S = 0.130056765;
        } else if (ageMonths >= 141 && ageMonths < 142) {
          L = -2.480514136;
          M = 17.6565339;
          S = 0.130410133;
        } else if (ageMonths >= 142 && ageMonths < 143) {
          L = -2.469300331;
          M = 17.70891811;
          S = 0.130749913;
        } else if (ageMonths >= 143 && ageMonths < 144) {
          L = -2.458272656;
          M = 17.76162094;
          S = 0.131076187;
        } else if (ageMonths >= 144 && ageMonths < 145) {
          L = -2.447426113;
          M = 17.81463359;
          S = 0.131389042;
        } else if (ageMonths >= 145 && ageMonths < 146) {
          L = -2.436755595;
          M = 17.86794729;
          S = 0.131688579;
        } else if (ageMonths >= 146 && ageMonths < 147) {
          L = -2.426255887;
          M = 17.92155332;
          S = 0.131974905;
        } else if (ageMonths >= 147 && ageMonths < 148) {
          L = -2.415921689;
          M = 17.97544299;
          S = 0.132248138;
        } else if (ageMonths >= 148 && ageMonths < 149) {
          L = -2.405747619;
          M = 18.02960765;
          S = 0.132508403;
        } else if (ageMonths >= 149 && ageMonths < 150) {
          L = -2.395728233;
          M = 18.08403868;
          S = 0.132755834;
        } else if (ageMonths >= 150 && ageMonths < 151) {
          L = -2.385858029;
          M = 18.1387275;
          S = 0.132990575;
        } else if (ageMonths >= 151 && ageMonths < 152) {
          L = -2.376131459;
          M = 18.19366555;
          S = 0.133212776;
        } else if (ageMonths >= 152 && ageMonths < 153) {
          L = -2.366542942;
          M = 18.24884431;
          S = 0.133422595;
        } else if (ageMonths >= 153 && ageMonths < 154) {
          L = -2.357086871;
          M = 18.3042553;
          S = 0.133620197;
        } else if (ageMonths >= 154 && ageMonths < 155) {
          L = -2.347757625;
          M = 18.35989003;
          S = 0.133805756;
        } else if (ageMonths >= 155 && ageMonths < 156) {
          L = -2.338549576;
          M = 18.41574009;
          S = 0.133979452;
        } else if (ageMonths >= 156 && ageMonths < 157) {
          L = -2.3294571;
          M = 18.47179706;
          S = 0.13414147;
        } else if (ageMonths >= 157 && ageMonths < 158) {
          L = -2.320474586;
          M = 18.52805255;
          S = 0.134292005;
        } else if (ageMonths >= 158 && ageMonths < 159) {
          L = -2.311596446;
          M = 18.5844982;
          S = 0.134431256;
        } else if (ageMonths >= 159 && ageMonths < 160) {
          L = -2.302817124;
          M = 18.64112567;
          S = 0.134559427;
        } else if (ageMonths >= 160 && ageMonths < 161) {
          L = -2.294131107;
          M = 18.69792663;
          S = 0.134676731;
        } else if (ageMonths >= 161 && ageMonths < 162) {
          L = -2.285532933;
          M = 18.75489278;
          S = 0.134783385;
        } else if (ageMonths >= 162 && ageMonths < 163) {
          L = -2.277017201;
          M = 18.81201584;
          S = 0.134879611;
        } else if (ageMonths >= 163 && ageMonths < 164) {
          L = -2.268578584;
          M = 18.86928753;
          S = 0.134965637;
        } else if (ageMonths >= 164 && ageMonths < 165) {
          L = -2.260211837;
          M = 18.92669959;
          S = 0.135041695;
        } else if (ageMonths >= 165 && ageMonths < 166) {
          L = -2.251911809;
          M = 18.98424378;
          S = 0.135108024;
        } else if (ageMonths >= 166 && ageMonths < 167) {
          L = -2.243673453;
          M = 19.04191185;
          S = 0.135164867;
        } else if (ageMonths >= 167 && ageMonths < 168) {
          L = -2.235491842;
          M = 19.09969557;
          S = 0.135212469;
        } else if (ageMonths >= 168 && ageMonths < 169) {
          L = -2.227362173;
          M = 19.15758672;
          S = 0.135251083;
        } else if (ageMonths >= 169 && ageMonths < 170) {
          L = -2.21927979;
          M = 19.21557707;
          S = 0.135280963;
        } else if (ageMonths >= 170 && ageMonths < 171) {
          L = -2.211240187;
          M = 19.27365839;
          S = 0.135302371;
        } else if (ageMonths >= 171 && ageMonths < 172) {
          L = -2.203239029;
          M = 19.33182247;
          S = 0.135315568;
        } else if (ageMonths >= 172 && ageMonths < 173) {
          L = -2.195272161;
          M = 19.39006106;
          S = 0.135320824;
        } else if (ageMonths >= 173 && ageMonths < 174) {
          L = -2.187335625;
          M = 19.44836594;
          S = 0.135318407;
        } else if (ageMonths >= 174 && ageMonths < 175) {
          L = -2.179425674;
          M = 19.50672885;
          S = 0.135308594;
        } else if (ageMonths >= 175 && ageMonths < 176) {
          L = -2.171538789;
          M = 19.56514153;
          S = 0.135291662;
        } else if (ageMonths >= 176 && ageMonths < 177) {
          L = -2.163671689;
          M = 19.62359571;
          S = 0.135267891;
        } else if (ageMonths >= 177 && ageMonths < 178) {
          L = -2.155821357;
          M = 19.6820831;
          S = 0.135237567;
        } else if (ageMonths >= 178 && ageMonths < 179) {
          L = -2.147985046;
          M = 19.74059538;
          S = 0.135200976;
        } else if (ageMonths >= 179 && ageMonths < 180) {
          L = -2.140160305;
          M = 19.7991242;
          S = 0.135158409;
        } else if (ageMonths >= 180 && ageMonths < 181) {
          L = -2.132344989;
          M = 19.85766121;
          S = 0.135110159;
        } else if (ageMonths >= 181 && ageMonths < 182) {
          L = -2.124537282;
          M = 19.916198;
          S = 0.135056522;
        } else if (ageMonths >= 182 && ageMonths < 183) {
          L = -2.116735712;
          M = 19.97472615;
          S = 0.134997797;
        } else if (ageMonths >= 183 && ageMonths < 184) {
          L = -2.108939167;
          M = 20.03323719;
          S = 0.134934285;
        } else if (ageMonths >= 184 && ageMonths < 185) {
          L = -2.10114692;
          M = 20.09172262;
          S = 0.134866291;
        } else if (ageMonths >= 185 && ageMonths < 186) {
          L = -2.093358637;
          M = 20.15017387;
          S = 0.134794121;
        } else if (ageMonths >= 186 && ageMonths < 187) {
          L = -2.085574403;
          M = 20.20858236;
          S = 0.134718085;
        } else if (ageMonths >= 187 && ageMonths < 188) {
          L = -2.077794735;
          M = 20.26693944;
          S = 0.134638494;
        } else if (ageMonths >= 188 && ageMonths < 189) {
          L = -2.070020599;
          M = 20.32523642;
          S = 0.134555663;
        } else if (ageMonths >= 189 && ageMonths < 190) {
          L = -2.062253431;
          M = 20.38346455;
          S = 0.13446991;
        } else if (ageMonths >= 190 && ageMonths < 191) {
          L = -2.054495145;
          M = 20.44161501;
          S = 0.134381553;
        } else if (ageMonths >= 191 && ageMonths < 192) {
          L = -2.046748156;
          M = 20.49967894;
          S = 0.134290916;
        } else if (ageMonths >= 192 && ageMonths < 193) {
          L = -2.039015385;
          M = 20.5576474;
          S = 0.134198323;
        } else if (ageMonths >= 193 && ageMonths < 194) {
          L = -2.031300282;
          M = 20.6155114;
          S = 0.134104101;
        } else if (ageMonths >= 194 && ageMonths < 195) {
          L = -2.023606828;
          M = 20.67326189;
          S = 0.134008581;
        } else if (ageMonths >= 195 && ageMonths < 196) {
          L = -2.015942013;
          M = 20.73088905;
          S = 0.133912066;
        } else if (ageMonths >= 196 && ageMonths < 197) {
          L = -2.008305745;
          M = 20.7883851;
          S = 0.133814954;
        } else if (ageMonths >= 197 && ageMonths < 198) {
          L = -2.000706389;
          M = 20.84574003;
          S = 0.133717552;
        } else if (ageMonths >= 198 && ageMonths < 199) {
          L = -1.993150137;
          M = 20.90294449;
          S = 0.1336202;
        } else if (ageMonths >= 199 && ageMonths < 200) {
          L = -1.985643741;
          M = 20.95998909;
          S = 0.133523244;
        } else if (ageMonths >= 200 && ageMonths < 201) {
          L = -1.97819451;
          M = 21.01686433;
          S = 0.133427032;
        } else if (ageMonths >= 201 && ageMonths < 202) {
          L = -1.970810308;
          M = 21.07356067;
          S = 0.133331914;
        } else if (ageMonths >= 202 && ageMonths < 203) {
          L = -1.96349954;
          M = 21.1300685;
          S = 0.133238245;
        } else if (ageMonths >= 203 && ageMonths < 204) {
          L = -1.956271141;
          M = 21.18637813;
          S = 0.133146383;
        } else if (ageMonths >= 204 && ageMonths < 205) {
          L = -1.949134561;
          M = 21.24247982;
          S = 0.13305669;
        } else if (ageMonths >= 205 && ageMonths < 206) {
          L = -1.942099744;
          M = 21.29836376;
          S = 0.132969531;
        } else if (ageMonths >= 206 && ageMonths < 207) {
          L = -1.935177101;
          M = 21.35402009;
          S = 0.132885274;
        } else if (ageMonths >= 207 && ageMonths < 208) {
          L = -1.92837748;
          M = 21.40943891;
          S = 0.132804292;
        } else if (ageMonths >= 208 && ageMonths < 209) {
          L = -1.921712136;
          M = 21.46461026;
          S = 0.132726962;
        } else if (ageMonths >= 209 && ageMonths < 210) {
          L = -1.915192685;
          M = 21.51952414;
          S = 0.132653664;
        } else if (ageMonths >= 210 && ageMonths < 211) {
          L = -1.908831065;
          M = 21.57417053;
          S = 0.132584784;
        } else if (ageMonths >= 211 && ageMonths < 212) {
          L = -1.902639482;
          M = 21.62853937;
          S = 0.132520711;
        } else if (ageMonths >= 212 && ageMonths < 213) {
          L = -1.896630358;
          M = 21.68262062;
          S = 0.132461838;
        } else if (ageMonths >= 213 && ageMonths < 214) {
          L = -1.890816268;
          M = 21.73640419;
          S = 0.132408563;
        } else if (ageMonths >= 214 && ageMonths < 215) {
          L = -1.885209876;
          M = 21.78988003;
          S = 0.132361289;
        } else if (ageMonths >= 215 && ageMonths < 216) {
          L = -1.879823505;
          M = 21.84303819;
          S = 0.132320427;
        } else if (ageMonths >= 216 && ageMonths < 217) {
          L = -1.874670324;
          M = 21.8958685;
          S = 0.132286382;
        } else if (ageMonths >= 217 && ageMonths < 218) {
          L = -1.869760299;
          M = 21.94836168;
          S = 0.1322596;
        } else if (ageMonths >= 218 && ageMonths < 219) {
          L = -1.865113245;
          M = 22.00050569;
          S = 0.132240418;
        } else if (ageMonths >= 219 && ageMonths < 220) {
          L = -1.860734944;
          M = 22.05229242;
          S = 0.13222933;
        } else if (ageMonths >= 220 && ageMonths < 221) {
          L = -1.85663384;
          M = 22.10371305;
          S = 0.132226801;
        } else if (ageMonths >= 221 && ageMonths < 222) {
          L = -1.852827186;
          M = 22.15475603;
          S = 0.132233201;
        } else if (ageMonths >= 222 && ageMonths < 223) {
          L = -1.849323204;
          M = 22.20541249;
          S = 0.132248993;
        } else if (ageMonths >= 223 && ageMonths < 224) {
          L = -1.846131607;
          M = 22.255673;
          S = 0.132274625;
        } else if (ageMonths >= 224 && ageMonths < 225) {
          L = -1.843261294;
          M = 22.30552831;
          S = 0.132310549;
        } else if (ageMonths >= 225 && ageMonths < 226) {
          L = -1.840720248;
          M = 22.3549693;
          S = 0.132357221;
        } else if (ageMonths >= 226 && ageMonths < 227) {
          L = -1.83851544;
          M = 22.40398706;
          S = 0.132415103;
        } else if (ageMonths >= 227 && ageMonths < 228) {
          L = -1.83665586;
          M = 22.45257182;
          S = 0.132484631;
        } else if (ageMonths >= 228 && ageMonths < 229) {
          L = -1.835138046;
          M = 22.50071778;
          S = 0.132566359;
        } else if (ageMonths >= 229 && ageMonths < 230) {
          L = -1.833972004;
          M = 22.54841437;
          S = 0.132660699;
        } else if (ageMonths >= 230 && ageMonths < 231) {
          L = -1.833157751;
          M = 22.59565422;
          S = 0.132768153;
        } else if (ageMonths >= 231 && ageMonths < 232) {
          L = -1.83269562;
          M = 22.64242956;
          S = 0.132889211;
        } else if (ageMonths >= 232 && ageMonths < 233) {
          L = -1.832584342;
          M = 22.68873292;
          S = 0.133024368;
        } else if (ageMonths >= 233 && ageMonths < 234) {
          L = -1.832820974;
          M = 22.73455713;
          S = 0.133174129;
        } else if (ageMonths >= 234 && ageMonths < 235) {
          L = -1.833400825;
          M = 22.7798953;
          S = 0.133338999;
        } else if (ageMonths >= 235 && ageMonths < 236) {
          L = -1.834317405;
          M = 22.82474087;
          S = 0.133519496;
        } else if (ageMonths >= 236 && ageMonths < 237) {
          L = -1.83555752;
          M = 22.86908912;
          S = 0.133716192;
        } else if (ageMonths >= 237 && ageMonths < 238) {
          L = -1.837119466;
          M = 22.91293151;
          S = 0.133929525;
        } else if (ageMonths >= 238 && ageMonths < 239) {
          L = -1.838987063;
          M = 22.95626373;
          S = 0.134160073;
        } else if (ageMonths >= 239 && ageMonths < 240) {
          L = -1.841146139;
          M = 22.99908062;
          S = 0.134408381;
        } else if (ageMonths >= 240 && ageMonths < 241) {
          L = -1.843580575;
          M = 23.04137734;
          S = 0.134675001;
        }
        zScore = (Math.pow(roundBmi / M, L) - 1) / (L * S);
      }

      if (gender == "Female") {
        if (ageMonths >= 24 && ageMonths < 25) {
          L = -1.024496827;
          M = 16.38804056;
          S = 0.085025838;
        } else if (ageMonths >= 25 && ageMonths < 26) {
          L = -1.102698353;
          M = 16.3189719;
          S = 0.084214052;
        } else if (ageMonths >= 26 && ageMonths < 27) {
          L = -1.18396635;
          M = 16.25207985;
          S = 0.083455124;
        } else if (ageMonths >= 27 && ageMonths < 28) {
          L = -1.268071036;
          M = 16.18734669;
          S = 0.082748284;
        } else if (ageMonths >= 28 && ageMonths < 29) {
          L = -1.354751525;
          M = 16.12475448;
          S = 0.082092737;
        } else if (ageMonths >= 29 && ageMonths < 30) {
          L = -1.443689692;
          M = 16.06428762;
          S = 0.081487717;
        } else if (ageMonths >= 30 && ageMonths < 31) {
          L = -1.53454192;
          M = 16.00593001;
          S = 0.080932448;
        } else if (ageMonths >= 31 && ageMonths < 32) {
          L = -1.626928093;
          M = 15.94966631;
          S = 0.080426175;
        } else if (ageMonths >= 32 && ageMonths < 33) {
          L = -1.720434829;
          M = 15.89548197;
          S = 0.079968176;
        } else if (ageMonths >= 33 && ageMonths < 34) {
          L = -1.814635262;
          M = 15.84336179;
          S = 0.079557735;
        } else if (ageMonths >= 34 && ageMonths < 35) {
          L = -1.909076262;
          M = 15.79329146;
          S = 0.079194187;
        } else if (ageMonths >= 35 && ageMonths < 36) {
          L = -2.003296102;
          M = 15.7452564;
          S = 0.078876895;
        } else if (ageMonths >= 36 && ageMonths < 37) {
          L = -2.096828937;
          M = 15.69924188;
          S = 0.078605255;
        } else if (ageMonths >= 37 && ageMonths < 38) {
          L = -2.189211877;
          M = 15.65523282;
          S = 0.078378696;
        } else if (ageMonths >= 38 && ageMonths < 39) {
          L = -2.279991982;
          M = 15.61321371;
          S = 0.078196674;
        } else if (ageMonths >= 39 && ageMonths < 40) {
          L = -2.368732949;
          M = 15.57316843;
          S = 0.078058667;
        } else if (ageMonths >= 40 && ageMonths < 41) {
          L = -2.455021314;
          M = 15.53508019;
          S = 0.077964169;
        } else if (ageMonths >= 41 && ageMonths < 42) {
          L = -2.538471972;
          M = 15.49893145;
          S = 0.077912684;
        } else if (ageMonths >= 42 && ageMonths < 43) {
          L = -2.618732901;
          M = 15.46470384;
          S = 0.077903716;
        } else if (ageMonths >= 43 && ageMonths < 44) {
          L = -2.695488973;
          M = 15.43237817;
          S = 0.077936763;
        } else if (ageMonths >= 44 && ageMonths < 45) {
          L = -2.768464816;
          M = 15.40193436;
          S = 0.078011309;
        } else if (ageMonths >= 45 && ageMonths < 46) {
          L = -2.837426693;
          M = 15.37335154;
          S = 0.078126817;
        } else if (ageMonths >= 46 && ageMonths < 47) {
          L = -2.902178205;
          M = 15.34660842;
          S = 0.078282739;
        } else if (ageMonths >= 47 && ageMonths < 48) {
          L = -2.962580386;
          M = 15.32168181;
          S = 0.078478449;
        } else if (ageMonths >= 48 && ageMonths < 49) {
          L = -3.018521987;
          M = 15.29854897;
          S = 0.078713325;
        } else if (ageMonths >= 49 && ageMonths < 50) {
          L = -3.069936555;
          M = 15.27718618;
          S = 0.078986694;
        } else if (ageMonths >= 50 && ageMonths < 51) {
          L = -3.116795864;
          M = 15.2575692;
          S = 0.079297841;
        } else if (ageMonths >= 51 && ageMonths < 52) {
          L = -3.159107331;
          M = 15.23967338;
          S = 0.079646006;
        } else if (ageMonths >= 52 && ageMonths < 53) {
          L = -3.196911083;
          M = 15.22347371;
          S = 0.080030389;
        } else if (ageMonths >= 53 && ageMonths < 54) {
          L = -3.230276759;
          M = 15.20894491;
          S = 0.080450145;
        } else if (ageMonths >= 54 && ageMonths < 55) {
          L = -3.259300182;
          M = 15.19606152;
          S = 0.080904391;
        } else if (ageMonths >= 55 && ageMonths < 56) {
          L = -3.284099963;
          M = 15.18479799;
          S = 0.081392203;
        } else if (ageMonths >= 56 && ageMonths < 57) {
          L = -3.30481415;
          M = 15.17512871;
          S = 0.081912623;
        } else if (ageMonths >= 57 && ageMonths < 58) {
          L = -3.321596954;
          M = 15.16702811;
          S = 0.082464661;
        } else if (ageMonths >= 58 && ageMonths < 59) {
          L = -3.334615646;
          M = 15.16047068;
          S = 0.083047295;
        } else if (ageMonths >= 59 && ageMonths < 60) {
          L = -3.344047622;
          M = 15.15543107;
          S = 0.083659478;
        } else if (ageMonths >= 60 && ageMonths < 61) {
          L = -3.35007771;
          M = 15.15188405;
          S = 0.084300139;
        } else if (ageMonths >= 61 && ageMonths < 62) {
          L = -3.352893805;
          M = 15.14980479;
          S = 0.0849682;
        } else if (ageMonths >= 62 && ageMonths < 63) {
          L = -3.352691376;
          M = 15.14916825;
          S = 0.085662539;
        } else if (ageMonths >= 63 && ageMonths < 64) {
          L = -3.34966438;
          M = 15.14994984;
          S = 0.086382035;
        } else if (ageMonths >= 64 && ageMonths < 65) {
          L = -3.343998803;
          M = 15.15212585;
          S = 0.087125591;
        } else if (ageMonths >= 65 && ageMonths < 66) {
          L = -3.335889574;
          M = 15.15567186;
          S = 0.087892047;
        } else if (ageMonths >= 66 && ageMonths < 67) {
          L = -3.325522491;
          M = 15.16056419;
          S = 0.088680264;
        } else if (ageMonths >= 67 && ageMonths < 68) {
          L = -3.31307846;
          M = 15.16677947;
          S = 0.089489106;
        } else if (ageMonths >= 68 && ageMonths < 69) {
          L = -3.298732648;
          M = 15.17429464;
          S = 0.090317434;
        } else if (ageMonths >= 69 && ageMonths < 70) {
          L = -3.282653831;
          M = 15.18308694;
          S = 0.091164117;
        } else if (ageMonths >= 70 && ageMonths < 71) {
          L = -3.265003896;
          M = 15.1931339;
          S = 0.092028028;
        } else if (ageMonths >= 71 && ageMonths < 72) {
          L = -3.245937506;
          M = 15.20441335;
          S = 0.092908048;
        } else if (ageMonths >= 72 && ageMonths < 73) {
          L = -3.225606516;
          M = 15.21690296;
          S = 0.093803033;
        } else if (ageMonths >= 73 && ageMonths < 74) {
          L = -3.204146115;
          M = 15.2305815;
          S = 0.094711916;
        } else if (ageMonths >= 74 && ageMonths < 75) {
          L = -3.181690237;
          M = 15.24542745;
          S = 0.095633595;
        } else if (ageMonths >= 75 && ageMonths < 76) {
          L = -3.158363475;
          M = 15.26141966;
          S = 0.096566992;
        } else if (ageMonths >= 76 && ageMonths < 77) {
          L = -3.134282833;
          M = 15.27853728;
          S = 0.097511046;
        } else if (ageMonths >= 77 && ageMonths < 78) {
          L = -3.109557879;
          M = 15.29675967;
          S = 0.09846471;
        } else if (ageMonths >= 78 && ageMonths < 79) {
          L = -3.084290931;
          M = 15.31606644;
          S = 0.099426955;
        } else if (ageMonths >= 79 && ageMonths < 80) {
          L = -3.058577292;
          M = 15.33643745;
          S = 0.100396769;
        } else if (ageMonths >= 80 && ageMonths < 81) {
          L = -3.032505499;
          M = 15.35785274;
          S = 0.101373159;
        } else if (ageMonths >= 81 && ageMonths < 82) {
          L = -3.0061576;
          M = 15.38029261;
          S = 0.10235515;
        } else if (ageMonths >= 82 && ageMonths < 83) {
          L = -2.979609448;
          M = 15.40373754;
          S = 0.103341788;
        } else if (ageMonths >= 83 && ageMonths < 84) {
          L = -2.952930993;
          M = 15.42816819;
          S = 0.104332139;
        } else if (ageMonths >= 84 && ageMonths < 85) {
          L = -2.926186592;
          M = 15.45356545;
          S = 0.105325289;
        } else if (ageMonths >= 85 && ageMonths < 86) {
          L = -2.899435307;
          M = 15.47991037;
          S = 0.106320346;
        } else if (ageMonths >= 86 && ageMonths < 87) {
          L = -2.872731211;
          M = 15.50718419;
          S = 0.10731644;
        } else if (ageMonths >= 87 && ageMonths < 88) {
          L = -2.846123683;
          M = 15.53536829;
          S = 0.108312721;
        } else if (ageMonths >= 88 && ageMonths < 89) {
          L = -2.819657704;
          M = 15.56444426;
          S = 0.109308364;
        } else if (ageMonths >= 89 && ageMonths < 90) {
          L = -2.793374145;
          M = 15.5943938;
          S = 0.110302563;
        } else if (ageMonths >= 90 && ageMonths < 91) {
          L = -2.767310047;
          M = 15.6251988;
          S = 0.111294537;
        } else if (ageMonths >= 91 && ageMonths < 92) {
          L = -2.741498897;
          M = 15.65684126;
          S = 0.112283526;
        } else if (ageMonths >= 92 && ageMonths < 93) {
          L = -2.715970894;
          M = 15.68930333;
          S = 0.113268793;
        } else if (ageMonths >= 93 && ageMonths < 94) {
          L = -2.690753197;
          M = 15.7225673;
          S = 0.114249622;
        } else if (ageMonths >= 94 && ageMonths < 95) {
          L = -2.665870146;
          M = 15.75661555;
          S = 0.115225321;
        } else if (ageMonths >= 95 && ageMonths < 96) {
          L = -2.641343436;
          M = 15.79143062;
          S = 0.116195218;
        } else if (ageMonths >= 96 && ageMonths < 97) {
          L = -2.617192204;
          M = 15.82699517;
          S = 0.117158667;
        } else if (ageMonths >= 97 && ageMonths < 98) {
          L = -2.593430614;
          M = 15.86329241;
          S = 0.118115073;
        } else if (ageMonths >= 98 && ageMonths < 99) {
          L = -2.570076037;
          M = 15.90030484;
          S = 0.119063807;
        } else if (ageMonths >= 99 && ageMonths < 100) {
          L = -2.547141473;
          M = 15.93801545;
          S = 0.12000429;
        } else if (ageMonths >= 100 && ageMonths < 101) {
          L = -2.524635245;
          M = 15.97640787;
          S = 0.120935994;
        } else if (ageMonths >= 101 && ageMonths < 102) {
          L = -2.502569666;
          M = 16.01546483;
          S = 0.121858355;
        } else if (ageMonths >= 102 && ageMonths < 103) {
          L = -2.48095189;
          M = 16.05516984;
          S = 0.12277087;
        } else if (ageMonths >= 103 && ageMonths < 104) {
          L = -2.459785573;
          M = 16.09550688;
          S = 0.123673085;
        } else if (ageMonths >= 104 && ageMonths < 105) {
          L = -2.439080117;
          M = 16.13645881;
          S = 0.124564484;
        } else if (ageMonths >= 105 && ageMonths < 106) {
          L = -2.418838304;
          M = 16.17800955;
          S = 0.125444639;
        } else if (ageMonths >= 106 && ageMonths < 107) {
          L = -2.399063683;
          M = 16.22014281;
          S = 0.126313121;
        } else if (ageMonths >= 107 && ageMonths < 108) {
          L = -2.379756861;
          M = 16.26284277;
          S = 0.127169545;
        } else if (ageMonths >= 108 && ageMonths < 109) {
          L = -2.360920527;
          M = 16.30609316;
          S = 0.128013515;
        } else if (ageMonths >= 109 && ageMonths < 110) {
          L = -2.342557728;
          M = 16.34987759;
          S = 0.128844639;
        } else if (ageMonths >= 110 && ageMonths < 111) {
          L = -2.324663326;
          M = 16.39418118;
          S = 0.129662637;
        } else if (ageMonths >= 111 && ageMonths < 112) {
          L = -2.307240716;
          M = 16.43898741;
          S = 0.130467138;
        } else if (ageMonths >= 112 && ageMonths < 113) {
          L = -2.290287663;
          M = 16.48428082;
          S = 0.131257852;
        } else if (ageMonths >= 113 && ageMonths < 114) {
          L = -2.273803847;
          M = 16.53004554;
          S = 0.132034479;
        } else if (ageMonths >= 114 && ageMonths < 115) {
          L = -2.257782149;
          M = 16.57626713;
          S = 0.132796819;
        } else if (ageMonths >= 115 && ageMonths < 116) {
          L = -2.242227723;
          M = 16.62292864;
          S = 0.133544525;
        } else if (ageMonths >= 116 && ageMonths < 117) {
          L = -2.227132805;
          M = 16.67001572;
          S = 0.134277436;
        } else if (ageMonths >= 117 && ageMonths < 118) {
          L = -2.212495585;
          M = 16.71751288;
          S = 0.134995324;
        } else if (ageMonths >= 118 && ageMonths < 119) {
          L = -2.19831275;
          M = 16.76540496;
          S = 0.135697996;
        } else if (ageMonths >= 119 && ageMonths < 120) {
          L = -2.184580762;
          M = 16.81367689;
          S = 0.136385276;
        } else if (ageMonths >= 120 && ageMonths < 121) {
          L = -2.171295888;
          M = 16.86231366;
          S = 0.137057004;
        } else if (ageMonths >= 121 && ageMonths < 122) {
          L = -2.158454232;
          M = 16.91130036;
          S = 0.137713039;
        } else if (ageMonths >= 122 && ageMonths < 123) {
          L = -2.146051754;
          M = 16.96062216;
          S = 0.138353254;
        } else if (ageMonths >= 123 && ageMonths < 124) {
          L = -2.134084303;
          M = 17.0102643;
          S = 0.138977537;
        } else if (ageMonths >= 124 && ageMonths < 125) {
          L = -2.122547629;
          M = 17.06021213;
          S = 0.139585795;
        } else if (ageMonths >= 125 && ageMonths < 126) {
          L = -2.111437411;
          M = 17.11045106;
          S = 0.140177947;
        } else if (ageMonths >= 126 && ageMonths < 127) {
          L = -2.100749266;
          M = 17.16096656;
          S = 0.140753927;
        } else if (ageMonths >= 127 && ageMonths < 128) {
          L = -2.090478774;
          M = 17.21174424;
          S = 0.141313686;
        } else if (ageMonths >= 128 && ageMonths < 129) {
          L = -2.080621484;
          M = 17.26276973;
          S = 0.141857186;
        } else if (ageMonths >= 129 && ageMonths < 130) {
          L = -2.071172932;
          M = 17.31402878;
          S = 0.142384404;
        } else if (ageMonths >= 130 && ageMonths < 131) {
          L = -2.062128649;
          M = 17.3655072;
          S = 0.142895332;
        } else if (ageMonths >= 131 && ageMonths < 132) {
          L = -2.053484173;
          M = 17.4171909;
          S = 0.143389972;
        } else if (ageMonths >= 132 && ageMonths < 133) {
          L = -2.045235058;
          M = 17.46906585;
          S = 0.143868341;
        } else if (ageMonths >= 133 && ageMonths < 134) {
          L = -2.03737688;
          M = 17.52111811;
          S = 0.144330469;
        } else if (ageMonths >= 134 && ageMonths < 135) {
          L = -2.029906684;
          M = 17.57333347;
          S = 0.144776372;
        } else if (ageMonths >= 135 && ageMonths < 136) {
          L = -2.022817914;
          M = 17.62569869;
          S = 0.145206138;
        } else if (ageMonths >= 136 && ageMonths < 137) {
          L = -2.016107084;
          M = 17.67819987;
          S = 0.145619819;
        } else if (ageMonths >= 137 && ageMonths < 138) {
          L = -2.009769905;
          M = 17.7308234;
          S = 0.146017491;
        } else if (ageMonths >= 138 && ageMonths < 139) {
          L = -2.003802134;
          M = 17.78355575;
          S = 0.146399239;
        } else if (ageMonths >= 139 && ageMonths < 140) {
          L = -1.998199572;
          M = 17.83638347;
          S = 0.146765161;
        } else if (ageMonths >= 140 && ageMonths < 141) {
          L = -1.992958064;
          M = 17.88929321;
          S = 0.147115364;
        } else if (ageMonths >= 141 && ageMonths < 142) {
          L = -1.988073505;
          M = 17.94227168;
          S = 0.147449967;
        } else if (ageMonths >= 142 && ageMonths < 143) {
          L = -1.983541835;
          M = 17.9953057;
          S = 0.147769097;
        } else if (ageMonths >= 143 && ageMonths < 144) {
          L = -1.979359041;
          M = 18.04838216;
          S = 0.148072891;
        } else if (ageMonths >= 144 && ageMonths < 145) {
          L = -1.975521156;
          M = 18.10148804;
          S = 0.148361495;
        } else if (ageMonths >= 145 && ageMonths < 146) {
          L = -1.972024258;
          M = 18.15461039;
          S = 0.148635067;
        } else if (ageMonths >= 146 && ageMonths < 147) {
          L = -1.968864465;
          M = 18.20773639;
          S = 0.148893769;
        } else if (ageMonths >= 147 && ageMonths < 148) {
          L = -1.966037938;
          M = 18.26085325;
          S = 0.149137776;
        } else if (ageMonths >= 148 && ageMonths < 149) {
          L = -1.963540872;
          M = 18.31394832;
          S = 0.14936727;
        } else if (ageMonths >= 149 && ageMonths < 150) {
          L = -1.961369499;
          M = 18.36700902;
          S = 0.149582439;
        } else if (ageMonths >= 150 && ageMonths < 151) {
          L = -1.959520079;
          M = 18.42002284;
          S = 0.149783482;
        } else if (ageMonths >= 151 && ageMonths < 152) {
          L = -1.9579889;
          M = 18.47297739;
          S = 0.149970604;
        } else if (ageMonths >= 152 && ageMonths < 153) {
          L = -1.956772271;
          M = 18.52586035;
          S = 0.15014402;
        } else if (ageMonths >= 153 && ageMonths < 154) {
          L = -1.95586652;
          M = 18.57865951;
          S = 0.15030395;
        } else if (ageMonths >= 154 && ageMonths < 155) {
          L = -1.955267984;
          M = 18.63136275;
          S = 0.150450621;
        } else if (ageMonths >= 155 && ageMonths < 156) {
          L = -1.954973011;
          M = 18.68395801;
          S = 0.15058427;
        } else if (ageMonths >= 156 && ageMonths < 157) {
          L = -1.954977947;
          M = 18.73643338;
          S = 0.150705138;
        } else if (ageMonths >= 157 && ageMonths < 158) {
          L = -1.955279136;
          M = 18.788777;
          S = 0.150813475;
        } else if (ageMonths >= 158 && ageMonths < 159) {
          L = -1.955872909;
          M = 18.84097713;
          S = 0.150909535;
        } else if (ageMonths >= 159 && ageMonths < 160) {
          L = -1.956755579;
          M = 18.89302212;
          S = 0.150993582;
        } else if (ageMonths >= 160 && ageMonths < 161) {
          L = -1.957923436;
          M = 18.94490041;
          S = 0.151065883;
        } else if (ageMonths >= 161 && ageMonths < 162) {
          L = -1.959372737;
          M = 18.99660055;
          S = 0.151126714;
        } else if (ageMonths >= 162 && ageMonths < 163) {
          L = -1.9610997;
          M = 19.04811118;
          S = 0.151176355;
        } else if (ageMonths >= 163 && ageMonths < 164) {
          L = -1.963100496;
          M = 19.09942105;
          S = 0.151215094;
        } else if (ageMonths >= 164 && ageMonths < 165) {
          L = -1.96537124;
          M = 19.15051899;
          S = 0.151243223;
        } else if (ageMonths >= 165 && ageMonths < 166) {
          L = -1.967907983;
          M = 19.20139397;
          S = 0.151261042;
        } else if (ageMonths >= 166 && ageMonths < 167) {
          L = -1.970706706;
          M = 19.25203503;
          S = 0.151268855;
        } else if (ageMonths >= 167 && ageMonths < 168) {
          L = -1.973763307;
          M = 19.30243131;
          S = 0.151266974;
        } else if (ageMonths >= 168 && ageMonths < 169) {
          L = -1.977073595;
          M = 19.35257209;
          S = 0.151255713;
        } else if (ageMonths >= 169 && ageMonths < 170) {
          L = -1.980633277;
          M = 19.40244671;
          S = 0.151235395;
        } else if (ageMonths >= 170 && ageMonths < 171) {
          L = -1.984437954;
          M = 19.45204465;
          S = 0.151206347;
        } else if (ageMonths >= 171 && ageMonths < 172) {
          L = -1.988483106;
          M = 19.50135548;
          S = 0.151168902;
        } else if (ageMonths >= 172 && ageMonths < 173) {
          L = -1.992764085;
          M = 19.55036888;
          S = 0.151123398;
        } else if (ageMonths >= 173 && ageMonths < 174) {
          L = -1.997276103;
          M = 19.59907464;
          S = 0.15107018;
        } else if (ageMonths >= 174 && ageMonths < 175) {
          L = -2.002014224;
          M = 19.64746266;
          S = 0.151009595;
        } else if (ageMonths >= 175 && ageMonths < 176) {
          L = -2.00697335;
          M = 19.69552294;
          S = 0.150942;
        } else if (ageMonths >= 176 && ageMonths < 177) {
          L = -2.012148213;
          M = 19.7432456;
          S = 0.150867753;
        } else if (ageMonths >= 177 && ageMonths < 178) {
          L = -2.017533363;
          M = 19.79062086;
          S = 0.150787221;
        } else if (ageMonths >= 178 && ageMonths < 179) {
          L = -2.023123159;
          M = 19.83763907;
          S = 0.150700774;
        } else if (ageMonths >= 179 && ageMonths < 180) {
          L = -2.028911755;
          M = 19.88429066;
          S = 0.150608788;
        } else if (ageMonths >= 180 && ageMonths < 181) {
          L = -2.034893091;
          M = 19.9305662;
          S = 0.150511645;
        } else if (ageMonths >= 181 && ageMonths < 182) {
          L = -2.041060881;
          M = 19.97645636;
          S = 0.150409731;
        } else if (ageMonths >= 182 && ageMonths < 183) {
          L = -2.047408604;
          M = 20.02195192;
          S = 0.15030344;
        } else if (ageMonths >= 183 && ageMonths < 184) {
          L = -2.05392949;
          M = 20.06704377;
          S = 0.150193169;
        } else if (ageMonths >= 184 && ageMonths < 185) {
          L = -2.060616513;
          M = 20.11172291;
          S = 0.150079322;
        } else if (ageMonths >= 185 && ageMonths < 186) {
          L = -2.067462375;
          M = 20.15598047;
          S = 0.149962308;
        } else if (ageMonths >= 186 && ageMonths < 187) {
          L = -2.074459502;
          M = 20.19980767;
          S = 0.14984254;
        } else if (ageMonths >= 187 && ageMonths < 188) {
          L = -2.081600029;
          M = 20.24319586;
          S = 0.149720441;
        } else if (ageMonths >= 188 && ageMonths < 189) {
          L = -2.088875793;
          M = 20.28613648;
          S = 0.149596434;
        } else if (ageMonths >= 189 && ageMonths < 190) {
          L = -2.096278323;
          M = 20.32862109;
          S = 0.149470953;
        } else if (ageMonths >= 190 && ageMonths < 191) {
          L = -2.103798828;
          M = 20.37064138;
          S = 0.149344433;
        } else if (ageMonths >= 191 && ageMonths < 192) {
          L = -2.111428194;
          M = 20.41218911;
          S = 0.149217319;
        } else if (ageMonths >= 192 && ageMonths < 193) {
          L = -2.119156972;
          M = 20.45325617;
          S = 0.14909006;
        } else if (ageMonths >= 193 && ageMonths < 194) {
          L = -2.126975375;
          M = 20.49383457;
          S = 0.14896311;
        } else if (ageMonths >= 194 && ageMonths < 195) {
          L = -2.134873266;
          M = 20.5339164;
          S = 0.148836931;
        } else if (ageMonths >= 195 && ageMonths < 196) {
          L = -2.142840157;
          M = 20.57349387;
          S = 0.148711989;
        } else if (ageMonths >= 196 && ageMonths < 197) {
          L = -2.150865204;
          M = 20.61255929;
          S = 0.148588757;
        } else if (ageMonths >= 197 && ageMonths < 198) {
          L = -2.158937201;
          M = 20.65110506;
          S = 0.148467715;
        } else if (ageMonths >= 198 && ageMonths < 199) {
          L = -2.167044578;
          M = 20.6891237;
          S = 0.148349348;
        } else if (ageMonths >= 199 && ageMonths < 200) {
          L = -2.175176987;
          M = 20.72660728;
          S = 0.14823412;
        } else if (ageMonths >= 200 && ageMonths < 201) {
          L = -2.183317362;
          M = 20.76355011;
          S = 0.148122614;
        } else if (ageMonths >= 201 && ageMonths < 202) {
          L = -2.191457792;
          M = 20.79994337;
          S = 0.148015249;
        } else if (ageMonths >= 202 && ageMonths < 203) {
          L = -2.199583649;
          M = 20.83578051;
          S = 0.147912564;
        } else if (ageMonths >= 203 && ageMonths < 204) {
          L = -2.207681525;
          M = 20.87105449;
          S = 0.147815078;
        } else if (ageMonths >= 204 && ageMonths < 205) {
          L = -2.215737645;
          M = 20.90575839;
          S = 0.147723315;
        } else if (ageMonths >= 205 && ageMonths < 206) {
          L = -2.223739902;
          M = 20.93988477;
          S = 0.147637768;
        } else if (ageMonths >= 206 && ageMonths < 207) {
          L = -2.231667995;
          M = 20.97342858;
          S = 0.147559083;
        } else if (ageMonths >= 207 && ageMonths < 208) {
          L = -2.239511942;
          M = 21.00638171;
          S = 0.147487716;
        } else if (ageMonths >= 208 && ageMonths < 209) {
          L = -2.247257081;
          M = 21.0387374;
          S = 0.14742421;
        } else if (ageMonths >= 209 && ageMonths < 210) {
          L = -2.254885145;
          M = 21.07048996;
          S = 0.147369174;
        } else if (ageMonths >= 210 && ageMonths < 211) {
          L = -2.26238209;
          M = 21.10163241;
          S = 0.147323144;
        } else if (ageMonths >= 211 && ageMonths < 212) {
          L = -2.269731517;
          M = 21.13215845;
          S = 0.147286698;
        } else if (ageMonths >= 212 && ageMonths < 213) {
          L = -2.276917229;
          M = 21.16206171;
          S = 0.147260415;
        } else if (ageMonths >= 213 && ageMonths < 214) {
          L = -2.283925442;
          M = 21.1913351;
          S = 0.147244828;
        } else if (ageMonths >= 214 && ageMonths < 215) {
          L = -2.290731442;
          M = 21.21997472;
          S = 0.147240683;
        } else if (ageMonths >= 215 && ageMonths < 216) {
          L = -2.29732427;
          M = 21.24797262;
          S = 0.147248467;
        } else if (ageMonths >= 216 && ageMonths < 217) {
          L = -2.303687802;
          M = 21.27532239;
          S = 0.14726877;
        } else if (ageMonths >= 217 && ageMonths < 218) {
          L = -2.309799971;
          M = 21.30201933;
          S = 0.147302299;
        } else if (ageMonths >= 218 && ageMonths < 219) {
          L = -2.315651874;
          M = 21.32805489;
          S = 0.147349514;
        } else if (ageMonths >= 219 && ageMonths < 220) {
          L = -2.32121731;
          M = 21.35342563;
          S = 0.147411215;
        } else if (ageMonths >= 220 && ageMonths < 221) {
          L = -2.326481911;
          M = 21.37812462;
          S = 0.147487979;
        } else if (ageMonths >= 221 && ageMonths < 222) {
          L = -2.331428139;
          M = 21.40214589;
          S = 0.147580453;
        } else if (ageMonths >= 222 && ageMonths < 223) {
          L = -2.336038473;
          M = 21.42548351;
          S = 0.147689289;
        } else if (ageMonths >= 223 && ageMonths < 224) {
          L = -2.34029545;
          M = 21.44813156;
          S = 0.14781515;
        } else if (ageMonths >= 224 && ageMonths < 225) {
          L = -2.344181703;
          M = 21.47008412;
          S = 0.147958706;
        } else if (ageMonths >= 225 && ageMonths < 226) {
          L = -2.34768;
          M = 21.49133529;
          S = 0.148120633;
        } else if (ageMonths >= 226 && ageMonths < 227) {
          L = -2.350773286;
          M = 21.51187918;
          S = 0.148301619;
        } else if (ageMonths >= 227 && ageMonths < 228) {
          L = -2.353444725;
          M = 21.53170989;
          S = 0.148502355;
        } else if (ageMonths >= 228 && ageMonths < 229) {
          L = -2.355677743;
          M = 21.55082155;
          S = 0.148723546;
        } else if (ageMonths >= 229 && ageMonths < 230) {
          L = -2.35745607;
          M = 21.56920824;
          S = 0.148965902;
        } else if (ageMonths >= 230 && ageMonths < 231) {
          L = -2.358763788;
          M = 21.58686406;
          S = 0.149230142;
        } else if (ageMonths >= 231 && ageMonths < 232) {
          L = -2.359585369;
          M = 21.60378309;
          S = 0.149516994;
        } else if (ageMonths >= 232 && ageMonths < 233) {
          L = -2.359905726;
          M = 21.61995939;
          S = 0.149827195;
        } else if (ageMonths >= 233 && ageMonths < 234) {
          L = -2.359710258;
          M = 21.635387;
          S = 0.150161492;
        } else if (ageMonths >= 234 && ageMonths < 235) {
          L = -2.358980464;
          M = 21.65006126;
          S = 0.150520734;
        } else if (ageMonths >= 235 && ageMonths < 236) {
          L = -2.357714508;
          M = 21.6639727;
          S = 0.150905439;
        } else if (ageMonths >= 236 && ageMonths < 237) {
          L = -2.355892424;
          M = 21.67711736;
          S = 0.151316531;
        } else if (ageMonths >= 237 && ageMonths < 238) {
          L = -2.353501353;
          M = 21.68948935;
          S = 0.151754808;
        } else if (ageMonths >= 238 && ageMonths < 239) {
          L = -2.350528726;
          M = 21.70108288;
          S = 0.152221086;
        } else if (ageMonths >= 239 && ageMonths < 240) {
          L = -2.346962247;
          M = 21.71189225;
          S = 0.152716206;
        } else if (ageMonths >= 240 && ageMonths < 241) {
          L = -2.342796948;
          M = 21.72190973;
          S = 0.153240872;
        }
        zScore = (Math.pow(roundBmi / M, L) - 1) / (L * S);
      }

      const az = Math.abs(zScore);

      if (zScore < -3.09) {
        thisPercentile = 0.1;
      } else if (zScore > 3.09) {
        thisPercentile = 99.9;
      } else {
        thisPercentile = n[Math.round(az * 100)];
      }

      if (zScore < 0) {
        thisPercentile = 100 - thisPercentile;
      }

      thisPercentile = Math.round(thisPercentile * 10) / 10;

      let status, color, left;
      if (thisPercentile < 5) {
        status = "Underweight";
        param.tech_under = "bg-blue-800 text-white";
        color = "#20BEC8";
        left = "3";
      } else if (thisPercentile >= 5 && thisPercentile < 85) {
        status = "Healthy Weight";
        param.tech_healthy = "bg-green-800 text-white";
        color = "#10951D";
      } else if (thisPercentile >= 85 && thisPercentile < 95) {
        status = "Overweight";
        param.tech_over = "bg-turmeric text-white";
        color = "#CABE52";
      } else if (thisPercentile >= 95) {
        status = "Obese";
        param.tech_obese1 = "bg-red-800 text-white";
        color = "#FF0000";
      }

      if (thisPercentile >= 5 && thisPercentile < 10) {
        left = "13";
      }
      if (thisPercentile >= 10 && thisPercentile < 40) {
        left = "20";
      }
      if (thisPercentile >= 40 && thisPercentile < 60) {
        left = "30";
      }
      if (thisPercentile >= 60 && thisPercentile < 80) {
        left = "45";
      }
      if (thisPercentile >= 80 && thisPercentile < 85) {
        left = "48";
      }
      if (thisPercentile >= 85 && thisPercentile < 90) {
        left = "56";
      }
      if (thisPercentile >= 90 && thisPercentile < 95) {
        left = "70";
      }
      if (thisPercentile >= 95) {
        left = "82";
      }

      param.tech_child = "active";
      param.tech_BMI_kid = roundBmi;
      param.tech_percent = thisPercentile;
      param.tech_Status = status;
      param.tech_color = color;
      param.tech_left = left;
      param.tech_stage = stage;
      return param;
    } else {
      const convert_height = heightInInches;
      const BMI =
        Math.round(((weight * 703) / (convert_height * convert_height)) * 100) /
        100;
      const weight_lbs = weight / 2.205;
      const height_m = convert_height / 39.37;
      const PI = Math.round((weight_lbs / Math.pow(height_m, 3)) * 10) / 10;

      let status = "";
      let rotate = "";
      let color = "";
      let left = "";

      if (BMI <= 18.5) {
        status = "Underweight.";
        rotate = "-95";
        color = "#20BEC8";
        left = "2";
        result["tech_under"] = "bg-blue-800 text-white";
      } else if (BMI > 18.5 && BMI <= 24.9) {
        status = "Healthy Weight.";
        rotate = "-82";
        color = "#10951D";
        left = "26";
        result["tech_healthy"] = "bg-green-800 text-white";
      } else if (BMI > 24.9 && BMI <= 29.9) {
        status = "Overweight.";
        rotate = "-45";
        color = "#CABE52";
        left = "50";
        result["tech_over"] = "bg-turmeric text-white";
      } else if (BMI > 29.9 && BMI <= 34.9) {
        status = "Obese";
        rotate = "0";
        color = "#FF0000";
        left = "74";
        result["tech_obese1"] = "bg-red-800 text-white";
      } else if (BMI > 34.9 && BMI <= 39.9) {
        status = "Severely Obese.";
        rotate = "45";
        color = "#FF0000";
        left = "80";
        result["tech_obese2"] = "bg-red-800 text-white";
      } else {
        status = "Morbidly Obese.";
        rotate = "90";
        color = "#FF0000";
        left = "80";
        result["tech_obese3"] = "bg-red-800 text-white";
      }

      let Robinson, Miller, Devine, Hamwi;

      if (gender == "Female") {
        Robinson = Math.round(49 + (1.7 * (convert_height - 60)));
        Miller = Math.round(53.1 + (1.36 * (convert_height - 60)));
        Devine = Math.round(45.5 + (2.3 * (convert_height - 60)));
        Hamwi = Math.round(45 + (2.2 * (convert_height - 60)));
      } else {
        Robinson = Math.round(52 + (1.9 * (convert_height - 60)));
        Miller = Math.round(56.2 + (1.41 * (convert_height - 60)));
        Devine = Math.round(50 + (2.3 * (convert_height - 60)));
        Hamwi = Math.round(48 + (2.7 * (convert_height - 60)));
      }
      let ibw = "";
      if (unit_type === "lbs") {
        ibw = `${Math.round(Robinson * 2.205)} - ${Math.round(
          Hamwi * 2.205
        )} lbs`;
      } else if (unit_type === "kg") {
        ibw = `${Robinson} - ${Hamwi} kg`;
      }

      const heightFeet = Math.floor(ft_in / 12);
      const heightInch = ft_in % 12;

      // Return Values
      result["tech_BMI"] = BMI;
      result["tech_ibw"] = ibw;
      result["tech_PI"] = PI;
      result["tech_Add"] = "active";
      result["tech_Standerd"] = "active";
      result["tech_Feet"] = heightFeet;
      result["tech_Inch"] = heightInch;
      result["tech_Status"] = status;
      result["tech_Rotate"] = rotate;
      result["tech_color"] = color;
      result["tech_left"] = left;
      result["tech_stage"] = stage;
      return result;
    }
  }

  /**
   * getCalculationVatCalculator: Service Method
   * POST: /api/calculators-lol/vat-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationVatCalculator(body) {
    let vat = body.tech_vat;
    let amount = body.tech_amount;
    let method = body.tech_method;
    const param = {};

    // Validation
    if (!vat || !amount) {
      param.error = "Please fill all fields.";
      return param;
    }
    if (isNaN(vat) || isNaN(amount)) {
      param.error = "Invalid Input.";
      return param;
    }

    let vatAmount, net, gross;

    if (method === "add") {
      net = amount;
      vatAmount = (vat * amount) / 100;
      gross = amount + vatAmount;
    } else {
      gross = amount;
      const vatMultiplier = 1 + vat / 100;
      net = parseFloat((amount / vatMultiplier).toFixed(2));
      vatAmount = amount - net;
    }

    // Return values
    param.tech_vatAmount = vatAmount;
    param.tech_net = net;
    param.tech_gross = gross;
    return param;
  }

  /**
   * getCalculationSalestaxCalculator: Service Method
   * POST: /api/calculators-lol/salestax-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSalestaxCalculator(body) {
    let vat = body.tech_vat;
    let amount = body.tech_amount;
    let method = body.tech_method;

    const param = {};

    // Check if vat and amount are numeric
    if (isNaN(vat) || isNaN(amount)) {
      param.error = "Please fill any two fields.";
      return param;
    }

    let vatAmount, netBill;

    if (method === "add") {
      vatAmount = (vat * amount) / 100;
      netBill = amount + vatAmount;
    } else {
      const vatMultiplier = 1 + vat / 100;
      netBill = parseFloat((amount / vatMultiplier).toFixed(2));
      vatAmount = amount - netBill;
    }

    // Prepare response
    param.tech_vatAmount = parseFloat(vatAmount.toFixed(2));
    param.tech_netBill = parseFloat(netBill.toFixed(2));
    return param;
  }

  /**
   * getCalculationPriceElasticaityDemandCalculator: Service Method
   * POST: /api/calculators-lol/price-elasticity-demand-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPriceElasticaityDemandCalculator(body) {
    let unit_type = body.tech_unit_type;
    let method = body.tech_method;
    let prince = body.tech_prince;
    let quantity = body.tech_quantity;
    let n_q = body.tech_n_q;
    let i_q = body.tech_i_q;
    let n_p = body.tech_n_p;
    let i_p = body.tech_i_p;
    let i_r = body.tech_i_r;
    let f_r = body.tech_f_r;
    let inc = body.tech_inc;
    const param = {};
    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function round(num, decimals) {
      return Number(Math.round(num + "e" + decimals) + "e-" + decimals);
    }

    function getDemandType(PED) {
      console.log(PED);
      const absPED = Math.abs(PED); // ABS lelo, taake negative value ka magnitude mile
      if (absPED > 1) {
        return "Elastic Demand";
      } else if (absPED === 1) {
        return "Unitary Elastic";
      } else if (absPED < 1 && absPED > 0) {
        return "Inelastic Demand";
      } else if (absPED === 0) {
        return "Perfectly Inelastic";
      } else {
        return "Invalid PED";
      }
    }

    if (unit_type === "Revenue") {
      if (isNumeric(i_r) && isNumeric(f_r)) {
        if (
          isNumeric(i_r) &&
          isNumeric(f_r) &&
          (inc === undefined || inc === "")
        ) {
          if (i_r == 0) {
            var r_percent = "0";
          } else {
            var r_percent = round(((f_r - i_r) / i_r) * 100, 2);
          }
          param.tech_i_r = i_r;
          param.tech_f_r = f_r;
          param.tech_r_percent = r_percent;
          param.tech_rev = "active";
          return param;
        } else {
          param.error = "Please Enter Only Two Values.";
          return param;
        }
      }

      if (isNumeric(f_r) && isNumeric(inc)) {
        if (
          (i_r === undefined || i_r === "") &&
          isNumeric(f_r) &&
          isNumeric(inc)
        ) {
          const incFactor = inc / 100 + 1;
          const i_r_calc = round(f_r / incFactor, 2);
          param.tech_i_r = i_r_calc;
          param.tech_f_r = f_r;
          param.tech_r_percent = inc;
          param.tech_rev = "active";
          return param;
        } else {
          param.error = "Please Enter Only Two Values.";
          return param;
        }
      }

      if (isNumeric(i_r) && isNumeric(inc)) {
        if (
          (f_r === undefined || f_r === "") &&
          isNumeric(i_r) &&
          isNumeric(inc)
        ) {
          const incFactor = inc / 100;
          const f_r_calc = round(i_r + i_r * incFactor, 2);
          param.tech_i_r = i_r;
          param.tech_f_r = f_r_calc;
          param.tech_r_percent = inc;
          param.tech_rev = "active";
          return param;
        } else {
          param.error = "Please Enter Only Two Values.";
          return param;
        }
      }

      param.error = "Please Enter Only Two Values.";
      return param;
    } else if (method === "1") {
      if (
        isNumeric(i_p) &&
        isNumeric(n_p) &&
        isNumeric(i_q) &&
        isNumeric(n_q)
      ) {
        let PED;
        if (i_p == n_p) {
          PED = (n_q - i_q) / ((n_q + i_q) / 2);
        } else {
          PED =
            (n_q - i_q) / ((n_q + i_q) / 2) / ((n_p - i_p) / ((n_p + i_p) / 2));
        }

        PED = round(PED, 4);

        const type = getDemandType(PED);
        const i_r = i_p * i_q;
        const f_r = n_p * n_q;
        const r_percent = round(((f_r - i_r) / i_r) * 100, 2);

        param.tech_type = type;
        param.tech_i_r = i_r;
        param.tech_f_r = f_r;
        param.tech_r_percent = r_percent;
        param.tech_PED = PED;
        param.tech_method = method;
        return param;
      } else {
        param.error = "Please fill all fields.";
        return param;
      }
    } else if (method === "2") {
      if (
        isNumeric(i_p) &&
        isNumeric(n_p) &&
        isNumeric(i_q) &&
        isNumeric(n_q)
      ) {
        let PED;
        if (i_p == n_p) {
          PED = (n_q - i_q) / i_q;
        } else {
          PED = (n_q - i_q) / i_q / ((n_p - i_p) / i_p);
        }

        PED = round(PED, 4);

        const type = getDemandType(PED);
        const i_r = i_p * i_q;
        const f_r = n_p * n_q;
        const r_percent = round(((f_r - i_r) / i_r) * 100, 2);

        param.tech_type = type;
        param.tech_i_r = i_r;
        param.tech_f_r = f_r;
        param.tech_r_percent = r_percent;
        param.tech_PED = PED;
        param.tech_method = method;
        return param;
      } else {
        param.error = "Please fill all fields.";
        return param;
      }
    } else if (method === "3") {
      if (isNumeric(quantity) && isNumeric(prince)) {
        let PED = quantity / prince;
        PED = round(PED, 4);

        const type = getDemandType(PED);

        param.tech_type = type;
        param.tech_PED = PED;
        param.tech_method = method;
        return param;
      } else {
        param.error = "Please fill all fields.";
        return param;
      }
    }

    param.error = "Invalid Request.";
    return param;
  }

  /**
   * getCalculationWaccCalculator: Service Method
   * POST: /api/calculators-lol/wacc-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationWaccCalculator(body) {
    let param = {};

    // Helper functions
    function isNumeric(value) {
      return !isNaN(parseFloat(value)) && isFinite(value);
    }

    function round(value, decimals) {
      return Number(Math.round(value + "e" + decimals) + "e-" + decimals);
    }

    if (!body || typeof body !== "object") {
      param.error = "Invalid input!";
      return param;
    }

    if (body.tech_unit_type === "debt") {
      if (
        isNumeric(body.tech_risk) &&
        isNumeric(body.tech_beta) &&
        isNumeric(body.tech_eq)
      ) {
        const eq = round(body.tech_risk + body.tech_beta * body.tech_eq, 4);
        param.tech_eq = eq;
        return param;
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }
    } else if (body.tech_unit_type === "cd") {
      if (isNumeric(body.tech_rate) && isNumeric(body.tech_tax)) {
        if (
          isNumeric(body.tech_risk) &&
          isNumeric(body.tech_beta) &&
          isNumeric(body.tech_eq)
        ) {
          const eq = round(body.tech_risk + body.tech_beta * body.tech_eq, 4);
          param.tech_eq = eq;
        }
        const cd = round(
          (body.tech_rate / 100) * (1 - body.tech_tax / 100) * 100,
          4
        );
        param.tech_cd = cd;
        return param;
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }
    } else {
      if (
        isNumeric(body.tech_a) &&
        isNumeric(body.tech_b) &&
        isNumeric(body.tech_c) &&
        isNumeric(body.tech_d) &&
        isNumeric(body.tech_e)
      ) {
        const D = body.tech_a;
        let RD = body.tech_b / 100;
        const E = body.tech_c;
        let RE = body.tech_d / 100;
        let T = body.tech_e / 100;

        const wacc = round(
          ((E / (E + D)) * RE + (D / (E + D)) * RD * (1 - T)) * 100,
          4
        );
        const pfe = round((E / (E + D)) * 100, 4);
        const pfd = round((D / (E + D)) * 100, 4);

        RD = RD * 100;
        RE = RE * 100;
        T = T * 100;

        param = {
          tech_wacc: wacc,
          tech_D: D,
          tech_RD: RD,
          tech_E: E,
          tech_RE: RE,
          tech_pfe: pfe,
          tech_pfd: pfd,
          tech_T: T,
        };
        return param;
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }
    }
  }

  /**
   * getCalculationEbitdaCalculator: Service Method
   * POST: /api/calculators-lol/ebitda-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationEbitdaCalculator(body) {
    let param = {};

    // Helper functions
    function isNumeric(value) {
      return !isNaN(parseFloat(value)) && isFinite(value);
    }

    if (!body || typeof body !== "object") {
      param.error = "Invalid input!";
      return param;
    }

    let unit_type = body.tech_unit_type;
    let x = body.tech_x;
    let y = body.tech_y;
    let a = body.tech_a;
    let d = body.tech_d;
    let rev = body.tech_rev;
    let net = body.tech_net;
    let Interest = body.tech_Interest;
    let Taxes = body.tech_Taxes;
    let ae = body.tech_ae;
    let de = body.tech_de;

    if (unit_type === "simple") {
      if (isNumeric(x) && isNumeric(y) && isNumeric(a) && isNumeric(d)) {
        const ebitda = x - y + a + d;
        const margin = Math.round((ebitda / x) * 100 * 100) / 100; // Round to 2 decimals
        param.tech_ebitda = ebitda;
        param.tech_margin = margin + " %";
        return param;
      } else {
        param.error = "Please fill all fields.";
        return param;
      }
    } else if (unit_type === "extended") {
      if (
        isNumeric(rev) &&
        isNumeric(net) &&
        isNumeric(Interest) &&
        isNumeric(Taxes) &&
        isNumeric(ae) &&
        isNumeric(de)
      ) {
        const ebitda = net + Interest + Taxes + de + ae;
        const margin = Math.round((ebitda / rev) * 100 * 100) / 100;
        param.tech_ebitda = ebitda;
        param.tech_extended = "active";
        param.tech_margin = margin + " %";
        return param;
      } else {
        param.error = "Please fill all fields.";
        return param;
      }
    } else {
      param.error = "Invalid unit_type!";
      return param;
    }
  }

  /**
   * getCalculationPaypalFeeCalculator: Service Method
   * POST: /api/calculators-lol/paypal-fee-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPaypalFeeCalculator(body) {
    let param = {};

    // Helper function
    function isNumeric(value) {
      return !isNaN(parseFloat(value)) && isFinite(value);
    }

    if (!body || typeof body !== "object") {
      param.error = "Invalid input!";
      return param;
    }

    let x = body.tech_x;
    let rate = body.tech_rate;

    if (isNumeric(x)) {
      let fee = 0;
      let send = 0;

      switch (rate) {
        case "0":
          fee = Math.round(((2.9 / 100) * x + 0.3) * 100) / 100;
          send = Math.round(((100 * x + 30) / (100 - 2.9)) * 100) / 100;
          break;
        case "1":
          fee = Math.round(((2.7 / 100) * x + 0.3) * 100) / 100;
          send = Math.round(((100 * x + 30) / (100 - 2.7)) * 100) / 100;
          break;
        case "2":
          fee = Math.round(((2.2 / 100) * x + 0.3) * 100) / 100;
          send = Math.round(((100 * x + 30) / (100 - 2.2)) * 100) / 100;
          break;
        case "3":
          fee = Math.round(((5 / 100) * x + 0.05) * 100) / 100;
          send = Math.round(((100 * x + 5) / (100 - 5)) * 100) / 100;
          break;
        case "4":
          fee = Math.round(((4.4 / 100) * x + 0.3) * 100) / 100;
          send = Math.round(((100 * x + 30) / (100 - 4.4)) * 100) / 100;
          break;
        case "5":
          fee = Math.round(((4.2 / 100) * x + 0.3) * 100) / 100;
          send = Math.round(((100 * x + 30) / (100 - 4.2)) * 100) / 100;
          break;
        case "6":
          fee = Math.round(((3.7 / 100) * x + 0.3) * 100) / 100;
          send = Math.round(((100 * x + 30) / (100 - 3.7)) * 100) / 100;
          break;
        case "7":
          fee = Math.round(((6.5 / 100) * x + 0.05) * 100) / 100;
          send = Math.round(((100 * x + 5) / (100 - 6.5)) * 100) / 100;
          break;
        case "8":
          fee = Math.round((2.7 / 100) * x * 100) / 100;
          send = Math.round(((100 * x) / (100 - 2.7)) * 100) / 100;
          break;
        case "9":
          fee = Math.round(((3.5 / 100) * x + 0.15) * 100) / 100;
          send = Math.round(((100 * x + 15) / (100 - 3.5)) * 100) / 100;
          break;
        case "10":
          fee = Math.round(((3.1 / 100) * x + 0.3) * 100) / 100;
          send = Math.round(((100 * x + 30) / (100 - 3.1)) * 100) / 100;
          break;
        default:
          param.error = "Invalid rate!";
          return param;
      }

      const receive = Math.round((x - fee) * 100) / 100;
      const fee1 = Math.round((send - x) * 100) / 100;

      param.tech_receive = receive.toFixed(2);
      param.tech_send = send.toFixed(2);
      param.tech_fee = fee.toFixed(2);
      param.tech_fee1 = fee1.toFixed(2);

      return param;
    } else {
      param.error = "Please fill all fields.";
      return param;
    }
  }

  /**
   * getCalculationMarginOfErrorCalculator: Service Method
   * POST: /api/calculators-lol/margin-of-error-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMarginOfErrorCalculator(body) {
    let per = body.tech_per;
    let x = body.tech_x;
    let y = body.tech_y;
    let z = body.tech_z;

    if (per && x && y && z) {
      let perValue = per.split("@")[0];
      let p = x / 100;
      let n = y;
      let Na = z;
      let ans = 0;

      if (perValue == 11 || perValue == 22) {
        perValue = 2.05;
      }

      ans =
        Math.round(
          ((perValue * Math.sqrt(p * (1 - p))) / Math.sqrt(n)) * 10000
        ) / 10000;

      if (Na !== undefined && Na !== null && Na !== "") {
        if (n == Na) {
          ans = 0;
        } else {
          ans =
            (Math.round(
              ((perValue * Math.sqrt(p * (1 - p))) /
                Math.sqrt(((Na - 1) * n) / (Na - n))) *
                10000
            ) /
              10000) *
            100;
        }
      }

      return {
        tech_ans: `±${ans}%`,
        tech_x: body.tech_x,
        tech_y: body.tech_y,
        tech_z: body.tech_z,
        tech_per: body.tech_per,
      };
    } else {
      return {
        error: "Please fill all fields.",
      };
    }
  }

  /**
   * getCalculationCpmCalculator: Service Method
   * POST: /api/calculators-lol/cpm-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCpmCalculator(body) {
    let checkbox = body.tech_checkbox;
    let xf = body.tech_xf;
    let yf = body.tech_yf;
    let xs = body.tech_xs;
    let ys = body.tech_ys;
    let methodf = body.tech_methodf;
    let methods = body.tech_methods;
    let x = body.tech_x;
    let y = body.tech_y;
    let method = body.tech_method;
    let currency = body.tech_my_current;

    // Helper functions
    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function roundToThree(num) {
      return Math.round(num * 1000) / 1000;
    }

    if (checkbox) {
      // Checkbox selected case
      if (isNumeric(xf) && isNumeric(yf) && isNumeric(xs) && isNumeric(ys)) {
        let ansf, anss, cpmf, cpms;

        if (methodf === "cpm") {
          ansf = roundToThree((1000 * yf) / xf);
          cpmf = ansf;
          ansf = `${currency} ${ansf}`;
        } else if (methodf === "tc") {
          ansf = roundToThree((xf * yf) / 1000);
          cpmf = xf;
          ansf = `${currency} ${ansf}`;
        } else {
          cpmf = xf;
          ansf = roundToThree((1000 * yf) / xf);
        }

        if (methods === "cpm") {
          anss = roundToThree((1000 * ys) / xs);
          cpms = anss;
          anss = `${currency} ${anss}`;
        } else if (methods === "tc") {
          anss = roundToThree((xs * ys) / 1000);
          cpms = xs;
          anss = `${currency} ${anss}`;
        } else {
          cpms = xs;
          anss = roundToThree((1000 * ys) / xs);
        }
        return {
          tech_ansf: ansf,
          tech_cpmf: cpmf,
          tech_anss: anss,
          tech_cpms: cpms,
          tech_methodf: methodf,
          tech_methods: methods,
        };
      } else {
        return {
          error: "Please fill all fields.",
        };
      }
    } else {
      // Without checkbox case
      if (isNumeric(x) && isNumeric(y)) {
        let ansResult;
        if (method === "cpm") {
          ansResult = x == 0 ? 0 : roundToThree((1000 * y) / x);
        } else if (method === "tc") {
          ansResult = x == 0 ? 0 : roundToThree((x * y) / 1000);
        } else {
          ansResult = x == 0 ? 0 : roundToThree((1000 * y) / x);
        }

        return {
          tech_ans: `${currency} ${ansResult}`,
          tech_method: method,
        };
      } else {
        return {
          error: "Please fill all fields.",
        };
      }
    }
  }

  /**
   * getCalculationMarkupCalculator: Service Method
   * POST: /api/calculators-lol/markup-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMarkupCalculator(body) {
    let to_cal = body.tech_to_cal;
    let a = body.tech_a;
    let b = body.tech_b;
    let c = body.tech_c;
    let d = body.tech_d;

    let result = {};

    if (to_cal === "1") {
      if (!isNaN(a) && !isNaN(b)) {
        let cost = parseFloat(a);
        let markup = parseFloat(b);
        let revenue = cost + cost * (markup / 100);
        let profit = revenue - cost;
        let margin = (100 * profit) / revenue;

        result = {
          tech_cost: cost.toFixed(2),
          tech_markup: markup.toFixed(2),
          tech_revenue: revenue.toFixed(2),
          tech_profit: profit.toFixed(2),
          tech_margin: margin.toFixed(2),
        };
      } else {
        result.error = "Please fill all fields.";
      }
    } else if (to_cal === "2") {
      if (!isNaN(a) && !isNaN(c)) {
        let cost = parseFloat(a);
        let revenue = parseFloat(c);
        let profit = revenue - cost;
        let margin = (100 * profit) / revenue;
        let markup = (100 * profit) / cost;

        result = {
          tech_cost: cost.toFixed(2),
          tech_markup: markup.toFixed(2),
          tech_revenue: revenue.toFixed(2),
          tech_profit: profit.toFixed(2),
          tech_margin: margin.toFixed(2),
        };
      } else {
        result.error = "Please fill all fields.";
      }
    } else if (to_cal === "3") {
      if (!isNaN(a) && !isNaN(d)) {
        let cost = parseFloat(a);
        let profit = parseFloat(d);
        let revenue = profit + cost;
        let margin = (100 * profit) / revenue;
        let markup = (100 * profit) / cost;

        result = {
          tech_cost: cost.toFixed(2),
          tech_markup: markup.toFixed(2),
          tech_revenue: revenue.toFixed(2),
          tech_profit: profit.toFixed(2),
          tech_margin: margin.toFixed(2),
        };
      } else {
        result.error = "Please fill all fields.";
      }
    } else if (to_cal === "4") {
      if (!isNaN(b) && !isNaN(c)) {
        let markup = parseFloat(b);
        let revenue = parseFloat(c);
        let margin = (markup / 100 / (1 + markup / 100)) * 100;
        let cost = revenue - (margin * revenue) / 100;
        let profit = revenue - cost;

        result = {
          tech_cost: cost.toFixed(2),
          tech_markup: markup.toFixed(2),
          tech_revenue: revenue.toFixed(2),
          tech_profit: profit.toFixed(2),
          tech_margin: margin.toFixed(2),
        };
      } else {
        result.error = "Please fill all fields.";
      }
    } else if (to_cal === "5") {
      if (!isNaN(b) && !isNaN(d)) {
        let markup = parseFloat(b);
        let profit = parseFloat(d);
        let margin = (markup / 100 / (1 + markup / 100)) * 100;
        let revenue = (100 * profit) / margin;
        let cost = revenue - (margin * revenue) / 100;

        result = {
          tech_cost: cost.toFixed(2),
          tech_markup: markup.toFixed(2),
          tech_revenue: revenue.toFixed(2),
          tech_profit: profit.toFixed(2),
          tech_margin: margin.toFixed(2),
        };
      } else {
        result.error = "Please fill all fields.";
      }
    } else if (to_cal === "6") {
      if (!isNaN(c) && !isNaN(d)) {
        let revenue = parseFloat(c);
        let profit = parseFloat(d);
        let cost = revenue - profit;
        let markup = (100 * profit) / cost;
        let margin = (markup / 100 / (1 + markup / 100)) * 100;

        result = {
          tech_cost: cost.toFixed(2),
          tech_markup: markup.toFixed(2),
          tech_revenue: revenue.toFixed(2),
          tech_profit: profit.toFixed(2),
          tech_margin: margin.toFixed(2),
        };
      } else {
        result.error = "Please fill all fields.";
      }
    } else {
      result.error = "Please fill all fields.";
    }

    return result;
  }

  /**
   * getCalculationCapRateCalculator: Service Method
   * POST: /api/calculators-lol/cap-rate-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCapRateCalculator(body) {
    // Separate variables
    let prop_val = body.tech_prop_val;
    let ann_grs_inc = body.tech_ann_grs_inc;
    let op_exp = body.tech_op_exp;
    let op_exp_unit = body.tech_op_exp_unit;
    let vac_rate = body.tech_vac_rate;

    // Remove commas
    prop_val = prop_val ? prop_val.toString().replace(/,/g, "") : "0";
    ann_grs_inc = ann_grs_inc ? ann_grs_inc.toString().replace(/,/g, "") : "0";
    op_exp = op_exp ? op_exp.toString().replace(/,/g, "") : "0";
    vac_rate = vac_rate ? vac_rate.toString().replace(/,/g, "") : "0";

    let param = {};

    // Check if inputs are numeric
    if (!isNaN(prop_val) && !isNaN(ann_grs_inc) && !isNaN(op_exp)) {
      vac_rate = isNaN(vac_rate) ? 0 : parseFloat(vac_rate);

      prop_val = parseFloat(prop_val);
      ann_grs_inc = parseFloat(ann_grs_inc);
      op_exp = parseFloat(op_exp);

      let vac_rate1 = (vac_rate / 100) * ann_grs_inc;
      let grs_op_inc = ann_grs_inc - vac_rate1;
      let ann_net_inc = 0;

      if (op_exp_unit === "%") {
        ann_net_inc =
          ((100 - op_exp) / 100) * ((100 - vac_rate) / 100) * ann_grs_inc;
        param["percent"] = "%";
      } else {
        ann_net_inc = grs_op_inc - op_exp;
      }

      let cap = (ann_net_inc / prop_val) * 100;

      param["tech_grs_op_inc"] = Math.round(grs_op_inc).toLocaleString();
      param["tech_ann_net_inc"] = Math.round(ann_net_inc).toLocaleString();
      param["tech_cap"] = parseFloat(cap.toFixed(3));
      param["tech_prop_val"] = Math.round(prop_val).toLocaleString();
      param["tech_ann_grs_inc"] = Math.round(ann_grs_inc).toLocaleString();
      param["tech_op_exp"] = Math.round(op_exp).toLocaleString();
      param["tech_vac_rate"] = Math.round(vac_rate).toLocaleString();
      param["tech_vac_rate1"] = Math.round(vac_rate1).toLocaleString();
      param["input_prop_val"] = body.tech_prop_val;
      param["input_ann_grs_inc"] = body.tech_ann_grs_inc;
      param["input_op_exp"] = body.tech_op_exp;
      param["input_op_exp_unit"] = body.tech_op_exp_unit;
      param["input_vac_rate"] = body.tech_vac_rate;

      return param;
    } else {
      param["error"] = "Please! Check Your Input";
      return param;
    }
  }

  /**
   * getCalculationCapmRateCalculator: Service Method
   * POST: /api/calculators-lol/capm-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCapmRateCalculator(body) {
    // Separate variables
    let cal = body.tech_cal;
    let rf = body.tech_rf;
    let rm = body.tech_rm;
    let bi = body.tech_bi;
    let r = body.tech_r;

    let param = {};

    if (cal && !isNaN(rf) && !isNaN(rm) && !isNaN(bi) && !isNaN(r)) {
      rf = parseFloat(rf);
      rm = parseFloat(rm);
      bi = parseFloat(bi);
      r = parseFloat(r);

      let eq_market_prem = 0;
      let risk_prem = 0;
      let r_mr = 0;
      let r_mrp = 0;

      if (cal === "R" && !isNaN(rf) && !isNaN(rm) && !isNaN(bi)) {
        eq_market_prem = rm - rf;
        risk_prem = bi * eq_market_prem;
        r = rf + risk_prem;
        r_mr = (rm * bi) / rf;
        r_mrp = r + r_mr;
      } else if (cal === "Bi" && !isNaN(r) && !isNaN(rf) && !isNaN(rm)) {
        let s1 = r - rf;
        eq_market_prem = rm - rf;
        if (eq_market_prem > 0) {
          bi = s1 / eq_market_prem;
        } else {
          bi = 0;
        }
        risk_prem = bi * eq_market_prem;
        r_mr = (rm * bi) / rf;
        r_mrp = r + r_mr;
        param["s1"] = parseFloat(s1.toFixed(3));
      } else if (cal === "Rf" && !isNaN(r) && !isNaN(rm) && !isNaN(bi)) {
        let s1 = bi * rm;
        let s2 = s1 - r;
        let s3 = bi - 1;
        rf = s2 / s3;
        eq_market_prem = rm - rf;
        risk_prem = bi * eq_market_prem;
        r_mr = (rm * bi) / rf;
        r_mrp = r + r_mr;
        param["tech_s1"] = parseFloat(s1.toFixed(3));
        param["tech_s2"] = parseFloat(s2.toFixed(3));
        param["tech_s3"] = parseFloat(s3.toFixed(3));
      } else if (cal === "Rm" && !isNaN(r) && !isNaN(rf) && !isNaN(bi)) {
        let s1 = bi - 1;
        let s2 = rf * s1;
        let s3 = s2 + r;
        rm = s3 / bi;
        eq_market_prem = rm - rf;
        risk_prem = bi * eq_market_prem;
        r_mr = (rm * bi) / rf;
        r_mrp = r + r_mr;
        param["tech_s1"] = parseFloat(s1.toFixed(3));
        param["tech_s2"] = parseFloat(s2.toFixed(3));
        param["tech_s3"] = parseFloat(s3.toFixed(3));
      } else {
        param["error"] = "Please fill all fields.";
        return param;
      }

      param["tech_cal"] = cal;
      param["tech_R"] = parseFloat(r.toFixed(3));
      param["tech_Rp"] = parseFloat(risk_prem.toFixed(3));
      param["tech_Emp"] = parseFloat(eq_market_prem.toFixed(3));
      param["tech_Rf"] = parseFloat(rf.toFixed(3));
      param["tech_Rm"] = parseFloat(rm.toFixed(3));
      param["tech_Bi"] = parseFloat(bi.toFixed(3));
      param["tech_Rmr"] = parseFloat(r_mr.toFixed(3));
      param["tech_Rmrp"] = parseFloat(r_mrp.toFixed(3));
      param["input_cal"] = body.tech_cal;
      param["input_rf"] = body.tech_rf;
      param["input_rm"] = body.tech_rm;
      param["input_bi"] = body.tech_bi;
      param["input_r"] = body.tech_r;

      return param;
    } else {
      param["error"] = "Please fill all fields.";
      return param;
    }
  }

  /**
   * getCalculationMarginalCostCalculator: Service Method
   * POST: /api/calculators-lol/marginal-cost-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMarginalCostCalculator(body) {
    let unit_type = body.tech_unit_type;

    // Variables separate
    let dc, dq, dq_unit, sr;
    let cc, fc, cq, cq_unit, fq, fq_unit, gr;

    let param = {}; // same as $this->param in PHP

    if (unit_type === "sr") {
      dc = body.tech_dc;
      dq = body.tech_dq;
      dq_unit = body.tech_dq_unit;
      sr = unit_type;
    } else {
      cc = body.tech_cc;
      fc = body.tech_fc;
      cq = body.tech_cq;
      cq_unit = body.tech_cq_unit;
      fq = body.tech_fq;
      fq_unit = body.tech_fq_unit;
      gr = unit_type;
    }

    let check = false;

    if (sr) {
      if (!isNaN(dc) && !isNaN(dq) && dq_unit) {
        check = true;
      }
    } else {
      if (
        !isNaN(cc) &&
        !isNaN(fc) &&
        !isNaN(cq) &&
        !isNaN(fq) &&
        cq_unit &&
        fq_unit
      ) {
        check = true;
      }
    }

    if (check) {
      if (dq_unit) {
        if (dq_unit === "pairs") {
          dq = dq * 2;
        } else if (dq_unit === "decades") {
          dq = dq * 10;
        } else if (dq_unit === "dozens") {
          dq = dq * 12;
        }
      }

      if (cq_unit) {
        if (cq_unit === "pairs") {
          cq = cq * 2;
        } else if (cq_unit === "decades") {
          cq = cq * 10;
        } else if (cq_unit === "dozens") {
          cq = cq * 12;
        }
      }

      if (fq_unit) {
        if (fq_unit === "pairs") {
          fq = fq * 2;
        } else if (fq_unit === "decades") {
          fq = fq * 10;
        } else if (fq_unit === "dozens") {
          fq = fq * 12;
        }
      }

      let mc, dcFinal, dqFinal;

      if (sr) {
        if (!isNaN(dc) && !isNaN(dq)) {
          mc = dc / dq;
          dcFinal = dc;
          dqFinal = dq;
          param["tech_check"] = "m1";
        }
      } else if (gr) {
        if (!isNaN(cc) && !isNaN(fc) && !isNaN(cq) && !isNaN(fq)) {
          dcFinal = fc - cc;
          dqFinal = fq - cq;
          mc = dcFinal / dqFinal;
          param["tech_check"] = "m2";
          param["tech_cc"] = cc;
          param["tech_fc"] = fc;
          param["tech_cq"] = cq;
          param["tech_fq"] = fq;
        }
      } else {
        param["error"] = "Please fill all fields.";
        return param;
      }

      param["tech_mc"] = mc;
      param["tech_dc"] = dcFinal;
      param["tech_dq"] = dqFinal;

      return param;
    } else {
      param["error"] = "Please fill all fields.";
      return param;
    }
  }

  /**
   * getCalculationOvertimeCalculator: Service Method
   * POST: /api/calculators-lol/overtime-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationOvertimeCalculator(body) {
    // Separate variables from body
    let pay = body.tech_pay;
    let per = body.tech_per;
    let timeper = "h_m"; // Hardcoded as in your PHP code
    let multi = body.tech_multi;
    let time = body.tech_time;
    let over = body.tech_over;
    let overper = body.tech_overper; // not used but extracted

    let param = {};

    if (!isNaN(pay) && per && !isNaN(multi)) {
      let hourly = pay;

      if (per === "hour") {
        hourly = hourly;
      } else if (per === "day") {
        hourly = hourly / 8;
      } else if (per === "week") {
        hourly = hourly / 40;
      } else {
        hourly = hourly / 173.6;
      }

      let monthTime = time;

      if (timeper === "h_m") {
        monthTime = monthTime;
      } else if (timeper === "d_m") {
        monthTime = monthTime * 8;
      } else if (timeper === "w_m") {
        monthTime = monthTime * 5 * 8;
      } else if (timeper === "h_w") {
        monthTime = monthTime * 4.344;
      } else if (timeper === "d_w") {
        monthTime = monthTime * 8 * 4.345;
      } else if (timeper === "h_d") {
        monthTime = monthTime * 5 * 4.345;
      }

      let regPay = +(hourly * monthTime);

      let overPayPerHour = +(multi * hourly);
      let overHour = +over;
      let overTotalPay = +(overHour * overPayPerHour);

      param["tech_overPayPerHour"] = overPayPerHour;
      param["tech_overTotalPay"] = overTotalPay;
      param["tech_regPay"] = regPay;
      param["tech_total"] = overTotalPay + regPay;
      return param;
    } else {
      param["error"] = "Please fill all fields.";
      return param;
    }
  }

  /**
   * getCalculationRoiCalculator: Service Method
   * POST: /api/calculators-lol/roi-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationRoiCalculator(body) {
    function tech_years(tech_a, tech_b) {
      if (tech_b === "1") {
        return tech_a / 365;
      } else if (tech_b === "2") {
        return tech_a / 12;
      } else if (tech_b === "3") {
        return tech_a / 52.143;
      } else if (tech_b === "4") {
        return tech_a * 1;
      }
      return tech_a;
    }

    function tech_dateDiffInDays(tech_date1, tech_date2) {
      const tech_diff = new Date(tech_date2) - new Date(tech_date1);
      return Math.abs(Math.round(tech_diff / (1000 * 60 * 60 * 24)));
    }

    function tech_formatNumberWithCommas(tech_num) {
      const tech_parts = parseFloat(tech_num).toFixed(4).split(".");
      tech_parts[0] = tech_parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
      return tech_parts.join(".");
    }

    const {
      tech_invest: tech_invest,
      tech_return: tech_returnAmount,
      tech_find: tech_find,
      tech_annualized: tech_annualized,
      tech_date: tech_date,
      tech_s_date: tech_s_date,
      tech_e_date: tech_e_date,
      tech_length: tech_length,
      tech_length_unit: tech_length_unit,
      tech_compare: tech_compare,
      tech_invest_compare: tech_invest_compare,
      tech_return_compare: tech_return_compare,
      tech_find_compare: tech_find_compare,
      tech_annualized_compare: tech_annualized_compare,
      tech_date_compare: tech_date_compare,
      tech_s_date_compare: tech_s_date_compare,
      tech_e_date_compare: tech_e_date_compare,
      tech_length_compare: tech_length_compare,
      tech_length_unit_compare: tech_length_unit_compares,
    } = body;

    let result = {};
    let tech_annualized_answer, tech_time, tech_loss, tech_gain, tech_roi;

    // Convert length units to numeric values
    let tech_length_unit_val = "1";
    if (tech_length_unit === "days") tech_length_unit_val = "1";
    else if (tech_length_unit === "weeks") tech_length_unit_val = "2";
    else if (tech_length_unit === "months") tech_length_unit_val = "3";
    else if (tech_length_unit === "years") tech_length_unit_val = "4";

    let tech_length_unit_compare_val = "1";
    if (tech_length_unit_compares === "days")
      tech_length_unit_compare_val = "1";
    else if (tech_length_unit_compares === "weeks")
      tech_length_unit_compare_val = "2";
    else if (tech_length_unit_compares === "months")
      tech_length_unit_compare_val = "3";
    else if (tech_length_unit_compares === "years")
      tech_length_unit_compare_val = "4";

    // Validate required fields
    if (tech_invest === undefined || tech_returnAmount === undefined) {
      result.error = "Investment and return amount are required";
      return result;
    }

    // Main calculation
    if (!(tech_invest <= 0)) {
      if (!(tech_returnAmount <= 0)) {
        const tech_answer = tech_returnAmount - tech_invest;

        if (tech_answer >= 0) {
          tech_loss = "0.00";
          tech_gain = tech_answer;
        } else {
          tech_loss = (-1 * tech_answer).toFixed(2);
          tech_gain = "0.00";
        }

        const tech_a1 = tech_answer / tech_invest;
        tech_roi = (tech_a1 * 100).toFixed(2);

        if (tech_find === "1") {
          if (tech_date === "1") {
            if (!tech_s_date || !tech_e_date) {
              result.error = "Start and end dates are required";
              return result;
            }

            let tech_from = new Date(tech_s_date);
            let tech_to = new Date(tech_e_date);

            if (tech_from > tech_to)
              [tech_from, tech_to] = [tech_to, tech_from];

            result.tech_from = tech_from.toLocaleDateString("en-US", {
              month: "short",
              day: "numeric",
              year: "numeric",
            });
            result.tech_to = tech_to.toLocaleDateString("en-US", {
              month: "short",
              day: "numeric",
              year: "numeric",
            });

            const tech_days = tech_dateDiffInDays(tech_from, tech_to);
            const tech_yrs = tech_days / 365;
            const tech_top_n = 1 / tech_yrs;
            const tech_inner1 = 1 + tech_a1;
            const tech_outer = Math.pow(tech_inner1, tech_top_n);
            const tech_annual_ans = tech_outer - 1;
            tech_annualized_answer = tech_annual_ans * 100;
            tech_time = tech_yrs;
          } else if (tech_date === "2") {
            if (!tech_length || tech_length == 0) {
              result.error = "Investment Length cannot be zero.";
              return result;
            }

            const tech_length_yrs = tech_years(
              tech_length,
              tech_length_unit_val
            );
            const tech_n_top = 1 / tech_length_yrs;
            const tech_inner = 1 + tech_a1;
            const tech_final = Math.pow(tech_inner, tech_n_top);
            const tech_annualized_ans1 = tech_final - 1;
            tech_annualized_answer = tech_annualized_ans1 * 100;
            tech_time = tech_length_yrs;
          }

          if (tech_annualized_answer !== undefined) {
            result.tech_annualized_answer = tech_formatNumberWithCommas(
              tech_annualized_answer
            );
          }
        } else if (tech_find === "2") {
          if (!tech_annualized) {
            result.error = "Annualized rate is required";
            return result;
          }

          const tech_annual = tech_annualized / 100;
          const tech_plus_roi = 1 + tech_a1;
          const tech_left = tech_annual + 1;
          const tech_log_left = Math.log(tech_left);
          const tech_log_right = Math.log(tech_plus_roi);

          let tech_ans =
            tech_log_right === 0 ? 0 : tech_log_left / tech_log_right;
          tech_time = tech_ans === 0 ? 0 : 1 / tech_ans;
        }
      } else {
        result.error = "The minimum returned amount is 0.";
        return result;
      }
    } else {
      result.error = "You have to invest some money!";
      return result;
    }

    // Comparison calculation
    if (tech_compare === "2") {
      if (
        tech_invest_compare === undefined ||
        tech_return_compare === undefined
      ) {
        result.error = "Comparison investment and return amount are required";
        return result;
      }

      if (!(tech_invest_compare <= 0)) {
        if (!(tech_return_compare <= 0)) {
          const tech_answer2 = tech_return_compare - tech_invest_compare;
          let tech_loss2, tech_gain2;

          if (tech_answer2 >= 0) {
            tech_loss2 = "0.00";
            tech_gain2 = tech_answer2.toFixed(2);
          } else {
            tech_loss2 = (-1 * tech_answer2).toFixed(2);
            tech_gain2 = "0.00";
          }

          const tech_a12 = tech_answer2 / tech_invest_compare;
          const tech_roi2 = (tech_a12 * 100).toFixed(2);
          let tech_annualized_answer2, tech_time2;

          if (tech_find_compare === "1") {
            if (tech_date_compare === "1") {
              if (!tech_s_date_compare || !tech_e_date_compare) {
                result.error = "Comparison start and end dates are required";
                return result;
              }

              let tech_from2 = new Date(tech_s_date_compare);
              let tech_to2 = new Date(tech_e_date_compare);

              if (tech_from2 > tech_to2)
                [tech_from2, tech_to2] = [tech_to2, tech_from2];

              result.tech_from2 = tech_from2.toLocaleDateString("en-US", {
                month: "short",
                day: "numeric",
                year: "numeric",
              });
              result.tech_to2 = tech_to2.toLocaleDateString("en-US", {
                month: "short",
                day: "numeric",
                year: "numeric",
              });

              const tech_days2 = tech_dateDiffInDays(tech_from2, tech_to2);
              const tech_yrs2 = tech_days2 / 365;
              const tech_top_n2 = 1 / tech_yrs2;
              const tech_inner12 = 1 + tech_a12;
              const tech_outer2 = Math.pow(tech_inner12, tech_top_n2);
              const tech_annual_ans2 = tech_outer2 - 1;
              tech_annualized_answer2 = tech_annual_ans2 * 100;
              tech_time2 = tech_yrs2;
            } else if (tech_date_compare === "2") {
              if (!tech_length_compare || tech_length_compare == 0) {
                result.error = "Comparison investment length cannot be zero";
                return result;
              }

              const tech_length_compare_yrs = tech_years(
                tech_length_compare,
                tech_length_unit_compare_val
              );
              const tech_n_top2 = 1 / tech_length_compare_yrs;
              const tech_inner2 = 1 + tech_a12;
              const tech_final2 = Math.pow(tech_inner2, tech_n_top2);
              const tech_annualized_ans12 = tech_final2 - 1;
              tech_annualized_answer2 = tech_annualized_ans12 * 100;
              tech_time2 = tech_length_compare_yrs;
            }

            if (tech_annualized_answer2 !== undefined) {
              result.tech_annualized_answer2 = tech_formatNumberWithCommas(
                tech_annualized_answer2
              );
            }
          } else if (tech_find_compare === "2") {
            if (!tech_annualized_compare) {
              result.error = "Comparison annualized rate is required";
              return result;
            }

            const tech_annual2 = tech_annualized_compare / 100;
            const tech_plus_roi2 = 1 + tech_a12;
            const tech_left2 = tech_annual2 + 1;
            const tech_log_left2 = Math.log(tech_left2);
            const tech_log_right2 = Math.log(tech_plus_roi2);
            const tech_ans2 = tech_log_left2 / tech_log_right2;
            tech_time2 = 1 / tech_ans2;
          }

          result.tech_time2 = parseFloat(tech_time2.toFixed(3));
          result.tech_loss2 = tech_loss2;
          result.tech_gain2 = tech_gain2;
          result.tech_roi2 = tech_roi2;
        } else {
          result.error = "The minimum comparison returned amount is 0.";
          return result;
        }
      } else {
        result.error = "You have to invest some money for comparison!";
        return result;
      }
    }

    // Common result properties
    result.tech_time =
      tech_time !== undefined ? parseFloat(tech_time.toFixed(3)) : undefined;
    result.tech_loss = tech_loss;
    result.tech_gain = tech_gain;
    result.tech_roi = tech_roi;
    result.tech_compare = tech_compare;
    result.tech_find = tech_find;
    result.tech_date = tech_date;
    result.tech_s_date = tech_s_date;
    result.tech_e_date = tech_e_date;

    return result;
  }

  /**
   * getCalculationFutureValueOfAnnuityCalculator: Service Method
   * POST: /api/calculators-lol/future-value-of-annuity
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationFutureValueOfAnnuityCalculator(body) {
    let payment = parseFloat(body.tech_payment);
    let interest = parseFloat(body.tech_interest);
    let term = parseFloat(body.tech_term);
    let term_unit = body.tech_term_unit;
    let compounding = parseFloat(body.tech_compounding);
    let payment_fre = parseFloat(body.tech_payment_fre);
    let annuity_type = body.tech_annuity_type;
    let g = body.tech_g ? parseFloat(body.tech_g) : null;

    function yearsConvert(term, term_unit) {
      if (term_unit === "mons") {
        return term / 12;
      } else if (term_unit === "yrs") {
        return term * 1;
      }
      return term;
    }

    let param = {};

    if (!isNaN(payment) && !isNaN(interest) && !isNaN(term)) {
      term = yearsConvert(term, term_unit);
      let r = interest / 100;
      let i = r / compounding;
      let n = term * compounding;
      let f_part = 1 + i;
      let s_part = Math.pow(f_part, n);
      let up_part = s_part - 1;
      let l_part = payment / i;

      let annuity;
      if (annuity_type === "mons") {
        annuity = up_part * l_part;
      } else if (annuity_type === "yrs") {
        let annuity_ans = up_part * l_part;
        annuity = annuity_ans * f_part;
      }

      if (!isNaN(g)) {
        if (g === i) {
          let n1 = n - 1;
          let s_part2 = Math.pow(f_part, n1);
          annuity = payment * n * s_part2;
        } else if (g !== i) {
          let G = g / 100;
          let ig = i - G;
          let iG = 1 + G;
          let ig_part = Math.pow(iG, n);
          let part1 = payment / ig;
          let part2 = s_part - ig_part;
          annuity = part1 * part2;
        }
      }

      if (compounding === 366) {
        let ry = r * term;
        let e1 = Math.pow(Math.E, ry);
        let e2 = Math.pow(Math.E, r);
        let top = e1 - 1;
        let down = e2 - 1;
        let annu = top / down;
        annuity = payment * annu;
      }

      let div = r / compounding;
      let top_div = compounding / payment_fre;
      let final_a = div + 1;
      let overall = Math.pow(final_a, top_div);
      let res = overall - 1;
      let equ = payment_fre * res * 100;
      let equ2 = equ;

      if (payment_fre === 1) {
        term = term * 1;
        annuity = annuity * 1;
        equ2 = equ;
      } else if (payment_fre === 2) {
        term = term * 2;
        annuity = annuity * 2;
        equ2 = equ / 2;
      } else if (payment_fre === 4) {
        term = term * 4;
        annuity = annuity * 4;
        equ2 = equ / 4;
      } else if (payment_fre === 12) {
        term = term * 12;
        annuity = annuity * 12;
        equ2 = equ / 12;
      } else if (payment_fre === 52) {
        term = term * 52;
        annuity = annuity * 52;
        equ2 = equ / 52;
      } else if (payment_fre === 365) {
        term = term * 365;
        annuity = annuity * 365;
        equ2 = equ / 365;
      }

      param["tech_term"] = term.toFixed(2);
      param["tech_annuity"] = annuity.toFixed(2);
      param["tech_equ"] = equ.toFixed(4);
      param["tech_equ2"] = equ2.toFixed(4);
    } else {
      param["error"] = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationUnemploymentRateCalculator: Service Method
   * POST: /api/calculators-lol/unemployment-rate-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationUnemploymentRateCalculator(body) {
    let employed_people = parseFloat(body.tech_employed_people);
    let unemployed_people = parseFloat(body.tech_unemployed_people);
    let adult_population = body.tech_adult_population;
    let calculate = body.tech_calculate;
    let labor_force = parseFloat(body.tech_labor_force);
    let unemployment_rate = parseFloat(body.tech_unemployment_rate);

    let param = {};
    let method;

    if (calculate == "1") {
      method = 1;
      if (!isNaN(employed_people) && !isNaN(unemployed_people)) {
        let cal_labor_force = employed_people + unemployed_people;
        let cal_unemployed_people = (unemployed_people / cal_labor_force) * 100;
        param["tech_labor_force"] = cal_labor_force.toFixed(2);
        param["tech_unemployment_rate"] = cal_unemployed_people.toFixed(2);
      } else {
        param["error"] = "Please fill all fields.";
        return param;
      }
    } else if (calculate == "2") {
      method = 2;
      if (!isNaN(labor_force) && !isNaN(unemployment_rate)) {
        let percent = unemployment_rate / 100;
        let unemployment = labor_force * percent;
        let employment = labor_force - unemployment;
        param["tech_unemployment"] = unemployment.toFixed(2);
        param["tech_employment"] = employment.toFixed(2);
      } else {
        param["error"] = "Please fill all fields.";
        return param;
      }
    }

    if (adult_population !== "") {
      adult_population = parseFloat(adult_population);
      if (!isNaN(adult_population)) {
        let cal_labor_force = employed_people + unemployed_people;
        let labor_force_participation =
          (cal_labor_force / adult_population) * 100;
        param["tech_labor_force_participation"] =
          labor_force_participation.toFixed(2);
      } else {
        param["error"] = "Please fill all fields.";
        return param;
      }
    }

    param["tech_method"] = method;

    return param;
  }

  /**
   * getCalculationCostOfEquityCalculator: Service Method
   * POST: /api/calculators-lol/cost-of-equity-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCostOfEquityCalculator(body) {
    let pay = body.tech_pay;
    let dividend_per_share = parseFloat(body.tech_dividend_per_share);
    let current_market_value = parseFloat(body.tech_current_market_value);
    let growth_rate_dividend = parseFloat(body.tech_growth_rate_dividend);
    let risk_rate_return = parseFloat(body.tech_risk_rate_return);
    let market_rate_return = parseFloat(body.tech_market_rate_return);
    let beta = parseFloat(body.tech_beta);

    let param = {};
    let final_answer;

    if (pay == "1") {
      if (
        !isNaN(dividend_per_share) &&
        !isNaN(current_market_value) &&
        !isNaN(growth_rate_dividend)
      ) {
        let ans =
          dividend_per_share / current_market_value +
          growth_rate_dividend / 100;
        final_answer = ans * 100;
      } else {
        param["error"] = "Please fill all fields.";
        return param;
      }
    } else if (pay == "2") {
      if (
        !isNaN(risk_rate_return) &&
        !isNaN(market_rate_return) &&
        !isNaN(beta)
      ) {
        final_answer =
          risk_rate_return + beta * (market_rate_return - risk_rate_return);
      } else {
        param["error"] = "Please fill all fields.";
        return param;
      }
    } else {
      param["error"] = "Invalid pay option.";
      return param;
    }

    param["tech_ans"] = final_answer.toFixed(2);
    param["tech_pay"] = pay;

    return param;
  }

  /**
   * getCalculationConsumerSurplusCalculator: Service Method
   * POST: /api/calculators-lol/consumer-surplus-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationConsumerSurplusCalculator(body) {
    let operations1 = body.tech_operations1;
    let operations2 = body.tech_operations2;
    let first = parseFloat(body.tech_first);
    let second = parseFloat(body.tech_second);
    let third = parseFloat(body.tech_third);
    let four = parseFloat(body.tech_four);
    let five = parseFloat(body.tech_five);

    let param = {};
    let answer1, answer2, pmax, ps, line1, line2;

    if (operations1 == "1") {
      if (!isNaN(first) && !isNaN(second) && !isNaN(third)) {
        answer1 = second - first;
        pmax = second;
        line1 = "Consumer Surplus";
        ps = answer1 + five;
      } else {
        param["error"] = "Please fill all fields.";
        return param;
      }
    } else if (operations1 == "2") {
      if (!isNaN(first) && !isNaN(second) && !isNaN(five)) {
        answer1 = second - first;
        pmax = second;
        ps = first + five;
        line1 = "Actual Price";
      } else {
        param["error"] = "Please fill all fields.";
        return param;
      }
    } else if (operations1 == "3") {
      if (!isNaN(first) && !isNaN(second) && !isNaN(five)) {
        answer1 = second + first;
        pmax = answer1;
        ps = first + five;
        line1 = "Willing Price";
      } else {
        param["error"] = "Please fill all fields.";
        return param;
      }
    } else {
      param["error"] = "Invalid operations1 option.";
      return param;
    }

    if (operations2 == "1") {
      if (!isNaN(third) && !isNaN(four)) {
        let mul1 = four * 0.5;
        answer2 = mul1 - pmax - third;
        line2 = "Extended Consumer Surplus";
      } else {
        param["error"] = "Please fill all fields.";
        return param;
      }
    } else if (operations2 == "2") {
      if (!isNaN(third) && !isNaN(four)) {
        let mul1 = 0.5 * four;
        answer2 = mul1 - pmax - third;
        line2 = "Equilibrium Price";
      } else {
        param["error"] = "Please fill all fields.";
        return param;
      }
    } else if (operations2 == "3") {
      if (!isNaN(third) && !isNaN(four)) {
        let div = four / 0.5;
        answer2 = div + pmax + third;
        line2 = "Equilibrium Quantity";
      } else {
        param["error"] = "Please fill all fields.";
        return param;
      }
    } else {
      param["error"] = "Invalid operations2 option.";
      return param;
    }

    param["tech_answer1"] = answer1.toFixed(2);
    param["tech_answer2"] = answer2.toFixed(2);
    param["tech_line1"] = line1;
    param["tech_ps"] = ps.toFixed(2);
    param["tech_line2"] = line2;
    param["tech_operations1"] = operations1;
    param["tech_operations2"] = operations2;
    return param;
  }

  /**
   * getCalculationStockCalculator: Service Method
   * POST: /api/calculators-lol/stock-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationStockCalculator(body) {
    let first = body.tech_first;
    let second = body.tech_second;
    let third = body.tech_third;
    let t_unit = body.tech_t_unit;
    let four = body.tech_four;
    let five = body.tech_five;
    let f_unit = body.tech_f_unit;
    let cgt = body.tech_cgt;
    let mycurrency = body.tech_mycurrency;

    let param = {};

    if (t_unit === "%") {
      t_unit = 1;
    } else {
      t_unit = 0.01;
    }

    if (f_unit === "%") {
      f_unit = 1;
    } else {
      f_unit = 0.01;
    }
    // if (t_unit === '%') {
    //     t_unit = 1;
    // } else if (t_unit === mycurrency) {
    //     t_unit = 0.01;
    // }

    // if (f_unit === '%') {
    //     f_unit = 1;
    // } else if (f_unit === mycurrency) {
    //     f_unit = 0.01;
    // }

    third = third * t_unit;
    five = five * f_unit;

    if (
      !isNaN(first) &&
      !isNaN(second) &&
      !isNaN(third) &&
      !isNaN(four) &&
      !isNaN(five) &&
      !isNaN(cgt)
    ) {
      if (cgt > 0) {
        let div1 = first / 100;
        let mul1 = second * third;
        let b_c = 0;

        if (t_unit === 1) {
          b_c = div1 * mul1;
        } else if (t_unit === 0.01) {
          b_c = third * 100;
        }

        let net_by = second * first;
        let netby_ans = net_by + b_c;

        let mul2 = four * five;
        let s_c = 0;

        if (f_unit === 1) {
          s_c = div1 * mul2;
        } else if (f_unit === 0.01) {
          s_c = five * 100;
        }

        let net_sa = four * first;
        let netsa_ans = net_sa - s_c;

        let profit = netsa_ans - netby_ans;
        let pro_per = profit / cgt;
        let pro_ans = profit - pro_per;

        let roi = profit / netby_ans;
        let roi_ans = roi * 100;
        let roi_ans1 = roi_ans / cgt;
        let roi_answer = roi_ans - roi_ans1;

        let per = five / 100;
        let minus_per = 1 - per;
        let mul_no = first * minus_per;
        let break_ans = netby_ans / mul_no;

        param.tech_b_c = b_c;
        param.tech_netby_ans = netby_ans;
        param.tech_s_c = s_c;
        param.tech_netsa_ans = netsa_ans;
        param.tech_profit = pro_ans;
        param.tech_roi_ans = roi_answer;
        param.tech_break_ans = break_ans;
      } else {
        param.error = "CGT Rate cannot be negative.";
      }
    } else {
      param.error = "Please fill all fields.";
    }

    return param;
  }

  /**
   * getCalculationPayRaiseCalculator: Service Method
   * POST: /api/calculators-lol/pay-raise-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPayRaiseCalculator(body) {
    let pay = body.tech_pay;
    let period = body.tech_period;
    let hour = body.tech_hour;
    let type = body.tech_type;
    let newAmount = body.tech_new;

    let param = {};

    if (!isNaN(pay) && !isNaN(hour) && !isNaN(newAmount)) {
      let hourly,
        weekly,
        monthly,
        yearly,
        incHour,
        incWeek,
        incMonth,
        incYear,
        percent;

      if (period == 1) {
        hourly = pay;
        weekly = pay * hour;
        monthly = Math.round(weekly * 4.3333 * 1000) / 1000;
        yearly = weekly * 52;
      } else if (period == 2) {
        hourly = pay / hour;
        weekly = pay;
        monthly = Math.round(weekly * 4.3333 * 1000) / 1000;
        yearly = weekly * 52;
      } else if (period == 3) {
        monthly = pay;
        yearly = monthly * 12;
        weekly = Math.round(((monthly * 12) / 52) * 1000) / 1000;
        hourly = weekly / hour;
      } else if (period == 4) {
        yearly = pay;
        monthly = yearly / 12;
        weekly = Math.round(((monthly * 12) / 52) * 1000) / 1000;
        hourly = weekly / hour;
      }

      if (type == 1) {
        incHour = hourly * (newAmount / 100);
        incWeek = weekly * (newAmount / 100);
        incMonth = monthly * (newAmount / 100);
        incYear = yearly * (newAmount / 100);
        percent = newAmount;
      } else {
        if (period == 1) {
          percent = (newAmount / hourly) * 100;
        } else if (period == 2) {
          percent = (newAmount / weekly) * 100;
        } else if (period == 3) {
          percent = (newAmount / monthly) * 100;
        } else if (period == 4) {
          percent = (newAmount / yearly) * 100;
        }
        incHour = hourly * (percent / 100);
        incWeek = weekly * (percent / 100);
        incMonth = monthly * (percent / 100);
        incYear = yearly * (percent / 100);
      }

      param.tech_percent = Math.round(percent * 100) / 100;
      param.tech_incHour = Math.round(incHour * 1000) / 1000;
      param.tech_incWeek = Math.round(incWeek * 1000) / 1000;
      param.tech_incMonth = Math.round(incMonth * 1000) / 1000;
      param.tech_incYear = Math.round(incYear * 1000) / 1000;
      param.tech_hourly = Math.round(hourly * 1000) / 1000;
      param.tech_weekly = Math.round(weekly * 1000) / 1000;
      param.tech_monthly = Math.round(monthly * 1000) / 1000;
      param.tech_yearly = Math.round(yearly * 1000) / 1000;
      param.tech_type = type;
      return param;
    } else {
      param.error = "Please fill all fields.";
      return param;
    }
  }

  /**
   * getCalculationRoasCalculator: Service Method
   * POST: /api/calculators-lol/roas-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationRoasCalculator(body) {
    let first = body.tech_first;
    let hidden_currency = body.tech_hidden_currency;
    let operations1 = body.tech_operations1;
    let second = body.tech_second;
    let third = body.tech_third;

    let param = {};

    if (operations1 == 1) {
      if (!isNaN(first) && !isNaN(second)) {
        let divide1 = second / first;
        let answer1 = divide1 * 100;
        let line = "";

        if (!isNaN(third)) {
          let answer2 = third - first;
          param.tech_answer2 = answer2;
        }

        if (answer1 > 0 && answer1 < 400) {
          line = `❌ Danger! Your ROAS is ${answer1.toFixed(
            2
          )}% that is alarming. If return is less than 400% ROAS, you are in loss. So you actually spend more on ad campaign.`;
        } else if (answer1 >= 400 && answer1 < 800) {
          line = `🚫 Your ROAS is ${answer1.toFixed(
            2
          )}% that is fair enough. But you must target 800% and spend more than before in ads.`;
        } else if (answer1 >= 800) {
          line = `✔ Great! Your ROAS is ${answer1.toFixed(
            2
          )}% that is fairly good enough.`;
        }

        param.tech_answer1 = answer1;
        param.tech_line = line;
        param.tech_first = first;
        param.tech_second = second;
        param.tech_operations1 = operations1;
        return param;
      } else {
        param.error = "Please fill all fields.";
        return param;
      }
    } else if (operations1 == 2) {
      if (!isNaN(first)) {
        if (first > 0) {
          let answer1 = first * 8;
          let answer2 = answer1 * 10;
          let line = `✅ Aim for ${hidden_currency} ${answer1} as climbing 800% ROAS will let you earn good initiatives.`;

          param.tech_answer1 = answer1;
          param.tech_answer2 = answer2;
          param.tech_line = line;
          param.tech_first = first;
          param.tech_second = second;
          param.tech_operations1 = operations1;
          return param;
        } else {
          param.error = "Money spent on ads cannot be negative or zero";
          return param;
        }
      } else {
        param.error = "Please fill all fields.";
        return param;
      }
    } else {
      param.error = "Invalid operation selected.";
      return param;
    }
  }

  /**
   * getCalculationTurboCalculator: Service Method
   * POST: /api/calculators-lol/turo-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationTurboCalculator(body) {
    let type = body.tech_type;
    let operations = body.tech_operations;
    let first = body.tech_first;
    let second = body.tech_second;
    let third = body.tech_third;
    let four = body.tech_four;
    let f_first = body.tech_f_first;
    let f_second = body.tech_f_second;
    let f_third = body.tech_f_third;

    let param = {};

    if (type === "first") {
      if (!isNaN(f_first) && !isNaN(f_second) && !isNaN(f_third)) {
        let multiply = f_third * f_second;
        let answer = multiply - f_first;
        let heading = "Turo Profit";

        param.tech_answer = answer;
        param.tech_heading = heading;
        param.tech_type = type;
        return param;
      } else {
        param.error = "Please fill all fields.";
        param.tech_type = type;
        return param;
      }
    } else if (type === "second") {
      if (operations === "1") {
        if (!isNaN(first) && !isNaN(second)) {
          let answer = first * second;
          let heading = "Income";

          param.tech_answer = answer;
          param.tech_heading = heading;
          param.tech_type = type;
          param.tech_operations = operations;
          return param;
        } else {
          param.error = "Please fill all fields.";
          param.tech_type = type;
          param.tech_operations = operations;
          return param;
        }
      } else if (operations === "2") {
        if (!isNaN(first) && !isNaN(second) && !isNaN(third)) {
          let divide = first / third;
          let answer = divide + second;
          answer = parseFloat(answer.toFixed(2));
          let heading = "Lease Details";

          param.tech_answer = answer;
          param.tech_heading = heading;
          param.tech_type = type;
          param.tech_operations = operations;
          return param;
        } else {
          param.error = "Please fill all fields.";
          param.tech_type = type;
          param.tech_operations = operations;
          return param;
        }
      } else if (operations === "3") {
        if (!isNaN(first) && !isNaN(second) && !isNaN(third) && !isNaN(four)) {
          let answer = first + second + 50 + four;
          let heading = "Expenses";

          param.tech_answer = answer;
          param.tech_heading = heading;
          param.tech_type = type;
          param.tech_operations = operations;
          return param;
        } else {
          param.error = "Please fill all fields.";
          return param;
        }
      }
    }

    param.error = "Invalid operation or type.";
    return param;
  }

  /**
   * getCalculationCommissionCalculator: Service Method
   * POST: /api/calculators-lol/commission-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCommissionCalculator(body) {
    let find = body.tech_find;
    let select1 = body.tech_select1;
    let sale_price = body.tech_sale_price;
    let commission_rate = body.tech_commission_rate;
    let commission_amount = body.tech_commission_amount;

    let param = {};

    if (find === "1" || find === "2") {
      let method = 1;

      if (select1 === "commission") {
        if (
          !isNaN(sale_price) &&
          !isNaN(commission_rate) &&
          sale_price > 0 &&
          commission_rate > 0
        ) {
          let answer = (sale_price * commission_rate) / 100;
          param.tech_sale_price = sale_price;
          param.tech_commission_rate = commission_rate;
          param.tech_answer = answer;
          param.tech_method = method;
          return param;
        } else {
          param.error = "Please fill all fields.";
          return param;
        }
      } else if (select1 === "sale_price") {
        method = 2;
        if (
          !isNaN(commission_rate) &&
          !isNaN(commission_amount) &&
          commission_rate > 0 &&
          commission_amount > 0
        ) {
          let answer = (commission_amount / commission_rate) * 100;
          param.tech_commission_rate = commission_rate;
          param.tech_commission_amount = commission_amount;
          param.tech_answer = answer;
          param.tech_method = method;
          return param;
        } else {
          param.error = "Please fill all fields.";
          return param;
        }
      } else if (select1 === "commission_rate") {
        method = 3;
        if (
          !isNaN(sale_price) &&
          !isNaN(commission_amount) &&
          sale_price > 0 &&
          commission_amount > 0
        ) {
          let answer = (commission_amount / sale_price) * 100;
          param.tech_sale_price = sale_price;
          param.tech_commission_amount = commission_amount;
          param.tech_answer = answer;
          param.tech_method = method;
          return param;
        } else {
          param.error = "Please fill all fields.";
          return param;
        }
      }
    }

    param.error = "Invalid calculation method or missing fields.";
    return param;
  }

  /**
   * getCalculationTimeAndaHalfCalculator: Service Method
   * POST: /api/calculators-lol/time-and-a-half
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationTimeAndaHalfCalculator(body) {
    let currency = body.tech_currency.trim();
    let normal_pay = parseFloat(body.tech_normal_pay.trim());
    let normal_time = parseFloat(body.tech_normal_time.trim());
    let over_time = parseFloat(body.tech_over_time.trim());
    let multiplier = parseFloat(body.tech_multiplier.trim());
    let pay_period = parseInt(body.tech_pay_period.trim(), 10);

    let param = {};

    if (
      !isNaN(normal_pay) &&
      !isNaN(normal_time) &&
      !isNaN(over_time) &&
      !isNaN(pay_period)
    ) {
      if (
        normal_pay >= 0 &&
        normal_time >= 0 &&
        over_time >= 0 &&
        pay_period >= 0
      ) {
        let half,
          half_pay,
          Overtime_Pay_per_Year,
          standered_pay,
          total,
          Regular_Pay_per_Year,
          Total_Pay_per_Year;

        if (
          (over_time === "" && normal_pay === 0) ||
          (over_time === 0 && normal_pay === 0)
        ) {
          half = "";
          half_pay = 0;
          Overtime_Pay_per_Year = 0;
          normal_pay = 0;
          normal_time = 0;
        } else if (over_time === 0 || over_time === "") {
          half = normal_pay * multiplier;
          half_pay = 0;
          Overtime_Pay_per_Year = 0;
        } else {
          half = normal_pay * multiplier;
          half_pay = normal_pay * multiplier * over_time;
          Overtime_Pay_per_Year = half_pay * pay_period;
        }

        if (normal_pay === 0 && normal_time === 0) {
          standered_pay = 0;
          total = "";
          Regular_Pay_per_Year = 0;
          Total_Pay_per_Year = 0;
        } else {
          standered_pay = normal_pay * normal_time;
          total = standered_pay + half_pay;
          Regular_Pay_per_Year = standered_pay * pay_period;
          Total_Pay_per_Year = total * pay_period;
        }

        param.tech_currency = currency;
        param.tech_normal_pay = normal_pay;
        param.tech_half = half;
        param.tech_half_pay = half_pay;
        param.tech_Overtime_Pay_per_Year = Overtime_Pay_per_Year;
        param.tech_standed_pay = standered_pay;
        param.tech_total = total;
        param.tech_Regular_Pay_per_Year = Regular_Pay_per_Year;
        param.tech_Total_Pay_per_Year = Total_Pay_per_Year;
        param.tech_multiplier = multiplier;
        param.tech_over_time = over_time;
        param.tech_normal_time = normal_time;

        return param;
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }
    } else {
      param.error = "Please! Check Your Input";
      return param;
    }
  }

  /**
   * getCalculationVariableCostCalculator: Service Method
   * POST: /api/calculators-lol/variable-cost-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationVariableCostCalculator(body) {
    let type = body.tech_type;
    let cost = parseFloat(body.tech_cost.trim());
    let output = parseFloat(body.tech_output.trim());

    let param = {};

    if (type && (type === "average_cost" || type === "variable_cost")) {
      if (isNaN(cost) || isNaN(output)) {
        param.error = "Please fill all fields.";
        return param;
      }

      if (type === "average_cost") {
        let av_cost = cost / output;
        param.tech_cost = cost;
        param.tech_output = output;
        param.tech_av_cost = av_cost;
      } else if (type === "variable_cost") {
        let v_cost = cost - output;
        param.tech_cost = cost;
        param.tech_output = output;
        param.tech_v_cost = v_cost;
      }
    } else {
      param.error = "Please fill all fields.";
      return param;
    }

    param.tech_type = type;
    return param;
  }

  /**
   * getCalculationGrowthRateCalculator: Service Method
   * POST: /api/calculators-lol/growth-rate-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationGrowthRateCalculator(body) {
    let operation = body.tech_operation.trim();
    let present_val = parseFloat(body.tech_present_val.trim());
    let past_val = parseFloat(body.tech_past_val.trim());
    let time_val = parseFloat(body.tech_time_val.trim());

    let param = {};

    if (operation === "1") {
      if (isNaN(present_val) || isNaN(past_val)) {
        param.error = "Please! Check Your Input";
        param.tech_operation = operation;
        return param;
      }

      let growth_diff = present_val - past_val;
      let growth_val = growth_diff / past_val;
      let growth_percent = growth_val * 100;
      param.tech_growth_diff = growth_diff;
      param.tech_growth_val = growth_val;
      param.tech_growth_percent = growth_percent;
    } else if (operation === "2") {
      if (isNaN(present_val) || isNaN(past_val) || isNaN(time_val)) {
        param.error = "Please! Check Your Input";
        param.tech_operation = operation;
        return param;
      }

      let growth_sub = present_val / past_val;
      let time_p = 1 / time_val;
      let g_val = Math.pow(growth_sub, time_p);
      let growth_val = g_val - 1;
      let growth_percent = growth_val * 100;
      param.tech_growth_sub = growth_sub;
      param.tech_g_val = g_val;
      param.tech_growth_val = growth_val;
      param.tech_growth_percent = growth_percent;
    } else {
      param.error = "Invalid operation";
      return param;
    }

    param.tech_present_val = present_val;
    param.tech_past_val = past_val;
    param.tech_time_val = time_val;
    param.tech_operation = operation;
    return param;
  }

  /**
   * getCalculationLaborCostCalculator: Service Method
   * POST: /api/calculators-lol/growth-rate-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationLaborCostCalculator(body) {
    let h_p_w = parseFloat(body.tech_h_p_w);
    let p_r = parseFloat(body.tech_p_r);
    let a_d_p_y = parseFloat(body.tech_a_d_p_y);
    let tax = parseFloat(body.tech_tax);
    let insurance = parseFloat(body.tech_insurance);
    let benefits = parseFloat(body.tech_benefits);
    let overtime = parseFloat(body.tech_overtime);
    let supplies = parseFloat(body.tech_supplies);
    let total_revenue = parseFloat(body.tech_total_revenue);

    let param = {};

    if (
      !isNaN(h_p_w) &&
      !isNaN(p_r) &&
      !isNaN(a_d_p_y) &&
      !isNaN(tax) &&
      !isNaN(insurance) &&
      !isNaN(benefits) &&
      !isNaN(overtime) &&
      !isNaN(supplies) &&
      !isNaN(total_revenue)
    ) {
      let g_h_per_year = h_p_w * 52;
      let gross_pay = g_h_per_year * p_r;
      let n_w_p_year = a_d_p_y * 8;
      let net_h_work = g_h_per_year - n_w_p_year;
      let annual_cost = tax + insurance + benefits + overtime + supplies;
      let annual_p_labor_cost = gross_pay + annual_cost;
      let h_l_cost = annual_p_labor_cost / net_h_work;
      let l_c_percentge = annual_p_labor_cost / total_revenue;

      param.tech_annual_p_labor_cost = annual_p_labor_cost;
      param.tech_h_l_cost = h_l_cost;
      param.tech_g_h_per_year = g_h_per_year;
      param.tech_gross_pay = gross_pay;
      param.tech_n_w_p_year = n_w_p_year;
      param.tech_net_h_work = net_h_work;
      param.tech_annual_cost = annual_cost;
      param.tech_l_c_percentge = l_c_percentge;
    } else {
      param.error = "Please fill all fields.";
      return param;
    }

    param.tech_h_p_w = h_p_w;
    param.tech_p_r = p_r;
    param.tech_a_d_p_y = a_d_p_y;
    param.tech_tax = tax;
    param.tech_insurance = insurance;
    param.tech_benefits = benefits;
    param.tech_overtime = overtime;
    param.tech_supplies = supplies;
    param.tech_total_revenue = total_revenue;

    return param;
  }

  /**
   * getCalculationBetaCalculator: Service Method
   * POST: /api/calculators-lol/beta-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBetaCalculator(body) {
    let rs = body.tech_rs;
    let rm = body.tech_rm;

    // Function to calculate significant figures
    function sigFig(value, digits) {
      if (value !== "") {
        let decimalPlaces;
        if (value === 0) {
          decimalPlaces = digits - 1;
        } else if (value < 0) {
          decimalPlaces = digits - Math.floor(Math.log10(Math.abs(value))) - 1;
        } else {
          decimalPlaces = digits - Math.floor(Math.log10(value)) - 1;
        }
        let answer = Number(value.toFixed(decimalPlaces));
        return answer;
      }
    }

    let param = {};

    if (!rs || !rm) {
      param.error = "Please! Check Your Input.";
      return param;
    }

    // Convert comma-separated string to an array of numbers
    rs = rs.split(",").map((value) => parseFloat(value.trim()));
    rm = rm.split(",").map((value) => parseFloat(value.trim()));

    const n = rs.length;

    if (n !== rm.length) {
      param.error = "The number of values should be same in both inputs.";
      return param;
    }

    let check = true;

    // Check if all values are numeric
    for (let i = 0; i < n; i++) {
      if (isNaN(rs[i]) || isNaN(rm[i])) {
        check = false;
        break;
      }
    }

    if (check) {
      let xy_sum = 0;
      let xi2 = [];
      let yi2 = [];

      // Calculate necessary sums
      for (let i = 0; i < n; i++) {
        xi2.push(Math.pow(rm[i], 2));
        yi2.push(Math.pow(rs[i], 2));
        xy_sum += rm[i] * rs[i];
      }

      const rs_sum = rs.reduce((acc, val) => acc + val, 0);
      const rm_sum = rm.reduce((acc, val) => acc + val, 0);
      const xi2_sum = xi2.reduce((acc, val) => acc + val, 0);
      const yi2_sum = yi2.reduce((acc, val) => acc + val, 0);

      const ss_xx = xi2_sum - Math.pow(rm_sum, 2) / n;
      const ss_yy = yi2_sum - Math.pow(rs_sum, 2) / n;
      const ss_xy = xy_sum - (rm_sum * rs_sum) / n;
      const beta_1 = ss_xy / ss_xx;

      param.tech_n = n;
      param.tech_rs = rs;
      param.tech_rm = rm;
      param.tech_rs_sum = rs_sum;
      param.tech_rm_sum = rm_sum;
      param.tech_xi2 = xi2;
      param.tech_yi2 = yi2;
      param.tech_xi2_sum = xi2_sum;
      param.tech_yi2_sum = yi2_sum;
      param.tech_xy_sum = xy_sum;
      param.tech_ss_xx = ss_xx;
      param.tech_ss_yy = ss_yy;
      param.tech_ss_xy = ss_xy;
      param.tech_beta_1 = sigFig(beta_1, 4);
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationGPDCalculator: Service Method
   * POST: /api/calculators-lol/gdp-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationGPDCalculator(body) {
    const consumption = body.tech_consumption;
    const consumption_unit = body.tech_consumption_unit;
    const investment = body.tech_investment;
    const investment_unit = body.tech_investment_unit;
    const purchases = body.tech_purchases;
    const purchases_unit = body.tech_purchases_unit;
    const exports = body.tech_exports;
    const exports_unit = body.tech_exports_unit;
    const imports = body.tech_imports;
    const imports_unit = body.tech_imports_unit;

    const units = (value, unit) => {
      let convertedValue = parseFloat(value);
      if (unit === "million") {
        return convertedValue * 1;
      } else if (unit === "billion") {
        return convertedValue * 1000;
      } else if (unit === "trillion") {
        return convertedValue * 1000000;
      }
      return convertedValue;
    };

    // Check if all values are numbers
    if (
      !isNaN(consumption) &&
      !isNaN(investment) &&
      !isNaN(purchases) &&
      !isNaN(exports) &&
      !isNaN(imports)
    ) {
      // Convert to the correct units
      const consumptionValue = units(consumption, consumption_unit);
      const investmentValue = units(investment, investment_unit);
      const purchasesValue = units(purchases, purchases_unit);
      const exportsValue = units(exports, exports_unit);
      const importsValue = units(imports, imports_unit);

      // Calculate net export and GDP
      const netExport = exportsValue - importsValue;
      const gdp =
        consumptionValue + investmentValue + purchasesValue + netExport;

      // Return the result
      return {
        tech_net_export: netExport,
        tech_gdp: gdp,
        input_consumption: body.tech_consumption,
        input_investment: body.tech_investment,
        input_purchases: body.tech_purchases,
        input_exports: body.tech_exports,
        input_imports: body.tech_imports,
      };
    } else {
      return {
        error: "Please! Check Your Input",
      };
    }
  }

  /**
   * getCalculationNPSCalculator: Service Method
   * POST: /api/calculators-lol/nps-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationNPSCalculator(body) {
    let score_ten = body.tech_score_ten;
    let score_nine = body.tech_score_nine;
    let score_eight = body.tech_score_eight;
    let score_seven = body.tech_score_seven;
    let score_six = body.tech_score_six;
    let score_five = body.tech_score_five;
    let score_four = body.tech_score_four;
    let score_three = body.tech_score_three;
    let score_two = body.tech_score_two;
    let score_one = body.tech_score_one;
    let score_zero = body.tech_score_zero;

    // Check if all values are numbers
    if (
      !isNaN(score_ten) &&
      !isNaN(score_nine) &&
      !isNaN(score_eight) &&
      !isNaN(score_seven) &&
      !isNaN(score_six) &&
      !isNaN(score_five) &&
      !isNaN(score_four) &&
      !isNaN(score_three) &&
      !isNaN(score_two) &&
      !isNaN(score_one) &&
      !isNaN(score_zero)
    ) {
      // Calculate good, neutral, and bad scores
      const good = parseFloat(score_ten) + parseFloat(score_nine);
      const neutral = parseFloat(score_eight) + parseFloat(score_seven);
      const bad =
        parseFloat(score_six) +
        parseFloat(score_five) +
        parseFloat(score_four) +
        parseFloat(score_three) +
        parseFloat(score_two) +
        parseFloat(score_one) +
        parseFloat(score_zero);
      const total = good + neutral + bad;

      // Check if total is zero
      if (total === 0) {
        return {
          error: "Check Your Input Total NPS not equal to zero",
        };
      }

      // Calculate the NPS score
      const answer = ((good / total - bad / total) * 100).toFixed(2); // Rounded to 2 decimal places
      return {
        tech_good: good,
        tech_neutral: neutral,
        tech_bad: bad,
        tech_total: total,
        tech_answer: answer,
        tech_score_ten: score_ten,
        tech_score_nine: score_nine,
        tech_score_eight: score_eight,
        tech_score_seven: score_seven,
        tech_score_six: score_six,
        tech_score_five: score_five,
        tech_score_four: score_four,
        tech_score_three: score_three,
        tech_score_two: score_two,
        tech_score_one: score_one,
        tech_score_zero: score_zero,
      };
    } else {
      return {
        error: "Please fill all fields.",
      };
    }
  }

  /**
   * getCalculationBondPriceCalculator: Service Method
   * POST: /api/calculators-lol/nps-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBondPriceCalculator(body) {
    let faceValue = body.tech_faceValue;
    let couponRate = body.tech_couponRate;
    let yearsToMaturity = body.tech_yearsToMaturity;
    let frequency = body.tech_frequency;
    let yieldRate = body.tech_yieldRate;

    if (
      !isNaN(faceValue) &&
      !isNaN(couponRate) &&
      !isNaN(yearsToMaturity) &&
      !isNaN(frequency) &&
      !isNaN(yieldRate)
    ) {
      const couponRateDecimal = couponRate / 100;
      const yieldDecimal = yieldRate / 100;

      // Function to calculate the bond price
      function calculateBondPrice(
        faceValue,
        couponRateDecimal,
        yearsToMaturity,
        yieldDecimal
      ) {
        const couponPayment = faceValue * couponRateDecimal;
        const totalPayments = yearsToMaturity;
        let presentValue = 0;

        for (let i = 1; i <= totalPayments; i++) {
          presentValue += couponPayment / Math.pow(1 + yieldDecimal, i);
        }
        presentValue += faceValue / Math.pow(1 + yieldDecimal, totalPayments);

        return presentValue;
      }

      const bondPrice = calculateBondPrice(
        faceValue,
        couponRateDecimal,
        yearsToMaturity,
        yieldDecimal
      );
      const couponPayment = (faceValue * couponRateDecimal) / frequency;
      const annualPayment = faceValue * couponRateDecimal;

      return {
        tech_couponPayment: parseFloat(couponPayment.toFixed(2)),
        tech_annual: parseFloat(annualPayment.toFixed(2)),
        tech_bondPrice: parseFloat(bondPrice.toFixed(2)),
      };
    } else {
      return {
        error: "Please check your input.",
      };
    }
  }

  /**
   * getCalculationOpportunityCostCalculator: Service Method
   * POST: /api/calculators-lol/opportunity-cost-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationOpportunityCostCalculator(body) {
    let return_best = body.tech_return_best;
    let return_choose = body.tech_return_choose;
    let param = {};
    // Trim and convert to numbers
    const bestReturn = parseFloat(return_best?.toString().trim());
    const chosenReturn = parseFloat(return_choose?.toString().trim());

    if (!isNaN(bestReturn) && !isNaN(chosenReturn)) {
      param.tech_OpportunityCost = bestReturn - chosenReturn;
      param.tech_return_best = bestReturn;
      param.tech_return_choose = chosenReturn;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationCarDepreciationCalculator: Service Method
   * POST: /api/calculators-lol/car-depreciation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCarDepreciationCalculator(body) {
    let car_cost = body.tech_car_cost;
    let c_age = body.tech_c_age;
    let car_year = body.tech_car_year;
    let rate_level = body.tech_rate_level;
    let hiddent_currency = body.tech_hiddent_currency;

    let result = {};

    car_cost = parseFloat(car_cost);
    c_age = parseInt(c_age);
    car_year = parseInt(car_year);
    rate_level = String(rate_level).trim();
    hiddent_currency = String(hiddent_currency).trim();

    if (
      isNaN(car_cost) ||
      isNaN(c_age) ||
      isNaN(car_year) ||
      !rate_level ||
      isNaN(car_cost)
    ) {
      result.error = "Please! Check Your Input";
      return result;
    }

    let asset = car_cost;
    let asset1 = car_cost;
    let depreciation = 0;
    let c_depreciation = 0;
    let table = "";
    let total_years = "";
    let total_book_value = "";

    for (let i = 1; i <= car_year; i++) {
      let rate = 0;
      if (rate_level === "1") {
        rate = 21.4;
      } else if (rate_level === "2") {
        rate = 15.6;
      } else {
        rate = 10.4;
      }

      if (i === 1 && c_age === 0) {
        if (rate_level === "1") {
          rate = 35.0;
        } else if (rate_level === "2") {
          rate = 25.0;
        } else {
          rate = 16.0;
        }
      }

      total_years += i + ",";
      depreciation = parseFloat(((asset1 * rate) / 100).toFixed(2));
      c_depreciation = parseFloat((c_depreciation + depreciation).toFixed(2));
      let end_book_value = parseFloat((asset - c_depreciation).toFixed(2));
      total_book_value += end_book_value + ",";

      table += `<tr><td className="py-2 border-b">${i}</td><td className="py-2 border-b"> ${hiddent_currency} ${asset1}</td><td className="py-2 border-b">${rate}%</td><td className="py-2 border-b"> ${hiddent_currency} ${depreciation}</td><td className="py-2 border-b"> ${hiddent_currency} ${c_depreciation}</td><td className="py-2 border-b"> ${hiddent_currency} ${end_book_value}</td></tr>`;

      asset1 = asset - c_depreciation;
    }

    result.tech_table = table;
    result.tech_total_years = total_years;
    result.tech_total_book_value = total_book_value;

    return result;
  }

  /**
   * getCalculationPropertyDepreciationCalculator: Service Method
   * POST: /api/calculators-lol/property-depreciation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPropertyDepreciationCalculator(body) {
    let basis = body.tech_basis;
    let recovery = body.tech_recovery;
    let round = body.tech_round;
    let date1 = body.tech_date1;
    let hiddent_currency = body.tech_hiddent_currency;

    // Helper functions
    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function roundNumber(value, decimals) {
      return Number(Math.round(value + "e" + decimals) + "e-" + decimals);
    }

    const result = {};

    // Validate inputs
    if (!isNumeric(basis) || !isNumeric(recovery) || !date1) {
      result.error = "Please! Check Your Input";
      return result;
    }

    const asset = parseFloat(basis);
    let asset1 = parseFloat(basis);
    let depreciation = 0;
    let c_depreciation = 0;
    let table = "";
    let total_years = [];
    let total_book_value = [];

    // Parse date (assuming format YYYY-MM-DD)
    const dateParts = date1.split("-");
    const startYear = parseInt(dateParts[0]);
    const startMonth = parseInt(dateParts[1]);

    for (let i = 0; i <= recovery; i++) {
      let rate = roundNumber(100 / recovery, 2);

      // First year partial calculation
      if (i === 0) {
        const months = 12.5 - startMonth;
        rate = rate / 12;
        rate = roundNumber(rate * months, 2);
      }

      const currentYear = startYear + i;
      total_years.push(currentYear);

      // Calculate depreciation based on rounding preference
      if (round === "yes") {
        depreciation = Math.round(asset * (rate / 100));
        c_depreciation = Math.round(c_depreciation + depreciation);
      } else {
        depreciation = roundNumber(asset * (rate / 100), 2);
        c_depreciation = roundNumber(c_depreciation + depreciation, 2);
      }

      let end_book_value =
        round === "yes"
          ? Math.round(asset - c_depreciation)
          : roundNumber(asset - c_depreciation, 2);

      // Handle negative book value
      if (end_book_value < 0) {
        end_book_value = 0;
        c_depreciation = c_depreciation - depreciation;
        depreciation = asset1;
        c_depreciation = c_depreciation + depreciation;
        rate = roundNumber((depreciation / asset) * 100, 2);
      }

      total_book_value.push(end_book_value);

      // Build HTML table row
      table += `<tr>
                    <td className="py-2 border-b">${currentYear}</td>
                    <td className="py-2 border-b">${hiddent_currency} ${asset1.toFixed(
        round === "yes" ? 0 : 2
      )}</td>
                    <td className="py-2 border-b">${rate}%</td>
                    <td className="py-2 border-b">${hiddent_currency} ${depreciation.toFixed(
        round === "yes" ? 0 : 2
      )}</td>
                    <td className="py-2 border-b">${hiddent_currency} ${c_depreciation.toFixed(
        round === "yes" ? 0 : 2
      )}</td>
                    <td className="py-2 border-b">${hiddent_currency} ${end_book_value.toFixed(
        round === "yes" ? 0 : 2
      )}</td>
                </tr>`;

      asset1 = asset - c_depreciation;
    }

    // Convert arrays to comma-separated strings
    result.tech_total_years = total_years.join(",");
    result.tech_total_book_value = total_book_value.join(",");
    result.tech_table = table;

    return result;
  }

  /**
   * getCalculationPaybackPeriodCalculator: Service Method
   * POST: /api/calculators-lol/payback-period-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPaybackPeriodCalculator(body) {
    // const {
    //     unit_type,
    //     initial,
    //     cash,
    //     in_de,
    //     year,
    //     discount,
    //     add_sub,
    //     initial2,
    //     discount2,
    //     count,
    //     currency,
    //     currency1
    // } = body;
    let unit_type = body.tech_unit_type;
    let initial = body.tech_initial;
    let cash = body.tech_cash;
    let in_de = body.tech_in_de;
    let year = body.tech_year_first;
    let discount = body.tech_discount;
    let add_sub = body.tech_add_sub;
    let initial2 = body.tech_initial2;
    let discount2 = body.tech_discount2;
    let count = body.tech_count;
    let currency = body.tech_currency;
    let currency1 = body.tech_currency1;

    let result = {};
    let param = {};

    if (unit_type === "same") {
      if (
        typeof initial === "number" &&
        typeof cash === "number" &&
        typeof in_de === "number" &&
        typeof year === "number" &&
        typeof discount === "number"
      ) {
        if (year <= 100) {
          let total = initial;
          let cdcf = initial * -1;
          let cdcf_ = initial * -1;
          let table = "";
          let com = 0;
          let back = 0;
          let dis_back = 0;

          let currentCash = cash;
          for (let i = 1; i <= year; i++) {
            if (i !== 1) {
              if (add_sub === "in") {
                currentCash += currentCash * (in_de / 100);
              } else {
                currentCash -= currentCash * (in_de / 100);
              }
            }
            const pv = currentCash / Math.pow(1 + discount / 100, i);
            com += pv;
            table += `<tr><td className='py-2 border-b'>Year ${i}</td><td className='py-2 border-b'>${currency} ${currentCash.toFixed(
              2
            )}</td><td className='py-2 border-b'>${currency} ${(
              cdcf + currentCash
            ).toFixed(
              2
            )}</td><td className='py-2 border-b'>${currency} ${pv.toFixed(
              2
            )}</td><td className='py-2 border-b'>${currency} ${(
              cdcf_ + pv
            ).toFixed(2)}</td></tr>`;
            cdcf += currentCash;
            cdcf_ += pv;
          }
          com /= year;
          const percent = ((com / total) * 100).toFixed(3);

          // Calculate payback period
          let i = 1;
          currentCash = cash;
          cdcf = 0;
          cdcf_ = 0;

          while (initial > cdcf_) {
            if (i !== 1) {
              if (add_sub === "in") {
                currentCash = currentCash + currentCash * (in_de / 100);
              } else {
                currentCash = currentCash - currentCash * (in_de / 100);
              }
            }
            const pv = currentCash / Math.pow(1 + discount / 100, i);
            cdcf_ += pv;
            if (cdcf_ >= initial && !dis_back) {
              const A = i - 1;
              const B = initial - (cdcf_ - pv);
              const C = pv;
              dis_back = (A + B / C).toFixed(3);
            }
            i++;
          }

          // Calculate non-discounted payback period
          i = 1;
          currentCash = cash;
          cdcf = 0;

          while (initial > cdcf) {
            if (i !== 1) {
              if (add_sub === "in") {
                currentCash = currentCash + currentCash * (in_de / 100);
              } else {
                currentCash = currentCash - currentCash * (in_de / 100);
              }
            }
            cdcf += currentCash;
            if (cdcf >= initial && !back) {
              const A = i - 1;
              const B = initial - (cdcf - currentCash);
              const C = currentCash;
              back = (A + B / C).toFixed(3);
            }
            i++;
          }

          result = {
            tech_back: back,
            tech_same: back,
            tech_percent: percent,
            tech_total: total,
            tech_dis_back: dis_back,
            tech_table: table,
          };
        } else {
          result.error =
            "Please provide a positive number of years that is 100 or less.";
        }
      } else {
        result.error = "Please! Check Your Input ";
      }
    } else if (unit_type === "not_same") {
      if (!isNaN(body.tech_initial2) && !isNaN(body.tech_discount2)) {
        const total = Number(body.tech_initial2);
        const discount = Number(body.tech_discount2);

        let cdcf = total * -1;
        let cdcf_ = total * -1;

        const put_input = {
          initial2: body.tech_initial2,
          discount2: body.tech_discount2,
          count: body.tech_count,
          time: new Date().toLocaleString("en-GB", {
            timeZone: "Asia/Karachi",
          }),
        };
        const save_input = [put_input];

        let table = "";
        let ave = 0;
        let total_back = 0;
        let distotal_back = 0;
        let ave_dis = 0;
        let ave_i = 0;
        let back, dis_back;
        let back_check = false;
        let dis_back_check = false;

        for (let i = 1; i <= body.tech_count; i++) {
          if (!isNaN(i)) {
            const cash = i;
            ave += cash;
            ave_i++;

            const pv = cash / Math.pow(1 + discount / 100, i);
            ave_dis += pv;

            table += `<tr><td className='py-2 border-b'>Year ${i}</td><td className='py-2 border-b'>${
              body.tech_currency1
            }${cash.toFixed(2)}</td><td className='py-2 border-b'>${
              body.tech_currency1
            }${(cdcf + cash).toFixed(2)}</td><td className='py-2 border-b'>${
              body.tech_currency1
            }${pv.toFixed(2)}</td><td className='py-2 border-b'>${
              body.tech_currency1
            }${(cdcf_ + pv).toFixed(2)}</td></tr>`;

            cdcf += cash;
            total_back += cash;

            if (cdcf >= 0 && back === undefined) {
              const A = i - 1;
              const B = total - (total_back - cash);
              const C = cash;
              back = +(A + B / C).toFixed(3);
              back_check = true;
            }

            cdcf_ += pv;
            distotal_back += pv;

            if (cdcf_ >= 0 && dis_back === undefined) {
              const A = i - 1;
              const B = total - (distotal_back - pv);
              const C = pv;
              dis_back = +(A + B / C).toFixed(3);
              dis_back_check = true;
            }
          }
        }

        let ave_cash = ave_i === 0 ? 0 : +(ave / ave_i).toFixed(2);
        let ave_cash_d = ave_i === 0 ? 0 : +(ave_dis / ave_i).toFixed(2);

        if (!dis_back_check) {
          param["dis_not_back"] = true;
          let i = 1;
          let temp_cdcf = 0;

          while (total > temp_cdcf) {
            temp_cdcf += ave_cash_d;
            if (temp_cdcf >= total) {
              const A = i - 1;
              const B = total - (temp_cdcf - ave_cash_d);
              const C = ave_cash_d;
              dis_back = +(A + B / C).toFixed(3);
            }
            i++;
          }
        }

        if (!back_check) {
          param["not_back"] = true;
          let i = 1;
          let temp_cdcf = 0;

          while (total > temp_cdcf) {
            temp_cdcf += ave_cash;
            if (temp_cdcf >= total) {
              const A = i - 1;
              const B = total - (temp_cdcf - ave_cash);
              const C = ave_cash;
              back = +(A + B / C).toFixed(3);
            }
            i++;
          }
        }

        param["tech_ave_i"] = ave_i;
        param["tech_ave_cash"] = ave_cash;
        param["tech_ave_cash_d"] = ave_cash_d;
        param["tech_back"] = back;
        param["tech_total"] = total;
        param["tech_dis_back"] = dis_back;
        param["tech_table"] = table;
        return param;
      } else {
        param["error"] = "Please! Check Your Input";
        return param;
      }
    }
    return result;
  }

  /**
   * getCalculationBasisPontCalculator: Service Method
   * POST: /api/calculators-lol/basis-point-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBasisPontCalculator(body) {
    let dec = body.tech_dec;
    let percent = body.tech_percent;
    let perm = body.tech_perm;
    let bsp = body.tech_bsp;
    let unit_type = body.tech_unit_type;
    let bps1 = body.tech_bps1;
    let bps_unit = body.tech_bps_unit;
    let of = body.tech_of;
    let equals = body.tech_equals;

    let param = {};

    if (bps_unit === "decimal") {
      bps_unit = "1";
    } else if (bps_unit === "percent") {
      bps_unit = "2";
    } else if (bps_unit === "permil") {
      bps_unit = "3";
    } else if (bps_unit === "bps") {
      bps_unit = "4";
    }

    if (unit_type === "submit") {
      if (!isNaN(dec) && percent === "" && perm === "" && bsp === "") {
        percent = dec * 100;
        perm = dec * 1000;
        bsp = dec * 10000;
        param.tech_percent = percent;
        param.tech_perm = perm;
        param.tech_bsp = bsp;
        param.tech_ans = 1;
        return param;
      } else if (dec === "" && !isNaN(percent) && perm === "" && bsp === "") {
        dec = percent / 100;
        perm = percent * 10;
        bsp = percent * 100;
        param.tech_dec = dec;
        param.tech_perm = perm;
        param.tech_bsp = bsp;
        param.tech_ans = 2;
        return param;
      } else if (dec === "" && percent === "" && !isNaN(perm) && bsp === "") {
        dec = perm / 1000;
        percent = perm / 10;
        bsp = perm * 10;
        param.tech_dec = dec;
        param.tech_percent = percent;
        param.tech_bsp = bsp;
        param.tech_ans = 3;
        return param;
      } else if (dec === "" && percent === "" && perm === "" && !isNaN(bsp)) {
        dec = bsp / 10000;
        percent = bsp / 100;
        perm = bsp / 10;
        param.tech_dec = dec;
        param.tech_perm = perm;
        param.tech_percent = percent;
        param.tech_ans = 4;
        return param;
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }
    } else if (unit_type === "submit1") {
      if (!isNaN(bps1) && !isNaN(of) && equals === "") {
        if (bps_unit === "1") {
          bps1 = bps1 * 10000;
        } else if (bps_unit === "2") {
          bps1 = bps1 * 100;
        } else if (bps_unit === "3") {
          bps1 = bps1 * 10;
        }

        equals = (bps1 * of) / 10000;
        param.tech_equals = equals;
        param.tech_of = of;
        param.tech_bps1 = bps1;
        param.tech_ans = 5;
        return param;
      } else if (!isNaN(bps1) && of === "" && !isNaN(equals)) {
        if (bps_unit === "1") {
          bps1 = bps1 * 10000;
        } else if (bps_unit === "2") {
          bps1 = bps1 * 100;
        } else if (bps_unit === "3") {
          bps1 = bps1 * 10;
        }
        of = (equals * 10000) / bps1;
        param.tech_equals = equals;
        param.tech_of = of;
        param.tech_bps1 = bps1;
        param.tech_ans = 5;
        return param;
      } else if (bps1 === "" && !isNaN(of) && !isNaN(equals)) {
        bps1 = (equals * 10000) / of;
        param.tech_equals = equals;
        param.tech_of = of;
        param.tech_bps1 = bps1;
        param.tech_ans = 5;
        return param;
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }
    }
  }

  /**
   * getCalculationWeddingBudgetCalculator: Service Method
   * POST: /api/calculators-lol/wedding-budget-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationWeddingBudgetCalculator(body) {
    let spend = body.tech_spend ? parseFloat(body.tech_spend) : 0;
    let guest = body.tech_guest ? parseFloat(body.tech_guest) : 0;
    let dress = body.tech_dress ? parseFloat(body.tech_dress) : 0;
    let jewelery = body.tech_jewelery ? parseFloat(body.tech_jewelery) : 0;
    let accessories = body.tech_accessories
      ? parseFloat(body.tech_accessories)
      : 0;
    let ring = body.tech_ring ? parseFloat(body.tech_ring) : 0;
    let makeup = body.tech_makeup ? parseFloat(body.tech_makeup) : 0;
    let stationery = body.tech_stationery
      ? parseFloat(body.tech_stationery)
      : 0;
    let photography = body.tech_photography
      ? parseFloat(body.tech_photography)
      : 0;
    let florist = body.tech_florist ? parseFloat(body.tech_florist) : 0;
    let planner = body.tech_planner ? parseFloat(body.tech_planner) : 0;
    let venue = body.tech_venue ? parseFloat(body.tech_venue) : 0;
    let dinner = body.tech_dinner ? parseFloat(body.tech_dinner) : 0;
    let catering = body.tech_catering ? parseFloat(body.tech_catering) : 0;
    let cake = body.tech_cake ? parseFloat(body.tech_cake) : 0;
    let DJs = body.tech_DJs ? parseFloat(body.tech_DJs) : 0;
    let liquors = body.tech_liquors ? parseFloat(body.tech_liquors) : 0;
    let ceremony = body.tech_ceremony ? parseFloat(body.tech_ceremony) : 0;
    let officiant = body.tech_officiant ? parseFloat(body.tech_officiant) : 0;
    let hotel = body.tech_hotel ? parseFloat(body.tech_hotel) : 0;
    let transportation = body.tech_transportation
      ? parseFloat(body.tech_transportation)
      : 0;
    let other = body.tech_other ? parseFloat(body.tech_other) : 0;
    let clickvalue1 = body.tech_clickvalue1
      ? parseFloat(body.tech_clickvalue1)
      : 0;
    let clickvalue2 = body.tech_clickvalue2
      ? parseFloat(body.tech_clickvalue2)
      : 0;
    let clickvalue3 = body.tech_clickvalue3
      ? parseFloat(body.tech_clickvalue3)
      : 0;
    let clickvalue4 = body.tech_clickvalue4
      ? parseFloat(body.tech_clickvalue4)
      : 0;
    let clickvalue5 = body.tech_clickvalue5
      ? parseFloat(body.tech_clickvalue5)
      : 0;

    let param = {};

    if (!isNaN(spend) && !isNaN(guest) && guest !== 0) {
      let bride_groom = dress + jewelery + accessories + ring + makeup;
      let sub_contractors = stationery + photography + florist + planner;
      let food_drinks = venue + dinner + catering + cake + DJs + liquors;
      let ceremony_total = ceremony + officiant;
      let trans_accomo = hotel + transportation;
      let total =
        bride_groom +
        sub_contractors +
        food_drinks +
        ceremony_total +
        trans_accomo;
      let average_cost = (total + other) / guest;
      let budget_balance = spend - total;

      param = {
        tech_average_cost: average_cost,
        tech_budget_balance: budget_balance,
        tech_bride_groom: bride_groom,
        tech_sub_contractors: sub_contractors,
        tech_food_drinks: food_drinks,
        tech_ceremony_total: ceremony_total,
        tech_trans_accomo: trans_accomo,
        tech_other: other,
        tech_spend: spend,
        tech_dress: dress,
        tech_jewelery: jewelery,
        tech_accessories: accessories,
        tech_ring: ring,
        tech_makeup: makeup,
        tech_clickvalue1: clickvalue1,
        tech_clickvalue2: clickvalue2,
        tech_clickvalue3: clickvalue3,
        tech_clickvalue4: clickvalue4,
        tech_clickvalue5: clickvalue5,
      };
    } else {
      param = {
        error: "Please fill all fields.",
      };
    }

    return param;
  }

  /**
   * getCalculationEmloyeeCostCalculator: Service Method
   * POST: /api/calculators-lol/employee-cost-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationEmloyeeCostCalculator(body) {
    let unit_type = body.tech_unit_type;
    let rate = body.tech_rate;
    let hour_worked = body.tech_hour_worked;
    let month = body.tech_month;
    let benefits = body.tech_benefits ?? 0; // if null or undefined, default to 0
    let health = body.tech_health ?? 0;
    let dental = body.tech_dental ?? 0;
    let vision = body.tech_vision ?? 0;
    let perk_name = body.tech_perk_name; // assume array
    let annual_contribution = body.tech_annual_contribution; // assume array

    rate = parseFloat(rate);
    hour_worked = parseFloat(hour_worked);
    month = parseFloat(month);
    benefits = parseFloat(benefits);
    health = parseFloat(health);
    dental = parseFloat(dental);
    vision = parseFloat(vision);

    let param = {};

    function calculatePerk(perk_name, annual_contribution) {
      let perk = 0;
      let name_array = [];
      let perk_val = [];

      for (
        let i = 0;
        i < perk_name.length && i < annual_contribution.length;
        i++
      ) {
        name_array.push(perk_name[i]);
        perk_val.push(parseFloat(annual_contribution[i]));
        perk += parseFloat(annual_contribution[i]);
      }
      return [name_array, perk, perk_val];
    }

    if (unit_type === "hourly") {
      if (!isNaN(rate) && !isNaN(hour_worked) && !isNaN(month)) {
        let emp_rate = rate * 4.66484 * hour_worked * month;
        let emp_h_r = emp_rate + benefits + health + dental + vision;

        if (perk_name && annual_contribution) {
          const [name_array, perk, perk_val] = calculatePerk(
            perk_name,
            annual_contribution
          );
          param.tech_perk_array = name_array;
          param.tech_perk = perk;
          param.tech_perk_val = perk_val;
          param.tech_emp_h_r_p = emp_h_r + perk;
        }

        param.tech_emp_h_r = emp_h_r;
        param.tech_rate = rate;
        param.tech_hour_worked = hour_worked;
        param.tech_benefits = benefits;
        param.tech_health = health;
        param.tech_dental = dental;
        param.tech_vision = vision;
        param.tech_month = month;
        param.tech_emp_rate = emp_rate;
      } else {
        param.error = "Please Enter valid values.";
        return param;
      }
    } else if (unit_type === "salary") {
      if (!isNaN(rate) && !isNaN(month)) {
        let per_anum = rate * 0.0765;
        let anual_salary =
          per_anum + rate + benefits + health + dental + vision;

        if (perk_name && annual_contribution) {
          const [name_array, perk, perk_val] = calculatePerk(
            perk_name,
            annual_contribution
          );
          param.tech_perk_array = name_array;
          param.tech_perk = perk;
          param.tech_perk_val = perk_val;
          param.tech_emp_h_r_p = anual_salary + perk;
        }

        param.tech_anual_salary = anual_salary;
        param.tech_rate = rate;
        param.tech_per_anum = per_anum;
        param.tech_benefits = benefits;
        param.tech_health = health;
        param.tech_dental = dental;
        param.tech_vision = vision;
      } else {
        param.error = "Please Enter valid values.";
        return param;
      }
    } else {
      param.error = "Invalid unit type.";
      return param;
    }

    param.tech_submit = unit_type;
    return param;
  }

  /**
   * getCalculationNPVCalculator: Service Method
   * POST: /api/calculators-lol/npv-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationNPVCalculator(body) {
    let initial = body.tech_initial;
    let discount = body.tech_discount;
    let year = body.tech_year; // year should be an array of values

    let param = {}; // to store and return results

    if (
      typeof initial === "number" &&
      typeof discount === "number" &&
      Array.isArray(year)
    ) {
      discount = discount / 100;
      let all_npv = [];

      for (let i = 1; i <= year.length; i++) {
        let npv_btm = Math.pow(1 + discount, i);
        all_npv.push(year[i - 1] / npv_btm);
      }

      let npv_ans = all_npv.reduce((a, b) => a + b, 0) - initial;
      let total_return = year.reduce((a, b) => a + b, 0) - initial;
      let gross_return = (total_return / initial) * 100;
      let net_cash_flow = (initial / 100) * gross_return;

      // DataPoints for Chart
      let dataPoints = year.map((value, index) => ({
        y: parseInt(value),
        label: `Year ${index + 1}`,
      }));

      param.tech_npv_ans = parseFloat(npv_ans.toFixed(2));
      param.tech_gross_return = parseFloat(gross_return.toFixed(2));
      param.tech_net_cash_flow = parseFloat(net_cash_flow.toFixed(2));
      param.tech_dataPoints = dataPoints;
      param.tech_year = year;
      param.tech_arrayLength = year.length;
    } else {
      param.error = "Please fill all fields correctly.";
      return param;
    }

    return param;
  }

  /**
   * getCalculationTipCalculator: Service Method
   * POST: /api/calculators-loltip-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTipCalculator(body) {
    // Separate input variables
    let tipFor = body.tech_for;
    let bill = body.tech_x;
    let xs = body.tech_xs;
    let tip = body.tech_y;
    let person = body.tech_z;
    let round = body.tech_round;
    let rounds = body.tech_rounds;
    // const { for: tipFor, x: bill, xs, y: tip, z: person, round, rounds } = body;

    // Helper function to check if value is numeric
    function isNumeric(value) {
      return !isNaN(value) && value !== null && value !== "";
    }

    // Helper function for rounding
    function roundNumber(value, precision = 0) {
      return precision
        ? parseFloat(value.toFixed(precision))
        : Math.round(value);
    }

    let response = {};

    // Handle single tip calculation
    if (tipFor === "single") {
      if (isNumeric(xs)) {
        response.tech_single = 1;
        return response;
      } else {
        response.error = "Please! Fill all the Input Fields";
        return response;
      }
    } else {
      // Handle multiple person tip calculation
      if (isNumeric(bill) && isNumeric(tip) && isNumeric(person)) {
        let a, b, c, d;

        if (round === "yes") {
          a = roundNumber((tip / 100) * bill);
          b = roundNumber(bill + a);
          c = roundNumber(a / person);
          d = roundNumber(b / person);
        } else {
          a = roundNumber((tip / 100) * bill, 2);
          b = roundNumber(bill + a, 2);
          c = roundNumber(a / person, 2);
          d = roundNumber(b / person, 2);
        }

        response.tech_a = a;
        response.tech_b = b;
        response.tech_c = c;
        response.tech_d = d;
        return response;
      } else {
        response.error = "Please! Fill all the Input Fields";
        return response;
      }
    }
  }

  /**
   * getCalculationHourlyToSalaryCalculator: Service Method
   * POST: /api/calculators-lol/hourly-to-salary-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationHourlyToSalaryCalculator(body) {
    // Separate input variables
    let first = body.tech_first;
    let second = body.tech_second;
    let third = body.tech_third;
    let car = body.tech_car;

    let response = {};
    // Helper function to check if value is numeric
    function isNumeric(value) {
      return !isNaN(value) && value !== null && value !== "";
    }

    // Check if inputs are numeric
    if (isNumeric(first) && isNumeric(second) && isNumeric(third)) {
      let annuly = first * second * third;
      let weekly = first * second;
      let monthly = annuly / 12;

      response.tech_annuly = annuly;
      response.tech_weekly = weekly;
      response.tech_monthly = monthly;
    } else {
      response.error = "Please! Check Your Input";
      return response;
    }

    response.car = car;
    return response;
  }

  /**
   * getCalculationSalaryToHourlyCalculator: Service Method
   * POST: /api/calculators-lol/salary-to-hourly-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSalaryToHourlyCalculator(body) {
    // Separate input variables
    let salary = body.tech_salary;
    let hweek = body.tech_hweek;
    let hyear = body.tech_hyear;
    let type = body.tech_type;
    let currency = body.tech_currency;
    // Helper function to check if value is numeric
    function isNumeric(value) {
      return !isNaN(value) && value !== null && value !== "";
    }
    let response = {};

    // Check if inputs are numeric and type is not empty
    if (
      isNumeric(salary) &&
      isNumeric(hweek) &&
      isNumeric(hyear) &&
      type !== ""
    ) {
      let median_sal,
        name = "";

      // Set median salary based on currency
      if (currency === "$") {
        median_sal = 53924;
        name = "Of US Median";
      } else if (currency === "£") {
        median_sal = 31285;
        name = "Of UK Median";
      } else {
        median_sal = 53924;
      }

      if (hweek > 0 && hyear > 0 && salary > 0) {
        let weekly_rate, hourly_rate, monthaly_rate, mean;

        // Perform calculations based on type
        if (type === "an") {
          weekly_rate = salary / hyear;
          hourly_rate = weekly_rate / hweek;
          monthaly_rate = salary / 12;
          mean = (salary / median_sal) * 100;
        } else if (type === "mo") {
          monthaly_rate = salary;
          hourly_rate = (monthaly_rate * 12) / hyear / hweek;
          weekly_rate = hourly_rate * hweek;
          mean = (salary / median_sal) * 100;
        } else if (type === "we") {
          weekly_rate = salary;
          hourly_rate = weekly_rate / hweek;
          monthaly_rate = (hourly_rate * hyear * hweek) / 12;
          mean = (salary / median_sal) * 100;
        } else if (type === "da") {
          hourly_rate = salary / (hweek / 5);
          weekly_rate = hourly_rate * hweek;
          monthaly_rate = (hourly_rate * hyear * hweek) / 12;
          mean = (salary / median_sal) * 100;
        }

        // Set values in the response object
        response.tech_hourly_rate = hourly_rate;
        response.tech_weekly_rate = weekly_rate;
        response.tech_monthaly_rate = monthaly_rate;
        response.tech_mean = mean;
        response.tech_name = name;
        response.tech_currency = currency;
        return response;
      } else {
        response.error = "Please! Enter the Correct Value";
        return response;
      }
    } else {
      response.error = "Please! Check Your Input";
      return response;
    }
  }

  /**
   * getCalculationRentSpitCalculator: Service Method
   * POST: /api/calculators-lol/rent-split-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRentSpitCalculator(body) {
    // Separate input variables
    let total_rent = body.tech_total_rent;
    let total_area = body.tech_total_area;
    let bedrooms = body.tech_bedrooms;
    let room_area = body.tech_room_area;
    let persons = body.tech_persons;
    let bath = body.tech_bath;

    // Helper function to check if value is numeric
    function isNumeric(value) {
      return !isNaN(value) && value !== null && value !== "";
    }

    // Helper function to sum an array of numbers
    function sumArray(arr) {
      return arr.reduce((acc, val) => acc + val, 0);
    }

    let response = {};

    // Check if inputs are numeric and not empty
    if (
      isNumeric(total_rent) &&
      isNumeric(total_area) &&
      bedrooms > 0 &&
      persons.length > 0 &&
      room_area.length > 0 &&
      bath.length > 0
    ) {
      if (total_area >= sumArray(room_area) + sumArray(bath)) {
        let common_area = total_area - sumArray(room_area) - sumArray(bath);
        let rent_per_sq = total_rent / (total_area - common_area);

        let room_rent = [];
        for (let i = 0; i < bedrooms; i++) {
          room_rent[i] = ((room_area[i] + bath[i]) * rent_per_sq) / persons[i];
        }

        response.tech_room_rent = room_rent;
        return response;
      } else {
        response.error =
          "Combined square footage of rooms should not exceed total square footage of house";
        return response;
      }
    } else {
      response.error = "Please! Check Your Input";
      return response;
    }
  }

  /**
   * getCalculationARVCalculator: Service Method
   * POST: /api/calculators-lol/arv-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationARVCalculator(body) {
    const method_unit = body.tech_method_unit.trim();
    const property = parseFloat(body.tech_property.trim());
    const area = parseFloat(body.tech_area.trim());
    const area_unit = body.tech_area_unit.trim();
    const value = parseFloat(body.tech_value.trim());
    const total = parseFloat(body.tech_total.trim());
    const total_unit = body.tech_total_unit.trim();
    const average = parseFloat(body.tech_average.trim());
    const average_unit = body.tech_average_unit.trim();
    const cost = parseFloat(body.tech_cost.trim());
    const purchase = parseFloat(body.tech_purchase.trim());

    let response = {};

    // Function to handle area unit conversions
    function arv_units(area, area_unit) {
      if (area_unit === "m²") {
        return area; // No conversion needed for m²
      } else if (area_unit === "ft²") {
        return area * 0.092903; // Convert ft² to m²
      } else if (area_unit === "yd²") {
        return area * 0.836127; // Convert yd² to m²
      } else if (area_unit === "mi²") {
        return area * 2.58999e6; // Convert mi² to m²
      } else {
        return "Unsupported unit or invalid input.";
      }
    }

    // Input validation
    if (
      isNaN(area) ||
      isNaN(total) ||
      isNaN(property) ||
      isNaN(value) ||
      isNaN(average) ||
      isNaN(cost) ||
      isNaN(purchase)
    ) {
      response.error = "Please! Check Your Input";
      return response;
    }

    if (area == 0) {
      response.error = "Average Area Price value cannot be equal to zero";
      return response;
    }
    if (total == 0) {
      response.error =
        "Total area of the property value cannot be equal to zero";
      return response;
    }
    if (property == 0) {
      response.error = "Property current value cannot be equal to zero";
      return response;
    }
    if (value == 0) {
      response.error = "Value of renovations cannot be equal to zero";
      return response;
    }
    if (average == 0) {
      response.error = "Repair cost value cannot be equal to zero";
      return response;
    }
    if (cost == 0) {
      response.error = "Total cost of renovation cannot be equal to zero";
      return response;
    }
    if (purchase == 0) {
      response.error = "Investor's purchase rule value cannot be equal to zero";
      return response;
    }
    if (purchase > 100) {
      response.error = "Investor's purchase rule % cannot exceed 100%";
      return response;
    }

    // ARV calculation logic
    let after_repair_value;
    if (method_unit === "Value Of The Property") {
      after_repair_value = property + value; // After repair value is property value + renovation value
    } else {
      const areas = arv_units(area, area_unit);
      const totals = arv_units(total, total_unit);
      after_repair_value = areas * totals; // After repair value = area * total
    }

    const averages = arv_units(average, average_unit);
    const requires_repairs = cost / averages; // Cost of repairs divided by average repair cost
    const maximum_bid_price = after_repair_value * (purchase / 100) - cost; // Maximum bid price
    const percentage = Math.abs(purchase - 100); // Difference between purchase and 100%
    const roi = (percentage / 100) * after_repair_value; // Return on investment

    // Return the response with calculated values
    response.tech_after_repair_value = after_repair_value;
    response.tech_requires_repairs = requires_repairs;
    response.tech_maximum_bid_price = maximum_bid_price;
    response.tech_percentage = percentage;
    response.tech_roi = roi;
    return response;
  }

  /**
   * getCalculation6MinuteWalkTestCalculator: Service Method
   * POST: /api/calculators-lol/6-minute-walk-test
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculation6MinuteWalkTestCalculator(body) {
    let age = body.tech_age;
    let weight = body.tech_weight;
    let distance = body.tech_distance;
    let heightFt = body.tech_height_ft;
    let heightIn = body.tech_height_in;
    let heightCm = body.tech_height_cm;
    let unit = body.tech_unit;
    let unit_ft_in = body.tech_unit_ft_in;
    let gender = body.tech_gender;
    let dis_unit = body.tech_dis_unit;

    let result = {};

    // Validate inputs
    if (
      !isNaN(age) &&
      !isNaN(weight) &&
      !isNaN(distance) &&
      (!isNaN(heightFt) || !isNaN(heightIn) || !isNaN(heightCm))
    ) {
      let wt = parseFloat(weight);
      let dist = parseFloat(distance);
      let ht_cm = parseFloat(heightCm);
      let ht_ft = parseFloat(heightFt);
      let ht_in = parseFloat(heightIn);

      // Convert weight from lbs to kg
      if (unit === "lbs") {
        wt = wt / 2.205;
      }

      // Convert height from ft/in to cm
      if (unit_ft_in === "ft/in") {
        ht_cm = ht_ft * 30.48;
        if (!isNaN(ht_in)) {
          ht_cm += ht_in * 2.54;
        }
      }

      // Gender-based calculation
      let ans = 0;
      let limit = 0;

      if (gender === "Male") {
        ans = Math.round(7.57 * ht_cm - 5.02 * age - 1.76 * wt - 309);
        limit = ans - 153;
      } else {
        ans = Math.round(2.11 * ht_cm - 5.78 * age - 2.29 * wt + 667);
        limit = ans - 139;
      }

      // Convert distance from feet to meters
      if (dis_unit === "ft") {
        dist = dist / 3.281;
      }

      const percent = Math.round((dist / ans) * 100);

      result = {
        tech_Ans: ans,
        tech_limit: limit,
        tech_Percent: percent,
      };
    } else {
      result = {
        error: "Please fill All the Required fields.",
      };
    }

    return result;
  }

  /**
   * getCalculationRMRCalculator: Service Method
   * POST: /api/calculators-lol/rmr-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRMRCalculator(body) {
    let age = body.tech_age;
    let weight = body.tech_weight;
    let height_ft = body.tech_height_ft;
    let height_in = body.tech_height_in;
    let height_cm = body.tech_height_cm;
    let unit = body.tech_unit;
    let unit_h = body.tech_unit_h;
    let gender = body.tech_gender;
    let result = {};

    if (
      !isNaN(age) &&
      !isNaN(weight) &&
      (!isNaN(height_ft) || !isNaN(height_in) || !isNaN(height_cm))
    ) {
      age = parseFloat(age);
      weight = parseFloat(weight);
      height_ft = parseFloat(height_ft);
      height_in = parseFloat(height_in);
      height_cm = parseFloat(height_cm);

      // Convert weight to kg if in lbs
      if (unit === "lbs") {
        weight = weight / 2.205;
      }

      // Convert height to cm if provided in ft/in
      if (unit_h === "ft/in") {
        height_cm = height_ft * 30.48;
        if (!isNaN(height_in)) {
          height_cm += height_in * 2.54;
        }
      }

      let rmr;

      if (gender === "Female") {
        rmr = parseFloat(
          (655 + 9.6 * weight + 1.8 * height_cm - 4.7 * age).toFixed(2)
        );
      } else {
        rmr = parseFloat(
          (66 + 13.7 * weight + 5 * height_cm - 6.8 * age).toFixed(2)
        );
      }

      result = {
        tech_RMR: rmr,
      };
    } else {
      result = {
        error: "Please fill All fields.",
      };
    }

    return result;
  }

  /**
   * getCalculationBMRCalculator: Service Method
   * POST: /api/calculators-lol/bmr-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationBMRCalculator(body) {
    let age = body.tech_age;
    let weight = body.tech_weight;
    let height_ft = body.tech_height_ft;
    let height_in = body.tech_height_in;
    let height_cm = body.tech_height_cm;
    let unit = body.tech_unit;
    let unit_ft_in = body.tech_unit_ft_in;
    let gender = body.tech_gender;
    let result = {};

    if (
      !isNaN(age) &&
      !isNaN(weight) &&
      (!isNaN(height_ft) || !isNaN(height_in) || !isNaN(height_cm))
    ) {
      age = parseFloat(age);
      weight = parseFloat(weight);
      height_ft = parseFloat(height_ft);
      height_in = parseFloat(height_in);
      height_cm = parseFloat(height_cm);

      // Convert weight to kg if in lbs
      if (unit === "lbs") {
        weight = weight / 2.205;
      }

      // Convert height to cm if in ft/in
      if (unit_ft_in === "ft/in") {
        height_cm = height_ft * 30.48;
        if (!isNaN(height_in)) {
          height_cm += height_in * 2.54;
        }
      }

      let bmr, hbmr, sbmr;

      if (gender === "Female") {
        bmr = parseFloat(
          (9.99 * weight + 6.25 * height_cm - 4.92 * age - 161).toFixed(2)
        );
        hbmr = parseFloat(
          (447.593 + 9.247 * weight + 3.098 * height_cm - 4.33 * age).toFixed(2)
        );

        if (age >= 18 && age < 30) {
          sbmr = 14.818 * weight + 486.6;
        } else if (age >= 30 && age < 60) {
          sbmr = 8.126 * weight + 845.6;
        } else if (age >= 60) {
          sbmr = 9.082 * weight + 658.5;
        }
      } else {
        bmr = parseFloat(
          (9.99 * weight + 6.25 * height_cm - 4.92 * age + 5).toFixed(2)
        );
        hbmr = parseFloat(
          (88.362 + 13.397 * weight + 4.799 * height_cm - 5.677 * age).toFixed(
            2
          )
        );

        if (age >= 18 && age < 30) {
          sbmr = 15.057 * weight + 692.2;
        } else if (age >= 30 && age < 60) {
          sbmr = 11.472 * weight + 873.1;
        } else if (age >= 60) {
          sbmr = 11.711 * weight + 587.7;
        }
      }

      result = {
        tech_BMR: bmr,
        tech_hbmr: hbmr,
        tech_sbmr: parseFloat(sbmr.toFixed(2)),
      };
    } else {
      result = {
        error: "Please Fill All Fields.",
      };
    }

    return result;
  }

  /**
   * getCalculationIdealWeightCalculator: Service Method
   * POST: /api/calculators-lol/ideal-weight-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationIdealWeightCalculator(body) {
    let age = body.tech_age;
    let weight = body.tech_weight;
    let gender = body.tech_gender;
    let heightFt = body.tech_height_ft;
    let heightIn = body.tech_height_in;
    let heightCm = body.tech_height_cm;
    let unit = body.tech_unit;
    let unit_ft_in = body.tech_unit_ft_in;
    let hidden_nameunit = body.tech_hidden_nameunit;

    if (
      !isNaN(age) &&
      !isNaN(weight) &&
      (!isNaN(heightFt) || !isNaN(heightIn) || !isNaN(heightCm))
    ) {
      let param = {};
      let height_cm = heightCm;
      if (unit_ft_in === "ft/in") {
        height_cm = heightFt * 30.48;
        if (heightIn != null) {
          height_cm += heightIn * 2.54;
        }
      }

      let height_in = height_cm / 2.54;
      let weight_kg = weight;

      if (unit === "lbs") {
        weight_kg = weight / 2.205;
      }

      const height_meters = height_in / 39.37;
      let ans = 0;

      if (gender === "Female") {
        if (height_in < 60) {
          const Intuitive = +(45.5 - 2.3 * (60 - height_in)).toFixed(2);
          const Baseline = +(45.5 - 0.758 * (60 - height_in)).toFixed(2);
          ans = Baseline;
          Object.assign(param, {
            tech_Intuitive: Intuitive,
            tech_Baseline: Baseline,
          });
        } else {
          const Robinson = +(49 + 1.7 * (height_in - 60)).toFixed(2);
          const Miller = +(53.1 + 1.36 * (height_in - 60)).toFixed(2);
          ans = +(45.5 + 2.3 * (height_in - 60)).toFixed(2);
          const Devine = ans;
          const Hamwi = +(45 + 2.2 * (height_in - 60)).toFixed(2);
          const Broca = +(
            height_cm -
            100 -
            (height_cm - 100) * (15 / 100)
          ).toFixed(2);
          const Lorentz = +(height_cm - 100 - (height_cm - 150) / 2).toFixed(2);
          const Peterson = +(
            2.2 * 22 +
            3.5 * 22 * (height_meters - 1.5)
          ).toFixed(2);
          const Lemmens = +(22 * Math.pow(height_meters, 2)).toFixed(2);
          const BMI_Method = +(25 * (height_meters * height_meters)).toFixed(2);
          Object.assign(param, {
            tech_Robinson: Robinson,
            tech_Miller: Miller,
            tech_Devine: Devine,
            tech_Hamwi: Hamwi,
            tech_Broca: Broca,
            tech_Lorentz: Lorentz,
            tech_Peterson: Peterson,
            tech_Lemmens: Lemmens,
            tech_BMI_Method: BMI_Method,
          });
        }
      } else {
        if (height_in < 60) {
          const Intuitive = +(50 - 2.3 * (60 - height_in)).toFixed(2);
          const Baseline = +(50 - 0.833 * (60 - height_in)).toFixed(2);
          ans = Baseline;
          Object.assign(param, {
            tech_Intuitive: Intuitive,
            tech_Baseline: Baseline,
          });
        } else {
          const Robinson = +(52 + 1.9 * (height_in - 60)).toFixed(2);
          const Miller = +(56.2 + 1.41 * (height_in - 60)).toFixed(2);
          ans = +(50 + 2.3 * (height_in - 60)).toFixed(2);
          const Devine = ans;
          const Hamwi = +(48 + 2.7 * (height_in - 60)).toFixed(2);
          const Broca = +(
            height_cm -
            100 -
            (height_cm - 100) * (10 / 100)
          ).toFixed(2);
          const Lorentz = +(height_cm - 100 - (height_cm - 150) / 4).toFixed(2);
          const Peterson = +(
            2.2 * 22 +
            3.5 * 22 * (height_meters - 1.5)
          ).toFixed(2);
          const Lemmens = +(22 * Math.pow(height_meters, 2)).toFixed(2);
          const BMI_Method = +(25 * (height_meters * height_meters)).toFixed(2);
          Object.assign(param, {
            tech_Robinson: Robinson,
            tech_Miller: Miller,
            tech_Devine: Devine,
            tech_Hamwi: Hamwi,
            tech_Broca: Broca,
            tech_Lorentz: Lorentz,
            tech_Peterson: Peterson,
            tech_Lemmens: Lemmens,
            tech_BMI_Method: BMI_Method,
          });
        }
      }

      const bmi_range1 = +(18.5 * (height_meters * height_meters)).toFixed(2);
      const bmi_range2 = +(25 * (height_meters * height_meters)).toFixed(2);

      let abw, Percent, bmi;
      if (unit === "kg") {
        abw = +(ans + 0.4 * (weight - ans)).toFixed(2) + " kg";
        Percent = +(((weight - ans) / ans) * 100).toFixed(2) + " %";
        bmi = +(weight / Math.pow(height_meters, 2)).toFixed(2);
      } else {
        abw = +(ans * 2.205 + 0.4 * (weight - ans * 2.205)).toFixed(2) + " lbs";
        Percent =
          +(((weight - ans * 2.205) / (ans * 2.205)) * 100).toFixed(2) + " %";
        bmi = +(weight / 2.205 / Math.pow(height_meters, 2)).toFixed(2);
      }

      let lbw;
      if (gender === "Female") {
        lbw = +((9270 * weight_kg) / (8780 + 244 * bmi)).toFixed(2);
      } else {
        lbw = +((9270 * weight_kg) / (6680 + 216 * bmi)).toFixed(2);
      }

      param.tech_ans =
        unit === "kg"
          ? `${ans} <span className='text-blue font-s-20'>kg</span>`
          : `${(ans * 2.205).toFixed(
              2
            )} <span className='text-blue font-s-20'>lbs</span>`;
      param.tech_lbw =
        unit === "kg" ? `${lbw} kg` : `${(lbw * 2.205).toFixed(2)} lbs`;
      param.tech_abw = abw;
      param.tech_hidden_nameunit = hidden_nameunit;
      param.tech_Percent = Percent;
      param.tech_bmi = bmi + " kg/m<sup>2</sup>";
      param.tech_bsa =
        +(
          0.007184 *
          Math.pow(weight_kg, 0.425) *
          Math.pow(height_cm, 0.725)
        ).toFixed(2) + " M<sup>2</sup>";
      param.tech_BMI1 = `${bmi_range1} - ${bmi_range2} kg`;
      param.tech_BMI2 = `${(bmi_range1 * 2.205).toFixed(2)} - ${(
        bmi_range2 * 2.205
      ).toFixed(2)} lbs`;

      return param;
    } else {
      return {
        hidden_nameunit,
        error: "Please Fill All fields.",
      };
    }
  }

  /**
   * getCalculationLeanBodyMassCalculator: Service Method
   * POST: /api/calculators-lol/lean-body-mass-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLeanBodyMassCalculator(body) {
    let weight = body.tech_weight;
    let heightFt = body.tech_height_ft;
    let heightIn = body.tech_height_in;
    let heightCm = body.tech_height_cm;
    let unit = body.tech_unit;
    let unit_ft_in = body.tech_unit_ft_in;
    let gender = body.tech_gender;
    let formula = body.tech_formula;

    let param = {};

    if (
      !isNaN(weight) &&
      (!isNaN(heightFt) || !isNaN(heightIn) || !isNaN(heightCm))
    ) {
      weight = parseFloat(weight);
      heightFt = parseFloat(heightFt) || 0;
      heightIn = parseFloat(heightIn) || 0;
      heightCm = parseFloat(heightCm) || 0;

      if (unit === "lbs") {
        weight = weight / 2.205;
      }

      if (unit_ft_in === "ft/in") {
        heightCm = heightFt * 30.48;
        if (heightIn) {
          heightCm += heightIn * 2.54;
        }
      }

      let Boer, James, Hume, Peters, Boer_per, James_per, Hume_per, Peters_per;

      if (gender === "Female") {
        Boer = 0.252 * weight + 0.473 * heightCm - 48.3;
        Boer_per = (Boer / weight) * 100;

        James = 1.07 * weight - 148 * Math.pow(weight / heightCm, 2);
        James_per = (James / weight) * 100;

        Hume = 0.29569 * weight + 0.41813 * heightCm - 43.2933;
        Hume_per = (Hume / weight) * 100;
      } else {
        Boer = 0.407 * weight + 0.267 * heightCm - 19.2;
        Boer_per = (Boer / weight) * 100;

        James = 1.1 * weight - 128 * Math.pow(weight / heightCm, 2);
        James_per = (James / weight) * 100;

        Hume = 0.3281 * weight + 0.33929 * heightCm - 29.5336;
        Hume_per = (Hume / weight) * 100;
      }

      Peters = 0.0817 * (Math.pow(weight, 0.6469) * Math.pow(heightCm, 0.7236));
      Peters_per = (Peters / weight) * 100;

      if (unit === "lbs") {
        Boer = Boer * 2.205;
        James = James * 2.205;
        Hume = Hume * 2.205;
        Peters = Peters * 2.205;
      }

      Boer = parseFloat(Boer.toFixed(2));
      James = parseFloat(James.toFixed(2));
      Hume = parseFloat(Hume.toFixed(2));
      Peters = parseFloat(Peters.toFixed(2));

      Boer_per = parseFloat(Boer_per.toFixed(2));
      James_per = parseFloat(James_per.toFixed(2));
      Hume_per = parseFloat(Hume_per.toFixed(2));
      Peters_per = parseFloat(Peters_per.toFixed(2));

      let ans = 0;
      let ans_per = 0;

      switch (formula) {
        case "Boer":
          param["tech_Boer_f"] = "bg-gradient text-white";
          ans = Boer;
          ans_per = Boer_per;
          break;
        case "James":
          param["tech_James_f"] = "bg-gradient text-white";
          ans = James;
          ans_per = James_per;
          break;
        case "Hume":
          param["tech_Hume_f"] = "bg-gradient text-white";
          ans = Hume;
          ans_per = Hume_per;
          break;
        case "Peters":
          param["tech_Peters_f"] = "bg-gradient text-white";
          ans = Peters;
          ans_per = Peters_per;
          break;
      }

      param["tech_Boer"] = `${Boer} ${unit}`;
      param["tech_Boer_per"] = Boer_per;
      param["tech_James"] = `${James} ${unit}`;
      param["tech_James_per"] = James_per;
      param["tech_Hume"] = `${Hume} ${unit}`;
      param["tech_Hume_per"] = Hume_per;
      param["tech_Peters"] = `${Peters} ${unit}`;
      param["tech_Peters_per"] = Peters_per;
      param["tech_ans"] = ans;
      param["tech_ans_per"] = ans_per;

      return param;
    } else {
      return { error: "Please Fill All Fields." };
    }
  }

  /**
   * getCalculationBSACalculator: Service Method
   * POST: /api/calculators-lol/bsa-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationBSACalculator(body) {
    let weight = body.tech_weight;
    let gender = body.tech_gender;
    let unit = body.tech_unit;
    let heightFt = body.tech_height_ft;
    let heightIn = body.tech_height_in;
    let heightCm = body.tech_height_cm;
    let unit_ft_in = body.tech_unit_ft_in;

    let response = {};

    if (
      !isNaN(weight) &&
      (!isNaN(heightFt) || !isNaN(heightIn) || !isNaN(heightCm))
    ) {
      weight = parseFloat(weight);
      heightFt = parseFloat(heightFt) || 0;
      heightIn = parseFloat(heightIn) || 0;
      heightCm = parseFloat(heightCm) || 0;

      if (unit === "lbs") {
        weight = weight / 2.205;
      }

      if (unit_ft_in === "ft/in") {
        heightCm = heightFt * 30.48;
        if (heightIn) {
          heightCm += heightIn * 2.54;
        }
      }

      const DuBois = +(
        0.007184 *
        Math.pow(weight, 0.425) *
        Math.pow(heightCm, 0.725)
      ).toFixed(2);
      const Mosteller = +(
        0.016667 *
        Math.sqrt(weight) *
        Math.sqrt(heightCm)
      ).toFixed(2);
      const Haycock = +(
        0.024265 *
        Math.pow(weight, 0.5378) *
        Math.pow(heightCm, 0.3964)
      ).toFixed(2);
      const Gehan = +(
        0.0235 *
        Math.pow(weight, 0.51456) *
        Math.pow(heightCm, 0.42246)
      ).toFixed(2);
      const Boyd = +(
        0.0333 *
        Math.pow(weight, 0.6157 - 0.0188 * Math.log10(weight)) *
        Math.pow(heightCm, 0.3)
      ).toFixed(2);
      const Fujimoto = +(
        0.008883 *
        Math.pow(weight, 0.444) *
        Math.pow(heightCm, 0.663)
      ).toFixed(2);
      const Takahira = +(
        0.007241 *
        Math.pow(weight, 0.425) *
        Math.pow(heightCm, 0.725)
      ).toFixed(2);

      let Schlich;
      if (gender === "Male") {
        Schlich = +(
          0.000579479 *
          Math.pow(weight, 0.38) *
          Math.pow(heightCm, 1.24)
        ).toFixed(2);
      } else {
        Schlich = +(
          0.000975482 *
          Math.pow(weight, 0.46) *
          Math.pow(heightCm, 1.08)
        ).toFixed(2);
      }

      response = {
        tech_DuBois: DuBois,
        tech_Mosteller: Mosteller,
        tech_Haycock: Haycock,
        tech_Gehan: Gehan,
        tech_Boyd: Boyd,
        tech_Fujimoto: Fujimoto,
        tech_Takahira: Takahira,
        tech_Schlich: Schlich,
      };
    } else {
      response.error = "Please fill all fields.";
    }

    return response;
  }

  /**
   * getCalculationCorrectedCalciumCalculator: Service Method
   * POST: /api/calculators-lol/corrected-calcium-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCorrectedCalciumCalculator(body) {
    let calcium = body.tech_calcium;
    let albumin = body.tech_albumin;
    let normal = body.tech_normal;
    let unit_c = body.tech_unit_c;
    let unit_a = body.tech_unit_a;
    let unit_n = body.tech_unit_n;

    let response = {};

    if (!isNaN(calcium) && !isNaN(albumin) && !isNaN(normal)) {
      calcium = parseFloat(calcium);
      albumin = parseFloat(albumin);
      normal = parseFloat(normal);

      if (unit_c === "mmol/l") {
        calcium = calcium * 4.0;
      }

      if (unit_a === "g/L") {
        albumin = albumin * 0.1;
      }

      if (unit_n === "g/L") {
        normal = normal * 0.1;
      }

      let Calcium_res = +(0.8 * (normal - albumin) + calcium).toFixed(1);

      if (unit_c === "mmol/l") {
        Calcium_res = Calcium_res / 4.0;
      }

      response = {
        tech_Calcium_res: +Calcium_res.toFixed(2),
        input_calcium: body.tech_calcium,
        input_albumin: body.tech_albumin,
        input_normal: body.tech_normal,
        input_unit_c: body.tech_unit_c,
        input_unit_a: body.tech_unit_a,
        input_unit_n: body.tech_unit_n,
      };
    } else {
      response = {
        error: "Please fill all fields.",
      };
    }

    return response;
  }

  /**
   * getCalculationANCCalculator: Service Method
   * POST: /api/calculators-lol/anc-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationANCCalculator(body) {
    let wbs = body.tech_wbs;
    let segs = body.tech_segs;
    let bands = body.tech_bands;
    let response = {};

    // Check if any non-submit field is empty
    let isValid = true;
    for (let key in body) {
      if (
        key !== "submit" &&
        (body[key] === "" || body[key] === null || body[key] === undefined)
      ) {
        isValid = false;
        break;
      }
    }

    if (!isNaN(wbs) && !isNaN(segs) && !isNaN(bands) && isValid) {
      wbs = parseFloat(wbs);
      segs = parseFloat(segs);
      bands = parseFloat(bands);

      let anc = (wbs * (segs + bands)) / 100;

      response = {
        tech_anc: +anc.toFixed(2),
      };
    } else {
      response = {
        error: "Please Fill All Fields.",
      };
    }

    return response;
  }

  /**
   * getCalculationALCCalculator: Service Method
   * POST: /api/calculators-lol/alc-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationALCCalculator(body) {
    let wbc = body.tech_wbs;
    let l = body.tech_l;

    let response = {};

    if (!isNaN(wbc) && !isNaN(l)) {
      wbc = parseFloat(wbc);
      l = parseFloat(l);

      let alc = parseFloat(((l / 100) * wbc).toFixed(3));

      response = {
        tech_alc: alc,
      };
    } else {
      response = {
        error: "Please Fill All Fields.",
      };
    }

    return response;
  }

  /**
   * getCalculationReticulocyteCountCalculator: Service Method
   * POST: /api/calculators-lol/reticulocyte-count-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationReticulocyteCountCalculator(body) {
    let x = body.tech_x;
    let y = body.tech_y;
    let z = body.tech_z;

    let response = {};

    if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
      let r = parseFloat(x);
      let h = parseFloat(y);
      let n = parseFloat(z);

      let reticulocyteIndex = r * (h / n);

      let maturationFactor;
      if (h < 20) {
        maturationFactor = 2.5;
      } else if (h < 25) {
        maturationFactor = 2.0;
      } else if (h < 35) {
        maturationFactor = 1.5;
      } else {
        maturationFactor = 1.0;
      }

      let correctedCount = reticulocyteIndex / maturationFactor;

      let ans, ans_p;
      if (reticulocyteIndex < 2) {
        ans = "Hypoproliferation";
        ans_p = "Reticulocyte index <2 indicates Hypoproliferation";
      } else {
        ans = "Adequate";
        ans_p = "Reticulocyte index ≥2 indicates Adequate response";
      }

      response = {
        tech_x: parseFloat(reticulocyteIndex.toFixed(2)),
        tech_y: parseFloat(correctedCount.toFixed(3)),
        tech_ans: ans,
        tech_ans_p: ans_p,
      };
    } else {
      response = {
        error: "Please Fill All Fields.",
      };
    }

    return response;
  }

  /**
   * getCalculationCentorScoreCalculator: Service Method
   * POST: /api/calculators-lol/centor-score-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCentorScoreCalculator(body) {
    let tonsils = body.tech_tonsils;
    let cough = body.tech_cough;
    let lymph = body.tech_lymph;
    let age = body.tech_age;
    let temp = body.tech_temp;
    let unit = body.tech_unit;
    let response = {};

    // Validate all inputs are present (allowing 0 as valid)
    if (
      tonsils !== undefined &&
      cough !== undefined &&
      lymph !== undefined &&
      age !== undefined &&
      temp !== undefined &&
      unit !== undefined &&
      !isNaN(age) &&
      !isNaN(temp)
    ) {
      tonsils = parseInt(tonsils);
      cough = parseInt(cough);
      lymph = parseInt(lymph);
      age = parseFloat(age);
      temp = parseFloat(temp);

      let ageScore;
      if (age < 15) {
        ageScore = 1;
      } else if (age >= 15 && age < 45) {
        ageScore = 0;
      } else {
        ageScore = -1;
      }

      let tempScore = 0;
      if (unit === "°C") {
        tempScore = temp > 38 ? 1 : 0;
      } else {
        tempScore = temp > 100.4 ? 1 : 0;
      }

      let ans = tonsils + cough + lymph + ageScore + tempScore;
      let per = "";
      let text = "";

      if (ans === 0) {
        per = "(1 - 2.5 %)";
        text = "There is no need for further testing or antibiotics.";
      } else if (ans === 1) {
        per = "(5 - 10 %)";
        text = "There is no need for further testing or antibiotics.";
      } else if (ans === 2) {
        per = "(11 - 17 %)";
        text = "At this point, rapid strep testing and/or culture (Optional).";
      } else if (ans === 3) {
        per = "(28 - 35 %)";
        text =
          "There is a need to consider rapid strep testing and/or culture.";
      } else {
        per = "(51 - 53 %)";
        text = "There is a need to treat empirically using antibiotics.";
      }

      response = {
        tech_ans: `${ans} Points`,
        tech_per: per,
        tech_text: text,
      };
    } else {
      response = {
        error: "Please Fill All Fields.",
      };
    }

    return response;
  }

  /**
   * getCalculationChildPughCalculator: Service Method
   * POST: /api/calculators-lol/child-pugh-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationChildPughCalculator(body) {
    let a = body.tech_a;
    let e = body.tech_e;
    let b = body.tech_b;
    let as = body.tech_as;
    let i = body.tech_i;
    let response = {};

    // Check if all required fields are provided
    if ([a, e, b, as, i].every((val) => val !== undefined && val !== "")) {
      a = parseInt(a);
      e = parseInt(e);
      b = parseInt(b);
      as = parseInt(as);
      i = parseInt(i);

      const ans = a + e + i + b + as;

      let classGroup = "";
      let ansa = "";
      let ansb = "";
      let percent1 = "";
      let percent2 = "";

      if (ans === 5 || ans === 6) {
        classGroup = "A";
        ansa = "Life Expectancy : 15-20 years";
        ansb = "Abdominal surgery peri-operative mortality: 10%";
        percent1 = "100";
        percent2 = "85";
      } else if (ans > 6 && ans < 10) {
        classGroup = "B";
        ansa = "Indication for transplant evaluation";
        ansb = "Abdominal surgery peri-operative mortality: 30%";
        percent1 = "81";
        percent2 = "57";
      } else {
        classGroup = "C";
        ansa = "Life Expectancy : 1-3 years";
        ansb = "Abdominal surgery peri-operative mortality: 82%";
        percent1 = "45";
        percent2 = "35";
      }

      response = {
        tech_ans: `${ans} Points`,
        tech_class: classGroup,
        tech_ansa: ansa,
        tech_ansb: ansb,
        tech_percent1: percent1,
        tech_percent2: percent2,
      };
    } else {
      response = {
        error: "Please Fill All Fields.",
      };
    }

    return response;
  }

  /**
   * getCalculationWaistToHipRatioCalculator: Service Method
   * POST: /api/calculators-lol/waist-to-hip-ratio-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationWaistToHipRatioCalculator(body) {
    let w = body.tech_w;
    let h = body.tech_h;
    let unit = body.tech_unit;
    let unit1 = body.tech_unit1;
    let gender = body.tech_gender;
    let response = {};

    if (!isNaN(w) && !isNaN(h)) {
      w = parseFloat(w);
      h = parseFloat(h);

      let ans = 0;

      // Unit conversion
      if (unit === unit1) {
        ans = parseFloat((w / h).toFixed(3));
      } else {
        if (unit === "in") {
          w = w * 2.54;
          ans = parseFloat((w / h).toFixed(3));
        } else if (unit1 === "in") {
          h = h * 2.54;
          ans = parseFloat((w / h).toFixed(3));
        }
      }

      // Always convert waist to cm for classification
      let waist = unit === "in" ? w * 2.54 : w;

      // Optional classification logic (still commented out)
      /*
          if (gender === 'male') {
              if (waist <= 90) response.health = "bg-green-800 text-white";
              else if (waist > 90 && waist <= 102) response.inc = "bg-orange text-white";
              else if (waist > 102) response.risk = "bg-red-800 text-white";
  
              if (ans <= 0.95) response.low = "bg-green-800 text-white";
              else if (ans > 0.95 && ans <= 1.0) response.mod = "bg-orange text-white";
              else if (ans > 1.0) response.high = "bg-red-800 text-white";
          } else {
              if (waist <= 80) response.health = "bg-green-800 text-white";
              else if (waist > 80 && waist <= 88) response.inc = "bg-orange text-white";
              else if (waist > 88) response.risk = "bg-red-800 text-white";
  
              if (ans <= 0.80) response.low = "bg-green-800 text-white";
              else if (ans > 0.80 && ans <= 0.84) response.mod = "bg-orange text-white";
              else if (ans > 0.84) response.high = "bg-red-800 text-white";
          }
          */

      response.tech_ans = ans;
      response.inpit_w = body.tech_w;
      response.inpit_h = body.tech_h;
      response.inpit_unit = body.tech_unit;
      response.inpit_unit1 = body.tech_unit1;
    } else {
      response.error = "Please Fill All Fields.";
    }

    return response;
  }

  /**
   * getCalculationWaistToHeightRatioCalculator: Service Method
   * POST: /api/calculators-lol/waist-to-height-ratio-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationWaistToHeightRatioCalculator(body) {
    let height_ft = body.tech_height_ft;
    let height_in = body.tech_height_in;
    let height_cm = body.tech_height_cm;
    let waist = body.tech_waist;
    let unit_ft_in = body.tech_unit_ft_in;
    let unit = body.tech_unit;
    let gender = body.tech_gender;

    let response = {};
    let color = "";
    let left = "";
    let ans = 0;

    if (
      (!isNaN(height_ft) || !isNaN(height_in) || !isNaN(height_cm)) &&
      !isNaN(waist)
    ) {
      // Convert height to cm
      let total_height_cm = 0;

      if (unit_ft_in === "ft/in") {
        if (!isNaN(height_ft)) {
          total_height_cm += parseFloat(height_ft) * 30.48;
        }
        if (!isNaN(height_in)) {
          total_height_cm += parseFloat(height_in) * 2.54;
        }
      } else {
        total_height_cm = parseFloat(height_cm);
      }

      // Convert waist to cm if it's in inches
      if (unit === "in") {
        waist = parseFloat(waist) * 2.54;
      } else {
        waist = parseFloat(waist);
      }

      // Ratio calculation
      ans = parseFloat((waist / total_height_cm).toFixed(2));

      if (gender === "Male") {
        if (ans < 0.34) {
          color = "#20BEC8";
          left = "2%";
          response.tech_under = "Underweight";
          response.tech_xslim = "bg-blue-800 text-white";
        } else if (ans > 0.34 && ans < 0.42) {
          color = "#20BEC8";
          left = "2%";
          response.tech_slim = "bg-blue-800 text-white";
          response.tech_under = "Underweight";
        } else if (ans >= 0.42 && ans <= 0.52) {
          color = "#10951D";
          left = "26%";
          response.tech_healthy = "Healthy";
          response.tech_health = "bg-green-800 text-white";
        } else if (ans >= 0.53 && ans <= 0.57) {
          color = "#CABE52";
          left = "50%";
          response.tech_over = "Overweight";
          response.tech_overc = "bg-yellow-800 text-white";
        } else if (ans > 0.58 && ans <= 0.62) {
          color = "#FF0000";
          left = "50%";
          response.tech_over = "Overweight";
          response.tech_overh = "bg-red-800 text-white";
        } else if (ans >= 0.63 && ans <= 0.8) {
          color = "#FF0000";
          left = "74%";
          response.tech_obese = "Obese";
          response.tech_obesew = "bg-red-800 text-white";
        } else if (ans > 0.8) {
          color = "#FF0000";
          left = "80%";
          response.tech_obese = "Obese";
          response.tech_obesew = "bg-red-800 text-white";
        }
      } else if (gender === "Female") {
        if (ans < 0.34) {
          color = "#20BEC8";
          left = "2%";
          response.tech_under = "Underweight";
          response.tech_xslim = "bg-blue-800 text-white";
        } else if (ans > 0.34 && ans < 0.42) {
          color = "#20BEC8";
          left = "2%";
          response.tech_slim = "bg-blue-800 text-white";
          response.tech_under = "Underweight";
        } else if (ans >= 0.42 && ans <= 0.48) {
          color = "#10951D";
          left = "26%";
          response.tech_healthy = "Healthy";
          response.tech_health = "bg-green-800 text-white";
        } else if (ans >= 0.49 && ans <= 0.53) {
          color = "#CABE52";
          left = "50%";
          response.tech_over = "Overweight";
          response.tech_overc = "bg-yellow-800 text-white";
        } else if (ans > 0.53 && ans <= 0.57) {
          color = "#FF0000";
          left = "50%";
          response.tech_over = "Overweight";
          response.tech_overh = "bg-red-800 text-white";
        } else if (ans >= 0.58 && ans <= 0.8) {
          color = "#FF0000";
          left = "74%";
          response.tech_obese = "Obese";
          response.tech_obesew = "bg-red-800 text-white";
        } else if (ans > 0.8) {
          color = "#FF0000";
          left = "80%";
          response.tech_obese = "Obese";
          response.tech_obesew = "bg-red-800 text-white";
        }
      }

      response.tech_ratio = ans;
      response.tech_color = color;
      response.tech_left = left;
    } else {
      response.error = "Please Fill All Fields.";
    }

    return response;
  }

  /**
   * getCalculationFFMICalculator: Service Method
   * POST: /api/calculators-lol/ffmi-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationFFMICalculator(body) {
    const result = {};

    let height_ft = Number(body.tech_height_ft);
    let height_in = Number(body.tech_height_in);
    let height_cm = Number(body.tech_height_cm);
    let percent = Number(body.tech_percent);
    let weight = Number(body.tech_weight);
    let unit = body.tech_unit;
    let unit_ft_in = body.tech_unit_ft_in;

    if (
      !isNaN(weight) &&
      !isNaN(percent) &&
      (!isNaN(height_ft) || !isNaN(height_in) || !isNaN(height_cm))
    ) {
      // Convert weight if in lbs
      if (unit === "lbs") {
        weight = weight / 2.205;
      }

      // Handle ft/in to cm
      if (unit_ft_in === "ft/in") {
        height_cm = height_ft * 30.48;
        if (height_in != null) {
          height_cm += height_in * 2.54;
        }
      }

      // Convert height to meters
      let height_inch = height_cm / 2.54;
      let height_m = height_inch / 39.37;

      // Calculations
      let body_fat = +(weight * (percent / 100)).toFixed(2);
      let lean = +(weight * (1 - percent / 100)).toFixed(2);
      let ffmi = +(lean / Math.pow(height_m, 2)).toFixed(2);
      let nffmi = +(ffmi + 6.1 * (1.8 - height_m)).toFixed(2);
      let bmi = +(weight / Math.pow(height_m, 2)).toFixed(2);

      let cat = "";
      // if (ffmi < 18) {
      //   result.skinny = "purple text-white";
      //   cat = "Below Average";
      // } else if (ffmi >= 18 && ffmi < 20) {
      //   result.average = "cyan text-white";
      //   cat = "Average";
      // } else if (ffmi >= 20 && ffmi < 22) {
      //   result.fat = "red text-white";
      //   cat = "Above Average";
      // } else if (ffmi >= 22 && ffmi < 23) {
      //   result.athlete = "orange text-white";
      //   cat = "Excellent";
      // } else if (ffmi >= 23 && ffmi < 26) {
      //   result.gym = "orange text-white";
      //   cat = "Superior";
      // } else if (ffmi >= 26 && ffmi < 28) {
      //   result.body = "bg-gradient text-white";
      //   cat = "Suspicion of steroid use";
      // } else {
      //   result.unlikely = "bg-gradient text-white";
      //   cat = "Unlikely";
      // }
      if (ffmi < 18) {
        result.skinny = "bg-purple-600 text-white";
        cat = "Below Average";
      } else if (ffmi >= 18 && ffmi < 20) {
        result.average = "bg-cyan-600 text-white";
        cat = "Average";
      } else if (ffmi >= 20 && ffmi < 22) {
        result.fat = "bg-red-600 text-white";
        cat = "Above Average";
      } else if (ffmi >= 22 && ffmi < 23) {
        result.athlete = "bg-orange-500 text-white";
        cat = "Excellent";
      } else if (ffmi >= 23 && ffmi < 26) {
        result.gym = "bg-orange-700 text-white";
        cat = "Superior";
      } else if (ffmi >= 26 && ffmi < 28) {
        result.body =
          "bg-gradient-to-r from-yellow-400 via-red-500 to-pink-500 text-white";
        cat = "Suspicion of steroid use";
      } else {
        result.unlikely =
          "bg-gradient-to-r from-gray-700 via-red-700 to-black text-white";
        cat = "Unlikely";
      }

      result.tech_body_fat = body_fat;
      result.tech_lean = lean;
      result.tech_ffmi = ffmi;
      result.tech_nffmi = nffmi;
      result.tech_bmi = bmi;
      result.tech_cat = cat;

      return result;
    } else {
      return {
        error: "Please Fill All Fields.",
      };
    }
  }

  /**
   * getCalculationBodyShapeCalculator: Service Method
   * POST: /api/calculators-lol/body-shape-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBodyShapeCalculator(body) {
    let high = parseFloat(body.tech_high);
    let chest = parseFloat(body.tech_chest);
    let waist = parseFloat(body.tech_waist);
    let hip = parseFloat(body.tech_hip);
    let high_units = body.tech_high_units;
    let chest_units = body.tech_bust_units;
    let waist_units = body.tech_waist_units;
    let hip_units = body.tech_hip_units;
    let gender = body.tech_gender;

    const cm_convert = (val, unit) => {
      return unit === "cm" ? val * 2.54 : val;
    };

    if (isFinite(high) && isFinite(chest) && isFinite(waist) && isFinite(hip)) {
      high = cm_convert(high, high_units);
      chest = cm_convert(chest, chest_units);
      waist = cm_convert(waist, waist_units);
      hip = cm_convert(hip, hip_units);

      let shape = "";
      let img = "";

      if (gender === "men") {
        if (
          Math.abs(chest - waist) <= 2 &&
          Math.abs(waist - hip) <= 2 &&
          Math.abs(hip - high) <= 2
        ) {
          shape = "Rectangle";
          img = "Rectangle_man";
        } else if (chest > waist && chest > hip) {
          shape = "Inverted Triangle";
          img = "male_inver_tri";
        } else if (
          chest > waist &&
          chest > high &&
          !(chest > waist && chest > hip && chest > high)
        ) {
          shape = "Trapezoid";
          img = "Trapezoid";
        } else if (hip > chest && high > chest) {
          shape = "Triangle";
          img = "male_tri";
        } else if (waist > chest && waist > hip) {
          shape = "Oval";
          img = "Oval_man";
        } else if (waist > chest && waist > high) {
          shape = "Triangle";
          img = "Triangle_man";
        } else {
          shape = "Oval";
          img = "Oval_man";
        }
      } else {
        if (
          chest - hip <= 1 &&
          hip - chest < 3.6 &&
          (chest - waist >= 9 || hip - waist >= 10)
        ) {
          shape = "Hourglass";
          img = "Hourglass";
        } else if (
          hip - chest >= 3.6 &&
          hip - chest < 10 &&
          hip - waist >= 9 &&
          high / waist < 1.193
        ) {
          shape = "Bottom Hourglass";
          img = "Bottom_Hourglass";
        } else if (chest - hip > 1 && chest - hip < 10 && chest - waist >= 9) {
          shape = "Top Hourglass";
          img = "Top_Hourglass";
        } else if (
          hip - chest > 2 &&
          hip - waist >= 7 &&
          high / waist >= 1.193
        ) {
          shape = "Spoon";
          img = "Spoon";
        } else if (hip - chest >= 3.6 && hip - waist < 9) {
          shape = "Triangle";
          img = "Triangle";
        } else if (chest - hip >= 3.6 && chest - waist < 9) {
          shape = "Inverted Triangle";
          img = "Inverted_Triangle";
        } else if (
          hip - chest < 3.6 &&
          chest - hip < 3.6 &&
          chest - waist < 9 &&
          hip - waist < 10
        ) {
          shape = "Rectangle";
          img = "Rectangle";
        } else if (chest > waist && hip > high) {
          shape = "Top Hourglass";
          img = "Top_Hourglass";
        } else {
          shape = "Rectangle";
          img = "Rectangle";
        }
      }

      const whr = parseFloat((waist / hip).toFixed(2));

      return {
        tech_shape: shape,
        tech_img: img,
        tech_whr: whr,
      };
    } else {
      return {
        error: "Please Input Values!",
      };
    }
  }

  /**
   * getCalculationWeightLossPercentageCalculator: Service Method
   * POST: /api/calculators-lol/weight-loss-percentage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationWeightLossPercentageCalculator(body) {
    let inw = body.tech_inw;
    let crw = body.tech_crw;
    let unit = body.tech_unit;
    let unit1 = body.tech_unit1;

    let param = {};

    inw = parseFloat(inw);
    crw = parseFloat(crw);

    if (!isNaN(inw) && !isNaN(crw)) {
      let inw_lbs, inw_kg, crw_lbs, crw_kg, pw, wg;

      if (unit === "lbs") {
        inw_lbs = inw;
        inw_kg = inw / 2.20462;
      } else {
        inw_lbs = inw * 2.20462;
        inw_kg = inw;
      }

      if (unit1 === "lb") {
        crw_lbs = crw;
        crw_kg = crw / 2.20462;
      } else {
        crw_lbs = crw * 2.20462;
        crw_kg = crw;
      }

      if (unit === unit1) {
        pw = parseFloat((((inw - crw) / inw) * 100).toFixed(2));
        wg = `${crw - inw} ${unit1}`;
      } else {
        if (unit === "kg") inw = inw * 2.20462;
        if (unit1 === "lbs") crw = crw * 2.20462;
        pw = parseFloat((((inw - crw) / inw) * 100).toFixed(2));
        wg = `${crw - inw} lbs`;
      }

      param.tech_pw = pw;
      param.tech_wg = wg;
      param.tech_inw_lbs = inw_lbs.toFixed(2);
      param.tech_inw_kg = inw_kg.toFixed(2);
      param.tech_crw_lbs = crw_lbs.toFixed(2);
      param.tech_crw_kg = crw_kg.toFixed(2);

      return param;
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /**
   * getCalculationDosageCalculator: Service Method
   * POST: /api/calculators-lol/dosage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDosageCalculator(body) {
    let w = body.tech_w;
    let w1 = body.tech_w1;
    let d = body.tech_d;
    let d1 = body.tech_d1;
    let f = body.tech_f;
    let mc = body.tech_mc;
    let mc1 = body.tech_mc1;
    let param = {};

    w = parseFloat(w);
    d = parseFloat(d);
    mc = parseFloat(mc);

    if (mc1 === "g/L") {
      mc1 = "gl";
    } else if (mc1 === "mg/mL") {
      mc1 = "mgl";
    } else if (mc1 === "µg/L") {
      mc1 = "ugl";
    } else if (mc1 === "mg/mL") {
      mc1 = "mg-ml";
    } else if (mc1 === "µg/mL") {
      mc1 = "ug-ml";
    }

    if (d1 === "µg/kg") {
      d1 = "u-kg";
    } else if (d1 === "mg/kg") {
      d1 = "mg-kg";
    } else if (d1 === "g/kg") {
      d1 = "g-kg";
    }

    if (w1 === "kg") {
      w1 = "kg";
    } else if (w1 === "lbs") {
      w1 = "lb";
    }

    if (!isNaN(w) && !isNaN(d)) {
      if (w1 === "lb") {
        w = w / 2.205;
      }

      if (d1 === "u-kg") {
        d = d / 1000;
      }

      if (d1 === "g-kg") {
        d = d * 1000;
      }

      if (mc1 === "mgl" || mc1 === "ug-ml") {
        mc = mc / 1000;
      }

      if (mc1 === "ugl") {
        mc = mc / 1000000;
      }

      let tdose = w * d;
      let gr = tdose / 1000;
      let ug = tdose * 1000;
      let dose;

      if (f != 1) {
        switch (f) {
          case "4h":
            dose = tdose / 6;
            break;
          case "3h":
            dose = tdose / 8;
            break;
          case "2h":
            dose = tdose / 12;
            break;
          case "h":
            dose = tdose / 24;
            break;
          default:
            dose = tdose / parseFloat(f);
        }
        param["tech_dose"] = dose;
      }

      if (!isNaN(mc)) {
        let lq_dose = tdose / mc;
        let g = lq_dose / 1000;

        param["tech_lq_dose"] = parseFloat(lq_dose.toFixed(2));
        param["tech_g"] = parseFloat(g.toFixed(2));

        if (f != 1) {
          let lq_dose1 = dose / mc;
          param["tech_lq_dose1"] = parseFloat(lq_dose1.toFixed(2));
        }
      }

      param["tech_tdose"] = parseFloat(tdose.toFixed(1));
      param["tech_ug"] = parseFloat(ug.toFixed(2));
      param["tech_gr"] = parseFloat(gr.toFixed(2));

      return param;
    } else {
      return { error: "Please fill all fields." };
    }
  }

  /**
   * getCalculationBraSizeCalculator: Service Method
   * POST: /api/calculators-lol/bra-size-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBraSizeCalculator(body) {
    let bust = parseFloat(body.tech_bust);
    let unit = body.tech_unit?.trim();
    let band = parseFloat(body.tech_band);
    let unit1 = body.tech_unit1?.trim();

    let response = {};

    if (!isNaN(bust) && !isNaN(band)) {
      const sizes = {
        0: ["AA", "AA", "AA", "AA", "AA"],
        1: ["A", "A", "A", "A", "A"],
        2: ["B", "B", "B", "B", "B"],
        3: ["C", "C", "C", "C", "C"],
        4: ["D", "D", "D", "E", "E"],
        5: ["DD/E", "DD", "DD", "F", "F"],
        6: ["DDD/F", "E", "E", "G", "G"],
        7: ["DDDD/G", "F", "F", "H", "H"],
        8: ["H", "G", "FF", "J", "J"],
        9: ["I", "H", "G", "K", "K"],
        10: ["J", "I", "GG", "L", "L"],
        11: ["K", "J", "H", "M", "M"],
        12: ["L", "K", "HH", "O", "O"],
        13: ["M", "L", "J", "P", "P"],
        14: ["N", "M", "JJ", "Q", "Q"],
        15: ["O", "N", "K", "S", "S"],
        16: ["P", "O", "KK", "T", "T"],
        17: ["Q", "P", "L", "U", "U"],
        18: ["R", "Too big bust size", "LL", "V", "V"],
        19: [
          "Too big bust size",
          "Too big bust size",
          "Too big bust size",
          "Y",
          "Y",
        ],
        20: [
          "Too big bust size",
          "Too big bust size",
          "Too big bust size",
          "Z",
          "Z",
        ],
      };

      let main_bust = bust;
      let main_band = band;

      if (unit === "cm") bust = Math.round(bust / 2.54);
      if (unit1 === "cm") band = Math.round(band / 2.54);

      let diff;
      if (band % 2 === 0) {
        diff = Math.round(bust) - Math.round(band);
      } else {
        band = band > main_band ? band - 1 : band + 1;
        diff = Math.round(bust) - Math.round(band);
      }

      if (band > bust) {
        response.error = "Bust size must be greater than Band size.";
        return response;
      }

      let aus, eu, fr;
      if (band < 26) {
        band = aus = eu = fr = "Band too small";
      } else {
        let diff1 = band - 26;
        aus = 4 + diff1;
        eu = 55 + diff1 * 2.5;
        fr = 70 + diff1 * 2.5;
      }

      let ans =
        diff > 20
          ? [
              "Too big bust size",
              "Too big bust size",
              "Too big bust size",
              "Too big bust size",
              "Too big bust size",
            ]
          : sizes[diff] || [
              "Unknown",
              "Unknown",
              "Unknown",
              "Unknown",
              "Unknown",
            ];

      response.tech_band = band;
      response.tech_aus = aus;
      response.tech_ans = ans;
      response.tech_eu = eu;
      response.tech_fr = fr;
    } else {
      response.error = "Please Check Your Input.";
    }

    return response;
  }

  /**
   * getCalculationImplantationCalculator: Service Method
   * POST: /api/calculators-lol/implantation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationImplantationCalculator(body) {
    let know = body.tech_know;
    let ovd = body.tech_ovd;
    let lp = body.tech_lp;
    let mcl = body.tech_mcl;
    let ivf = body.tech_ivf;

    know = (know || "").trim();
    ovd = (ovd || "").trim();
    lp = (lp || "").trim();
    mcl = parseInt(mcl) || 0;
    ivf = (ivf || "").trim();

    let result = {};

    let ovulationDate;

    if (know === "yes" && ovd) {
      ovulationDate = moment(ovd);
    } else if (know === "no" && lp) {
      const days = mcl - 14;
      ovulationDate = moment(lp).add(days, "days");
    } else {
      result.error = "Please Check Your Input.";
      return result;
    }

    const formattedOvulationDate = ovulationDate.format("MMM DD, YYYY");

    let table = `<table className="w-full" cellspacing="0">
          <thead className="bggreen_implantation_calculator">
              <tr>
                  <td colspan="3" className="text-center border-2 radius-t-10 px-3 py-2">
                      Ovulation Date: "${formattedOvulationDate}"
                  </td>
              </tr>
              <tr>
                  <td className="radius-bl-10 px-3 py-2">Days Past Ovulation (DPO)</td>
                  <td className="px-3">Date</td>
                  <td className="radius-br-10 px-3">Probability of Implantation</td>
              </tr>
          </thead>
          <tbody>`;

    for (let i = 0; i < 17; i++) {
      const impDate = ovulationDate
        .clone()
        .add(i, "days")
        .format("MMM DD, YYYY");
      let cmnt = "";
      let clr = "";

      if (i === 0) {
        cmnt = "Ovulation";
        clr = "clr_0";
      } else if (i > 0 && i < 6) {
        cmnt = "Travel inside Fallopian tube";
        clr = "clr_1";
      } else if ((i > 5 && i < 9) || (i > 9 && i < 13)) {
        cmnt = "Implantation possible";
        clr = "clr_2";
      } else if (i === 9) {
        cmnt = "Implantation very possible";
        clr = "clr_3";
      } else if (i > 12 && i < 15) {
        cmnt = "Implantation unlikely";
        clr = "clr_1";
      } else {
        cmnt = "Missed Period: Pregnancy Test?";
        clr = "clr_4";
      }

      const border = i < 16 ? "border-b" : "";
      table += `<tr className='${clr}'><th className='text-start ${border} px-3 py-3'>${i} DPO</th><td className='${border} px-3'>${impDate}</td><td className='${border} px-3'>${cmnt}</td></tr>`;
    }

    table += "</tbody></table>";

    if (ivf) {
      const ivfDate = moment(ivf).add(5, "days").format("MMM DD, YYYY");
      result.tech_ivf = ivfDate;
    }

    result.tech_table = table;
    return result;
  }

  /**
   * getCalculationBloodTypeCalculator: Service Method
   * POST: /api/calculators-lol/blood-type-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationBloodTypeCalculator(body) {
    let op = body.tech_selection;
    let op1 = body.tech_c_unit;
    let op2 = body.tech_selection3;
    let op3 = body.tech_d_unit;

    let A = 0,
      B = 0,
      AB = 0,
      O = 0;
    let Rhpos = 0,
      Rhneg = 0;

    // Blood group logic
    if (op === "0" && op2 === "0") {
      A = 0;
      B = 0;
      AB = 0;
      O = 100;
    }
    if (op === "1" && op2 === "1") {
      A = 93.75;
      B = 0;
      AB = 0;
      O = 6.25;
    }
    if (op === "2" && op2 === "2") {
      A = 0;
      B = 93.75;
      AB = 0;
      O = 6.25;
    }
    if (op === "3" && op2 === "3") {
      A = 25;
      B = 25;
      AB = 50;
      O = 0;
    }
    if ((op === "0" && op2 === "1") || (op === "1" && op2 === "0")) {
      A = 75;
      B = 0;
      AB = 0;
      O = 25;
    }
    if ((op === "0" && op2 === "2") || (op === "2" && op2 === "0")) {
      A = 0;
      B = 75;
      AB = 0;
      O = 25;
    }
    if ((op === "0" && op2 === "3") || (op === "3" && op2 === "0")) {
      A = 50;
      B = 50;
      AB = 0;
      O = 0;
    }
    if ((op === "1" && op2 === "2") || (op === "2" && op2 === "1")) {
      A = 18.75;
      B = 18.75;
      AB = 56.25;
      O = 6.25;
    }
    if ((op === "1" && op2 === "3") || (op === "3" && op2 === "1")) {
      A = 50;
      B = 12.5;
      AB = 37.5;
      O = 0;
    }
    if ((op === "2" && op2 === "3") || (op === "3" && op2 === "2")) {
      A = 12.5;
      B = 50;
      AB = 37.5;
      O = 0;
    }

    // Rh factor logic
    if (op1 === "0" && op3 === "0") {
      Rhpos = 93.75;
      Rhneg = 6.25;
    }
    if ((op1 === "0" && op3 === "1") || (op1 === "1" && op3 === "0")) {
      Rhpos = 75;
      Rhneg = 25;
    }
    if (op1 === "1" && op3 === "1") {
      Rhpos = 0;
      Rhneg = 100;
    }

    return {
      tech_A: A,
      tech_B: B,
      tech_AB: AB,
      tech_O: O,
      tech_rhpos: Rhpos,
      tech_rhneg: Rhneg,
    };
  }

  /**
   * getCalculationMelatoninDosageCalculator: Service Method
   * POST: /api/calculators-lol/melatonin-dosage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMelatoninDosageCalculator(body) {
    let selection = body.tech_selection;
    let selection1 = body.tech_selection3;
    let units = body.tech_d_unit;
    let inputs = body.tech_charge;

    let unit;
    if (units === "days") {
      unit = 1;
    } else if (units === "weeks") {
      unit = 2;
    } else if (units === "months") {
      unit = 3;
    } else if (units === "years") {
      unit = 4;
    } else {
      unit = units; // in case it's already converted
    }

    let days,
      weeks,
      months,
      years,
      cn,
      drops,
      applications,
      tablets,
      strips,
      ml,
      ans2,
      ans3,
      ans4,
      ans1_second,
      ans1_third,
      ans1_four,
      tablet;

    if (isNaN(inputs) || inputs <= 0) {
      return { error: "Please! Enter value greater than 0." };
    }

    if (unit == 1) {
      days = "days";
      cn = inputs * 1;
    } else if (unit == 2) {
      weeks = "weeks";
      cn = inputs * 7;
    } else if (unit == 3) {
      months = "months";
      const cn1 = inputs * 30.44;
      const cn2 = cn1 + 0.4;
      cn = Math.round(cn2);
    } else if (unit == 4) {
      years = "years";
      const cn1 = inputs * 365.25;
      const cn2 = cn1 + 0.4;
      cn = Math.round(cn2);
    }

    let answer1, answer2, answer3, answer4, ans1, ans1_first;

    switch (selection) {
      case "1":
        answer1 = "0.3-5";
        answer2 = "Taken 1 h before sleep.";
        switch (selection1) {
          case "1":
            answer3 = "Number of tablets needed for a";
            tablets = "tablets";
            answer4 = inputs;
            ans1_first = cn * 5;
            const ans1_sec = ans1_first / 3;
            ans1_second = Math.round(ans1_sec + 0.4);
            ans1_third = cn;
            const ans1_four1 = ans1_first / 10;
            ans1_four = Math.round(ans1_four1 + 0.4);
            ans1 = "1 mg →";
            ans2 = "3 mg →";
            ans3 = "5 mg →";
            ans4 = "10 mg →";
            break;
          case "2":
            answer3 = "Volume needed for a";
            answer4 = inputs;
            drops = "drops";
            ml = "mL";
            ans1 = "1 mg/25ml →";
            ans1_first = cn * 125;
            ans1_second = ans1_first / 5;
            break;
          case "3":
            answer3 = "Number of spray applications needed for";
            answer4 = inputs;
            applications = "applications";
            ans1 = "0.5 mg/application →";
            ans1_first = cn * 10;
            break;
          case "4":
            answer3 = "Number of strips needed for";
            answer4 = inputs;
            strips = "strips";
            ans1 = "1 mg →";
            ans2 = "3 mg →";
            const ans1_first1 = cn * 5;
            ans1_first = Math.round(ans1_first1 + 0.4);
            const ans1_sec1 = ans1_first / 3;
            ans1_second = Math.round(ans1_sec1 + 0.4);
            break;
        }
        break;
      case "2":
        answer1 = "1-6";
        answer2 =
          "For eastbound flights (e.g., US to Europe) take melatonin for two days before the flight, around 7 PM. Continue taking melatonin for 4 days after arrival, right before going to bed.";
        switch (selection1) {
          case "1":
            answer3 = "Number of tablets needed for a";
            tablets = "tablets";
            answer4 = inputs;
            ans1_first = cn * 6;
            const ans1_sec = ans1_first / 3;
            ans1_second = Math.round(ans1_sec + 0.4);
            const ans1_third1 = ans1_first / 5;
            ans1_third = Math.round(ans1_third1 + 0.4);
            const ans1_four1 = ans1_first / 10;
            ans1_four = Math.round(ans1_four1 + 0.4);
            ans1 = "1 mg →";
            ans2 = "3 mg →";
            ans3 = "5 mg →";
            ans4 = "10 mg →";
            break;
          case "2":
            answer3 = "Volume needed for a";
            answer4 = inputs;
            drops = "drops";
            ml = "mL";
            ans1 = "1 mg/25ml →";
            ans1_first = cn * 150;
            ans1_second = ans1_first / 5;
            break;
          case "3":
            answer3 = "Number of spray applications needed for";
            answer4 = inputs;
            applications = "applications";
            ans1 = "0.5 mg/application →";
            ans1_first = cn * 12;
            break;
          case "4":
            answer3 = "Number of strips needed for";
            answer4 = inputs;
            strips = "strips";
            ans1 = "1 mg →";
            ans2 = "3 mg →";
            const ans1_first1 = cn * 6;
            ans1_first = Math.round(ans1_first1 + 0.4);
            const ans1_sec1 = ans1_first / 3;
            ans1_second = Math.round(ans1_sec1 + 0.4);
            break;
        }
        break;
      case "3":
        answer1 = "1-6";
        answer2 =
          "For westbound flights (e.g., Europe to the US) take melatonin for 4 days after arrival, right before going to bed.";
        switch (selection1) {
          case "1":
            answer3 = "Number of tablets needed for a";
            tablets = "tablets";
            answer4 = inputs;
            ans1_first = cn * 6;
            const ans1_sec = cn * 2;
            ans1_second = Math.round(ans1_sec + 0.4);
            const ans1_third1 = ans1_first / 5;
            ans1_third = Math.round(ans1_third1 + 0.4);
            const ans1_four1 = ans1_first / 10;
            ans1_four = Math.round(ans1_four1 + 0.4);
            ans1 = "1 mg →";
            ans2 = "3 mg →";
            ans3 = "5 mg →";
            ans4 = "10 mg →";
            break;
          case "2":
            answer3 = "Volume needed for a";
            answer4 = inputs;
            drops = "drops";
            ml = "mL";
            ans1 = "1 mg/25ml →";
            ans1_first = cn * 150;
            ans1_second = ans1_first / 5;
            break;
          case "3":
            answer3 = "Number of spray applications needed for";
            answer4 = inputs;
            applications = "applications";
            ans1 = "0.5 mg/application →";
            ans1_first = cn * 12;
            break;
          case "4":
            answer3 = "Number of strips needed for";
            answer4 = inputs;
            strips = "strips";
            ans1 = "1 mg →";
            ans2 = "3 mg →";
            const ans1_first1 = cn * 6;
            ans1_first = Math.round(ans1_first1 + 0.4);
            const ans1_sec1 = ans1_first / 3;
            ans1_second = Math.round(ans1_sec1 + 0.4);
            break;
        }
        break;
      case "4":
        answer1 = "0.5";
        answer2 = "Take melatonin around 9-10 PM, before going to sleep.";
        switch (selection1) {
          case "1":
            answer3 = "Number of tablets needed for a";
            tablet = "tablets";
            answer4 = inputs;
            const ans1_first1s = cn * 0.5;
            ans1_first = Math.round(ans1_first1s + 0.4);
            const ans1_sec = ans1_first / 3;
            ans1_second = Math.round(ans1_sec + 0.4);
            ans1 = "1 mg →";
            ans2 = "3 mg →";
            break;
          case "2":
            answer3 = "Volume needed for a";
            answer4 = inputs;
            drops = "drops";
            ml = "mL";
            ans1 = "1 mg/25ml →";
            ans1_first = cn * 12.5;
            ans1_second = cn * 2.5;
            break;
          case "3":
            answer3 = "Number of spray applications needed for";
            answer4 = inputs;
            applications = "applications";
            ans1 = "0.5 mg/application →";
            ans1_first = cn;
            break;
          case "4":
            answer3 = "Number of strips needed for";
            answer4 = inputs;
            strips = "strips";
            ans1 = "1 mg →";
            const ans1_first1 = cn * 0.5;
            ans1_first = Math.round(ans1_first1 + 0.4);
            break;
        }
        break;
      case "5":
        answer1 = "2.5";
        answer2 = "Taken daily, for up to 4 weeks.";
        switch (selection1) {
          case "1":
            answer3 = "Number of tablets needed for a";
            tablets = "tablets";
            answer4 = inputs;
            const ans1_first1d = cn * 2.5;
            ans1_first = Math.round(ans1_first1d + 0.4);
            const ans1_sec = ans1_first / 3;
            ans1_second = Math.round(ans1_sec + 0.4);
            const ans1_third1 = ans1_first / 5;
            ans1_third = Math.round(ans1_third1 + 0.4);
            const ans1_four1 = ans1_first / 10;
            ans1_four = Math.round(ans1_four1 + 0.4);
            ans1 = "1 mg →";
            ans2 = "3 mg →";
            ans3 = "5 mg →";
            ans4 = "10 mg →";
            break;
          case "2":
            answer3 = "Volume needed for a";
            answer4 = inputs;
            drops = "drops";
            ml = "mL";
            ans1 = "1 mg/25ml →";
            ans1_first = cn * 62.5;
            ans1_second = ans1_first / 5;
            break;
          case "3":
            answer3 = "Number of spray applications needed for";
            answer4 = inputs;
            applications = "applications";
            ans1 = "0.5 mg/application →";
            const ans1_first1e = cn * 5;
            ans1_first = Math.round(ans1_first1e + 0.4);
            break;
          case "4":
            answer3 = "Number of strips needed for";
            answer4 = inputs;
            strips = "strips";
            ans1 = "1 mg →";
            ans2 = "3 mg →";
            const ans1_first1 = cn * 2.5;
            ans1_first = Math.round(ans1_first1 + 0.4);
            const ans1_sec1 = ans1_first / 3;
            ans1_second = Math.round(ans1_sec1 + 0.4);
            break;
        }
        break;
      case "6":
        answer1 = "10";
        answer2 = "Taken daily, for up to 8 weeks.";
        switch (selection1) {
          case "1":
            answer3 = "Number of tablets needed for a";
            tablets = "tablets";
            answer4 = inputs;
            const ans1_first1 = cn * 10;
            ans1_first = Math.round(ans1_first1 + 0.4);
            const ans1_sec = ans1_first / 3;
            ans1_second = Math.round(ans1_sec + 0.4);
            const ans1_third1 = ans1_first / 5;
            ans1_third = Math.round(ans1_third1 + 0.4);
            const ans1_four1 = ans1_first / 10;
            ans1_four = Math.round(ans1_four1 + 0.4);
            ans1 = "1 mg →";
            ans2 = "3 mg →";
            ans3 = "5 mg →";
            ans4 = "10 mg →";
            break;
          case "2":
            answer3 = "Volume needed for a";
            answer4 = inputs;
            drops = "drops";
            ml = "mL";
            ans1 = "1 mg/25ml →";
            ans1_first = cn * 250;
            ans1_second = ans1_first / 5;
            break;
          case "3":
            answer3 = "Number of spray applications needed for";
            answer4 = inputs;
            applications = "applications";
            ans1 = "0.5 mg/application →";
            ans1_first = cn * 20;
            break;
          case "4":
            answer3 = "Number of strips needed for";
            answer4 = inputs;
            strips = "strips";
            ans1 = "1 mg →";
            ans2 = "3 mg →";
            const ans1_first111 = cn * 10;
            ans1_first = Math.round(ans1_first111 + 0.4);
            const ans1_sec1 = ans1_first / 3;
            ans1_second = Math.round(ans1_sec1 + 0.4);
            break;
        }
        break;
      default:
        return { error: "Invalid selection" };
    }

    return {
      tech_answer1: answer1,
      tech_answer2: answer2,
      tech_answer3: answer3,
      tech_answer4: answer4,
      tech_ans1: ans1,
      tech_ans2: ans2,
      tech_ans3: ans3,
      tech_ans4: ans4,
      tech_ans1_first: ans1_first,
      tech_ans1_second: ans1_second,
      tech_ans1_third: ans1_third,
      tech_ans1_four: ans1_four,
      tech_tablets: tablets,
      tech_tablet: tablet,
      tech_ml: ml,
      tech_drops: drops,
      tech_unit: unit,
      tech_applications: applications,
      tech_strips: strips,
      tech_cn: cn,
      tech_years: years,
      tech_days: days,
      tech_weeks: weeks,
      tech_months: months,
    };
  }

  /**
   * getCalculationProstateVolumeCalculator: Service Method
   * POST: /api/calculators-lol/prostate-volume-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationProstateVolumeCalculator(body) {
    let length = body.tech_length;
    let length_unit = body.tech_length_unit;
    let width = body.tech_width;
    let width_unit = body.tech_width_unit;
    let height = body.tech_height;
    let height_unit = body.tech_height_unit;
    let psa = body.tech_psa;

    // Unit conversion map
    const unitMap = {
      mm: 10,
      cm: 1,
      dm: 0.1,
      m: 0.01,
      km: 0.00001,
      mi: 0.000006213711922373,
      in: 0.3937007874016,
      ft: 0.03280839895013,
      yd: 0.01093613298338,
    };

    let result = {};

    // Convert to float
    length = parseFloat(length);
    width = parseFloat(width);
    height = parseFloat(height);
    psa = parseFloat(psa);

    if (!isNaN(length) && !isNaN(width) && !isNaN(height)) {
      let first = length * unitMap[length_unit];
      let second = width * unitMap[width_unit];
      let third = height * unitMap[height_unit];

      let div = Math.PI / 6;
      let div2 = (5 * Math.PI) / 24;

      let answer = first * second * third * div;
      let answer22 = first * second * third * div2;

      let answer2 = 0;
      let answer23 = 0;

      if (!isNaN(psa)) {
        if (psa !== 0) {
          answer2 = psa / answer;
          answer23 = psa / answer22;
        }
      }

      result.tech_answer = answer;
      result.tech_answer22 = answer22;
      result.tech_answer2 = answer2;
      result.tech_answer23 = answer23;
    } else {
      result.error = "Please! Check your input.";
    }

    return result;
  }

  /**
   * getCalculationDihybridcrossCalculator: Service Method
   * POST: /api/calculators-lol/dihybrid-cross-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDihybridcrossCalculator(body) {
    const mother1 = body.tech_mtype1 ? body.tech_mtype1.trim() : "";
    const mother2 = body.tech_mtype2 ? body.tech_mtype2.trim() : "";
    const father1 = body.tech_ftype1 ? body.tech_ftype1.trim() : "";
    const father2 = body.tech_ftype2 ? body.tech_ftype2.trim() : "";

    const result = {
      tech_table: "",
      tech_finalRes: null,
      tech_tablResults: [],
    };

    function isNumeric(value) {
      return /^\d+$/.test(value);
    }
    if (
      isNumeric(mother1) &&
      isNumeric(mother2) &&
      isNumeric(father1) &&
      isNumeric(father2)
    ) {
      let m1, m2, m3, m4;
      let f1, f2, f3, f4;

      // Mother's gametes
      if (mother1 === "0" && mother2 === "0") {
        m1 = m2 = m3 = m4 = "AB";
      } else if (mother1 === "0" && mother2 === "1") {
        m1 = m2 = "AB";
        m3 = m4 = "Ab";
      } else if (mother1 === "0" && mother2 === "2") {
        m1 = m2 = m3 = m4 = "Ab";
      } else if (mother1 === "1" && mother2 === "1") {
        m1 = "AB";
        m2 = "Ab";
        m3 = "aB";
        m4 = "ab";
      } else if (mother1 === "1" && mother2 === "0") {
        m1 = m2 = "AB";
        m3 = m4 = "aB";
      } else if (mother1 === "1" && mother2 === "2") {
        m1 = m2 = "Ab";
        m3 = m4 = "ab";
      } else if (mother1 === "2" && mother2 === "0") {
        m1 = m2 = m3 = m4 = "aB";
      } else if (mother1 === "2" && mother2 === "1") {
        m1 = m2 = "aB";
        m3 = m4 = "ab";
      } else if (mother1 === "2" && mother2 === "2") {
        m1 = m2 = m3 = m4 = "ab";
      }

      // Father's gametes
      if (father1 === "0" && father2 === "0") {
        f1 = f2 = f3 = f4 = "AB";
      } else if (father1 === "0" && father2 === "1") {
        f1 = f2 = "AB";
        f3 = f4 = "Ab";
      } else if (father1 === "0" && father2 === "2") {
        f1 = f2 = f3 = f4 = "Ab";
      } else if (father1 === "1" && father2 === "1") {
        f1 = "AB";
        f2 = "Ab";
        f3 = "aB";
        f4 = "ab";
      } else if (father1 === "1" && father2 === "0") {
        f1 = f2 = "AB";
        f3 = f4 = "aB";
      } else if (father1 === "1" && father2 === "2") {
        f1 = f2 = "Ab";
        f3 = f4 = "ab";
      } else if (father1 === "2" && father2 === "0") {
        f1 = f2 = f3 = f4 = "aB";
      } else if (father1 === "2" && father2 === "1") {
        f1 = f2 = "aB";
        f3 = f4 = "ab";
      } else if (father1 === "2" && father2 === "2") {
        f1 = f2 = f3 = f4 = "ab";
      }

      // Generate table
      result.tech_table = `<table className="dihybrid-cross-calculator" cellspacing="0">
              <tr>
                  <td className="border-b py-2"><b>♂️\\♀️</b></td>
                  <td className="border-b"><b>${m1}</b></td>
                  <td className="border-b py-2"><b>${m2}</b></td>
                  <td className="border-b"><b>${m3}</b></td>
                  <td className="border-b py-2"><b>${m4}</b></td>
              </tr>
              <tr>
                  <td className="border-b py-2"><b>${f1}</b></td>
                  <td className="border-b py-2">${m1[0]}${f1[0]}${m1[1]}${f1[1]}</td>
                  <td className="border-b py-2">${m2[0]}${f1[0]}${m2[1]}${f1[1]}</td>
                  <td className="border-b py-2">${m3[0]}${f1[0]}${m3[1]}${f1[1]}</td>
                  <td className="border-b py-2">${m4[0]}${f1[0]}${m4[1]}${f1[1]}</td>
              </tr>
              <tr>
                  <td className="border-b py-2"><b>${f2}</b></td>
                  <td className="border-b py-2">${m1[0]}${f2[0]}${m1[1]}${f2[1]}</td>
                  <td className="border-b py-2">${m2[0]}${f2[0]}${m2[1]}${f2[1]}</td>
                  <td className="border-b py-2">${m3[0]}${f2[0]}${m3[1]}${f2[1]}</td>
                  <td className="border-b py-2">${m4[0]}${f2[0]}${m4[1]}${f2[1]}</td>
              </tr>
              <tr>
                  <td className="border-b py-2"><b>${f3}</b></td>
                  <td className="border-b py-2">${m1[0]}${f3[0]}${m1[1]}${f3[1]}</td>
                  <td className="border-b py-2">${m2[0]}${f3[0]}${m2[1]}${f3[1]}</td>
                  <td className="border-b py-2">${m3[0]}${f3[0]}${m3[1]}${f3[1]}</td>
                  <td className="border-b py-2">${m4[0]}${f3[0]}${m4[1]}${f3[1]}</td>
              </tr>
              <tr>
                  <td className="py-2"><b>${f4}</b></td>
                  <td>${m1[0]}${f4[0]}${m1[1]}${f4[1]}</td>
                  <td>${m2[0]}${f4[0]}${m2[1]}${f4[1]}</td>
                  <td>${m3[0]}${f4[0]}${m3[1]}${f4[1]}</td>
                  <td>${m4[0]}${f4[0]}${m4[1]}${f4[1]}</td>
              </tr>
          </table>`;

      const tablMother = [parseInt(mother1), parseInt(mother2)];
      const tablFather = [parseInt(father1), parseInt(father2)];

      const tablProp = [
        [
          [1, 0.5, 0],
          [0.5, 0.25, 0],
          [0, 0, 0],
        ],
        [
          [0, 0.5, 1],
          [0.5, 0.5, 0.5],
          [1, 0.5, 0],
        ],
        [
          [0, 0, 0],
          [0, 0.25, 0.5],
          [0, 0.5, 1],
        ],
      ];

      for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
          result.tech_tablResults[3 * i + j] =
            tablProp[i][tablMother[0]][tablFather[0]] *
            tablProp[j][tablMother[1]][tablFather[1]];
        }
      }

      function getTablResults(mother1, father1, mother2, father2, idx) {
        const tablMother = [parseInt(mother1), parseInt(mother2)];
        const tablFather = [parseInt(father1), parseInt(father2)];
        const tablProp = [
          [
            [1, 0.5, 0],
            [0.5, 0.25, 0],
            [0, 0, 0],
          ],
          [
            [0, 0.5, 1],
            [0.5, 0.5, 0.5],
            [1, 0.5, 0],
          ],
          [
            [0, 0, 0],
            [0, 0.25, 0.5],
            [0, 0.5, 1],
          ],
        ];
        const tech_tablResults = [];
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            tech_tablResults[3 * i + j] =
              tablProp[i][tablMother[0]][tablFather[0]] *
              tablProp[j][tablMother[1]][tablFather[1]];
          }
        }
        return tech_tablResults[idx];
      }

      result.tech_finalRes = getTablResults(
        mother1,
        father1,
        mother2,
        father2,
        0
      );
    } else {
      result.error = "Please Check Your Input.";
    }

    return result;
  }

  /**
   * getCalculationHCGCalculator: Service Method
   * POST: /api/calculators-lol/hcg-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationHCGCalculator(body) {
    let first = parseFloat(body.tech_first);
    let second = parseFloat(body.tech_second);
    let third = parseFloat(body.tech_third);
    let unit3 = body.tech_unit3;

    function din(a, b) {
      if (a === "hours") {
        return b * 0.04167;
      } else if (a === "days") {
        return b * 1;
      } else {
        return 0; // fallback for unsupported units
      }
    }

    third = din(unit3, third);

    if (!isNaN(first) && !isNaN(second) && !isNaN(third)) {
      let difference = second - first;
      let pos = Math.abs(difference);
      let div1 = pos / first;
      let percent = div1 * 100;
      let div2 = second / first;
      let log = Math.log2(div2);
      let t2 = third / log;
      let hours = t2 * 24;
      let f_div = 24 / hours;
      let s_div = 48 / hours;
      let f_pow = Math.pow(2, f_div);
      let s_pow = Math.pow(2, s_div);
      let f_min = f_pow - 1;
      let s_min = s_pow - 1;
      let i1 = f_min * 100;
      let i2 = s_min * 100;

      return {
        tech_difference: difference,
        tech_percent: percent,
        tech_t2: t2,
        tech_i1: i1,
        tech_i2: i2,
      };
    } else {
      return {
        error: "Please! check your input.",
      };
    }
  }

  /**
   * getCalculationDressSizeCalculator: Service Method
   * POST: /api/calculators-lol/dress-size-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDressSizeCalculator(body) {
    let bust = Number(body.tech_bust);
    let waist = Number(body.tech_waist);
    let hips = Number(body.tech_hips);
    let response = {};

    function getUSSize(EuroSize) {
      if (EuroSize <= 30) return "00";
      else if (EuroSize <= 32) return "0";
      else if (EuroSize <= 34) return "2";
      else if (EuroSize <= 36) return "4";
      else if (EuroSize <= 38) return "6";
      else if (EuroSize <= 40) return "8";
      else if (EuroSize <= 42) return "10";
      else if (EuroSize <= 44) return "12";
      else if (EuroSize <= 46) return "14";
      else if (EuroSize <= 48) return "16";
      else if (EuroSize <= 50) return "18";
      else if (EuroSize <= 52) return "20";
      else if (EuroSize <= 54) return "22";
      else return "Not strictly determined";
    }

    function getUKSize(EuroSize) {
      if (EuroSize <= 30) return "2";
      else if (EuroSize <= 32) return "4";
      else if (EuroSize <= 34) return "6";
      else if (EuroSize <= 36) return "8";
      else if (EuroSize <= 38) return "10";
      else if (EuroSize <= 40) return "12";
      else if (EuroSize <= 42) return "14";
      else if (EuroSize <= 44) return "16";
      else if (EuroSize <= 46) return "18";
      else if (EuroSize <= 48) return "20";
      else if (EuroSize <= 50) return "22";
      else if (EuroSize <= 52) return "24";
      else if (EuroSize <= 54) return "26";
      else return "Not strictly determined";
    }

    function getInternationalSize(EuroSize) {
      if (EuroSize <= 30) return "XXS";
      else if (EuroSize <= 32) return "XS";
      else if (EuroSize <= 34) return "XS";
      else if (EuroSize <= 36) return "S";
      else if (EuroSize <= 38) return "S";
      else if (EuroSize <= 40) return "M";
      else if (EuroSize <= 42) return "M";
      else if (EuroSize <= 44) return "L";
      else if (EuroSize <= 46) return "L";
      else if (EuroSize <= 48) return "XL";
      else if (EuroSize <= 50) return "XL";
      else if (EuroSize <= 52) return "XXL";
      else if (EuroSize <= 54) return "XXL";
      else return "Not strictly determined";
    }

    if (bust && waist && hips) {
      if (bust === waist && waist === hips) {
        let euroSize = bust.toString();
        let usaSize = getUSSize(bust);
        let ukSize = getUKSize(bust);
        let internationalSize = getInternationalSize(bust);

        if (bust >= 56) {
          response.tech_firstText =
            "Sorry, we couldn't calculate a dress size based on your measurements. Check the catalog or manufacturer before buying your dress, or try it on if you can";
        } else {
          response.tech_usaSize = usaSize;
          response.tech_ukSize = ukSize;
          response.tech_euroSize = euroSize;
          response.tech_internationalSize = internationalSize;
        }
      } else {
        if (bust >= 56 || waist >= 56 || hips >= 56) {
          response.tech_firstText =
            "Sorry, we couldn't calculate a dress size based on your measurements. Check the catalog or manufacturer before buying your dress, or try it on if you can";
        } else {
          response.tech_secondText =
            "Looks like your measurements fall into different size categories (as shown in the table below). Check the <b>detailed dress size chart</b> in the article to assess which size should fit you best.";

          response.tech_usBust = getUSSize(bust);
          response.tech_usWaist = getUSSize(waist);
          response.tech_usHips = getUSSize(hips);

          response.tech_ukBust = getUKSize(bust);
          response.tech_ukWaist = getUKSize(waist);
          response.tech_ukHips = getUKSize(hips);

          response.tech_euBust = bust;
          response.tech_euWaist = waist;
          response.tech_euHips = hips;

          response.tech_internationalBust = getInternationalSize(bust);
          response.tech_internationalWaist = getInternationalSize(waist);
          response.tech_internationalHips = getInternationalSize(hips);
        }
      }
    } else {
      response.error = "Please check your input.";
    }

    return response;
  }

  /**
   * getCalculationTinettiCalculator: Service Method
   * POST: /api/calculators-lol/tinetti-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTinettiCalculator(body) {
    let a1 = Number(body.tech_a1);
    let a2 = Number(body.tech_a2);
    let a3 = Number(body.tech_a3);
    let a4 = Number(body.tech_a4);
    let a5 = Number(body.tech_a5);
    let a6 = Number(body.tech_a6);
    let a7 = Number(body.tech_a7);
    let a8 = Number(body.tech_a8);
    let a9 = Number(body.tech_a9);
    let a10 = Number(body.tech_a10);

    let b1 = Number(body.tech_b1);
    let b2 = Number(body.tech_b2);
    let b3 = Number(body.tech_b3);
    let b4 = Number(body.tech_b4);
    let b5 = Number(body.tech_b5);
    let b6 = Number(body.tech_b6);
    let b7 = Number(body.tech_b7);
    let b8 = Number(body.tech_b8);
    let b9 = Number(body.tech_b9);
    let b10 = Number(body.tech_b10);

    let add1 = a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10;
    let add2 = b1 + b2 + b3 + b4 + b5 + b6 + b7 + b8 + b9 + b10;
    let add3 = add1 + add2;

    return {
      tech_add1: add1,
      tech_add2: add2,
      tech_add3: add3,
    };
  }

  /**
   * getCalculationDripRateCalculator: Service Method
   * POST: /api/calculators-lol/drip-rate-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDripRateCalculator(body) {
    let result = {};

    let v = Number(body.tech_v);
    let v_unit = body.tech_v_unit.replace("@", "");
    let t = Number(body.tech_t);
    let t_unit = body.tech_t_unit;
    let dp = Number(body.tech_dp);
    let dp_unit = body.tech_dp_unit.replace("@", "");
    let type = body.tech_type;

    let d = Number(body.tech_d);
    let d_unit = body.tech_d_unit;
    let bw = Number(body.tech_bw);
    let bw_unit = body.tech_bw_unit;
    let bv = Number(body.tech_bv);
    let bv_unit = body.tech_bv_unit;
    let drug = Number(body.tech_drug);
    let drug_unit = body.tech_drug_unit;

    // Volume units
    let v_units = {
      "mm³": 0.001,
      "cm³": 1,
      "dm³": 1000,
      ml: 1,
      cl: 10,
      l: 1000,
    };
    v_unit = v_units[v_unit] || 1;

    // Time units
    let t_units = {
      sec: 0.0166667,
      min: 1,
      hrs: 60,
    };
    t_unit = t_units[t_unit] || 1;

    // Dose units
    let d_units = {
      "mg/kg/min": 0.0166667,
      "mg/oz/min": 35.274,
      "mg/lb/min": 0.15747, // used only the last one from PHP (duplicate key bug in PHP code)
    };
    d_unit = d_units[d_unit] || 1;

    // Body weight units
    let bw_units = {
      kg: 1,
      oz: 0.02835,
      lbs: 0.4536,
      stone: 6.35,
    };
    bw_unit = bw_units[bw_unit] || 1;

    // Bag volume units
    let bv_units = {
      ml: 1,
      cl: 10,
      l: 1000,
    };
    bv_unit = bv_units[bv_unit] || 1;

    // Drug units
    let drug_units = {
      µg: 0.001,
      mg: 1,
      g: 1000,
    };
    drug_unit = drug_units[drug_unit] || 1;

    // Drip units
    let dp_units = {
      "gtts/mm³": 1000,
      "gtts/cm³": 1,
      "gtts/ml": 1,
    };
    dp_unit = dp_units[dp_unit] || 1;

    if (type === "first") {
      if (v > 0 && t > 0 && dp > 0) {
        let v_val = v * v_unit;
        let t_val = t * t_unit;
        let dp_val = dp * dp_unit;

        let dpm = (v_val * dp_val) / t_val;
        let dph = (v_val * dp_val) / (t_val / 60);
        let dr = dph / dp_val;

        result.tech_dpm = dpm;
        result.tech_dph = dph;
        result.tech_dr = dr;
      } else {
        return { error: "Please! Check Your Input." };
      }
    } else if (type === "second") {
      if (d > 0 && bw > 0 && bv > 0 && drug > 0 && dp > 0) {
        let d_val = d * d_unit;
        let bw_val = bw * bw_unit;
        let bv_val = bv * bv_unit;
        let drug_val = drug * drug_unit;
        let dp_val = dp * dp_unit;

        if (bw_val > 0 && bw_val < 300) {
          let dr =
            ((((60 * d_val) / 1000) * bw_val * bv_val) / (1000 * drug_val)) *
            1000000;
          let concentration = (drug_val / bv_val) * 1000;
          let time_to_bag = (d_val * bw_val * 60) / drug_val;
          let flow_rate = dr * dp_val;

          result.tech_concentration = concentration;
          result.tech_time_to_bag = time_to_bag;
          result.tech_flow_rate = flow_rate;
          result.tech_dr = dr;
        } else {
          return {
            error: "Body weight must be greater than 0 and less than 300 kg.",
          };
        }
      } else {
        return { error: "Please! Check Your Input." };
      }
    }

    result.tech_type = type;
    return result;
  }

  /**
   * getCalculationStepstoCaloriesCalculator: Service Method
   * POST: /api/calculators-lol/steps-to-calories-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationStepstoCaloriesCalculator(body) {
    let weight = body.tech_weight;
    let w_unit = body.tech_w_unit;
    let height_ft = body.tech_height_ft;
    let height_in = body.tech_height_in;
    let height_cm = body.tech_height_cm;
    let steps = body.tech_steps;
    let speed = body.tech_speed;
    let h_unit = body.tech_unit_ft_in;

    // Helper
    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }
    // Weight conversion
    if (w_unit === "kg") {
      w_unit = 1;
    } else if (w_unit === "lbs") {
      w_unit = 2;
    } else if (w_unit === "stone") {
      w_unit = 3;
    }

    function convertWeight(unit, value) {
      if (unit === 1) return value * 1;
      if (unit === 2) return value * 0.4536;
      if (unit === 3) return value * 6.35;
      return null;
    }

    weight = convertWeight(w_unit, weight);

    let convert_height;

    if (h_unit === "ft/in") {
      if (isNumeric(height_ft) || isNumeric(height_in)) {
        convert_height = height_ft * 12 + (height_in || 0);
      } else {
        return { error: "Please! Check your input." };
      }
    } else if (h_unit === "cm") {
      if (isNumeric(height_cm)) {
        convert_height = height_cm / 2.54;
      } else {
        return { error: "Please! Check your input." };
      }
    } else if (h_unit === "ft") {
      if (isNumeric(height_cm)) {
        convert_height = height_cm * 12;
      } else {
        return { error: "Please! Check your input." };
      }
    } else if (h_unit === "in") {
      if (isNumeric(height_cm)) {
        convert_height = height_cm * 1;
      } else {
        return { error: "Please! Check your input." };
      }
    } else if (h_unit === "m") {
      if (isNumeric(height_cm)) {
        convert_height = height_cm * 39.37;
      } else {
        return { error: "Please! Check your input." };
      }
    }

    if (isNumeric(weight) && isNumeric(steps)) {
      if (weight >= 15) {
        if (convert_height >= 50) {
          let text, sp;

          if (speed === 0.9) {
            text = "2 miles/hour (3.2 km/h)";
            sp = 2.8;
          } else if (speed === 1.34) {
            text = "3 miles/hour (4.8 km/h)";
            sp = 3.5;
          } else if (speed === 1.79) {
            text = "4 miles/hour (6.4 km/h)";
            sp = 5;
          } else {
            return { error: "Invalid speed value." };
          }

          const distance = steps / 2000;
          const waqat = distance / sp;
          let time = Math.round(waqat * 60);
          const cal_burn = time * 3.5 * sp * (weight / 200);
          const cal_per = cal_burn / steps;

          const main_text =
            `<p className="mt-1">Taking ${steps} steps at this pace taesk about ${time} minutes</p>` +
            `<p className="mt-1">In some cases, taking <b>the same amount of steps at a slower pace may burn more calories</b>. However, they will be burned over a longer period of time, and most of the calories burnt are just so the body can maintain itself <b>(basal metabolism), not from the exercise!</b></p>` +
            `<p><b>Example:</b> An average man, walking at a normal pace, will take 7,000 steps in 1 hour, and he will burn 260 kcal. For a person who walks slowly, taking the same amount of steps will take 1.5 hrs, and will burn approx. 300 kcal (however this person will be burning 200 kcal per hour).</p>`;

          return {
            tech_cal_burn: cal_burn,
            tech_cal_per: cal_per,
            tech_main_text: main_text,
            tech_text: text,
          };
        } else {
          return {
            error: "This calculator is intended for those 50 cm or taller.",
          };
        }
      } else {
        return {
          error: "This calculator is intended for those 15 kg or heavier.",
        };
      }
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /**
   * getCalculationCholesterolRatioCalculator: Service Method
   * POST: /api/calculators-lol/cholesterol-ratio-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCholesterolRatioCalculator(body) {
    let tc = body.tech_tc;
    let tc_unit = body.tech_tc_unit;
    let hc = body.tech_hc;
    let hc_unit = body.tech_hc_unit;
    let lc = body.tech_lc;
    let lc_unit = body.tech_lc_unit;
    let tr = body.tech_tr;
    let tr_unit = body.tech_tr_unit;
    let gender = body.tech_gender;

    let param = {};

    // Convert units to mg/dL
    tc_unit = tc_unit === "mmol/L" ? 38.67 : 1;
    hc_unit = hc_unit === "mmol/L" ? 38.67 : 1;
    lc_unit = lc_unit === "mmol/L" ? 38.67 : 1;
    tr_unit = tr_unit === "mmol/L" ? 88.57 : 1;

    // Ensure values are numbers
    tc = parseFloat(tc);
    hc = parseFloat(hc);
    lc = parseFloat(lc);
    tr = parseFloat(tr);

    let ans1, ans2, ans3, ans4, ans5, ans6;

    if (!isNaN(tc) && !isNaN(hc) && !isNaN(lc) && isNaN(tr)) {
      if (tc > 0 && hc > 0 && lc > 0) {
        tc *= tc_unit;
        hc *= hc_unit;
        lc *= lc_unit;
        ans1 = tc / hc;
        ans2 = lc / hc;
        ans3 = tc;
        ans4 = hc;
        ans5 = lc;
        ans6 = (tc - hc - lc) * 5;
      } else {
        param.error = "Please! Enter Positive Value.";
        return param;
      }
    } else if (!isNaN(tc) && !isNaN(hc) && !isNaN(tr) && isNaN(lc)) {
      if (tc > 0 && hc > 0 && tr > 0) {
        tc *= tc_unit;
        hc *= hc_unit;
        tr *= tr_unit;
        ans3 = tc;
        ans4 = hc;
        ans5 = tc - hc - 0.2 * tr;
        ans2 = ans5 / hc;
        ans1 = tc / hc;
        ans6 = tr;
      } else {
        param.error = "Please! Enter Positive Value.";
        return param;
      }
    } else if (!isNaN(hc) && !isNaN(lc) && !isNaN(tr) && isNaN(tc)) {
      if (hc > 0 && lc > 0 && tr > 0) {
        hc *= hc_unit;
        lc *= lc_unit;
        tr *= tr_unit;
        ans3 = hc + lc + 0.2 * tr;
        ans1 = ans3 / hc;
        ans2 = lc / hc;
        ans4 = hc;
        ans5 = lc;
        ans6 = tr;
      } else {
        param.error = "Please! Enter Positive Value.";
        return param;
      }
    } else if (!isNaN(tc) && !isNaN(lc) && !isNaN(tr) && isNaN(hc)) {
      if (tc > 0 && lc > 0 && tr > 0) {
        tc *= tc_unit;
        lc *= lc_unit;
        tr *= tr_unit;
        ans3 = tc;
        ans4 = tc - lc - 0.2 * tr;
        ans5 = lc;
        ans6 = tr;
        ans2 = lc / ans4;
        ans1 = tc / ans4;
      } else {
        param.error = "Please! Enter Positive Value.";
        return param;
      }
    } else {
      param.error = "Please! Enter Only Three Values or Check your input.";
      return param;
    }

    return {
      tech_ans1: ans1,
      tech_ans2: ans2,
      tech_ans3: ans3,
      tech_ans4: ans4,
      tech_ans5: ans5,
      tech_ans6: ans6,
      tech_gender: gender,
    };
  }

  /**
   * getCalculationParacetamolDosageCalculator: Service Method
   * POST: /api/calculators-lol/paracetamol-dosage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationParacetamolDosageCalculator(body) {
    let age = body.tech_age;
    let age_unit = body.tech_age_unit;
    let weight = body.tech_weight;
    let weight_unit = body.tech_weight_unit;
    let ss = body.tech_ss;
    let med_type = body.tech_med_type;
    let param = {};

    // Convert age_unit to years
    if (age_unit === "weeks") age_unit = 0.0191651;
    else if (age_unit === "months") age_unit = 0.08333;
    else if (age_unit === "years") age_unit = 1;

    // Convert weight_unit to kg
    if (weight_unit === "kg") weight_unit = 1;
    else if (weight_unit === "lbs") weight_unit = 0.453592;

    if (["1", "2", "3"].includes(med_type)) {
      if (!isNaN(weight)) {
        const weight_val = weight * weight_unit;
        let dose;

        if (["1", "2"].includes(med_type)) {
          if (weight_val >= 5 && weight_val <= 7) dose = 4;
          else if (weight_val >= 8 && weight_val < 10) dose = 5;
          else if (weight_val >= 11 && weight_val <= 14) dose = 6;
          else if (weight_val >= 15 && weight_val <= 19) dose = 9;
          else if (weight_val >= 20 && weight_val <= 24) dose = 12;
          else if (weight_val >= 25 && weight_val <= 29) dose = 15;
          else if (weight_val >= 30 && weight_val <= 34) dose = 18;
          else if (weight_val >= 35 && weight_val <= 39) dose = 21;
          else if (weight_val >= 40 && weight_val <= 44) dose = 25;
          else if (weight_val <= 0) {
            param.error = "Child weight should be a positive number.";
            return param;
          } else if (weight_val > 100) {
            param.error =
              "The maximum value for a child weight is 100 kg or 220 lb.";
            return param;
          }
        } else if (med_type === "3") {
          if (weight_val >= 35 && weight_val <= 49) dose = 1;
          else if (weight_val >= 50 && weight_val <= 64) dose = 1.5;
          else if (weight_val >= 65 && weight_val <= 100) dose = 2;
          else if (weight_val <= 0) {
            param.error = "Child weight should be a positive number.";
            return param;
          } else if (weight_val > 100) {
            param.error =
              "The maximum value for a child weight is 100 kg or 220 lb.";
            return param;
          }
        }

        if (age !== "") {
          if (!isNaN(age)) {
            const age_val = age * age_unit;
            if (med_type === "1") {
              if (age_val < 1) {
                param.error =
                  "Infant syrup is not suitable for children under the age of 2 months. Consult a doctor for individualised dosing scheme.";
                return param;
              } else if (age_val > 6) {
                param.error =
                  "For children older than 6 years, try <i>Six plus syrup</i>.";
                return param;
              }
            } else if (med_type === "2") {
              if (age_val < 6) {
                param.error =
                  "Six plus syrup is not suitable for children under the age of 6 years. Try Infant syrup.";
                return param;
              }
            } else if (med_type === "3") {
              if (age_val < 6) {
                param.error =
                  "Tablets not suitable for children under the age of 6 years. Try Infant syrup.";
                return param;
              }
            }
          } else {
            param.error = "Please! Check your input.";
            return param;
          }
        }

        if (["1", "2"].includes(med_type)) {
          if (
            (weight_val >= 45 && weight_val <= 100) ||
            (weight_val >= 1 && weight_val <= 4)
          ) {
            param.tech_line =
              "The form of medication is not suitable for chosen weight. Try a different type or consult a physician.";
          } else {
            param.tech_dose = med_type === "1" ? dose : dose / 2;
          }
        } else if (med_type === "3") {
          if (weight_val <= 34) {
            param.tech_line =
              "The form of medication is not suitable for chosen weight. Try a different type or consult a physician.";
          } else {
            param.tech_dose = dose;
          }
        }

        const fifteen = weight_val * 15;
        const sixty = weight_val * 60;

        param.tech_fifteen = fifteen > 1000 ? 1000 : fifteen;
        param.tech_sixty = sixty > 4000 ? 4000 : sixty;
      } else {
        param.error = "Please! Check your input.";
        return param;
      }
    } else if (med_type === "4") {
      if (!isNaN(weight) && !isNaN(ss)) {
        const weight_val = weight * weight_unit;

        if (weight <= 0) {
          param.error = "Child weight should be a positive number.";
          return param;
        } else if (weight > 100) {
          param.error =
            "The maximum value for a child weight is 100 kg or 220 lb.";
          return param;
        }

        if (ss < 0) {
          param.error = "Solution strength should be a positive number.";
          return param;
        } else {
          if (age !== "") {
            if (age < 0) {
              param.error =
                "The Infant/Child Age should be a whole (integer) number!";
              return param;
            } else if (age >= 18) {
              param.error =
                "Please note the infant/child age you specified is over 18 years. This calculator is suitable for infant/child age below 18 years of age.";
              return param;
            } else {
              param.tech_fifteen = weight_val * 15;
              param.tech_sixty = weight_val * 60;
              param.tech_solution_amount = param.tech_fifteen / ss;
            }
          }
        }
      } else {
        param.error = "Please! Check your input.";
        return param;
      }
    }

    param.tech_med_type = med_type;
    return param;
  }

  /**
   * getCalculationAmoxicillinPediatricDosageCalculator: Service Method
   * POST: /api/calculators-lol/amoxicillin-pediatric-dosage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAmoxicillinPediatricDosageCalculator(body) {
    let age = body.tech_age;
    let age_unit = body.tech_age_unit;
    let weight = body.tech_weight;
    let weight_unit = body.tech_weight_unit;
    let med_type = body.tech_med_type;
    let general_dosing = body.tech_general_dosing;
    let route = body.tech_route;
    let dosag = body.tech_dosag;

    let param = {};

    // Age unit conversion
    let ageConversion;
    if (age_unit === "Weeks") {
      ageConversion = 0.019165;
    } else if (age_unit === "Months") {
      ageConversion = 0.08333;
    } else if (age_unit === "Years") {
      ageConversion = 1;
    }

    // Weight unit conversion
    let weightConversion;
    if (weight_unit === "kg") {
      weightConversion = 1;
    } else if (weight_unit === "lbs") {
      weightConversion = 0.453592;
    } else if (weight_unit === "stone") {
      weightConversion = 6.35;
    }

    if (isNaN(weight)) {
      param.error = "Please! Check your input.";
      return param;
    }
    let weightVal = weight * weightConversion;

    // Age check
    if (age !== "") {
      if (isNaN(age)) {
        param.error = "Please! Check your input.";
        return param;
      }
      let ageVal = age * ageConversion;
      if (ageVal <= 0 || ageVal > 18) {
        param.error = "Please Enter Age Between 1 and 18.";
        return param;
      }
    }

    // Weight check
    if (weight <= 0) {
      param.error = "Weight must be greater than 0.";
      return param;
    } else if (weight >= 100) {
      param.error = "Weight cannot exceed 100 kg (220 lb).";
      return param;
    }

    let inMm, inMilli;

    // General dosing calculations
    if (general_dosing === "1") {
      let inMmValue = weightVal * 15;
      if (med_type === "1") {
        inMilli = inMmValue / 25;
      } else if (med_type === "2") {
        inMilli = inMmValue / 50;
      } else if (med_type === "3") {
        inMilli = inMmValue / 40;
      } else if (med_type === "4") {
        inMilli = inMmValue / 80;
      }
      if (route === "1") {
        inMm = inMmValue;
        inMilli = inMilli;
      } else if (route === "2") {
        inMm = inMmValue * 2;
        inMilli = inMilli * 2;
      }
    } else if (general_dosing === "2") {
      let inMmValue =
        weightVal < 15
          ? weightVal * 50
          : weight < 30
          ? 750
          : weight < 100
          ? 1000
          : 0;
      inMilli = inMmValue / 25;
      if (med_type === "2") {
        inMilli = inMmValue / 50;
      } else if (med_type === "3") {
        inMilli = inMmValue / 40;
      } else if (med_type === "4") {
        inMilli = inMmValue / 80;
      }
    } else if (general_dosing === "3") {
      let inMmValue = weightVal * 50;
      if (med_type === "1") {
        inMilli = inMmValue / 25;
      } else if (med_type === "2") {
        inMilli = inMmValue / 50;
      } else if (med_type === "3") {
        inMilli = inMmValue / 40;
      } else if (med_type === "4") {
        inMilli = inMmValue / 80;
      }
    }

    param.tech_in_mm = inMm;
    param.tech_in_milli = inMilli;
    param.tech_general_dosing = general_dosing;
    param.tech_route = route;
    param.tech_dosag = dosag;
    param.tech_w_val = weightVal;

    return param;
  }

  /**
   * getCalculationHarrisBenedictCalculator: Service Method
   * POST: /api/calculators-lol/harris-benedict-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationHarrisBenedictCalculator(body) {
    let age = body.tech_age;
    let weight = body.tech_weight;
    let height_ft = body.tech_height_ft;
    let height_in = body.tech_height_in;
    let height_cm = body.tech_height_cm;
    let unit = body.tech_unit;
    let gender = body.tech_gender;
    let activity = body.tech_activity;
    let unit_h = body.tech_unit_ft_in;

    if (
      isFinite(age) &&
      isFinite(weight) &&
      (isFinite(height_ft) || isFinite(height_in) || isFinite(height_cm))
    ) {
      // Weight Conversion
      if (unit === "lbs") {
        weight = weight / 2.205;
      } else if (unit === "stone") {
        weight = weight * 6.35;
      } else if (unit === "kg") {
        weight = weight * 1;
      }

      // Height Conversion
      if (unit_h === "ft/in") {
        height_cm = height_ft * 30.48;
        if (height_in != null) {
          height_cm += height_in * 2.54;
        }
      } else if (unit_h === "ft") {
        height_cm = height_cm * 30.48;
      } else if (unit_h === "in") {
        height_cm = height_cm * 2.54;
      } else if (unit_h === "cm") {
        height_cm = height_cm * 1;
      } else if (unit_h === "m") {
        height_cm = height_cm * 100;
      }

      let bmr_ans;
      if (gender === "female") {
        bmr_ans = Math.round(
          665.1 + 9.563 * weight + 1.85 * height_cm - 4.676 * age
        );
      } else {
        bmr_ans = Math.round(
          66.5 + 13.75 * weight + 5.003 * height_cm - 6.75 * age
        );
      }

      const pro = 15;
      const fats = 30;
      const carb = 55;

      const tee = activity * bmr_ans;
      const cal_gram = tee * 0.129598;

      const pro_gram_ans = Math.round(((pro / 100) * tee) / 4);
      const carb_gram_ans = Math.round(((carb / 100) * tee) / 4);
      const fats_gram_ans = Math.round(((fats / 100) * tee) / 4);

      const sum = pro_gram_ans + carb_gram_ans + fats_gram_ans;

      const pro_per = Math.round((pro_gram_ans / sum) * 100);
      const carb_per = Math.round((carb_gram_ans / sum) * 100);
      const fats_per = Math.round((fats_gram_ans / sum) * 100);

      return {
        tech_bmr_ans: bmr_ans,
        tech_tee: tee,
        tech_pro_gram_ans: pro_gram_ans,
        tech_carb_gram_ans: carb_gram_ans,
        tech_fats_gram_ans: fats_gram_ans,
        tech_pro_per: pro_per,
        tech_carb_per: carb_per,
        tech_fats_per: fats_per,
      };
    } else {
      return {
        error: "Please! Check your input.",
      };
    }
  }

  /**
   * getCalculationCaloriesBurnedBikingCalculator: Service Method
   * POST: /api/calculators-lol/calories-burned-biking-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCaloriesBurnedBikingCalculator(body) {
    let operations = body.tech_operations;
    let activity = body.tech_activity;
    let first = body.tech_first;
    let units1 = body.tech_units1;
    let second = body.tech_second;
    let units2 = body.tech_units2;
    let third = body.tech_third;
    let units3 = body.tech_units3;
    let met = body.tech_met;
    let height_ft = body.tech_height_ft;
    let height_in = body.tech_height_in;
    let height_cm = body.tech_height_cm;
    let unit_ft_in = body.tech_unit_ft_in;
    let gender = body.tech_gender;
    let age = body.tech_age;

    // Unit conversion: Power
    const power = (unit, value) => {
      switch (unit) {
        case "mW":
          return value / 1000;
        case "W":
          return value;
        case "kW":
          return value * 1000;
        case "BTU/h":
          return value * 0.2931;
        case "hp(l)":
          return value * 745.7;
        case "kcal/min":
          return value * 69.73;
        case "kcal/h":
          return value * 1.1622;
        default:
          return null;
      }
    };

    // Unit conversion: Weight
    const weight = (unit, value) => {
      switch (unit) {
        case "lbs":
          return value / 2.205;
        case "kg":
          return value;
        case "stone":
          return value * 6.35;
        default:
          return null;
      }
    };

    // Unit conversion: Time
    const time2 = (unit, value) => {
      switch (unit) {
        case "sec":
          return value / 3600;
        case "min":
          return value / 60;
        case "hrs":
          return value;
        case "days":
          return value * 16;
        default:
          return null;
      }
    };

    first = power(units1, first);
    second = weight(units2, second);
    third = time2(units3, third);

    if (isNaN(second) || (!height_ft && !height_in && !height_cm)) {
      return { error: "Please! Check your input." };
    }

    // Convert height to cm
    if (unit_ft_in === "ft/in") {
      height_cm = height_ft * 30.48;
      if (height_in) {
        height_cm += height_in * 2.54;
      }
    } else if (unit_ft_in === "ft") {
      height_cm *= 30.48;
    } else if (unit_ft_in === "in") {
      height_cm *= 2.54;
    } else if (unit_ft_in === "m") {
      height_cm *= 100;
    } else if (unit_ft_in === "cm") {
      height_cm = height_cm;
    }

    // BMR Calculation
    let bmr_ans;
    if (gender === "female") {
      bmr_ans = Math.round(
        665.1 + 9.563 * second + 1.85 * height_cm - 4.676 * age
      );
    } else {
      bmr_ans = Math.round(
        66.5 + 13.75 * second + 5.003 * height_cm - 6.75 * age
      );
    }

    let calories, w_loss;

    if (operations === "Yes") {
      if (!isNaN(first) && !isNaN(third)) {
        calories = (first * third) / 4.18 / 0.24;
        w_loss = calories / 7700;
      } else {
        return { error: "Please! Check your input." };
      }
    } else if (operations === "No") {
      if (!isNaN(second) && !isNaN(met) && !isNaN(third)) {
        calories = (third * 60 * met * 3.5 * second) / 200;
        w_loss = calories / 7700;
      } else {
        return { error: "Please! Check your input." };
      }
    }

    const exercise = met * third;

    return {
      tech_bmr_ans: bmr_ans,
      tech_calories: calories,
      tech_w_loss: w_loss,
      tech_exercise: exercise,
    };
  }

  /**
   * getCalculationTreadmillCalorieCalculator: Service Method
   * POST: /api/calculators-lol/treadmill-calorie-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTreadmillCalorieCalculator(body) {
    let gradient = body.tech_gradient;
    let weight = body.tech_weight;
    let weight_unit = body.tech_weight_unit;
    let speed = body.tech_speed;
    let speed_unit = body.tech_speed_unit;
    let distance = body.tech_distance;
    let distance_unit = body.tech_distance_unit;
    let time = body.tech_time;

    let result = {};

    if (gradient < -0.001) {
      result.error = "Please input the gradient above 0.";
      return result;
    }
    if (speed < 0) {
      result.error = "Please input the speed above 0.";
      return result;
    }
    if (time < 0) {
      result.error = "Please input the running-time(min) above 0.";
      return result;
    }
    if (distance < 0) {
      result.error = "Please input the running-distance(Mile/Km) above 0.";
      return result;
    }
    if (weight < 0) {
      result.error = "Please input the weight(lbs/Kg) above 0.";
      return result;
    }

    if (
      typeof speed === "number" &&
      typeof distance === "number" &&
      typeof time === "number"
    ) {
      result.error =
        "Speed, Time, and the Distance cannot be specified at the same time.";
      return result;
    }

    if (
      (!speed && !distance && !time) ||
      (!distance && !time) ||
      (!speed && !time) ||
      (!distance && !speed)
    ) {
      result.error = "Please! Check your Input.";
      return result;
    }

    if (typeof gradient === "number" && typeof weight === "number") {
      let speed_mph, speed_kmh, distance_m, distance_km, time_ans;

      if (typeof speed === "number" && typeof distance === "number") {
        if (speed_unit === "km/h" || distance_unit === "km") {
          speed_mph = speed / 1.609;
          distance_m = distance / 1.609;
          speed_kmh = speed;
          distance_km = distance;
        } else {
          speed_kmh = speed * 1.609;
          distance_km = distance * 1.609;
          speed_mph = speed;
          distance_m = distance;
        }
        time_ans = (distance_m / speed_mph) * 60;
      } else if (typeof speed === "number" && typeof time === "number") {
        if (speed_unit === "km/h") {
          speed_mph = speed / 1.609;
          speed_kmh = speed;
        } else {
          speed_kmh = speed * 1.609;
          speed_mph = speed;
        }
        time_ans = time / 60;
        distance_m = speed_mph * time_ans;
        distance_km = distance_m * 1.609;
      } else if (typeof distance === "number" && typeof time === "number") {
        if (distance_unit === "km") {
          distance_m = distance / 1.609;
          distance_km = distance;
        } else {
          distance_km = distance * 1.609;
          distance_m = distance;
        }
        time_ans = time / 60;
        speed_mph = distance_m / time_ans;
        speed_kmh = speed_mph * 1.609;
      }

      let weight_kg = weight_unit === "lbs" ? weight / 2.205 : weight;
      let speed_mph_sec = speed_mph + (speed_mph * gradient * 9) / 200;
      let speed_kmh_sec = speed_kmh + (speed_kmh * gradient * 9) / 200;
      let distance_m_sec = (speed_mph_sec * time_ans) / 60;
      let distance_km_sec = (speed_kmh_sec * time_ans) / 60;
      let y0 = speed_kmh + (speed_kmh * gradient * 9) / 200;

      let cal = (((y0 * 1000) / 60 + 17.5) * time_ans * weight_kg) / 1000;
      let fat = cal / 7 / 2;
      let fatoz_ans = fat / 28.3495;
      let fatg_ans = fat;
      let mets = (cal / weight_kg / time_ans) * 60;
      let energy_kj = 4.184 * cal;
      let energy_kw_ans = energy_kj / 3600;
      let electric_heater_ans = 60 * energy_kw_ans;
      let light_bulb_ans = (electric_heater_ans * 10) / 60;
      let cburger_ans = cal / 310;
      let beer2_ans = cal / 153.1;
      let cleanning_ans = (cal / 1.59 / weight) * 60;
      let shop_ans = cal / 2.5;

      let meter_dash_ans = 360 / y0;
      let meter_run_h_ans = Math.floor(600 / y0);
      let meter_run_m_ans = (600 / y0 - meter_run_h_ans) * 60;

      let half_marathon = (21.095 * 60) / y0;
      let half_marathonh = Math.floor(half_marathon / 60);
      let half_marathonm = Math.floor(half_marathon - half_marathonh * 60);
      let half_marathons =
        (half_marathon - half_marathonh * 60 - half_marathonm) * 60;

      let marathon = (42.195 * 60) / y0;
      let marathonh = Math.floor(marathon / 60);
      let marathonm = Math.floor(marathon - marathonh * 60);
      let marathons = (marathon - marathonh * 60 - marathonm) * 60;
      let myrecord = marathon / 60;
      let record_ans = (2.0275 / myrecord) * 100;

      result = {
        tech_speed_mph: Number(speed_mph.toFixed(1)),
        tech_speed_kmh: Number(speed_kmh.toFixed(1)),
        tech_time_ans: Number(time_ans.toFixed(1)),
        tech_distance_m: Number(distance_m.toFixed(1)),
        tech_distance_km: Number(distance_km.toFixed(1)),
        tech_speed_mph_sec: Number(speed_mph_sec.toFixed(1)),
        tech_speed_kmh_sec: Number(speed_kmh_sec.toFixed(1)),
        tech_distance_m_sec: Number(distance_m_sec.toFixed(1)),
        tech_distance_km_sec: Number(distance_km_sec.toFixed(1)),
        tech_cal: Number(cal.toFixed(1)),
        tech_fatoz_ans: Number(fatoz_ans.toFixed(1)),
        tech_fatg_ans: Number(fatg_ans.toFixed(1)),
        tech_mets: Number(mets.toFixed(1)),
        tech_energy_kw_ans: Number(energy_kw_ans.toFixed(1)),
        tech_electric_heater_ans: Number(electric_heater_ans.toFixed(1)),
        tech_light_bulb_ans: Number(light_bulb_ans.toFixed(1)),
        tech_cburger_ans: Number(cburger_ans.toFixed(1)),
        tech_beer2_ans: Number(beer2_ans.toFixed(1)),
        tech_shop_ans: Number(shop_ans.toFixed(1)),
        tech_cleanning_ans: Number(cleanning_ans.toFixed(1)),
        tech_meter_dash_ans: Number(meter_dash_ans.toFixed(1)),
        tech_meter_run_h_ans: Number(meter_run_h_ans.toFixed(1)),
        tech_meter_run_m_ans: Number(meter_run_m_ans.toFixed(1)),
        tech_half_marathonh: Number(half_marathonh.toFixed(1)),
        tech_half_marathonm: Number(half_marathonm.toFixed(1)),
        tech_half_marathons: Number(half_marathons.toFixed(1)),
        tech_marathonh: Number(marathonh.toFixed(1)),
        tech_marathonm: Number(marathonm.toFixed(1)),
        tech_marathons: Number(marathons.toFixed(1)),
        tech_record_ans: Number(record_ans.toFixed(1)),
        tech_gradient: gradient,
      };
      return result;
    } else {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /**
   * getCalculationWalkingCalorieCalculator: Service Method
   * POST: /api/calculators-lol/walking-calorie-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationWalkingCalorieCalculator(body) {
    let unit_type = body.tech_unit_type?.trim();
    let age = parseFloat(body.tech_age);
    let gender = body.tech_gender?.trim();
    let height = parseFloat(body.tech_height);
    let inches = parseFloat(body.tech_inches);
    let weight = parseFloat(body.tech_weight);
    let speed_unit = body.tech_speed_unit?.trim();
    let mets = parseFloat(body.tech_mets);
    let duration = parseFloat(body.tech_duration);

    let result = {};
    // Helper functions
    function getSpeedKmh(speed_unit) {
      switch (speed_unit) {
        case "less than 2.0mph (3.2km/h)":
        case "2.0mph (3.2km/h)":
          return 3.2;
        case "2.5mph (4.0km/h)":
          return 4.0;
        case "3.0mph (4.8km/h)":
          return 4.8;
        case "3.5mph (5.6km/h)":
          return 5.6;
        case "4.0mph (6.4km/h)":
          return 6.4;
        case "4.5mph (7.2km/h)":
          return 7.2;
        default:
          return 8.0;
      }
    }

    function getSpeedMph(speed_unit) {
      switch (speed_unit) {
        case "less than 2.0mph (3.2km/h)":
        case "2.0mph (3.2km/h)":
          return 2.0;
        case "2.5mph (4.0km/h)":
          return 2.5;
        case "3.0mph (4.8km/h)":
          return 3.0;
        case "3.5mph (5.6km/h)":
          return 3.5;
        case "4.0mph (6.4km/h)":
          return 4.0;
        case "4.5mph (7.2km/h)":
          return 4.5;
        default:
          return 5.0;
      }
    }
    if (unit_type === "sl") {
      if (
        isFinite(age) &&
        isFinite(height) &&
        isFinite(weight) &&
        isFinite(mets) &&
        isFinite(duration)
      ) {
        let male_calories;
        if (gender === "male") {
          male_calories =
            88.362 + 13.397 * weight + 4.799 * height - 5.677 * age;
        } else {
          male_calories =
            447.593 + 9.247 * weight + 3.098 * height - 4.33 * age;
        }

        let exercise = (duration * mets) / 60;
        let hour_duration = duration / 60;

        let speed_kmh = getSpeedKmh(speed_unit);
        let speed_mph = getSpeedMph(speed_unit);

        let hour_duration_min = hour_duration * speed_kmh;
        let hour_mile = hour_duration * speed_mph;

        let burned = Math.round((male_calories * mets * hour_duration) / 24);

        result = {
          tech_male_calories: male_calories,
          tech_exercise: exercise,
          tech_hour_duration_min: hour_duration_min,
          tech_hour_mile: hour_mile,
          tech_burned: burned,
        };
      } else {
        result = { error: "Please! Check Your Input." };
      }
    } else {
      if (
        isFinite(age) &&
        isFinite(height) &&
        isFinite(weight) &&
        isFinite(mets) &&
        isFinite(duration) &&
        isFinite(inches)
      ) {
        let heig_ft = height * 30.48;
        let heig_in = inches * 2.54;
        height = heig_ft + heig_in;
        weight = weight / 2.205;

        let male_calories;
        if (gender === "male") {
          male_calories =
            88.362 + 13.397 * weight + 4.799 * height - 5.677 * age;
        } else {
          male_calories =
            447.593 + 9.247 * weight + 3.098 * height - 4.33 * age;
        }

        let exercise = (duration * mets) / 60;
        let hour_duration = duration / 60;

        let speed_kmh = getSpeedKmh(speed_unit);
        let speed_mph = getSpeedMph(speed_unit);

        let hour_duration_min = hour_duration * speed_kmh;
        let hour_mile = hour_duration * speed_mph;

        let burned = Math.round((male_calories * mets * hour_duration) / 24);

        result = {
          tech_male_calories: male_calories,
          tech_exercise: exercise,
          tech_hour_duration_min: hour_duration_min,
          tech_hour_mile: hour_mile,
          tech_burned: burned,
        };
      } else {
        result = { error: "Please! Check Your Input." };
      }
    }

    return result;
  }

  /**
   * getCalculationEllipticalCalorieCalculator: Service Method
   * POST: /api/calculators-lol/elliptical-calorie-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationEllipticalCalorieCalculator(body) {
    let weight = String(body.tech_weight).trim();
    let weightUnit = String(body.tech_weight_unit).trim();
    let time = String(body.tech_time).trim();
    let hour = String(body.tech_hour).trim();
    let min = String(body.tech_min).trim();
    let timeUnit = String(body.tech_unit_hrs_min).trim();
    let effort = String(body.tech_effort).trim();
    let effortUnit = String(body.tech_effort_unit).trim();

    const response = {};

    if ((!hour || hour === "0") && (!min || min === "0")) {
      response.error = "Please! Check Your Input.";
      return response;
    }

    hour = hour ? parseFloat(hour) : 0;
    min = min ? parseFloat(min) : 0;

    if (weightUnit === "kg") {
      weight = parseFloat(weight);
    } else if (weightUnit === "lbs") {
      weight = parseFloat(weight) * 2.205;
    } else if (weightUnit === "stone") {
      weight = parseFloat(weight) / 6.35;
    }

    if (timeUnit === "sec") {
      time = parseFloat(time);
    } else if (timeUnit === "min") {
      time = parseFloat(time) * 60;
    } else if (timeUnit === "hrs") {
      time = parseFloat(time) * 3600;
    } else if (timeUnit === "hrs/min") {
      time = hour * 3600 + min * 60;
    }

    if (effortUnit === "Light (MET = 4.6)") {
      effort = 4.6;
    } else if (effortUnit === "Moderate (MET = 4.9)") {
      effort = 4.9;
    } else if (effortUnit === "Vigorous (MET = 5.7)") {
      effort = 5.7;
    } else if (effortUnit === "Custom (enter MET value)") {
      effort = parseFloat(effort);
    }

    if (isFinite(weight) && isFinite(time) && isFinite(effort)) {
      const answer = (time * effort * 3.5 * weight) / (200 * 60);
      const subAnswer = (60 * effort * 3.5 * weight) / 200;

      response.tech_weight = weight;
      response.tech_time = time;
      response.tech_answer = answer;
      response.tech_sub_answer = subAnswer;
      return response;
    } else {
      response.error = "Please! Check Your Input.";
      return response;
    }
  }

  /**
   * getCalculationBulkingCalculator: Service Method
   * POST: /api/calculators-lol/bulking-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBulkingCalculator(body) {
    let age = Number(body.tech_age);
    let heightFt = Number(body.tech_height_ft);
    let heightCm = Number(body.tech_height_cm);
    let weight = Number(body.tech_weight);
    let perCal = Number(body.tech_per_cal);
    let gender = String(body.tech_gender);
    let percent = Number(body.tech_percent);
    let activity = String(body.tech_activity);
    let stype = String(body.tech_stype);
    let start = String(body.tech_start);
    let target = String(body.tech_target);
    let weight1 = Number(body.tech_weight1);
    let surplus = String(body.tech_surplus);
    let kalDay = Number(body.tech_kal_day);
    let submit = String(body.tech_unit_type);

    const response = {};
    const want = "2";

    if (
      !isFinite(age) ||
      !isFinite(weight) ||
      !isFinite(weight1) ||
      !start ||
      !target
    ) {
      response.error = "Please fill All Fields.";
      return response;
    }

    let heightIn, unit;
    if (submit === "imperial") {
      heightIn = heightFt * 2.54;
      weight = weight / 2.205;
      weight1 = weight1 / 2.205;
      unit = "lbs";
    } else {
      if (isFinite(heightCm)) {
        heightIn = heightCm;
        unit = "kg";
      } else {
        response.error = "Please enter height.";
        return response;
      }
    }

    let BMR, Robinson, Miller, Devine, Hamwi, tdee;
    if (gender === "Male") {
      BMR = Math.round(
        10 * Math.round(weight) + 6.25 * Math.round(heightCm) - 5 * age + 5
      );
      if (activity === "sedentary") tdee = Math.round(BMR * 1.1);
      else if (activity === "Lightly_Active") tdee = Math.round(BMR * 1.2);
      else if (activity === "Moderately_Active") tdee = Math.round(BMR * 1.4);
      else if (activity === "Very_Active") tdee = Math.round(BMR * 1.6);
      else tdee = Math.round(BMR * 1.8);

      Robinson = Math.round(49 + 1.7 * (heightIn - 60));
      Miller = Math.round(53.1 + 1.36 * (heightIn - 60));
      Devine = Math.round(45.5 + 2.3 * (heightIn - 60));
      Hamwi = Math.round(45 + 2.2 * (heightIn - 60));
    } else {
      BMR = Math.round(10 * weight + 6.25 * heightCm - 5 * age - 161);
      if (activity === "sedentary") tdee = Math.round(BMR * 1.1);
      else if (activity === "Lightly_Active") tdee = Math.round(BMR * 1.2);
      else if (activity === "Moderately_Active") tdee = Math.round(BMR * 1.4);
      else if (activity === "Very_Active") tdee = Math.round(BMR * 1.6);
      else tdee = Math.round(BMR * 1.8);

      Robinson = Math.round(52 + 1.9 * (heightIn - 60));
      Miller = Math.round(56.2 + 1.41 * (heightIn - 60));
      Devine = Math.round(50 + 2.3 * (heightIn - 60));
      Hamwi = Math.round(48 + 2.7 * (heightIn - 60));
    }

    if (percent) {
      const lbm = (weight * (100 - percent)) / 100;
      BMR = Math.round(370 + 21.6 * lbm);
    }

    const heightM = heightIn / 39.37;
    const BMI = Math.round((weight / (heightM * heightM)) * 100) / 100;

    let youAre = "";
    if (BMI <= 18.5) youAre = "Underweight";
    else if (BMI > 18.5 && BMI <= 24.9) youAre = "Normal Weight";
    else if (BMI > 24.9 && BMI <= 29.9) youAre = "Overweight";
    else if (BMI > 29.9 && BMI <= 35) youAre = "Obesity";
    else youAre = "Severe Obesity";

    const ibw =
      submit === "imperial"
        ? `${Math.round(Robinson * 2.205)}-${Math.round(Hamwi * 2.205)} lbs`
        : `${Robinson}-${Hamwi} kg`;

    const startDate = DateTime.fromISO(start);
    const targetDate = DateTime.fromISO(target);

    if (!startDate.isValid || !targetDate.isValid) {
      response.error = "Please Enter Start and Target Date.";
      return response;
    }

    if (startDate >= targetDate) {
      response.error = "Target Date must be later than start date.";
      return response;
    }

    const days = targetDate.diff(startDate, "days").days;
    const poundsDaily = Math.round((weight1 / days) * 100) / 100;
    const highRiskWeight = poundsDaily > 0.3;

    let caloriesGain;
    if (surplus === "custom") {
      if (stype === "Incal") {
        caloriesGain = kalDay;
      } else {
        caloriesGain = tdee * (perCal / 100);
      }
    } else {
      if (surplus === "0.10") caloriesGain = tdee * 0.1;
      else if (surplus === "0.15") caloriesGain = tdee * 0.15;
      else caloriesGain = tdee * 0.2;
    }

    const caloriesDaily = Math.round(tdee + caloriesGain);
    const highRiskCalories = caloriesDaily < 1200;

    const goal =
      submit === "imperial"
        ? Math.round(weight + weight1)
        : Math.round(((weight + weight1) / 2.205) * 100) / 100;

    const fat = Math.round((caloriesDaily / 9) * 0.2);
    const protein = Math.round((caloriesDaily / 4) * 0.3);
    const carbs = Math.round((caloriesDaily / 4) * 0.5);

    return {
      tech_HighRiskWeight: highRiskWeight,
      tech_PoundsDaily: poundsDaily,
      tech_HighRiskCalories: highRiskCalories,
      tech_CaloriesDaily: caloriesDaily,
      tech_CaloriesLess: Math.round(caloriesGain),
      tech_Calories: tdee,
      tech_Goal: goal,
      tech_days: days,
      tech_BMR: BMR,
      tech_BMI: BMI,
      tech_you_are: youAre,
      tech_lbm: percent
        ? Math.round((weight * (100 - percent)) / 100)
        : undefined,
      tech_ibw: ibw,
      tech_fat: fat,
      tech_po: protein,
      tech_cb: carbs,
      tech_want: want,
      tech_unit: unit,
    };
  }

  /**
   * getCalculationFoodCostCalculator: Service Method
   * POST: /api/calculators-lol/food-cost-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationFoodCostCalculator(body) {
    let food_type = body.tech_food_type;
    let menu = body.tech_menu;
    let measure_unit = body.tech_measure_unit;
    let units_case = body.tech_units_case;
    let cost_unit = body.tech_cost_unit;
    let serving_size = body.tech_serving_size;
    let other = body.tech_other;
    let menu_price = body.tech_menu_price;

    let response = {};

    // Convert to numbers
    menu = Number(menu);
    units_case = Number(units_case);
    cost_unit = Number(cost_unit);
    serving_size = Number(serving_size);
    other = Number(other);
    menu_price = Number(menu_price);

    if (
      isNaN(menu) ||
      isNaN(units_case) ||
      isNaN(cost_unit) ||
      isNaN(serving_size) ||
      isNaN(other) ||
      isNaN(menu_price)
    ) {
      response.error = "Please! Check Your Input.";
      return response;
    }

    let costPerUnit;
    if (food_type === "food_piece") {
      costPerUnit = cost_unit;
    } else {
      if (units_case > 0 && cost_unit > 0) {
        costPerUnit = Math.round((cost_unit / units_case) * 100) / 100;
      } else {
        response.error = "Please! Check Your Input.";
        return response;
      }
    }

    let costPerServing;
    if (serving_size > 0) {
      costPerServing = Math.round(serving_size * costPerUnit * 100) / 100;
    } else {
      response.error = "Serving Size Cannot be Less Than Zero.";
      return response;
    }

    let costPerPlate = costPerServing + other;

    let contributionPerPlate;
    let food_cost;
    if (menu_price > 0) {
      contributionPerPlate = menu_price - costPerPlate;
      food_cost = Math.round((costPerPlate / menu_price) * 100);
    } else {
      response.error = "Please! Check Your Input.";
      return response;
    }

    let profitPerCase;
    if (units_case > 0 && serving_size > 0) {
      let servingsPerCase = units_case / serving_size;
      profitPerCase = contributionPerPlate * servingsPerCase;
    } else {
      response.error = "Please! Check Your Input.";
      return response;
    }

    response.tech_costPerUnit = costPerUnit;
    response.tech_costPerServing = costPerServing;
    response.tech_costPerPlate = costPerPlate;
    response.tech_contributionPerPlate = contributionPerPlate;
    response.tech_food_cost = food_cost;
    response.tech_profitPerCase = profitPerCase;

    return response;
  }

  /**
   * getCalculationStepsToMilesCalculator: Service Method
   * POST: /api/calculators-lol/steps-to-miles-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationStepsToMilesCalculator(body) {
    let methods = body.tech_methods;
    let sex = body.tech_sex;
    let first = body.tech_first;
    let unit = body.tech_unit;
    let steps = body.tech_steps;

    let response = {};

    // Convert numeric inputs
    first = Number(first);
    steps = Number(steps);

    // Normalize unit to numeric code
    if (unit === "cm") {
      unit = "1";
    } else if (unit === "dm") {
      unit = "2";
    } else if (unit === "m") {
      unit = "3";
    } else if (unit === "in") {
      unit = "4";
    } else if (unit === "ft") {
      unit = "5";
    } else if (unit === "mi") {
      unit = "6";
    }

    // Height conversion helper
    function height(a, b) {
      if (a === "1") {
        return b / 30.48;
      } else if (a === "2") {
        return b / 3.048;
      } else if (a === "3") {
        return b * 3.281;
      } else if (a === "4") {
        return b / 12;
      } else if (a === "5") {
        return b;
      } else if (a === "6") {
        return b * 5280;
      }
      return b;
    }

    first = height(unit, first);

    let answer;

    if (methods === "1") {
      if (!isNaN(steps)) {
        if (sex === "1") {
          answer = steps * 0.0004735;
        } else if (sex === "2") {
          answer = steps * 0.0004167;
        }
      } else {
        response.error = "Please! Check your input.";
        return response;
      }
    } else if (methods === "2") {
      if (!isNaN(first) && !isNaN(steps)) {
        if (sex === "1") {
          answer = steps * 0.0004735;
        } else if (sex === "2") {
          answer = steps * 0.0004167;
        }
      } else {
        response.error = "Please! Check your input.";
        return response;
      }
    } else if (methods === "3") {
      if (!isNaN(first) && !isNaN(steps)) {
        answer = (steps * first) / 5280;
      } else {
        response.error = "Please! Check your input.";
        return response;
      }
    } else {
      response.error = "Invalid method selected.";
      return response;
    }

    response.tech_answer = answer;
    return response;
  }

  /**
   * getCalculationFatBurningHeartCalculator: Service Method
   * POST: /api/calculators-lol/fat-burning-heart-rate
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationFatBurningHeartCalculator(body) {
    let age = body.tech_age;
    let gender = body.tech_gender;
    let RHR = body.tech_RHR;

    let response = {};
    age = Number(age);
    RHR = Number(RHR);

    if (!isNaN(age)) {
      if (age <= 150) {
        let MHR = 220 - age;
        let NHR;

        if (gender === "male") {
          NHR = [
            ["49-55", "49-54", "50-56", "50-57", "51-56", "50-55"],
            ["56-61", "55-61", "57-62", "58-63", "57-61", "56-61"],
            ["62-65", "62-65", "63-66", "64-67", "62-67", "62-65"],
            ["66-69", "66-70", "67-70", "68-71", "68-71", "66-69"],
            ["70-73", "71-74", "71-75", "72-76", "72-75", "70-73"],
            ["74-81", "75-81", "76-62", "77-83", "76-81", "74-79"],
            ["82+", "82+", "83+", "84+", "82+", "80+"],
          ];
        } else {
          NHR = [
            ["54-60", "54-59", "54-59", "54-60", "54-59", "54-59"],
            ["61-65", "60-64", "60-64", "61-65", "60-64", "60-64"],
            ["66-69", "65-68", "65-69", "66-69", "65-68", "65-68"],
            ["70-73", "69-72", "70-73", "70-73", "69-73", "69-72"],
            ["74-78", "73-76", "74-78", "74-77", "74-77", "73-76"],
            ["79-84", "77-82", "79-84", "78-83", "78-83", "77-84"],
            ["85+", "83+", "85+", "84+", "84+", "84+"],
          ];
        }

        let res = [];
        let res_normal = "";

        if (age < 18) {
          res_normal = "Normal Heart Rate Cannot be calculated under age 18";
          res = ["", "", "", "", "", "", ""];
        } else if (age >= 18 && age <= 25) {
          for (let i = 0; i < 7; i++) res[i] = NHR[i][0];
        } else if (age >= 26 && age <= 35) {
          for (let i = 0; i < 7; i++) res[i] = NHR[i][1];
        } else if (age >= 36 && age <= 45) {
          for (let i = 0; i < 7; i++) res[i] = NHR[i][2];
        } else if (age >= 46 && age <= 55) {
          for (let i = 0; i < 7; i++) res[i] = NHR[i][3];
        } else if (age >= 56 && age <= 65) {
          for (let i = 0; i < 7; i++) res[i] = NHR[i][4];
        } else if (age >= 66) {
          for (let i = 0; i < 7; i++) res[i] = NHR[i][5];
        } else {
          res_normal = "Invalid Age";
          res = [""];
        }

        let HRR = !isNaN(RHR) ? MHR - RHR : "";

        // let HRR;

        // if (!isNaN(RHR) && !isNaN(MHR)) {
        //     HRR = MHR - RHR;
        // } else {
        //     RHR = "";
        //     HRR = "";
        // }

        // 60-80% method
        let percent_lower = (MHR * 60) / 100;
        let percent_upper = (MHR * 80) / 100;

        // Zoladz method
        let zoladz_lower = MHR - 50 - 5;
        let zoladz_upper = MHR - 40 + 5;

        // Karvonen method
        let karvonen_lower = !isNaN(RHR) ? (HRR * 60) / 100 + RHR : "";
        let karvonen_upper = !isNaN(RHR) ? (HRR * 80) / 100 + RHR : "";

        response.tech_percent_lower = Number(percent_lower.toFixed(4));
        response.tech_percent_upper = Number(percent_upper.toFixed(4));
        response.tech_MHR = MHR;
        response.tech_HRR = HRR;
        response.tech_zoladz_lower = zoladz_lower;
        response.tech_zoladz_upper = zoladz_upper;
        response.tech_karvonen_lower = karvonen_lower;
        response.tech_karvonen_upper = karvonen_upper;
        response.tech_res_normal = res_normal;
        response.tech_res0 = res[0];
        response.tech_res1 = res[1];
        response.tech_res2 = res[2];
        response.tech_res3 = res[3];
        response.tech_res4 = res[4];
        response.tech_res5 = res[5];
        response.tech_res6 = res[6];
        response.input_age = body.tech_age;
        response.input_gender = body.tech_gender;
        response.input_RHR = body.tech_RHR;

        return response;
      } else {
        response.error = "Age must be less than 150.";
        return response;
      }
    } else {
      response.error = "Please! Check your input.";
      return response;
    }
  }

  /**
   * getCalculationNNTCalculator: Service Method
   * POST: /api/calculators-lol/nnt-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationNNTCalculator(body) {
    let outcome = body.tech_outcome;
    let first = body.tech_first;
    let second = body.tech_second;
    let third = body.tech_third;

    let response = {};

    first = Number(first);
    second = Number(second);
    third = Number(third);

    let arr, nnt;

    if (outcome === "per") {
      if (!isNaN(second) && !isNaN(third)) {
        if (second > 0 && third > 0) {
          let minus = second - third;
          arr = minus / 100;
          nnt = 1 / arr;
        } else {
          response.error = "This value can't be negative.";
          return response;
        }
      } else {
        response.error = "Please! Check your input.";
        return response;
      }
    } else {
      if (!isNaN(first) && !isNaN(second) && !isNaN(third)) {
        if (first > 0 && second > 0 && third > 0) {
          let f_div = (-1 * second) / first;
          let s_div = (-1 * third) / first;
          let r0 = 1 - Math.exp(f_div);
          let r1 = 1 - Math.exp(s_div);
          arr = r0 - r1;
          nnt = 1 / arr;
        } else {
          response.error = "This value can't be negative.";
          return response;
        }
      } else {
        response.error = "Please! Check your input.";
        return response;
      }
    }

    response.tech_arr = arr;
    response.tech_nnt = nnt;
    response.input_outcome = body.tech_outcome;
    response.input_first = body.tech_first;
    response.input_second = body.tech_second;
    response.input_third = body.tech_third;
    return response;
  }

  /**
   * getCalculationAstAltRatioCalculator: Service Method
   * POST: /api/calculators-lol/ast-alt-ratio-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationAstAltRatioCalculator(body) {
    let ast = String(body.tech_ast).trim();
    let ast_unit = String(body.tech_ast_unit).trim().replace("U / ", "");
    let alt = String(body.tech_alt).trim();
    let alt_unit = String(body.tech_alt_unit).trim().replace("U / ", "");

    function sigFig(value, digits) {
      if (value !== "") {
        let decimalPlaces;
        if (value === 0) {
          decimalPlaces = digits - 1;
        } else if (value < 0) {
          decimalPlaces = digits - Math.floor(Math.log10(value * -1)) - 1;
        } else {
          decimalPlaces = digits - Math.floor(Math.log10(value)) - 1;
        }
        return Number(value.toFixed(decimalPlaces));
      }
    }

    let result = {};

    if (
      !isNaN(ast) &&
      ast !== "" &&
      !isNaN(alt) &&
      alt !== "" &&
      ast_unit !== "" &&
      alt_unit !== ""
    ) {
      ast = parseFloat(ast);
      alt = parseFloat(alt);

      // Unit Conversion AST
      if (ast_unit === "mm³") {
        ast = ast / 0.000001;
      } else if (ast_unit === "cm³") {
        ast = ast / 0.001;
      } else if (ast_unit === "cu in") {
        ast = ast / 0.016387;
      } else if (ast_unit === "cu ft") {
        ast = ast / 28.317;
      } else if (ast_unit === "ml") {
        ast = ast / 0.001;
      } else if (ast_unit === "cl") {
        ast = ast / 0.01;
      }

      // Unit Conversion ALT
      if (alt_unit === "mm³") {
        alt = alt / 0.000001;
      } else if (alt_unit === "cm³") {
        alt = alt / 0.001;
      } else if (alt_unit === "cu in") {
        alt = alt / 0.016387;
      } else if (alt_unit === "cu ft") {
        alt = alt / 28.317;
      } else if (alt_unit === "ml") {
        alt = alt / 0.001;
      } else if (alt_unit === "cl") {
        alt = alt / 0.01;
      }

      if (ast >= 2000) {
        return { error: "AST cannot be greater than or equal to 2000." };
      }
      if (alt >= 2000) {
        return { error: "ALT cannot be greater than or equal to 2000." };
      }

      let ratio = ast / alt;
      let m1 = "";
      let m2 = "";
      let m3 = "";

      if (ast < 8) {
        m1 = "Lower than the average";
      } else if (ast >= 8 && ast <= 48) {
        m1 = "Within normal range";
      } else if (ast > 48) {
        m1 = "Higher than the average";
      }

      if (alt < 7) {
        m2 = "Lower than the average";
      } else if (alt >= 7 && alt <= 55) {
        m2 = "Within normal range";
      } else if (alt > 55) {
        m2 = "Higher than the average";
      }

      if (ratio < 0.6) {
        m3 = "Lower than the average";
      } else if (ratio >= 0.6 && ratio <= 1) {
        m3 = "Within normal range";
      } else if (ratio > 1) {
        m3 = "Too high - indicative of cirrhosis";
      }

      result = {
        tech_ratio: sigFig(ratio, 3),
        tech_ast: ast,
        tech_alt: alt,
        tech_m1: m1,
        tech_m2: m2,
        tech_m3: m3,
      };
    } else {
      result = { error: "Please! Check Your Input." };
    }

    return result;
  }

  /**
   * getCalculationNetCarbsCalculator: Service Method
   * POST: /api/calculators-lol/net-carbs-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationNetCarbsCalculator(body) {
    let serving = body.tech_serving;
    let location = body.tech_location;
    let carbohydrates = body.tech_carbohydrates;
    let fiber = body.tech_fiber;
    let alcohol = body.tech_alcohol;
    let contains = body.tech_contains;

    // Helper function
    function isNumeric(value) {
      return !isNaN(value) && value !== "" && value !== null;
    }

    let result = {};

    if (location === "yes") {
      if (isNumeric(carbohydrates) && isNumeric(fiber) && isNumeric(alcohol)) {
        carbohydrates = parseFloat(carbohydrates);
        fiber = parseFloat(fiber);
        alcohol = parseFloat(alcohol);

        let Net_carbs;
        if (contains === "no") {
          Net_carbs = carbohydrates - fiber - alcohol / 2;
          result.tech_Net_carbs = Net_carbs;
        } else if (contains === "yes") {
          Net_carbs = carbohydrates - fiber - alcohol;
          result.tech_Net_carbs = Net_carbs;
        } else {
          result.error = "Please! Check Your Input.";
          return result;
        }

        result.input_carbohydrates = carbohydrates;
        result.input_fiber = fiber;
        result.input_alcohol = alcohol;
      } else {
        result.error = "Please! Check Your Input.";
        return result;
      }
    } else if (location === "no") {
      if (isNumeric(carbohydrates) && isNumeric(alcohol)) {
        carbohydrates = parseFloat(carbohydrates);
        alcohol = parseFloat(alcohol);

        let Net_carbs;
        if (contains === "yes") {
          Net_carbs = carbohydrates - alcohol;
          result.tech_Net_carbs = Net_carbs;
        } else if (contains === "no") {
          Net_carbs = carbohydrates - alcohol / 2;
          result.tech_Net_carbs = Net_carbs;
        } else {
          result.error = "Please! Check Your Input.";
          return result;
        }

        result.input_carbohydrates = carbohydrates;
        result.input_alcohol = alcohol;
        result.input_fiber = fiber;
      } else {
        result.error = "Please! Check Your Input.";
        return result;
      }
    } else {
      result.error = "Please! Check Your Input.";
      return result;
    }

    return result;
  }

  /**
   * getCalculationUrineOutputCalculator: Service Method
   * POST: /api/calculators-lol/urine-output-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationUrineOutputCalculator(body) {
    let weight = body.tech_weight;
    let weight_unit = body.tech_weight_unit;
    let time = body.tech_time;
    let time_unit = body.tech_time_unit;
    let urine = body.tech_urine;
    let urine_unit = body.tech_urine_unit;
    let fluid = body.tech_fluid;
    let fluid_unit = body.tech_fluid_unit;
    let output_unit = body.tech_output_unit;
    let balance_unit = body.tech_balance_unit;
    let min = body.tech_time_min;
    let sec = body.tech_time_sec;
    let hours = body.tech_time_min;
    let mins = body.tech_time_sec;

    let result = {};

    function converter(value, unit) {
      if (unit === "g") value = value * 1000;
      else if (unit === "dag") value = value * 100;
      else if (unit === "kg") value = value * 1;
      else if (unit === "oz") value = value * 35.274;
      else if (unit === "lbs") value = value * 2.205;
      return value;
    }

    function timex(value, unit) {
      if (unit === "sec") value = value * 3600;
      else if (unit === "min") value = value * 60;
      else if (unit === "hrs") value = value * 1;
      else if (unit === "day") value = value / 24;
      return value;
    }

    function urinex(value, unit) {
      if (unit === "mm³") value = value * 1000;
      else if (unit === "cm³") value = value / 1;
      else if (unit === "dm³") value = value / 1000;
      else if (unit === "cu in") value = value / 16.387;
      else if (unit === "ml") value = value * 1;
      else if (unit === "cl") value = value / 10;
      else if (unit === "liters") value = value / 1000;
      else if (unit === "us gal") value = value / 3785;
      else if (unit === "uk gal") value = value / 4546;
      else if (unit === "us fl oz") value = value / 28.413;
      else if (unit === "uk fl oz") value = value / 28.413;
      return value;
    }

    function isNumeric(val) {
      return !isNaN(val) && val !== "" && val !== null;
    }

    if (
      isNumeric(urine) &&
      isNumeric(weight) &&
      isNumeric(time) &&
      isNumeric(fluid)
    ) {
      let time_ans;

      if (time_unit === "min/sec" || time_unit === "hrs/min") {
        if (time_unit === "min/sec") {
          if (isNumeric(min) && isNumeric(sec)) {
            time = min / 60 + sec / 3600;
            time_ans = time;
          } else {
            result.error = "Please! Check Your Input.";
            return result;
          }
        } else if (time_unit === "hrs/min") {
          if (isNumeric(hours) && isNumeric(mins)) {
            time = hours + mins / 60;
            time_ans = time;
          } else {
            result.error = "Please! Check Your Input.";
            return result;
          }
        }
      } else {
        time = timex(time, time_unit);
        time_ans = time;
      }

      urine = urinex(urine, urine_unit);
      weight = converter(weight, weight_unit);
      let answer_unit = urine / (weight * time);
      let answer = converter(answer_unit, output_unit);
      fluid = urinex(fluid, fluid_unit);
      let sec_answer = fluid - urine;

      result.tech_answer = answer;
      result.tech_sec_answer = sec_answer;
      result.tech_time_ans = Number(time_ans.toFixed(4));
    } else {
      result.error = "Please! Check Your Input.";
      return result;
    }

    return result;
  }

  /**
   * getCalculationBishopScoreCalculator: Service Method
   * POST: /api/calculators-lol/bishop-score-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBishopScoreCalculator(body) {
    let effacement = body.tech_effacement;
    let consistency = body.tech_consistency;
    let fetal_station = body.tech_fetal_station;
    let head_position = body.tech_head_position;
    let dilation = body.tech_dilation;

    let resultData = {};

    function isNumeric(val) {
      return !isNaN(val) && val !== "" && val !== null;
    }

    if (
      isNumeric(effacement) &&
      isNumeric(consistency) &&
      isNumeric(fetal_station) &&
      isNumeric(head_position) &&
      isNumeric(dilation)
    ) {
      let bishopScore =
        Number(dilation) +
        Number(effacement) +
        Number(consistency) +
        Number(fetal_station) +
        Number(head_position);

      let resultMessage = "";
      if (bishopScore <= 6) {
        resultMessage =
          "You are not expected to go into labor in the upcoming weeks. If induction is needed, consider adding cervical ripening agents.";
      } else if (bishopScore >= 8) {
        resultMessage =
          "You are expected to go into labor within a few days. If induction is needed, it's likely to be successful.";
      } else {
        resultMessage = "Consider further evaluation.";
      }

      resultData.tech_bishopScore = bishopScore;
      resultData.tech_result = resultMessage;
    } else {
      resultData.error = "Please! Check Your Input.";
      return resultData;
    }

    return resultData;
  }

  /**
   * getCalculationArmyBodyFatCalculator: Service Method
   * POST: /api/calculators-lol/army-body-fat-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationArmyBodyFatCalculator(body) {
    let activeDuty = body.tech_activeDuty;
    let age = body.tech_age;
    let gender = body.tech_gender;
    let height = body.tech_height_cm;
    let height_unit = body.tech_unit_ft_in;
    let height_ft = body.tech_height_ft;
    let height_in = body.tech_height_in;
    let neck = body.tech_neck_cm;
    let neck_unit = body.tech_unit_ft_in1;
    let neck_ft = body.tech_neck_ft;
    let neck_in = body.tech_neck_in;
    let waist = body.tech_waist_cm;
    let waist_unit = body.tech_unit_ft_in2;
    let waist_ft = body.tech_waist_ft;
    let waist_in = body.tech_waist_in;
    let hip_unit = body.tech_unit_ft_in3;
    let hip_ft = body.tech_hip_ft;
    let hip_in = body.tech_hip_in;

    let hip =
      gender === "female" && body.tech_hip_cm !== undefined
        ? body.tech_hip_cm
        : null;

    function convertToInches(value, unit, ft, inches) {
      if (unit === "ft/in") {
        return ft * 12 + inches;
      } else if (unit === "cm") {
        return value * 0.393701;
      } else if (unit === "m") {
        return value * 39.3701;
      } else if (unit === "ft") {
        return value * 12;
      } else if (unit === "in") {
        return value;
      } else {
        return null;
      }
    }

    height = convertToInches(height, height_unit, height_ft, height_in);
    waist = convertToInches(waist, waist_unit, waist_ft, waist_in);
    neck = convertToInches(neck, neck_unit, neck_ft, neck_in);
    if (gender === "female" && hip !== null) {
      hip = convertToInches(hip, hip_unit, hip_ft, hip_in);
    }

    function isNumeric(val) {
      return !isNaN(val) && val !== null && val !== "";
    }

    let resultData = {};

    if (
      isNumeric(height) &&
      isNumeric(waist) &&
      isNumeric(neck) &&
      (gender !== "female" || isNumeric(hip))
    ) {
      function calculateMaleBodyFat(height, neck, waist) {
        return (
          86.01 * Math.log10(waist - neck) - 70.041 * Math.log10(height) + 36.76
        );
      }

      function calculateFemaleBodyFat(height, neck, waist, hip) {
        return (
          163.205 * Math.log10(waist + hip - neck) -
          97.684 * Math.log10(height) -
          78.387
        );
      }

      function determineBodyFatCategory(
        age,
        gender,
        activeDuty,
        bodyFatPercentage
      ) {
        let maxBodyFat;
        if (gender === "male") {
          if (age >= 17 && age <= 20) {
            maxBodyFat = activeDuty ? 20 : 24;
          } else if (age >= 21 && age <= 27) {
            maxBodyFat = activeDuty ? 22 : 26;
          } else if (age >= 28 && age <= 39) {
            maxBodyFat = activeDuty ? 24 : 28;
          } else {
            maxBodyFat = activeDuty ? 26 : 30;
          }
        } else if (gender === "female") {
          if (age >= 17 && age <= 20) {
            maxBodyFat = 30;
          } else if (age >= 21 && age <= 27) {
            maxBodyFat = 32;
          } else if (age >= 28 && age <= 39) {
            maxBodyFat = 34;
          } else {
            maxBodyFat = 36;
          }
        }

        if (bodyFatPercentage <= maxBodyFat) {
          return "Congratulations! You meet the US Army body fat standards!";
        } else {
          return "Sorry, you are not fit enough to join the US Army. Keep on training!";
        }
      }

      let bodyFatPercentage;
      if (gender === "male") {
        bodyFatPercentage = calculateMaleBodyFat(height, neck, waist);
      } else {
        bodyFatPercentage = calculateFemaleBodyFat(height, neck, waist, hip);
      }

      let bodyFatCategory = determineBodyFatCategory(
        age,
        gender,
        activeDuty,
        bodyFatPercentage
      );

      resultData.tech_bodyFatPercentage = bodyFatPercentage;
      resultData.tech_bodyFatCategory = bodyFatCategory;
    } else {
      resultData.error = "Please! Check Your Input.";
    }

    return resultData;
  }

  /**
   * getCalculationAdjustedBodyWeightCalculator: Service Method
   * POST: /api/calculators-lol/adjusted-body-weight-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationAdjustedBodyWeightCalculator(body) {
    let weight = body.tech_weight;
    let weight_unit = body.tech_weight_unit;
    let gender = body.tech_gender;
    let height = body.tech_height_cm;
    let height_unit = body.tech_unit_ft_in;
    let height_ft = body.tech_height_ft;
    let height_in = body.tech_height_in;

    // Convert height to inches
    if (height_unit) {
      if (height_unit === "ft/in") {
        let feet_to_inches = height_ft * 12;
        height = feet_to_inches + height_in;
      } else if (height_unit === "cm") {
        height = height * 0.393701;
      } else if (height_unit === "m") {
        height = height * 39.3701;
      } else if (height_unit === "ft") {
        height = height * 12;
      } else if (height_unit === "in") {
        height = height;
      }
    }

    // Convert weight to kg if needed
    if (weight_unit) {
      if (weight_unit === "lbs") {
        weight = weight * 0.45359237;
      }
    }

    let result = {};

    if (!isNaN(height) && !isNaN(weight)) {
      function calculateIdealBodyWeight(gender, height) {
        if (gender === "male") {
          return 52 + 1.9 * (height - 60);
        } else if (gender === "female") {
          return 49 + 1.7 * (height - 60);
        }
        return null;
      }

      function calculateAdjustedBodyWeight(idealBodyWeight, weight) {
        return idealBodyWeight + 0.4 * (weight - idealBodyWeight);
      }

      let idealBodyWeight = calculateIdealBodyWeight(gender, height);
      let adjustedBodyWeight = calculateAdjustedBodyWeight(
        idealBodyWeight,
        weight
      );

      result.tech_idealBodyWeight = Number(idealBodyWeight.toFixed(2));
      result.tech_adjustedBodyWeight = Number(adjustedBodyWeight.toFixed(2));
    } else {
      result.error = "Please! Check Your Input.";
    }

    return result;
  }

  /**
   * getCalculationBenchPressCalculator: Service Method
   * POST: /api/calculators-lol/bench-press-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBenchPressCalculator(body) {
    let weight = parseFloat(body.tech_weight);
    let unit = body.tech_unit;
    let reps = parseFloat(body.tech_reps);
    let tableType = body.tech_tableType; // currently unused, but included for consistency

    // Convert input weight to pounds if necessary
    if (unit === "kg") {
      weight *= 2.20462;
    } else if (unit === "stone") {
      weight *= 14;
    }

    // Calculate one-rep max using Epley formula
    let oneRepMax = weight * (1 + reps / 30);

    // Convert result back to input unit
    if (unit === "kg") {
      oneRepMax /= 2.20462;
    } else if (unit === "stone") {
      oneRepMax /= 14;
    }

    let result = {
      tech_oneRepMax: Number(oneRepMax.toFixed(2)),
    };

    return result;
  }

  /**
   * getCalculationDrugHalfLifeCalculator: Service Method
   * POST: /api/calculators-lol/drug-half-life-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDrugHalfLifeCalculator(body) {
    let half = parseFloat(body.tech_time);
    let half_one = parseFloat(body.tech_time_min);
    let half_sec = parseFloat(body.tech_time_sec);
    let half_unit = body.tech_time_unit;
    let dosage = parseFloat(body.tech_dosage);
    let dosage_unit = body.tech_dosage_unit;

    function secUnit(dosage, dosage_unit) {
      if (dosage_unit === "µg") {
        dosage = dosage / 1000;
      } else if (dosage_unit === "mg") {
        dosage = dosage;
      } else if (dosage_unit === "g") {
        dosage = dosage * 1000;
      }
      return dosage;
    }

    function timeUnit(half, half_unit) {
      if (half_unit === "mins") {
        half = half * 60;
      } else if (half_unit === "hrs") {
        half = half * 3600;
      } else if (half_unit === "days") {
        half = half * 86400;
      } else if (half_unit === "sec") {
        half = half;
      }
      return half;
    }

    function otherTime(half_one, half_sec, half_unit) {
      let half = 0;
      if (half_unit === "hrs/min") {
        half = half_one * 3600 + half_sec * 60;
      } else if (half_unit === "min/sec") {
        half = half_one * 60 + half_sec;
      }
      return half;
    }

    let result = {};

    if (half_unit === "min/sec" || half_unit === "hrs/min") {
      if (isNaN(half_one) && isNaN(half_sec)) {
        result.error = "Please! Enter Input.";
        return result;
      }
      if (isNaN(half_one)) half_one = 0;
      if (isNaN(half_sec)) half_sec = 0;

      if (!isNaN(dosage)) {
        half = otherTime(half_one, half_sec, half_unit);
        if (half === 0) {
          result.error = "Half life value cannot be equal to zero.";
          return result;
        }

        let time_convert = half_unit === "min/sec" ? half / 60 : half / 3600;

        let answer = +time_convert.toFixed(3);
        let answer_one = +(answer + answer).toFixed(2);
        let answer_two = +(answer_one + answer).toFixed(2);
        let answer_three = +(answer_two + answer).toFixed(2);
        let answer_four = +(answer_three + answer).toFixed(2);
        let answer_five = +(answer_four + answer).toFixed(2);

        let subanswer = secUnit(dosage, dosage_unit) / 2;
        let subanswer_one = subanswer / 2;
        let subanswer_sec = subanswer_one / 2;
        let subanswer_three = subanswer_sec / 2;
        let subanswer_four = subanswer_three / 2;
        let subanswer_five = subanswer_four / 2;

        result = {
          tech_subanswer: subanswer,
          tech_subanswer_one: subanswer_one,
          tech_subanswer_sec: subanswer_sec,
          tech_subanswer_three: subanswer_three,
          tech_subanswer_four: subanswer_four,
          tech_subanswer_five: subanswer_five,
          tech_answer: answer,
          tech_answer_one: answer_one,
          tech_answer_two: answer_two,
          tech_answer_three: answer_three,
          tech_answer_four: answer_four,
          tech_answer_five: answer_five,
        };
      } else {
        result.error = "Please! Check Your Input.";
        return result;
      }
    } else {
      if (!isNaN(half) && !isNaN(dosage)) {
        if (half === 0) {
          result.error = "Half life value cannot be equal to zero.";
          return result;
        }

        if (half_unit === "mins") {
          half = timeUnit(half, half_unit);
          time_convert = half / 60;
        } else if (half_unit === "hrs") {
          half = timeUnit(half, half_unit);
          time_convert = half / 3600;
        } else if (half_unit === "days") {
          half = timeUnit(half, half_unit);
          time_convert = half / 86400;
        } else if (half_unit === "sec") {
          half = timeUnit(half, half_unit);
          time_convert = half;
        }

        let answer = +time_convert.toFixed(3);
        let answer_one = +(answer + answer).toFixed(2);
        let answer_two = +(answer_one + answer).toFixed(2);
        let answer_three = +(answer_two + answer).toFixed(2);
        let answer_four = +(answer_three + answer).toFixed(2);
        let answer_five = +(answer_four + answer).toFixed(2);

        let subanswer = secUnit(dosage, dosage_unit) / 2;
        let subanswer_one = subanswer / 2;
        let subanswer_sec = subanswer_one / 2;
        let subanswer_three = subanswer_sec / 2;
        let subanswer_four = subanswer_three / 2;
        let subanswer_five = subanswer_four / 2;

        result = {
          tech_subanswer: subanswer,
          tech_subanswer_one: subanswer_one,
          tech_subanswer_sec: subanswer_sec,
          tech_subanswer_three: subanswer_three,
          tech_subanswer_four: subanswer_four,
          tech_subanswer_five: subanswer_five,
          tech_answer: answer,
          tech_answer_one: answer_one,
          tech_answer_two: answer_two,
          tech_answer_three: answer_three,
          tech_answer_four: answer_four,
          tech_answer_five: answer_five,
        };
      } else {
        result.error = "Please! Check Your Input.";
        return result;
      }
    }

    return result;
  }

  /**
   * getCalculationMacroCalculator: Service Method
   * POST: /api/calculators-lol/macro-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMacroCalculator(body) {
    let check = true;

    // Check all input fields except ignored ones
    for (let key in body) {
      if (
        key !== "tech_height_ft" &&
        key !== "tech_height_in" &&
        key !== "tech_height_cm" &&
        key !== "tech_submit" &&
        key !== "tech_percent" &&
        key !== "/macro-calculator/"
      ) {
        if (!body[key]) {
          check = false;
        }
      }
    }

    let heightFt = parseFloat(body["tech_height_ft"]);
    let heightIn = parseFloat(body["tech_height_in"]);
    let heightCm = parseFloat(body["tech_height_cm"]);

    if (isNaN(heightFt) && isNaN(heightIn) && isNaN(heightCm)) {
      check = false;
    }

    let result = {};

    if (check === true) {
      let age = parseFloat(body.tech_age);
      let weight = parseFloat(body.tech_weight);
      let unit = body.tech_unit;
      let unitFtIn = body.tech_unit_ft_in;
      let gender = body.tech_gender;
      let formula = body.tech_formula;
      let percent = body.tech_percent ? parseFloat(body.tech_percent) : null;
      let activity = body.tech_activity;
      let goal = body.tech_goal;
      let meal = body.tech_meal;

      if (unit === "lbs") {
        weight = weight / 2.205;
      }

      if (unitFtIn === "ft/in") {
        heightCm = heightFt * 30.48;
        if (heightIn) {
          heightCm += heightIn * 2.54;
        }
      }

      let BMR = 0;
      let sugar = gender === "Female" ? 25 : 37.5;

      if (gender === "Female") {
        if (formula === "first") {
          BMR = Math.round(10 * weight + 6.25 * heightCm - 5 * age - 161);
        } else if (formula === "2nd") {
          BMR = Math.round(
            9.247 * weight + 3.098 * heightCm - 4.33 * age + 447.593
          );
        } else {
          if (!percent) {
            result.error = "Please fill required fields.";
            return result;
          }
          BMR = Math.round(370 + 21.6 * (1 - percent / 100) * weight);
        }
      } else {
        // Male
        if (formula === "first") {
          BMR = Math.round(10 * weight + 6.25 * heightCm - 5 * age + 5);
        } else if (formula === "2nd") {
          BMR = Math.round(
            13.397 * weight + 4.799 * heightCm - 5.677 * age + 88.362
          );
        } else {
          if (!percent) {
            result.error = "Please fill required fields.";
            return result;
          }
          BMR = Math.round(370 + 21.6 * (1 - percent / 100) * weight);
        }
      }

      let tdee = 0;

      if (activity === "Sedentary") {
        tdee = Math.round(BMR * 1.2);
      } else if (activity === "Lightly Active") {
        tdee = Math.round(BMR * 1.375);
      } else if (activity === "Moderately Active") {
        tdee = Math.round(BMR * 1.465);
      } else if (activity === "Very Active") {
        tdee = Math.round(BMR * 1.725);
      } else {
        tdee = Math.round(BMR * 1.9);
      }

      if (goal === "Fat Loss") {
        tdee = tdee - 500;
      } else if (goal === "Loss 10%") {
        tdee = tdee * 0.1;
      } else if (goal === "Maintain") {
        tdee = tdee * 1;
      } else {
        tdee = tdee * 1.1;
      }

      if (meal !== "all") {
        tdee = Math.round(tdee / parseInt(meal));
        sugar = Math.round(sugar / parseInt(meal));
      }

      let stand_fat = Math.round((tdee * 0.1) / 9);

      result.tech_calories = tdee;
      result.tech_Sugar = sugar;
      result.tech_stand_fat = stand_fat;

      return result;
    } else {
      result.error = "Please fill All fields.";
      return result;
    }
  }

  /**
   * getCalculationMealCalorieCalculator: Service Method
   * POST: /api/calculators-lol/meal-calorie-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMealCalorieCalculator(body) {
    let calorie = body.tech_calorie;
    let meals = body.tech_meals;

    const parsedCalorie = parseFloat(calorie);
    let response = {};

    if (!isNaN(parsedCalorie)) {
      if (meals === "3") {
        const b_f = Math.round((32.5 / 100) * parsedCalorie);
        const lanch = Math.round((37.5 / 100) * parsedCalorie);
        const dinner = Math.round((30 / 100) * parsedCalorie);
        response = {
          tech_b_f: b_f,
          tech_lanch: lanch,
          tech_dinner: dinner,
        };
      } else if (meals === "4") {
        const b_f = Math.round((27.5 / 100) * parsedCalorie);
        const m_s = Math.round((7.5 / 100) * parsedCalorie);
        const lanch = Math.round((37.5 / 100) * parsedCalorie);
        const dinner = Math.round((27.5 / 100) * parsedCalorie);
        response = {
          tech_b_f: b_f,
          tech_m_s: m_s,
          tech_lanch: lanch,
          tech_dinner: dinner,
        };
      } else if (meals === "5") {
        const b_f = Math.round((27.5 / 100) * parsedCalorie);
        const m_s = Math.round((7.5 / 100) * parsedCalorie);
        const lanch = Math.round((37.5 / 100) * parsedCalorie);
        const a_n = Math.round((7.5 / 100) * parsedCalorie);
        const dinner = Math.round((27.5 / 100) * parsedCalorie);
        response = {
          tech_b_f: b_f,
          tech_m_s: m_s,
          tech_lanch: lanch,
          tech_a_n: a_n,
          tech_dinner: dinner,
        };
      } else {
        response = { error: "Invalid number of meals. Choose 3, 4, or 5." };
      }
    } else {
      response = { error: "Please Fill All Fields." };
    }

    return response;
  }

  /**
   * getCalculationTargetHeartRateCalculator: Service Method
   * POST: /api/calculators-lol/target-heart-rate-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationTargetHeartRateCalculator(body) {
    let method = body.tech_method;
    let age = body.tech_age;
    let formula = body.tech_formula;
    let percent = body.tech_percent;
    let rhr = body.tech_rhr;
    let rhrm = body.tech_rhrm;
    let hrr = body.tech_hrr;
    let inputMhr = body.tech_mhr;

    let mhr;

    // Main MHR calculation based on formula if method is NOT 3
    if (method !== "3" && !isNaN(age)) {
      const ageNum = parseFloat(age);
      switch (parseInt(formula)) {
        case 1:
          mhr = 220 - ageNum;
          break;
        case 2:
          mhr = 226 - ageNum;
          break;
        case 3:
          mhr = 205.8 - 0.685 * ageNum;
          break;
        case 4:
          mhr = 206.3 - 0.711 * ageNum;
          break;
        case 5:
          mhr = 217 - 0.85 * ageNum;
          break;
        case 6:
          mhr = 208 - 0.7 * ageNum;
          break;
        case 7:
          mhr = 206.9 - 0.67 * ageNum;
          break;
        case 8:
          mhr = 211 - 0.64 * ageNum;
          break;
        case 9:
          mhr = 203.7 / (1 + Math.exp(0.033 * (ageNum - 104.3)));
          break;
        case 10:
          mhr = 190.2 / (1 + Math.exp(0.0453 * (ageNum - 107.5)));
          break;
        case 11:
          mhr = 206 - 0.88 * ageNum;
          break;
        default:
          mhr = 220 - ageNum;
      }
    } else {
      mhr = 220 - parseFloat(age);
    }

    let response = {};

    if (method === "1") {
      if (!isNaN(age) && !isNaN(percent)) {
        response = {
          tech_mhr: mhr,
        };
      } else {
        response = { error: "Please fill All fields." };
      }
    } else if (method === "2") {
      if (!isNaN(age) && !isNaN(rhr) && !isNaN(percent)) {
        response = {
          tech_mhr: mhr,
          tech_rhr: parseFloat(rhr),
        };
      } else {
        response = { error: "Please fill All fields." };
      }
    } else if (method === "3") {
      if (!isNaN(inputMhr) && !isNaN(rhrm) && !isNaN(percent)) {
        response = {
          tech_mhr: parseFloat(inputMhr),
          tech_rhr: parseFloat(rhr),
        };
      } else {
        response = { error: "Please fill All fields." };
      }
    } else if (method === "4") {
      if (!isNaN(age) && !isNaN(hrr) && !isNaN(percent)) {
        const rhrCalculated = mhr - parseFloat(hrr);
        response = {
          tech_mhr: mhr,
          tech_rhr: rhrCalculated,
        };
      } else {
        response = { error: "Please fill All fields." };
      }
    }

    return response;
  }

  /**
   * getCalculationWilksCalculator: Service Method
   * POST: /api/calculators-lol/wilks-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationWilksCalculator(body) {
    let sex = body.tech_sex;
    let method = body.tech_method;
    let bw = body.tech_bw;
    let unit = body.tech_unit;
    let bp = body.tech_bp;
    let bp_reps = body.tech_bp_reps;
    let bs = body.tech_bs;
    let bs_reps = body.tech_bs_reps;
    let dl = body.tech_dl;
    let dl_reps = body.tech_dl_reps;
    let wl = body.tech_wl;

    let response = {};

    if (
      !isNaN(bw) &&
      !isNaN(bp) &&
      !isNaN(bs) &&
      !isNaN(dl) &&
      !isNaN(wl) &&
      !isNaN(bp_reps) &&
      !isNaN(bs_reps) &&
      !isNaN(dl_reps) &&
      sex &&
      method &&
      unit
    ) {
      let weightBw = parseFloat(bw);
      let weightWl = parseFloat(wl);
      let weightBp = parseFloat(bp);
      let weightBs = parseFloat(bs);
      let weightDl = parseFloat(dl);

      if (method === "au") {
        if (unit === "lbs") {
          weightBw *= 0.4536;
          weightWl *= 0.4536;
          response.lb = parseFloat(weightBw.toFixed(2));
          response.lb1 = parseFloat(weightWl.toFixed(2));
        }

        if (!isNaN(weightBw) && !isNaN(weightWl)) {
          let ws_cal, ws;

          if (sex === "male") {
            ws_cal =
              500 /
              (-216.0475144 +
                16.2606339 * weightBw +
                -0.002388645 * Math.pow(weightBw, 2) +
                -0.00113732 * Math.pow(weightBw, 3) +
                0.00000701863 * Math.pow(weightBw, 4) +
                -1.291e-8 * Math.pow(weightBw, 5));
          } else if (sex === "female") {
            ws_cal =
              500 /
              (594.31747775582 +
                -27.23842536447 * weightBw +
                0.82112226871 * Math.pow(weightBw, 2) +
                -0.00930733913 * Math.pow(weightBw, 3) +
                0.00004731582 * Math.pow(weightBw, 4) +
                -9.054e-8 * Math.pow(weightBw, 5));
          }

          ws = weightWl * ws_cal;
          response.tech_ws_cal = parseFloat(ws_cal.toFixed(3));
          response.tech_ws = parseFloat(ws.toFixed(2));
        } else {
          response.error = "Please Fill All The Fields.";
        }
      } else if (method === "sep") {
        if (unit === "lbs") {
          weightBw *= 0.4536;
          weightBp *= 0.4536;
          weightBs *= 0.4536;
          weightDl *= 0.4536;
          response.lb = parseFloat(weightBw.toFixed(2));
        }

        if (
          !isNaN(weightBw) &&
          !isNaN(weightBp) &&
          !isNaN(weightBs) &&
          !isNaN(weightDl)
        ) {
          const bpw = weightBp * (1 + bp_reps / 30);
          const bsw = weightBs * (1 + bs_reps / 30);
          const dlw = weightDl * (1 + dl_reps / 30);
          let fw = bpw + bsw + dlw;
          let ws_cal, ws;

          if (sex === "male") {
            ws_cal =
              500 /
              (-216.0475144 +
                16.2606339 * weightBw +
                -0.002388645 * Math.pow(weightBw, 2) +
                -0.00113732 * Math.pow(weightBw, 3) +
                0.00000701863 * Math.pow(weightBw, 4) +
                -1.291e-8 * Math.pow(weightBw, 5));
          } else if (sex === "female") {
            ws_cal =
              500 /
              (594.31747775582 +
                -27.23842536447 * weightBw +
                0.82112226871 * Math.pow(weightBw, 2) +
                -0.00930733913 * Math.pow(weightBw, 3) +
                0.00004731582 * Math.pow(weightBw, 4) +
                -9.054e-8 * Math.pow(weightBw, 5));
          }

          ws = fw * ws_cal;
          response.lb1 = parseFloat(fw.toFixed(2));
          if (unit === "lbs") fw = fw / 0.4536;
          response.tech_ws_cal = parseFloat(ws_cal.toFixed(3));
          response.tech_ws = parseFloat(ws.toFixed(2));
          response.tech_fw = parseFloat(fw.toFixed(2));
        } else {
          response.error = "Please Fill All The Fields.";
        }
      }
    } else {
      response.error = "Please! Check Your Input.";
    }

    return response;
  }

  /**
   * getCalculationAlleleFrequencyCalculator: Service Method
   * POST: /api/calculators-lol/allele-frequency-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationAlleleFrequencyCalculator(body) {
    let type = body.tech_type;
    let operations = body.tech_operations;
    let first = body.tech_first;
    let second = body.tech_second;
    let third = body.tech_third;
    let four = body.tech_four;

    let response = {};
    let pfreq, qfreq, p_square, q_square, p_q;

    if (type === "frst") {
      if (!isNaN(first) && !isNaN(second) && !isNaN(third)) {
        const mul1 = 0.5 * second;
        const downAdd =
          parseFloat(first) + parseFloat(second) + parseFloat(third);
        const p = parseFloat(first) + mul1;
        const q = parseFloat(third) + mul1;
        pfreq = p / downAdd;
        qfreq = q / downAdd;
      } else {
        response.error = "Please! Check Your Input.";
        return response;
      }
    } else if (type === "scnd") {
      if (operations === 1 || operations === 2) {
        if (!isNaN(four)) {
          if (four > 1) {
            const f_ans = 100 / four;
            const div = 1 / f_ans;
            qfreq = Math.sqrt(div);

            const A = 1;
            const B = 2 * qfreq;
            const q_sq = Math.pow(qfreq, 2);
            const C = q_sq - 1;
            const dis = Math.pow(B, 2) - 4 * A * C;

            if (dis > 0) {
              const x1 = (-B + Math.sqrt(dis)) / (2 * A);
              const x2 = (-B - Math.sqrt(dis)) / (2 * A);
              pfreq = Math.max(x1, x2);
            } else if (dis < 0) {
              // Complex roots (the original Laravel code turns them into strings)
              const realPart = -B / (2 * A);
              const imagPart = Math.sqrt(-dis) / (2 * A);
              const x1 = `${realPart} + ${imagPart}`;
              const x2 = `${realPart} - ${imagPart}`;
              pfreq = x1; // You could choose to return both as well
            } else {
              pfreq = -B / (2 * A);
            }

            response.tech_f_ans = f_ans;
          } else {
            response.error =
              "Occurrence of the disease must be greater than 1 in 1 person.";
            return response;
          }
        } else {
          response.error = "Please! Check Your Input.";
          return response;
        }
      }
    }

    if (
      pfreq !== undefined &&
      qfreq !== undefined &&
      !isNaN(pfreq) &&
      !isNaN(qfreq)
    ) {
      p_square = Math.pow(pfreq, 2);
      q_square = Math.pow(qfreq, 2);
      p_q = 2 * pfreq * qfreq;
    }

    response.tech_pfreq = pfreq;
    response.tech_qfreq = qfreq;
    response.tech_p_square = p_square;
    response.tech_q_square = q_square;
    response.tech_p_q = p_q;
    response.tech_type = body.tech_type;
    response.tech_operations = body.tech_operations;
    response.tech_first = body.tech_first;
    response.tech_second = body.tech_second;
    response.tech_third = body.tech_third;
    response.tech_four = body.tech_four;

    return response;
  }

  /**
   * getCalculationWeightWatchersPointsCalculator: Service Method
   * POST: /api/calculators-lol/weight-watchers-points-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationWeightWatchersPointsCalculator(body) {
    let fe = body.tech_fe;
    let fe_unit = body.tech_fe_unit;
    let sf = body.tech_sf;
    let sf_unit = body.tech_sf_unit;
    let sgr = body.tech_sgr;
    let sgr_unit = body.tech_sgr_unit;
    let ptn = body.tech_ptn;
    let ptn_unit = body.tech_ptn_unit;
    let ptn2 = body.tech_ptn2;
    let ptn2_unit = body.tech_ptn2_unit;
    let carbo = body.tech_carbo;
    let carbo_unit = body.tech_carbo_unit;
    let fat = body.tech_fat;
    let fat_unit = body.tech_fat_unit;
    let fiber = body.tech_fiber;
    let fiber_unit = body.tech_fiber_unit;
    let fat2 = body.tech_fat2;
    let fat2_unit = body.tech_fat2_unit;
    let fiber2 = body.tech_fiber2;
    let fiber2_unit = body.tech_fiber2_unit;
    let call2 = body.tech_call2;
    let call2_unit = body.tech_call2_unit;
    let selection = body.tech_selection;
    let weight = body.tech_weight;
    let weight_unit = body.tech_weight_unit;
    let height = body.tech_height;
    let height_unit = body.tech_height_unit;
    let age = body.tech_age;
    let gender = body.tech_gender;
    let activity = body.tech_activity;

    let response = {};
    let ans;

    // Convert energy units
    if (fe_unit === "cal") fe_unit = 1;
    else if (fe_unit === "kJ") fe_unit = 0.239006;
    else if (fe_unit === "J") fe_unit = 0.1434;

    if (call2_unit === "cal") call2_unit = 1;
    else if (call2_unit === "kJ") call2_unit = 0.239006;
    else if (call2_unit === "J") call2_unit = 0.1434;

    // Convert weight units
    if (weight_unit === "kg") weight_unit = 1;
    else if (weight_unit === "lbs") weight_unit = 0.453592;

    // Convert height units
    if (height_unit === "in") height_unit = 0.0254;
    else if (height_unit === "cm") height_unit = 1;

    function convertGrams(unit, value) {
      if (unit === "mg") return value / 1000;
      if (unit === "g") return value;
      if (unit === "kg") return value / 0.001;
      if (unit === "oz") return value / 0.03527396194958;
      if (unit === "lbs") return value / 0.002204622621849;
      if (unit === "dr") return value / 0.5643833911933;
      if (unit === "gr") return value / 15.43235835294;
      return value;
    }

    // Method 1
    if (selection === "1") {
      if (
        !isNaN(fe) &&
        !isNaN(sf) &&
        !isNaN(sgr) &&
        !isNaN(ptn) &&
        fe > 0 &&
        sf > 0 &&
        sgr > 0
      ) {
        const fev = fe_unit * fe;
        const sfv = convertGrams(sf_unit, sf);
        const sgrv = convertGrams(sgr_unit, sgr);
        const ptnv = convertGrams(ptn_unit, ptn);
        ans = Math.round(
          fev * 0.0305 + sfv * 0.275 + sgrv * 0.12 - ptnv * 0.098
        );
      } else {
        response.error = "Please! Check Your Input.";
        return response;
      }
    }

    // Method 2
    else if (selection === "2") {
      if (
        !isNaN(ptn2) &&
        !isNaN(fat) &&
        !isNaN(fiber) &&
        !isNaN(carbo) &&
        ptn2 > 0 &&
        fat > 0 &&
        fiber > 0 &&
        carbo > 0
      ) {
        const ptn2_val = convertGrams(ptn2_unit, ptn2);
        const fatv = convertGrams(fat_unit, fat);
        const fiberv = convertGrams(fiber_unit, fiber);
        const carbov = convertGrams(carbo_unit, carbo);
        ans = Math.round(
          fatv / 3.8889 + carbov / 9.2105 + ptn2_val / 10.9375 - fiberv / 12.5
        );
      } else {
        response.error = "Please! Check Your Input.";
        return response;
      }
    }

    // Method 3
    else if (selection === "3") {
      if (
        !isNaN(fat2) &&
        !isNaN(fiber2) &&
        !isNaN(call2) &&
        fat2 > 0 &&
        fiber2 > 0 &&
        call2 > 0
      ) {
        let fat2v = convertGrams(fat2_unit, fat2);
        let fiber2v = convertGrams(fiber2_unit, fiber2);
        let call2v = call2_unit * call2;
        if (fiber2v > 4) fiber2v = 4;
        ans = Math.round(call2v / 50 + fat2v / 12 - fiber2v / 5);
      } else {
        response.error = "Please! Check Your Input.";
        return response;
      }
    }

    // Method 4
    else if (selection === "4") {
      if (!isNaN(height) && !isNaN(weight) && !isNaN(age)) {
        if (age >= 19) {
          let base, agefact, actfact, wgtfact, hgtfact;

          if (gender === "male") {
            base = 864;
            agefact = 9.72;
            actfact = 1.12;
            wgtfact = 14.2;
            hgtfact = 503;
          } else {
            base = 387;
            agefact = 7.31;
            actfact = 1.14;
            wgtfact = 10.9;
            hgtfact = 660.7;
          }

          const totage = age * agefact;
          const wgtKG = weight * weight_unit;
          const totwgt = wgtKG * wgtfact;
          const hgtCM = height * height_unit;
          const tothgt = hgtCM * hgtfact;

          const tee1 = (totwgt + tothgt) * actfact;
          const tee2 = base - totage + tee1;
          const atee1 = tee2 * 0.1 - 200;
          const atee2 = tee2 - atee1;
          const targ1 = (atee2 - 1000) / 35;

          ans = Math.round(targ1 - 11);

          if (ans <= 26) ans = 26;
          else if (ans >= 71) ans = 71;

          if (activity === "1") ans += 0;
          else if (activity === "2") ans += 3;
          else if (activity === "3") ans += 6;
          else if (activity === "4") ans += 9;
        } else {
          response.error = "This calculator is for people aged 19 or older.";
          return response;
        }
      } else {
        response.error = "Please! Check Your Input.";
        return response;
      }
    }

    response.tech_method = selection;
    response.tech_ans = ans;
    return response;
  }

  /**
   * getCalculationProteinCalculator: Service Method
   * POST: /api/calculators-lol/protein-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationProteinCalculator(body) {
    let age = body.tech_age;
    let gender = body.tech_gender;
    let weight = body.tech_weight;
    let weight_unit = body.tech_weight_unit;
    let activity_level = body.tech_activity_level;
    let protein_for = body.tech_protein_for;
    let height_ft = body.tech_height_ft;
    let height_in = body.tech_height_in;
    let height_cm = body.tech_height_cm;
    let h_unit = body.tech_unit_ft_in;

    const convertToCm = (unit, value) => {
      switch (unit) {
        case "cm":
          return value;
        case "in":
          return value * 2.54;
        case "m":
          return value * 100;
        case "ft":
          return value * 30.48;
        default:
          return null;
      }
    };

    const convertToKg = (unit, value) => {
      switch (unit) {
        case "g":
          return value / 1000;
        case "kg":
          return value;
        case "lb":
          return value / 2.205;
        case "stone":
          return value * 6.35;
        default:
          return null;
      }
    };

    if (h_unit === "ft/in") {
      if (isNaN(height_ft) || isNaN(height_in)) {
        return { error: "Please! Check your input." };
      }
      height_cm = height_ft * 30.48 + height_in * 2.54;
    } else {
      if (isNaN(height_cm)) {
        return { error: "Please! Check your input." };
      }
      height_cm = convertToCm(h_unit, height_cm);
    }

    if (!isNaN(age) && !isNaN(weight)) {
      const weight_kg = convertToKg(weight_unit, weight);
      let BMR;

      if (gender === "male") {
        BMR = 10 * weight_kg + 6.25 * height_cm - 5 * age + 5;
      } else {
        BMR = 10 * weight_kg + 6.25 * height_cm - 5 * age - 161;
      }

      let multiplier;
      switch (activity_level) {
        case "sedentary":
          multiplier = 1.2;
          break;
        case "light":
          multiplier = 1.375;
          break;
        case "moderate":
          multiplier = 1.55;
          break;
        case "very_active":
          multiplier = 1.725;
          break;
        default:
          multiplier = 1.9;
          break;
      }

      const calories = BMR * multiplier;

      return {
        tech_calories: calories,
        tech_weight_kg: weight_kg,
      };
    } else {
      return { error: "Please! Check your input." };
    }
  }

  /**
   * getCalculationWeightGainCalculator: Service Method
   * POST: /api/calculators-lol/weight-gain-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationWeightGainCalculator(body) {
    let age = body.tech_age;
    let height_ft = body.tech_height_ft;
    let height_cm = body.tech_height_cm;
    let weight = body.tech_weight;
    let per_cal = body.tech_per_cal;
    let gender = body.tech_gender;
    let percent = body.tech_percent;
    let activity = body.tech_activity;
    let stype = body.tech_stype;
    let start = body.tech_start;
    let target = body.tech_target;
    let weight1 = body.tech_weight1;
    let surplus = body.tech_surplus;
    let kal_day = body.tech_kal_day;
    let submit = body.tech_unit_type;

    const want = "2";
    let unit, height_in;

    if (isNaN(age) || isNaN(weight) || isNaN(weight1) || !start || !target) {
      return { error: "Please fill All Fields." };
    }

    // Convert imperial to metric if needed
    if (submit === "imperial") {
      height_in = height_ft * 2.54;
      weight = weight / 2.205;
      weight1 = weight1 / 2.205;
      unit = "lb";
    } else {
      if (isNaN(height_cm)) {
        return { error: "Please enter height." };
      }
      height_in = height_cm;
      unit = "kg";
    }

    let BMR, tdee, Robinson, Miller, Devine, Hamwi;

    const round = (num) => Math.round(num);

    if (gender === "Male") {
      BMR = round(10 * round(weight) + 6.25 * round(height_cm) - 5 * age + 5);
      switch (activity) {
        case "sedentary":
          tdee = round(BMR * 1.1);
          break;
        case "Lightly_Active":
          tdee = round(BMR * 1.2);
          break;
        case "Moderately_Active":
          tdee = round(BMR * 1.4);
          break;
        case "Very_Active":
          tdee = round(BMR * 1.6);
          break;
        default:
          tdee = round(BMR * 1.8);
      }
      Robinson = round(49 + 1.7 * (height_in - 60));
      Miller = round(53.1 + 1.36 * (height_in - 60));
      Devine = round(45.5 + 2.3 * (height_in - 60));
      Hamwi = round(45 + 2.2 * (height_in - 60));
    } else {
      BMR = round(10 * weight + 6.25 * height_cm - 5 * age - 161);
      switch (activity) {
        case "sedentary":
          tdee = round(BMR * 1.1);
          break;
        case "Lightly_Active":
          tdee = round(BMR * 1.2);
          break;
        case "Moderately_Active":
          tdee = round(BMR * 1.4);
          break;
        case "Very_Active":
          tdee = round(BMR * 1.6);
          break;
        default:
          tdee = round(BMR * 1.8);
      }
      Robinson = round(52 + 1.9 * (height_in - 60));
      Miller = round(56.2 + 1.41 * (height_in - 60));
      Devine = round(50 + 2.3 * (height_in - 60));
      Hamwi = round(48 + 2.7 * (height_in - 60));
    }

    let lbm;
    if (percent) {
      lbm = (weight * (100 - percent)) / 100;
      BMR = round(370 + 21.6 * lbm);
    }

    const height_m = height_in / 39.37;
    const BMI = +(weight / (height_m * height_m)).toFixed(2);

    let you_are;
    if (BMI <= 18.5) you_are = "Underweight";
    else if (BMI <= 24.9) you_are = "Normal Weight";
    else if (BMI <= 29.9) you_are = "Overweight";
    else if (BMI <= 35) you_are = "Obesity";
    else you_are = "Severe Obesity";

    const ibw =
      submit === "imperial"
        ? `${round(Robinson * 2.205)}-${round(Hamwi * 2.205)} lbs`
        : `${Robinson}-${Hamwi} kg`;

    const startDate = new Date(start);
    const targetDate = new Date(target);

    if (startDate >= targetDate) {
      return { error: "Target Date must be later than start date." };
    }

    const days = Math.ceil((targetDate - startDate) / (1000 * 60 * 60 * 24));
    const pounds_daily = +(weight1 / days).toFixed(2);
    const high_risk_weight = pounds_daily > 0.3;

    let calories_gain;

    if (surplus === "custom") {
      calories_gain = stype === "Incal" ? kal_day : tdee * (per_cal / 100);
    } else {
      const surplusMap = {
        "0.10": 0.1,
        0.15: 0.15,
        "0.20": 0.2,
      };
      calories_gain = tdee * (surplusMap[surplus] || 0.2);
    }

    const calories_daily = round(tdee + calories_gain);
    const high_risk_calories = calories_daily < 1200;

    const goal =
      submit === "imperial"
        ? +(weight + weight1).toFixed(2)
        : +((weight + weight1) / 2.205).toFixed(2);

    const fat = round((calories_daily / 9) * 0.2);
    const po = round((calories_daily / 4) * 0.3);
    const cb = round((calories_daily / 4) * 0.5);

    return {
      tech_HighRiskWeight: high_risk_weight,
      tech_PoundsDaily: pounds_daily,
      tech_HighRiskCalories: high_risk_calories,
      tech_CaloriesDaily: calories_daily,
      tech_CaloriesLess: round(calories_gain),
      tech_Calories: tdee,
      tech_Goal: goal,
      tech_days: days,
      tech_BMR: BMR,
      tech_BMI: BMI,
      tech_you_are: you_are,
      tech_lbm: lbm,
      tech_ibw: ibw,
      tech_fat: fat,
      tech_po: po,
      tech_cb: cb,
      tech_want: want,
      tech_unit: unit,
    };
  }

  /**
   * getCalculationPediatricDoseCalculator: Service Method
   * POST: /api/calculators-lol/pediatric-dose-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPediatricDoseCalculator(body) {
    let dose = body.tech_dose;
    let dose_unit = body.tech_dose_unit;
    let dose_unit2 = body.tech_dose_unit2;
    let dose_unit3 = body.tech_dose_unit3;
    let bsa = body.tech_bsa;
    let weight = body.tech_weight;
    let weight_unit = body.tech_weight_unit;
    let mass = body.tech_mass;
    let mass_unit = body.tech_mass_unit;
    let per = body.tech_per;
    let per_unit = body.tech_per_unit;
    let dose_frequency = body.tech_dose_frequency;
    let type = body.tech_type;
    let child_age = body.tech_child_age;

    const quarter = (unit, value) => {
      const map = {
        qD: 1,
        BID: 2,
        TID: 3,
        QID: 4,
        "q8 hr": 3,
        "q6 hr": 4,
        "q4 hr": 6,
        "q3 hr": 8,
        "q2 hr": 12,
        "q1 hr": 24,
      };
      return value * (map[unit] || 1);
    };

    const quarter2 = (unit, value) => {
      const map = {
        qD: 1,
        BID: 2,
        TID: 3,
        QID: 4,
        "q8 hr": 3,
        "q6 hr": 4,
        "q4 hr": 6,
        "q3 hr": 8,
        "q2 hr": 12,
        "q1 hr": 24,
      };
      return value / (map[unit] || 1);
    };

    const mass_convert = (unit, value) => {
      const map = { mg: 1, µg: 0.001, g: 1000 };
      return value * (map[unit] || 1);
    };

    const milli_convert = (unit, value) => {
      const map = {
        ml: 1,
        "mm³": 0.001,
        "cm³": 1,
        "cu in": 16.387,
        cl: 10,
        cc: 0.1,
      };
      return value * (map[unit] || 1);
    };

    const weil = (unit, value) => {
      const map = {
        kg: 1,
        lbs: 0.4536,
        g: 0.001,
        dag: 0.01,
        oz: 0.02835,
      };
      return value * (map[unit] || 1);
    };

    const weil2 = (unit, value) => {
      const map = {
        kg: 2.2046,
        lbs: 1,
        g: 0.001,
        dag: 0.01,
        oz: 0.02835,
      };
      return value * (map[unit] || 1);
    };

    let param = {};
    let main_answer1, ans1, main_answer3, main_answer4;

    try {
      dose = parseFloat(dose);
      weight = parseFloat(weight);
      mass = parseFloat(mass);
      per = parseFloat(per);
      bsa = parseFloat(bsa);
      child_age = parseFloat(child_age);

      if (type === "first") {
        if (dose > 0 && weight > 0 && mass > 0 && per > 0) {
          let wv = weil(weight_unit, weight);
          let mv = mass_convert(mass_unit, mass);
          let perv = milli_convert(per_unit, per);

          if (["mg/kg", "mg/kg/day"].includes(dose_unit)) {
            main_answer1 = dose * wv;
          } else if (dose_unit === "mg/kg/dose") {
            main_answer1 = quarter(dose_frequency, dose * wv);
          } else if (["mcg/kg", "mcg/kg/day"].includes(dose_unit)) {
            main_answer1 = (dose * wv) / 1000;
          } else if (dose_unit === "mcg/kg/dose") {
            main_answer1 = quarter(dose_frequency, (dose * wv) / 1000);
          }
        } else {
          throw new Error("Please! Check your input.");
        }
      } else if (type === "second") {
        if (dose > 0 && bsa > 0 && mass > 0 && per > 0) {
          let mv = mass_convert(mass_unit, mass);
          let perv = milli_convert(per_unit, per);

          if (dose_unit2 === "mg/m²") {
            main_answer1 = dose * bsa;
          } else if (dose_unit2 === "mg/day") {
            main_answer1 = (dose * bsa) / 1.73;
          } else if (dose_unit2 === "mg/dose") {
            main_answer1 = quarter(dose_frequency, (dose * bsa) / 1.73);
          } else if (dose_unit2 === "mcg/m²") {
            main_answer1 = (dose * bsa) / 1000;
          } else if (dose_unit2 === "mcg/day") {
            main_answer1 = (dose * bsa) / 1.73 / 1000;
          } else if (dose_unit2 === "mcg/dose") {
            main_answer1 = quarter(dose_frequency, (dose * bsa) / 1.73 / 1000);
          }
        } else {
          throw new Error("Please! Check your input.");
        }
      } else if (type === "third") {
        if (dose > 0 && child_age > 0 && mass > 0 && per > 0) {
          let mv = mass_convert(mass_unit, mass);
          let perv = milli_convert(per_unit, per);

          if (dose_unit3 === "mg/day") {
            main_answer1 = dose * (child_age / (child_age + 12));
          } else if (dose_unit3 === "mg/dose") {
            main_answer1 = quarter(
              dose_frequency,
              dose * (child_age / (child_age + 12))
            );
          } else if (dose_unit3 === "mcg/day") {
            main_answer1 = (dose * (child_age / (child_age + 12))) / 1000;
          } else if (dose_unit3 === "mcg/dose") {
            main_answer1 = quarter(
              dose_frequency,
              (dose * (child_age / (child_age + 12))) / 1000
            );
          }
        } else {
          throw new Error("Please! Check your input.");
        }
      } else if (type === "fourth") {
        if (dose > 0 && weight > 0 && mass > 0 && per > 0) {
          let wv = weil2(weight_unit, weight);
          let mv = mass_convert(mass_unit, mass);
          let perv = milli_convert(per_unit, per);

          if (dose_unit3 === "mg/day") {
            main_answer1 = dose * (wv / 150);
          } else if (dose_unit3 === "mg/dose") {
            main_answer1 = quarter(dose_frequency, dose * (wv / 150));
          } else if (dose_unit3 === "mcg/day") {
            main_answer1 = (dose * (wv / 150)) / 1000;
          } else if (dose_unit3 === "mcg/dose") {
            main_answer1 = quarter(dose_frequency, (dose * (wv / 150)) / 1000);
          }
        } else {
          throw new Error("Please! Check your input.");
        }
      }

      ans1 = quarter2(dose_frequency, main_answer1);
      let mv = mass_convert(mass_unit, mass);
      let perv = milli_convert(per_unit, per);
      main_answer3 = mv / perv;
      let l = main_answer1 / main_answer3;
      main_answer4 = quarter2(dose_frequency, l);

      return {
        tech_mass: mass,
        tech_mass_unit: mass_unit,
        tech_per: per,
        tech_per_unit: per_unit,
        tech_ans1: ans1,
        tech_dose_frequency: dose_frequency,
        tech_main_answer1: main_answer1,
        tech_main_answer3: main_answer3,
        tech_main_answer4: main_answer4,
      };
    } catch (error) {
      return { error: error.message };
    }
  }

  /**
   * getCalculationMaintenanceCalorieCalculator: Service Method
   * POST: /api/calculators-lol/maintenance-calorie-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMaintenanceCalorieCalculator(body) {
    let unit_type = body.tech_unit_type;
    let gender = body.tech_gender;
    let age = body.tech_age;
    let ft_in = body.tech_ft_in;
    let height_cm = body.tech_height_cm;
    let weight = body.tech_weight;
    let activity = body.tech_activity;

    // Helper functions
    function round(value, decimals = 0) {
      return Number(Math.round(value + "e" + decimals) + "e-" + decimals);
    }

    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }

    let param = {};

    if (isNumeric(age) && isNumeric(weight) && gender && activity) {
      let weight_kg, height_in;

      if (unit_type === "lbs") {
        if (!ft_in) {
          return { error: "Please Select Height." };
        }
        weight_kg = weight / 2.205;
        height_cm = ft_in * 2.54;
      } else {
        if (!height_cm) {
          return { error: "Please Enter Height." };
        }
        weight_kg = weight;
      }

      let height_m = height_cm / 100;
      height_in = height_cm / 2.54;
      let weight_lbs = weight_kg * 2.205;
      let BMI = round(weight_kg / (height_m * height_m), 2);

      let rmr, BMR, tdee, Miller, Hamwi;

      if (gender === "Female") {
        rmr = round(655 + 9.6 * weight_kg + 1.8 * height_cm - 4.7 * age);
        BMR = round(height_cm * 6.25 + weight_kg * 10 - age * 5 - 161);
        Miller = round(53.1 + 1.36 * (height_in - 60));
        Hamwi = round(45 + 2.2 * (height_in - 60));
      } else {
        rmr = round(66 + 13.7 * weight_kg + 5 * height_cm - 6.8 * age);
        BMR = round(height_cm * 6.25 + weight_kg * 10 - age * 5 + 5);
        Miller = round(56.2 + 1.41 * (height_in - 60));
        Hamwi = round(48 + 2.7 * (height_in - 60));
      }

      const activityFactors = {
        Sedentary: 1.2,
        "Lightly Active": 1.375,
        "Moderately Active": 1.55,
        "Very Active": 1.725,
        "Extra Active": 1.9,
      };

      tdee = round(BMR * (activityFactors[activity] || 1.2));

      let ibwRange;
      if (unit_type === "lbs") {
        Miller = Miller * 2.205;
        Hamwi = Hamwi * 2.205;
      }

      if (Hamwi >= Miller) {
        ibwRange = `${round(Miller)}-${round(Hamwi)}`;
      } else {
        ibwRange = `${round(Hamwi)}-${round(Miller)}`;
      }

      let fat = round((tdee / 9) * 0.2);
      let po = round((tdee / 4) * 0.3);
      let cb = round((tdee / 4) * 0.5);

      param = {
        tech_Calories: tdee,
        tech_BMR: BMR,
        tech_rmr: rmr,
        tech_BMI: BMI,
        tech_ibw: ibwRange,
        tech_fat: fat,
        tech_po: po,
        tech_cb: cb,
        tech_submit: unit_type,
      };

      return param;
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /**
   * getCalculationBreastfeedingCalorieCalculator: Service Method
   * POST: /api/calculators-lol/breastfeeding-calorie-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBreastfeedingCalorieCalculator(body) {
    let unit_type = body.tech_unit_type;
    let age = body.tech_age;
    let ft_in = body.tech_ft_in;
    let height_cm = body.tech_height_cm;
    let weight = body.tech_weight;
    let activity = body.tech_activity;
    let bf = body.tech_bf;
    let pregnant = body.tech_pregnant;

    let param = {};

    // Trim string fields and convert numbers
    let submit = unit_type?.trim();
    age = parseFloat(age);
    weight = parseFloat(weight);
    ft_in = parseFloat(ft_in);
    height_cm = parseFloat(height_cm);
    activity = parseFloat(activity);
    bf = parseFloat(bf);
    pregnant = parseFloat(pregnant);

    let check = false;

    if (submit === "lbs" && isNumeric(age) && isNumeric(weight)) {
      check = true;
    } else if (
      submit === "kg" &&
      isNumeric(age) &&
      isNumeric(height_cm) &&
      isNumeric(weight)
    ) {
      check = true;
    }

    if (check) {
      if (submit === "lbs") {
        weight = weight * 0.45359237;
        height_cm = ft_in * 2.54;
      }

      let maintain = round(
        (10 * weight + 6.25 * height_cm - 5 * age - 161) * activity +
          bf +
          pregnant
      );
      let lose = maintain - 300;
      let supply = maintain - 500;

      param = {
        tech_maintain: maintain,
        tech_lose: lose,
        tech_supply: supply,
        tech_carbos1: round((maintain * 0.44) / 4),
        tech_carbos2: round((lose * 0.44) / 4),
        tech_proteins1: round((maintain * 0.26) / 4),
        tech_proteins2: round((lose * 0.26) / 4),
        tech_fats1: round((maintain * 0.25) / 9),
        tech_fats2: round((lose * 0.25) / 9),
      };

      return param;
    } else {
      return { error: "Please! Check Your Input." };
    }

    // Helper functions
    function round(value, decimals = 0) {
      return Number(Math.round(value + "e" + decimals) + "e-" + decimals);
    }

    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }
  }

  /**
   * getCalculationSwimmingCalorieCalculator: Service Method
   * POST: /api/calculators-lol/swimming-calorie-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationSwimmingCalorieCalculator(body) {
    let weight = body.tech_weight;
    let weight_unit = body.tech_weight_unit;
    let time = body.tech_time;
    let time_unit = body.tech_time_unit;
    let style = body.tech_style;

    // Trim and parse values
    weight = parseFloat(String(weight).trim());
    time = parseFloat(String(time).trim());
    style = parseFloat(String(style).trim());
    weight_unit = String(weight_unit).trim();
    time_unit = String(time_unit).trim();

    let param = {};
    // Helpers
    function round(value, decimals = 0) {
      return Number(Math.round(value + "e" + decimals) + "e-" + decimals);
    }

    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }
    // Validation
    if (!isNumeric(style) || !isNumeric(weight) || !weight_unit) {
      return { error: "Please! Check Your Inputs" };
    }

    if (!time_unit) {
      return { error: "Please! Check Your Inputs" };
    }

    if (!isNumeric(time)) {
      return { error: "Please! Check Your Inputs" };
    }

    // Conversion helpers
    function convertToKg(unit, value) {
      if (unit === "lb") return value / 2.205;
      if (unit === "kg") return value;
      if (unit === "stone") return value * 6.35;
      return NaN;
    }

    function convertToMin(unit, value) {
      if (unit === "sec") return value / 60;
      if (unit === "min") return value;
      if (unit === "hrs") return value * 60;
      return NaN;
    }

    const final_weight = convertToKg(weight_unit, weight);
    const final_min = convertToMin(time_unit, time);

    if (!isNumeric(final_weight) || !isNumeric(final_min)) {
      return { error: "Conversion failed. Invalid input units." };
    }

    const cal_burned_per_min = (style * final_weight * 3.5) / 200;
    const total_cal_burned = cal_burned_per_min * final_min;

    param.tech_cal_burned_per_min = round(cal_burned_per_min, 2);
    param.tech_total_cal_burned = round(total_cal_burned, 2);

    return param;
  }

  /**
   * getCalculationDistanceCalculator: Service Method
   * POST: /api/calculators-lol/distance-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDistanceCalculator(body) {
    let submit = body.tech_submit;

    let lat1 = body.tech_lat1;
    let long1 = body.tech_long1;
    let lat2 = body.tech_lat2;
    let long2 = body.tech_long2;

    let deg1 = body.tech_deg1;
    let mint1 = body.tech_mint1;
    let sec1 = body.tech_sec1;
    let dir1 = body.tech_dir1;

    let deg2 = body.tech_deg2;
    let mint2 = body.tech_mint2;
    let sec2 = body.tech_sec2;
    let dir2 = body.tech_dir2;

    let deg21 = body.tech_deg21;
    let mint21 = body.tech_mint21;
    let sec21 = body.tech_sec21;
    let dir21 = body.tech_dir21;

    let deg22 = body.tech_deg22;
    let mint22 = body.tech_mint22;
    let sec22 = body.tech_sec22;
    let dir22 = body.tech_dir22;

    let to_cal = body.tech_to_cal;

    let param = {};

    const findDistance = (lat1, lon1, lat2, lon2) => {
      const theta = lon1 - lon2;
      let dist =
        Math.sin(degToRad(lat1)) * Math.sin(degToRad(lat2)) +
        Math.cos(degToRad(lat1)) *
          Math.cos(degToRad(lat2)) *
          Math.cos(degToRad(theta));
      dist = Math.acos(dist);
      dist = radToDeg(dist);
      const miles = dist * 60 * 1.1515;
      return miles;
    };

    const ConvertDMSToDD = (degrees, minutes, seconds, direction) => {
      let dd = Number(degrees) + Number(minutes) / 60 + Number(seconds) / 3600;
      if (direction === "S" || direction === "W") {
        dd *= -1;
      }
      return dd;
    };

    const degToRad = (deg) => (deg * Math.PI) / 180;
    const radToDeg = (rad) => (rad * 180) / Math.PI;

    if (to_cal === "decimal") {
      if (submit) {
        const miles = findDistance(
          Number(lat1),
          Number(long1),
          Number(lat2),
          Number(long2)
        );
        param.tech_mile = miles;
        param.tech_km = miles * 1.609344;
      } else {
        param.error = "Please! Check Your Input";
      }
    } else {
      if (submit) {
        const lat1_dd = ConvertDMSToDD(deg1, mint1, sec1, dir1);
        const long1_dd = ConvertDMSToDD(deg2, mint2, sec2, dir2);
        const lat2_dd = ConvertDMSToDD(deg21, mint21, sec21, dir21);
        const long2_dd = ConvertDMSToDD(deg22, mint22, sec22, dir22);
        const miles = findDistance(lat1_dd, long1_dd, lat2_dd, long2_dd);
        param.tech_mile = miles;
        param.tech_km = miles * 1.609344;
      } else {
        param.error = "Please! Check Your Input";
      }
    }

    return param;
  }

  /**
   * getCalculationErACalculator: Service Method
   * POST: /api/calculators-lol/era-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationErACalculator(body) {
    let x = body.tech_x;
    let y = body.tech_y;
    let z = body.tech_z;
    let g = body.tech_g;

    let param = {};

    if (!isNaN(x) || !isNaN(y) || !isNaN(z)) {
      const earn_run = Number(x);
      let inning = Number(y);
      const game = g !== undefined && g !== "" ? Number(g) : 9;

      if (z !== undefined && z !== "") {
        inning = Number(y) + Number(z) / 3;
      }

      const era = parseFloat(((earn_run / inning) * game).toFixed(3));
      param.tech_era = era;
    } else {
      param.error = "Please! Fill all the Input Fields";
    }

    return param;
  }

  /**
   * getCalculationAgeDifferenceCalculator: Service Method
   * POST: /api/calculators-lol/vorici-chromatic-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationVoriciChromaticCalculator(body) {
    let submit = body.tech_submit;
    let s_f = body.tech_s_f;
    let str_f = body.tech_str_f;
    let dex_f = body.tech_dex_f;
    let int_f = body.tech_int_f;
    let r_f = body.tech_r_f;
    let g_f = body.tech_g_f;
    let b_f = body.tech_b_f;

    let param = {};

    if (submit) {
      // Ensure that all input fields are provided
      param.tech_s_f = s_f;
      param.tech_str_f = str_f;
      param.tech_dex_f = dex_f;
      param.tech_int_f = int_f;
      param.tech_r_f = r_f;
      param.tech_g_f = g_f;
      param.tech_b_f = b_f;
    } else {
      param.error = "Please! Fill all the Input Fields";
    }

    return param;
  }

  /**
   * getCalculationAspectRatioCalculator: Service Method
   * POST: /api/calculators-lol/aspect-ratio-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAspectRatioCalculator(body) {
    let ratios = body.tech_ratios;
    let w1 = body.tech_w1;
    let h1 = body.tech_h1;
    let w2 = body.tech_w2;
    let h2 = body.tech_h2;

    // Trim string values
    ratios = ratios?.trim();
    w1 = w1?.toString().trim();
    h1 = h1?.toString().trim();
    w2 = w2?.toString().trim();
    h2 = h2?.toString().trim();

    w1 = parseFloat(w1);
    h1 = parseFloat(h1);
    w2 = parseFloat(w2);
    h2 = parseFloat(h2);

    const response = {};

    if (!isNaN(w1) && !isNaN(h1)) {
      function gcd(a, b) {
        if (b === 0) return a;
        return gcd(b, a % b);
      }

      function reduceRatio(numerator, denominator) {
        if (numerator === denominator) return "1 : 1";
        const divisor = gcd(numerator, denominator);
        let left = numerator / divisor;
        let right = denominator / divisor;
        if (left == 8 && right == 5) {
          left = 16;
          right = 10;
        }
        return `${left} : ${right}`;
      }

      function solve(width, height, numerator, denominator) {
        if (!isNaN(width)) {
          return Math.round(width / (numerator / denominator));
        } else if (!isNaN(height)) {
          return Math.round(height * (numerator / denominator));
        } else {
          return "";
        }
      }

      function ratio2css(numerator, denominator) {
        let width = "";
        let height = "";
        if (numerator > denominator) {
          width = 200;
          height = solve(width, "", numerator, denominator);
        } else {
          height = 200;
          width = solve("", height, numerator, denominator);
        }
        return `width:${Math.round(width)}px;height:${Math.round(
          height
        )}px;line-height:${Math.round(height)}px`;
      }

      let x1v = w1;
      let y1v = h1;
      let stop = 0;
      const maxIterations = 10;
      while (!Number.isInteger(x1v) || !Number.isInteger(y1v)) {
        x1v *= 10;
        y1v *= 10;
        ++stop;
        if (stop > maxIterations) break;
      }

      if (!isNaN(w2) && isNaN(h2)) {
        h2 = (h1 / w1) * w2;
        response.tech_check = "h2";
        response.tech_ans = Math.round(h2 * 1000) / 1000;
      } else if (isNaN(w2) && !isNaN(h2)) {
        w2 = (w1 / h1) * h2;
        response.tech_check = "w2";
        response.tech_ans = Math.round(w2 * 1000) / 1000;
      } else if (!isNaN(w2) && !isNaN(h2)) {
        response.error = "Please enter either W₂ or H₂ to find the other.";
        return response;
      }

      const mode = w1 >= h1 ? "Landscape" : "Portrait";

      response.tech_asp_ratio = reduceRatio(w1, h1);
      response.tech_vsl_ratio = ratio2css(x1v, y1v);
      response.tech_pixels = (w1 * h1).toLocaleString();
      response.tech_mode = mode;
      return response;
    } else {
      return { error: "Please! Check Your Input" };
    }
  }

  /**
   * getCalculationBoardFootCalculator: Service Method
   * POST: /api/calculators-lol/board-foot-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationBoardFootCalculator(body) {
    let length = body.tech_length?.toString().trim();
    let no = body.tech_no?.toString().trim();
    let length_unit = body.tech_length_unit?.toString().trim();
    let width = body.tech_width?.toString().trim();
    let width_unit = body.tech_width_unit?.toString().trim();
    let thickness = body.tech_thickness?.toString().trim();
    let thickness_unit = body.tech_thickness_unit?.toString().trim();
    let price = body.tech_price?.toString().trim();

    // Convert strings to numbers
    length = parseFloat(length);
    no = parseFloat(no);
    width = parseFloat(width);
    thickness = parseFloat(thickness);

    const response = {};

    if (!isNaN(length) && !isNaN(no) && !isNaN(width) && !isNaN(thickness)) {
      // Thickness conversion to inches
      if (thickness_unit === "cm") {
        thickness *= 0.3937;
      } else if (thickness_unit === "m") {
        thickness *= 39.37;
      } else if (thickness_unit === "ft") {
        thickness *= 12;
      } else if (thickness_unit === "yd") {
        thickness *= 36;
      }

      // Width conversion to inches
      if (width_unit === "cm") {
        width *= 0.3937;
      } else if (width_unit === "m") {
        width *= 39.37;
      } else if (width_unit === "ft") {
        width *= 12;
      } else if (width_unit === "yd") {
        width *= 36;
      }

      // Length conversion to feet
      if (length_unit === "cm") {
        length *= 0.03281;
      } else if (length_unit === "m") {
        length *= 3.281;
      } else if (length_unit === "in") {
        length /= 12;
      } else if (length_unit === "yd") {
        length *= 3;
      }

      // Calculate board foot
      let ans = length * width * (thickness / 12);
      ans *= no;

      response.tech_ans = ans;
      return response;
    } else {
      return { error: "Please! Check Your Inputs" };
    }
  }

  /**
   * getCalculationEdpiCalculator: Service Method
   * POST: /api/calculators-lol/edpi-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationEdpiCalculator(body) {
    let dpi = body.tech_dpi?.toString().trim();
    let row = body.tech_row?.toString().trim();
    let sen = body.tech_sen?.toString().trim();
    let game = body.tech_game?.toString().trim();
    let win = body.tech_win?.toString().trim();
    let submit = body.tech_submit;

    // Convert to numeric
    dpi = parseFloat(dpi);
    row = parseFloat(row);
    sen = parseFloat(sen);
    game = parseInt(game);
    win = parseFloat(win);

    const response = {};

    if (submit) {
      // Helper: Calculate Sensitivity Type
      const CalcSn = (e, game) => {
        const s = e * 1;
        switch (game) {
          case 1:
          case 6:
            if (s > 0 && s < 700) return "Low Sens";
            if (s >= 700 && s < 1200) return "Medium Sens";
            if (s >= 1200) return "High Sens";
            break;
          case 3:
            if (s > 0 && s < 200) return "Low Sens";
            if (s >= 200 && s < 400) return "Medium Sens";
            if (s >= 400) return "High Sens";
            break;
          case 4:
            if (s > 0 && s < 40) return "Low Sens";
            if (s >= 40 && s < 80) return "Medium Sens";
            if (s >= 80) return "High Sens";
            break;
          case 5:
            if (s > 0 && s < 3000) return "Low Sens";
            if (s >= 3000 && s < 6000) return "Medium Sens";
            if (s >= 6000) return "High Sens";
            break;
          case 2:
          default:
            return "";
        }
      };

      // Helper: Calculate 360cm
      const Calc360 = (e, game) => {
        const coeff = {
          1: 0.022,
          2: 0.0066,
          3: 0.07,
          4: 0.005555,
          5: 0.0066,
          6: 0.021999,
        };
        const multiplier = coeff[game] || 0.022;
        return (360 / (multiplier * e)) * 2.54;
      };

      let ans = 0;
      if (game === 1) {
        let t = row === 0 ? win : 1;
        ans = dpi * sen * t;
      } else if (game === 4) {
        ans = (dpi * sen) / 100;
      } else {
        ans = dpi * sen;
      }

      const type = CalcSn(ans, game);
      const cm = Calc360(ans, game);
      const inch = cm / 2.54;

      response.tech_ans = parseFloat(ans.toFixed(2));
      response.tech_cm = parseFloat(cm.toFixed(2));
      response.tech_in = parseFloat(inch.toFixed(2));
      response.tech_type = type;
      return response;
    } else {
      return { error: "Please! Check Your Inputs" };
    }
  }

  /**
   * getCalculationVisaChanceCalculator: Service Method
   * POST: /api/calculators-lol/visa-chance-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationVisaChanceCalculator(body) {
    let name = body.tech_name?.trim();
    let resident = body.tech_resident?.trim();
    let nationality = body.tech_nationality?.trim();
    let travel = parseInt(body.tech_travel);

    const response = {};

    if (!travel || !nationality || !resident) {
      response.error = "Please! Check Your Inputs";
      return response;
    }

    const ec = [
      [],
      [
        "Albania",
        "Algeria",
        "Andorra",
        "Argentina",
        "Australia",
        "Austria",
        "Bahamas",
        "Bahrain",
        "Barbados",
        "Belgium",
        "Bolivia",
        "Bosnia & herzegovina",
        "Brazil",
        "Brunei darussalam",
        "Bulgaria",
        "Canada",
        "Chile",
        "China",
        "Colombia",
        "Costa rica",
        "Croatia",
        "Cuba",
        "Cyprus",
        "Czech republic",
        "Denmark",
        "Djibouti",
        "Ecuador",
        "Estonia",
        "Finland",
        "France",
        "Germany",
        "Greece",
        "Guatemala",
        "Holy see (vatican)",
        "Honduras",
        "Hungary",
        "Iceland",
        "India",
        "Indonesia",
        "Iran",
        "Ireland",
        "Israel",
        "Italy",
        "Jamaica",
        "Japan",
        "Jordan",
        "Korea",
        "Kuwait",
        "Latvia",
        "Liechtenstein",
        "Lithuania",
        "Luxembourg",
        "Macedonia",
        "Malaysia",
        "Maldives",
        "Malta",
        "Mauritius",
        "Mexico",
        "Monaco",
        "Mongolia",
        "Montenegro",
        "Morocco",
        "Nepal",
        "Netherlands",
        "New zealand",
        "Norway",
        "Oman",
        "Pakistan",
        "Panama",
        "Paraguay",
        "Peru",
        "Poland",
        "Portugal",
        "Qatar",
        "Romania",
        "San marino",
        "Saudi arabia",
        "Serbia",
        "Seychelles",
        "Singapore",
        "Slovakia",
        "Slovenia",
        "South africa",
        "Spain",
        "Sri lanka",
        "Sweden",
        "Switzerland",
        "Thailand",
        "Trinidad and tobago",
        "Turkey",
        "Turkmenistan",
        "United arab emirates",
        "United kingdom",
        "United states of america",
        "Vietnam",
      ],
      [
        "Afghanistan",
        "Albania",
        "Algeria",
        "American Samoa",
        "Andorra",
        "Angola",
        "Anguilla",
        "Antarctica",
        "Antigua and Barbuda",
        "Argentina",
        "Armenia",
        "Aruba",
        "Australia",
        "Austria",
        "Azerbaijan",
        "Bahamas",
        "Bahrain",
        "Bangladesh",
        "Barbados",
        "Belarus",
        "Belgium",
        "Belize",
        "Benin",
        "Bermuda",
        "Bhutan",
        "Bolivia",
        "Bosnia and Herzegovina",
        "Botswana",
        "Bouvet Island",
        "Brazil",
        "British Indian Ocean Territory",
        "Brunei Darussalam",
        "Bulgaria",
        "Burkina Faso",
        "Burundi",
        "Cambodia",
        "Cameroon",
        "Canada",
        "Cape Verde",
        "Cayman Islands",
        "Central African Republic",
        "Chad",
        "Chile",
        "China",
        "Christmas Island",
        "Cocos (Keeling) Islands",
        "Colombia",
        "Comoros",
        "Congo",
        "Cook Islands",
        "Costa Rica",
        "Croatia (Hrvatska)",
        "Cuba",
        "Cyprus",
        "Czech Republic",
        "Denmark",
        "Djibouti",
        "Dominica",
        "Dominican Republic",
        "East Timor",
        "Ecuador",
        "Egypt",
        "El Salvador",
        "Equatorial Guinea",
        "Eritrea",
        "Estonia",
        "Ethiopia",
        "Falkland Islands (Malvinas)",
        "Faroe Islands",
        "Fiji",
        "Finland",
        "France",
        "France, Metropolitan",
        "French Guiana",
        "French Polynesia",
        "French Southern Territories",
        "Gabon",
        "Gambia",
        "Georgia",
        "Germany",
        "Ghana",
        "Gibraltar",
        "Greece",
        "Greenland",
        "Grenada",
        "Guadeloupe",
        "Guam",
        "Guatemala",
        "Guernsey",
        "Guinea",
        "Guinea-Bissau",
        "Guyana",
        "Haiti",
        "Heard and Mc Donald Islands",
        "Honduras",
        "Hong Kong",
        "Hungary",
        "Iceland",
        "India",
        "Indonesia",
        "Iran (Islamic Republic of)",
        "Iraq",
        "Ireland",
        "Isle of Man",
        "Israel",
        "Italy",
        "Ivory Coast",
        "Jamaica",
        "Japan",
        "Jersey",
        "Jordan",
        "Kazakhstan",
        "Kenya",
        "Kiribati",
        "Korea, Democratic People's Republic of",
        "Korea, Republic of",
        "Kosovo",
        "Kuwait",
        "Kyrgyzstan",
        "Lao People's Democratic Republic",
        "Latvia",
        "Lebanon",
        "Lesotho",
        "Liberia",
        "Libyan Arab Jamahiriya",
        "Liechtenstein",
        "Lithuania",
        "Luxembourg",
        "Macau",
        "Macedonia",
        "Madagascar",
        "Malawi",
        "Malaysia",
        "Maldives",
        "Mali",
        "Malta",
        "Marshall Islands",
        "Martinique",
        "Mauritania",
        "Mauritius",
        "Mayotte",
        "Mexico",
        "Micronesia, Federated States of",
        "Moldova, Republic of",
        "Monaco",
        "Mongolia",
        "Montenegro",
        "Montserrat",
        "Morocco",
        "Mozambique",
        "Myanmar",
        "Namibia",
        "Nauru",
        "Nepal",
        "Netherlands",
        "Netherlands Antilles",
        "New Caledonia",
        "New Zealand",
        "Nicaragua",
        "Niger",
        "Nigeria",
        "Niue",
        "Norfolk Island",
        "Northern Mariana Islands",
        "Norway",
        "Oman",
        "Pakistan",
        "Palau",
        "Palestine",
        "Panama",
        "Papua New Guinea",
        "Paraguay",
        "Peru",
        "Philippines",
        "Pitcairn",
        "Poland",
        "Portugal",
        "Puerto Rico",
        "Qatar",
        "Reunion",
        "Romania",
        "Russian Federation",
        "Rwanda",
        "Saint Kitts and Nevis",
        "Saint Lucia",
        "Saint Vincent and the Grenadines",
        "Samoa",
        "San Marino",
        "Sao Tome and Principe",
        "Saudi Arabia",
        "Senegal",
        "Serbia",
        "Seychelles",
        "Sierra Leone",
        "Singapore",
        "Slovakia",
        "Slovenia",
        "Solomon Islands",
        "Somalia",
        "South Africa",
        "South Georgia South Sandwich Islands",
        "South Sudan",
        "Spain",
        "Sri Lanka",
        "St. Helena",
        "St. Pierre and Miquelon",
        "Sudan",
        "Suriname",
        "Svalbard and Jan Mayen Islands",
        "Swaziland",
        "Sweden",
        "Switzerland",
        "Syrian Arab Republic",
        "Taiwan",
        "Tajikistan",
        "Tanzania, United Republic of",
        "Thailand",
        "Togo",
        "Tokelau",
        "Tonga",
        "Trinidad and Tobago",
        "Tunisia",
        "Turkey",
        "Turkmenistan",
        "Turks and Caicos Islands",
        "Tuvalu",
        "Uganda",
        "Ukraine",
        "United Arab Emirates",
        "United Kingdom",
        "United States",
        "United States minor outlying islands",
        "Uruguay",
        "Uzbekistan",
        "Vanuatu",
        "Vatican City State",
        "Venezuela",
        "Vietnam",
        "Virgin Islands (British)",
        "Virgin Islands (U.S.)",
        "Wallis and Futuna Islands",
        "Western Sahara",
        "Yemen",
        "Zaire",
        "Zambia",
        "Zimbabwe",
      ],
    ];

    const lowerNationality = nationality.toLowerCase();
    const matchList = (ec[travel] || []).map((n) => n.toLowerCase());

    const ans = matchList.includes(lowerNationality)
      ? "There are more likely 99% chances of your visa eligibility!"
      : "There are more likely 50% chances of your visa eligibility!";

    response.tech_ans = ans;
    return response;
  }

  /**
   * getCalculationPopulationDensityCalculator: Service Method
   * POST: /api/calculators-lol/population-density-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPopulationDensityCalculator(body) {
    let area = body.tech_area?.toString().trim();
    let no = body.tech_no?.toString().trim();

    const response = {};

    if (!isNaN(area) && !isNaN(no)) {
      let areaNum = parseFloat(area);
      let noNum = parseFloat(no);

      let ans = noNum / areaNum;
      response.tech_ans = Math.round(ans);
      return response;
    } else {
      response.error = "Please! Check Input Fields";
      return response;
    }
  }

  /**
   * getCalculationProratedrentCalculator: Service Method
   * POST: /api/calculators-lol/prorated-rent-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationProratedrentCalculator(body) {
    let date = body.tech_date?.toString().trim();
    let rent = parseFloat(body.tech_rent?.toString().trim());
    let bill_on = parseInt(body.tech_bill_on?.toString().trim());

    const response = {};

    if (!isNaN(rent) && !isNaN(bill_on) && date) {
      let dt = new Date(date);
      let year = dt.getFullYear();
      let mon = dt.getMonth(); // 0-indexed
      let day = dt.getDate();

      // Get total days in the current month
      let daysInMonth = new Date(year, mon + 1, 0).getDate();
      let per_day = rent / daysInMonth;
      let pror = 0;
      let days_in_mon = 0;
      let end_date = "";
      let res = 0;

      if (bill_on >= day || bill_on === 1) {
        res = 1;

        if (bill_on <= daysInMonth) {
          if (bill_on === 1) {
            days_in_mon = daysInMonth - day + 1;
            pror = per_day * days_in_mon;
            end_date = `${year}-${String(mon + 1).padStart(
              2,
              "0"
            )}-${daysInMonth}`;
          } else {
            days_in_mon = bill_on - day;
            pror = per_day * days_in_mon;
            end_date = `${year}-${String(mon + 1).padStart(2, "0")}-${String(
              bill_on - 1
            ).padStart(2, "0")}`;
          }
        } else {
          days_in_mon = 1;
          pror = per_day * days_in_mon;
          end_date = `${year}-${String(mon + 1).padStart(
            2,
            "0"
          )}-${daysInMonth}`;
        }
      } else if (bill_on < day) {
        res = 2;
        days_in_mon = daysInMonth - day + 1;
        pror = per_day * days_in_mon;

        let nextMonth = new Date(year, mon + 1, 1);
        let year1 = nextMonth.getFullYear();
        let mon1 = nextMonth.getMonth();
        let daysInNextMonth = new Date(year1, mon1 + 1, 0).getDate();
        let per_day1 = rent / daysInNextMonth;
        let days_in_mon1 = bill_on - 1;
        let pror1 = per_day1 * days_in_mon1;

        end_date = `${year1}-${String(mon1 + 1).padStart(2, "0")}-${String(
          bill_on - 1
        ).padStart(2, "0")}`;

        response.tech_d1 = daysInNextMonth;
        response.tech_per_day1 = parseFloat(per_day1.toFixed(2));
        response.tech_days_in_mon1 = days_in_mon1;
        response.tech_pror1 = parseFloat(pror1.toFixed(2));
      }

      response.tech_date = date;
      response.tech_d = daysInMonth;
      response.tech_per_day = parseFloat(per_day.toFixed(2));
      response.tech_days_in_mon = days_in_mon;
      response.tech_pror = parseFloat(pror.toFixed(2));
      response.tech_end_date = end_date;
      response.tech_res = res;
      return response;
    } else {
      response.error = "Please! Check Your Input";
      return response;
    }
  }

  /**
   * getCalculationKoreanAgeCalculator: Service Method
   * POST: /api/calculators-lol/korean-age-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationKoreanAgeCalculator(body) {
    const current_year = parseInt(body.tech_current_year?.toString().trim());
    const year = parseInt(body.tech_year?.toString().trim());
    const birthday_unit = body.tech_birthday_unit?.toString().trim(); // "1" or "2"
    const age = parseInt(body.tech_age?.toString().trim());
    const room_unit = body.tech_room_unit?.toString().trim(); // "1" or "2"

    const response = {};

    if (room_unit === "1") {
      // Calculate from year of birth
      if (!isNaN(year) && !isNaN(current_year)) {
        if (year < current_year) {
          const korean_age = current_year - year + 1;
          response.tech_korean_age = korean_age;
        } else {
          response.error =
            "It is must that your birth year is earlier than current one in case you are from the future";
        }
      } else {
        response.error = "Please! Check Your Inputs";
      }
    } else if (room_unit === "2") {
      // Calculate from international age
      if (!isNaN(age)) {
        if (age > 0) {
          let korean_age;
          if (birthday_unit === "1") {
            korean_age = age + 2;
          } else if (birthday_unit === "2") {
            korean_age = age + 1;
          }

          if (korean_age !== undefined) {
            response.tech_korean_age = korean_age;
          } else {
            response.error = "Invalid birthday unit";
          }
        } else {
          response.error = "Age Cannot be negative";
        }
      } else {
        response.error = "Please! Check Your Inputs";
      }
    } else {
      response.error = "Invalid room unit";
    }

    return response;
  }

  /**
   * getCalculationWinningPercentageCalculator: Service Method
   * POST: /api/calculators-lol/winning-percentage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationWinningPercentageCalculator(body) {
    const win = parseFloat(body.tech_win?.toString().trim());
    const loss = parseFloat(body.tech_loss?.toString().trim());
    const tie =
      body.tie !== undefined ? parseFloat(body.tech_tie?.toString().trim()) : 0;
    const value =
      body.value !== undefined
        ? parseFloat(body.tech_value?.toString().trim())
        : null;

    const response = {};

    if (!isNaN(win) && !isNaN(loss)) {
      const no_games = win * loss;
      let total = win + loss;

      if (!isNaN(tie)) {
        total += tie;
      }

      let ans;
      if (!isNaN(value) && value !== 0) {
        ans = ((win + value * tie) / total) * 100;
      } else {
        ans = (win / total) * 100;
      }

      response.tech_ans = ans;
      response.tech_no_games = no_games;
    } else {
      response.error = "Please! Check Your Inputs";
    }

    return response;
  }

  /**
   * getCalculationMcgToMgCalculator: Service Method
   * POST: /api/calculators-lol/mcg-to-mg-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMcgToMgCalculator(body) {
    const operations = body.tech_operations?.toString().trim();
    const first = parseFloat(body.tech_first?.toString().trim());

    const response = {};

    if (operations === "1") {
      if (!isNaN(first)) {
        response.tech_jawab = first / 1000;
      } else {
        response.error = "Please! Check Your Inputs";
        return response;
      }
    } else if (operations === "2") {
      if (!isNaN(first)) {
        response.tech_jawab = first * 1000;
      } else {
        response.error = "Please! Check Your Inputs";
        return response;
      }
    } else {
      response.error = "Invalid operation selected";
      return response;
    }

    response.tech_operations = operations;
    response.input_first = first;
    return response;
  }

  /**
   * getCalculationDownloadCalculator: Service Method
   * POST: /api/calculators-lol/download-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDownloadCalculator(body) {
    const operations = body.tech_operations;
    const first = parseFloat(body.tech_first);
    const second = parseFloat(body.tech_second);
    const third = parseFloat(body.tech_third);
    const f_unit = body.tech_f_unit;
    const s_unit = body.tech_s_unit;
    const t_unit = body.tech_t_unit;

    const response = {};

    function calculate(unit, value) {
      const map = {
        B: value / 1e6,
        kB: value / 1e3,
        MB: value * 1,
        GB: value * 1e3,
        TB: value * 1e6,
        PB: value * 1e9,
        EB: value * 1e12,
        ZB: value * 1e15,
        YB: value * 1e18,
        bit: value / 8e6,
        kbit: value * 0.000125,
        Mbit: value / 8,
        Gbits: value * 125,
        Tbit: value * 125000,
        KiB: value * 0.001024,
        MiB: value * 1.0486,
        GiB: value * 1073.7,
        TiB: value * 1099512,
        PiB: value * 1125899907,
        EiB: value * 1152921504607,
        ZiB: value * 1180591620717411,
        YiB: value * 1208925819614629175,
        Kibit: value * 0.000128,
        Mibit: value * 0.13107,
        Gibit: value * 134.22,
        Tibit: value * 137439,
      };
      return map[unit] ?? 0;
    }

    function tim(unit, value) {
      const map = {
        sec: value,
        min: value * 60,
        hrs: value * 3600,
        days: value * 86400,
        wks: value * 604800,
        mos: value * 2629800,
        yrs: value * 31557600,
      };
      return map[unit] ?? 0;
    }

    let jawab = 0;
    if (operations === "1") {
      if (first > 0 && second > 0) {
        const size = calculate(f_unit, first);
        const speed = calculate(s_unit, second);
        jawab = size / speed;
        const bandwidths = [
          28800, 56000, 256000, 512000, 1000000, 2000000, 8000000, 24000000,
          10000000, 100000000, 7200000, 80000000, 1000000000,
        ];

        bandwidths.forEach((bw, i) => {
          const filetime = (size * 1024 * 8) / bw;
          const hours = String(Math.floor(filetime / 3600)).padStart(2, "0");
          const minutes = String(Math.floor((filetime % 3600) / 60)).padStart(
            2,
            "0"
          );
          const seconds = String(Math.floor(filetime % 60)).padStart(2, "0");
          response[`f${i + 1}`] = `${hours}:${minutes}:${seconds}`;
        });
      } else {
        response.error =
          first <= 0
            ? "Please input a file size greater than 0."
            : "Please enter a positive download speed.";
        return response;
      }
    } else if (operations === "2") {
      if (first > 0 && third > 0) {
        const size = calculate(f_unit, first);
        const time = tim(t_unit, third);
        jawab = size / time;
      } else {
        response.error =
          first <= 0
            ? "Please input a file size greater than 0."
            : "Please enter a download time greater than 0.";
        return response;
      }
    } else if (operations === "3") {
      if (second > 0 && third > 0) {
        const speed = calculate(s_unit, second);
        const time = tim(t_unit, third);
        jawab = speed * time;
      } else {
        response.error =
          second <= 0
            ? "Please enter a positive download speed."
            : "Please enter a download time greater than 0.";
        return response;
      }
    } else {
      response.error = "Invalid operation";
      return response;
    }

    response.tech_jawab = Math.round(jawab);
    return response;
  }

  /**
   * getCalculationKdCalculator: Service Method
   * POST: /api/calculators-lol/kd-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationKdCalculator(body) {
    let kills = body.tech_kills;
    let deaths = body.tech_deaths;
    let assists = body.tech_assists;

    let param = {};
    // Helper function
    function isNumeric(value) {
      return !isNaN(parseFloat(value)) && isFinite(value);
    }
    // Validate kills and deaths
    if (isNumeric(kills) && isNumeric(deaths)) {
      if (kills > 0 && deaths > 0) {
        const kd_ratio = kills / deaths;

        if (assists !== undefined && assists !== "") {
          if (isNumeric(assists)) {
            if (assists > 0) {
              const kda_ratio = (kills + assists) / deaths;
              param.kda_ratio = kda_ratio;
            } else {
              return { error: "Enter Positive Value" };
            }
          } else {
            return { error: "Please! Check Your Input" };
          }
        }

        param.tech_kd_ratio = kd_ratio;
        return param;
      } else {
        return { error: "Enter Positive Value" };
      }
    } else {
      return { error: "Please! Check Your Input" };
    }
  }

  /**
   * getCalculationDataTransferCalculator: Service Method
   * POST: /api/calculators-lol/data-transfer-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDataTransferCalculator(body) {
    let first = body.tech_first;
    let f_unit = body.tech_f_unit;
    let second = body.tech_second;
    let s_unit = body.tech_s_unit;
    let kilo = body.tech_kilo;
    let overhead = body.tech_overhead;

    const param = {};

    function calculateHazar(a, b) {
      const conversions = {
        1: b / 1000000,
        2: b / 1000,
        3: b * 1,
        4: b * 1000,
        5: b * 1000000,
        6: b * 1000000000,
        7: b * 1000000000000,
        8: b * 1000000000000000,
        9: b * 1000000000000000000,
        10: b / 8000000,
        11: b * 0.000125,
        12: b / 8,
        13: b * 125,
        14: b * 125000,
        15: b * 0.001024,
        16: b * 1.0486,
        17: b * 1073.7,
        18: b * 1099512,
        19: b * 1125899907,
        20: b * 1152921504607,
        21: b * 1180591620717411,
        22: b * 1208925819614629175,
        23: b * 0.000128,
        24: b * 0.13107,
        25: b * 134.22,
        26: b * 137439,
      };
      return conversions[a] ?? b;
    }

    function calculateHazar24(a, b) {
      const conversions = {
        1: b / 1000024,
        2: b / 1024,
        3: b * 1,
        4: b * 1024,
        5: b * 1000024,
        6: b * 1000000024,
        7: b * 1000000000024,
        8: b * 1000000000000024,
        9: b * 1000000000000000024,
        10: b / 8000024,
        11: b * 0.000125,
        12: b / 8,
        13: b * 125,
        14: b * 125024,
        15: b * 0.001024,
        16: b * 1.0486,
        17: b * 1073.7,
        18: b * 1099512,
        19: b * 1125899907,
        20: b * 1152921504607,
        21: b * 1180591620717411,
        22: b * 1208925819614629175,
        23: b * 0.000128,
        24: b * 0.13107,
        25: b * 134.22,
        26: b * 137439,
      };
      return conversions[a] ?? b;
    }

    function formatTime(t) {
      const hours = String(Math.floor(t / 3600)).padStart(2, "0");
      const minutes = String(Math.floor((t % 3600) / 60)).padStart(2, "0");
      const seconds = String(Math.floor(t % 60)).padStart(2, "0");
      return `${hours}:${minutes}:${seconds}`;
    }

    if (isNaN(first) || isNaN(second)) {
      param.error = "Please check your input";
      return param;
    }

    let f1 = parseFloat(first);
    let s1 = parseFloat(second);

    const fUnit = parseInt(f_unit);
    const sUnit = parseInt(s_unit);
    const kiloVal = parseInt(kilo);
    const overheadVal = parseInt(overhead);

    if (kiloVal === 1) {
      f1 = calculateHazar24(fUnit, f1);
      s1 = calculateHazar24(sUnit, s1);
    } else if (kiloVal === 2) {
      f1 = calculateHazar(fUnit, f1);
      s1 = calculateHazar(fUnit, s1);
    }

    if (overheadVal === 2) f1 += f1 * 0.05;
    else if (overheadVal === 3) f1 += f1 * 0.1;
    else if (overheadVal === 4) f1 += f1 * 0.2;
    else if (overheadVal === 5) f1 += f1 * 0.3;
    else if (overheadVal === 6) f1 += f1 * 0.4;
    else if (overheadVal === 7) f1 += f1 * 0.5;

    if (f1 <= 0) {
      param.error = "Please input a file size greater than 0.";
      return param;
    }

    if (s1 <= 0) {
      param.error = "Please enter a positive download speed.";
      return param;
    }

    const jawab = Math.round(f1 / s1);
    const mainAns = formatTime(jawab);

    const bandwidths = [1.544, 10, 100, 1000, 10240, 480, 5120, 10240, 20480];
    const tableAns = bandwidths.map((bw) => {
      const filetime = (f1 * 1024 * 8) / (bw * 1024);
      return formatTime(filetime);
    });

    param.tech_jawab = jawab;
    param.tech_main_ans = mainAns;
    for (let i = 0; i < tableAns.length; i++) {
      param[`tech_f${i + 1}`] = tableAns[i];
    }

    return param;
  }

  /**
   * getCalculationWordsPerMinuteCalculator: Service Method
   * POST: /api/calculators-lol/words-per-minute-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationWordsPerMinuteCalculator(body) {
    let speak_speed = body.tech_speak_speed;
    let ss = body.tech_ss;
    let reading_speed = body.tech_reading_speed;
    let rs = body.tech_rs;
    let select = body.tech_select;
    let words = body.tech_words;
    let x = body.tech_x;

    const param = {};

    function formatTime(t, f = ":") {
      const hours = String(Math.floor(t / 3600)).padStart(2, "0");
      const minutes = String(Math.floor((t / 60) % 60)).padStart(2, "0");
      const seconds = String(Math.floor(t % 60)).padStart(2, "0");
      return `${hours}${f}${minutes}${f}${seconds}`;
    }

    if (!isNaN(ss) && !isNaN(rs)) {
      ss = parseFloat(ss);
      rs = parseFloat(rs);

      if (ss > 0) {
        if (rs > 0) {
          let speak_ans, read_ans;

          if (select == "1") {
            if (!isNaN(words)) {
              words = parseInt(words);
              if (words > 0) {
                speak_ans = words / ss;
                read_ans = words / rs;
              } else {
                param.error = "The number of words must be more than 0.";
                return param;
              }
            } else {
              param.error = "Please check your input";
              return param;
            }
          } else if (select == "2") {
            if (x && typeof x === "string" && x.trim().length > 0) {
              const para_words = x.trim().split(/\s+/).length;
              if (para_words > 0) {
                speak_ans = para_words / ss;
                read_ans = para_words / rs;
                param.tech_para_words = para_words;
              } else {
                param.error = "The number of words must be more than 0.";
                return param;
              }
            } else {
              param.error = "Please check your input";
              return param;
            }
          }

          const speak_time = formatTime(speak_ans * 60);
          const read_time = formatTime(read_ans * 60);

          param.tech_speak_ans = speak_ans;
          param.tech_read_ans = read_ans;
          param.tech_speak_time = speak_time;
          param.tech_read_time = read_time;

          return param;
        } else {
          param.error = "The reading speed must be more than 0.";
          return param;
        }
      } else {
        param.error = "The speaking speed must be more than 0.";
        return param;
      }
    } else {
      param.error = "Please check your input";
      return param;
    }
  }

  /**
   * getCalculationDeskHeightCalculator: Service Method
   * POST: /api/calculators-lol/desk-height-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDeskHeightCalculator(body) {
    let units = body.tech_units;
    let height = body.tech_height;
    let height2 = body.tech_height2;
    let position = body.tech_position;

    let unit;
    if (units === "Centimeters") {
      unit = 2.54;
      height = parseFloat(height);
    } else if (units === "Feet and Inches") {
      unit = 1;
      height = parseFloat(height2);
    }

    const seat_min = (0.3219306 * height) / 2.54 - 5.312559;
    const seat_max = (0.2715447 * height) / 2.54 - 0.1796748;
    const table_min = (0.4739837 * height) / 2.54 - 6.677846;
    const table_max = (0.5528455 * height) / 2.54 - 9.427033;
    const monitor_min = (0.7248521 * height) / 2.54 - 1.95858;
    const monitor_max = (0.7376726 * height) / 2.54 - 1.21499;
    const table_min_standing = (0.6005917 * height) / 2.54 + 0.02662722;
    const table_max_standing = (0.6656805 * height) / 2.54 - 1.044379;
    const monitor_min_standing = (0.9674556 * height) / 2.54 - 2.464497;
    const monitor_max_standing = (0.9349112 * height) / 2.54 + 1.071006;

    let ans1 = "";
    let ans2 = "";
    let ans3 = "";

    if (position === "0") {
      ans1 = `${Math.round(seat_min * unit * 2) / 2} - ${
        Math.round(seat_max * unit * 2) / 2
      }`;
      ans2 = `${Math.round(table_min * unit * 2) / 2} - ${
        Math.round(table_max * unit * 2) / 2
      }`;
      ans3 = `${Math.round(monitor_min * unit * 2) / 2} - ${
        Math.round(monitor_max * unit * 2) / 2
      }`;
    } else if (position === "1") {
      ans2 = `${Math.round(table_min_standing * unit * 2) / 2} - ${
        Math.round(table_max_standing * unit * 2) / 2
      }`;
      ans3 = `${Math.round(monitor_min_standing * unit * 2) / 2} - ${
        Math.round(monitor_max_standing * unit * 2) / 2
      }`;
    }

    return {
      tech_units: units,
      tech_position: position,
      tech_ans1: ans1,
      tech_ans2: ans2,
      tech_ans3: ans3,
    };
  }
  /**
   * getCalculationRingSizeCalculator: Service Method
   * POST: /api/calculators-lol/ring-size-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationRingSizeCalculator(body) {
    let unit = body.tech_unit;
    let cd = body.tech_to_measure;
    let dia_mm = body.tech_d_o_r_mm;
    let dia_in = body.tech_d_o_r_in;
    let cir_mm = body.tech_c_o_f_mm;
    let cir_in = body.tech_c_o_f_in;

    const param = {};
    let ring_size, uk_au, us_ca, f, g, j, s;
    if (
      !isNaN(cir_mm) &&
      !isNaN(cir_in) &&
      !isNaN(dia_mm) &&
      !isNaN(dia_in) &&
      cd !== "" &&
      unit !== ""
    ) {
      const pie = 3.14159;

      if (cd === "d_o_r") {
        if (unit === "millimeters") {
          ring_size = Math.round(dia_mm * pie * 100) / 100;
        } else if (unit === "inches") {
          ring_size = Math.round(dia_in * pie * 100) / 100;
        }
      } else if (cd === "c_o_f") {
        if (unit === "millimeters") {
          ring_size = Math.round((cir_mm / pie) * 100) / 100;
        } else if (unit === "inches") {
          ring_size = Math.round((cir_in / pie) * 1000) / 1000;
        }
      }

      if (
        ring_size == 9.91 ||
        ring_size == 0.388 ||
        ring_size == 31.13 ||
        ring_size == 1.23
      ) {
        us_ca = "0000";
        uk_au = "-";
        f = "-";
        g = "-";
        j = "-";
        s = "-";
      } else if (
        ring_size == 10.72 ||
        ring_size == 0.442 ||
        ring_size == 33.68 ||
        ring_size == 1.39
      ) {
        us_ca = "00";
        uk_au = "-";
        f = "-";
        g = "-";
        j = "-";
        s = "-";
      } else if (
        ring_size == 11.53 ||
        ring_size == 0.454 ||
        ring_size == 36.22 ||
        ring_size == 1.43
      ) {
        us_ca = "0";
        uk_au = "-";
        f = "-";
        g = "-";
        j = "-";
        s = "-";
      } else if (
        ring_size == 11.95 ||
        ring_size == 0.474 ||
        ring_size == 37.54 ||
        ring_size == 1.49
      ) {
        us_ca = "1/2";
        uk_au = "A";
        f = "-";
        g = "-";
        j = "-";
        s = "-";
      } else if (
        ring_size == 12.18 ||
        ring_size == 0.482 ||
        ring_size == 38.26 ||
        ring_size == 1.51
      ) {
        us_ca = "3/4";
        uk_au = "A 1/2";
        f = "-";
        g = "-";
        j = "-";
        s = "-";
      } else if (
        ring_size == 12.37 ||
        ring_size == 0.487 ||
        ring_size == 38.86 ||
        ring_size == 1.53
      ) {
        us_ca = "1";
        uk_au = "B";
        f = "-";
        g = "-";
        j = "1";
        s = "-";
      } else if (
        ring_size == 12.6 ||
        ring_size == 0.496 ||
        ring_size == 39.58 ||
        ring_size == 1.56
      ) {
        us_ca = "1 1/4";
        uk_au = "B 1/2";
        f = "-";
        g = "-";
        j = "1";
        s = "-";
      } else if (
        ring_size == 12.78 ||
        ring_size == 0.503 ||
        ring_size == 40.15 ||
        ring_size == 1.58
      ) {
        us_ca = "1 1/2";
        uk_au = "C";
        f = "-";
        g = "-";
        j = "-";
        s = "-";
      } else if (
        ring_size == 13.0 ||
        ring_size == 0.512 ||
        ring_size == 40.84 ||
        ring_size == 1.61
      ) {
        us_ca = "1 3/4";
        uk_au = "C 1/2";
        f = "-";
        g = "-";
        j = "-";
        s = "-";
      } else if (
        ring_size == 13.21 ||
        ring_size == 0.52 ||
        ring_size == 41.5 ||
        ring_size == 1.63
      ) {
        us_ca = "2";
        uk_au = "D";
        f = "41 1/2";
        g = "13 1/2";
        j = "2";
        s = "1 1/2";
      } else if (
        ring_size == 13.41 ||
        ring_size == 0.528 ||
        ring_size == 42.13 ||
        ring_size == 1.66
      ) {
        us_ca = "2 1/4";
        uk_au = "D 1/2";
        f = "-";
        g = "-";
        j = "-";
        s = "-";
      } else if (
        ring_size == 13.61 ||
        ring_size == 0.536 ||
        ring_size == 42.76 ||
        ring_size == 1.68
      ) {
        us_ca = "2 1/2";
        uk_au = "E";
        f = "42 3/4";
        g = "13 3/4";
        j = "3";
        s = "2 3/4";
      } else if (
        ring_size == 13.83 ||
        ring_size == 0.544 ||
        ring_size == 43.45 ||
        ring_size == 1.71
      ) {
        us_ca = "2 3/4";
        uk_au = "E 1/2";
        f = "-";
        g = "-";
        j = "-";
        s = "-";
      } else if (
        ring_size == 14.05 ||
        ring_size == 0.553 ||
        ring_size == 44.14 ||
        ring_size == 1.74
      ) {
        us_ca = "3";
        uk_au = "F";
        f = "44";
        g = "14";
        j = "4";
        s = "4";
      } else if (
        ring_size == 14.15 ||
        ring_size == 0.557 ||
        ring_size == 44.45 ||
        ring_size == 1.75
      ) {
        us_ca = "3 1/8";
        uk_au = "F 1/2";
        f = "-";
        g = "-";
        j = "-";
        s = "-";
      } else if (
        ring_size == 14.25 ||
        ring_size == 0.561 ||
        ring_size == 44.77 ||
        ring_size == 1.76
      ) {
        us_ca = "3 1/4";
        uk_au = "F 3/4";
        f = "-";
        g = "-";
        j = "-";
        s = "-";
      } else if (
        ring_size == 14.36 ||
        ring_size == 0.565 ||
        ring_size == 45.11 ||
        ring_size == 1.77
      ) {
        us_ca = "3 1/2";
        uk_au = "G 1/4";
        f = "45 1/4";
        g = "-";
        j = "5";
        s = "5 1/4";
      } else if (
        ring_size == 14.45 ||
        ring_size == 0.569 ||
        ring_size == 45.4 ||
        ring_size == 1.79
      ) {
        us_ca = "3 3/4";
        uk_au = "H";
        f = "46 1/2";
        g = "-";
        j = "-";
        s = "6 1/2";
      } else if (
        ring_size == 14.56 ||
        ring_size == 0.573 ||
        ring_size == 45.74 ||
        ring_size == 1.8
      ) {
        us_ca = "4";
        uk_au = "H 1/2";
        f = "-";
        g = "15";
        j = "7";
        s = "-";
      } else if (
        ring_size == 14.65 ||
        ring_size == 0.577 ||
        ring_size == 46.02 ||
        ring_size == 1.81
      ) {
        us_ca = "4 1/4";
        uk_au = "I";
        f = "47 3/4";
        g = "-";
        j = "-";
        s = "7 3/4";
      } else if (
        ring_size == 14.86 ||
        ring_size == 0.585 ||
        ring_size == 46.68 ||
        ring_size == 1.84
      ) {
        us_ca = "4 1/2";
        uk_au = "I 1/2";
        f = "-";
        g = "15 1/4";
        j = "8";
        s = "-";
      } else if (
        ring_size == 15.04 ||
        ring_size == 0.592 ||
        ring_size == 47.25 ||
        ring_size == 1.86
      ) {
        us_ca = "4 5/8";
        uk_au = "J";
        f = "49";
        g = "15 1/2";
        s = "9";
        j = "-";
      } else if (
        ring_size == 15.27 ||
        ring_size == 0.601 ||
        ring_size == 47.97 ||
        ring_size == 1.89
      ) {
        us_ca = "5";
        uk_au = "J 1/2";
        f = "-";
        g = "15 3/4";
        s = "-";
        j = "9";
      } else if (
        ring_size == 15.4 ||
        ring_size == 0.606 ||
        ring_size == 48.38 ||
        ring_size == 1.9
      ) {
        us_ca = "5 1/8";
        uk_au = "K";
        f = "50";
        g = "-";
        s = "10";
        j = "-";
      } else if (
        ring_size == 15.53 ||
        ring_size == 0.611 ||
        ring_size == 48.79 ||
        ring_size == 1.92
      ) {
        us_ca = "4 3/4";
        uk_au = "J 1/4";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 15.7 ||
        ring_size == 0.618 ||
        ring_size == 49.32 ||
        ring_size == 1.94
      ) {
        us_ca = "3 3/8";
        uk_au = "G";
        f = "-";
        g = "14 1/2";
        s = "-";
        j = "-";
      } else if (
        ring_size == 15.8 ||
        ring_size == 0.622 ||
        ring_size == 49.64 ||
        ring_size == 1.95
      ) {
        us_ca = "5 3/8";
        uk_au = "K 1/2";
        f = "-";
        g = "10";
        s = "-";
        j = "-";
      } else if (
        ring_size == 15.9 ||
        ring_size == 0.626 ||
        ring_size == 49.95 ||
        ring_size == 1.97
      ) {
        us_ca = "5 1/4";
        uk_au = "K 1/4";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 16.0 ||
        ring_size == 0.63 ||
        ring_size == 50.27 ||
        ring_size == 1.98
      ) {
        us_ca = "5 3/8";
        uk_au = "K 1/2";
        f = "-";
        g = "-";
        s = "-";
        j = "10";
      } else if (
        ring_size == 16.1 ||
        ring_size == 0.634 ||
        ring_size == 50.58 ||
        ring_size == 1.99
      ) {
        us_ca = "5 1/2";
        uk_au = "L";
        f = "51 3/4";
        g = "16";
        s = "11 3/4";
        j = "-";
      } else if (
        ring_size == 16.3 ||
        ring_size == 0.642 ||
        ring_size == 51.21 ||
        ring_size == 2.02
      ) {
        us_ca = "5 3/4";
        uk_au = "L 1/4";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 16.41 ||
        ring_size == 0.646 ||
        ring_size == 51.55 ||
        ring_size == 2.03
      ) {
        us_ca = "5 7/8";
        uk_au = "L 1/2";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 16.51 ||
        ring_size == 0.65 ||
        ring_size == 51.87 ||
        ring_size == 2.04
      ) {
        us_ca = "6";
        uk_au = "M";
        f = "52 3/4";
        g = "16 1/2";
        s = "12 3/4";
        j = "12";
      } else if (
        ring_size == 16.71 ||
        ring_size == 0.658 ||
        ring_size == 51.5 ||
        ring_size == 2.07
      ) {
        us_ca = "6 1/4";
        uk_au = "M 1/2";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 16.92 ||
        ring_size == 0.666 ||
        ring_size == 53.16 ||
        ring_size == 2.09
      ) {
        us_ca = "6 1/2";
        uk_au = "N";
        f = "54";
        g = "17";
        s = "14";
        j = "13";
      } else if (
        ring_size == 17.13 ||
        ring_size == 0.674 ||
        ring_size == 53.82 ||
        ring_size == 2.12
      ) {
        us_ca = "6 3/4";
        uk_au = "N 1/2";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 17.35 ||
        ring_size == 0.683 ||
        ring_size == 54.51 ||
        ring_size == 2.15
      ) {
        us_ca = "7";
        uk_au = "O";
        f = "55 1/4";
        g = "17 1/4";
        s = "15 1/4";
        j = "14";
      } else if (
        ring_size == 17.45 ||
        ring_size == 0.687 ||
        ring_size == 54.82 ||
        ring_size == 2.16
      ) {
        us_ca = "7 1/4";
        uk_au = "O 1/2";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 17.75 ||
        ring_size == 0.699 ||
        ring_size == 55.76 ||
        ring_size == 2.2
      ) {
        us_ca = "7 1/2";
        uk_au = "P";
        f = "56 1/2";
        g = "17 3/4";
        s = "16 1/2";
        j = "15";
      } else if (
        ring_size == 17.97 ||
        ring_size == 0.707 ||
        ring_size == 56.45 ||
        ring_size == 2.22
      ) {
        us_ca = "7 3/4";
        uk_au = "P 1/2";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 18.19 ||
        ring_size == 0.716 ||
        ring_size == 57.15 ||
        ring_size == 2.25
      ) {
        us_ca = "8";
        uk_au = "Q";
        f = "57 3/4";
        g = "18";
        s = "17 3/4";
        j = "16";
      } else if (
        ring_size == 18.35 ||
        ring_size == 0.722 ||
        ring_size == 57.65 ||
        ring_size == 2.27
      ) {
        us_ca = "8 1/4";
        uk_au = "Q 1/2";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 18.53 ||
        ring_size == 0.729 ||
        ring_size == 58.21 ||
        ring_size == 2.29
      ) {
        us_ca = "8 1/2";
        uk_au = "Q 3/4";
        f = "-";
        g = "18 1/2";
        s = "-";
        j = "17";
      } else if (
        ring_size == 18.61 ||
        ring_size == 0.733 ||
        ring_size == 58.47 ||
        ring_size == 2.3
      ) {
        us_ca = "8 5/8";
        uk_au = "R";
        f = "59";
        g = "14 1/2";
        s = "19";
        j = "-";
      } else if (
        ring_size == 18.69 ||
        ring_size == 0.736 ||
        ring_size == 58.72 ||
        ring_size == 2.31
      ) {
        us_ca = "8 3/4";
        uk_au = "R 1/4";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 18.8 ||
        ring_size == 0.738 ||
        ring_size == 59.06 ||
        ring_size == 2.32
      ) {
        us_ca = "8 7/8";
        uk_au = "R 1/2";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 18.89 ||
        ring_size == 0.748 ||
        ring_size == 59.34 ||
        ring_size == 2.35
      ) {
        us_ca = "9";
        uk_au = "R 3/4";
        f = "-";
        g = "19";
        s = "-";
        j = "18";
      } else if (
        ring_size == 19.1 ||
        ring_size == 0.752 ||
        ring_size == 60.0 ||
        ring_size == 2.36
      ) {
        us_ca = "9 1/8";
        uk_au = "S";
        f = "60 1/4";
        g = "-";
        s = "20 1/4";
        j = "-";
      } else if (
        ring_size == 19.22 ||
        ring_size == 0.757 ||
        ring_size == 60.38 ||
        ring_size == 2.38
      ) {
        us_ca = "9 1/4";
        uk_au = "S 1/4";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 19.31 ||
        ring_size == 0.761 ||
        ring_size == 60.66 ||
        ring_size == 2.39
      ) {
        us_ca = "9 3/8";
        uk_au = "S 1/2";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 19.41 ||
        ring_size == 0.764 ||
        ring_size == 60.98 ||
        ring_size == 2.4
      ) {
        us_ca = "9 1/2";
        uk_au = "S 3/4";
        f = "-";
        g = "19 1/2";
        s = "-";
        j = "19";
      } else if (
        ring_size == 19.51 ||
        ring_size == 0.768 ||
        ring_size == 61.29 ||
        ring_size == 2.41
      ) {
        us_ca = "9 5/8";
        uk_au = "T";
        f = "61 1/2";
        g = "-";
        s = "21 1/2";
        j = "-";
      } else if (
        ring_size == 19.62 ||
        ring_size == 0.772 ||
        ring_size == 61.64 ||
        ring_size == 2.43
      ) {
        us_ca = "9 3/4";
        uk_au = "T 1/4";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 19.84 ||
        ring_size == 0.781 ||
        ring_size == 62.33 ||
        ring_size == 2.45
      ) {
        us_ca = "10";
        uk_au = "T 1/2";
        f = "-";
        g = "20";
        s = "-";
        j = "20";
      } else if (
        ring_size == 20.02 ||
        ring_size == 0.788 ||
        ring_size == 62.89 ||
        ring_size == 2.48
      ) {
        us_ca = "10 1/4";
        uk_au = "U";
        f = "62 3/4";
        g = "_";
        s = "22 3/4";
        j = "21";
      } else if (
        ring_size == 20.2 ||
        ring_size == 0.797 ||
        ring_size == 63.46 ||
        ring_size == 2.5
      ) {
        us_ca = "10 1/2";
        uk_au = "U 1/2";
        f = "-";
        g = "20 1/4";
        s = "-";
        j = "22";
      } else if (
        ring_size == 20.32 ||
        ring_size == 0.8 ||
        ring_size == 63.84 ||
        ring_size == 2.51
      ) {
        us_ca = "10 5/8";
        uk_au = "V";
        f = "63";
        g = "-";
        s = "23 3/4";
        j = "-";
      } else if (
        ring_size == 20.44 ||
        ring_size == 0.805 ||
        ring_size == 64.21 ||
        ring_size == 2.53
      ) {
        us_ca = "10 3/4";
        uk_au = "V 1/4";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 20.68 ||
        ring_size == 0.814 ||
        ring_size == 64.97 ||
        ring_size == 2.56
      ) {
        us_ca = "11";
        uk_au = "V 1/2";
        f = "-";
        g = "20 3/4";
        s = "-";
        j = "23";
      } else if (
        ring_size == 20.76 ||
        ring_size == 0.817 ||
        ring_size == 65.22 ||
        ring_size == 2.57
      ) {
        us_ca = "11 1/8";
        uk_au = "W";
        f = "65";
        g = "-";
        s = "25";
        j = "-";
      } else if (
        ring_size == 20.85 ||
        ring_size == 0.821 ||
        ring_size == 65.5 ||
        ring_size == 2.58
      ) {
        us_ca = "11 1/4";
        uk_au = "W 1/4";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 20.94 ||
        ring_size == 0.824 ||
        ring_size == 65.78 ||
        ring_size == 2.59
      ) {
        us_ca = "11 3/8";
        uk_au = "W 1/2";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 21.08 ||
        ring_size == 0.83 ||
        ring_size == 66.22 ||
        ring_size == 2.61
      ) {
        us_ca = "11 1/2";
        uk_au = "W 3/4";
        f = "-";
        g = "21";
        s = "-";
        j = "24";
      } else if (
        ring_size == 21.18 ||
        ring_size == 0.834 ||
        ring_size == 66.54 ||
        ring_size == 2.62
      ) {
        us_ca = "11 5/8";
        uk_au = "X";
        f = "66 1/4";
        g = "-";
        s = "26 1/4";
        j = "-";
      } else if (
        ring_size == 21.24 ||
        ring_size == 0.836 ||
        ring_size == 66.73 ||
        ring_size == 2.63
      ) {
        us_ca = "11 3/4";
        uk_au = "X 1/4";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 21.3 ||
        ring_size == 0.839 ||
        ring_size == 66.92 ||
        ring_size == 2.64
      ) {
        us_ca = "11 7/8";
        uk_au = "X 1/2";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 21.49 ||
        ring_size == 0.846 ||
        ring_size == 67.51 ||
        ring_size == 2.66
      ) {
        us_ca = "12";
        uk_au = "Y";
        f = "67 1/2";
        g = "21 1/4";
        s = "27 1/2";
        j = "25";
      } else if (
        ring_size == 21.69 ||
        ring_size == 0.854 ||
        ring_size == 68.14 ||
        ring_size == 2.68
      ) {
        us_ca = "12 1/4";
        uk_au = "Y 1/2";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 21.89 ||
        ring_size == 0.862 ||
        ring_size == 68.77 ||
        ring_size == 2.71
      ) {
        us_ca = "12 1/2";
        uk_au = "Z";
        f = "68 3/4";
        g = "21 3/4";
        s = "28 3/4";
        j = "26";
      } else if (
        ring_size == 22.1 ||
        ring_size == 0.869 ||
        ring_size == 69.43 ||
        ring_size == 2.73
      ) {
        us_ca = "12 3/4";
        uk_au = "Z +1/2";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 22.33 ||
        ring_size == 0.879 ||
        ring_size == 70.15 ||
        ring_size == 2.76
      ) {
        us_ca = "13";
        uk_au = "Z+1";
        f = "-";
        g = "22";
        s = "-";
        j = "27";
      } else if (
        ring_size == 22.6 ||
        ring_size == 0.891 ||
        ring_size == 71 ||
        ring_size == 2.8
      ) {
        us_ca = "13 1/2";
        uk_au = "Z + 1.5";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      }

      return {
        tech_ring_size: ring_size,
        tech_uk_au: uk_au,
        tech_us_ca: us_ca,
        tech_f: f,
        tech_g: g,
        tech_j: j,
        tech_s: s,
        tech_unit: unit,
      };
    } else {
      param.error = "Please check your input";
      return param;
    }
  }

  /**
   * getCalculationShoeSizeCalculator: Service Method
   * POST: /api/calculators-lol/shoe-size-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationShoeSizeCalculator(body) {
    const result = {};

    // Separate input variables from body
    let gen = (body.tech_gen || "").trim();
    let country = (body.tech_country || "").trim();
    let size = parseFloat(body.tech_size || 0);

    // Validate input
    if (!isNaN(size) && size >= 0) {
      let fcm, fin, us, uk, eu, ko, wo, m, mj;

      if (country === "fcm") {
        fcm = size;
      } else if (country === "fin") {
        fcm = size * 2.54;
      } else if (country === "ko") {
        fcm = size / 10;
      } else if (country === "mj") {
        fcm = size;
      } else if (country === "m") {
        fcm = size / 10;
      }

      if (gen === "ad") {
        if (country === "us") {
          fcm = (size + 24) * 0.847 - 2 * 0.847;
        } else if (country === "uk") {
          fcm = (size + 25) * 0.847 - 2 * 0.847;
        } else if (country === "eu") {
          fcm = size * 0.667 - 2 * 0.667;
        }

        fin = fcm / 2.54;
        us = (fcm + 2 * 0.847) / 0.847 - 24;
        ko = ((us + 22) / 3) * 25.5;
        wo = (fcm + 2 * 0.847) / 0.847 - 23;
        uk = fin * 3 - 23;
        eu = Math.floor(1.27 * (uk + 23 + 2));
        m = fcm * 10;
        mj = fcm;
      } else if (gen === "c") {
        if (country === "us") {
          fcm = ((size + 11.5 - 0.4) * 0.847) / 1.08;
        } else if (country === "uk") {
          fcm = ((size + 12 - 0.4) * 0.847) / 1.08;
        } else if (country === "eu") {
          fcm = (size * 0.667) / 1.08;
        }

        ko = fcm * 10;
        fin = fcm / 2.54;
        us = (fcm * 1.08) / 0.847 - 11.5 + 0.4;
        uk = (fcm * 1.08) / 0.847 - 12 + 0.4;
        eu = (fcm + 2 * 0.667) / 0.667;
        m = fcm * 10;
        mj = fcm;
        wo = "not yet";
      }

      result.tech_us = us;
      result.tech_fcm = fcm;
      result.tech_fin = fin;
      result.tech_uk = uk;
      result.tech_eu = eu;
      result.tech_ko = ko;
      result.tech_wo = wo;
      result.tech_m = m;
      result.tech_mj = mj;
      result.tech_country = country;
      result.tech_gen = gen;
    } else {
      result.error = "Please! Check Your Input";
    }

    return result;
  }

  /**
   * getCalculationCurtainSizeCalculator: Service Method
   * POST: /api/calculators-lol/curtain-size-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCurtainSizeCalculator(body) {
    let type_curtain = (body.tech_type_curtain || "").trim();
    let fullness = (body.tech_fullness || "").trim();
    let w_height = parseFloat(body.tech_w_height);
    let w_width = parseFloat(body.tech_w_width);
    let wh_units = (body.tech_wh_units || "").trim();
    let ww_units = (body.tech_ww_units || "").trim();

    let result = {};

    if (!type_curtain) {
      result.error = "Please! Check Your Inputs";
      return result;
    }

    if (!isFinite(w_height) || !isFinite(w_width)) {
      result.error = "Please! Check Your Inputs";
      return result;
    }

    // Convert height units to inches
    if (wh_units === "mm") {
      w_height = w_height * 25.4;
    } else if (wh_units === "cm") {
      w_height = w_height * 2.54;
    } else if (wh_units === "m") {
      w_height = w_height / 39.37;
    } else if (wh_units === "ft") {
      w_height = w_height / 12;
      console.log(w_height);
    } else if (wh_units === "yd") {
      w_height = w_height / 36;
    }

    // Convert width units to inches
    if (ww_units === "mm") {
      w_width = w_width * 25.4;
    } else if (ww_units === "cm") {
      w_width = w_width * 2.54;
    } else if (ww_units === "m") {
      w_width = w_width / 39.37;
    } else if (ww_units === "ft") {
      w_width = w_width / 12;
    } else if (ww_units === "yd") {
      w_width = w_width / 36;
    }

    let c_lenght = 0;
    if (type_curtain === "sill_lenght") {
      c_lenght = w_height + 4;
    } else if (type_curtain === "cafe_length") {
      c_lenght = w_height / 2;
    } else if (type_curtain === "extra_long") {
      c_lenght = w_height + 4 + 6;
    }

    let c_width = 0;
    if (fullness === "std_full") {
      c_width = w_width * 2;
    } else if (fullness === "del_full") {
      c_width = w_width * 2.5;
    } else if (fullness === "ult_full") {
      c_width = w_width * 3;
    }

    result.tech_type_curtain = type_curtain;
    result.tech_w_height = w_height;
    result.tech_w_width = w_width;
    result.tech_c_lenght = c_lenght;
    result.tech_c_width = c_width;
    return result;
  }

  /**
   * getCalculationTeslaChargingCalculator: Service Method
   * POST: /api/calculators-lol/tesla-charging-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTeslaChargingCalculator(body) {
    let main_unit = (body.tech_main_unit || "").trim();
    let battery = parseFloat(body.tech_battery);
    let electricity = parseFloat(body.tech_electricity);
    let type = (body.tech_type || "").trim();
    let price = parseFloat(body.tech_price);
    let distance = parseFloat(body.tech_distance);
    let units = (body.tech_units || "").trim();

    let result = {};

    if (main_unit === "Full Capacity Charging Cost") {
      if (isFinite(battery) && isFinite(electricity)) {
        let cost = battery * electricity;
        result.tech_cost = cost;
      } else {
        result.error = "Please! Check Your Inputs";
        return result;
      }
    } else if (main_unit === "Custom Distance Charging Cost") {
      const Model = {
        1: { name: "Tesla Model S (2013 - 60D)", capacity: 60, efficiency: 35 },
        2: { name: "Tesla Model S (2016 - 60D)", capacity: 62, efficiency: 32 },
        3: {
          name: "Tesla Model S (2017 - 100D)",
          capacity: 95,
          efficiency: 33,
        },
        4: { name: "Tesla Model 3 (2019)", capacity: 54, efficiency: 26 },
        5: { name: "Tesla Model 3 (2021)", capacity: 82, efficiency: 29 },
        6: { name: "Tesla Model X (2016 - 90D)", capacity: 90, efficiency: 34 },
        7: {
          name: "Tesla Model X (2016 - P100D)",
          capacity: 100,
          efficiency: 38,
        },
        8: { name: "Tesla Model Y (2021)", capacity: 75, efficiency: 24 },
        9: { name: "Chevrolet Bolt (2016)", capacity: 60, efficiency: 20.8 },
        10: { name: "Audi Q4 e-tron 50 quattro", capacity: 77, efficiency: 32 },
        11: { name: "Nissan Leaf", capacity: 36, efficiency: 28 },
        12: {
          name: "Hyundai IONIQ Electric",
          capacity: 38.3,
          efficiency: 24.5,
        },
        13: { name: "Citroen e-C4", capacity: 45, efficiency: 29 },
        14: { name: "Kia EV6", capacity: 58, efficiency: 26.5 },
        15: { name: "Kia Soul EV", capacity: 64, efficiency: 28 },
        16: { name: "BMW i3", capacity: 37.9, efficiency: 26 },
        17: { name: "BMW i4", capacity: 80, efficiency: 29 },
        18: { name: "Fiat 500e", capacity: 42, efficiency: 27.5 },
        19: { name: "Hyundai Kona Electric", capacity: 64, efficiency: 26 },
      };

      if (!type || !Model[type]) {
        result.error = "Please! Check Your Inputs";
        return result;
      }

      if (!isFinite(price) || !isFinite(distance)) {
        result.error = "Please! Check Your Inputs";
        return result;
      }

      let model = Model[type];
      let name = model.name;
      let capacity = model.capacity;
      let efficiency = model.efficiency;

      if (units === "mi") {
        distance = distance * 1.609; // Convert miles to km
      }

      efficiency = efficiency * 0.621; // Convert km/kw to mi/kw

      let cost = price * capacity;
      let res = price * distance * efficiency;
      let ec = res / 100;

      result.tech_name = name;
      result.tech_capacity = capacity;
      result.tech_efficiency = efficiency;
      result.tech_cost = cost;
      result.tech_ec = ec;
    } else {
      result.error = "Please! Check Your Inputs";
      return result;
    }
    return result;
  }

  /**
   * getCalculationCompressionHightCalculator: Service Method
   * POST: /api/calculators-lol/compression-height-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCompressionHightCalculator(body) {
    let height = parseFloat(body.tech_height);
    let height_unit = (body.tech_height_unit || "").trim();
    let stone = parseFloat(body.tech_stone);
    let stone_unit = (body.tech_stone_unit || "").trim();
    let length = parseFloat(body.tech_length);
    let length_unit = (body.tech_length_unit || "").trim();
    let deck = parseFloat(body.tech_deck);
    let deck_unit = (body.tech_deck_unit || "").trim();

    function unitIn(value, unit) {
      return unit === "in" ? value : value * 39.37;
    }

    let result = {};

    if (
      isFinite(height) &&
      isFinite(stone) &&
      isFinite(length) &&
      isFinite(deck)
    ) {
      height = unitIn(height, height_unit);
      length = unitIn(length, length_unit);
      stone = unitIn(stone, stone_unit);
      deck = unitIn(deck, deck_unit);

      let compression_val = height - 0.5 * stone - length - deck;
      let compression_val_m = compression_val / 39.37;

      result.tech_compression_val = compression_val;
      result.tech_compression_val_m = compression_val_m;
    } else {
      result.error = "Please! Check Your Inputs";
      return result;
    }

    return result;
  }

  /**
   * getCalculationFuelCostCalculator: Service Method
   * POST: /api/calculators-lol/fuel-cost-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationFuelCostCalculator(body) {
    let distance = parseFloat(body.tech_distance);
    let d_units = (body.tech_d_units || "").trim();
    let f_efficiency = parseFloat(body.tech_f_efficiency);
    let f_eff_units = (body.tech_f_eff_units || "").trim();
    let f_price = parseFloat(body.tech_f_price);
    let f_p_units = (body.tech_f_p_units || "").trim();
    let currency = (body.tech_currancy || "").trim();

    let result = {};

    // Clean up currency from price unit (e.g., "$/L" -> "/L")
    f_p_units = f_p_units.replace(currency, "");

    if (isFinite(distance) && isFinite(f_efficiency) && isFinite(f_price)) {
      // Convert distance to kilometers if in miles
      if (d_units === "mi") {
        distance *= 1.6093;
      }

      // Convert fuel efficiency to km per liter
      if (f_eff_units === "L/100km") {
        f_efficiency = 100 / f_efficiency;
      } else if (f_eff_units === "US mpg") {
        f_efficiency = f_efficiency * 0.425144;
      } else if (f_eff_units === "UK mpg") {
        f_efficiency = f_efficiency * 0.354006;
      } else if (f_eff_units === "lpm") {
        f_efficiency = (1 / f_efficiency) * 1.6093;
      }

      // Convert fuel price to per liter
      if (f_p_units === "/cl") {
        f_price = f_price * 100;
      } else if (f_p_units === "/US gal") {
        f_price = f_price * 0.26;
      } else if (f_p_units === "/UK gal") {
        f_price = f_price * 0.22;
      }

      let fuel = distance / f_efficiency;
      let trip_cost = fuel * f_price;

      result.tech_distance = distance;
      result.tech_f_efficiency = f_efficiency;
      result.tech_f_eff_units = f_eff_units;
      result.tech_f_p_units = f_p_units;
      result.tech_f_price = f_price;
      result.tech_fuel = fuel;
      result.tech_trip_cost = trip_cost;
    } else {
      result.error = "Please! Check Your Inputs";
    }

    return result;
  }

  /**
   * getCalculationLawnMowingCostCalculator: Service Method
   * POST: /api/calculators-lol/lawn-mowing-cost-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLawnMowingCostCalculator(body) {
    let type = (body.tech_type || "").trim();
    let charges = (body.tech_charges || "").trim();
    let mow_price = parseFloat(body.tech_mow_price);
    let m_p_units = (body.tech_m_p_units || "").trim();
    let currancy = (body.tech_currancy || "").trim();
    let area_mow = parseFloat(body.tech_area_mow);
    let a_m_units = (body.tech_a_m_units || "").trim();
    let hours_work = parseFloat(body.tech_hours_work);
    let mow_speed = parseFloat(body.tech_mow_speed);
    let mow_speed_units = (body.tech_mow_speed_units || "").trim();
    let mow_width = parseFloat(body.tech_mow_width);
    let mow_width_units = (body.tech_mow_width_units || "").trim();
    let mow_pro = parseFloat(body.tech_mow_pro);
    let to_mow = parseFloat(body.tech_to_mow);
    let to_mow_units = (body.tech_to_mow_units || "").trim();

    m_p_units = m_p_units.replace(currancy + " ", "");

    let result = {};

    function perAreaUnit(input, unit) {
      if (unit === "m²") input = input / 1000000;
      else if (unit === "ft²") input = input / 10760000;
      else if (unit === "yd²") input = input / 1196000;
      else if (unit === "a") input = input * 0.0001;
      else if (unit === "da") input = input * 0.001;
      else if (unit === "ha") input = input / 100;
      else if (unit === "ac") input = input / 247.1;
      return input;
    }

    if (type === "lawn_mowed") {
      if (charges === "area") {
        if (isFinite(mow_price) && isFinite(area_mow)) {
          if (m_p_units) mow_price = perAreaUnit(mow_price, m_p_units);
          if (a_m_units) area_mow = perAreaUnit(area_mow, a_m_units);
          let total_cost = mow_price * area_mow;

          result.tech_mow_price = mow_price;
          result.tech_area_mow = area_mow;
          result.tech_total_cost = total_cost;
        } else {
          return { error: "Please! Check Your Input" };
        }
      } else if (charges === "hour") {
        if (isFinite(mow_price) && isFinite(hours_work)) {
          let total_cost = mow_price * hours_work;
          result.tech_mow_price = mow_price;
          result.tech_hours_work = hours_work;
          result.tech_total_cost = total_cost;
        } else {
          return { error: "Please! Check Your Input" };
        }
      }

      result.charges = charges;
    } else if (type === "mowing_time") {
      if (isFinite(mow_speed) && isFinite(mow_width) && isFinite(mow_pro)) {
        if (mow_speed_units === "m/h") {
          mow_speed /= 1000;
        } else if (mow_speed_units === "ft/h") {
          mow_speed /= 3281;
        }

        if (mow_width_units === "cm") {
          mow_width /= 100000;
        } else if (mow_width_units === "m") {
          mow_width /= 1000;
        } else if (mow_width_units === "in") {
          mow_width /= 39370;
        } else if (mow_width_units === "ft") {
          mow_width /= 3281;
        }

        let res = mow_speed * mow_width;
        let per = mow_pro / 100;
        let m_cost = res * per;

        result.tech_mow_speed = mow_speed;
        result.tech_mow_width = mow_width;
        result.tech_mow_pro = mow_pro;
        result.tech_m_cost = m_cost;

        if (!isNaN(to_mow)) {
          if (to_mow_units) {
            to_mow = perAreaUnit(to_mow, to_mow_units);
          }
          let m_time = to_mow / m_cost;
          let hours = Math.floor(m_time);
          let minutes = Math.floor((m_time - hours) * 60);
          result.tech_to_mow = to_mow;
          result.tech_hours = hours;
          result.tech_minutes = minutes;
        }
      } else {
        return { error: "Please! Check Your Input" };
      }
    }

    result.tech_type = type;
    return result;
  }

  /**
   * getCalculationTvSizeCalculator: Service Method
   * POST: /api/calculators-lol/tv-size-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTvSizeCalculator(body) {
    let selection = body.tech_selection;
    let size = body.tech_size;
    let size_unit = body.tech_size_unit;
    let resolution = body.tech_resolution;
    let angle = body.tech_angle;
    let angle_unit = body.tech_angle_unit;
    let distance = body.tech_distance;
    let distance_unit = body.tech_distance_unit;

    // Helper function to get total vertical pixels from resolution keyword
    function getPixelValue(resolution) {
      const pixelMap = {
        "480p": 480,
        "720p": 720,
        "1080p": 1080,
        ultra_hd: 2160,
        "4k": 2160,
        "8k": 4320,
      };
      return pixelMap[resolution] || 0;
    }

    // Helper to round to significant figures
    function sigFig(value, digits) {
      if (value !== "") {
        if (value === 0) return parseFloat(value.toFixed(digits - 1));
        let decimalPlaces =
          digits - Math.floor(Math.log10(Math.abs(value))) - 1;
        decimalPlaces = Math.max(decimalPlaces, 0); // Prevent negative decimals
        return parseFloat(value.toFixed(decimalPlaces));
      }
      return "";
    }

    let param = {};

    // Parse input numbers
    let sizeFloat = parseFloat(size);
    let distanceFloat = parseFloat(distance);
    let angleFloat = parseFloat(angle);

    // Output variables
    let width, height, pixels, new_angle, md, unit;
    let md_cm,
      md_m,
      md_ft,
      od = "",
      od_cm = "",
      od_m = "",
      od_ft = "";

    if (selection === "size") {
      // If calculating from screen size
      if (!isNaN(sizeFloat) && size_unit && resolution) {
        // Convert input size to inches
        if (size_unit === "cm") sizeFloat /= 2.54;
        else if (size_unit === "m") sizeFloat /= 0.0254;
        else if (size_unit === "ft") sizeFloat /= 0.08333;

        width = (16 / Math.sqrt(16 ** 2 + 9 ** 2)) * sizeFloat;
        height = sizeFloat * 0.49;

        pixels = (16 / 9) * getPixelValue(resolution);
        new_angle = pixels / 60;

        md = width / (2 * Math.tan((new_angle / 2) * (Math.PI / 180)));
        unit = size_unit;

        md_cm = md * 2.54;
        md_m = md * 0.0254;
        md_ft = md * 0.08333;
      } else {
        return { error: "Please! Check Your Input" };
      }
    } else if (selection === "distance") {
      // If calculating from distance
      if (!isNaN(distanceFloat) && distance_unit && resolution) {
        const jugaadValues = {
          "480p": 0.28616,
          "720p": 0.4322,
          "1080p": 0.658,
          ultra_hd: 1.434,
          "4k": 1.5556,
          "8k": 4.705,
        };
        const jugaad = jugaadValues[resolution];
        if (!jugaad) return { error: "Unsupported resolution" };

        pixels = (16 / 9) * getPixelValue(resolution);
        new_angle = pixels / 60;

        width =
          distanceFloat * (2 * Math.tan((new_angle / 2) * (Math.PI / 180)));
        width = width / 0.08333;

        sizeFloat = distanceFloat * jugaad;
        sizeFloat = sizeFloat / 0.08333;

        height = sizeFloat * 0.49;
        md = distanceFloat;
        unit = distance_unit;

        md_cm = md * 30.5;
        md_m = md * 0.305;
        md_ft = md;
        md = md * 12;
      } else {
        return { error: "Please! Check Your Input" };
      }
    } else {
      return { error: "Please! Check Your Input" };
    }

    // Calculate optimal viewing distance based on visual angle
    if (!isNaN(angleFloat) && angle_unit) {
      let angleRad =
        angle_unit === "deg" ? angleFloat * (Math.PI / 180) : angleFloat;
      if (angleRad > Math.PI) {
        return {
          error:
            "Flat screens have a 180° field of vision; you can't see beyond that angle (unless your nose is touching it 😉).",
        };
      }

      let tanVal = Math.tan(angleRad / 2);
      od = (0.5 * width) / tanVal;

      od_cm = od * 2.54;
      od_m = od * 0.0254;
      od_ft = od * 0.08333;
    }

    // Unit conversions
    let size_cm = sizeFloat * 2.54;
    let size_m = sizeFloat * 0.0254;
    let size_ft = sizeFloat * 0.08333;

    let width_cm = width * 2.54;
    let width_m = width * 0.0254;
    let width_ft = width * 0.08333;

    let height_cm = height * 2.54;
    let height_m = height * 0.0254;
    let height_ft = height * 0.08333;

    // Final formatted answer
    const ans = [
      sigFig(sizeFloat, 4),
      sigFig(width, 4),
      sigFig(height, 4),
      sigFig(od_ft, 3),
      sigFig(md_ft, 3),
    ];

    return {
      tech_ans: ans,
      tech_unit: unit,
      tech_units_cm: [
        sigFig(size_cm, 4),
        sigFig(width_cm, 4),
        sigFig(height_cm, 4),
        sigFig(od_cm, 3),
        sigFig(md_cm, 3),
      ],
      tech_units_m: [
        sigFig(size_m, 4),
        sigFig(width_m, 4),
        sigFig(height_m, 4),
        sigFig(od_m, 3),
        sigFig(md_m, 3),
      ],
      tech_units_in: [
        sigFig(sizeFloat, 4),
        sigFig(width, 4),
        sigFig(height, 4),
        sigFig(od, 3),
        sigFig(md, 3),
      ],
      tech_units_ft: [
        sigFig(size_ft, 4),
        sigFig(width_ft, 4),
        sigFig(height_ft, 4),
        sigFig(od_ft, 3),
        sigFig(md_ft, 3),
      ],
    };
  }

  /**
   * getCalculationRiverRockCalculator: Service Method
   * POST: /api/calculators-lol/river-rock-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRiverRockCalculator(body) {
    let rock_type = body.tech_rock_type;
    let density = body.tech_density;
    let density_unit = body.tech_density_unit;
    let length = body.tech_length;
    let length_unit = body.tech_length_unit;
    let width = body.tech_width;
    let width_unit = body.tech_width_unit;
    let depth = body.tech_depth;
    let depth_unit = body.tech_depth_unit;
    let wastage = body.tech_wastage;
    let price = body.tech_price;
    let price_unit = body.tech_price_unit;
    let currancy = body.tech_currancy;

    price_unit = price_unit.replace(currancy, "");

    function sigFig(value, digits) {
      if (value !== "") {
        if (value === 0) {
          return Number(value.toFixed(digits - 1));
        }
        let decimalPlaces =
          digits - Math.floor(Math.log10(Math.abs(value))) - 1;
        return Number(value.toFixed(Math.max(0, decimalPlaces)));
      }
    }

    if (
      !isNaN(length) &&
      length_unit &&
      !isNaN(width) &&
      width_unit &&
      !isNaN(depth) &&
      depth_unit &&
      !isNaN(density)
    ) {
      length = parseFloat(length);
      width = parseFloat(width);
      depth = parseFloat(depth);
      density = parseFloat(density);
      wastage = parseFloat(wastage || 0);
      price = parseFloat(price || 0);

      // Unit conversions
      const unitMap = {
        mm: 1000,
        cm: 100,
        in: 39.3701,
        ft: 3.28084,
        yd: 1.093613,
      };

      if (unitMap[length_unit]) length = length / unitMap[length_unit];
      if (unitMap[width_unit]) width = width / unitMap[width_unit];
      if (unitMap[depth_unit]) depth = depth / unitMap[depth_unit];

      const densityConversions = {
        t_m3: 1 / 0.001,
        g_cm3: 1 / 0.001,
        lb_cu_in: 1 / 0.0000361273,
        lb_cu_ft: 1 / 0.062428,
        lb_cu_yd: 1 / 1.685555,
      };

      if (densityConversions[density_unit])
        density = density * densityConversions[density_unit];

      const area = width * length;
      const volume = area * depth * (1 + wastage / 100);
      let weight = volume * density * 0.001;

      let price_v = 0;
      let total_cost = 0;
      let price_v_units = [];

      if (!isNaN(price) && price_unit) {
        const priceConversions = {
          "/kg": 1000,
          "/lb": 2204.62,
          "/stone": 157.47,
          "/us_ton": 1.1,
          "/long_ton": 0.98,
        };
        if (priceConversions[price_unit])
          price = price * priceConversions[price_unit];

        price_v = (price * density) / 1000;
        total_cost = price * weight;

        price_v_units = [
          `${sigFig(price_v / 1000000, 3)}@@@cm³`,
          `${sigFig(price_v / 61023.74, 3)}@@@cu in`,
          `${sigFig(price_v * 0.03, 3)}@@@cu ft`,
          `${sigFig(price_v * 0.76, 3)}@@@cu yd`,
        ];
      }

      const volume_units = [
        `${sigFig(volume * 1000000, 3)}@@@cm³`,
        `${sigFig(volume * 61024, 3)}@@@cu in`,
        `${sigFig(volume * 35.3, 3)}@@@cu ft`,
        `${sigFig(volume * 1.308, 3)}@@@cu yd`,
      ];

      const weight_units = [
        `${sigFig(weight * 1000, 3)}@@@kg`,
        `${sigFig(weight * 2205, 3)}@@@lb`,
        `${sigFig(weight * 157.5, 3)}@@@stone`,
        `${sigFig(weight * 1.102, 3)}@@@US ton`,
        `${sigFig(weight * 0.984, 3)}@@@Long ton`,
      ];

      const area_units = [
        `${sigFig(area * 10000, 3)}@@@cm²`,
        `${sigFig(area * 0.000001, 3)}@@@km²`,
        `${sigFig(area * 1550, 3)}@@@in²`,
        `${sigFig(area * 10.76, 3)}@@@ft²`,
        `${sigFig(area * 1.196, 3)}@@@yd²`,
        `${sigFig(area * 0.000000386, 3)}@@@mi²`,
      ];

      return {
        tech_volume: sigFig(volume, 3),
        tech_volume_units: volume_units,
        tech_weight: sigFig(weight, 3),
        tech_weight_units: weight_units,
        tech_area: sigFig(area, 3),
        tech_area_units: area_units,
        tech_price_v: sigFig(price_v, 3),
        tech_price_v_units: price_v_units,
        tech_total_cost: sigFig(total_cost, 3),
      };
    } else {
      return { error: "Please! Check Your Inputs" };
    }
  }

  /**
   * getCalculationCircleSkirtCalculator: Service Method
   * POST: /api/calculators-lol/circle-skirt-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCircleSkirtCalculator(body) {
    let type = body.tech_type;
    let length = body.tech_length;
    let length_unit = body.tech_length_unit;
    let waist = body.tech_waist;
    let waist_unit = body.tech_waist_unit;

    function convertToCm(value, unit) {
      switch (unit) {
        case "mm":
          return value * 0.1; // Millimeters to centimeters
        case "cm":
          return value; // Centimeters to centimeters
        case "m":
          return value * 100; // Meters to centimeters
        case "in":
          return value * 2.54; // Inches to centimeters
        case "ft":
          return value * 30.48; // Feet to centimeters
        default:
          return null; // Invalid unit
      }
    }

    if (!isNaN(length) && !isNaN(waist) && type) {
      length = parseFloat(length);
      waist = parseFloat(waist);

      let length_cm = convertToCm(length, length_unit);
      let waist_cm = convertToCm(waist, waist_unit);

      if (length_cm === null || waist_cm === null) {
        return { error: "Invalid unit provided" };
      }

      let radius_cm;

      // π = 3.14
      const pi = 3.14;
      if (type === "full") {
        radius_cm = waist_cm / (2 * pi) - 2;
      } else if (type === "three-quarter") {
        radius_cm = ((4 / 3) * waist_cm) / (2 * pi) - 2;
      } else if (type === "half") {
        radius_cm = (2 * waist_cm) / (2 * pi) - 2;
      } else if (type === "quarter") {
        radius_cm = (4 * waist_cm) / (2 * pi) - 2;
      } else {
        return { error: "Invalid skirt type" };
      }

      let radius_mm = radius_cm * 10;
      let radius_m = radius_cm / 100;
      let radius_in = radius_cm / 2.54;
      let radius_ft = radius_cm / 30.48;

      let fabric_length_cm = length_cm + radius_cm + 2;
      let fabric_length_mm = fabric_length_cm * 10;
      let fabric_length_m = fabric_length_cm / 100;
      let fabric_length_in = fabric_length_cm / 2.54;
      let fabric_length_ft = fabric_length_cm / 30.48;

      return {
        tech_radius_cm: Number(radius_cm.toFixed(2)),
        tech_radius_mm: Number(radius_mm.toFixed(2)),
        tech_radius_m: Number(radius_m.toFixed(2)),
        tech_radius_in: Number(radius_in.toFixed(2)),
        tech_radius_ft: Number(radius_ft.toFixed(2)),
        tech_fabric_length_cm: Number(fabric_length_cm.toFixed(2)),
        tech_fabric_length_mm: Number(fabric_length_mm.toFixed(2)),
        tech_fabric_length_m: Number(fabric_length_m.toFixed(2)),
        tech_fabric_length_in: Number(fabric_length_in.toFixed(2)),
        tech_fabric_length_ft: Number(fabric_length_ft.toFixed(2)),
      };
    } else {
      return { error: "Please! Check Your Inputs" };
    }
  }

  /**
   * getCalculationBotoxCostCalculator: Service Method
   * POST: /api/calculators-lol/botox-cost-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationBotoxCostCalculator(body) {
    let solve = body.tech_solve;
    let input_f = body.tech_input_f;
    let input_s = body.tech_input_s;

    if (isNaN(input_f) || isNaN(input_s)) {
      return { error: "Please! Check Your Input" };
    }

    let answer;

    // Check if solve is "1" or "2"
    if (solve === "1" || solve === "2") {
      answer = input_f / input_s; // Division
    } else {
      answer = input_f * input_s; // Multiplication
    }

    return {
      tech_answer: answer,
    };
  }
  /**
   * getCalculationYardsToTonsCalculator: Service Method
   * POST: /api/calculators-lol/yards-to-tons-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationYardsToTonsCalculator(body) {
    let density = body.tech_density;
    let density_unit = body.tech_density_unit;
    let cubic_yards = body.tech_cubic_yards;

    // Function to convert density to cubic yard based on the density unit
    function cubicYard(density, density_unit) {
      let total_cubic_yard = 0;

      if (density_unit === "lb/ft³") {
        total_cubic_yard = density / 74.074;
      } else if (density_unit === "kg/m³") {
        total_cubic_yard = density / 1187;
      }

      return total_cubic_yard;
    }

    // Check if the inputs are numeric
    if (isNaN(density) || isNaN(cubic_yards)) {
      return { error: "Please! Check Your Input" };
    }

    // Convert density and calculate tons
    density = cubicYard(density, density_unit);
    let tons = density * cubic_yards;
    let metric_tonnes = tons * 0.907185;
    let pounds = metric_tonnes * 2204.62;

    return {
      tech_tons: tons,
      tech_metric_tonnes: metric_tonnes,
      tech_pounds: pounds,
    };
  }
  /**
   * getCalculationDilutionRatioCalculator: Service Method
   * POST: /api/calculators-lol/dilution-ratio-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDilutionRatioCalculator(body) {
    let final_volume = body.tech_final_volume;
    let final_unit = body.tech_final_unit;
    let dilution_ratio = body.tech_dilution_ratio;
    let concentrate_volume = body.tech_concentrate_volume;
    let concentrate_unit = body.tech_concentrate_unit;
    let water_volume = body.tech_water_volume;
    let water_unit = body.tech_water_unit;

    const dilutionUnit = (input, unit) => {
      const conversions = {
        "cm³": 0.001,
        "dm³": 1,
        "m³": 1000,
        cuin: 0.016387,
        cuft: 28.317,
        cuyd: 764.6,
        ml: 0.001,
        cl: 0.01,
        USgal: 3.7854,
        UKgal: 4.546,
      };
      return input * (conversions[unit] || 1);
    };

    const isNumeric = (n) => !isNaN(parseFloat(n)) && isFinite(n);

    if (
      isNumeric(final_volume) &&
      isNumeric(dilution_ratio) &&
      !concentrate_volume &&
      !water_volume
    ) {
      final_volume = dilutionUnit(final_volume, final_unit);
      let cv = final_volume / (parseFloat(dilution_ratio) + 1);
      let wv = cv * parseFloat(dilution_ratio);
      return {
        tech_res1: `${cv.toFixed(2)} liters`,
        tech_res11: cv.toFixed(2),
        tech_res2: `${wv.toFixed(2)} liters`,
        tech_res22: wv.toFixed(2),
        tech_name1: "Concentrate volume",
        tech_name2: "Water volume",
      };
    } else if (
      isNumeric(final_volume) &&
      !dilution_ratio &&
      isNumeric(concentrate_volume) &&
      !water_volume
    ) {
      final_volume = dilutionUnit(final_volume, final_unit);
      concentrate_volume = dilutionUnit(concentrate_volume, concentrate_unit);
      let dr = final_volume / concentrate_volume - 1;
      let wv = dr * concentrate_volume;
      return {
        tech_res1: `${dr.toFixed(1)} :1`,
        tech_res11: dr.toFixed(1),
        tech_res2: `${wv.toFixed(2)} liters`,
        tech_res22: wv.toFixed(2),
        tech_name1: "Dilution ratio",
        tech_name2: "Water volume",
      };
    } else if (
      isNumeric(final_volume) &&
      !dilution_ratio &&
      !concentrate_volume &&
      isNumeric(water_volume)
    ) {
      final_volume = dilutionUnit(final_volume, final_unit);
      water_volume = dilutionUnit(water_volume, water_unit);
      let cv = final_volume - water_volume;
      if (cv === 0) {
        return { error: "Please! Division by zero chose other values" };
      }
      let dr = water_volume / cv;
      return {
        tech_res1: `${dr.toFixed(2)} :1`,
        tech_res11: dr.toFixed(2),
        tech_res2: `${cv.toFixed(2)} liters`,
        tech_res22: cv.toFixed(2),
        tech_name1: "Dilution ratio",
        tech_name2: "Concentrate volume",
      };
    } else if (
      !final_volume &&
      isNumeric(dilution_ratio) &&
      isNumeric(concentrate_volume) &&
      !water_volume
    ) {
      concentrate_volume = dilutionUnit(concentrate_volume, concentrate_unit);
      let fv = concentrate_volume * (parseFloat(dilution_ratio) + 1);
      let wv = concentrate_volume * parseFloat(dilution_ratio);
      return {
        tech_res1: `${fv.toFixed(2)} liters`,
        tech_res11: fv.toFixed(2),
        tech_res2: `${wv.toFixed(2)} liters`,
        tech_res22: wv.toFixed(2),
        tech_name1: "Final volume",
        tech_name2: "Water volume",
      };
    } else if (
      !final_volume &&
      isNumeric(dilution_ratio) &&
      !concentrate_volume &&
      isNumeric(water_volume)
    ) {
      water_volume = dilutionUnit(water_volume, water_unit);
      if (parseFloat(dilution_ratio) === 0) {
        return { error: "Please! Division by zero, chose other values" };
      }
      let cv = water_volume / parseFloat(dilution_ratio);
      let fv = cv * (parseFloat(dilution_ratio) + 1);
      return {
        tech_res1: `${fv.toFixed(2)} liters`,
        tech_res11: fv.toFixed(2),
        tech_res2: `${cv.toFixed(2)} liters`,
        tech_res22: cv.toFixed(2),
        tech_name1: "Final volume",
        tech_name2: "Concentrate volume",
      };
    } else if (
      !final_volume &&
      !dilution_ratio &&
      isNumeric(concentrate_volume) &&
      isNumeric(water_volume)
    ) {
      concentrate_volume = dilutionUnit(concentrate_volume, concentrate_unit);
      water_volume = dilutionUnit(water_volume, water_unit);
      let dr = water_volume / concentrate_volume;
      let fv = concentrate_volume * (dr + 1);
      return {
        tech_res1: `${dr.toFixed(2)} :1`,
        tech_res11: dr.toFixed(2),
        tech_res2: `${fv.toFixed(2)} liters`,
        tech_res22: fv.toFixed(2),
        tech_name1: "Dilution ratio",
        tech_name2: "Final volume",
      };
    } else {
      return { error: "Please! Enter only two values to get your result" };
    }
  }

  /**
   * getCalculationgpMCalculator: Service Method
   * POST: /api/calculators-lol/gpm-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationgpMCalculator(body) {
    let volume = body.tech_volume?.toString().trim();
    let vol_unit = body.tech_vol_unit?.toString().trim();
    let time = body.tech_time?.toString().trim();
    let time_unit = body.tech_time_unit?.toString().trim();
    let ans_unit = body.tech_ans_unit?.toString().trim();

    function volume_convert(a, b) {
      const conversions = {
        "mm³": a * 0.00000026417,
        "cm³": a * 0.00026417,
        "dm³": a * 0.26417,
        "m³": a * 264.17,
        "cu in": a * 0.004329,
        "cu ft": a * 7.48,
        "cu yd": a * 201.97,
        ml: a * 0.00026417,
        cl: a * 0.0026417,
        liters: a * 0.26417,
        "US gal": a,
        "UK gal": a * 1.201,
        "US fl oz": a * 0.007813,
        "UK fl oz": a * 0.007506,
        cups: a * 0.0625,
        tbsp: a * 0.0039626,
        tsp: a * 0.0013209,
        "US qt": a * 0.25,
        "UK qt": a * 0.30024,
        "US pt": a * 0.125,
        "UK pt": a * 0.15012,
      };
      return conversions[b] ?? null;
    }

    function time_convert(a, b) {
      const conversions = {
        sec: a * 1,
        min: a * 60,
        hrs: a * 3600,
        days: a * 86400,
        wks: a * 604800,
        mos: a * 2629800,
        yrs: a * 31557600,
      };
      return conversions[b] ?? null;
    }

    function ans_convert(a, b) {
      const map = {
        1: { val: a * 1, unit: "US gal/s" },
        2: { val: a * 60, unit: "US gal/min" },
        3: { val: a * 3600, unit: "US gal/h" },
        4: { val: a * 86400, unit: "US gal/day" },
        5: { val: a * 0.8327, unit: "UK gal/s" },
        6: { val: a * 49.96, unit: "UK gal/min" },
        7: { val: a * 2997.6, unit: "UK gal/h" },
        8: { val: a * 71943, unit: "UK gal/day" },
        9: { val: a * 0.13368, unit: "ft³/s" },
        10: { val: a * 8.021, unit: "ft³/min" },
        11: { val: a * 481.25, unit: "ft³/h" },
        12: { val: a * 11550, unit: "ft³/day" },
        13: { val: a * 3785410, unit: "mm³/s" },
        14: { val: a * 0.0037854, unit: "m³/s" },
        15: { val: a * 0.22712, unit: "m³/min" },
        16: { val: a * 13.627, unit: "m³/h" },
        17: { val: a * 327.06, unit: "m³/day" },
        18: { val: a * 3.7854, unit: "L/s" },
        19: { val: a * 227.12, unit: "L/min" },
        20: { val: a * 13627, unit: "L/h" },
        21: { val: a * 327059, unit: "L/day" },
        22: { val: a * 227125, unit: "ml/min" },
        23: { val: a * 13627476, unit: "ml/h" },
        24: { val: a * 7680, unit: "US fl oz / min" },
        25: { val: a * 460800, unit: "US fl oz / h" },
        26: { val: a * 7994, unit: "UK fl oz / min" },
        27: { val: a * 479620, unit: "UK fl oz / h" },
        28: { val: a * 480, unit: "US pt / min" },
        29: { val: a * 28800, unit: "US pt / h" },
        30: { val: a * 399.7, unit: "UK pt / min" },
        31: { val: a * 23981, unit: "UK pt / h" },
      };
      return map[b] ?? null;
    }

    const param = {};

    if (!isNaN(volume) && !isNaN(time)) {
      const volConverted = volume_convert(parseFloat(volume), vol_unit);
      const timeConverted = time_convert(parseFloat(time), time_unit);

      if (volConverted == null || timeConverted == null) {
        return { error: "Invalid volume or time unit" };
      }

      const rawRate = volConverted / timeConverted;
      const result = ans_convert(rawRate, ans_unit);

      if (result == null) {
        return { error: "Invalid answer unit selection" };
      }

      param.tech_main_ans = result.val;
      param.tech_answer_unit = result.unit;
    } else {
      param.error = "Please! Check Your Inputs";
    }

    return param;
  }

  /**
   * getCalculationCeilingfanSizeCalculator: Service Method
   * POST: /api/calculators-lol/ceiling-fan-size-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCeilingfanSizeCalculator(body) {
    let room_width = body.tech_room_width?.toString().trim();
    let room_length = body.tech_room_length?.toString().trim();
    let ceiling_height = body.tech_ceiling_height?.toString().trim();

    const param = {};

    if (!isNaN(room_width) && !isNaN(room_length) && !isNaN(ceiling_height)) {
      const width = parseFloat(room_width);
      const length = parseFloat(room_length);
      const height = parseFloat(ceiling_height);

      const squareFootage = width * length;

      let fanSize = "";
      if (squareFootage <= 75) {
        fanSize = "29 to 36 inches";
      } else if (squareFootage <= 144) {
        fanSize = "36 to 42 inches";
      } else if (squareFootage <= 225) {
        fanSize = "44 to 50 inches";
      } else {
        fanSize = "52 inches or larger";
      }

      const downrodLength = height >= 9 ? "6 inches" : "3 inches";

      param.tech_squareFootage = squareFootage;
      param.tech_fanSize = fanSize;
      param.tech_downrodLength = downrodLength;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }
  /**
   * getCalculationCostPerMileDrivingCalculator: Service Method
   * POST: /api/calculators-lol/cost-per-mile-driving-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCostPerMileDrivingCalculator(body) {
    let cost_of_gas = body.tech_cost_of_gas?.toString().trim();
    let miles_per_gallon = body.tech_miles_per_gallon?.toString().trim();
    let car_value = body.tech_car_value?.toString().trim();

    const param = {};

    if (!isNaN(cost_of_gas) && !isNaN(miles_per_gallon) && !isNaN(car_value)) {
      let gasCost = parseFloat(cost_of_gas); // e.g., 7
      let mpg = parseFloat(miles_per_gallon); // e.g., 7
      let carVal = parseFloat(car_value); // e.g., 4

      let car_value_div = carVal / 25000; // 0.00016
      let total_car_value = car_value_div * 0.03; // 4.8e-6
      let total_cost_mile = gasCost / mpg; // 1
      let answer = total_cost_mile + total_car_value + 0.05; // 1.0500048

      return {
        tech_answer: answer,
        tech_car_value: car_value_div,
        tech_total_car_value: total_car_value.toExponential(1), // "4.8e-6"
        tech_total_cost_mile: total_cost_mile,
        input_cost_of_gas: gasCost,
        input_miles_per_gallon: mpg,
        input_car_value: carVal,
      };
    } else {
      param.error = "Please! Check Your Input";
    }
  }

  /**
   * getCalculationGoldCostPerPoundCalculator: Service Method
   * POST: /api/calculators-lol/gold-cost-per-pound-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationGoldCostPerPoundCalculator(body) {
    let weight = body.tech_weight?.toString().trim();
    let cost = body.tech_cost?.toString().trim();

    const param = {};

    if (!isNaN(weight) && !isNaN(cost)) {
      let numericWeight = parseFloat(weight);
      let numericCost = parseFloat(cost);
      let GCP = numericCost / numericWeight;

      param.tech_GCP = parseFloat(GCP.toFixed(2)); // format to 2 decimal places
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }
  /**
   * getCalculationMoistureContentCalculator: Service Method
   * POST: /api/calculators-lol/moisture-content-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMoistureContentCalculator(body) {
    let wet = body.tech_wet?.toString().trim();
    let wet_unit = body.tech_wet_unit?.toString().trim();
    let dry = body.tech_dry?.toString().trim();
    let dry_unit = body.tech_dry_unit?.toString().trim();

    const param = {};

    if (!isNaN(wet) && !isNaN(dry)) {
      wet = parseFloat(wet);
      dry = parseFloat(dry);

      // Convert wet units
      switch (wet_unit) {
        case "mg":
          wet = wet / 1_000_000;
          break;
        case "g":
          wet = wet / 1_000;
          break;
        case "oz":
          wet = wet / 35.27396;
          break;
        case "lb":
          wet = wet / 2.204623;
          break;
      }

      // Convert dry units
      switch (dry_unit) {
        case "mg":
          dry = dry / 1_000_000;
          break;
        case "g":
          dry = dry / 1_000;
          break;
        case "oz":
          dry = dry / 35.27396;
          break;
        case "lb":
          dry = dry / 2.204623;
          break;
      }

      const mc = ((wet - dry) / wet) * 100;

      param.tech_mc = mc;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }
  /**
   * getCalculationShadedAreaCalculator: Service Method
   * POST: /api/calculators-lol/shaded-area-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationShadedAreaCalculator(body) {
    let solve = body.tech_solve?.toString().trim(); // e.g., "2@@m²"
    let input = body.tech_input?.toString().trim(); // e.g., "10"
    let in_unit = body.tech_in_unit?.toString().trim(); // e.g., "cm"

    const param = {};

    function convertInput(input, unit) {
      switch (unit) {
        case "m":
          return input * 1;
        case "AU":
          return input * 1.5e11;
        case "cm":
          return input * 0.001;
        case "km":
          return input * 1000;
        case "in":
          return input * 0.0254;
        case "ft":
          return input * 0.3048;
        case "mil":
          return input * 0.0000254;
        case "mm":
          return input * 0.001;
        case "nm":
          return input * 1e-9;
        case "mile":
          return input * 1609.344;
        case "parsec":
          return input * 3.08e16;
        case "pm":
          return input * 1e-12;
        case "yd":
          return input * 0.9144;
        default:
          return null;
      }
    }

    if (!isNaN(input)) {
      input = parseFloat(input);
      let convertedInput = convertInput(input, in_unit);

      if (convertedInput === null) {
        param.error = "Invalid input unit";
        return param;
      }

      const [val, unit] = solve.split("@@");
      const factor = parseFloat(val);

      const answer =
        Math.pow(convertedInput, 2) -
        3.14 * Math.pow(convertedInput / 2, 2) * factor;

      param.tech_answer = answer;
      param.tech_unit = unit;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationEngneHourstoMilesCalculator: Service Method
   * POST: /api/calculators-lol/engine-hours-to-miles-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationEngneHourstoMilesCalculator(body) {
    const f_input = parseFloat(body.tech_f_input);
    const s_input = parseFloat(body.tech_s_input);

    const param = {};

    if (!isNaN(f_input) && !isNaN(s_input)) {
      const answer = f_input * s_input;

      param.tech_answer = answer;
      param.input_f_input = f_input;
      param.input_s_input = s_input;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationMagnificationCalculator: Service Method
   * POST: /api/calculators-lol/magnification-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMagnificationCalculator(body) {
    let d = parseFloat(body.tech_d);
    const d_unit = body.tech_d_unit;
    let f = parseFloat(body.tech_f);
    const f_unit = body.tech_f_unit;

    const param = {};

    function sigFig2(value, digits) {
      if (value === 0) {
        return 0;
      }
      const decimalPlaces =
        digits - Math.floor(Math.log10(Math.abs(value))) - 1;
      return parseFloat(value.toFixed(decimalPlaces));
    }

    if (!isNaN(d) && !isNaN(f)) {
      // Distance unit conversion
      switch (d_unit) {
        case "mm":
          d /= 1000;
          break;
        case "cm":
          d /= 100;
          break;
        case "km":
          d /= 0.001;
          break;
        case "in":
          d /= 39.3701;
          break;
        case "ft":
          d /= 3.28084;
          break;
        case "yd":
          d /= 1.093613;
          break;
        case "mi":
          d /= 0.000621371;
          break;
        case "nmi":
          d /= 0.000539957;
          break;
      }

      // Focal length unit conversion
      switch (f_unit) {
        case "mm":
          f /= 1000;
          break;
        case "cm":
          f /= 100;
          break;
        case "km":
          f /= 0.001;
          break;
        case "in":
          f /= 39.3701;
          break;
        case "ft":
          f /= 3.28084;
          break;
        case "yd":
          f /= 1.093613;
          break;
      }

      const k = Math.pow(d, 2) / 4 - f * d;
      if (k < 0) {
        param.error = "Oops! Something Went Wrong";
        return param;
      }

      const r = Math.sqrt(k);
      const h = d / 2 - r;
      const g = d / 2 + r;
      const m = h / g;

      param.tech_h = sigFig2(h, 5);
      param.tech_g = sigFig2(g, 5);
      param.tech_m = sigFig2(m, 5);
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationSplitBillCalculator: Service Method
   * POST: /api/calculators-lol/split-bill-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationSplitBillCalculator(body) {
    const billAmount = parseFloat(body.tech_bill_amount);
    const split = parseFloat(body.tech_split);
    const param = {};

    if (!isNaN(billAmount) && !isNaN(split)) {
      if (split === 0) {
        param.error =
          "Number of ways to split the bill value cannot be equal to zero.";
        return param;
      }

      const answer = billAmount / split;
      param.tech_answer = answer;
      param.input_billAmount = billAmount;
      param.input_split = split;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationDrawLengthCalculator: Service Method
   * POST: /api/calculators-lol/draw-length-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDrawLengthCalculator(body) {
    const length = parseFloat(body.tech_length);
    const param = {};

    if (!isNaN(length)) {
      const draw = length / 2.5;
      const arrow = draw + 1.5;
      const draw_cm = draw * 2.54;
      const arrow_cm = arrow * 2.54;

      param.tech_draw = draw;
      param.tech_arrow = arrow;
      param.tech_draw_cm = draw_cm;
      param.tech_arrow_cm = arrow_cm;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationOnBasePercentageCalculator: Service Method
   * POST: /api/calculators-lol/on-base-percentage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationOnBasePercentageCalculator(body) {
    const hits = parseFloat(body.tech_hits);
    const bases = parseFloat(body.tech_bases);
    const pitch = parseFloat(body.tech_pitch);
    const bats = parseFloat(body.tech_bats);
    const flies = parseFloat(body.tech_flies);

    const param = {};

    if (
      !isNaN(hits) &&
      !isNaN(bases) &&
      !isNaN(pitch) &&
      !isNaN(bats) &&
      !isNaN(flies)
    ) {
      const denominator = bats + bases + pitch + flies;
      if (denominator === 0) {
        param.error = "Division by zero error. Please check input values.";
        return param;
      }

      const answer = (hits + bases + pitch) / denominator;
      param.tech_answer = answer;
      param.input_hits = hits;
      param.input_bases = bases;
      param.input_pitch = pitch;
      param.input_bats = bats;
      param.input_flies = flies;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationTaperCalculator: Service Method
   * POST: /api/calculators-lol/taper-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationTaperCalculator(body) {
    const major = parseFloat(body.tech_major);
    const majorUnit = body.tech_major_unit;
    const minor = parseFloat(body.tech_minor);
    const minorUnit = body.tech_minor_unit;
    const length = parseFloat(body.tech_length);
    const lengthUnit = body.tech_length_unit;

    const param = {};

    // Unit conversion function for length
    function taperUnit(length, lengthUnit) {
      let inches;
      switch (lengthUnit) {
        case "mm":
          inches = length / 25.4;
          break;
        case "in":
          inches = length * 1;
          break;
        case "cm":
          inches = length / 2.54;
          break;
        case "m":
          inches = length * 39.37;
          break;
        case "ft":
          inches = length / 12;
          break;
        default:
          inches = length;
      }
      return inches;
    }

    if (!isNaN(major) && !isNaN(minor) && !isNaN(length)) {
      const lengthMain = taperUnit(length, lengthUnit);
      const majorMain = taperUnit(major, majorUnit);
      const minorMain = taperUnit(minor, minorUnit);

      const taper = (majorMain - minorMain) / lengthMain;
      const main = taper * 1;
      const mainCm = taper / 2.54;
      const mainM = taper * 39.37;
      const mainFt = taper / 12;
      const mainMm = taper / 25.4;

      const sub = main / 2;
      const sudans = Math.atan(sub);
      const angle = (sudans * 180) / Math.PI; // Convert to degrees
      const answer = angle * 1;
      const answerRad = sudans;
      const answerGon = Math.pow(angle, 1.11111);

      param.tech_main = main;
      param.tech_main_cm = mainCm;
      param.tech_main_m = mainM;
      param.tech_main_ft = mainFt;
      param.tech_main_mm = mainMm;
      param.tech_answer = answer;
      param.tech_answer_rad = answerRad;
      param.tech_answer_gon = answerGon;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationBatteryLifeCalculator: Service Method
   * POST: /api/calculators-lol/battery-life-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBatteryLifeCalculator(body) {
    let batteryCapacity = parseFloat(body.tech_battery_capacity);
    const batteryUnits = body.tech_battery_units;
    const dischargeSafety = parseFloat(body.tech_discharge_safety);
    let deviceCon1 = parseFloat(body.tech_device_con1);
    const deviceCon1Units = body.tech_device_con1_units;
    let awakeTime = parseFloat(body.tech_awake_time);
    const awakeTimeUnits = body.tech_awake_time_units;
    let deviceCon2 = parseFloat(body.tech_device_con2);
    const deviceCon2Units = body.tech_device_con2_units;
    let sleepTime = parseFloat(body.tech_sleep_time);
    const sleepTimeUnits = body.tech_sleep_time_units;

    const param = {};
    if (
      !isNaN(batteryCapacity) &&
      !isNaN(dischargeSafety) &&
      !isNaN(deviceCon1) &&
      !isNaN(awakeTime) &&
      !isNaN(deviceCon2) &&
      !isNaN(sleepTime)
    ) {
      // Battery capacity units

      if (batteryUnits) {
        if (batteryUnits == "Ah") {
          batteryCapacity = batteryCapacity * 1000;
        } else if (batteryUnits == "mAh") {
          batteryCapacity = batteryCapacity;
        }
      }

      if (deviceCon1Units) {
        if (deviceCon1Units == "A") {
          deviceCon1 = deviceCon1 * 1000;
        } else if (deviceCon1Units == "µA") {
          deviceCon1 = deviceCon1 * 1000;
        }
      }

      if (awakeTimeUnits) {
        if (awakeTimeUnits == "sec") {
          awakeTime = awakeTime;
        } else if (awakeTimeUnits == "min") {
          awakeTime = awakeTime * 60;
        } else if (awakeTimeUnits == "hrs") {
          awakeTime = awakeTime * 3600;
        } else if (awakeTimeUnits == "days") {
          awakeTime = awakeTime * 86400;
        } else if (awakeTimeUnits == "wks") {
          awakeTime = awakeTime * 604800;
        } else if (awakeTimeUnits == "mos") {
          awakeTime = awakeTime * 2629800;
        } else if (awakeTimeUnits == "yrs") {
          awakeTime = awakeTime * 31557600;
        }
      }
      if (deviceCon2Units) {
        if (deviceCon1Units == "A") {
          deviceCon1 = deviceCon1 * 0.001;
        } else if (deviceCon1Units == "µA") {
          deviceCon1 = deviceCon1 * 1000;
        } else if (deviceCon1Units == "mA") {
          deviceCon1 = deviceCon1;
        }
      }

      if (sleepTimeUnits) {
        if (awakeTimeUnits == "sec") {
          sleepTime = sleepTime;
        } else if (sleepTime == "min") {
          sleepTime = sleepTime * 60;
        } else if (sleepTime == "hrs") {
          sleepTime = sleepTime * 3600;
        } else if (sleepTime == "days") {
          sleepTime = sleepTime * 86400;
        } else if (sleepTime == "wks") {
          sleepTime = sleepTime * 604800;
        } else if (sleepTime == "mos") {
          sleepTime = sleepTime * 2629800;
        } else if (sleepTime == "yrs") {
          sleepTime = sleepTime * 31557600;
        }
      }

      let per = dischargeSafety / 100;
      let x = 1 - per;
      let y = batteryCapacity / deviceCon1;
      let Battery_life = y * x;
      let Average_consumption =
        (deviceCon1 * awakeTime + deviceCon2 * sleepTime) /
        (awakeTime + sleepTime);
      param["tech_Battery_life"] = Battery_life;
      param["tech_Average_consumption"] = Average_consumption;
      param["input_battery_capacity"] = batteryCapacity;
      param["input_discharge_safety"] = dischargeSafety;
      param["input_device_con1"] = deviceCon1;
      param["input_awake_time"] = body.tech_awake_time;
      param["input_device_con2"] = deviceCon2;
      param["input_sleep_time"] = sleepTime;
    } else {
      param.error = "Please ! Check Input";
    }

    return param;
  }
  /**
   * getCalculationSluggingPercentageCalculator: Service Method
   * POST: /api/calculators-lol/slugging-percentage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationSluggingPercentageCalculator(body) {
    const singles = parseFloat(body.tech_singles);
    const doubles = parseFloat(body.tech_doubles);
    const triples = parseFloat(body.tech_triples);
    const home = parseFloat(body.tech_home);
    const bats = parseFloat(body.tech_bats);

    const param = {};

    if (
      !isNaN(singles) &&
      !isNaN(doubles) &&
      !isNaN(triples) &&
      !isNaN(home) &&
      !isNaN(bats)
    ) {
      if (bats === 0) {
        param.error = "At Bats value cannot be equal to zero";
        return param;
      }

      const answer = (singles + 2 * doubles + 3 * triples + 4 * home) / bats;

      param.tech_answer = answer;
      param.tech_singles = singles;
      param.tech_doubles = doubles;
      param.tech_triples = triples;
      param.tech_home = home;
      param.tech_bats = bats;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationMagicNumberCalculator: Service Method
   * POST: /api/calculators-lol/magic-number-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMagicNumberCalculator(body) {
    const win = parseFloat(body.tech_win);
    const loss = parseFloat(body.tech_loss);

    const param = {};

    if (!isNaN(win) && !isNaN(loss)) {
      const answer = 162 - win - loss + 1;

      param.tech_answer = answer;
      param.input_win = win;
      param.input_loss = loss;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationFabricCalculator: Service Method
   * POST: /api/calculators-lol/fabric-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationFabricCalculator(body) {
    let fabric = parseFloat(body.tech_fabric);
    const fabric_unit = body.tech_fabric_unit;
    let width = parseFloat(body.tech_width);
    const width_unit = body.tech_width_unit;
    let length = parseFloat(body.tech_length);
    const length_unit = body.tech_length_unit;
    const piece = parseFloat(body.tech_piece);
    const unit = body.tech_unit;

    const param = {};

    function convertUnit(value, unit) {
      switch (unit) {
        case "mm":
          return value * 1000;
        case "cm":
          return value * 100;
        case "m":
          return value;
        case "km":
          return value / 1000;
        case "in":
          return value * 39.37;
        case "ft":
          return value * 3.281;
        case "yd":
          return value * 1.094;
        default:
          return value;
      }
    }

    if (!isNaN(fabric) && !isNaN(width) && !isNaN(length) && !isNaN(piece)) {
      width = convertUnit(width, width_unit);
      fabric = convertUnit(fabric, fabric_unit);

      if (fabric === 0) {
        param.error = "fabric width cannot be equal to zero";
        return param;
      }

      if (width === 0) {
        param.error = "pieces to cut width cannot be equal to zero";
        return param;
      }

      const sub_across = fabric / width;
      const across = Math.round(sub_across);
      if (across === 0) {
        param.error = "across value cannot be equal to zero";
        return param;
      }

      const sub_down = piece / across;
      const down = Math.round(sub_down);

      length = convertUnit(length, length_unit);
      const sub_material = length * down;
      const material = Math.round(sub_material);
      const unit_material = convertUnit(material, unit);
      const answer = Math.round(unit_material);

      param.tech_answer = answer;
      param.tech_down = down;
      param.tech_across = across;
      param.tech_unit = unit;
      param.tech_piece = piece;
      param.tech_fabric = fabric;
      param.tech_width = width;
      param.tech_length = length;
      param.input_fabric = parseFloat(body.tech_fabric);
      param.input_width = parseFloat(body.tech_width);
      param.input_length = parseFloat(body.tech_length);
      param.input_piece = parseFloat(body.tech_piece);
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationSemestergradeCalculator: Service Method
   * POST: /api/calculators-lol/semester-grade-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationSemestergradeCalculator(body) {
    const f_grade = parseFloat(body.tech_f_grade);
    const f_weight = parseFloat(body.tech_f_weight);
    const s_grade = parseFloat(body.tech_s_grade);
    const s_weight = parseFloat(body.tech_s_weight);
    const l_grade = parseFloat(body.tech_l_grade);
    const l_weight = parseFloat(body.tech_l_weight);

    const param = {};

    if (
      !isNaN(f_grade) &&
      !isNaN(f_weight) &&
      !isNaN(s_grade) &&
      !isNaN(s_weight) &&
      !isNaN(l_grade) &&
      !isNaN(l_weight)
    ) {
      const semesterGrade =
        f_grade * f_weight + s_grade * s_weight + l_grade * l_weight;
      param.tech_semesterGrade = semesterGrade / 100;
    } else {
      param.error = "Please check input.";
    }

    return param;
  }

  /**
   * getCalculationScreenSizeCalculator: Service Method
   * POST: /api/calculators-lol/screen-size-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationScreenSizeCalculator(body) {
    let screen = body.tech_screen;
    let ratio_1 = body.tech_ratio_1;
    let ratio_2 = body.tech_ratio_2;
    let type = body.tech_type;
    let curvature = body.tech_curvature;
    let radius = body.tech_radius;
    let radius_units = body.tech_radius_units;
    let select_one = body.tech_select_one;
    let select_two = body.tech_select_two;
    let curved_dimensions = body.tech_curved_dimensions;
    let curved_dimensions_units = body.tech_curved_dimensions_units;
    let flat_dimensions = body.tech_flat_dimensions;
    let flat_dimensions_units = body.tech_flat_dimensions_units;
    const param = {};

    function conversionScreen(unit, value) {
      if (!unit) return value;
      switch (unit) {
        case "cm":
          return value / 2.54;
        case "m":
          return value / 0.0254;
        case "in":
          return value;
        case "ft":
          return value * 12;
        case "yd":
          return value * 36;
        case "mm":
          return value / 25.4;
        default:
          return value;
      }
    }

    const isNumeric = (n) => !isNaN(parseFloat(n)) && isFinite(n);

    if (type === "flat") {
      if (
        isNumeric(ratio_1) &&
        isNumeric(ratio_2) &&
        isNumeric(flat_dimensions)
      ) {
        const convertedFlatDim = conversionScreen(
          flat_dimensions_units,
          flat_dimensions
        );
        const r1 = parseFloat(ratio_1);
        const r2 = parseFloat(ratio_2);

        if (select_one === "Diagonal") {
          const width = (r1 / Math.sqrt(r1 ** 2 + r2 ** 2)) * convertedFlatDim;
          const height = (r2 / Math.sqrt(r1 ** 2 + r2 ** 2)) * convertedFlatDim;
          param.tech_screenArea = width * height;
          param.tech_width = width;
          param.tech_height = height;
        } else if (select_one === "Width") {
          const height = (r2 / r1) * convertedFlatDim;
          const diagonal = Math.sqrt(convertedFlatDim ** 2 + height ** 2);
          param.tech_screenArea = convertedFlatDim * height;
          param.tech_diagonal = diagonal;
          param.tech_height = height;
        } else if (select_one === "Height") {
          const width = (r1 / r2) * convertedFlatDim;
          const diagonal = Math.sqrt(width ** 2 + convertedFlatDim ** 2);
          param.tech_screenArea = width * convertedFlatDim;
          param.tech_width = width;
          param.tech_diagonal = diagonal;
        }
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }
    } else {
      if (
        isNumeric(ratio_1) &&
        isNumeric(ratio_2) &&
        isNumeric(curved_dimensions)
      ) {
        let radius1 = conversionScreen(radius_units, radius);
        const convertedCurvedDim = conversionScreen(
          curved_dimensions_units,
          curved_dimensions
        );
        const r1 = parseFloat(ratio_1);
        const r2 = parseFloat(ratio_2);

        if (select_two === "Diagonal") {
          const height =
            (r2 / Math.sqrt(r1 ** 2 + r2 ** 2)) * convertedCurvedDim;
          const base_width = Math.sqrt(
            convertedCurvedDim ** 2 - Math.round(height, 1) ** 2
          );
          const screen_length = (r1 / r2) * height;
          const base_depth =
            radius1 * (1 - Math.cos(screen_length / (2 * radius1)));
          param.tech_screenArea = base_width * height;
          param.tech_base_width = base_width;
          param.tech_height = height;
          param.tech_base_depth = base_depth;
          param.tech_screen_length = screen_length;
        } else if (select_two === "Width") {
          const height = convertedCurvedDim / (r1 / r2);
          const diagonal = Math.sqrt(convertedCurvedDim ** 2 + height ** 2);
          const screen_length = (r1 / r2) * height;
          const base_depth =
            radius1 * (1 - Math.cos(screen_length / (2 * radius1)));
          param.tech_screenArea = convertedCurvedDim * height;
          param.tech_height = height;
          param.tech_diagonal = diagonal;
          param.tech_base_depth = base_depth;
          param.tech_screen_length = screen_length;
        } else if (select_two === "Height") {
          const base_width = convertedCurvedDim * (r1 / r2);
          const diagonal = Math.sqrt(base_width ** 2 + convertedCurvedDim ** 2);
          const screen_length = (r1 / r2) * convertedCurvedDim;
          const base_depth =
            radius1 * (1 - Math.cos(screen_length / (2 * radius1)));
          param.tech_base_width = base_width;
          param.tech_diagonal = diagonal;
          param.tech_screenArea = base_width * convertedCurvedDim;
          param.tech_base_depth = base_depth;
          param.tech_screen_length = screen_length;
        }
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }
    }
    return param;
  }

  /**
   * getCalculationRecessedLightingCalculator: Service Method
   * POST: /api/calculators-lol/recessed-lighting-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationRecessedLightingCalculator(body) {
    let a = body.tech_a;
    let b = body.tech_b;
    let columns_fixture = body.tech_columns_fixture;
    let rows_fixture = body.tech_rows_fixture;

    const param = {};

    const isNumeric = (n) => !isNaN(parseFloat(n)) && isFinite(n);

    if (isNumeric(a) && isNumeric(b)) {
      a = parseFloat(a);
      b = parseFloat(b);
      columns_fixture = parseFloat(columns_fixture);
      rows_fixture = parseFloat(rows_fixture);

      const a_not = a / (2 * rows_fixture);
      const a_i = a / rows_fixture;
      const b_not = b / (2 * columns_fixture);
      const b_i = b / columns_fixture;
      const y_not = a / rows_fixture;
      const y_i = a / rows_fixture;
      const x_not = b / 2;
      const x_i = b / 2;

      param.tech_a_not = a_not;
      param.tech_a_i = a_i;
      param.tech_b_not = b_not;
      param.tech_b_i = b_i;
      param.tech_y_not = y_not;
      param.tech_y_i = y_i;
      param.tech_x_not = x_not;
      param.tech_x_i = x_i;
    } else {
      param.error = "Please! Check Your Input";
      return param;
    }

    return param;
  }

  /**
   * getCalculationCMFCalculator: Service Method
   * POST: /api/calculators-lol/cfm-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCMFCalculator(body) {
    let length = body.tech_length;
    let length_units = body.tech_length_units;
    let width = body.tech_width;
    let width_units = body.tech_width_units;
    let celling = body.tech_celling;
    let celling_units = body.tech_celling_units;
    let airflow = body.tech_airflow;

    const param = {};

    const isNumeric = (n) => !isNaN(parseFloat(n)) && isFinite(n);

    function convertToMeters(value, unit) {
      if (unit === "m") return value;
      if (unit === "cm") return value * 0.01;
      if (unit === "in") return value * 0.0254;
      if (unit === "ft") return value * 0.3048;
      if (unit === "yd") return value * 0.9144;
      return null;
    }

    if (
      isNumeric(length) &&
      isNumeric(width) &&
      isNumeric(celling) &&
      isNumeric(airflow)
    ) {
      length = convertToMeters(parseFloat(length), length_units);
      width = convertToMeters(parseFloat(width), width_units);
      celling = convertToMeters(parseFloat(celling), celling_units);
      airflow = parseFloat(airflow);

      const floorArea = length * width;
      const volume = floorArea * celling;

      const airflow_rate = volume * airflow;
      const requiredAirFlow = (floorArea * celling * airflow) / 1.7;

      param.tech_floorArea = floorArea;
      param.tech_volume = volume;
      param.tech_airflow_rate = airflow_rate;
      param.tech_requiredAirFlow = requiredAirFlow;
    } else {
      param.error = "Please! Check Your Input";
      return param;
    }

    return param;
  }

  /**
   * getCalculationBoxFillCalculator: Service Method
   * POST: /api/calculators-lol/box-fill-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBoxFillCalculator(body) {
    let conducting_wire_size = body.tech_conducting_wire_size;
    let clamps = body.tech_clamps;
    let conducting_wire = body.tech_conducting_wire;
    let fittings = body.tech_fittings;
    let devices = body.tech_devices;
    let grounding_conductor = body.tech_grounding_conductor;
    let largest_wire_size = body.tech_largest_wire_size;

    const param = {};
    let clamp_vol_allownce,
      conductor_fill_volume,
      clamp_fill_vol,
      fitt_vol_allownce,
      device_vol_allownce,
      fitt_fill_vol,
      device_fill_vol,
      grounding_fill_vol_allownce,
      grounding_fill_vol,
      larg_cond_wire,
      total_box_vol,
      total_volume_allowance_needed;
    const isNumeric = (n) => !isNaN(parseFloat(n)) && isFinite(n);

    if (
      isNumeric(conducting_wire) &&
      isNumeric(devices) &&
      isNumeric(grounding_conductor)
    ) {
      conducting_wire = parseFloat(conducting_wire);
      devices = parseFloat(devices);
      grounding_conductor = parseFloat(grounding_conductor);
      conducting_wire_size = parseFloat(conducting_wire_size);
      largest_wire_size = parseFloat(largest_wire_size);

      conductor_fill_volume = conducting_wire * conducting_wire_size;
      if (clamps == "yes") {
        clamp_vol_allownce = 1;
        clamp_fill_vol = conducting_wire_size;
      } else {
        clamp_vol_allownce = 0;
        clamp_fill_vol = 0;
      }
      if (fittings == "yes") {
        fitt_vol_allownce = 1;
        fitt_fill_vol = conducting_wire_size;
      } else {
        fitt_vol_allownce = 0;
        fitt_fill_vol = 0;
      }

      device_vol_allownce = devices * 2;
      device_fill_vol = device_vol_allownce * conducting_wire_size;
      grounding_fill_vol_allownce = grounding_conductor / 4;
      grounding_fill_vol = largest_wire_size * grounding_fill_vol_allownce;
      larg_cond_wire =
        grounding_conductor +
        device_vol_allownce +
        clamp_vol_allownce +
        fitt_vol_allownce;
      total_box_vol =
        conductor_fill_volume +
        clamp_fill_vol +
        fitt_fill_vol +
        device_fill_vol +
        grounding_fill_vol;
      total_volume_allowance_needed =
        conducting_wire +
        clamp_vol_allownce +
        fitt_vol_allownce +
        device_vol_allownce +
        grounding_fill_vol_allownce;

      param.tech_conducting_wire = conducting_wire;
      param.tech_conducting_wire_size = conducting_wire_size;
      param.tech_conductor_fill_volume = conductor_fill_volume;
      param.tech_clamp_vol_allownce = clamp_vol_allownce;
      param.tech_clamp_fill_vol = clamp_fill_vol;
      param.tech_fitt_vol_allownce = fitt_vol_allownce;
      param.tech_fitt_fill_vol = fitt_fill_vol;
      param.tech_device_vol_allownce = device_vol_allownce;
      param.tech_device_fill_vol = device_fill_vol;
      param.tech_grounding_fill_vol_allownce = grounding_fill_vol_allownce;
      param.tech_largest_wire_size = largest_wire_size;
      param.tech_grounding_fill_vol = grounding_fill_vol;
      param.tech_larg_cond_wire = larg_cond_wire;
      param.tech_total_volume_allowance_needed = total_volume_allowance_needed;
      param.tech_total_box_vol = total_box_vol;
    } else {
      param.error = "Please! Check Your Input";
      return param;
    }
    return param;
  }

  /**
   * getCalculationTonnageCalculator: Service Method
   * POST: /api/calculators-lol/tonnage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationTonnageCalculator(body) {
    let unit_weight = parseFloat(body.tech_unit_weight);
    let length = parseFloat(body.tech_length);
    let length_units = body.tech_length_units;
    let width = parseFloat(body.tech_width);
    let width_units = body.tech_width_units;
    let depth = parseFloat(body.tech_depth);
    let depth_units = body.tech_depth_units;
    let price_per = parseFloat(body.tech_price_per);
    let price_per_units = body.tech_price_per_units;
    let wastage = parseFloat(body.tech_wastage);

    const param = {};
    let tonnage, weight_needed, total_cost;
    const isNumeric = (n) => !isNaN(parseFloat(n)) && isFinite(n);

    if (price_per_units !== undefined) {
      if (price_per_units === "kg") {
        price_per = price_per;
      } else if (price_per_units === "t") {
        price_per = price_per * 1000;
      } else if (price_per_units === "lb") {
        price_per = price_per * 0.453592;
      } else if (price_per_units === "st") {
        price_per = price_per * 6.35029;
      }
    }

    function convertToM(value, unit) {
      if (unit === "m") {
        return value;
      } else if (unit === "cm") {
        return value * 100;
      } else if (unit === "in") {
        return value * 39.37;
      } else if (unit === "ft") {
        return value * 3.281;
      } else if (unit === "yd") {
        return value * 1.094;
      } else {
        return null;
      }
    }

    if (
      isNumeric(length) &&
      isNumeric(width) &&
      isNumeric(depth) &&
      isNumeric(price_per) &&
      isNumeric(wastage)
    ) {
      width = convertToM(width, width_units);
      length = convertToM(length, length_units);
      depth = convertToM(depth, depth_units);
      // Calculate area
      console.log(length, width);
      const area = length * width;
      console.log(area);
      // Calculate volume
      const volume = area * depth;

      // Calculate tonnage
      tonnage = Math.round(volume * unit_weight * 0.001, 2);

      // Calculate weight needed considering wastage
      weight_needed = Math.round(Math.round(tonnage) / (1 - wastage / 100), 2);

      // Calculate total cost
      total_cost = Math.round(weight_needed, 5) * price_per;

      param.tech_area = area;
      param.tech_volume = volume;
      param.tech_tonnage = tonnage;
      param.tech_weight_needed = weight_needed;
      param.tech_total_cost = total_cost;
    } else {
      param.error = "Please! Check Your Input";
      return param;
    }

    return param;
  }

  /**
   * getCalculationDunkCalculator: Service Method
   * POST: /api/calculators-lol/dunk-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDunkCalculator(body) {
    let height = parseFloat(body.tech_height);
    let height_unit = body.tech_height_unit;
    let mass = parseFloat(body.tech_mass);
    let mass_unit = body.tech_mass_unit;
    let acceleration = parseFloat(body.tech_acceleration);
    let acceleration_unit = body.tech_acceleration_unit;
    let palm_size = parseFloat(body.tech_palm_size);
    let palm_size_unit = body.tech_palm_size_unit;
    let standing = parseFloat(body.tech_standing);
    let standing_unit = body.tech_standing_unit;

    const param = {};

    const isNumeric = (n) => !isNaN(parseFloat(n)) && isFinite(n);

    function unitConvert(unit, value) {
      switch (unit) {
        case "m":
          return value * 100;
        case "in":
          return value * 2.54;
        case "ft":
          return value * 30.48;
        case "yd":
          return value * 91.44;
        case "mm":
          return value * 0.1;
        case "km":
          return value * 1;
        case "mi":
          return value * 2.54;
        case "nmi":
          return value * 2.54;
        default:
          return value;
      }
    }

    function massUnitConvert(unit, value) {
      switch (unit) {
        case "g":
          return value * 0.001;
        case "t":
          return value * 1000;
        case "lb":
          return value * 0.4536;
        case "st":
          return value * 6.35;
        case "US ton":
          return value * 907.2;
        case "long ton":
          return value * 1016;
        case "Earths":
          return value * 5.9722e24;
        default:
          return value;
      }
    }

    function gravUnitConvert(unit, value) {
      switch (unit) {
        case "g":
          return value * 9.807;
        case "ft/s²":
          return value * 0.3048;
        default:
          return value;
      }
    }

    if (
      isNumeric(height) &&
      isNumeric(mass) &&
      isNumeric(acceleration) &&
      isNumeric(palm_size) &&
      isNumeric(standing)
    ) {
      height = unitConvert(height_unit, height);
      mass = massUnitConvert(mass_unit, mass);
      acceleration = gravUnitConvert(acceleration_unit, acceleration);
      palm_size = unitConvert(palm_size_unit, palm_size);
      standing = unitConvert(standing_unit, standing);

      const minimum_vertical_leap = height - standing + palm_size;
      const hang_time = +(
        Math.sqrt((8 * minimum_vertical_leap) / acceleration) / 10
      ).toFixed(3);
      const jumping_energy = +(
        (mass * acceleration * minimum_vertical_leap) /
        100
      ).toFixed(3);
      const initial_jumping_speed = +(
        Math.sqrt(2 * acceleration * minimum_vertical_leap) / 10
      ).toFixed(3);

      param.tech_minimum_vertical_leap = minimum_vertical_leap;
      param.tech_hang_time = hang_time;
      param.tech_jumping_energy = jumping_energy;
      param.tech_initial_jumping_speed = initial_jumping_speed;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationNetherPortalCalculator: Service Method
   * POST: /api/calculators-lol/nether-portal-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationNetherPortalCalculator(body) {
    const submit = String(body.tech_submit || "").trim();
    const sim_adv = String(body.tech_sim_adv || "").trim();
    const cal = String(body.cal || "").trim();

    const x = parseFloat(body.tech_x);
    const y = parseFloat(body.tech_y);
    const z = parseFloat(body.tech_z);

    const x1 = parseFloat(body.tech_x1);
    const y1 = parseFloat(body.tech_y1);
    const z1 = parseFloat(body.tech_z1);
    const x2 = parseFloat(body.tech_x2);
    const y2 = parseFloat(body.tech_y2);
    const z2 = parseFloat(body.tech_z2);

    const param = {};

    const isNum = (val) => !isNaN(parseFloat(val)) && isFinite(val);

    if (!submit) {
      param.error = "Please! Check Your Input";
      return param;
    }

    if (sim_adv === "simple") {
      if (cal === "1") {
        if (!isNum(x) && !isNum(y) && !isNum(z)) {
          param.error = "Please! Check Your Input";
          return param;
        }

        const ox = isNum(x) ? x : 0;
        const oy = isNum(y) ? y : 0;
        const oz = isNum(z) ? z : 0;

        const nx = Math.floor(ox / 8);
        const ny = oy;
        const nz = Math.floor(oz / 8);

        if (oy > 123 && oy < 256) {
          param.tech_comment =
            "To correctly link your portal, it has to be placed on top of the Nether roof! The portal will, however, still work if it isn't on the roof.";
        }

        param.tech_x = nx;
        param.tech_y = ny;
        param.tech_z = nz;
        param.tech_share = "share";
      } else if (cal === "2") {
        if (!isNum(x) && !isNum(y) && !isNum(z)) {
          param.error = "Please! Check Your Input";
          return param;
        }

        const nx = isNum(x) ? x : 0;
        const ny = isNum(y) ? y : 0;
        const nz = isNum(z) ? z : 0;

        const ox = nx * 8;
        const oy = ny;
        const oz = nz * 8;

        if (ny > 123 && ny < 256) {
          param.tech_comment =
            "To correctly link your portal, it has to be placed on top of the Nether roof! The portal will, however, still work if it isn't on the roof.";
        }

        param.tech_x = ox;
        param.tech_y = oy;
        param.tech_z = oz;
        param.tech_share = "share";
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }
    } else {
      if (
        isNum(x1) &&
        isNum(y1) &&
        isNum(z1) &&
        isNum(x2) &&
        isNum(y2) &&
        isNum(z2)
      ) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const dz = z2 - z1;
        const distance = Math.sqrt(dx ** 2 + dy ** 2 + dz ** 2);
        param.tech_distance = distance;
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }
    }

    return param;
  }

  /**
   * getCalculationCBMCalculator: Service Method
   * POST: /api/calculators-lol/cbm-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCBMCalculator(body) {
    let type = body.tech_type;
    let width = body.tech_width;
    let width_unit = body.tech_width_unit;
    let length = body.tech_length;
    let length_unit = body.tech_length_unit;
    let heigth = body.tech_heigth;
    let heigth_unit = body.tech_heigth_unit;
    let quantity = body.tech_quantity;
    let weight = body.tech_weight;
    let weight_unit = body.tech_weight_unit;

    const convertToCm = (unit, value) => {
      switch (unit) {
        case "m":
          return value * 100;
        case "mm":
          return value / 10;
        case "cm":
          return value;
        case "km":
          return value * 100000;
        case "in":
          return value * 2.54;
        case "ft":
          return value * 30.48;
        case "yd":
          return value * 91.44;
        case "mi":
          return value * 160934;
        default:
          return 0;
      }
    };

    const convertToMeter = (unit, value) => {
      switch (unit) {
        case "cm":
          return value / 100;
        case "mm":
          return value / 1000;
        case "m":
          return value;
        case "km":
          return value * 1000;
        case "in":
          return value / 39.37;
        case "ft":
          return value / 3.281;
        case "yd":
          return value / 1.094;
        case "mi":
          return value * 1609;
        default:
          return 0;
      }
    };

    const convertToKg = (unit, value) => {
      switch (unit) {
        case "ug":
          return value / 1e9;
        case "mg":
          return value / 1e6;
        case "g":
          return value / 1000;
        case "dag":
          return value / 100;
        case "lb":
          return value / 2.205;
        case "kg":
          return value;
        case "t":
          return value * 1000;
        case "gr":
          return value / 15432;
        case "dr":
          return value / 295;
        case "oz":
          return value / 35.274;
        case "stone":
          return value * 6.35;
        case "us-ton":
          return value * 907.2;
        case "long-ton":
          return value * 1016;
        case "earths":
          return value * 5.972e24;
        case "me":
          return value * 1.098e30;
        case "u":
          return value * 6.022e26;
        case "oz-t":
          return value / 32.151;
        default:
          return 0;
      }
    };

    const formatNumber = (value) => {
      return value.toLocaleString("en-US", {
        minimumFractionDigits: 2,
        maximumFractionDigits: 2,
      });
    };

    const param = {};

    if (!isNaN(width) && !isNaN(length) && !isNaN(heigth) && !isNaN(quantity)) {
      const width_m = convertToMeter(width_unit, width);
      const length_m = convertToMeter(length_unit, length);
      const heigth_m = convertToMeter(heigth_unit, heigth);

      if (type === "basic") {
        const cbm = width_m * length_m * heigth_m * quantity;
        param.tech_cbm = formatNumber(cbm);
        return param;
      } else if (type === "advance") {
        if (!isNaN(weight)) {
          const width_cm = convertToCm(width_unit, width);
          const length_cm = convertToCm(length_unit, length);
          const heigth_cm = convertToCm(heigth_unit, heigth);
          const weight_kg = convertToKg(weight_unit, weight);

          const cbm = width_m * length_m * heigth_m;
          const total_cbm = cbm * quantity;
          const total_weight = weight_kg * quantity;
          const volumetric_weight = (width_cm * length_cm * heigth_cm) / 5000;
          const total_volumetric_weight = volumetric_weight * quantity;
          const size_20 = Math.floor(33.2 / cbm);
          const size_40 = Math.floor(67.67 / cbm);
          const size_40_hq = Math.floor(76.3 / cbm);
          const size_45_hq = Math.floor(88.4 / cbm);

          param.tech_cbm = formatNumber(cbm);
          param.tech_total_cbm = formatNumber(total_cbm);
          param.tech_total_weight = formatNumber(total_weight);
          param.tech_total_volumetric_weight = formatNumber(
            total_volumetric_weight
          );
          param.tech_size_20 = size_20;
          param.tech_size_40 = size_40;
          param.tech_size_40_hq = size_40_hq;
          param.tech_size_45_hq = size_45_hq;
          return param;
        } else {
          return { status: "error", message: "Please! Check Your Input" };
        }
      }
    } else {
      return { status: "error", message: "Please! Check Your Input" };
    }
  }

  /**
   * getCalculationBikeSizeCalculator: Service Method
   * POST: /api/calculators-lol/bike-size-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBikeSizeCalculator(body) {
    let bike_for = body.tech_bike_for;
    let bike_type = body.tech_bike_type;
    let kids_age = body.tech_kids_age;
    let hight = body.tech_hight;
    let hight_unit = body.tech_hight_unit;
    let inseam_length = body.tech_inseam_length;
    let inseam_length_unit = body.tech_inseam_length_unit;

    function convertToCm(unit, value) {
      if (unit === "cm") return value;
      if (unit === "in") return value * 2.54;
      if (unit === "ft") return value * 30.48;
      if (unit === "mm") return value / 10;
      return null;
    }

    const param = {};

    if (bike_for) {
      if (bike_for === "kids") {
        if (kids_age) {
          let wheel_size, hight_result;

          if (kids_age === "2-3") {
            wheel_size = 12;
            hight_result = "86-102";
          } else if (kids_age === "2-4") {
            wheel_size = 14;
            hight_result = "94-109";
          } else if (kids_age === "4-6") {
            wheel_size = 16;
            hight_result = "109-122";
          } else if (kids_age === "5-8") {
            wheel_size = 20;
            hight_result = "114-130";
          } else if (kids_age === "8-11") {
            wheel_size = 24;
            hight_result = "122-135";
          } else if (kids_age === "11+") {
            wheel_size = 26;
            hight_result = "135-145";
          }

          param.tech_wheel_mm = (wheel_size * 25.4).toFixed(2);
          param.tech_wheel_cm = (wheel_size * 2.54).toFixed(2);
          param.tech_wheel_in = wheel_size;
          param.tech_wheel_ft = (wheel_size / 12).toFixed(2);
          param.tech_hight = hight_result;
          param.tech_kids_age = kids_age;
          return param;
        } else {
          return { error: "Please! Check Your Input" };
        }
      } else {
        if (bike_type && !isNaN(inseam_length) && !isNaN(hight)) {
          let inseam_cm = convertToCm(inseam_length_unit, inseam_length);
          let hight_cm = convertToCm(hight_unit, hight);

          let frame_size;
          if (["trekking", "city", "hybrid"].includes(bike_type)) {
            frame_size = inseam_cm * 0.64;
          } else if (bike_type === "road") {
            frame_size = inseam_cm * 0.67;
          } else if (bike_type === "mountain") {
            frame_size = inseam_cm * 0.67 - 11;
          }

          let crank_size_mm = inseam_cm * 1.25 + 65;

          param.tech_frame_mm = (frame_size * 10).toFixed(2);
          param.tech_frame_cm = frame_size.toFixed(2);
          param.tech_frame_in = (frame_size / 2.54).toFixed(2);
          param.tech_frame_ft = (frame_size / 30.48).toFixed(2);

          param.tech_crank_mm = crank_size_mm.toFixed(2);
          param.tech_crank_cm = (crank_size_mm / 10).toFixed(2);
          param.tech_crank_in = (crank_size_mm / 25.4).toFixed(2);
          param.tech_crank_ft = (crank_size_mm / 304.8).toFixed(2);

          param.tech_crank_dia_mm = (crank_size_mm * 2).toFixed(2);
          param.tech_crank_dia_cm = ((crank_size_mm / 10) * 2).toFixed(2);
          param.tech_crank_dia_in = ((crank_size_mm / 25.4) * 2).toFixed(2);
          param.tech_crank_dia_ft = ((crank_size_mm / 304.8) * 2).toFixed(2);

          param.tech_hight_mm = (hight_cm * 10).toFixed(2);
          param.tech_hight_cm = hight_cm.toFixed(2);
          param.tech_hight_in = (hight_cm / 2.54).toFixed(2);
          param.tech_hight_ft = (hight_cm / 30.48).toFixed(2);

          param.tech_inseam_mm = (inseam_cm * 10).toFixed(2);
          param.tech_inseam_cm = inseam_cm.toFixed(2);
          param.tech_inseam_in = (inseam_cm / 2.54).toFixed(2);
          param.tech_inseam_ft = (inseam_cm / 30.48).toFixed(2);
          return param;
        } else {
          return { error: "Please! Check Your Input" };
        }
      }
    } else {
      return { error: "Please! Check Your Input" };
    }
  }

  /**
   * getCalculationAcBtuCalculator: Service Method
   * POST: /api/calculators-lol/ac-btu-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationAcBtuCalculator(body) {
    let calculate = body.tech_calculate;
    let height = body.tech_height;
    let height_unit = body.tech_height_unit;
    let width = body.tech_width;
    let width_unit = body.tech_width_unit;
    let length = body.tech_length;
    let length_unit = body.ltech_ength_unit;
    let temperature = body.tech_temperature;
    let temperature_unit = body.tech_temperature_unit;
    let peoples = body.tech_peoples;
    let type = body.tech_type;
    let insulation_condition = body.tech_insulation_condition;
    let sun_exposure = body.tech_sun_exposure;
    let climate = body.tech_climate;

    function convertToFt(unit, value) {
      return unit === "m" ? value * 3.281 : value;
    }

    function formatNumber(num, decimals = 2) {
      return Number(num).toLocaleString("en-US", {
        minimumFractionDigits: decimals,
        maximumFractionDigits: decimals,
      });
    }

    if (
      !isNaN(height) &&
      !isNaN(width) &&
      !isNaN(length) &&
      insulation_condition
    ) {
      let height_ft = convertToFt(height_unit, height);
      let width_ft = convertToFt(width_unit, width);
      let length_ft = convertToFt(length_unit, length);
      let area = width_ft * length_ft;

      let btu = 0;
      let total_btu = 0;

      if (calculate === "ac") {
        if (area <= 150) btu = 5000;
        else if (area <= 250) btu = 6000;
        else if (area <= 300) btu = 7000;
        else if (area <= 350) btu = 8000;
        else if (area <= 400) btu = 9000;
        else if (area <= 450) btu = 10000;
        else if (area <= 550) btu = 12000;
        else if (area <= 700) btu = 14000;
        else if (area <= 1000) btu = 18000;
        else if (area <= 1200) btu = 21000;
        else if (area <= 1500) btu = 24000;
        else if (area <= 2000) btu = 30000;
        else if (area <= 2500) btu = 34000;
        else btu = area * 20;

        total_btu = btu;

        if (height_ft > 8) {
          total_btu += (height_ft - 8) * 1000;
        }

        if (type && sun_exposure && climate && !isNaN(peoples)) {
          if (peoples > 2) {
            total_btu += (peoples - 2) * 600;
          }

          if (type === "living-room") total_btu += 1000;
          else if (type === "kitchen") total_btu += 4000;
          else if (type === "above-floor") total_btu += btu * 0.1;

          if (insulation_condition === "good") total_btu -= btu * 0.2;
          else if (insulation_condition === "poor") total_btu += btu * 0.2;

          if (sun_exposure === "shaded") total_btu -= btu * 0.1;
          else if (sun_exposure === "sunny") total_btu += btu * 0.1;

          if (climate === "cold") total_btu -= btu * 0.15;
          else if (climate === "hot") total_btu += btu * 0.2;
        } else {
          return { status: "error", message: "Please! Check Your Input" };
        }
      } else {
        if (temperature !== undefined && temperature !== null) {
          let temperature_f =
            temperature_unit === "cel"
              ? (temperature * 9) / 5 + 32
              : temperature;
          let final_temp = Math.abs(temperature_f - 30);

          btu = area * height_ft * final_temp * 0.135;
          total_btu = btu;

          if (insulation_condition === "good") total_btu -= btu * 0.4;
          else if (insulation_condition === "poor") total_btu = btu * 2.1;
        } else {
          return { status: "error", message: "Please! Check Your Input" };
        }
      }

      let ton = (total_btu / 12000).toFixed(2);
      let wattsValue = total_btu * 0.29307107017222;
      let kilowatts = (total_btu * 0.00029307107017222).toFixed(2);
      let hp_i = (total_btu * 0.0003930147789222).toFixed(2);
      let hp_e = hp_i;

      return {
        tech_ton: ton,
        tech_watts: formatNumber(wattsValue),
        tech_kilowatts: kilowatts,
        tech_hp_i: hp_i,
        tech_hp_e: hp_e,
        tech_total_btu: Math.round(total_btu),
      };
    } else {
      return { status: "error", message: "Please! Check Your Input" };
    }
  }

  /**
   * getCalculationBlindSizeCalculator: Service Method
   * POST: /api/calculators-lol/blind-size-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBlindSizeCalculator(body) {
    let type = body.tech_type?.trim();
    let top = parseFloat(body.tech_top);
    let t_units = body.tech_t_units?.trim();
    let width = parseFloat(body.tech_width);
    let w_units = body.tech_w_units?.trim();
    let bottom = parseFloat(body.tech_bottom);
    let b_units = body.tech_b_units?.trim();
    let h_left = parseFloat(body.tech_h_left);
    let l_units = body.tech_l_units?.trim();
    let h_center = parseFloat(body.tech_h_center);
    let c_units = body.tech_c_units?.trim();
    let h_right = parseFloat(body.tech_h_right);
    let r_units = body.tech_r_units?.trim();

    let param = {};

    if (!type) {
      param.error = "Please! Check Your Inputs";
      return param;
    }

    if (
      isNaN(top) ||
      isNaN(width) ||
      isNaN(bottom) ||
      isNaN(h_left) ||
      isNaN(h_center) ||
      isNaN(h_right)
    ) {
      param.error = "Please! Check Your Inputs";
      return param;
    }

    function convertToInches(value, unit) {
      if (unit === "mm") return value / 25.4;
      if (unit === "cm") return value / 2.54;
      if (unit === "ft") return value * 12;
      return value; // already in inches
    }

    top = convertToInches(top, t_units);
    width = convertToInches(width, w_units);
    bottom = convertToInches(bottom, b_units);
    h_left = convertToInches(h_left, l_units);
    h_center = convertToInches(h_center, c_units);
    h_right = convertToInches(h_right, r_units);

    let blind_width,
      blind_lenght,
      s_lenght = "";

    if (type === "inside") {
      blind_width = Math.min(top, width, bottom);
      blind_lenght = Math.min(h_left, h_center, h_right);
      s_lenght = blind_lenght - 0.25;
    } else if (type === "outside") {
      blind_width = Math.min(top, width, bottom) + 3;
      blind_lenght = Math.min(h_left, h_center, h_right) + 1.5;
    }

    param.tech_type = type;
    param.tech_blind_width = +blind_width.toFixed(2);
    param.tech_blind_lenght = +blind_lenght.toFixed(2);
    param.tech_s_lenght = s_lenght !== "" ? +s_lenght.toFixed(2) : "";

    return param;
  }

  /**
   * getCalculationAverageTimeCalculator: Service Method
   * POST: /api/calculators-lol/average-time-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationAverageTimeCalculator(body) {
    let count_val = parseInt(body.tech_count_val);
    let inhour = body.tech_;
    let inminutes = body.tech_inminutes;
    let inseconds = body.tech_inseconds;
    let inmiliseconds = body.tech_inmiliseconds;
    let checkbox1 = body.tech_checkbox1;
    let checkbox2 = body.tech_checkbox2;
    let checkbox3 = body.tech_checkbox3;
    let checkbox4 = body.tech_checkbox4;

    let param = {};
    let hour_list = [];
    let min_list = [];
    let sec_list = [];
    let mili_list = [];
    let hoursminsandsecs = [];

    // Helper functions
    function calc_time(times) {
      let total = 0;
      for (let time of times) {
        let [h, m, s] = time.split(":").map(Number);
        total += h * 3600 + m * 60 + s;
      }
      return total;
    }

    function avg_time(times) {
      let total = calc_time(times);
      let avg = Math.round(total / times.length);
      let h = Math.floor(avg / 3600);
      avg %= 3600;
      let m = Math.floor(avg / 60);
      let s = avg % 60;
      return [
        h.toString().padStart(2, "0"),
        m.toString().padStart(2, "0"),
        s.toString().padStart(2, "0"),
      ];
    }

    for (let i = 0; i < count_val; i++) {
      let hour =
        checkbox1 === false ? 0 : inhour[i] === "" ? 0 : parseFloat(inhour[i]);
      let minute =
        checkbox2 === false
          ? 0
          : inminutes[i] === ""
          ? 0
          : parseFloat(inminutes[i]);
      let second =
        checkbox3 === false
          ? 0
          : inseconds[i] === ""
          ? 0
          : parseFloat(inseconds[i]);
      let milisecond =
        checkbox4 === false
          ? 0
          : inmiliseconds[i] === ""
          ? 0
          : parseFloat(inmiliseconds[i]);

      if (isNaN(hour) || isNaN(minute) || isNaN(second) || isNaN(milisecond)) {
        param.error = "Please! Check Your Input";
        return param;
      }

      hour_list.push(hour);
      min_list.push(minute);
      sec_list.push(second);
      mili_list.push(milisecond);

      let total_seconds = hour * 3600 + minute * 60 + second;
      let hours = Math.floor(total_seconds / 3600);
      let mins = Math.floor((total_seconds % 3600) / 60);
      let secs = Math.floor(total_seconds % 60);
      hoursminsandsecs.push(
        `${hours.toString().padStart(2, "0")}:${mins
          .toString()
          .padStart(2, "0")}:${secs.toString().padStart(2, "0")}`
      );
    }

    let [hr, min, s] = avg_time(hoursminsandsecs);
    let total_milliseconds = mili_list.reduce((sum, val) => sum + val, 0);
    let avg_milliseconds = total_milliseconds / mili_list.length;

    param.tech_hour_list = hour_list;
    param.tech_min_list = min_list;
    param.tech_sec_list = sec_list;
    param.tech_mili_list = mili_list;
    param.tech_time_hour = hr;
    param.tech_time_minutes = min;
    param.tech_time_seconds = s;
    param.tech_time_miliseconds = avg_milliseconds;

    return param;
  }

  /**
   * getCalculationHourlyPayCalculator: Service Method
   * POST: /api/calculators-lol/hourly-pay-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationHourlyPayCalculator(body) {
    let paytype = parseFloat(body.tech_paytype);
    let status = body.tech_status;
    let paidtype = body.tech_paidtype;
    let working = body.tech_working;
    let grosspay = body.tech_grosspay;
    let wage = body.tech_wage;
    let overtimeType = body.tech_overtimeType;
    let h_over = body.tech_h_over;
    let w_over = body.tech_w_over;

    let param = {};
    let weekly_salary = [];
    let salaries = [];
    let overtimes = [];

    function calculateFederalTax(income, filingStatus, standardDeduction) {
      const federalTaxBrackets = {
        single: [
          [0, 11000, 0.1],
          [11000, 44725, 0.12],
          [44725, 95375, 0.22],
          [95375, 182100, 0.24],
          [182100, 231250, 0.32],
          [231250, 578125, 0.35],
          [578125, Infinity, 0.37],
        ],
        married: [
          [0, 22000, 0.1],
          [22000, 89450, 0.12],
          [89450, 190750, 0.22],
          [190750, 364200, 0.24],
          [364200, 462500, 0.32],
          [462500, 693750, 0.35],
          [693750, Infinity, 0.37],
        ],
        head_of_household: [
          [0, 15700, 0.1],
          [15700, 59850, 0.12],
          [59850, 95350, 0.22],
          [95350, 182100, 0.24],
          [182100, 231250, 0.32],
          [231250, 578100, 0.35],
          [578100, Infinity, 0.37],
        ],
      };

      let taxableIncome = income - standardDeduction;
      if (taxableIncome <= 0) return 0;

      let tax = 0;
      for (let [lower, upper, rate] of federalTaxBrackets[filingStatus]) {
        if (taxableIncome > lower) {
          let amountInBracket = Math.min(taxableIncome, upper) - lower;
          tax += amountInBracket * rate;
          if (taxableIncome <= upper) break;
        }
      }
      return tax;
    }

    if (paytype && status) {
      for (let i = 0; i < paidtype.length; i++) {
        if (paidtype[i] === "hourly") {
          if (!isNaN(working[i]) && !isNaN(wage[i])) {
            let weekly = working[i] * wage[i];
            weekly_salary.push(weekly);
            salaries.push(weekly);
          } else {
            param.error = "Please! Check Your Input.";
            return param;
          }
        } else {
          if (grosspay[i] === "per_year") {
            if (!isNaN(wage[i])) {
              let weekly = wage[i] / paytype;
              weekly_salary.push(weekly);
              salaries.push(weekly);
            } else {
              param.error = "Please! Check Your Input.";
              return param;
            }
          } else {
            if (!isNaN(wage[i])) {
              weekly_salary.push(wage[i]);
              salaries.push(wage[i]);
            } else {
              param.error = "Please! Check Your Input.";
              return param;
            }
          }
        }
      }

      for (let j = 0; j < overtimeType.length; j++) {
        if (overtimeType[j] && !isNaN(h_over[j]) && !isNaN(w_over[j])) {
          let overtimeRate = overtimeType[j] === "overtime" ? 1.5 : 2;
          let overtimePay = h_over[j] * w_over[j] * overtimeRate;
          weekly_salary.push(overtimePay);
          overtimes.push(overtimePay);
        }
      }

      let total_weekly_salary = weekly_salary.reduce((a, b) => a + b, 0);
      let annualSalary = total_weekly_salary * paytype;

      let medicareTax =
        (annualSalary * 0.0145) / (annualSalary / total_weekly_salary);
      let socialSecurityTax = Math.min(annualSalary, 160200) * 0.062;
      socialSecurityTax =
        socialSecurityTax / (annualSalary / total_weekly_salary);

      let standardDeduction = 13850;
      let federalTax = calculateFederalTax(
        annualSalary,
        status,
        standardDeduction
      );
      federalTax = federalTax / (annualSalary / total_weekly_salary);
      if (federalTax > 2) federalTax -= 2;

      let total_tax = medicareTax + socialSecurityTax + federalTax;
      let take_home = total_weekly_salary - total_tax;

      param.tech_salaries = salaries;
      param.tech_overtimes = overtimes;
      param.tech_weekly_salary = weekly_salary;
      param.tech_total_weekly_salary = parseFloat(
        total_weekly_salary.toFixed(2)
      );
      param.tech_annualSalary = parseFloat(annualSalary.toFixed(2));
      param.tech_medicareTax = parseFloat(medicareTax.toFixed(2));
      param.tech_socialSecurityTax = Math.round(socialSecurityTax);
      param.tech_federalTax = parseFloat(federalTax.toFixed(2));
      param.tech_total_tax = parseFloat(total_tax.toFixed(2));
      param.tech_take_home = parseFloat(take_home.toFixed(2));

      return param;
    } else {
      param.error = "Please! Check Your Input.";
      return param;
    }
  }

  /** getCalculationLogWeightCalculator
   * POST: /api/calculators-lol/hourly-pay-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationLogWeightCalculator(body) {
    let category = body.tech_category;
    let woodSelector = body.tech_woodSelector;
    let small_end = body.tech_small_end;
    let small_unit = body.tech_small_unit;
    let large_end = body.tech_large_end;
    let large_unit = body.tech_large_unit;
    let length = body.tech_length;
    let length_unit = body.tech_length_unit;
    let stack_w = body.tech_stack_w;
    let stackw_unit = body.tech_stackw_unit;
    let stack_h = body.tech_stack_h;
    let stackh_unit = body.tech_stackh_unit;
    let custom = body.tech_custom;
    let custom_unit = body.tech_custom_unit;
    let submit = body.tech_submit;

    woodSelector = woodSelector?.replace("@", "");

    if (!submit) {
      return { error: "Please check your input" };
    }

    function convertToSm(a, unit) {
      const conversions = {
        cm: 1,
        m: 100,
        in: 2.54,
        ft: 30.48,
        yd: 91.44,
        mm: 0.1,
      };
      return a * (conversions[unit] || 1);
    }

    function calculateToLb(a, unit) {
      const conversions = {
        kg: 2.20462,
        lb: 1,
        st: 14,
        us_tom: 2000,
        l_ton: 2240,
      };
      return a * (conversions[unit] || 1);
    }

    function unitToFt(a, unit) {
      const conversions = {
        "kg/m³": 0.062428,
        "lb/ft": 1,
        "lb/yd": 0.037037037,
        "g/cm³": 62.427961,
        "kg/cm³": 62427.960591578,
        "g/m³": 0.000062427961,
      };
      return a * (conversions[unit] || 1);
    }

    let dm_of_mid, volume, weight, quantity_stack, weight_stack;

    if (category === "log") {
      if (!isNaN(small_end)) {
        let ds = convertToSm(small_end, small_unit);
        let dl = convertToSm(large_end, large_unit);
        let len = convertToSm(length, length_unit);
        let custom_val = unitToFt(custom, custom_unit);
        let stackWidth = convertToSm(stack_w, stackw_unit);
        let stackHeight = convertToSm(stack_h, stackh_unit);

        dm_of_mid = (ds + ds) / 2;
        volume = len * ((Math.PI * dm_of_mid * dm_of_mid) / 4) * 0.000035315;
        volume = parseFloat(volume.toFixed(7));

        weight =
          woodSelector === "custom"
            ? volume * custom_val
            : volume * parseFloat(woodSelector);

        stackWidth /= ds;
        stackHeight /= dl;

        quantity_stack = stackWidth * stackHeight;
        weight_stack = quantity_stack * weight;
      } else {
        return { error: "Please check your input" };
      }
    } else if (category === "board") {
      if (!isNaN(small_end) && !isNaN(large_end)) {
        let ds = convertToSm(small_end, small_unit);
        let dl = convertToSm(large_end, large_unit);
        let len = convertToSm(length, length_unit);
        let custom_val = unitToFt(custom, custom_unit);
        let stackWidth = convertToSm(stack_w, stackw_unit);
        let stackHeight = convertToSm(stack_h, stackh_unit);

        dm_of_mid = (ds + ds) / 2;
        volume = len * ds * dl * 0.000035315;
        volume = parseFloat(volume.toFixed(7));

        weight =
          woodSelector === "custom"
            ? volume * custom_val
            : volume * parseFloat(woodSelector);

        stackWidth /= ds;
        stackHeight /= dl;

        quantity_stack = stackWidth * stackHeight;
        weight_stack = quantity_stack * weight;
      } else {
        return { error: "Please check your input" };
      }
    }

    return {
      tech_dm_of_mid: dm_of_mid,
      tech_volume: volume,
      tech_weight: weight,
      tech_quantity_stack: quantity_stack,
      tech_weight_stack: weight_stack,
    };
  }

  /** getCalculationWaterWeightCalculator
   * POST: /api/calculators-lol/hourly-pay-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationWaterWeightCalculator(body) {
    let from = parseFloat(body.tech_from);
    let vol = parseFloat(body.tech_vol);
    let temp = parseFloat(body.tech_temp);

    if (isFinite(from) && isFinite(vol) && isFinite(temp)) {
      let ans = (1.0e16 / (from / vol)) * temp;
      let lbs = ans * 0.0022;
      let onz = ans * 0.03527396195;
      let kg = ans * 0.001;

      return {
        tech_gram: ans,
        tech_lbs: lbs,
        tech_onz: onz,
        tech_kg: kg,
      };
    } else {
      return {
        error: "Please! Check Your Inputs",
      };
    }
  }

  /** getCalculationTurkeySizeCalculator
   * POST: /api/calculators-lol/turkey-size-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationTurkeySizeCalculator(body) {
    let adults = parseFloat(body.tech_adults);
    let children = parseFloat(body.tech_children);
    let leftovers = body.tech_leftovers;

    function convertToHoursMins(time, format = "%02d hrs %02d mins") {
      if (time < 1) return null;
      let hours = Math.floor(time / 60);
      let minutes = Math.round(time % 60);
      return format
        .replace("%02d", String(hours).padStart(2, "0"))
        .replace("%02d", String(minutes).padStart(2, "0"));
    }

    if (
      isFinite(adults) &&
      adults >= 0 &&
      isFinite(children) &&
      children >= 0
    ) {
      let mul1, mul2, turkey_weight;

      if (leftovers === "no") {
        mul1 = adults;
        mul2 = 0.5 * children;
      } else {
        mul1 = adults * 1.5;
        mul2 = 0.75 * children;
      }

      turkey_weight = mul1 + mul2;
      let inside_fridge = turkey_weight * 5;
      let cold_water = turkey_weight;
      let unstuffed_turkey = convertToHoursMins(turkey_weight * 15);
      let stuffed_turkey = convertToHoursMins(turkey_weight * 17.5);

      return {
        tech_turkey_weight: turkey_weight,
        tech_inside_fridge: inside_fridge,
        tech_cold_water: cold_water,
        tech_unstuffed_turkey: unstuffed_turkey,
        tech_stuffed_turkey: stuffed_turkey,
      };
    } else if (adults < 0) {
      return { error: "Number of adults cannot be lower than 0." };
    } else if (children < 0) {
      return { error: "Number of children cannot be lower than 0." };
    } else {
      return { error: "Please! Check Your Inputs" };
    }
  }

  /** getCalculationAverageAtomicMassCalculator
   * POST: /api/calculators-lol/average-atomic-mass-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAverageAtomicMassCalculator(body) {
    let isotopes_no = body.tech_isotopes_no;
    let per = body.tech_per;
    let per_unit = body.tech_per_unit;
    let mass = body.tech_mass;

    let param = {};

    if (
      typeof isotopes_no === "number" &&
      Array.isArray(per) &&
      Array.isArray(per_unit) &&
      Array.isArray(mass)
    ) {
      let am_array = [];

      for (let i = 0; i < isotopes_no; i++) {
        if (per_unit[i] !== undefined && !isNaN(per[i]) && !isNaN(mass[i])) {
          let abundance = per_unit[i] === "decimal" ? per[i] : per[i] / 100;
          am_array[i] = mass[i] * abundance;
        } else {
          param.error = "Please! Check Your Input.";
          return param;
        }
      }

      let amSum = am_array.reduce((a, b) => a + b, 0);

      param.tech_amSum = amSum;
      param.tech_per = per;
      param.tech_mass = mass;
      return param;
    } else {
      param.error = "Please! Check Your Input.";
      return param;
    }
  }

  /** getCalculationGibbsFreeEnergyCalculator
   * POST: /api/calculators-lol/gibbs-free-energy-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationGibbsFreeEnergyCalculator(body) {
    let entropy = body.tech_entropy;
    let enthalpy = body.tech_enthalpy;
    let temperature = body.tech_temperature;
    let enthalpy_units = body.tech_enthalpy_units;
    let entropy_units = body.tech_entropy_units;
    let t_units = body.tech_t_units;

    let param = {};

    // Convert entropy units to KJ
    if (entropy_units) {
      if (entropy_units == "KJ") {
        entropy = entropy;
      } else if (entropy_units == "cal") {
        entropy = entropy * 0.004184;
      } else if (entropy_units == "kcal") {
        entropy = entropy * 4.184;
      } else if (entropy_units == "J") {
        entropy = entropy * 0.001;
      }
    }

    if (enthalpy_units) {
      if (enthalpy_units == "KJ") {
        enthalpy = enthalpy;
      } else if (enthalpy_units == "cal") {
        enthalpy = enthalpy * 0.004184;
      } else if (enthalpy_units == "kcal") {
        enthalpy = enthalpy * 4.184;
      } else if (enthalpy_units == "J") {
        enthalpy = enthalpy * 0.001;
      }
    }
    if (t_units) {
      if (t_units == "°F") {
        temperature = ((temperature - 32) * 5) / 9 + 273.15;
      } else if (t_units == "°C") {
        temperature = temperature + 273.15;
      }
    }

    // Validate numeric inputs
    if (
      typeof enthalpy === "number" &&
      typeof entropy === "number" &&
      typeof temperature === "number"
    ) {
      let gibbs_free_energy = enthalpy * 1000 - temperature * entropy * 1000; // J
      let gibbs = gibbs_free_energy / 1000; // KJ

      param.tech_gibbs = gibbs;
      param.tech_enthalpy = body.tech_enthalpy;
      param.tech_entropy = body.tech_entropy;
      param.tech_temperature = body.tech_temperature;
      return param;
    } else {
      param.error = "Please! Check Your Input.";
      return param;
    }
  }

  /** getCalculationvaporPressureCalculator
   * POST: /api/calculators-lol/vapor-pressure-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationvaporPressureCalculator(body) {
    let t1 = body.tech_t1;
    let t1_units = body.tech_t1_units;
    let t2 = body.tech_t2;
    let t2_units = body.tech_t2_units;
    let p1 = body.tech_p1;
    let p1_units = body.tech_p1_units; // not used in calculation, assumed already in correct unit
    let deltaHvap = body.tech_deltaHvap;
    let deltaHvap_units = body.tech_deltaHvap_units;
    let p_sol = body.tech_p_sol;
    let p_sol_units = body.tech_p_sol_units;
    let x_sol = body.tech_x_sol;

    let param = {};

    function convertToKelvin(value, unit) {
      switch (unit) {
        case "°C":
          return value + 273.15;
        case "°F":
          return ((value - 32) * 5) / 9 + 273.15;
        case "k":
          return value;
        case "°R":
          return (value * 5) / 9;
        case "°De":
          return 373.15 - (value * 2) / 3;
        case "°N":
          return (value * 100) / 33 + 273.15;
        case "°Ré":
          return (value * 5) / 4 + 273.15;
        case "°Rø":
          return ((value - 7.5) * 40) / 21 + 273.15;
        default:
          return null;
      }
    }

    function convertToPascals(value, unit) {
      switch (unit) {
        case "Pa":
          return value;
        case "Bar":
          return value * 100000;
        case "psi":
          return value * 6894.76;
        case "at":
        case "atm":
          return value * 101325;
        case "Torr":
          return value * 133.322;
        case "hPa":
          return value * 100;
        case "kPa":
          return value * 1000;
        case "MPa":
          return value * 1000000;
        case "GPa":
          return value * 1000000000;
        default:
          return null;
      }
    }

    function convertToJoules(value, unit) {
      switch (unit) {
        case "J":
          return value;
        case "KJ":
          return value * 1000;
        case "MJ":
          return value * 1000000;
        case "Wh":
          return value * 3600;
        case "KWh":
          return value * 3.6e6;
        case "ft-lb":
          return value * 1.35582;
        case "kcal":
          return value * 4184;
        default:
          return null;
      }
    }

    if (
      typeof t1 === "number" &&
      typeof t2 === "number" &&
      typeof p1 === "number" &&
      typeof deltaHvap === "number" &&
      typeof p_sol === "number" &&
      typeof x_sol === "number"
    ) {
      t1 = convertToKelvin(t1, t1_units);
      t2 = convertToKelvin(t2, t2_units);
      deltaHvap = convertToJoules(deltaHvap, deltaHvap_units);
      p_sol = convertToPascals(p_sol, p_sol_units);
      const R = 8.314;

      const rightSide = (-deltaHvap / R) * (1 / t2 - 1 / t1);
      let p2 = p1 * Math.exp(rightSide);
      let xsolvent = p_sol * x_sol;

      param.tech_p2 = p2;
      param.tech_xsolvent = xsolvent;
      return param;
    } else {
      param.error = "Please! Check Your Input.";
      return param;
    }
  }

  /** getCalculationEntropyCalculator
   * POST: /api/calculators-lol/entropy-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationEntropyCalculator(body) {
    let point_unit = body.tech_point_unit?.trim();
    let products = body.tech_products?.toString().trim();
    let products_unit = body.tech_products_unit?.trim();
    let reactants = body.tech_reactants?.toString().trim();
    let reactants_unit = body.tech_reactants_unit?.trim();
    let enthalpy = body.tech_enthalpy?.toString().trim();
    let enthalpy_unit = body.tech_enthalpy_unit?.trim();
    let temperature = body.tech_temperature?.toString().trim();
    let temperature_unit = body.tech_temperature_unit?.trim();
    let entropy = body.tech_entropy?.toString().trim();
    let entropy_unit = body.tech_entropy_unit?.trim();
    let base_unit = body.tech_base_unit?.trim();
    let moles = body.tech_moles?.toString().trim();
    let initial = body.tech_initial?.toString().trim();
    let initial_unit = body.tech_initial_unit?.trim();
    let pre_one_unit = body.tech_pre_one_unit?.trim();
    let final = body.tech_final?.toString().trim();
    let final_unit = body.tech_final_unit?.trim();
    let pre_two_unit = body.tech_pre_two_unit?.trim();

    let param = {};

    // Conversion stubs (define your actual logic here)

    function joules_unit(value, unit) {
      value = parseFloat(value);
      if (isNaN(value)) return null;

      switch (unit.toLowerCase()) {
        case "j/mol*k":
          return value;
        case "kj/mol*k":
          return value * 1000;
        case "mj/mol*k":
          return value * 1000000;
        case "wh/mol*k":
          return value * 3600;
        case "kwh/mol*k":
          return value * 3.6e6;
        case "ft-lb/mol*k":
          return value / 0.7375621493;
        case "cal/mol*k":
          return value * 4.184;
        case "kcal/mol*k":
          return value * 4184;
        case "ev/mol*k":
          return value / 6.242e18;
        default:
          return null; // Unsupported unit
      }
    }
    function joulez_unit(value, unit) {
      value = parseFloat(value);
      if (isNaN(value)) return null;

      switch (unit.toLowerCase()) {
        case "j":
          return value;
        case "kj":
          return value * 1000;
        case "mj":
          return value * 1000000;
        case "wh":
          return value * 3600;
        case "kwh":
          return value * 3.6e6;
        case "ft-lb":
          return value / 0.7375621493;
        case "cal":
          return value * 4.184;
        case "kcal":
          return value * 4184;
        case "ev":
          return value / 6.242e18;
        default:
          return null; // Unsupported unit
      }
    }
    function joulesz_unit(value, unit) {
      value = parseFloat(value);
      if (isNaN(value)) return null;

      switch (unit.toLowerCase()) {
        case "j/k":
          return value;
        case "kj/k":
          return value * 1000;
        case "mj/k":
          return value * 1000000;
        case "wh/k":
          return value * 3600;
        case "kwh/k":
          return value * 3.6e6;
        case "ft-lb/k":
          return value / 0.7375621493;
        case "cal/k":
          return value * 4.184;
        case "kcal/k":
          return value * 4184;
        case "ev/k":
          return value / 6.242e18;
        default:
          return null; // Unsupported unit
      }
    }
    function temp_unit(temperature, temperature_unit) {
      temperature = parseFloat(temperature); // Ensure it's a number

      if (isNaN(temperature)) {
        return null;
      }
      switch (temperature_unit) {
        case "°C":
          return temperature + 273.15; // Celsius to Kelvin
        case "°F":
          return (temperature - 32) * (5 / 9) + 273.15; // Fahrenheit to Kelvin
        case "K":
          return temperature; // Already Kelvin
        default:
          return null; // Invalid unit
      }
    }
    function firstunit(initial, initial_unit) {
      initial = parseFloat(initial);
      if (isNaN(initial)) return null;
      switch (initial_unit) {
        case "mm³":
          return initial;
        case "cm³":
          return initial * 1000;
        case "dm³":
          return initial * 1000000;
        case "m³":
          return initial * 1000000000;
        case "in³":
          return initial / 0.00006102; // 1 in³ = 16,387.064 mm³
        case "ft³":
          return initial * 28316846.592;
        case "ml":
          return initial / 0.001;
        case "cl":
          return initial * 10000;
        case "l":
          return initial * 1000000;
        case "US gal":
          return initial * 3785411.784;
        case "UK gal":
          return initial * 4546090.05;
        case "US fl oz":
          return initial / 0.000033814;
        case "UK fl oz":
          return initial / 0.000035195;
        default:
          return null; // Unsupported unit
      }
    }

    function sec_unit(initial, pre_one_unit) {
      initial = parseFloat(initial);
      if (isNaN(initial)) return null;

      switch (pre_one_unit) {
        case "Pa":
          return initial;
        case "Bar":
          return initial * 100000;
        case "psi":
          return initial * 6895;
        case "at":
          return initial / 0.0000101972;
        case "atm":
          return initial / 0.000009869;
        case "Torr":
          return initial * 133.3;
        case "hPa":
          return initial * 100;
        case "kPa":
          return initial * 1000;
        case "MPa":
          return initial * 1000000;
        case "GPa":
          return initial * 1000000000;
        case "inHg":
          return initial * 3386.39;
        case "mmHg":
          return initial * 133.322;
        default:
          return null; // Unsupported unit
      }
    }

    if (point_unit === "entropy change for a reaction") {
      if (!isNaN(products) && !isNaN(reactants)) {
        products = joules_unit(products, products_unit);
        reactants = joules_unit(reactants, reactants_unit);

        if (products == 0 || reactants == 0) {
          param.error =
            products == 0
              ? "total entropy Of Products value cannot be equal to zero."
              : "total entropy Of reactants value cannot be equal to zero.";
          return param;
        }

        param.entropy_reaction = products - reactants;
      } else {
        param.error = "Please! Check Your Input.";
        return param;
      }
    } else if (point_unit === "gibbs free energy ΔG = ΔH - T*ΔS") {
      if (!isNaN(enthalpy) && !isNaN(temperature) && !isNaN(entropy)) {
        enthalpy = joulez_unit(enthalpy, enthalpy_unit);
        entropy = joulesz_unit(entropy, entropy_unit);
        temperature = temp_unit(temperature, temperature_unit);
        param.tech_gibbs = enthalpy - temperature * entropy;
      } else {
        param.error = "Please! Check Your Input.";
        return param;
      }
    } else if (point_unit === "isothermal entropy change of an ideal gas") {
      if (base_unit === "volume") {
        if (!isNaN(moles) && !isNaN(initial) && !isNaN(final)) {
          if (
            parseFloat(moles) == 0 ||
            parseFloat(initial) == 0 ||
            parseFloat(final) == 0
          ) {
            param.error = "moles, initial, or final cannot be zero.";
            return param;
          }

          initial = firstunit(initial, initial_unit);
          final = firstunit(final, final_unit);
          param.tech_answer =
            parseFloat(moles) * 8.3145 * Math.log(final / initial);
        } else {
          param.error = "Please! Check Your Input.";
          return param;
        }
      } else if (base_unit === "pressure") {
        if (!isNaN(moles) && !isNaN(initial) && !isNaN(final)) {
          initial = sec_unit(initial, pre_one_unit);
          final = sec_unit(final, pre_two_unit);
          param.tech_answers =
            -parseFloat(moles) * 8.3145 * Math.log(final / initial);
        } else {
          param.error = "Please! Check Your Input.";
          return param;
        }
      } else {
        param.error = "Please! Check Your Input.";
        return param;
      }
    } else {
      param.error = "Please! Check Your Input.";
      return param;
    }
    return param;
  }

  /** getCalculationSolutionDilutionCalculator
   * POST: /api/calculators-lol/solution-dilution-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSolutionDilutionCalculator(body) {
    let concentration = parseFloat(body.tech_concentration);
    let concentration_unit = body.tech_concentration_unit?.trim();
    let volume = parseFloat(body.tech_volume);
    let volume_unit = body.tech_volume_unit?.trim();
    let final = parseFloat(body.tech_final);
    let final_unit = body.tech_final_unit?.trim();

    function convertToMolar(value, unit) {
      switch (unit) {
        case "M":
          return value;
        case "mM":
          return value / 1000;
        case "μM":
          return value / 1000000;
        case "nM":
          return value / 1000000000;
        case "pM":
          return value / 1000000000000;
        case "fM":
          return value / 1000000000000000;
        case "aM":
          return value / 1e18;
        case "zM":
          return value / 1e21;
        case "yM":
          return value / 1e24;
        default:
          return null;
      }
    }

    function unitToLiters(value, unit) {
      switch (unit) {
        case "mm³":
          return value / 1e9;
        case "cm³":
          return value / 1000;
        case "dm³":
          return value;
        case "m³":
          return value * 1000;
        case "in³":
          return value / 61023.7;
        case "ft³":
          return value * 28.3168;
        case "yd³":
          return value / 764.555;
        case "ml":
          return value / 1000;
        case "cl":
          return value / 100;
        case "l":
          return value;
        case "US gal":
          return value * 3.78541;
        case "UK gal":
          return value * 4.54609;
        case "US fl oz":
          return value / 33.814;
        case "UK fl oz":
          return value / 35.1951;
        case "cups":
          return value * 0.284131;
        case "tbsp":
          return value / 67.628;
        case "tsp":
          return value / 202.884;
        case "US qt":
          return value * 0.946353;
        case "UK qt":
          return value * 1.13652;
        case "US pt":
          return value / 1.05669;
        case "UK pt":
          return value / 1.13652;
        default:
          return null;
      }
    }

    let param = {};

    if (!isNaN(concentration) && !isNaN(volume) && !isNaN(final)) {
      let convertedConcentration = convertToMolar(
        concentration,
        concentration_unit
      );
      let convertedVolume = unitToLiters(volume, volume_unit);
      let convertedFinal = convertToMolar(final, final_unit);
      if (convertedFinal === 0 || convertedFinal === null) {
        param.error = "Concentration (final) cannot be zero or invalid.";
        return param;
      }

      let answer = (convertedConcentration * convertedVolume) / convertedFinal;
      console.log(
        convertedConcentration,
        convertedVolume,
        convertedFinal,
        answer
      );
      param.tech_answer = answer;
      return param;
    } else {
      param.error = "Please! Check Your Input.";
      return param;
    }
  }

  /** getCalculationChemicalEquationBalancerCalculator
   * POST: /api/calculators-lol/chemical-equation-balancer-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationChemicalEquationBalancerCalculator(body) {
    let eq = body.tech_eq?.trim();
    let param = {};

    if (!eq || /<|&|php|print_r|print|echo|script|%/i.test(eq)) {
      param.error = "Please Enter Valid Input.";
      return param;
    }

    // Prepare the equation
    let parem = eq
      .replace(/\s+/g, "")
      .replace(/→|->/g, "=")
      .replace(/%20/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/\^/g, "**");

    let [r, p] = parem.split("=");
    let option = 2;

    try {
      let response = await axios.get("http://167.172.134.148/limiting", {
        params: { r, p },
        timeout: 120000,
      });

      if (response.status !== 200 || !response.data.includes("@@@")) {
        param.error = "Please! Check Your Equation.";
        return param;
      }

      let [be, mols, atoms] = response.data.split("@@@");
      let inp = parem.replace(/plus/g, "+");

      param.tech_inp = inp;
      param.tech_be = be;
      param.tech_mols = mols;
      param.tech_atoms = atoms;
      param.tech_chemical_equation = eq.replace(/→|->/g, "=");
      param.tech_option = option;
      return param;
    } catch (error) {
      param.error = "Please! Check Your Input.";
      return param;
    }
  }

  /** getCalculationLimitingReactantCalculator
   * POST: /api/calculators-lol/limiting-reactant-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLimitingReactantCalculator(body) {
    let eq = (body.tech_eq || "").trim();

    // Validation against potentially dangerous input
    const invalidPattern = /<|>|&|php|print_r|print|echo|script|%/i;
    if (invalidPattern.test(eq)) {
      return { error: "Please Enter Valid Input." };
    }

    if (!eq) {
      return { error: "Please! Check Your Input." };
    }

    try {
      let parem = eq;
      parem = parem.replace(/\s+/g, "");
      parem = parem.replace(/%20/g, "");
      parem = parem.replace(/\+/g, "plus");
      parem = parem.replace(/{/g, "(");
      parem = parem.replace(/}/g, ")");
      parem = parem.replace(/e\^sqrt\(x\)/g, "exp(2*x)");
      parem = parem.replace(/e\^|exp\^/g, "exp");
      parem = parem.replace(/\^/g, "**");

      const [r, p] = parem.split("=");
      const option = 2;

      const response = await axios.get("http://167.172.134.148/limiting", {
        params: { r, p },
        timeout: 120000, // 120 seconds
      });

      const buffer = response.data.split("@@@");
      const inp = parem.replace(/plus/g, "+");

      return {
        teach_inp: inp,
        teach_be: buffer[0],
        teach_mols: buffer[1],
        teach_atoms: buffer[2],
        teach_chemical_equation: eq,
        teach_option: option,
      };
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationRedoxReactionCalculator
   * POST: /api/calculators-lol/redox-reaction-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRedoxReactionCalculator(body) {
    let eq = (body.tech_eq || "").trim();

    if (eq) {
      eq = eq.replace(/plus/g, "+");

      return {
        tech_eq: eq,
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /** getCalculationPPMCalculator
   * POST: /api/calculators-lol/ppm-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPPMCalculator(body) {
    let type = body.tech_calculator_name;
    let operations = body.tech_operations;
    let first = body.tech_first;
    let drop1 = body.tech_drop1;
    let drop2 = body.tech_drop2;
    let drop3 = body.tech_drop3;
    let second = body.tech_second;
    let drop4 = body.tech_drop4;
    let third = body.tech_third;

    let response = { tech_type: type };

    first = parseFloat(first);
    second = parseFloat(second);
    third = parseFloat(third);

    if (type === "calculator1") {
      if (isNaN(first)) {
        return { error: "Please! Check Your Input." };
      }

      switch (operations) {
        case "1":
          response.tech_answer1 = first;
          response.tech_answer2 = first * 100;
          response.tech_answer3 = first * 1000;
          response.tech_answer4 = first * 1000000;
          response.tech_answer5 = first * 1000000000;
          response.tech_answer6 = first * 1000000000000;
          break;
        case "2":
          response.tech_answer1 = first / 100;
          response.tech_answer2 = first;
          response.tech_answer3 = first * 10;
          response.tech_answer4 = first * 10000;
          response.tech_answer5 = first * 10000000;
          response.tech_answer6 = first * 10000000000;
          break;
        case "3":
          response.tech_answer1 = first / 1000;
          response.tech_answer2 = first / 10;
          response.tech_answer3 = first;
          response.tech_answer4 = first * 1000;
          response.tech_answer5 = first * 1000000;
          response.tech_answer6 = first * 1000000000;
          break;
        case "4":
          response.tech_answer1 = first / 1000000;
          response.tech_answer2 = first / 10000;
          response.tech_answer3 = first / 1000;
          response.tech_answer4 = first;
          response.tech_answer5 = first * 1000;
          response.tech_answer6 = first * 1000000;
          break;
        case "5":
          response.tech_answer1 = first / 1000000000;
          response.tech_answer2 = first / 10000000;
          response.tech_answer3 = first / 1000000;
          response.tech_answer4 = first / 1000;
          response.tech_answer5 = first;
          response.tech_answer6 = first * 1000;
          break;
        case "6":
          response.tech_answer1 = first / 1000000000000;
          response.tech_answer2 = first / 10000000000;
          response.tech_answer3 = first / 1000000000;
          response.tech_answer4 = first / 1000000;
          response.tech_answer5 = first / 1000;
          response.tech_answer6 = first;
          break;
        default:
          return { error: "Please! Check Your Input." };
      }
    } else if (type === "calculator2") {
      if (drop1 == 1 || drop1 == 2) {
        if (drop2 == 1) {
          if (drop4 == 1) {
            if (isNaN(second) || isNaN(third))
              return { error: "Please! Check Your Input." };
            let jawab1 = third * second;
            response.tech_jawab2 = parseFloat((jawab1 / 24.45).toFixed(3));
          } else if (drop4 == 2) {
            if (isNaN(second) || isNaN(third))
              return { error: "Please! Check Your Input." };
            let jawab1 = third * 24.45;
            response.tech_jawab2 = parseFloat((jawab1 / second).toFixed(3));
          }
        } else if (drop2 == 2) {
          if (drop4 == 1) {
            if (isNaN(second) || isNaN(third))
              return { error: "Please! Check Your Input." };
            let jawab1 = third * second;
            let jawab3 = jawab1 / 24.45;
            response.tech_jawab2 = jawab3 / 100000000000;
          } else if (drop4 == 2) {
            if (isNaN(second) || isNaN(third))
              return { error: "Please! Check Your Input." };
            let jawab1 = third * 24.45;
            let jawab3 = jawab1 / second;
            response.tech_jawab2 = jawab3 * 100000000000;
          }
        }
      } else if (drop1 == 3) {
        if (drop2 == 1) {
          if (drop4 == 1) {
            if (isNaN(third)) return { error: "Please! Check Your Input." };
            response.tech_jawab2 = parseFloat((third * 1.29).toFixed(3));
          } else if (drop4 == 2) {
            if (isNaN(third)) return { error: "Please! Check Your Input." };
            response.tech_jawab2 = parseFloat((third * 0.773).toFixed(3));
          }
        } else if (drop2 == 2) {
          if (drop4 == 1) {
            if (isNaN(third)) return { error: "Please! Check Your Input." };
            response.tech_jawab2 = parseFloat((third * 1000).toFixed(3));
          } else if (drop4 == 2) {
            if (isNaN(third)) return { error: "Please! Check Your Input." };
            response.tech_jawab2 = parseFloat((third / 1000).toFixed(3));
          }
        }
      }
    } else {
      return { error: "Invalid calculator_name" };
    }

    return response;
  }

  /** getCalculationMolalityCalculator
   * POST: /api/calculators-lol/molality-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMolalityCalculator(body) {
    let find = body.tech_find;
    let amount_solute = parseFloat(body.tech_amount_solute);
    let amount_solute_unit = body.tech_amount_solute_unit;
    let mass_solvent = parseFloat(body.tech_mass_solvent);
    let mass_solvent_unit = body.tech_mass_solvent_unit;
    let molality = parseFloat(body.tech_molality);
    let molality_unit = body.tech_molality_unit;
    let type = body.tech_type;
    let density = parseFloat(body.tech_density);
    let density_unit = parseFloat(body.tech_density_unit);
    let molecular_mass_solute = parseFloat(body.tech_molecular_mass_solute);
    let molecular_mass_solute_unit = parseFloat(
      body.tech_molecular_mass_solute_unit
    );

    let response = {};

    const unitConversion = {
      amount_solute_unit: {
        mol: 1,
        mmol: 0.001,
        µmol: 1e-6,
        nmol: 1e-9,
        pmol: 1e-12,
      },
      mass_solvent_unit: {
        µg: 1e-9,
        mg: 1e-6,
        g: 0.001,
        dag: 0.01,
        kg: 1,
        oz: 0.02835,
        lbs: 0.4536,
      },
      molality_unit: {
        "mol/µg": 1e-9,
        "mol/mg": 1e-6,
        "mol/g": 0.001,
        "mol/dag": 0.01,
        "mol/kg": 1,
        "mol/oz": 0.02835,
        "mol/lbs": 0.4536,
      },
    };

    amount_solute_unit =
      unitConversion.amount_solute_unit[amount_solute_unit] || 1;
    mass_solvent_unit =
      unitConversion.mass_solvent_unit[mass_solvent_unit] || 1;
    molality_unit = unitConversion.molality_unit[molality_unit] || 1;

    if (type === "first") {
      if (find === "1") {
        if (!isNaN(amount_solute) && !isNaN(mass_solvent)) {
          let amount_solute_value = amount_solute * amount_solute_unit;
          let mass_solvent_value = mass_solvent * mass_solvent_unit;
          let calculate_molality = amount_solute_value / mass_solvent_value;
          response.tech_molality = calculate_molality;
        } else {
          return { error: "Please! Check Your Input." };
        }
      } else if (find === "2") {
        if (!isNaN(molality) && !isNaN(mass_solvent)) {
          let mass_solvent_value = mass_solvent * mass_solvent_unit;
          let calculate_molality_value = molality * molality_unit;
          let amount_of_solute = mass_solvent_value * calculate_molality_value;
          response.tech_amount_of_solute = amount_of_solute;
        } else {
          return { error: "Please! Check Your Input." };
        }
      } else if (find === "3") {
        if (!isNaN(molality) && !isNaN(amount_solute)) {
          let amount_solute_value = amount_solute * amount_solute_unit;
          let calculate_molality_value = molality * molality_unit;
          let mass_of_solvent = amount_solute_value / calculate_molality_value;
          response.tech_amount_of_solvent = mass_of_solvent;
        } else {
          return { error: "Please! Check Your Input." };
        }
      }

      response.tech_method = find;
    } else if (type === "second") {
      if (
        !isNaN(density) &&
        !isNaN(molecular_mass_solute) &&
        !isNaN(molality)
      ) {
        let density_value = density * density_unit;
        let molecular_mass_solute_value =
          molecular_mass_solute / molecular_mass_solute_unit;
        let calculate_molality_value = molality * molality_unit;
        let calculate_molarity =
          density_value /
          (1 / calculate_molality_value + molecular_mass_solute_value / 1000);
        response.tech_molality = calculate_molarity;
      } else {
        return { error: "Please! Check Your Input." };
      }
    }

    response.tech_type = type;
    return response;
  }

  /** getCalculationMoleRatioCalculator
   * POST: /api/calculators-lol/mole-ratio-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMoleRatioCalculator(body) {
    let find = body.tech_find;
    let first_coefficient = body.tech_first_coefficient;
    let first_product = body.tech_first_product;
    let moles = body.tech_moles;

    let z = 0;
    let y = 0;
    let response = {};

    if (find === "1" || find === "2" || find === "3") {
      for (let i = 0; i < first_coefficient.length; i++) {
        if (isFinite(first_coefficient[i]) && first_coefficient[i] > 0) {
          z++;
        } else {
          response.error = "Please! Check Your Input.";
          return response;
        }
      }

      for (let j = 0; j < first_product.length; j++) {
        if (isFinite(first_product[j]) && first_product[j] > 0) {
          y++;
        } else {
          response.error = "Please! Check Your Input.";
          return response;
        }
      }
    }

    if (find === "2" && Array.isArray(moles)) {
      for (let k = 0; k < first_coefficient.length - 1; k++) {
        let smith =
          (moles[k] * first_coefficient[k + 1]) / first_coefficient[k];
        // You can add smith to response if needed
        // Example: response[`smith_${k}`] = smith;
      }
    }

    if (z === first_coefficient.length && y === first_product.length) {
      response.tch_coefficient = first_coefficient;
      response.tch_first_product = first_product;
    }

    return response;
  }

  /** getCalculationMolarityCalculator
   * POST: /api/calculators-lol/molarity-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMolarityCalculator(body) {
    let cal = String(body.tech_cal).trim();
    let mass = parseFloat(body.tech_mass);
    let mass_unit = String(body.tech_mass_unit).trim();
    let vol = parseFloat(body.tech_vol);
    let vol_unit = String(body.tech_vol_unit).trim();
    let conc = parseFloat(body.tech_conc);
    let conc_unit = String(body.tech_conc_unit).trim();
    let sc = parseFloat(body.tech_sc);
    let sc_unit = String(body.tech_sc_unit).trim();
    let dc = parseFloat(body.tech_dc);
    let dc_unit = String(body.tech_dc_unit).trim();
    let dv = parseFloat(body.tech_dv);
    let dv_unit = String(body.tech_dv_unit).trim();
    let mw = parseFloat(body.tech_mw);

    let response = {};

    const isValid = [mass, vol, conc, mw, sc, dc, dv].every((v) => !isNaN(v));

    if (!isValid) {
      response.error = "Please! Check Your Input.";
      return response;
    }

    // Unit conversions
    const unitConvert = {
      mass: { pg: 1e-12, ng: 1e-9, μg: 1e-6, mg: 1e-3, kg: 1e3 },
      vol: { nL: 1e-9, μL: 1e-6, mL: 1e-3 },
      conc: { fM: 1e-15, pM: 1e-12, nM: 1e-9, μM: 1e-6, mM: 1e-3 },
    };

    if (mass_unit in unitConvert.mass) mass *= unitConvert.mass[mass_unit];
    if (conc_unit in unitConvert.conc) conc *= unitConvert.conc[conc_unit];
    if (vol_unit in unitConvert.vol) vol *= unitConvert.vol[vol_unit];
    if (sc_unit in unitConvert.conc) sc *= unitConvert.conc[sc_unit];
    if (dc_unit in unitConvert.conc) dc *= unitConvert.conc[dc_unit];
    if (dv_unit in unitConvert.vol) dv *= unitConvert.vol[dv_unit];

    if (cal === "mass" && !isNaN(conc) && !isNaN(mw) && !isNaN(vol)) {
      mass = conc * vol * mw;
      response.tech_ans = `${(mass / 0.001).toFixed(
        4
      )} <span class="text-green font-s-25">mg</span>`;
      response.tech_ans_pg = `${(mass / 1e-12).toFixed(4)} pg`;
      response.tech_ans_ng = `${(mass / 1e-9).toFixed(4)} ng`;
      response.tech_ans_ug = `${(mass / 1e-6).toFixed(4)} μg`;
      response.tech_ans_g = `${mass.toFixed(4)} g`;
      response.tech_ans_kg = `${(mass / 1e6).toFixed(4)} kg`;
    } else if (cal === "vol" && !isNaN(mass) && !isNaN(mw) && !isNaN(conc)) {
      vol = mass / (conc * mw);
      response.tech_ans = `${(vol / 0.001).toFixed(
        4
      )} <span class="text-green font-s-25">mL</span>`;
      response.tech_ans_nl = `${(vol / 1e-9).toFixed(4)} nL`;
      response.tech_ans_ul = `${(vol / 1e-6).toFixed(4)} μL`;
      response.tech_ans_l = `${vol.toFixed(4)} L`;
    } else if (cal === "mol" && !isNaN(mass) && !isNaN(mw) && !isNaN(vol)) {
      let mol = mass / (vol * mw);
      response.tech_ans = `${(mol / 1e-3).toFixed(
        4
      )} <span class="text-green font-s-25">mM</span>`;
      response.tech_ans_fm = `${(mol / 1e-15).toFixed(4)} fM`;
      response.tech_ans_pm = `${(mol / 1e-12).toFixed(4)} pM`;
      response.tech_ans_nm = `${(mol / 1e-9).toFixed(4)} nM`;
      response.tech_ans_um = `${(mol / 1e-6).toFixed(4)} μM`;
      response.tech_ans_m = `${mol.toFixed(4)} M`;
    } else if (cal === "rv" && !isNaN(sc) && !isNaN(dc) && !isNaN(dv)) {
      if (dc > sc) {
        response.error =
          "Desired Concentration shouldn't be greater than Stock Concentration.";
        return response;
      }
      let rv = (dc / sc) * dv;
      response.tech_ans = `${(rv / 0.001).toFixed(
        4
      )} <span class="text-green font-s-25">mL</span>`;
      response.tech_ans_nl = `${(rv / 1e-9).toFixed(4)} nL`;
      response.tech_ans_ul = `${(rv / 1e-6).toFixed(4)} μL`;
      response.tech_ans_l = `${rv.toFixed(4)} L`;
    } else {
      response.error = "Please! Check Your Input.";
      return response;
    }

    return response;
  }
  /** getCalculationDilutionCalculator
   * POST: /api/calculators-lol/dilution-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDilutionCalculator(body) {
    let cal = body.tech_cal;
    let c1 = body.tech_c1;
    let c1_unit = body.tech_c1_unit;
    let v1 = body.tech_v1;
    let v1_unit = body.tech_v1_unit;
    let c2 = body.tech_c2;
    let c2_unit = body.tech_c2_unit;
    let v2 = body.tech_v2;
    let v2_unit = body.tech_v2_unit;

    c1 = parseFloat(c1);
    v1 = parseFloat(v1);
    c2 = parseFloat(c2);
    v2 = parseFloat(v2);

    let response = {};

    if (isFinite(c1) && isFinite(v1) && isFinite(c2) && isFinite(v2)) {
      // Convert concentration units to M
      if (c1_unit === "fM") c1 *= 1e-15;
      else if (c1_unit === "pM") c1 *= 1e-12;
      else if (c1_unit === "nM") c1 *= 1e-9;
      else if (c1_unit === "μM") c1 *= 1e-6;
      else if (c1_unit === "mM") c1 *= 1e-3;

      if (c2_unit === "fM") c2 *= 1e-15;
      else if (c2_unit === "pM") c2 *= 1e-12;
      else if (c2_unit === "nM") c2 *= 1e-9;
      else if (c2_unit === "μM") c2 *= 1e-6;
      else if (c2_unit === "mM") c2 *= 1e-3;

      // Convert volume units to L
      if (v1_unit === "nL") v1 *= 1e-9;
      else if (v1_unit === "μL") v1 *= 1e-6;
      else if (v1_unit === "mL") v1 *= 1e-3;

      if (v2_unit === "nL") v2 *= 1e-9;
      else if (v2_unit === "μL") v2 *= 1e-6;
      else if (v2_unit === "mL") v2 *= 1e-3;

      if (cal === "c1") {
        c1 = (c2 * v2) / v1;
        response.tech_ans = `${(c1 / 1e-3).toFixed(
          4
        )} <span class="text-green font-s-25">mM</span>`;
        response.tech_ans_fm = `${(c1 / 1e-15).toFixed(4)} fM`;
        response.tech_ans_pm = `${(c1 / 1e-12).toFixed(4)} pM`;
        response.tech_ans_nm = `${(c1 / 1e-9).toFixed(4)} nM`;
        response.tech_ans_um = `${(c1 / 1e-6).toFixed(4)} μM`;
        response.tech_ans_m = `${c1.toFixed(4)} M`;
      } else if (cal === "v1") {
        v1 = (c2 * v2) / c1;
        response.tech_ans = `${(v1 / 1e-3).toFixed(
          4
        )} <span class="text-green font-s-25">mL</span>`;
        response.tech_ans_nl = `${(v1 / 1e-9).toFixed(4)} nL`;
        response.tech_ans_ul = `${(v1 / 1e-6).toFixed(4)} μL`;
        response.tech_ans_l = `${v1.toFixed(4)} L`;
      } else if (cal === "c2") {
        c2 = (c1 * v1) / v2;
        response.tech_ans = `${(c2 / 1e-3).toFixed(
          4
        )} <span class="text-green font-s-25">mM</span>`;
        response.tech_ans_fm = `${(c2 / 1e-15).toFixed(4)} fM`;
        response.tech_ans_pm = `${(c2 / 1e-12).toFixed(4)} pM`;
        response.tech_ans_nm = `${(c2 / 1e-9).toFixed(4)} nM`;
        response.tech_ans_um = `${(c2 / 1e-6).toFixed(4)} μM`;
        response.tech_ans_m = `${c2.toFixed(4)} M`;
      } else if (cal === "v2") {
        v2 = (c1 * v1) / c2;
        response.tech_ans = `${(v2 / 1e-3).toFixed(
          4
        )} <span class="text-green font-s-25">mL</span>`;
        response.tech_ans_nl = `${(v2 / 1e-9).toFixed(4)} nL`;
        response.tech_ans_ul = `${(v2 / 1e-6).toFixed(4)} μL`;
        response.tech_ans_l = `${v2.toFixed(4)} L`;
      } else {
        response.error = "Please! Check Your Input.";
        return response;
      }

      return response;
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationAtomtoMolesCalculator
   * POST: /api/calculators-lol/atoms-to-moles-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAtomtoMolesCalculator(body) {
    let form = body.tech_form?.trim();
    let x = parseFloat(body.tech_x?.trim());

    let response = {};

    if (isFinite(x)) {
      let ans;

      if (form === "raw") {
        // Convert atomic mass unit to grams
        ans = x * 1.66053907e-24;
      } else {
        // Convert grams to number of atoms/moles
        ans = x * 6.02214076e23;
      }

      response.tech_ans = ans;
      return response;
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationGramstoAtomsCalculator
   * POST: /api/calculators-lol/grams-to-atoms-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationGramstoAtomsCalculator(body) {
    let form = body.tech_form?.trim();
    let x = parseFloat(body.tech_x?.trim());
    let y = parseFloat(body.tech_y?.trim());

    let response = {};

    if (isFinite(x)) {
      const na = 6.02214076e23;
      let ans;

      if (form === "raw") {
        ans = (na * y) / x;
      } else {
        ans = (y * x) / na;
      }

      response.tech_ans = ans.toExponential(3); // Same as sprintf('%.3e', ...) in PHP
      return response;
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationPkaToPhCalculator
   * POST: /api/calculators-lol/pka-to-ph-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPkaToPhCalculator(body) {
    const buf_unit = body.tech_buf_unit;
    const ka = parseFloat(body.tech_ka);
    const acid = parseFloat(body.tech_acid);
    const acid_unit = body.tech_acid_unit;
    const salt = parseFloat(body.tech_salt);
    const salt_unit = body.tech_salt_unit;
    const convert = body.tech_convert;
    const ph_input = parseFloat(body.tech_ph);

    const response = {};

    const log10 = (x) => Math.log(x) / Math.LN10;

    const getUnitMultiplier = (unit) => {
      switch (unit) {
        case "M":
          return 1;
        case "mM":
          return 0.001;
        case "μM":
          return 0.000001;
        default:
          return 0;
      }
    };

    const acid_unitx = getUnitMultiplier(acid_unit);
    const salt_unitx = getUnitMultiplier(salt_unit);

    const isValidNumber = (val) => isFinite(val) && val > 0;

    if (convert === "1") {
      // Convert from Ka to pH
      if (
        (buf_unit === "1" || buf_unit === "2") &&
        isValidNumber(ka) &&
        isValidNumber(acid) &&
        isValidNumber(salt)
      ) {
        const av = acid * acid_unitx;
        const sv = salt * salt_unitx;

        if (av <= 0 || sv <= 0) {
          return {
            error: "Converted acid/salt value must be greater than zero.",
          };
        }

        let pka = -log10(ka);
        if (pka === -0) pka = 0;

        let ph;
        if (buf_unit === "1") {
          ph = pka - log10(av / sv);
        } else {
          ph = 14 - pka + log10(av / sv);
        }

        if (!isFinite(ph)) {
          return { error: "Calculation resulted in an invalid pH value." };
        }

        response.tech_unit = buf_unit;
        response.tech_pka = pka;
        response.tech_ph = ph;
      } else {
        return {
          error:
            "Please! Enter positive numeric values for Ka, Acid, and Salt.",
        };
      }
    } else if (convert === "2") {
      // Convert from pH to Ka
      if (
        (buf_unit === "1" || buf_unit === "2") &&
        isValidNumber(ph_input) &&
        isValidNumber(acid) &&
        isValidNumber(salt)
      ) {
        const av = acid * acid_unitx;
        const sv = salt * salt_unitx;

        if (av <= 0 || sv <= 0) {
          return {
            error: "Converted acid/salt value must be greater than zero.",
          };
        }

        let pka;
        if (buf_unit === "1") {
          pka = ph_input + log10(av / sv);
        } else {
          pka = 14 - ph_input + log10(av / sv);
        }

        const pk = Math.pow(10, -pka);

        if (!isFinite(pka) || !isFinite(pk)) {
          return {
            error: "Calculation resulted in an invalid pKa or Ka value.",
          };
        }

        response.tech_unit = buf_unit;
        response.tech_pka = pka;
        response.tech_pk = pk;
      } else {
        return {
          error:
            "Please! Enter positive numeric values for pH, Acid, and Salt.",
        };
      }
    } else {
      return { error: "Invalid conversion type." };
    }

    return response;
  }

  /** getCalculationTheoreticalyieldCalculator
   * POST: /api/calculators-lol/theoretical-yield-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTheoreticalyieldCalculator(body) {
    let lx = parseFloat(body.tech_lx);
    let ly = parseFloat(body.tech_ly);
    let dx = parseFloat(body.tech_dx);
    let dy = parseFloat(body.tech_dy);
    let sx = parseFloat(body.tech_sx);
    let unit_x = body.tech_unit_x;

    let response = {};

    if (
      isFinite(lx) &&
      isFinite(ly) &&
      isFinite(dx) &&
      isFinite(dy) &&
      isFinite(sx)
    ) {
      let mass = lx;

      if (unit_x === "µg") {
        mass = mass / 1e6;
      } else if (unit_x === "mg") {
        mass = mass / 1000;
      } else if (unit_x === "kg") {
        mass = mass * 1000;
      } else if (unit_x === "lbs") {
        mass = mass * 454;
      }

      let mole = Math.round((mass / ly) * 100) / 100; // rounded to 2 decimal places
      let ans = Math.round(dx * dy * 100) / 100;
      let st = Math.round(dx * (sx / mole) * 100) / 100;

      response.tech_mole = mole;
      response.tech_st = st;
      response.tech_ans = ans;
      return response;
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationMolecularFormulaCalculator
   * POST: /api/calculators-lol/molecular-formula-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMolecularFormulaCalculator(body) {
    let no1 = parseFloat(body.tech_no1);
    let opt1 = body.tech_opt1?.trim();
    let no2 = parseFloat(body.tech_no2);
    let opt2 = body.tech_opt2?.trim();

    let response = {};

    if (isFinite(no1) && isFinite(no2) && opt1 && opt2) {
      let [nbr1, name] = opt1.split("@@");
      let [nbr2, name2] = opt2.split("@@");

      nbr1 = parseFloat(nbr1);
      nbr2 = parseFloat(nbr2);

      if (!isFinite(nbr1) || !isFinite(nbr2)) {
        response.error = "Invalid compound structure in opt1 or opt2.";
        return response;
      }

      let final_result1 = no1 / nbr1;
      let final_result2 = no2 / nbr2;
      let final_result3 = final_result1 / final_result2;

      response.tech_mode = 2;
      response.tech_name = name;
      response.tech_name2 = name2;
      response.tech_nbr1 = nbr1;
      response.tech_nbr2 = nbr2;
      response.tech_no1 = no1;
      response.tech_no2 = no2;
      response.tech_final_result1 = final_result1;
      response.tech_final_result2 = final_result2;
      response.tech_final_result3 = final_result3;

      return response;
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationFormalChargeCalculator
   * POST: /api/calculators-lol/formal-charge-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationFormalChargeCalculator(body) {
    let V = parseFloat(body.tech_V);
    let LP = parseFloat(body.tech_LP);
    let BE = parseFloat(body.tech_BE);

    let response = {};

    if (isFinite(V) && isFinite(LP) && isFinite(BE)) {
      let formal = V - (LP + 0.5 * BE);

      response.tech_formal = formal;
      return response;
    } else {
      response.error = "Please! Check Your Input.";
      return response;
    }
  }

  /** getCalculationEquilibriumConstantCalculator
   * POST: /api/calculators-lol/equilibrium-constant-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationEquilibriumConstantCalculator(body) {
    let concentration_one = parseFloat(body.tech_concentration_one);
    let concentration_one_unit = body.tech_concentration_one_unit;
    let concentration_two = parseFloat(body.tech_concentration_two);
    let concentration_two_unit = body.tech_concentration_two_unit;
    let concentration_three = parseFloat(body.tech_concentration_three);
    let concentration_three_unit = body.tech_concentration_three_unit;
    let concentration_four = parseFloat(body.tech_concentration_four);
    let concentration_four_unit = body.tech_concentration_four_unit;

    let a = parseFloat(body.tech_a);
    let b = parseFloat(body.tech_b);
    let c = parseFloat(body.tech_c);
    let d = parseFloat(body.tech_d);
    let selection = body.tech_selection;
    let chemical_equation = body.tech_chemical_equation || "";
    let total_pressure = parseFloat(body.tech_total_pressure);

    let response = {};

    // Input validation for chemical equation
    if (/[<>&]|php|print_r|print|echo|script|%/i.test(chemical_equation)) {
      response.error = "Please Enter Valid Input.";
      return response;
    }

    // Helper: Convert unit
    function convertUnit(unit, value) {
      switch (unit) {
        case "M":
          return value * 1;
        case "mM":
          return value * 0.001;
        case "μM":
          return value * 1e-6;
        case "nM":
          return value * 1e-9;
        case "pM":
          return value * 1e-12;
        case "fM":
          return value * 1e-15;
        case "aM":
        case "zM":
        case "yM":
          return value * 0;
        default:
          return NaN;
      }
    }

    if (chemical_equation) {
      if (selection === "1") {
        if (
          isFinite(concentration_one) &&
          isFinite(concentration_two) &&
          isFinite(concentration_three) &&
          isFinite(concentration_four) &&
          isFinite(a) &&
          isFinite(b) &&
          isFinite(c) &&
          isFinite(d)
        ) {
          let first_value = convertUnit(
            concentration_one_unit,
            concentration_one
          );
          let second_value = convertUnit(
            concentration_two_unit,
            concentration_two
          );
          let third_value = convertUnit(
            concentration_three_unit,
            concentration_three
          );
          let fourth_value = convertUnit(
            concentration_four_unit,
            concentration_four
          );

          let Kc =
            (Math.pow(third_value, c) * Math.pow(fourth_value, d)) /
            (Math.pow(second_value, b) * Math.pow(first_value, a));

          response.tech_answer = Kc;
          response.tech_opt = selection;
          return response;
        } else {
          response.error = "Please! Check Your Input.";
          return response;
        }
      } else if (selection === "2") {
        if (isFinite(total_pressure) && chemical_equation !== "") {
          response.tech_equation = chemical_equation;
          response.tech_total_pressure = total_pressure;
          response.tech_opt = selection;
          return response;
        } else {
          response.error = "Please! Check Your Input.";
          return response;
        }
      }
    }

    response.error = "Please Enter Valid Input.";
    return response;
  }

  /** getCalculationElectronConfigurationCalculator
   * POST: /api/calculators-lol/electron-configuration-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationElectronConfigurationCalculator(body) {
    let element = body.tech_element;

    if (!element) {
      return { error: "Element is required" };
    }

    const periodicTable = {
      H: [1, "Hydrogen", "Gas", 1.008, "1s¹", "N/A", "1s¹"],
      He: [2, "Helium", "Gas", 4.0026, "1s²", "N/A", "1s²"],
      Li: [3, "Lithium", "Solid", 6.94, "1s²2s¹", "[He]2s¹", "2s¹"],
      Be: [4, "Beryllium", "Solid", 9.0122, "1s²2s²", "[He]2s²", "2s²"],
      B: [5, "Boron", "Solid", 10.81, "1s²2s²2p¹", "[He]2s²2p¹", "2s²2p¹"],
      C: [6, "Carbon", "Solid", 12.011, "1s²2s²2p²", "[He]2s²2p²", "2s²2s²"],
      N: [7, "Nitrogen", "Gas", 14.007, "1s²2s²2p³", "[He]2s²2p³", "2s²2p³"],
      O: [8, "Oxygen", "Gas", 15.999, "1s²2s²2p⁴", "[He]2s²2p⁴", "2s²2p⁴"],
      F: [9, "Fluorine", "Gas", 18.998, "1s²2s²2p⁵", "[He]2s²2p⁵", "2s²2p⁵"],
      Ne: [10, "Neon", "Gas", 20.18, "1s²2s²2p⁶", "[He]2s²2p⁶", "2s²2p⁶"],
      Na: [11, "Sodium", "Solid", 22.99, "1s²2s²2p⁶3s¹", "[Ne]3s¹", "3s¹"],
      Mg: [12, "Magnesium", "Solid", 24.305, "1s²2s²2p⁶3s²", "[Ne]3s²", "3s²"],
      Al: [
        13,
        "Aluminum",
        "Solid",
        26.982,
        "1s²2s²2p⁶3s²3p¹",
        "[Ne]3s²3p¹",
        "3s²3p¹",
      ],
      Si: [
        14,
        "Silicon",
        "Solid",
        28.085,
        "1s²2s²2p⁶3s²3p²",
        "[Ne]3s²3p²",
        "3s²3p²",
      ],
      P: [
        15,
        "Phosphorus",
        "Solid",
        30.974,
        "1s²2s²2p⁶3s²3p³",
        "[Ne]3s²3p³",
        "3s²3p³",
      ],
      S: [
        16,
        "Sulfur",
        "Solid",
        32.06,
        "1s²2s²2p⁶3s²3p⁴",
        "[Ne]3s²3p⁴",
        "3s²3p⁴",
      ],
      Cl: [
        17,
        "Chlorine",
        "Gas",
        35.45,
        "1s²2s²2p⁶3s²3p⁵",
        "[Ne]3s²3p⁵",
        "3s²3p⁵",
      ],
      Ar: [
        18,
        "Argon",
        "Gas",
        39.948,
        "1s²2s²2p⁶3s²3p⁶",
        "[Ne]3s²3p⁶",
        "3s²3p⁶",
      ],
      K: [
        19,
        "Potassium",
        "Solid",
        39.098,
        "1s²2s²2p⁶3s²3p⁶4s¹",
        "[Ar]4s¹",
        "4s¹",
      ],
      Ca: [
        20,
        "Calcium",
        "Solid",
        40.078,
        "1s²2s²2p⁶3s²3p⁶4s²",
        "[Ar]4s²",
        "4s²",
      ],
      Sc: [
        21,
        "Scandium",
        "Solid",
        44.956,
        "1s²2s²2p⁶3s²3p⁶3d¹4s²",
        "[Ar]4s²3d¹",
        "3d¹4s²",
      ],
      Ti: [
        22,
        "Titanium",
        "Solid",
        47.867,
        "1s²2s²2p⁶3s²3p⁶3d²4s²",
        "[Ar]4s²3d²",
        "3d²4s²",
      ],
      V: [
        23,
        "Vanadium",
        "Solid",
        50.942,
        "1s²2s²2p⁶3s²3p⁶3d³4s²",
        "[Ar]4s²3d³",
        "3d³4s²",
      ],
      Cr: [
        24,
        "Chromium",
        "Solid",
        51.996,
        "1s²2s²2p⁶3s²3p⁶3d⁵4s¹",
        "[Ar]3d⁵4s¹",
        "3d⁵4s¹",
      ],
      Mn: [
        25,
        "Manganese",
        "Solid",
        54.938,
        "1s²2s²2p⁶3s²3p⁶3d⁵4s²",
        "[Ar]4s²3d⁵",
        "3d⁵4s²",
      ],
      Fe: [
        26,
        "Iron",
        "Solid",
        55.845,
        "1s²2s²2p⁶3s²3p⁶3d64s²",
        "[Ar]4s²3d⁶",
        "3d64s²",
      ],
      Co: [
        27,
        "Cobalt",
        "Solid",
        58.933,
        "1s²2s²2p⁶3s²3p⁶3d⁷4s²",
        "[Ar]4s²3d⁷",
        "3d⁷4s²",
      ],
      Ni: [
        28,
        "Nickel",
        "Solid",
        58.693,
        "1s²2s²2p⁶3s²3p⁶3d⁸4s²",
        "[Ar]4s²3d⁸",
        "3d⁸4s²",
      ],
      Cu: [
        29,
        "Copper",
        "Solid",
        63.546,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s¹",
        "[Ar]4s¹3d¹⁰",
        "3d¹⁰4s¹",
      ],
      Zn: [
        30,
        "Zinc",
        "Solid",
        65.38,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²",
        "[Ar]4s²3d¹⁰",
        "3d¹⁰4s²",
      ],
      Ga: [
        31,
        "Gallium",
        "Solid",
        69.723,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p¹",
        "[Ar]4s²3d¹⁰4p¹",
        "4s²4p¹",
      ],
      Ge: [
        32,
        "Germanium",
        "Solid",
        72.63,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p²",
        "[Ar]4s²3d¹⁰4p²",
        "4s²4p²",
      ],
      As: [
        33,
        "Arsenic",
        "Solid",
        74.922,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p³",
        "[Ar]4s²3d¹⁰4p³",
        "4s²4p³",
      ],
      Se: [
        34,
        "Selenium",
        "Solid",
        78.971,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁴",
        "[Ar]4s²3d¹⁰4p⁴",
        "4s²4p⁴",
      ],
      Br: [
        35,
        "Bromine",
        "Liquid",
        79.904,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁵",
        "[Ar]4s²3d¹⁰4p⁵",
        "4s²4p⁵",
      ],
      Kr: [
        36,
        "Krypton",
        "Gas",
        83.798,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶",
        "[Ar]4s²3d¹⁰4p⁶",
        "4s²4p⁶",
      ],
      Rb: [
        37,
        "Rubidium",
        "Solid",
        85.468,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶5s¹",
        "[Kr]5s¹",
        "5s¹",
      ],
      Sr: [
        38,
        "Strontium",
        "Solid",
        87.62,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶5s²",
        "[Kr]5s²",
        "5s²",
      ],
      Y: [
        39,
        "Yttrium",
        "Solid",
        88.906,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹5s²",
        "[Kr]5s²4d¹",
        "4d¹5s²",
      ],
      Zr: [
        40,
        "Zirconium",
        "Solid",
        91.224,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d²5s²",
        "[Kr]5s²4d²",
        "4d²5s²",
      ],
      Nb: [
        41,
        "Niobium",
        "Solid",
        92.906,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d⁴5s¹",
        "[Kr]5s¹4d⁴",
        "4d⁴5s¹",
      ],
      Mo: [
        42,
        "Molybdenum",
        "Solid",
        95.95,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d⁵5s¹",
        "[Kr]5s¹4d⁵",
        "4d⁵5s¹",
      ],
      Tc: [
        43,
        "Technetium",
        "Solid",
        98,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d⁵5s²",
        "[Kr]5s²4d⁵",
        "4d⁵5s²",
      ],
      Ru: [
        44,
        "Ruthenium",
        "Solid",
        101.07,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d⁷5s¹",
        "[Kr]5s¹4d⁷",
        "4d⁷5s¹",
      ],
      Rh: [
        45,
        "Rhodium",
        "Solid",
        102.91,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d⁸5s¹",
        "[Kr]5s¹4d⁸",
        "4d⁸5s¹",
      ],
      Pd: [
        46,
        "Palladium",
        "Solid",
        106.42,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰",
        "[Kr]4d¹⁰",
        "4d¹⁰",
      ],
      Ag: [
        47,
        "Silver",
        "Solid",
        107.87,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s¹",
        "[Kr]5s¹4d¹⁰",
        "4d¹⁰5s¹",
      ],
      Cd: [
        48,
        "Cadmium",
        "Solid",
        112.41,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²",
        "[Kr]5s²4d¹⁰",
        "4d¹⁰5s²",
      ],
      In: [
        49,
        "Indium",
        "Solid",
        114.82,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p¹",
        "[Kr]5s²4d¹⁰5p¹",
        "5s²5p¹",
      ],
      Sn: [
        50,
        "Tin",
        "Solid",
        118.71,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p²",
        "[Kr]5s²4d¹⁰5p²",
        "5s²5p²",
      ],
      Sb: [
        51,
        "Antimony",
        "Solid",
        121.76,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p³",
        "[Kr]5s²4d¹⁰5p³",
        "5s²5p³",
      ],
      Te: [
        52,
        "Tellurium",
        "Solid",
        127.6,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁴",
        "[Kr]5s²4d¹⁰5p⁴",
        "5s²5p⁴",
      ],
      I: [
        53,
        "Iodine",
        "Solid",
        126.9,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁵",
        "[Kr]5s²4d¹⁰5p⁵",
        "5s²5p⁵",
      ],
      Xe: [
        54,
        "Xenon",
        "Gas",
        131.29,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶",
        "[Kr]5s²4d¹⁰5p⁶",
        "5s²5p⁶",
      ],
      Cs: [
        55,
        "Cesium",
        "Solid",
        132.91,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s¹",
        "[Xe]6s¹",
        "6s¹",
      ],
      Ba: [
        56,
        "Barium",
        "Solid",
        137.33,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²",
        "[Xe]6s²",
        "6s²",
      ],
      La: [
        57,
        "Lanthanum",
        "Solid",
        138.91,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²5d¹",
        "[Xe]6s²5d¹",
        "6s²5d¹",
      ],
      Ce: [
        58,
        "Cerium",
        "Solid",
        140.12,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹5d¹",
        "[Xe]6s²4f¹5d¹",
        "6s²4f¹5d¹",
      ],
      Pr: [
        59,
        "Praseodymium",
        "Solid",
        140.91,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f³",
        "[Xe]6s²4f³",
        "6s²4f³",
      ],
      Nd: [
        60,
        "Neodymium",
        "Solid",
        144.24,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f⁴",
        "[Xe]6s²4f⁴",
        "6s²4f⁴",
      ],
      Pm: [
        61,
        "Promethium",
        "Solid",
        145,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f⁵",
        "[Xe]6s²4f⁵",
        "6s²4f⁵",
      ],
      Sm: [
        62,
        "Samarium",
        "Solid",
        150.36,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f⁶",
        "[Xe]6s²4f⁶",
        "6s²4f⁶",
      ],
      Eu: [
        63,
        "Europium",
        "Solid",
        151.96,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f⁷",
        "[Xe]6s²4f⁷",
        "6s²4f⁷",
      ],
      Gd: [
        64,
        "Gadolinium",
        "Solid",
        157.25,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶5d¹6s²4f⁷",
        "[Xe]6s²4f⁷5d¹",
        "6s²4f⁷5d¹",
      ],
      Tb: [
        65,
        "Terbium",
        "Solid",
        158.93,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f⁹",
        "[Xe]6s²4f⁹",
        "6s²4f⁹",
      ],
      Dy: [
        66,
        "Dysprosium",
        "Solid",
        162.5,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹⁰",
        "[Xe]6s²4f¹⁰",
        "6s²4f¹⁰",
      ],
      Ho: [
        67,
        "Holmium",
        "Solid",
        164.93,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹¹",
        "[Xe]6s²4f¹¹",
        "6s²4f¹¹",
      ],
      Er: [
        68,
        "Erbium",
        "Solid",
        167.26,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹²",
        "[Xe]6s²4f¹²",
        "6s²4f¹²",
      ],
      Tm: [
        69,
        "Thulium",
        "Solid",
        168.93,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹³",
        "[Xe]6s²4f¹³",
        "6s²4f¹³",
      ],
      Yb: [
        70,
        "Ytterbium",
        "Solid",
        173.05,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴",
        "[Xe]6s²4f¹⁴",
        "6s²4f¹⁴",
      ],
      Lu: [
        71,
        "Lutetium",
        "Solid",
        174.97,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹",
        "[Xe]6s²4f¹⁴5d¹",
        "6s²⁴5d¹",
      ],
      Hf: [
        72,
        "Hafnium",
        "Solid",
        178.49,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d²",
        "[Xe]6s²4f¹⁴5d²",
        "6s²5d²",
      ],
      Ta: [
        73,
        "Tantalum",
        "Solid",
        180.95,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d³",
        "[Xe]6s²4f¹⁴5d³",
        "6s²5d³",
      ],
      W: [
        74,
        "Tungsten",
        "Solid",
        183.84,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d⁴",
        "[Xe]6s²4f¹⁴5d⁴",
        "6s²5d⁴",
      ],
      Re: [
        75,
        "Rhenium",
        "Solid",
        186.21,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d⁵",
        "[Xe]6s²4f¹⁴5d⁵",
        "6s²5d⁵",
      ],
      Os: [
        76,
        "Osmium",
        "Solid",
        190.23,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d6",
        "[Xe]6s²4f¹⁴5d⁶",
        "6s²5d⁶",
      ],
      Ir: [
        77,
        "Iridium",
        "Solid",
        192.22,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d⁷",
        "[Xe]6s²4f¹⁴5d⁷",
        "6s²5d⁷",
      ],
      Pt: [
        78,
        "Platinum",
        "Solid",
        195.08,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s¹4f¹⁴5d⁹",
        "[Xe]6s¹4f¹⁴5d⁹",
        "6s¹5d⁹",
      ],
      Au: [
        79,
        "Gold",
        "Solid",
        196.97,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s¹4f¹⁴5d¹⁰",
        "[Xe]6s¹4f¹⁴5d¹⁰",
        "6s¹5d¹⁰",
      ],
      Hg: [
        80,
        "Mercury",
        "Solid",
        200.59,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰",
        "[Xe]6s²4f¹⁴5d¹⁰",
        "6s²5d¹⁰",
      ],
      Tl: [
        81,
        "Thallium",
        "Solid",
        204.38,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p¹",
        "[Xe]6s²4f¹⁴5d¹⁰6p¹",
        "6s²6p¹",
      ],
      Pb: [
        82,
        "Lead",
        "Solid",
        207.2,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p²",
        "[Xe]6s²4f¹⁴5d¹⁰6p²",
        "6s²6p²",
      ],
      Bi: [
        83,
        "Bismuth",
        "Solid",
        208.98,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p³",
        "[Xe]6s²4f¹⁴5d¹⁰6p³",
        "6s²6p³",
      ],
      Po: [
        84,
        "Polonium",
        "Solid",
        209,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁴",
        "[Xe]6s²4f¹⁴5d¹⁰6p⁴",
        "6s²6p⁴",
      ],
      At: [
        85,
        "Astatine",
        "Solid",
        210,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁵",
        "[Xe]6s²4f¹⁴5d¹⁰6p⁵",
        "6s²6p⁵",
      ],
      Rn: [
        86,
        "Radon",
        "Gas",
        222,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶",
        "[Xe]6s²4f¹⁴5d¹⁰6p⁶",
        "6s²6p⁶",
      ],
      Fr: [
        87,
        "Francium",
        "Solid",
        223,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s¹",
        "[Rn]7s¹",
        "7s¹",
      ],
      Ra: [
        88,
        "Radium",
        "Solid",
        226,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²",
        "[Rn]7s²",
        "7s²",
      ],
      Ac: [
        89,
        "Actinium",
        "Solid",
        227,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶6d¹7s²",
        "[Rn]7s²6d¹",
        "7s²6d¹",
      ],
      Th: [
        90,
        "Thorium",
        "Solid",
        232.04,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶6d²7s²",
        "[Rn]7s²6d²",
        "7s²6d²",
      ],
      Pa: [
        91,
        "Protactinium",
        "Solid",
        231.04,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f²6d¹",
        "[Rn]7s²5f²6d¹",
        "7s²5f²6d¹",
      ],
      U: [
        92,
        "Uranium",
        "Solid",
        238.03,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f³6d¹",
        "[Rn]7s²5f³6d¹",
        "7s²5f³6d¹",
      ],
      Np: [
        93,
        "Neptunium",
        "Solid",
        237,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²6p⁶4f¹⁴5d¹⁰7s²5f⁴6d¹ ",
        "[Rn]7s²5f⁴6d¹",
        "7s²5f⁴6d¹ ",
      ],
      Pu: [
        94,
        "Plutonium",
        "Solid",
        244,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²6s²4f¹⁴5d¹⁰6p⁶7s²5f⁶5p⁶",
        "[Rn]7s²5f⁶",
        "7s²5f⁶",
      ],
      Am: [
        95,
        "Americium",
        "Solid",
        243,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f⁷",
        "[Rn]7s²5f⁷",
        "7s²5f⁷",
      ],
      Cm: [
        96,
        "Curium",
        "Solid",
        247,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f⁷6d¹",
        "[Rn]7s²5f⁷6d¹",
        "7s²5f⁷6d¹",
      ],
      Bk: [
        97,
        "Berkelium",
        "Solid",
        247,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f⁹",
        "[Rn]7s²5f⁹",
        "7s²5f⁹",
      ],
      Cf: [
        98,
        "Californium",
        "Solid",
        251,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁰",
        "[Rn]7s²5f¹⁰",
        "7s²5f¹⁰",
      ],
      Es: [
        99,
        "Einsteinium",
        "Solid",
        252,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹¹",
        "[Rn]7s²5f¹¹",
        "7s²5f¹¹",
      ],
      Fm: [
        100,
        "Fermium",
        "Solid",
        257,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹²",
        "[Rn]5f¹²7s²",
        "5f¹²7s²",
      ],
      Md: [
        101,
        "Mendelevium",
        "Solid",
        258,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹³",
        "[Rn]7s²5f¹³",
        "7s²5f¹³",
      ],
      No: [
        102,
        "Nobelium",
        "Solid",
        259,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴",
        "[Rn]7s²5f¹⁴",
        "7s²5f¹⁴",
      ],
      Lr: [
        103,
        "Lawrencium",
        "Solid",
        266,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴7p¹",
        "[Rn]7s²5f¹⁴6d¹",
        "7s²7p¹",
      ],
      Rf: [
        104,
        "Rutherfordium",
        "Solid",
        267,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴6d²",
        "[Rn]7s²5f¹⁴6d²",
        "7s²6d²",
      ],
      Db: [
        105,
        "Dubnium",
        "Solid",
        268,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴6d³",
        "[Rn]7s²5f¹⁴6d³",
        "7s²6d³",
      ],
      Sg: [
        106,
        "Seaborgium",
        "Solid",
        269,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴6d⁴",
        "[Rn]7s²5f¹⁴6d⁴",
        "7s²6d⁴",
      ],
      Bh: [
        107,
        "Bohrium",
        "Solid",
        270,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴6d⁵",
        "[Rn]7s²5f¹⁴6d⁵",
        "7s²6d⁵",
      ],
      Hs: [
        108,
        "Hassium",
        "Solid",
        277,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴6d⁶",
        "[Rn]7s²5f¹⁴6d⁶",
        "7s²6d⁶",
      ],
      Mt: [
        109,
        "Meitnerium",
        "Solid",
        278,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴6d⁷",
        "[Rn]7s²5f¹⁴6d⁷",
        "7s²6d⁷",
      ],
      Ds: [
        110,
        "Darmstadtium",
        "Solid (Expected)",
        281,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴6d⁸",
        "[Rn]7s²5f¹⁴6d⁸",
        "7s²6d⁸",
      ],
      Rg: [
        111,
        "Roentgenium",
        "Solid (Expected)",
        282,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴6d⁹",
        "[Rn]7s²5f¹⁴6d⁹",
        "7s²6d⁹",
      ],
      Cn: [
        112,
        "Copernicium",
        "Solid (Expected)",
        285,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶6d¹⁰7s²5f¹⁴",
        "[Rn]7s²5f¹⁴6d¹⁰",
        "7s²6d¹⁰",
      ],
      Nh: [
        113,
        "Nihonium",
        "Solid (Expected)",
        286,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴6d¹⁰7p¹",
        "[Rn]5f¹⁴6d¹⁰7s²7p¹",
        "7s²7p¹",
      ],
      Fl: [
        114,
        "Flerovium",
        "Solid (Expected)",
        289,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴6d¹⁰7p²",
        "[Rn]7s²7p²5f¹⁴6d¹⁰",
        "7s²7p²",
      ],
      Mc: [
        115,
        "Moscovium",
        "Solid (Expected)",
        290,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴6d¹⁰7p³",
        "[Rn]7s²7p³5f¹⁴6d¹⁰",
        "7s²7p³",
      ],
      Lv: [
        116,
        "Livermorium",
        "Solid (Expected)",
        293,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴6d¹⁰7p⁴",
        "[Rn]7s²7p⁴5f¹⁴6d¹⁰",
        "7s²7p⁴",
      ],
      Ts: [
        117,
        "Tennessine",
        "Solid (Expected)",
        294,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴6d¹⁰7p⁵",
        "[Rn]7s²7p⁵5f¹⁴6d¹⁰",
        "7s²7p⁵",
      ],
      Og: [
        118,
        "Oganesson",
        "Gas (Expected)",
        294,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴6d¹⁰7p⁶",
        "[Rn]7s²7p⁶5f¹⁴6d¹⁰",
        "7s²7p⁶",
      ],
    };

    const result = periodicTable[element];

    if (!result) {
      return { error: "Element not found in the periodic table." };
    }

    return {
      tech_atomicNumber: result[0],
      tech_element: result[1],
      tech_phase: result[2],
      tech_atomicMass: result[3],
      tech_configuration: result[4],
      tech_nobleGasNotation: result[5],
      tech_valenceConfiguration: result[6],
    };
  }
  /** getCalculationMolarMassCalculator
   * POST: /api/calculators-lol/molar-mass-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMolarMassCalculator(body) {
    let f = (body.tech_f || "").trim();

    // Basic input validation - similar regex to PHP
    const forbiddenPattern =
      /<|>|\&|php|print_r|print|echo|script|sin|cos|tan|arcsin|arccos|arctan|&|%/i;
    if (forbiddenPattern.test(f)) {
      return { error: "Please Enter Valid Input." };
    }

    if (!f) {
      return { error: "Please! Check Your Input." };
    }

    // Prepare the input string similar to PHP str_replace
    let parem = f;
    parem = parem.replace(/\s+/g, "");
    parem = parem.replace(/%20/g, "");
    parem = parem.replace(/\+/g, "plus");
    parem = parem.replace(/{/g, "(");
    parem = parem.replace(/}/g, ")");
    parem = parem.replace(/e\^/g, "exp");
    parem = parem.replace(/exp\^/g, "exp");
    parem = parem.replace(/\^/g, "**");
    parem = parem.replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    try {
      const response = await axios.get("http://167.172.134.148/molar", {
        timeout: 120000,
        params: { f: parem },
      });

      const buffer = response.data.split("@@@");

      let mass = buffer[2];
      let atoms = buffer[5];
      let elem = buffer[6].split("###");
      let mm = buffer[7].split("###");
      let num = buffer[8].split("###");
      let rm = buffer[9].split("###");
      let frac = buffer[10].split("###");
      let t_mm = buffer[11];

      let table = `<table class='col-12' cellspacing='0'>
              <thead>
                  <tr>
                      <th class='text-start border-b py-2 pe-2'>Element</th>
                      <th class='text-start border-b py-2 pe-2'>No. of Atoms</th>
                      <th class='text-start border-b py-2 pe-2'>Molar Mass (MM)</th>
                      <th class='text-start border-b py-2 pe-2'>(%)</th>
                      <th class='text-start py-2'>Subtotal Mass</th>
                  </tr>
              </thead>
              <tbody>`;

      table += `<tr><td class='border-b py-2'>&nbsp;</td><td class='border-b py-2'>&nbsp;</td><td class='border-b py-2'>(g/mol)</td><td class='border-b py-2'>(%)</td><td class='border-b py-2'>(g/mol)</td></tr>`;

      for (let i = 0; i < elem.length - 1; i++) {
        table += `<tr>
                  <td class='border-b py-2'>${elem[i]}</td>
                  <td class='border-b py-2'>${num[i]}</td>
                  <td class='border-b py-2'>${parseFloat(mm[i]).toFixed(4)}</td>
                  <td class='border-b py-2'>${parseFloat(frac[i]).toFixed(
                    2
                  )}</td>
                  <td class='border-b py-2'>${parseFloat(rm[i]).toFixed(4)}</td>
              </tr>`;
      }

      table += `<tr>
              <th class='text-start py-2'>Total</th>
              <th class='text-start py-2'>${atoms}</th>
              <th class='text-start py-2'>${parseFloat(t_mm).toFixed(4)}</th>
              <th class='text-start py-2'>100.00</th>
              <th class='text-start py-2'>${parseFloat(mass).toFixed(4)}</th>
          </tr></tbody></table>`;

      return {
        tech_hill: buffer[0],
        tech_emp: buffer[1],
        tech_mass: parseFloat(mass).toFixed(4),
        tech_n_mass: parseFloat(buffer[3]).toFixed(4),
        tech_m_mass: parseFloat(buffer[4]).toFixed(4),
        tech_atoms: atoms,
        tech_table: table,
        tech_elem: elem,
        tech_frac: frac,
      };
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationTitrationCalculator
   * POST: /api/calculators-lol/titration-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationTitrationCalculator(body) {
    let cal = (body.tech_cal || "").trim();
    let ma = parseFloat((body.tech_ma || "").toString().trim());
    let ma_unit = (body.tech_ma_unit || "").trim();
    let va = parseFloat((body.tech_va || "").toString().trim());
    let va_unit = (body.tech_va_unit || "").trim();
    let mb = parseFloat((body.tech_mb || "").toString().trim());
    let mb_unit = (body.tech_mb_unit || "").trim();
    let vb = parseFloat((body.tech_vb || "").toString().trim());
    let vb_unit = (body.tech_vb_unit || "").trim();
    let hp = parseFloat((body.tech_hp || "").toString().trim());
    let oh = parseFloat((body.tech_oh || "").toString().trim());

    // Helper function to convert molarity units to M (molar)
    function convertMolarity(value, unit) {
      if (isNaN(value)) return NaN;
      switch (unit) {
        case "pM":
          return value * 1e-12;
        case "nM":
          return value * 1e-9;
        case "μM":
          return value * 1e-6;
        case "mM":
          return value * 1e-3;
        default:
          return value;
      }
    }

    // Helper function to convert volume units to liters
    function convertVolume(value, unit) {
      if (isNaN(value)) return NaN;
      switch (unit) {
        case "mm³":
          return value * 1e-6;
        case "cm³":
          return value * 1e-3;
        case "dm³":
          return value * 1;
        case "m³":
          return value * 1000;
        case "cu in":
          return value * 0.0163871;
        case "cu ft":
          return value * 28.3168;
        case "cu yd":
          return value * 764.555;
        case "ml":
          return value * 0.001;
        case "cl":
          return value * 0.01;
        case "l":
          return value * 1;
        case "us gal":
          return value * 3.78541;
        case "uk gal":
          return value * 4.54609;
        case "us fl oz":
          return value * 0.0295735;
        case "uk fl oz":
          return value * 0.0284131;
        default:
          return value;
      }
    }

    // Convert units to standard units
    ma = convertMolarity(ma, ma_unit);
    va = convertVolume(va, va_unit);
    mb = convertMolarity(mb, mb_unit);
    vb = convertVolume(vb, vb_unit);

    // Validate numeric inputs
    if ([ma, va, mb, vb, hp, oh].some((x) => isNaN(x))) {
      return { error: "Please! Check Your Input." };
    }

    // Calculation cases
    if (cal === "ma") {
      // ma = (oh * mb * vb) / (va * hp)
      let ans = (oh * mb * vb) / (va * hp);

      return {
        tech_ans: `${ans} <span class="text-green font-s-25">M</span>`,
        tech_ans_pm: `${ans * 1e-12} pM`,
        tech_ans_nm: `${ans * 1e-9} nM`,
        tech_ans_um: `${ans * 1e-6} μM`,
        tech_ans_mm: `${ans * 1e-3} mM`,
      };
    } else if (cal === "va") {
      // va = (oh * mb * vb) / (ma * hp)
      let ans = (oh * mb * vb) / (ma * hp);

      return {
        tech_ans: `${ans} <span class="text-green font-s-25">liter</span>`,
        tech_ans_nl: `${ans * 1e-9} nL`,
        tech_ans_ul: `${ans * 1e-6} μL`,
        tech_ans_ml: `${ans * 1e-3} mL`,
      };
    } else if (cal === "hp") {
      // hp = (oh * mb * vb) / (ma * va)
      let tech_ans = (oh * mb * vb) / (ma * va);

      return { tech_ans };
    } else if (cal === "mb") {
      // mb = (hp * ma * va) / (oh * vb)
      let ans = (hp * ma * va) / (oh * vb);

      return {
        tech_ans: `${ans} <span class="font-s20">M</span>`,
        tech_ans_pm: `${ans * 1e-12} pM`,
        tech_ans_nm: `${ans * 1e-9} nM`,
        tech_ans_um: `${ans * 1e-6} μM`,
        tech_ans_mm: `${ans * 1e-3} mM`,
      };
    } else if (cal === "vb") {
      // vb = (hp * ma * va) / (oh * mb)
      let ans = (hp * ma * va) / (oh * mb);

      return {
        tech_ans: `${ans} <span class="font-s20">liter</span>`,
        tech_ans_nl: `${ans * 1e-9} nL`,
        tech_ans_ul: `${ans * 1e-6} μL`,
        ans_ml: `${ans * 1e-3} mL`,
      };
    } else if (cal === "oh") {
      // oh = (hp * ma * va) / (vb * mb)
      let tech_ans = (hp * ma * va) / (vb * mb);

      return { tech_ans };
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationHalfLifeCalculator
   * POST: /api/calculators-lol/half-life-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationHalfLifeCalculator(body) {
    let calculator_name = body.tech_calculator_name?.trim();
    let param = {};

    let check = false;

    if (calculator_name === "calculator1") {
      let find = body.tech_find?.trim();
      let nt = parseFloat(body.tech_nt?.trim());
      let n0 = parseFloat(body.tech_n0?.trim());
      let t = parseFloat(body.tech_t?.trim());
      let t1_2 = parseFloat(body.tech_t1_2?.trim());

      if (!isNaN(nt) && !isNaN(n0) && !isNaN(t) && !isNaN(t1_2)) {
        check = true;
      }

      if (check) {
        if (find === "nt") {
          let s1 = t / t1_2;
          let s2 = Math.pow(0.5, s1);
          nt = n0 * s2;
          param = {
            tech_ans: nt,
            tech_s1: s1,
            tech_s2: s2,
            tech_share: "share",
          };
        } else if (find === "n0") {
          let s1 = t / t1_2;
          let s2 = Math.pow(0.5, s1);
          n0 = nt / s2;
          param = {
            tech_ans: n0,
            tech_s1: s1,
            tech_s2: s2,
            tech_share: "share",
          };
        } else if (find === "t") {
          let s1 = nt / n0;
          let s2 = Math.log(s1);
          let s3 = t1_2 * s2;
          let s4 = -Math.log(2);
          t = s3 / s4;
          param = {
            tech_ans: t,
            tech_s1: s1,
            tech_s2: s2,
            tech_s3: s3,
            tech_s4: s4,
            tech_share: "share",
          };
        } else if (find === "t1_2") {
          let s1 = nt / n0;
          let s2 = Math.log(s1);
          let s3 = -Math.log(2);
          let s4 = t * s3;
          t1_2 = s4 / s2;
          param = {
            tech_ans: t1_2,
            tech_s1: s1,
            tech_s2: s2,
            tech_s3: s3,
            tech_s4: s4,
            tech_share: "share",
          };
        } else {
          param = { error: "Please! Check Your Input." };
        }
      }
    } else {
      let find_by = body.tech_find_by?.trim();
      let t_1_2 = parseFloat(body.tech_t_1_2?.trim());
      let T = parseFloat(body.tech_T?.trim());
      let lamda = parseFloat(body.tech_lamda?.trim());

      if (!isNaN(t_1_2) && !isNaN(T) && !isNaN(lamda)) {
        check = true;
      }

      if (check) {
        if (find_by === "t_1_2") {
          T = t_1_2 / Math.log(2);
          lamda = Math.log(2) / t_1_2;
        } else if (find_by === "T") {
          t_1_2 = T * Math.log(2);
          lamda = Math.log(2) / t_1_2;
        } else if (find_by === "lamda") {
          t_1_2 = Math.log(2) / lamda;
          T = t_1_2 / Math.log(2);
        } else {
          return { error: "Please! Check Your Input." };
        }

        param = {
          tech_t_1_2: t_1_2,
          tech_T: T,
          tech_lamda: lamda,
        };
      }
    }

    if (!check && !param.RESULT) {
      param = { error: "Please! Check Your Input." };
    }

    return param;
  }

  /** getCalculationMoleCalculator
   * POST: /api/calculators-lol/mole-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMoleCalculator(body) {
    let cal = body.tech_cal?.trim();
    let mass = parseFloat(body.tech_mass?.trim());
    let mass_unit = body.tech_mass_unit?.trim();
    let mw = parseFloat(body.tech_mw?.trim());
    let moles = parseFloat(body.tech_moles?.trim());
    let moles_unit = body.tech_moles_unit?.trim();
    let param = {};

    if (!isNaN(mass) && !isNaN(mw) && !isNaN(moles)) {
      function sigFig(value, digits) {
        if (value === 0) return 0;
        const decimalPlaces = Math.max(
          0,
          Math.min(100, digits - Math.floor(Math.log10(Math.abs(value))) - 1)
        );
        return Number(value.toFixed(decimalPlaces));
      }

      // Convert mass to grams
      const massConversions = {
        pg: 1e-12,
        ng: 1e-9,
        μg: 1e-6,
        mg: 1e-3,
        dag: 10,
        kg: 1000,
        t: 1e6,
        oz: 28.35,
        lbs: 453.6,
        stones: 6350,
        "US ton": 907185,
        "Long ton": 1016047,
        u: 1 / 6.02214e23,
      };
      if (massConversions[mass_unit]) {
        mass *= massConversions[mass_unit];
      }

      // Convert moles to base mol
      const molesConversions = {
        mM: 1e-3,
        μM: 1e-6,
        nM: 1e-9,
        pM: 1e-12,
      };
      if (molesConversions[moles_unit]) {
        moles *= molesConversions[moles_unit];
      }

      if (cal === "mass") {
        mass = mw * moles;

        param.tech_ans = `${sigFig(
          mass,
          4
        )} <span class="text-green font-s-25">g</span>`;
        param.tech_ans_pg = `${sigFig(mass / 1e-12, 4)} pg`;
        param.tech_ans_ng = `${sigFig(mass / 1e-9, 4)} ng`;
        param.tech_ans_ug = `${sigFig(mass / 1e-6, 4)} μg`;
        param.tech_ans_mg = `${sigFig(mass / 1e-3, 4)} mg`;
        param.tech_ans_dag = `${sigFig(mass / 10, 4)} dag`;
        param.tech_ans_kg = `${sigFig(mass / 1000, 4)} kg`;
        param.tech_ans_t = `${sigFig(mass / 1e6, 4)} t`;
        param.tech_ans_oz = `${sigFig(mass / 28.35, 4)} oz`;
        param.tech_ans_lb = `${sigFig(mass / 453.6, 4)} lb`;
        param.tech_ans_stone = `${sigFig(mass / 6350, 4)} stone`;
        param.tech_ans_us_ton = `${sigFig(mass / 907185, 4)} US ton`;
        param.tech_ans_long_ton = `${sigFig(mass / 1016047, 4)} Long ton`;
        param.tech_ans_u = `${sigFig(mass * 6.02214e23, 4)} u`;
      } else if (cal === "mw") {
        mw = mass / moles;
        param.tech_ans = `${sigFig(
          mw,
          4
        )} <span class="text-green font-s-25">g/mol</span>`;
      } else if (cal === "moles") {
        moles = mass / mw;

        param.tech_ans = `${sigFig(
          moles,
          4
        )} <span class="text-green font-s-25">M</span>`;
        param.tech_ans_mm = `${sigFig(moles / 1e-3, 4)} mM`;
        param.tech_ans_um = `${sigFig(moles / 1e-6, 4)} μM`;
        param.tech_ans_nm = `${sigFig(moles / 1e-9, 4)} nM`;
        param.tech_ans_pm = `${sigFig(moles / 1e-12, 4)} pM`;
      } else {
        return { error: "Please! Check Your Input." };
      }

      // Molecules calculations
      let molecules_23 = sigFig(moles * 6.02214076, 4);
      param.tech_molecules_23 = `${molecules_23}x10²³`;
      param.tech_molecules_22 = `${sigFig(molecules_23 * 10, 4)}x10²²`;
      param.tech_molecules_24 = `${sigFig(molecules_23 * 0.1, 4)}x10²⁴`;

      return param;
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationAtomicMassCalculator
   * POST: /api/calculators-lol/atomic-mass-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAtomicMassCalculator(body) {
    let z = parseInt(body.tech_z);
    let n = parseInt(body.tech_n);
    let param = {};

    if (isNaN(z) || isNaN(n)) {
      param.error = "Please! Check Your Input.";
      return param;
    }

    function checkIsotope(isotopeList, z, n) {
      return isotopeList.some((item) => item[0] === z && item[1] === n);
    }

    const elementSymbols = [
      "H",
      "He",
      "Li",
      "Be",
      "B",
      "C",
      "N",
      "O",
      "F",
      "Ne",
      "Na",
      "Mg",
      "Al",
      "Si",
      "P",
      "S",
      "Cl",
      "Ar",
      "K",
      "Ca",
      "Sc",
      "Ti",
      "V",
      "Cr",
      "Mn",
      "Fe",
      "Co",
      "Ni",
      "Cu",
      "Zn",
      "Ga",
      "Ge",
      "As",
      "Se",
      "Br",
      "Kr",
      "Rb",
      "Sr",
      "Y",
      "Zr",
      "Nb",
      "Mo",
      "Tc",
      "Ru",
      "Rh",
      "Pd",
      "Ag",
      "Cd",
      "In",
      "Sn",
      "Sb",
      "Te",
      "I",
      "Xe",
      "Cs",
      "Ba",
      "La",
      "Ce",
      "Pr",
      "Nd",
      "Pm",
      "Sm",
      "Eu",
      "Gd",
      "Tb",
      "Dy",
      "Ho",
      "Er",
      "Tm",
      "Yb",
      "Lu",
      "Hf",
      "Ta",
      "W",
      "Re",
      "Os",
      "Ir",
      "Pt",
      "Au",
      "Hg",
      "Tl",
      "Pb",
      "Bi",
      "Po",
      "At",
      "Rn",
      "Fr",
      "Ra",
      "Ac",
      "Th",
      "Pa",
      "U",
      "Np",
      "Pu",
      "Am",
      "Cm",
      "Bk",
      "Cf",
      "Es",
      "Fm",
      "Md",
      "No",
      "Lr",
      "Rf",
      "Db",
      "Sg",
      "Bh",
      "Hs",
      "Mt",
      "Ds",
      "Rg",
      "Cn",
      "Nh",
      "Fl",
      "Mc",
      "Lv",
      "Ts",
      "Og",
    ];

    const stableIsotopes = [
      [52, 76],
      [54, 70],
      [36, 42],
      [54, 82],
      [32, 44],
      [56, 74],
      [34, 48],
      [48, 68],
      [20, 28],
      [83, 126],
      [40, 56],
      [52, 78],
      [60, 90],
      [42, 58],
      [63, 88],
      [74, 106],
      [23, 27],
      [48, 65],
      [62, 86],
      [60, 84],
      [76, 110],
      [72, 102],
      [49, 66],
      [64, 88],
      [78, 112],
      [62, 85],
      [57, 81],
      [37, 50],
      [75, 112],
      [71, 105],
      [90, 142],
      [92, 146],
      [19, 21],
      [92, 143],
      [94, 150],
      [62, 84],
      [41, 51],
      [92, 144],
      [82, 123],
      [53, 76],
      [96, 151],
      [72, 110],
      [46, 61],
      [43, 54],
      [43, 55],
      [25, 28],
      [66, 88],
      [26, 34],
      [83, 127],
      [55, 80],
      [93, 144],
      [64, 86],
      [40, 53],
      [4, 6],
      [13, 13],
      [94, 148],
      [83, 125],
      [96, 152],
      [17, 19],
      [34, 45],
      [92, 142],
      [50, 76],
      [36, 45],
      [43, 56],
      [75, 111],
      [92, 141],
      [93, 143],
      [20, 21],
      [28, 31],
      [90, 140],
      [57, 80],
      [82, 120],
      [91, 140],
      [94, 145],
      [41, 53],
      [96, 149],
      [96, 154],
      [95, 148],
      [90, 139],
      [94, 146],
      [6, 8],
      [96, 150],
      [67, 96],
      [42, 51],
      [88, 138],
      [97, 150],
      [67, 99],
      [98, 153],
      [41, 50],
      [80, 114],
      [47, 61],
      [95, 146],
      [98, 151],
      [97, 151],
      [18, 21],
      [77, 115],
      [65, 93],
      [95, 147],
      [14, 18],
      [84, 125],
      [28, 35],
      [62, 89],
      [94, 144],
      [65, 92],
      [64, 84],
      [92, 140],
      [22, 22],
      [78, 115],
      [50, 71],
      [63, 87],
      [18, 24],
      [83, 124],
      [72, 106],
      [55, 82],
      [96, 147],
      [38, 52],
      [82, 128],
      [89, 138],
      [96, 148],
      [61, 84],
      [41, 52],
      [94, 147],
      [48, 65],
      [63, 89],
      [98, 152],
      [1, 2],
      [36, 49],
      [56, 77],
      [63, 91],
      [76, 118],
      [88, 140],
      [61, 85],
      [27, 33],
      [63, 92],
      [81, 123],
      [71, 103],
      [45, 56],
      [45, 57],
      [84, 124],
      [94, 142],
      [51, 74],
      [26, 29],
      [98, 154],
      [61, 86],
      [11, 11],
      [55, 79],
      [69, 102],
      [90, 138],
      [72, 100],
      [73, 106],
      [71, 102],
      [99, 153],
      [48, 61],
      [93, 142],
      [44, 62],
      [61, 83],
      [62, 83],
      [98, 150],
      [97, 152],
      [23, 26],
      [25, 29],
      [50, 69],
      [58, 86],
      [99, 155],
      [27, 30],
      [32, 36],
      [61, 82],
      [47, 63],
      [30, 35],
      [64, 89],
      [45, 57],
      [79, 116],
      [77, 117],
      [75, 109],
      [96, 146],
      [20, 25],
      [71, 106],
      [52, 69],
      [66, 93],
      [71, 103],
      [84, 126],
      [58, 81],
      [50, 73],
      [69, 101],
      [64, 87],
      [74, 107],
      [34, 41],
      [52, 71],
      [50, 63],
      [73, 109],
      [52, 75],
      [39, 49],
      [100, 157],
      [76, 109],
      [69, 99],
      [63, 86],
      [43, 54],
      [16, 19],
      [37, 46],
      [21, 25],
      [40, 48],
      [33, 40],
      [27, 29],
      [74, 111],
      [77, 115],
      [65, 95],
      [27, 31],
      [75, 108],
      [72, 103],
      [74, 114],
      [38, 47],
      [40, 55],
      [43, 52],
      [41, 50],
      [98, 156],
      [51, 73],
      [53, 72],
      [39, 52],
      [52, 73],
      [63, 85],
      [4, 3],
      [101, 157],
      [38, 51],
      [49, 65],
      [64, 82],
      [80, 123],
      [94, 143],
      [48, 67],
      [26, 33],
      [72, 109],
      [61, 87],
      [47, 58],
      [99, 156],
      [44, 59],
      [54, 73],
      [75, 109],
      [41, 54],
      [18, 19],
      [52, 77],
      [37, 47],
      [96, 145],
      [58, 83],
      [70, 99],
      [101, 159],
      [24, 27],
      [96, 144],
      [91, 142],
      [38, 44],
      [15, 18],
      [72, 107],
      [90, 144],
      [63, 84],
      [74, 104],
      [92, 138],
      [99, 154],
      [52, 69],
      [90, 137],
      [37, 49],
      [98, 155],
      [33, 41],
      [91, 139],
      [46, 57],
      [45, 54],
      [23, 25],
      [76, 115],
      [83, 122],
      [63, 93],
      [88, 137],
      [15, 17],
      [50, 67],
      [59, 84],
      [77, 112],
      [55, 81],
      [53, 73],
      [56, 84],
      [51, 75],
      [81, 121],
      [54, 77],
      [77, 113],
      [56, 75],
      [88, 135],
      [32, 39],
      [60, 87],
      [94, 152],
      [77, 116],
      [78, 110],
      [41, 51],
      [89, 136],
      [55, 76],
      [50, 75],
      [68, 101],
      [64, 85],
      [69, 98],
      [54, 75],
      [84, 122],
      [34, 38],
      [47, 59],
      [71, 100],
      [53, 78],
      [99, 158],
      [47, 64],
      [65, 96],
      [92, 145],
      [71, 101],
      [71, 106],
      [55, 77],
      [83, 123],
      [79, 117],
      [28, 28],
      [52, 66],
      [63, 82],
      [51, 69],
      [25, 27],
      [61, 87],
      [65, 91],
      [65, 90],
      [54, 79],
      [73, 110],
      [83, 127],
      [97, 148],
      [52, 67],
      [63, 83],
      [20, 27],
      [93, 141],
      [45, 56],
      [78, 115],
      [43, 53],
      [92, 139],
      [70, 105],
      [53, 71],
      [78, 117],
      [51, 76],
      [86, 136],
      [75, 111],
      [88, 136],
      [46, 54],
      [41, 54],
      [66, 100],
      [60, 80],
      [21, 26],
      [39, 48],
      [40, 49],
      [31, 36],
      [52, 80],
      [58, 76],
      [79, 120],
      [81, 120],
      [100, 153],
      [78, 113],
      [49, 62],
      [44, 53],
      [42, 57],
      [51, 71],
      [33, 38],
      [79, 119],
      [80, 117],
      [39, 51],
      [75, 107],
      [69, 103],
      [29, 38],
      [21, 23],
      [56, 72],
      [35, 42],
      [70, 96],
      [73, 104],
      [93, 146],
      [65, 88],
      [28, 38],
      [94, 153],
      [79, 119],
      [48, 67],
      [61, 88],
      [54, 79],
      [82, 121],
      [93, 145],
      [95, 145],
      [68, 104],
      [71, 99],
      [30, 42],
      [62, 91],
      [78, 124],
      [21, 27],
      [97, 149],
      [80, 115],
      [77, 111],
      [57, 83],
      [99, 155],
      [32, 37],
      [56, 77],
      [33, 44],
      [51, 68],
      [64, 83],
      [79, 115],
      [91, 138],
      [98, 148],
      [28, 29],
      [45, 60],
      [35, 47],
      [36, 43],
      [58, 79],
      [71, 98],
      [58, 85],
      [99, 152],
      [38, 45],
      [55, 74],
      [105, 163],
      [91, 141],
      [76, 117],
      [69, 96],
      [52, 79],
      [89, 137],
      [68, 92],
      [61, 90],
      [56, 79],
      [50, 71],
      [67, 99],
      [33, 43],
      [81, 119],
      [33, 39],
      [90, 141],
      [100, 152],
      [96, 156],
      [65, 91],
      [75, 114],
      [80, 117],
      [74, 113],
      [97, 151],
      [72, 101],
      [41, 55],
      [65, 89],
      [93, 143],
      [19, 24],
      [76, 106],
      [91, 137],
      [24, 24],
      [65, 89],
      [82, 118],
      [46, 66],
      [12, 16],
      [45, 55],
      [53, 80],
      [54, 68],
      [100, 155],
      [43, 52],
      [75, 106],
      [78, 119],
      [57, 78],
      [77, 117],
      [59, 83],
      [79, 121],
      [64, 95],
      [58, 77],
      [79, 114],
      [65, 86],
      [27, 28],
      [65, 87],
      [75, 113],
      [54, 71],
      [40, 57],
      [77, 109],
      [40, 46],
      [35, 41],
      [52, 67],
      [95, 147],
      [72, 98],
      [63, 94],
      [11, 13],
      [36, 40],
      [39, 47],
      [86, 125],
      [41, 49],
      [77, 108],
      [92, 148],
      [31, 41],
      [30, 39],
      [46, 63],
      [39, 48],
      [53, 70],
      [76, 115],
      [76, 107],
      [63, 87],
      [29, 35],
      [75, 107],
      [78, 122],
      [53, 77],
      [19, 23],
      [72, 99],
      [95, 144],
      [80, 113],
      [83, 120],
      [32, 45],
      [83, 121],
      [78, 111],
      [82, 130],
      [80, 115],
      [73, 102],
      [94, 151],
      [77, 110],
      [68, 97],
      [39, 54],
      [95, 149],
      [103, 163],
      [65, 89],
      [76, 107],
      [66, 89],
      [38, 53],
      [79, 117],
      [31, 35],
      [62, 94],
      [52, 75],
      [82, 119],
      [63, 89],
      [30, 32],
      [54, 81],
      [27, 31],
      [51, 77],
      [58, 79],
      [94, 140],
      [73, 111],
      [99, 151],
      [46, 55],
      [26, 26],
      [69, 104],
      [73, 107],
      [66, 91],
      [85, 125],
      [73, 103],
      [69, 97],
      [99, 157],
      [68, 103],
      [81, 118],
      [85, 126],
      [34, 39],
      [42, 51],
      [91, 143],
      [53, 82],
      [48, 59],
      [37, 45],
      [66, 87],
      [55, 72],
      [89, 139],
      [43, 56],
      [59, 86],
      [76, 113],
      [84, 123],
      [42, 48],
      [101, 156],
      [46, 65],
      [60, 79],
      [72, 108],
      [85, 124],
      [47, 66],
      [65, 91],
      [81, 117],
      [100, 151],
      [60, 78],
      [67, 93],
      [51, 67],
      [94, 149],
      [79, 113],
      [49, 61],
      [58, 75],
      [43, 51],
      [39, 46],
      [31, 42],
      [80, 112],
      [57, 75],
      [45, 54],
      [105, 162],
      [71, 108],
      [37, 44],
      [97, 146],
      [49, 66],
      [36, 49],
      [44, 61],
      [35, 45],
      [59, 80],
      [51, 78],
      [97, 147],
      [49, 60],
      [72, 112],
      [65, 84],
      [50, 60],
      [21, 23],
      [30, 41],
      [57, 84],
      [57, 76],
      [21, 22],
      [77, 118],
      [80, 113],
      [71, 105],
      [103, 159],
      [82, 120],
      [39, 53],
      [84, 120],
      [58, 74],
      [65, 85],
      [48, 69],
      [29, 32],
      [82, 127],
      [100, 154],
      [97, 153],
      [68, 93],
      [75, 115],
      [39, 51],
      [79, 112],
      [73, 100],
      [47, 65],
      [98, 149],
      [77, 107],
      [77, 113],
      [22, 23],
      [67, 100],
      [62, 72],
      [96, 143],
      [81, 116],
      [36, 52],
      [16, 22],
      [38, 49],
      [51, 66],
      [89, 135],
      [43, 50],
      [39, 46],
      [61, 89],
      [38, 54],
      [100, 156],
      [14, 17],
      [25, 31],
      [28, 37],
      [77, 118],
      [74, 102],
      [48, 69],
      [52, 64],
      [60, 81],
      [67, 94],
      [86, 124],
      [82, 116],
      [96, 142],
      [35, 48],
      [66, 86],
      [73, 105],
      [78, 109],
      [66, 99],
      [104, 163],
      [53, 79],
      [68, 90],
      [32, 34],
      [56, 73],
      [62, 88],
      [74, 103],
      [45, 61],
      [56, 73],
      [59, 79],
      [53, 68],
      [50, 77],
      [54, 69],
      [78, 108],
      [95, 150],
      [41, 48],
      [76, 119],
      [49, 68],
      [77, 109],
      [70, 107],
      [81, 117],
      [81, 115],
      [36, 47],
      [9, 9],
      [18, 23],
      [69, 94],
      [91, 148],
      [83, 118],
      [85, 122],
      [86, 138],
      [38, 42],
      [76, 105],
      [84, 121],
      [60, 89],
      [83, 119],
      [99, 150],
      [65, 82],
      [40, 47],
      [56, 70],
      [49, 64],
      [27, 34],
      [44, 51],
      [95, 143],
      [85, 123],
      [58, 75],
      [35, 40],
      [63, 89],
      [101, 158],
      [78, 119],
      [88, 142],
      [57, 85],
      [33, 45],
      [82, 117],
      [32, 46],
      [98, 157],
      [81, 115],
      [77, 119],
      [53, 79],
      [56, 83],
      [32, 43],
      [53, 67],
      [105, 161],
      [101, 155],
      [59, 78],
      [36, 51],
      [70, 94],
      [68, 95],
      [36, 41],
      [70, 108],
      [95, 142],
      [62, 80],
      [41, 56],
      [78, 107],
      [81, 114],
      [52, 77],
      [47, 57],
      [49, 61],
      [73, 101],
      [31, 37],
      [38, 47],
      [77, 113],
      [67, 95],
      [82, 122],
      [41, 48],
      [47, 56],
      [96, 153],
      [72, 111],
      [89, 140],
      [52, 65],
      [93, 147],
      [72, 110],
      [83, 129],
      [51, 65],
      [65, 83],
      [105, 165],
    ];

    const radioactiveIsotopes = [
      // Add any known radioactive isotopes here if needed.
    ];

    const a = z + n;

    if (z > 118) {
      param.error = "To date, the maximum number of protons is 118.";
      return param;
    } else if (n > 177) {
      param.error = "To date, the maximum number of neutrons is 177.";
      return param;
    } else if (a > 0 && z > 0 && n >= 0) {
      param.tech_symbol = elementSymbols[z - 1];

      if (checkIsotope(stableIsotopes, z, n)) {
        param.tech_stable = "Stable";
      } else if (checkIsotope(radioactiveIsotopes, z, n)) {
        param.tech_unstable = "Unstable";
      } else {
        param.tech_unobserved = "Unobserved";
      }

      param.tech_a = a;
      param.tech_asi = a * 1.66;
      return param;
    }

    param.error = "Please! Check Your Input.";
    return param;
  }

  /** getCalculationNernstEquationCalculator
   * POST: /api/calculators-lol/nernst-equation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationNernstEquationCalculator(body) {
    let cal = String(body.tech_cal).trim();
    let ecell = parseFloat(body.tech_ecell);
    let ecell_unit = String(body.tech_ecell_unit).trim();
    let eo = parseFloat(body.tech_eo);
    let eo_unit = String(body.tech_eo_unit).trim();
    let t = parseFloat(body.tech_t);
    let t_unit = String(body.tech_t_unit).trim();
    let n = parseFloat(body.tech_n);
    let q = parseFloat(body.tech_q);

    let param = {};

    if (isNaN(ecell) || isNaN(eo) || isNaN(t) || isNaN(n) || isNaN(q)) {
      param.error = "Please! Check Your Input.";
      return param;
    }

    // Convert units
    if (ecell_unit === "mV") {
      ecell *= 0.001;
    }
    if (eo_unit === "mV") {
      eo *= 0.001;
    }
    if (t_unit === "°C") {
      t = t * 1 + 273.15;
    } else if (t_unit === "°F") {
      t = ((t - 32) * 5) / 9 + 273.15;
    }

    const r = 0.00008617332;

    try {
      if (cal === "ecell") {
        ecell = eo - (r * t * Math.log(q)) / n;
        param.tech_ans = `${ecell} <span class="text-green font-s-25">V</span>`;
      } else if (cal === "eo") {
        eo = ecell + (r * t * Math.log(q)) / n;
        param.tech_ans = `${eo} <span class="text-green font-s-25">V</span>`;
      } else if (cal === "t") {
        const denominator = Math.log(q) * r;
        if (denominator === 0) {
          t = Infinity;
        } else {
          t = ((eo - ecell) * n) / denominator;
        }
        param.tech_ans = `${t} <span class="text-green font-s-25">K</span>`;
      } else if (cal === "n") {
        if (eo - ecell === 0) {
          n = Infinity;
        } else {
          n = (Math.log(q) * r * t) / (eo - ecell);
        }
        param.tech_ans = n;
      } else if (cal === "q") {
        if (r * t === 0) {
          q = Infinity;
        } else {
          q = Math.exp((n * (eo - ecell)) / (r * t));
        }
        param.tech_ans = q;
      } else {
        param.error = "Please! Check Your Input.";
        return param;
      }

      return param;
    } catch (e) {
      param.error = "An error occurred during calculation.";
      return param;
    }
  }

  /** getCalculationGramsToMolesCalculator
   * POST: /api/calculators-lol/grams-to-moles-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationGramsToMolesCalculator(body) {
    let chemical_selection = body.tech_chemical_selection;
    let unit = body.tech_unit;
    let mm_unit = body.tech_mm_unit;
    let mm = parseFloat(body.tech_mm);
    let m_unit = body.tech_m_unit;
    let m = parseFloat(body.tech_m);
    let nm = parseFloat(body.tech_nm);
    let nm_unit = body.tech_nm_unit;

    if (nm_unit == "mol") {
      nm_unit = "1";
    } else if (nm_unit == "mmol") {
      nm_unit = "2";
    } else if (nm_unit == "μmol") {
      nm_unit = "3";
    } else if (nm_unit == "nmol") {
      nm_unit = "4";
    } else if (nm_unit == "pmol") {
      nm_unit = "5";
    }

    if (m_unit == "ng") {
      m_unit = "1";
    } else if (m_unit == "µg") {
      m_unit = "2";
    } else if (m_unit == "mg") {
      m_unit = "3";
    } else if (m_unit == "g") {
      m_unit = "4";
    } else if (m_unit == "dag") {
      m_unit = "5";
    } else if (m_unit == "kg") {
      m_unit = "6";
    }

    if (mm_unit == "g/mol") {
      mm_unit = "1";
    } else if (mm_unit == "dag/mol") {
      mm_unit = "2";
    } else if (mm_unit == "kg/mol") {
      mm_unit = "3";
    }

    let param = {};
    let mm_convert, m_convert, ans1, ans2, nm_convert, ans3, ans4, ans5, ans6;
    if (unit === "1") {
      if (!isNaN(mm) && !isNaN(m) && mm > 0 && m > 0) {
        if (mm_unit == "1") {
          mm_convert = mm * 1;
        } else if (mm_unit == "2") {
          mm_convert = mm * 10;
        } else if (mm_unit == "3") {
          mm_convert = mm * 1000;
        }
        if (m_unit == "1") {
          m_convert = m * 0.000000001;
        } else if (m_unit == "2") {
          m_convert = m * 0.000001;
        } else if (m_unit == "3") {
          m_convert = m * 0.001;
        } else if (m_unit == "4") {
          m_convert = m * 1;
        } else if (m_unit == "5") {
          m_convert = m * 10;
        } else if (m_unit == "6") {
          m_convert = m * 1000;
        }
        ans1 = m_convert / mm_convert;
        ans2 = ans1 * 6.02214085774;

        param.tech_ans90 = m_convert;
        param.tech_ans91 = mm_convert;
        param.tech_ans1 = ans1;
        param.tech_ans2 = ans2;
      } else {
        param.error = "Please! Check Your Input.";
      }
    } else if (unit === "2") {
      if (!isNaN(mm) && !isNaN(nm) && mm > 0 && nm > 0) {
        if (mm_unit == "1") {
          mm_convert = mm * 1;
        } else if (mm_unit == "2") {
          mm_convert = mm * 10;
        } else if (mm_unit == "3") {
          mm_convert = mm * 1000;
        }
        if (nm_unit == "1") {
          nm_convert = nm * 1;
        } else if (nm_unit == "2") {
          nm_convert = nm * 0.001;
        } else if (nm_unit == "3") {
          nm_convert = nm * 0.000001;
        } else if (nm_unit == "4") {
          nm_convert = nm * 0.000000001;
        } else if (nm_unit == "5") {
          nm_convert = nm * 0.000000000001;
        }
        ans3 = nm_convert * mm_convert;
        ans4 = nm_convert * 6.02214085774;

        param.tech_ans90 = mm_convert;
        param.tech_ans91 = nm_convert;
        param.tech_ans3 = ans3;
        param.tech_ans4 = ans4;
      } else {
        param.error = "Please! Check Your Input.";
      }
    } else if (unit === "3") {
      if (!isNaN(m) && !isNaN(nm) && m > 0 && nm > 0) {
        if (m_unit == "1") {
          m_convert = m * 0.000000001;
        } else if (m_unit == "2") {
          m_convert = m * 0.000001;
        } else if (m_unit == "3") {
          m_convert = m * 0.001;
        } else if (m_unit == "4") {
          m_convert = m * 1;
        } else if (m_unit == "5") {
          m_convert = m * 10;
        } else if (m_unit == "6") {
          m_convert = m * 1000;
        }
        if (nm_unit == "1") {
          nm_convert = nm * 1;
        } else if (nm_unit == "2") {
          nm_convert = nm * 0.001;
        } else if (nm_unit == "3") {
          nm_convert = nm * 0.000001;
        } else if (nm_unit == "4") {
          nm_convert = nm * 0.000000001;
        } else if (nm_unit == "5") {
          nm_convert = nm * 0.000000000001;
        }
        ans5 = m_convert / nm_convert;
        ans6 = nm_convert * 6.02214085774;

        param.tech_ans5 = ans5;
        param.tech_ans6 = ans6;
        param.tech_ans90 = m_convert;
        param.tech_ans91 = nm_convert;
      } else {
        param.error = "Please! Check Your Input.";
      }
    }

    return param;
  }

  /** getCalculationMolesToGramsCalculator
   * POST: /api/calculators-lol/moles-to-grams-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMolesToGramsCalculator(body) {
    let {
      tech_chemical_selection,
      tech_unit: unit,
      tech_mm_unit: mm_unit,
      tech_mm: mm,
      tech_m_unit: m_unit,
      tech_m: m,
      tech_nm: nm,
      tech_nm_unit: nm_unit,
    } = body;

    let param = {};
    let nmUnits,
      mm_convert,
      m_convert,
      ans1,
      ans2,
      ans3,
      ans4,
      ans5,
      ans6,
      nm_convert;

    if (nm_unit == "mol") {
      nm_unit = "1";
    } else if (nm_unit == "mmol") {
      nm_unit = "2";
    } else if (nm_unit == "μmol") {
      nm_unit = "3";
    } else if (nm_unit == "nmol") {
      nm_unit = "4";
    } else if (nm_unit == "pmol") {
      nm_unit = "5";
    }

    if (m_unit == "ng") {
      m_unit = "1";
    } else if (m_unit == "µg") {
      m_unit = "2";
    } else if (m_unit == "mg") {
      m_unit = "3";
    } else if (m_unit == "g") {
      m_unit = "4";
    } else if (m_unit == "dag") {
      m_unit = "5";
    } else if (m_unit == "kg") {
      m_unit = "6";
    }

    if (mm_unit == "g/mol") {
      mm_unit = "1";
    } else if (mm_unit == "dag/mol") {
      mm_unit = "2";
    } else if (mm_unit == "kg/mol") {
      mm_unit = "3";
    }

    if (unit === "1") {
      if (!isNaN(mm) && !isNaN(m) && mm > 0 && m > 0) {
        if (mm_unit == "1") {
          mm_convert = mm * 1;
        } else if (mm_unit == "2") {
          mm_convert = mm * 10;
        } else if (mm_unit == "3") {
          mm_convert = mm * 1000;
        }
        if (m_unit == "1") {
          m_convert = m * 0.000000001;
        } else if (m_unit == "2") {
          m_convert = m * 0.000001;
        } else if (m_unit == "3") {
          m_convert = m * 0.001;
        } else if (m_unit == "4") {
          m_convert = m * 1;
        } else if (m_unit == "5") {
          m_convert = m * 10;
        } else if (m_unit == "6") {
          m_convert = m * 1000;
        }
        ans1 = m_convert / mm_convert;
        ans2 = ans1 * 6.02214085774;

        param = {
          tech_ans90: m_convert,
          tech_ans91: mm_convert,
          tech_ans1: ans1,
          tech_ans2: ans2,
        };
      } else {
        param.error = "Please! Check Your Input.";
      }
    } else if (unit === "2") {
      if (!isNaN(mm) && !isNaN(nm) && mm > 0 && nm > 0) {
        if (mm_unit == "1") {
          mm_convert = mm * 1;
        } else if (mm_unit == "2") {
          mm_convert = mm * 10;
        } else if (mm_unit == "3") {
          mm_convert = mm * 1000;
        }
        if (nm_unit == "1") {
          nm_convert = nm * 1;
        } else if (nm_unit == "2") {
          nm_convert = nm * 0.001;
        } else if (nm_unit == "3") {
          nm_convert = nm * 0.000001;
        } else if (nm_unit == "4") {
          nm_convert = nm * 0.000000001;
        } else if (nm_unit == "5") {
          nm_convert = nm * 0.000000000001;
        }
        ans3 = nm_convert * mm_convert;
        ans4 = nm_convert * 6.02214085774;

        param = {
          tech_ans90: mm_convert,
          tech_ans91: nm_convert,
          tech_ans3: ans3,
          tech_ans4: ans4,
        };
      } else {
        param.error = "Please! Check Your Input.";
      }
    } else if (unit === "3") {
      if (!isNaN(m) && !isNaN(nm) && m > 0 && nm > 0) {
        if (m_unit == "1") {
          m_convert = m * 0.000000001;
        } else if (m_unit == "2") {
          m_convert = m * 0.000001;
        } else if (m_unit == "3") {
          m_convert = m * 0.001;
        } else if (m_unit == "4") {
          m_convert = m * 1;
        } else if (m_unit == "5") {
          m_convert = m * 10;
        } else if (m_unit == "6") {
          m_convert = m * 1000;
        }
        if (nm_unit == "1") {
          nm_convert = nm * 1;
        } else if (nm_unit == "2") {
          nm_convert = nm * 0.001;
        } else if (nm_unit == "3") {
          nm_convert = nm * 0.000001;
        } else if (nm_unit == "4") {
          nm_convert = nm * 0.000000001;
        } else if (nm_unit == "5") {
          nm_convert = nm * 0.000000000001;
        }
        ans5 = m_convert / nm_convert;
        ans6 = nm_convert * 6.02214085774;

        param = {
          tech_ans90: m_convert,
          tech_ans91: nm_convert,
          tech_ans5: ans5,
          tech_ans6: ans6,
        };
      } else {
        param.error = "Please! Check Your Input.";
      }
    }

    return param;
  }

  /** getCalculationActivationEnergyCalculator
   * POST: /api/calculators-lol/activation-energy-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationActivationEnergyCalculator(body) {
    let {
      tech_temperature: temperature,
      tech_rate: rate,
      tech_const: constValue,
      tech_tempUnit: tempUnit,
      tech_rateUnits: rateUnits,
      tech_constUnits: constUnits,
    } = body;
    let input;
    temperature = Number(temperature);
    rate = Number(rate);
    constValue = Number(constValue);

    // Helper: Convert to per second
    function convertToPerSecond(value, unit) {
      if (unit === "sec") {
        input = value;
      } else if (unit === "min") {
        input = value * 60;
      } else if (unit === "hour") {
        input = value * 3600;
      } else if (unit === "day") {
        input = value * 86400;
      } else if (unit === "week") {
        input = value * 86400 * 7;
      } else if (unit === "month") {
        input = value * (30 * 86400);
      } else if (unit === "year") {
        input = value * (365.25 * 24 * 3600);
      }
      return input;
    }

    let param = {};

    if (!isNaN(temperature) && !isNaN(rate) && !isNaN(constValue)) {
      // Temperature conversion to Kelvin
      if (tempUnit === "fahrenheit") {
        temperature = ((temperature - 32) * 5) / 9 + 273.15;
      } else if (tempUnit === "celsius") {
        temperature = temperature + 273.15;
      }

      // Convert rate and const to per second
      rate = convertToPerSecond(rate, rateUnits);
      constValue = convertToPerSecond(constValue, constUnits);

      // Calculate activation energy
      let x = -0.008314 * temperature;
      let log = Math.log(rate / constValue);
      let res = x * log;

      let joule = res * 1000;
      let megajoule = res * 0.001;
      let calories = res * 239;
      let kilocalories = res * 0.239;

      param = {
        tech_temperature: temperature,
        tech_log: log,
        tech_rate: rate,
        tech_const: constValue,
        tech_res: res,
        tech_joule: joule,
        tech_megajoule: megajoule,
        tech_calories: calories,
        tech_kilocalories: kilocalories,
      };
    } else {
      param.error = "Please! Check Your Input.";
    }

    return param;
  }

  /** getCalculationMmolLToMgDlCalculator
   * POST: /api/calculators-lol/mmol-l-to-mg-dl-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMmolLToMgDlCalculator(body) {
    let { tech_solve: solve, tech_input: input } = body;

    input = Number(input);

    if (!isNaN(input)) {
      let answer;

      if (solve === "1") {
        answer = input * 18;
      } else {
        answer = input / 18;
      }

      return {
        tech_answer: answer,
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /** getCalculationCFUCalculator
   * POST: /api/calculators-lol/cfu-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCFUCalculator(body) {
    let {
      tech_nc: nc,
      tech_df: df,
      tech_volume: volume,
      tech_volume_units: volume_units,
    } = body;

    nc = Number(nc);
    df = Number(df);
    volume = Number(volume);

    if (!isNaN(nc) && !isNaN(df) && !isNaN(volume)) {
      if (volume_units) {
        if (volume_units === "mm³") {
          volume *= 0.000000001;
        } else if (volume_units === "cm³") {
          volume *= 0.000001;
        } else if (volume_units === "dm³") {
          volume *= 0.001;
        } else if (volume_units === "cu in") {
          volume *= 0.000016387;
        } else if (volume_units === "cu ft") {
          volume *= 0.028317;
        } else if (volume_units === "cu yd") {
          volume *= 0.7646;
        } else if (volume_units === "ml") {
          volume *= 0.000001;
        } else if (volume_units === "cl") {
          volume *= 0.00001;
        } else if (volume_units === "l") {
          volume *= 0.001;
        }
      }

      const res = nc * df;
      const cfu = res / volume;

      return {
        tech_nc: nc,
        tech_df: df,
        tech_volume: volume,
        tech_res: res,
        tech_cfu: cfu,
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /** getCalculationMlToMolesCalculator
   * POST: /api/calculators-lol/ml-to-moles-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMlToMolesCalculator(body) {
    let {
      tech_volume: volume,
      tech_volume_unit: volume_unit,
      tech_molarity: molarity,
      tech_molarity_unit: molarity_unit,
    } = body;

    volume = Number(volume);
    molarity = Number(molarity);
    let vol_u, mol_u, answer;
    // Convert unit names to identifiers
    if (volume_unit == "mL") {
      volume_unit = "1";
    } else if (volume_unit == "L") {
      volume_unit = "2";
    } else if (volume_unit == "uL") {
      volume_unit = "3";
    }

    if (molarity_unit == "M") {
      molarity_unit = "1";
    } else if (molarity_unit == "mM") {
      molarity_unit = "2";
    } else if (molarity_unit == "uM") {
      molarity_unit = "3";
    }

    // Unit conversion functions
    function volume_units(a, b) {
      if (b == "1") {
        vol_u = a / 1000;
      } else if (b == "2") {
        vol_u = a * 1;
      } else if (b == "3") {
        vol_u = a * 0.000001;
      }
      return vol_u;
    }
    function molarity_units(a, b) {
      if (b == "1") {
        mol_u = a * 1;
      } else if (b == "2") {
        mol_u = a / 1000;
      } else if (b == "3") {
        mol_u = a / 1000000;
      }
      return mol_u;
    }

    if (!isNaN(volume) && !isNaN(molarity)) {
      volume = volume_units(volume, volume_unit);
      molarity = molarity_units(molarity, molarity_unit);
      answer = volume * molarity;
      return {
        tech_answer: answer,
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /** getCalculationSTPCalculator
   * POST: /api/calculators-lol/stp-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSTPCalculator(body) {
    let {
      tech_volume: volume,
      tech_volume_units: volume_units,
      tech_temp: temp,
      tech_temp_units: temp_units,
      tech_pressure: pressure,
      tech_pressure_units: pressure_units,
    } = body;

    volume = Number(volume);
    temp = Number(temp);
    pressure = Number(pressure);

    if (!isNaN(volume) && !isNaN(temp) && !isNaN(pressure)) {
      // Volume unit conversion to dm³
      const volumeConversions = {
        "mm³": volume * 0.000001,
        "cm³": volume * 0.001,
        "dm³": volume * 1,
        "m³": volume * 1000,
        "cu in": volume * 0.016387,
        "cu ft": volume * 28.317,
        "cu yd": volume * 764.6,
        ml: volume * 0.001,
        cl: volume * 0.01,
      };
      if (volume_units in volumeConversions)
        volume = volumeConversions[volume_units];

      // Temperature conversion to Kelvin
      if (temp_units === "°F") {
        temp = ((temp - 32) * 5) / 9 + 273.15;
      } else if (temp_units === "°C") {
        temp += 273.15;
      }

      // Pressure conversion to mmHg
      const pressureConversions = {
        Pa: pressure * 0.0075,
        bar: pressure * 750,
        psi: pressure * 51.71,
        at: pressure * 735.6,
        atm: pressure * 760,
        hPa: pressure * 0.75,
        kPa: pressure * 7.5,
        MPa: pressure * 7500,
        GPa: pressure * 7500617,
        inHg: pressure * 25.4,
        mmHg: pressure,
      };
      if (pressure_units in pressureConversions)
        pressure = pressureConversions[pressure_units];

      // STP Calculations
      let t = 273.15 / temp;
      let v = volume * t;
      let p = pressure / 760;
      let vstp = v * p;
      let moles = vstp / 22.4;

      return {
        tech_vstp: vstp,
        tech_moles: moles,
        tech_volume: volume,
        tech_temp: temp,
        tech_pressure: pressure,
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /** getCalculationStoichiometryCalculator
   * POST: /api/calculators-lol/stoichiometry-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationStoichiometryCalculator(body) {
    let { tech_eq: eq } = body;
    eq = String(eq).trim();

    // Input validation
    const invalidPattern = /<|>|&|php|print_r|print|echo|script|%/i;
    if (invalidPattern.test(eq)) {
      return { error: "Please Enter Valid Input." };
    }

    if (!eq) {
      return { error: "Please! Check Your Input." };
    }

    try {
      let parem = eq
        .replace(/\s+/g, "")
        .replace(/%20/g, "")
        .replace(/\+/g, "plus")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**")
        .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

      let [r, p] = parem.split("=");
      let option = 2;

      const formData = qs.stringify({ r, p });

      const response = await axios.post(
        "http://167.172.134.148/stoichiometry",
        formData,
        {
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
          },
          timeout: 120000,
        }
      );

      const result = response.data.split("@@@");
      let inp = parem.replace(/plus/g, "+");

      return {
        tech_inp: inp,
        tech_be: result[0],
        tech_mols: result[1],
        tech_atoms: result[2],
        tech_chemical_equation: eq,
        tech_option: option,
      };
    } catch (err) {
      console.error(err.message);
      return { error: "Please enter any one value." };
    }
  }

  /** getCalculationEmpiricalFormulaCalculator
   * POST: /api/calculators-lol/empirical-formula-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationEmpiricalFormulaCalculator(body) {
    let e1 = body.tech_e1;
    let e2 = body.tech_e2;
    let e3 = body.tech_e3;
    let e4 = body.tech_e4;
    let e5 = body.tech_e5;
    let e6 = body.tech_e6;
    let m1 = body.tech_m1;
    let m2 = body.tech_m2;
    let m3 = body.tech_m3;
    let m4 = body.tech_m4;
    let m5 = body.tech_m5;
    let m6 = body.tech_m6;

    let periodicValues = {
      H: 1.008,
      He: 4.0026,
      Li: 6.94,
      Be: 9.0122,
      B: 10.81,
      C: 12.011,
      N: 14.007,
      O: 15.999,
      F: 18.998,
      Ne: 20.18,
      Na: 22.99,
      Mg: 24.305,
      Al: 26.982,
      Si: 28.085,
      P: 30.974,
      S: 32.06,
      Cl: 35.45,
      Ar: 39.948,
      K: 39.098,
      Ca: 40.078,
      Sc: 44.956,
      Ti: 47.867,
      V: 50.942,
      Cr: 51.996,
      Mn: 54.938,
      Fe: 55.845,
      Co: 58.933,
      Ni: 58.693,
      Cu: 63.546,
      Zn: 65.38,
      Ga: 69.723,
      Ge: 72.63,
      As: 74.922,
      Se: 78.971,
      Br: 79.904,
      Kr: 83.798,
      Rb: 85.468,
      Sr: 87.62,
      Y: 88.906,
      Zr: 91.224,
      Nb: 92.906,
      Mo: 95.95,
      Tc: 98,
      Ru: 101.07,
      Rh: 102.91,
      Pd: 106.42,
      Ag: 107.87,
      Cd: 112.41,
      In: 114.82,
      Sn: 118.71,
      Sb: 121.76,
      Te: 127.6,
      I: 126.9,
      Xe: 131.29,
      Cs: 132.91,
      Ba: 137.33,
      La: 138.91,
      Ce: 140.12,
      Pr: 140.91,
      Nd: 144.24,
      Pm: 145,
      Sm: 150.36,
      Eu: 151.96,
      Gd: 157.25,
      Tb: 158.93,
      Dy: 162.5,
      Ho: 164.93,
      Er: 167.26,
      Tm: 168.93,
      Yb: 173.05,
      Lu: 174.97,
      Hf: 178.49,
      Ta: 180.95,
      W: 183.84,
      Re: 186.21,
      Os: 190.23,
      Ir: 192.22,
      Pt: 195.08,
      Au: 196.97,
      Hg: 200.59,
      Tl: 204.38,
      Pb: 207.2,
      Bi: 208.98,
      Po: 209,
      At: 210,
      Rn: 222,
      Fr: 223,
      Ra: 226,
      Ac: 227,
      Th: 232.04,
      Pa: 231.04,
      U: 238.03,
      Np: 237,
      Pu: 244,
      Am: 243,
      Cm: 247,
      Bk: 247,
      Cf: 251,
      Es: 252,
      Fm: 257,
      Md: 258,
      No: 259,
      Lr: 266,
      Rf: 267,
      Db: 268,
      Sg: 269,
      Bh: 270,
      Hs: 277,
      Mt: 278,
      Ds: 281,
      Rg: 282,
      Cn: 285,
      Nh: 286,
      Fl: 289,
      Mc: 290,
      Lv: 293,
      Ts: 294,
      Og: 294,
    };

    let param = {};
    let check = true;
    let values = [];

    for (let i = 1; i <= 6; i++) {
      let e = body[`tech_e${i}`];
      let m = body[`tech_m${i}`];

      if (e && !isNaN(m)) {
        e = String(e).trim();
        values.push(`${e}-${m}`);
      } else if ((e && isNaN(m)) || (!e && m)) {
        check = false;
      }
    }

    let moles = [],
      s1 = "",
      s2 = "",
      s3 = "",
      s4 = "",
      s5 = "",
      s6 = "",
      res = [];

    if (check && values.length) {
      for (let val of values) {
        let [symbol, mass] = val.split("-");
        let el =
          symbol.trim().charAt(0).toUpperCase() +
          symbol.trim().slice(1).toLowerCase();

        s1 += `<td class='border-b p-2 text-[18px]'> ${el} </td>`;
        param.tech_s1 = s1;

        if (periodicValues[el]) {
          let mol = Number(mass) / periodicValues[el];
          moles.push(mol);
          s2 += `<td class='border-b p-2 text-[18px]'> ${mass}g </td>`;
          s3 += `<td class='border-b p-2 text-[22px]'>\\( \\frac {${mass}}{${periodicValues[el]}} \\)</td>`;
          param.tech_s2 = s2;
          param.tech_s3 = s3;
        } else {
          return { error: "Please! Check Your Input" };
        }
      }

      let minVal = Math.min(...moles);

      moles.forEach((mol, idx) => {
        let rounded = Math.round(mol);
        let ratio = Math.round(mol / minVal);
        s4 += `<td class='border-b p-2 text-[18px]'> ${rounded} </td>`;
        s5 += `<td class='border-b p-2 text-[22px]'>\\( \\frac {${rounded}}{${Math.round(
          minVal
        )}} \\)</td>`;
        s6 += `<td class='border-b p-2 text-[18px]'>${ratio}</td>`;
        res.push(ratio === 1 ? "" : ratio);
      });

      param.tech_s4 = s4;
      param.tech_s5 = s5;
      param.tech_s6 = s6;

      let formula = values
        .map((val, idx) => {
          let el = val.split("-")[0];
          let sym =
            el.trim().charAt(0).toUpperCase() +
            el.trim().slice(1).toLowerCase();
          return `${sym}<sub class='text-green'>${res[idx]}</sub>`;
        })
        .join("");

      param.tech_formula = formula;
      param.tech_count = values.length;
      return param;
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationPercentYieldCalculator
   * POST: /api/calculators-lol/percent-yield-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPercentYieldCalculator(body) {
    let method = body.tech_method;
    let x = body.tech_x;
    let y = body.tech_y;
    let z = body.tech_z;
    let unit_x = body.tech_unit_x;
    let unit_y = body.tech_unit_y;

    let result = {};

    // Convert unit values
    function convertToGrams(value, unit) {
      if (unit === "µg") return value / 1e6;
      if (unit === "mg") return value / 1000;
      if (unit === "kg") return value * 1000;
      if (unit === "lbs") return value * 454;
      return value;
    }

    if (method === "1") {
      if (!isNaN(x) && !isNaN(y)) {
        let actual = convertToGrams(parseFloat(y), unit_y);
        let ther = convertToGrams(parseFloat(x), unit_x);
        let ans = Math.round((actual / ther) * 100 * 100) / 100;
        result.tech_ans = ans;
      } else {
        result.error = "Please Fill All Fields.";
      }
    }

    if (method === "2") {
      if (!isNaN(z) && !isNaN(y)) {
        let actual = convertToGrams(parseFloat(y), unit_y);
        let ans = Math.round((actual / parseFloat(z)) * 100 * 100) / 100;
        result.tech_ans = ans;
      } else {
        result.error = "Please Fill All Fields.";
      }
    }

    if (method === "3") {
      if (!isNaN(z) && !isNaN(y)) {
        let actual = convertToGrams(parseFloat(y), unit_y);
        let ans = Math.round(((actual * parseFloat(z)) / 100) * 100) / 100;
        result.tech_ans = ans;
      } else {
        result.error = "Please Fill All Fields.";
      }
    }

    return result;
  }

  /** getCalculationPowerToWeightRatioCalculator
   * POST: /api/calculators-lol/power-to-weight-ratio-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPowerToWeightRatioCalculator(body) {
    let power = body.tech_power;
    let power_unit = body.tech_power_unit;
    let weight = body.tech_weight;
    let weight_unit = body.tech_weight_unit;

    let convert, convert2;
    function convert_power(a, b) {
      if ((a = "w")) {
        convert = b * 0.001;
      } else if ((a = "kw")) {
        convert = b * 1;
      } else if ((a = "hpl")) {
        convert = b * 0.7457;
      } else if ((a = "hpm")) {
        convert = b * 0.7355;
      } else if ((a = "js")) {
        convert = b * 0.001;
      } else if ((a = "kjs")) {
        convert = b * 1;
      } else if ((a = "nms")) {
        convert = b * 0.001;
      }
      return convert;
    }
    function convert_weight(c, d) {
      if (c == "kg") {
        convert2 = d * 1;
      } else if ((c = "g")) {
        convert2 = d * 0.001;
      } else if ((c = "t")) {
        convert2 = d * 1000;
      } else if ((c = "lb")) {
        convert2 = d * 0.4536;
      } else if ((c = "oz")) {
        convert2 = d * 0.02835;
      } else if ((c = "us")) {
        convert2 = d * 907.2;
      } else if ((c = "long")) {
        convert2 = d * 1016;
      } else if ((c = "mg")) {
        convert2 = d * 0.000001;
      } else if (c == "gr") {
        convert2 = d * 0.00006479891;
      }
      return convert2;
    }

    let result = {};

    if (!isNaN(power) && !isNaN(weight)) {
      let powerValue = convert_power(power_unit, power);
      let weightValue = convert_weight(weight_unit, weight);
      let ratio = powerValue / weightValue;

      result.tech_answer = ratio;
    } else {
      result.error = "Please fill all fields.";
    }

    return result;
  }

  /** getCalculationConstantOfProportionalityCalculator
   * POST: /api/calculators-lol/constant-of-proportionality-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationConstantOfProportionalityCalculator(body) {
    let y = typeof body.tech_y === "string" ? body.tech_y.trim() : body.tech_y;
    let x = typeof body.tech_x === "string" ? body.tech_x.trim() : body.tech_x;

    let result = {};

    if (!isNaN(y) && !isNaN(x)) {
      let answer = parseFloat(y) / parseFloat(x);
      result.tech_ans = parseFloat(answer.toFixed(5));
      result.tech_x = x;
      result.tech_y = y;
    } else {
      result.error = "Please fill all fields.";
    }

    return result;
  }

  /** getCalculationQuantmNumberCalculator
   * POST: /api/calculators-lol/quantum-number-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationQuantmNumberCalculator(body) {
    let type = body.tech_type;
    let value = parseInt(body.tech_value);
    let result = {};

    if (type === "principal") {
      if (!isNaN(value)) {
        let angular_momentum = "";
        for (let i = 0; i < value; i++) {
          angular_momentum += i.toString();
        }

        let table = `<table class='w-full text-[18px]'><tr><td class='py-2 border-b'><strong>Principal quantum number (𝑛)</strong></td><td class='py-2 border-b'><strong>Angular momentum quantum number (𝑙)</strong></td><td class='py-2 border-b'><strong>Magnetic quantum number (𝘮ₗ)</strong></td></tr>`;

        for (let i = 0; i < value; i++) {
          let inner = -i;
          for (let j = inner; j <= i; j++) {
            table += `<tr><td class="py-2 border-b">${value}</td><td class="py-2 border-b">${i}</td><td class="py-2 border-b">${j}</td></tr>`;
          }
        }

        table += "</table>";

        result.tech_table = table;
        result.tech_angular_momentum = angular_momentum;
        result.tech_value = value;
      } else {
        return { error: "Please fill all fields." };
      }
    } else if (type === "angular") {
      if (!isNaN(value)) {
        let resultString = "";
        for (let j = -value; j <= value; j++) {
          resultString += "," + j;
        }
        let magnetic = resultString.replace(/^,/, "");
        let num_orbital = 2 * value + 1;

        result.tech_magnetic = magnetic;
        result.tech_num_orbital = num_orbital;
      } else {
        return { error: "Please fill all fields." };
      }
    } else {
      return { error: "Please fill all fields." };
    }

    result.tech_type = type;
    return result;
  }

  /** getCalculationCcTohpCalculator
   * POST: /api/calculators-lol/cc-to-hp-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCcTohpCalculator(body) {
    let solve = body.tech_solve;
    let input = parseFloat(body.tech_input);
    let result = {};

    if (!isNaN(input)) {
      let answer;

      if (solve === "1") {
        // cc to hp
        answer = input / 15;
      } else {
        // hp to cc
        answer = input * 15;
      }

      result.tech_answer = answer;
    } else {
      result.error = "Please fill all fields.";
    }

    return result;
  }

  /** getCalculationCombinationCalculator
   * POST: /api/calculators-lol/combination-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCombinationCalculator(body) {
    const result = {};

    try {
      let n = BigInt(body.tech_n);
      let r = BigInt(body.tech_r);

      if (n > 999999n) {
        result.error = "n must be less than or equal to 999999";
        return result;
      }

      if (n < r) {
        result.error = "n must be greater than r";
        return result;
      }
      function factorial(n) {
        let result = 1n;
        for (let i = 2n; i <= n; i++) {
          result *= i;
        }
        return result;
      }
      const nMinusR = n - r;

      const factn = factorial(n);
      const factr = factorial(r);
      const factnr = factorial(nMinusR);

      const rnr = factr * factnr;
      const answer = factn / rnr;

      // Manually build all responses with string-safe versions
      result["tech_resans"] = answer.toString();
      result[
        "tech_step2res"
      ] = `= ${n.toString()}! / (${r.toString()}!(${nMinusR.toString()})!)`;
      result[
        "tech_step3res"
      ] = `= ${n.toString()}! / ${r.toString()}! x ${nMinusR.toString()}!`;
      result["tech_nans"] = n.toString();
      result["tech_rans"] = r.toString();

      return result;
    } catch (err) {
      return {
        error: "Invalid input or internal error.",
        details: err.message,
      };
    }
  }

  /** getCalculationCentralLimittheoremCalculator
   * POST: /api/calculators-lol/central-limit-theorem-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCentralLimittheoremCalculator(body) {
    const result = {};

    let u = parseFloat(body.tech_u);
    let o = parseFloat(body.tech_o);
    let n = parseFloat(body.tech_n);

    if (!isNaN(u) && !isNaN(o) && !isNaN(n)) {
      let s1 = Math.sqrt(n);
      let s = o / s1;
      let x = u;

      result.tech_s = s;
      result.tech_x = x;
      result.tech_s1 = s1;
      result.tech_o = o;
      result.tech_n = n;
      result.tech_u = u;
      return result;
    } else {
      return {
        error: "Please! Check Your Input",
      };
    }
  }

  /** getCalculationbinomialCoefficientCalculator
   * POST: /api/calculators-lol/binomial-coefficient-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationbinomialCoefficientCalculator(body) {
    const result = {};

    let n = parseInt(body.tech_n);
    let k = parseInt(body.tech_k);

    if (isNaN(n) || isNaN(k)) {
      return { error: "Please! Check Your Input" };
    }

    if (k > n) {
      return { error: "n must be larger than or equal to k" };
    }

    function factorial(x) {
      if (x <= 1) return 1n;
      let fact = 1n;
      for (let i = 2n; i <= BigInt(x); i++) {
        fact *= i;
      }
      return fact;
    }

    try {
      let nFact = factorial(n);
      let kFact = factorial(k);
      let nkFact = factorial(n - k);

      let ans = nFact / (kFact * nkFact);
      result.tech_ans = ans.toString();
      return result;
    } catch (err) {
      return { error: "Please! Try a small number" };
    }
  }

  /** getCalculationRowScoreCalculator
   * POST: /api/calculators-lol/raw-score-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRowScoreCalculator(body) {
    const result = {};

    let mean = parseFloat(body.tech_mean);
    let standardDeviation = parseFloat(body.tech_standard_daviation);
    let zScore = parseFloat(body.tech_z_score);
    let type = body.tech_type?.toString().trim();

    if (isNaN(mean) || isNaN(standardDeviation) || isNaN(zScore)) {
      return { error: "Please! Check Your Input" };
    }

    let res = mean + zScore * standardDeviation;

    result.tech_mean = mean;
    result.tech_standard_daviation = standardDeviation;
    result.tech_z_score = zScore;
    result.tech_res = res;
    result.tech_type = type;

    return result;
  }

  /** getCalculationEmpiricalProbabilityCalculator
   * POST: /api/calculators-lol/empirical-probability-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationEmpiricalProbabilityCalculator(body) {
    const result = {};

    let first = parseFloat(body.tech_first);
    let second = parseFloat(body.tech_second);

    if (isNaN(first) || isNaN(second) || second === 0) {
      return { error: "Please! Check Your Input" };
    }

    let answer = parseFloat((first / second).toFixed(2));

    result.tech_answer = answer;
    result.tech_first = first;
    result.tech_second = second;

    return result;
  }

  /** getCalculationRelativeRiskCalculator
   * POST: /api/calculators-lol/relative-risk-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRelativeRiskCalculator(body) {
    const result = {};

    let e_disease = parseFloat(body.tech_e_disease);
    let e_no_disease = parseFloat(body.tech_e_no_disease);
    let c_disease = parseFloat(body.tech_c_disease);
    let c_no_disease = parseFloat(body.tech_c_no_disease);
    let confidenceLevel = body.tech_confidenceLevel; // Optional, not used in this logic
    let z_score = body.tech_z_score; // Optional, not used in this logic

    if (
      isNaN(e_disease) ||
      isNaN(e_no_disease) ||
      isNaN(c_disease) ||
      isNaN(c_no_disease)
    ) {
      return { error: "Please! Check Your Input" };
    }

    let riskExposed = e_disease / (e_disease + e_no_disease);
    let riskControl = c_disease / (c_disease + c_no_disease);
    let relative = riskExposed / riskControl;

    result.tech_relative = relative;
    result.tech_riskExposed = riskExposed;
    result.tech_riskControl = riskControl;

    return result;
  }
  /** getCalculationChiSquareCalculator
   * POST: /api/calculators-lol/chi-square-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationChiSquareCalculator(body) {
    const result = {};

    let observed = parseFloat(body.tech_observed);
    let expected = parseFloat(body.tech_expected);

    if (isNaN(observed) || isNaN(expected)) {
      return { error: "Please! Check Your Input" };
    }

    let chiSquared = Math.pow(observed - expected, 2) / expected;

    result.tech_chiSquared = chiSquared;
    result.tech_observed = observed;
    result.tech_expected = expected;

    return result;
  }

  /** getCalculationPHapCalculator
   * POST: /api/calculators-lol/p-hat-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPHapCalculator(body) {
    const result = {};

    let sample_size = parseFloat(body.tech_sample_size);
    let occurrences = parseFloat(body.tech_occurrences);

    if (isNaN(sample_size) || isNaN(occurrences)) {
      return { error: "Please! Check Your Input" };
    }

    let p_hat = occurrences / sample_size;

    result.tech_p_hat = p_hat;
    result.tech_sample_size = sample_size;
    result.tech_occurrences = occurrences;

    return result;
  }

  /** getCalculationStandardErrorCalculator
   * POST: /api/calculators-lol/standard-error-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationStandardErrorCalculator(body) {
    let form = body.tech_form;
    let x = body.tech_x;
    let pmvalue = body.tech_pmvalue;
    let psdvalue = body.tech_psdvalue;
    let deviation = body.tech_deviation;
    let sample = body.tech_sample;

    let param = {};

    if (form === "raw") {
      let check = true;

      if (!x && !pmvalue && !psdvalue) {
        check = false;
      }

      if (x) {
        x = x.replace(/[\s,\n\r]+/g, ",");
        while (x.includes(",,")) {
          x = x.replace(",,", ",");
        }

        let numbers = x
          .split(",")
          .map((s) => s.trim())
          .filter((s) => s !== "");

        for (let val of numbers) {
          if (isNaN(val)) {
            check = false;
            break;
          }
        }

        if (check) {
          numbers = numbers.map(Number);
          let count = numbers.length;
          let sum = numbers.reduce((a, b) => a + b, 0);
          let mean = sum / count;

          let arr1 = [];
          let v = "",
            v1 = "",
            v3 = "";

          for (let i = 0; i < numbers.length; i++) {
            let a = numbers[i] - mean;
            let b = Math.pow(a, 2);
            arr1.push(b);

            if (i !== numbers.length - 1) {
              v3 += ` ${b} +`;
              v1 += ` (${numbers[i]} - ${mean})² + `;
              v += ` (${a})² +`;
            } else {
              v3 += ` ${b} `;
              v1 += ` (${numbers[i]} - ${mean})² `;
              v += ` (${a})² `;
            }
          }

          let c = arr1.reduce((a, b) => a + b, 0);
          let v2 = count - 1;
          let v4 = 1 / v2;
          let v5 = v4 * c;
          let v6 = Math.sqrt(count);
          let d = Math.sqrt((1 / (count - 1)) * c);
          let e = Math.round(d * 10000) / 10000;
          let rv = Math.round(Math.sqrt(v5) * 10000) / 10000;
          let v7 = Math.round((e / v6) * 10000) / 10000;
          let se = Math.round((d / Math.sqrt(count)) * 10000) / 10000;

          param = {
            tech_count: count,
            tech_sum: sum,
            tech_mean: mean,
            tech_e: e,
            tech_se: se,
            tech_v: v,
            tech_v1: v1,
            tech_v2: v2,
            tech_v3: v3,
            tech_c: c,
            tech_v4: v4,
            tech_v5: v5,
            tech_rv: rv,
            tech_v6: v6,
            tech_v7: v7,
            tech_form: form,
          };
          return param;
        } else {
          return { error: "Please Input Some Values." };
        }
      }
    }

    if (form === "summary") {
      if (!isNaN(deviation) && !isNaN(sample)) {
        let sn = Math.round(Math.sqrt(sample) * 10000) / 10000;
        let se = Math.round((deviation / sn) * 10000) / 10000;

        param = {
          tech_se: se,
          tech_sn: sn,
          tech_form: form,
        };
        return param;
      } else {
        return { error: "Please! Check Your Input" };
      }
    }
  }

  /** getCalculationEmpiricalRuleCalculator
   * POST: /api/calculators-lol/empirical-rule-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationEmpiricalRuleCalculator(body) {
    let form = body.tech_form;
    let mean = body.tech_mean;
    let deviation = body.tech_deviation;
    let x = body.tech_x;
    let type_r = body.tech_type_r;

    let param = {};

    if (form === "summary") {
      if (!isNaN(mean) && !isNaN(deviation)) {
        let first = `${(mean - deviation).toFixed(2)} & ${(
          mean + deviation
        ).toFixed(2)}`;
        let second = `${(mean - 2 * deviation).toFixed(2)} & ${(
          mean +
          2 * deviation
        ).toFixed(2)}`;
        let third = `${(mean - 3 * deviation).toFixed(2)} & ${(
          mean +
          3 * deviation
        ).toFixed(2)}`;

        param = {
          tech_mean: mean,
          tech_devi: deviation,
          tech_first: first,
          tech_second: second,
          tech_third: third,
        };
        return param;
      } else {
        return { error: "Please Fill All Fields" };
      }
    } else {
      if (x && typeof x === "string") {
        let array = x
          .split(",")
          .map((s) => s.trim())
          .filter((s) => s !== "");
        let numberCheck = array.every((val) => !isNaN(val));
        let count = array.length;

        if (numberCheck) {
          let numbers = array.map(Number);
          let sum = numbers.reduce((a, b) => a + b, 0);
          let meanVal = parseFloat((sum / count).toFixed(3));

          let d = 0;
          for (let val of numbers) {
            d += Math.pow(val - meanVal, 2);
          }

          let devi;
          if (type_r === "2") {
            devi = parseFloat(Math.sqrt((1 / count) * d).toFixed(4));
          } else {
            devi = parseFloat(Math.sqrt((1 / (count - 1)) * d).toFixed(4));
          }

          let first = `${(meanVal - devi).toFixed(2)} & ${(
            meanVal + devi
          ).toFixed(2)}`;
          let second = `${(meanVal - 2 * devi).toFixed(2)} & ${(
            meanVal +
            2 * devi
          ).toFixed(2)}`;
          let third = `${(meanVal - 3 * devi).toFixed(2)} & ${(
            meanVal +
            3 * devi
          ).toFixed(2)}`;

          param = {
            tech_count: count,
            tech_mean: meanVal,
            tech_devi: devi,
            tech_first: first,
            tech_second: second,
            tech_third: third,
          };
          return param;
        } else {
          return { error: "Please Fill All Fields" };
        }
      } else {
        return { error: "Please Fill All Fields" };
      }
    }
  }

  /** getCalculationExpectedValueCalculator
   * POST: /api/calculators-lol/expected-value-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationExpectedValueCalculator(body) {
    let check = body.tech_check;
    let param = {};

    if (check === "txtar") {
      let xx = body.tech_xx;
      let px = body.tech_px;

      let valid = true;

      if (
        !Array.isArray(xx) ||
        !Array.isArray(px) ||
        xx.length === 0 ||
        px.length === 0
      ) {
        valid = false;
      }

      if (valid) {
        for (let val of xx) {
          if (isNaN(val)) valid = false;
        }
        for (let val of px) {
          if (isNaN(val)) valid = false;
        }
      }

      if (!valid) {
        return { error: "Please fill all fields." };
      }

      let n = xx.length;
      let n1 = px.length;
      let pxSum = parseFloat(
        px.reduce((a, b) => a + parseFloat(b), 0).toFixed(1)
      );

      if (n !== n1) {
        return { error: "X and P(X) must have same number of elements." };
      }
      if (pxSum !== 1) {
        return { error: "The sum of P(X) must be 1." };
      }

      let res = [];
      let show_res = "";
      let show_res1 = "";
      let txt = [];

      for (let i = 0; i < n; i++) {
        let val = parseFloat(xx[i]);
        let val1 = parseFloat(px[i]);
        let product = val * val1;
        res.push(product);

        let plus = i + 1 === n ? "" : "+";
        show_res += `( ${val} ) * ( ${val1} )${plus}`;
        show_res1 += `( ${product} )${plus}`;

        txt[i] = `
            <tr class='bg-white'>
              <td class='border p-2'>${val}</td>
              <td class='border p-2'>${val1}</td>
              <td class='border p-2'>${product}</td>
            </tr>
          `;
        param["show_val" + i] = txt[i];
      }

      let sum1 = xx.reduce((a, b) => a + parseFloat(b), 0);
      let sum2 = px.reduce((a, b) => a + parseFloat(b), 0);
      let ress = res.reduce((a, b) => a + b, 0);

      param["tech_show_res"] = show_res;
      param["tech_show_res1"] = show_res1;
      param["tech_sum1"] = sum1;
      param["tech_sum2"] = sum2;
      param["tech_ress"] = ress;

      return param;
    } else if (check === "table") {
      let td_value = parseInt(body.tech_td_value);
      let numbers = [];
      let numbers1 = [];

      for (let i = 1; i < td_value; i++) {
        let aKey = `a${i}`;
        let bKey = `b${i}`;
        let aVal = parseFloat(body[aKey]);
        let bVal = parseFloat(body[bKey]);

        if (!isNaN(aVal)) numbers.push(aVal);
        if (!isNaN(bVal)) numbers1.push(bVal);
      }

      let n = numbers.length;
      let n1 = numbers1.length;

      if (n !== n1) {
        return { error: "X and P(X) must have same number of elements." };
      }

      let pxSum = numbers1.reduce((a, b) => a + b, 0);
      if (pxSum !== 1) {
        return { error: "The sum of P(X) must be 1." };
      }

      let res = [];
      let show_res = "";
      let show_res1 = "";
      let txt = [];

      for (let i = 0; i < n; i++) {
        let val = numbers[i];
        let val1 = numbers1[i];
        let product = val * val1;
        res.push(product);

        let plus = i + 1 === n ? "" : "+";
        show_res += `( ${val} ) * ( ${val1} )${plus}`;
        show_res1 += `( ${product} )${plus}`;

        txt[i] = `
            <tr class='bg-white'>
              <td class='border p-2'>${val}</td>
              <td class='border p-2'>${val1}</td>
              <td class='border p-2'>${product}</td>
            </tr>
          `;
        param["show_val" + i] = txt[i];
      }

      let sum1 = numbers.reduce((a, b) => a + b, 0);
      let sum2 = numbers1.reduce((a, b) => a + b, 0);
      let ress = res.reduce((a, b) => a + b, 0);

      param["tech_show_res"] = show_res;
      param["tech_show_res1"] = show_res1;
      param["tech_sum1"] = sum1;
      param["tech_sum2"] = sum2;
      param["tech_ress"] = ress;

      return param;
    } else {
      return { error: "Please fill all fields." };
    }
  }

  /** getCalculationMadCalculator
   * POST: /api/calculators-lol/mad-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMadCalculator(body) {
    let x = body.tech_x;
    let method = parseInt(body.tech_method);
    let m = parseFloat(body.tech_m);
    let data = [];
    let response = {};

    if (x) {
      x = x.replace(/[\s,\n\r]+/g, ","); // Normalize to single commas
      while (x.includes(",,")) x = x.replace(",,", ",");
      data = x
        .split(",")
        .map((s) => s.trim())
        .filter((s) => s !== "");

      if (!data.every((v) => !isNaN(v))) {
        response.error = "Please! Check Your Input";
        return response;
      }

      data = data.map(Number);
      response.tech_x = x;
      response.tech_m = m;

      if (method === 0) {
        let sum = data.reduce((a, b) => a + b, 0);
        let n = data.length;
        let mean = sum / n;
        let diff = data.map((v) => Math.abs(mean - v));
        let sum1 = diff.reduce((a, b) => a + b, 0);
        let mad = sum1 / n;

        response.tech_n = n;
        response.tech_diff = diff;
        response.tech_sum1 = sum1;
        response.tech_mean = mean;
        response.tech_method = method;
        response.tech_mad = parseFloat(mad.toFixed(1));
        return response;
      } else if (method === 1) {
        data.sort((a, b) => a - b);
        let n = data.length;
        let median =
          n % 2 !== 0
            ? data[Math.floor(n / 2)]
            : (data[n / 2] + data[n / 2 - 1]) / 2;

        response.tech_median = median;

        let diff = data.map((v) => Math.abs(median - v));
        response.tech_diff = diff;

        diff.sort((a, b) => a - b);
        let n1 = diff.length;
        let median1 =
          n1 % 2 !== 0
            ? diff[Math.floor(n1 / 2)]
            : (diff[n1 / 2] + diff[n1 / 2 - 1]) / 2;

        response.tech_diff1 = diff;
        response.tech_mad = parseFloat(median1.toFixed(1));
        response.tech_method = method;
        return response;
      } else {
        let n = data.length;
        let diff = data.map((v) => Math.abs(m - v));
        let sum = diff.reduce((a, b) => a + b, 0);
        let mad = sum / n;

        response.tech_diff = diff;
        response.tech_sum = sum;
        response.tech_mad = parseFloat(mad.toFixed(1));
        response.tech_method = method;
        return response;
      }
    } else {
      response.error = "Please! Check Your Input";
      return response;
    }
  }

  /** getCalculationPermutationCalculator
   * POST: /api/calculators-lol/permutation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPermutationCalculator(body) {
    let n = parseInt(body.tech_n);
    let r = parseInt(body.tech_r);
    let find = body.tech_find;

    let response = {};

    if (!isNaN(n) && !isNaN(r)) {
      response.tech_n = n;
      response.tech_r = r;
      response.tech_find = find;

      if (r <= n) {
        let n_fact = factorial(n);
        let r_fact = factorial(r);
        let nr = n - r;
        let nr_fact = factorial(nr);
        let nr_fact_prod = r_fact * nr_fact;

        let nr1 = n + r - 1;
        let nr1_fact = factorial(nr1);
        let n1 = n - 1;
        let n1_fact = factorial(n1);
        let nr1_fact_prod = r_fact * n1_fact;

        let comb = n_fact / nr_fact_prod;
        let perm = n_fact / nr_fact;
        let comb_rep = nr1_fact / nr1_fact_prod;
        let perm_rep = Math.pow(n, r);

        if (find === "2") {
          response.tech_perms = "perms";
        } else {
          response.tech_p_w_r = "p_w_r";
        }

        // Step 1 string
        let s1 = Array.from({ length: n }, (_, i) => i + 1).join(" * ");

        // Step 2 string
        let s2 = Array.from({ length: nr }, (_, i) => i + 1).join(" * ");

        response.tech_comb = comb;
        response.tech_perm = perm;
        response.tech_s1 = s1;
        response.tech_s2 = s2;
        response.tech_nr = nr;
        response.tech_n_fact = n_fact;
        response.tech_r_fact = r_fact;
        response.tech_nr_fact = nr_fact;
        response.tech_comb_rep = comb_rep;
        response.tech_perm_rep = perm_rep;

        if (n < 101) {
          response.tech_show_steps = "show_steps";
        }

        return response;
      } else {
        response.error = "r needs to be less than or equal to n";
        return response;
      }
    } else {
      response.error = "Please! Check Your Input";
      return response;
    }
  }

  /** getCalculationStandardDeviationCalculator
   * POST: /api/calculators-lol/standard-deviation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationStandardDeviationCalculator(body) {
    let stdv_txt = body.tech_stdv_txt;
    let stdv_rad = body.tech_stdv_rad;

    function sanitize(input) {
      return String(input).trim().replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }

    stdv_txt = sanitize(stdv_txt);
    stdv_txt = stdv_txt.replace(/\s+/g, " ");
    stdv_rad = sanitize(stdv_rad);

    let check = true;

    if (!stdv_txt) check = false;

    stdv_txt = stdv_txt.replace(/[ ,\n\r]+/g, ",");
    while (stdv_txt.includes(",,")) stdv_txt = stdv_txt.replace(/,,/g, ",");

    let dataArr = stdv_txt
      .split(",")
      .map((s) => s.trim())
      .filter((s) => s !== "")
      .map(Number);

    for (const value of dataArr) {
      if (isNaN(value)) check = false;
    }

    if (dataArr.length < 2) check = false;

    if (!check) {
      return { error: "Please! Check Your Input" };
    }

    const n = dataArr.length;
    const sum = dataArr.reduce((a, b) => a + b, 0);
    const mean = parseFloat((sum / n).toFixed(3));

    let sumSquaredDiff = 0;
    for (const value of dataArr) {
      sumSquaredDiff += Math.pow(value - mean, 2);
    }

    const mSym = stdv_rad === "population" ? "μ" : "x̄";
    const divisor = stdv_rad === "population" ? n : n - 1;
    const stdDev = parseFloat(Math.sqrt(sumSquaredDiff / divisor).toFixed(4));

    const variance = parseFloat(Math.pow(stdDev, 2).toFixed(2));
    const coefOfVar = parseFloat((stdDev / mean).toFixed(4));
    const stdErr = parseFloat((stdDev / Math.sqrt(n)).toFixed(4));

    let table = `<table class='w-full text-[18px]' style='border-collapse: collapse'><thead><tr class='bg-gray-100'><th class='border p-2 text-center text-blue'>xᵢ</th><th class='border p-2 text-center text-blue'>xᵢ - ${mSym}</th><th class='border p-2 text-center text-blue'>(xᵢ - ${mSym})²</th></tr></thead><tbody>`;
    let sumSq = 0;
    let frequencyMap = {};

    for (const val of dataArr) {
      const diff = val - mean;
      const squared = Math.pow(diff, 2);
      table += `<tr class='bg-white'><td class='border p-2 text-center'>${val}</td><td class='border p-2 text-center'>${diff.toFixed(
        3
      )}</td><td class='border p-2 text-center'>${squared.toFixed(
        3
      )}</td></tr>`;
      sumSq += squared;
      frequencyMap[val] = (frequencyMap[val] || 0) + 1;
    }

    table += `<tr class='bg-gray-100'><th class='border p-2 text-center text-blue'>Σxᵢ = ${sum}</th><th class='p-2 border'></th><th class='border p-2 text-center text-blue'>Σ(xᵢ - ${mSym})² = ${sumSq.toFixed(
      3
    )}</th></tr></tbody></table>`;

    let tablef = "";
    for (const [key, value] of Object.entries(frequencyMap)) {
      tablef += `<tr><td class='py-2 border-b'>${key}</td><td class='py-2 border-b'>${value} (${(
        (100 / n) *
        value
      ).toFixed(2)}%)</td></tr>`;
    }

    return {
      tech_put: (n / 100) * (1 - n / 100),
      tech_i: n,
      tech_mor: stdErr,
      tech_d: stdDev,
      tech_m: mean,
      tech_c: coefOfVar,
      tech_t_n: n,
      tech_v_2: variance,
      tech_sum: sum,
      tech_s_e: stdErr,
      tech_table: table,
      tech_tablef: tablef,
      tech_ar_sum: sumSq.toFixed(3),
      tech_stdv_rad: stdv_rad,
    };
  }

  /** getCalculationFiveNumberSummaryCalculator
   * POST: /api/calculators-lol/5-five-number-summary-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationFiveNumberSummaryCalculator(body) {
    let seprateby = body.tech_seprateby;
    let textarea = body.tech_textarea;

    if (!textarea || textarea.trim() === "") {
      return { error: "Please! Check Your Input" };
    }

    seprateby = seprateby === "space" ? " " : seprateby;
    let values = textarea
      .split(seprateby)
      .map((v) => v.trim())
      .filter((v) => v !== "");

    let isNumeric = values.every((val) => !isNaN(val));
    if (!isNumeric) {
      return { error: "Please! Check Your Input" };
    }

    values = values.map(Number).sort((a, b) => a - b);

    if (values.length < 2) {
      return { error: "Please! enter 2 or more numbers" };
    }

    let count = values.length;
    let a1 = values[0];
    let a2 = values[count - 1];

    const quartile = (arr) => {
      let sorted = [...arr].sort((a, b) => a - b);
      let mid = Math.floor((sorted.length - 1) / 2);
      if (sorted.length % 2) {
        return Number(sorted[mid].toFixed(1));
      } else {
        return Number(((sorted[mid] + sorted[mid + 1]) / 2).toFixed(1));
      }
    };

    let second = quartile(values);
    let tmp = { first: [], third: [] };
    values.forEach((val) => {
      if (val < second) tmp.first.push(val);
      else if (val > second) tmp.third.push(val);
    });

    let first = quartile(tmp.first);
    let third = quartile(tmp.third);
    let min = Math.min(...values);
    let max = Math.max(...values);
    let iter = third - first;
    let sum = values.reduce((acc, cur) => acc + cur, 0);
    let average = Number((sum / count).toFixed(4));

    let median;
    if (count % 2 !== 0) {
      median = values[Math.floor(count / 2)];
    } else {
      median = (values[count / 2 - 1] + values[count / 2]) / 2;
    }

    let freqMap = {};
    values.forEach((val) => {
      freqMap[val] = (freqMap[val] || 0) + 1;
    });

    let maxFreq = Math.max(...Object.values(freqMap));
    let mode = Object.keys(freqMap)
      .filter((k) => freqMap[k] === maxFreq)
      .map(Number);

    let mean = sum / count;
    let d = values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0);
    let s_d_p = Math.sqrt(d / count).toFixed(4);
    let s_d_s = Math.sqrt(d / (count - 1)).toFixed(4);

    return {
      tech_a1: a1,
      tech_a2: a2,
      tech_min: min,
      tech_max: max,
      tech_first: first,
      tech_second: second,
      tech_third: third,
      tech_iter: iter,
      tech_mode: mode,
      tech_s_d_p: s_d_p,
      tech_s_d_s: s_d_s,
      tech_median: median,
      tech_average: average,
      tech_count: count,
      tech_numbers: values,
      tech_desc: [...values].sort((a, b) => b - a),
    };
  }

  /** getCalculationConfidenceIntervalCalculator
   * POST: /api/calculators-lol/confidence-interval-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationConfidenceIntervalCalculator(body) {
    let x = parseFloat(body.tech_x);
    let s = parseFloat(body.tech_s);
    let n = parseFloat(body.tech_n);
    let cl = parseFloat(body.tech_cl);
    let z = parseFloat(body.tech_z);

    if (!isNaN(x) && !isNaN(s) && !isNaN(n) && !isNaN(cl) && !isNaN(z)) {
      if (n < 1 || cl < 0 || cl > 99.99) {
        return { error: "Please! Check Your Input" };
      }

      const sigFig = (value, digits) => {
        if (value === 0) return 0;
        const d = digits - Math.floor(Math.log10(Math.abs(value))) - 1;
        return Number(value.toFixed(d));
      };

      let se = s / Math.sqrt(n);
      let moe = z * se;
      let ci1 = x - moe;
      let ci2 = x + moe;
      let ci = `${x} ± ${sigFig(moe, 4)}`;
      let rtpv = (100 - cl) / 2 / 100;

      return {
        tech_se: sigFig(se, 5),
        tech_ci: ci,
        tech_ci1: sigFig(ci1, 4),
        tech_ci2: sigFig(ci2, 4),
        tech_lb: sigFig(ci1, 6),
        tech_ub: sigFig(ci2, 6),
        tech_moe: sigFig(moe, 5),
        tech_rtpv: rtpv,
        tech_zscore: sigFig(z, 7),
      };
    } else {
      return { error: "Please! Fill All The Fields" };
    }
  }

  /** getCalculationVarianceCalculator
   * POST: /api/calculators-lol/variance-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationVarianceCalculator(body) {
    let cal_meth = body.tech_cal_meth;
    let set = body.tech_set;

    if (!set || !cal_meth) {
      return { error: "Please check your input." };
    }

    let check = true;
    set = set.replace(/[\n\r\s]+/g, ",").replace(/,+/g, ",");
    let setArray = set
      .split(",")
      .map((v) => v.trim())
      .filter((v) => v !== "")
      .map(Number);

    if (setArray.length < 2 || setArray.some(isNaN)) {
      return { error: "Please check your input." };
    }

    setArray.sort((a, b) => a - b);
    let array_set = [...setArray];
    let i = setArray.length;
    let sum = setArray.reduce((a, b) => a + b, 0);
    let mean = parseFloat((sum / i).toFixed(3));
    let d = setArray.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0);

    let s_d, mSym;
    if (cal_meth === "population") {
      s_d = Math.sqrt(d / i);
      mSym = "μ";
    } else {
      s_d = Math.sqrt(d / (i - 1));
      mSym = "x̄";
    }

    s_d = parseFloat(s_d.toFixed(4));
    let variance = parseFloat((s_d ** 2).toFixed(2));
    let c_v = parseFloat((s_d / mean).toFixed(4));

    // Table creation (as HTML string)
    let ss = 0;
    let table = `<table class='w-full text-[18px]' style='border-collapse: collapse'><thead><tr class='bg-gray-100'><th class='border p-2 text-center text-blue'>xᵢ</th><th class='border p-2 text-center text-blue'>xᵢ - ${mSym}</th><th class='border p-2 text-center text-blue'>(xᵢ - ${mSym})²</th></tr></thead><tbody>`;

    for (let f = 0; f < i; f++) {
      let xi = setArray[f];
      let diff = xi - mean;
      let sq = Math.pow(diff, 2);
      ss += sq;
      table += `<tr class='bg-white'><td class='border p-2 text-center'>${xi}</td><td class='border p-2 text-center'>${diff.toFixed(
        3
      )}</td><td class='border p-2 text-center'>${sq.toFixed(3)}</td></tr>`;
    }

    table += `<tr class='bg-gray-100'><th class='border p-2 text-center text-blue'>Σxᵢ = ${sum}</th><th class='border p-2'></th><th class='border p-2 text-center text-blue'>Σ(xᵢ - ${mSym})² = ${ss.toFixed(
      3
    )}</th></tr></tbody></table>`;

    return {
      tech_var: variance,
      tech_mean: mean,
      tech_s_d: s_d,
      tech_c_v: c_v,
      tech_t_n: i,
      tech_sum: sum,
      tech_table: table,
      tech_ss: parseFloat(ss.toFixed(3)),
      tech_cal_meth: cal_meth,
      tech_set: setArray,
      tech_array_set: array_set,
    };
  }

  /** getCalculationCoefficientOfDeterminationCalculator
   * POST: /api/calculators-lol/coefficient-of-determination
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCoefficientOfDeterminationCalculator(body) {
    let x = body.tech_x;
    let y = body.tech_y;

    // Clean and normalize the input
    x = x
      .replace(/[\s,\n\r]+/g, ",")
      .replace(/,+/g, ",")
      .trim();
    y = y
      .replace(/[\s,\n\r]+/g, ",")
      .replace(/,+/g, ",")
      .trim();

    if (!x || !y) {
      return { error: "Please check your input." };
    }

    let set1 = x
      .split(",")
      .map((v) => v.trim())
      .filter((v) => v !== "");
    let set2 = y
      .split(",")
      .map((v) => v.trim())
      .filter((v) => v !== "");

    if (set1.some(isNaN) || set2.some(isNaN) || set1.length !== set2.length) {
      return { error: "Please check your input." };
    }

    set1 = set1.map(Number);
    set2 = set2.map(Number);

    const n = set1.length;
    const sumx = set1.reduce((a, b) => a + b, 0);
    const sumy = set2.reduce((a, b) => a + b, 0);

    let table = `<table class='w-full text-[18px]' style='border-collapse: collapse'><thead><tr class='bg-gray-100'><th class='border p-2 text-center text-blue'>Obs.</th><th class='border p-2 text-center text-blue'>X</th><th class='border p-2 text-center text-blue'>Y</th><th class='border p-2 text-center text-blue'>Xᵢ²</th><th class='border p-2 text-center text-blue'>Yᵢ²</th><th class='border p-2 text-center text-blue'>Xᵢ⋅Yᵢ</th></tr></thead><tbody>`;

    let sumxi = 0,
      sumyi = 0,
      sumxy = 0;
    for (let i = 0; i < n; i++) {
      const xi2 = Math.pow(set1[i], 2);
      const yi2 = Math.pow(set2[i], 2);
      const xyi = set1[i] * set2[i];
      sumxi += xi2;
      sumyi += yi2;
      sumxy += xyi;

      table += `<tr class='bg-white'><td class='border p-2 text-center'>${
        i + 1
      }</td><td class='border p-2 text-center'>${
        set1[i]
      }</td><td class='border p-2 text-center'>${
        set2[i]
      }</td><td class='border p-2 text-center'>${xi2}</td><td class='border p-2 text-center'>${yi2}</td><td class='border p-2 text-center'>${xyi}</td></tr>`;
    }
    table += `<tr class='bg-gray-100'><th class='border p-2 text-center text-blue'>Sum = </th><th class='border p-2 text-center text-blue'>${sumx}</th><th class='border p-2 text-center text-blue'>${sumy}</th><th class='border p-2 text-center text-blue'>${sumxi}</th><th class='border p-2 text-center text-blue'>${sumyi}</th><th class='border p-2 text-center text-blue'>${sumxy}</th></tr></tbody></table>`;

    const sumx2 = Math.pow(sumx, 2);
    const sumy2 = Math.pow(sumy, 2);

    const ssxx = sumxi - (1 / n) * sumx2;
    const ssyy = sumyi - (1 / n) * sumy2;
    const ssxy = sumxy - (1 / n) * sumx * sumy;
    const r = ssxy / Math.sqrt(ssxx * ssyy);
    const r2 = Math.pow(r, 2);

    const meanx = sumx / n;
    const meany = sumy / n;

    let s1 = "",
      s2 = "",
      s3 = "",
      s_d = 0,
      s_d1 = 0;
    for (let i = 0; i < n; i++) {
      const dx = set1[i] - meanx;
      const dy = set2[i] - meany;

      s1 +=
        `(${set1[i]} - ${meanx.toFixed(4)})(${set2[i]} - ${meany.toFixed(4)})` +
        (i < n - 1 ? " + " : "");
      s2 += `(${dx.toFixed(4)}*${dy.toFixed(4)})` + (i < n - 1 ? " + " : "");
      s3 += `(${(dx * dy).toFixed(4)})` + (i < n - 1 ? " + " : "");

      s_d += dx * dx;
      s_d1 += dy * dy;
    }

    const stdx = Math.sqrt(s_d / (n - 1));
    const stdy = Math.sqrt(s_d1 / (n - 1));
    const s11 = (n - 1) * stdx * stdy;

    const delta = n * sumxi - sumx2;
    const a = (n * sumxy - sumx * sumy) / delta;
    const b = (sumxi * sumy - sumx * sumxy) / delta;

    let sst = 0,
      sst_table = `<table class='w-full text-[18px]' style='border-collapse: collapse'><thead><tr class='bg-gray-100'><th class='border p-2 text-center text-blue'>i</th><th class='border p-2 text-center text-blue'>yᵢ</th><th class='border p-2 text-center text-blue'>ȳ</th><th class='border p-2 text-center text-blue'>(yᵢ - ȳ)²</th></tr></thead><tbody>`;
    for (let i = 0; i < n; i++) {
      const diff = Math.pow(set2[i] - meany, 2);
      sst_table += `<tr class='bg-white'><td class='border p-2 text-center'>${i}</td><td class='border p-2 text-center'>${
        set2[i]
      }</td><td class='border p-2 text-center'>${meany.toFixed(
        4
      )}</td><td class='border p-2 text-center'>${diff.toFixed(4)}</td></tr>`;
      sst += diff;
    }
    sst_table += `</tbody></table>`;

    let ssr = 0,
      ssr_table = `<table class='w-full text-[18px]' style='border-collapse: collapse'><thead><tr class='bg-gray-100'><th class='border p-2 text-center text-blue'>i</th><th class='border p-2 text-center text-blue'>x̂ᵢ</th><th class='border p-2 text-center text-blue'>ȳ</th><th class='border p-2 text-center text-blue'>(x̂ᵢ - ȳ)²</th></tr></thead><tbody>`;
    for (let i = 0; i < n; i++) {
      const yhat = a * set1[i] + b;
      const diff = Math.pow(yhat - meany, 2);
      ssr_table += `<tr class='bg-white'><td class='border p-2 text-center'>${i}</td><td class='border p-2 text-center'>${yhat.toFixed(
        4
      )}</td><td class='border p-2 text-center'>${meany.toFixed(
        4
      )}</td><td class='border p-2 text-center'>${diff.toFixed(4)}</td></tr>`;
      ssr += diff;
    }
    ssr_table += `</tbody></table>`;

    let sse = 0,
      sse_table = `<table class='w-full text-[18px]' style='border-collapse: collapse'><thead><tr class='bg-gray-100'><th class='border p-2 text-center text-blue'>i</th><th class='border p-2 text-center text-blue'>yᵢ</th><th class='border p-2 text-center text-blue'>x̂ᵢ</th><th class='border p-2 text-center text-blue'>(yᵢ - x̂ᵢ)²</th></tr></thead><tbody>`;
    for (let i = 0; i < n; i++) {
      const yhat = a * set1[i] + b;
      const diff = Math.pow(set2[i] - yhat, 2);
      sse_table += `<tr class='bg-white'><td class='border p-2 text-center'>${i}</td><td class='border p-2 text-center'>${
        set2[i]
      }</td><td class='border p-2 text-center'>${yhat.toFixed(
        4
      )}</td><td class='border p-2 text-center'>${diff.toFixed(4)}</td></tr>`;
      sse += diff;
    }
    sse_table += `</tbody></table>`;

    return {
      tech_n: n,
      tech_r: r.toFixed(4),
      tech_r2: r2.toFixed(4),
      tech_sumx: sumx.toFixed(4),
      tech_sumy: sumy.toFixed(4),
      tech_sumxi: sumxi.toFixed(4),
      tech_sumyi: sumyi.toFixed(4),
      tech_sumxy: sumxy.toFixed(4),
      tech_sumx2: sumx2.toFixed(4),
      tech_sumy2: sumy2.toFixed(4),
      tech_ssxx: ssxx.toFixed(4),
      tech_ssyy: ssyy.toFixed(4),
      tech_ssxy: ssxy.toFixed(4),
      tech_s_d: stdx.toFixed(4),
      tech_s_d1: stdy.toFixed(4),
      tech_s1: s1,
      tech_s2: s2,
      tech_s3: s3,
      tech_s11: s11.toFixed(4),
      tech_meanx: meanx.toFixed(4),
      tech_meany: meany.toFixed(4),
      tech_table: table,
      tech_sst: sst.toFixed(4),
      tech_ssr: ssr.toFixed(4),
      tech_sse: sse.toFixed(4),
      tech_a: a.toFixed(2),
      tech_b: b.toFixed(2),
      tech_sst_table: sst_table,
      tech_ssr_table: ssr_table,
      tech_sse_table: sse_table,
    };
  }

  /** getCalculationPointEstimateCalculator
   * POST: /api/calculators-lol/point-estimate
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPointEstimateCalculator(body) {
    let success = parseFloat(body.tech_success);
    let trials = parseFloat(body.tech_trials);
    let ci = parseFloat(body.tech_ci);
    let result = {};

    if (!isNaN(success) && !isNaN(trials) && !isNaN(ci)) {
      if (success <= trials) {
        const z_table = {
          "0.0": [
            0.5, 0.50399, 0.50798, 0.51197, 0.51595, 0.51994, 0.52392, 0.5279,
            0.53188, 0.53586,
          ],
          0.1: [
            0.5398, 0.5438, 0.54776, 0.55172, 0.55567, 0.55966, 0.5636, 0.56749,
            0.57142, 0.57535,
          ],
          0.2: [
            0.5793, 0.58317, 0.58706, 0.59095, 0.59483, 0.59871, 0.60257,
            0.60642, 0.61026, 0.61409,
          ],
          0.3: [
            0.61791, 0.62172, 0.62552, 0.6293, 0.63307, 0.63683, 0.64058,
            0.64431, 0.64803, 0.65173,
          ],
          0.4: [
            0.65542, 0.6591, 0.66276, 0.6664, 0.67003, 0.67364, 0.67724,
            0.68082, 0.68439, 0.68793,
          ],
          0.5: [
            0.69146, 0.69497, 0.69847, 0.70194, 0.7054, 0.70884, 0.71226,
            0.71566, 0.71904, 0.7224,
          ],
          0.6: [
            0.72575, 0.72907, 0.73237, 0.73565, 0.73891, 0.74215, 0.74537,
            0.74857, 0.75175, 0.7549,
          ],
          0.7: [
            0.75804, 0.76115, 0.76424, 0.7673, 0.77035, 0.77337, 0.77637,
            0.77935, 0.7823, 0.78524,
          ],
          0.8: [
            0.78814, 0.79103, 0.79389, 0.79673, 0.79955, 0.80234, 0.80511,
            0.80785, 0.81057, 0.81327,
          ],
          0.9: [
            0.81594, 0.81859, 0.82121, 0.82381, 0.82639, 0.82894, 0.83147,
            0.83398, 0.83646, 0.83891,
          ],
          "1.0": [
            0.84134, 0.84375, 0.84614, 0.84849, 0.85083, 0.85314, 0.85543,
            0.85769, 0.85993, 0.86214,
          ],
          1.1: [
            0.86433, 0.8665, 0.86864, 0.87076, 0.87286, 0.87493, 0.87698, 0.879,
            0.881, 0.88298,
          ],
          1.2: [
            0.88493, 0.88686, 0.88877, 0.89065, 0.89251, 0.89435, 0.89617,
            0.89796, 0.89973, 0.90147,
          ],
          1.3: [
            0.9032, 0.9049, 0.90658, 0.90824, 0.90988, 0.91149, 0.91308,
            0.91466, 0.91621, 0.91774,
          ],
          1.4: [
            0.91924, 0.92073, 0.9222, 0.92364, 0.92507, 0.92647, 0.92785,
            0.92922, 0.93056, 0.93189,
          ],
          1.5: [
            0.93319, 0.93448, 0.93574, 0.93699, 0.93822, 0.93943, 0.94062,
            0.94179, 0.94295, 0.94408,
          ],
          1.6: [
            0.9452, 0.9463, 0.94738, 0.94845, 0.9495, 0.95053, 0.95154, 0.95254,
            0.95352, 0.95449,
          ],
          1.7: [
            0.95543, 0.95637, 0.95728, 0.95818, 0.95907, 0.95994, 0.9608,
            0.96164, 0.96246, 0.96327,
          ],
          1.8: [
            0.96407, 0.96485, 0.96562, 0.96638, 0.96712, 0.96784, 0.96856,
            0.96926, 0.96995, 0.97062,
          ],
          1.9: [
            0.97128, 0.97193, 0.97257, 0.9732, 0.97381, 0.97441, 0.975, 0.97558,
            0.97615, 0.9767,
          ],
          "2.0": [
            0.97725, 0.97778, 0.97831, 0.97882, 0.97932, 0.97982, 0.9803,
            0.98077, 0.98124, 0.98169,
          ],
          2.1: [
            0.98214, 0.98257, 0.983, 0.98341, 0.98382, 0.98422, 0.98461, 0.985,
            0.98537, 0.98574,
          ],
          2.2: [
            0.9861, 0.98645, 0.98679, 0.98713, 0.98745, 0.98778, 0.98809,
            0.9884, 0.9887, 0.98899,
          ],
          2.3: [
            0.98928, 0.98956, 0.98983, 0.9901, 0.99036, 0.99061, 0.99086,
            0.99111, 0.99134, 0.99158,
          ],
          2.4: [
            0.9918, 0.99202, 0.99224, 0.99245, 0.99266, 0.99286, 0.99305,
            0.99324, 0.99343, 0.99361,
          ],
          2.5: [
            0.99379, 0.99396, 0.99413, 0.9943, 0.99446, 0.99461, 0.99477,
            0.99492, 0.99506, 0.9952,
          ],
          2.6: [
            0.99534, 0.99547, 0.9956, 0.99573, 0.99585, 0.99598, 0.99609,
            0.99621, 0.99632, 0.99643,
          ],
          2.7: [
            0.99653, 0.99664, 0.99674, 0.99683, 0.99693, 0.99702, 0.99711,
            0.9972, 0.99728, 0.99736,
          ],
          2.8: [
            0.99744, 0.99752, 0.9976, 0.99767, 0.99774, 0.99781, 0.99788,
            0.99795, 0.99801, 0.99807,
          ],
          2.9: [
            0.99813, 0.99819, 0.99825, 0.99831, 0.99836, 0.99841, 0.99846,
            0.99851, 0.99856, 0.99861,
          ],
          "3.0": [
            0.99865, 0.99869, 0.99874, 0.99878, 0.99882, 0.99886, 0.99889,
            0.99893, 0.99896, 0.999,
          ],
          3.1: [
            0.99903, 0.99906, 0.9991, 0.99913, 0.99916, 0.99918, 0.99921,
            0.99924, 0.99926, 0.99929,
          ],
          3.2: [
            0.99931, 0.99934, 0.99936, 0.99938, 0.9994, 0.99942, 0.99944,
            0.99946, 0.99948, 0.9995,
          ],
          3.3: [
            0.99952, 0.99953, 0.99955, 0.99957, 0.99958, 0.9996, 0.99961,
            0.99962, 0.99964, 0.99965,
          ],
          3.4: [
            0.99966, 0.99968, 0.99969, 0.9997, 0.99971, 0.99972, 0.99973,
            0.99974, 0.99975, 0.99976,
          ],
          3.5: [
            0.99977, 0.99978, 0.99978, 0.99979, 0.9998, 0.99981, 0.99981,
            0.99982, 0.99983, 0.99983,
          ],
          3.6: [
            0.99984, 0.99985, 0.99985, 0.99986, 0.99986, 0.99987, 0.99987,
            0.99988, 0.99988, 0.99989,
          ],
          3.7: [
            0.99989, 0.9999, 0.9999, 0.9999, 0.99991, 0.99991, 0.99992, 0.99992,
            0.99992, 0.99992,
          ],
          3.8: [
            0.99993, 0.99993, 0.99993, 0.99994, 0.99994, 0.99994, 0.99994,
            0.99995, 0.99995, 0.99995,
          ],
          3.9: [
            0.99995, 0.99995, 0.99996, 0.99996, 0.99996, 0.99996, 0.99996,
            0.99996, 0.99997, 0.99997,
          ],
          "4.0": [
            0.99997, 0.99997, 0.99997, 0.99997, 0.99997, 0.99997, 0.99998,
            0.99998, 0.99998, 0.99998,
          ],
        };

        function sigFig(value, digits) {
          if (value === 0) {
            return 0;
          }
          let decimalPlaces =
            digits - Math.floor(Math.log10(Math.abs(value))) - 1;
          return parseFloat(value.toFixed(decimalPlaces));
        }

        let z1 = (1 + ci / 100) / 2;
        let zz = z1.toString().split(".")[1]?.length || 0;
        let z = "";
        let old = 0.5;

        outer: for (let keys in z_table) {
          let values = z_table[keys];
          for (let key = 0; key < values.length; key++) {
            let value = values[key];
            if (key > 0) old = values[key - 1];
            if (z1 === value) {
              z = parseFloat(keys) + key / 100;
              break outer;
            } else if (key === 0 && value > z1) {
              z = parseFloat(keys) + key / 100;
              break outer;
            } else if (value > z1) {
              z = parseFloat(keys) + (key - 1) / 100;
              break outer;
            }
          }
        }

        let z_2 = Math.pow(z, 2);
        let mle = success / trials;
        let laplace = (success + 1) / (trials + 2);
        let jeffrey = (success + 0.5) / (trials + 1);
        let wilson = (success + z_2 / 2) / (trials + z_2);
        let pe;

        if (mle <= 0.5) {
          pe = wilson;
        } else if (mle > 0.5 && mle < 0.9) {
          pe = mle;
        } else if (mle >= 0.9 && mle < 1.0) {
          pe = jeffrey < laplace ? jeffrey : laplace;
        } else if (mle === 1.0) {
          pe = laplace;
        }

        if (ci > 0) {
          z = -z;
        }

        result.tech_pe = sigFig(pe, 4);
        result.tech_z = sigFig(z, 4);
        result.tech_mle = sigFig(mle, 4);
        result.tech_laplace = sigFig(laplace, 4);
        result.tech_jeffrey = sigFig(jeffrey, 4);
        result.tech_wilson = sigFig(wilson, 4);
      } else {
        result.error =
          "The number of trials must be greater than the number of successes";
      }
    } else {
      result.error = "Please check your input.";
    }

    return result;
  }

  /** getCalculationRelativeFrequencyCalculator
   * POST: /api/calculators-lol/relative-frequency
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRelativeFrequencyCalculator(body) {
    let data = body.tech_data;
    let freq = body.tech_freq;
    let k = parseInt(body.tech_k);
    let st_val = parseFloat(body.tech_st_val);
    let param = {};

    if (data && data.trim() !== "") {
      let check = true;

      data = data.replace(/[ ,\n\r]+/g, ",");
      data = data.replace(/[a-zA-Z]/g, "");
      while (data.includes(",,")) {
        data = data.replace(/,,/g, ",");
      }

      let set = data
        .split(",")
        .map((item) => item.trim())
        .filter((item) => item !== "")
        .map(Number);

      for (let value of set) {
        if (isNaN(value)) {
          check = false;
        }
        if (freq === "grp" && value < st_val) {
          param.error =
            "Number can't be less than the starting value of grouped data!";
          return param;
        }
      }

      if (freq === "grp" && (!k || isNaN(k))) {
        check = false;
      }

      if (!check) {
        param.error = "Please check your input.";
        return param;
      }

      let count = {};
      set.forEach((val) => (count[val] = (count[val] || 0) + 1));
      let n = set.length;

      let table = "";
      let rf_values = [];
      let rf1_values = [];

      if (freq === "ind") {
        table += `<table class='w-full text-[18px]' style='border-collapse: collapse'><thead><tr class='bg-gray-100'><th class='border p-2 text-center text-blue'>Element</th><th class='border p-2 text-center text-blue'>Frequency</th><th class='border p-2 text-center text-blue'>Relative Frequency</th><th class='border p-2 text-center text-blue'>Cumulative Relative Frequency</th></tr></thead><tbody>`;
        let cf = 0;
        let crf = 0;

        for (let key in count) {
          let f = count[key];
          cf += f;
          let rf = f / n;
          crf += rf;
          rf_values.push(rf);
          table += `<tr class='bg-white'><td class='border p-2 text-center'>${key}</td><td class='border p-2 text-center'>${f}</td><td class='border p-2 text-center'>${rf.toFixed(
            4
          )}</td><td class='border p-2 text-center'>${crf.toFixed(
            4
          )}</td></tr>`;
        }
        table += "</tbody></table>";
      }

      let ds = set.join(", ");
      set.sort((a, b) => a - b);
      let sum = set.reduce((a, b) => a + b, 0);
      let mean = sum / n;
      let average = parseFloat(mean.toFixed(4));
      let min = Math.min(...set);
      let max = Math.max(...set);
      let range = max - min;

      let median =
        n % 2 !== 0
          ? set[Math.floor(n / 2)]
          : (set[n / 2] + set[n / 2 - 1]) / 2;

      let m_max = Math.max(...Object.values(count));
      let mode = Object.keys(count).filter((k) => count[k] === m_max);

      let ss = 0,
        hm_sum = 0,
        asum = 0;
      set.forEach((val) => {
        ss += Math.pow(val - mean, 2);
        hm_sum += 1 / val;
        asum += Math.abs(val);
      });

      let hm = n / hm_sum;
      let s_d = Math.sqrt(ss / n);
      let s_d1 = Math.sqrt(ss / (n - 1));
      let variance = s_d * s_d;
      let c_v = s_d1 / mean;
      let gm = Math.pow(
        set.reduce((a, b) => a * b, 1),
        1 / n
      );
      let snr = mean / s_d1;

      let ad = set.reduce((acc, val) => acc + Math.abs(val - mean), 0);
      let mad = ad / n;

      function quartile(arr, q) {
        let pos = (arr.length + 1) * q;
        let base = Math.floor(pos) - 1;
        let rest = pos - Math.floor(pos);
        if (arr[base + 1] !== undefined) {
          return arr[base] + rest * (arr[base + 1] - arr[base]);
        } else {
          return arr[base];
        }
      }

      let q1 = quartile(set, 0.25);
      let q2 = quartile(set, 0.5);
      let q3 = quartile(set, 0.75);
      let iqr = q3 - q1;
      let qd = iqr / 2;
      let cqd = iqr / (q3 + q1);
      let uf = q1 - 1.5 * iqr;
      let lf = q3 + 1.5 * iqr;

      let z = set.map((val) => ((val - mean) / s_d).toFixed(4)).join(", ");
      let sds = set.join(", ");

      if (freq === "grp") {
        let ci = Math.round((max - min) / k + 1);
        let x = st_val;
        let group = [];
        let group_count = [];

        for (let i = 0; i < k; i++) {
          let next = x + ci;
          if (next > 10000000) {
            param.error = "A number can't be Greater Than 10000000";
            return param;
          }
          group.push(`${x} to ${next}`);
          let count = set.filter((val) => val >= x && val <= next).length;
          group_count.push(count);
          x = next + 1;
        }

        table = `<table class='w-full text-[18px]' style='border-collapse: collapse'><thead><tr class='bg-gray-100'><th class='border p-2 text-center text-blue'>Group</th><th class='border p-2 text-center text-blue'>Frequency</th><th class='border p-2 text-center text-blue'>Relative Frequency</th><th class='border p-2 text-center text-blue'>Cumulative Relative Frequency</th></tr></thead><tbody>`;
        let cf1 = 0,
          crf1 = 0;
        for (let i = 0; i < k; i++) {
          cf1 += group_count[i];
          let rf1 = group_count[i] / n;
          crf1 += rf1;
          rf1_values.push(rf1);
          table += `<tr class='bg-white'><td class='border p-2 text-center'>${
            group[i]
          }</td><td class='border p-2 text-center'>${
            group_count[i]
          }</td><td class='border p-2 text-center'>${rf1.toFixed(
            4
          )}</td><td class='border p-2 text-center'>${crf1.toFixed(
            4
          )}</td></tr>`;
        }
        table += "</tbody></table>";

        param.tech_group = group;
        param.tech_group_count = group_count;
      }

      Object.assign(param, {
        tech_table: table,
        tech_set: set,
        tech_ds: ds,
        tech_rf_values: rf_values,
        tech_rf1_values: rf1_values,
        tech_sds: sds,
        tech_n: n,
        tech_count: count,
        tech_mean: mean,
        tech_median: median,
        tech_mode: mode,
        tech_min: min,
        tech_max: max,
        tech_range: range,
        tech_sum: sum,
        tech_ss: ss,
        tech_asum: asum,
        tech_s_d: s_d,
        tech_s_d1: s_d1,
        tech_c_v: c_v,
        tech_snr: snr,
        tech_variance: variance,
        tech_gm: gm,
        tech_hm: hm,
        tech_ad: ad,
        tech_mad: mad,
        tech_q1: q1,
        tech_q2: q2,
        tech_q3: q3,
        tech_iqr: iqr,
        tech_qd: qd,
        tech_cqd: cqd,
        tech_uf: uf,
        tech_lf: lf,
        tech_z: z,
      });

      return param;
    } else {
      return { error: "Please check your input." };
    }
  }

  /** getCalculationProbabilityCalculator
   * POST: /api/calculators-lol/probability-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationProbabilityCalculator(body) {
    let result = {};

    let option = body.tech_for;

    if (option === "1") {
      let nbr1 = Number(body.tech_nbr1);
      let event = Number(body.tech_event);

      if (!isNaN(nbr1) && !isNaN(event)) {
        let event_occur = +(event / nbr1).toFixed(3);
        let not_occur = +(1 - event_occur).toFixed(3);

        result.tech_event_occur = event_occur;
        result.tech_not_occur = not_occur;
        result.tech_Single = "active";
      } else {
        result.error = "Please fill All fields.";
      }
    } else if (option === "2") {
      let nbr2 = Number(body.tech_nbr2);
      let event_a = Number(body.tech_event_a);
      let event_b = Number(body.tech_event_b);

      if (!isNaN(nbr2) && !isNaN(event_a) && !isNaN(event_b)) {
        let event_a_occur = +(event_a / nbr2).toFixed(4);
        let not_a_occur = +(1 - event_a_occur).toFixed(4);
        let event_b_occur = +(event_b / nbr2).toFixed(4);
        let not_b_occur = +(1 - event_b_occur).toFixed(4);
        let both_events = +(event_a_occur * event_b_occur).toFixed(4);
        let either_events = +(
          event_a_occur +
          event_b_occur -
          both_events
        ).toFixed(4);
        let conditional = +(both_events / event_b_occur).toFixed(4);

        result = {
          tech_event_a_occur: event_a_occur,
          tech_not_a_occur: not_a_occur,
          tech_event_b_occur: event_b_occur,
          tech_not_b_occur: not_b_occur,
          tech_both_events: both_events,
          tech_either_events: either_events,
          tech_conditional: conditional,
          tech_Multiple: "active",
        };
      } else {
        result.error = "Please fill All fields.";
      }
    } else if (option === "3") {
      let pro_a = Number(body.tech_pro_a);
      let pro_b = Number(body.tech_pro_b);
      let format = body.format;

      if (!isNaN(pro_a) && !isNaN(pro_b)) {
        if (format === "2") {
          pro_a = pro_a / 100;
          pro_b = pro_b / 100;
        }

        let not_a_occur = +(1 - pro_a).toFixed(4);
        let not_b_occur = +(1 - pro_b).toFixed(4);
        let both_events = +(pro_a * pro_b).toFixed(4);
        let either_events = +(pro_a + pro_b - both_events).toFixed(5);
        let conditional = +(both_events / pro_b).toFixed(4);
        let not_both = +(pro_a + pro_b - 2 * both_events).toFixed(5);
        let nor_both = +(1 - either_events).toFixed(5);
        let anotb = +(pro_a * (1 - pro_b)).toFixed(5);
        let bnota = +((1 - pro_a) * pro_b).toFixed(5);

        result = {
          tech_not_a_occur: not_a_occur,
          tech_not_b_occur: not_b_occur,
          tech_both_events: both_events,
          tech_either_events: either_events,
          tech_conditional: conditional,
          tech_not_both: not_both,
          tech_nor_both: nor_both,
          tech_anotb: anotb,
          tech_bnota: bnota,
          tech_pro_a: pro_a,
          tech_pro_b: pro_b,
          tech_Solver: "events",
        };
      } else {
        result.error = "Please fill All fields.";
      }
    } else if (option === "4") {
      let eve_a = Number(body.tech_eve_a);
      let rep_a = Number(body.tech_rep_a);
      let eve_b = Number(body.tech_eve_b);
      let rep_b = Number(body.tech_rep_b);

      if (!isNaN(eve_a) && !isNaN(rep_a) && !isNaN(eve_b) && !isNaN(rep_b)) {
        result = {
          tech_Events: "events",
        };
      } else {
        result.error = "Please fill All fields.";
      }
    } else if (option === "5") {
      let andb = Number(body.tech_andb);
      let prob_b = Number(body.tech_prob_b);

      if (!isNaN(andb) && !isNaN(prob_b)) {
        result.tech_condi = +(andb / prob_b).toFixed(4);
      } else {
        result.error = "Please fill All fields.";
      }
    }

    return result;
  }

  /** getCalculationCoefficientOfVariationCalculator
   * POST: /api/calculators-lol/coefficient-of-variation
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCoefficientOfVariationCalculator(body) {
    let result = {};

    let x = body.tech_x;
    let type = body.tech_type_;

    if (x && x.trim() !== "") {
      let cleaned = x.replace(/[\n\r\s,]+/g, ",");
      while (cleaned.includes(",,")) cleaned = cleaned.replace(",,", ",");

      let array = cleaned
        .split(",")
        .map((v) => v.trim())
        .filter((v) => v !== "");
      let count = array.length;
      let replace = cleaned.replace(/,/g, "+");

      let isAllNumbers = array.every((val) => !isNaN(val));
      let numericArray = array.map(Number);

      result.tech_count = count;
      result.tech_arr = array;
      result.tech_replace = replace;

      if (isAllNumbers) {
        let sum = numericArray.reduce((a, b) => a + b, 0);
        let mean = +(sum / count).toFixed(3);

        let d = 0;
        for (let val of numericArray) {
          d += Math.pow(val - mean, 2);
        }

        let s_d =
          type === "2" ? Math.sqrt(d / count) : Math.sqrt(d / (count - 1));
        s_d = +s_d.toFixed(4);

        let c = +(s_d / mean).toFixed(4);

        result.tech_sum = sum;
        result.tech_m = mean;
        result.tech_d = s_d;
        result.tech_c = c;
        result.tech_t_n = count;
      } else {
        result.error = "Please Enter Valid Input.";
      }
    } else {
      result.error = "Please fill All fields.";
    }

    return result;
  }

  /** getCalculationCovarianceCalculator
   * POST: /api/calculators-lol/covariance-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCovarianceCalculator(body) {
    let param = {};

    let set_x = body.tech_set_x;
    let set_y = body.tech_set_y;
    let formula = body.tech_formula;
    let between = Number(body.tech_between);
    let devi_x = Number(body.tech_devi_x);
    let devi_y = Number(body.tech_devi_y);
    let matrix = body.tech_matrix;

    if (formula === "1") {
      if (set_x && set_y) {
        // Normalize inputs: replace spaces/newlines etc with commas
        set_x = set_x.replace(/[\s,\n\r]+/g, ",");
        while (set_x.includes(",,")) set_x = set_x.replace(/,,/g, ",");

        set_y = set_y.replace(/[\s,\n\r]+/g, ",");
        while (set_y.includes(",,")) set_y = set_y.replace(/,,/g, ",");

        let arrayX = set_x
          .split(",")
          .map((e) => e.trim())
          .filter((e) => e !== "");
        let arrayY = set_y
          .split(",")
          .map((e) => e.trim())
          .filter((e) => e !== "");

        // Validate numeric and equal length
        let check =
          arrayX.length === arrayY.length &&
          arrayX.every((val) => !isNaN(Number(val))) &&
          arrayY.every((val) => !isNaN(Number(val)));

        if (check) {
          let nbr = arrayX.length;
          let numsX = arrayX.map(Number);
          let numsY = arrayY.map(Number);

          let sumX = numsX.reduce((a, b) => a + b, 0);
          let sumY = numsY.reduce((a, b) => a + b, 0);

          let meanX = +(sumX / nbr).toFixed(2);
          let meanY = +(sumY / nbr).toFixed(2);

          let total = 0;
          for (let i = 0; i < nbr; i++) {
            let X1 = numsX[i] - meanX;
            let Y1 = numsY[i] - meanY;
            total += X1 * Y1;
          }

          let sample = +(total / nbr).toFixed(2);
          let population = +(total / (nbr - 1)).toFixed(2);

          param.tech_nbr = nbr;
          param.tech_mean_x = meanX;
          param.tech_mean_y = meanY;
          param.tech_sample = sample;
          param.tech_population = population;
          param.tech_formula = formula;

          return param;
        } else {
          param.error = "Please Check Your Input";
          return param;
        }
      } else {
        param.error = "Please Enter all value";
        return param;
      }
    }

    if (formula === "2") {
      if (!isNaN(between) && !isNaN(devi_x) && !isNaN(devi_y)) {
        param.tech_ans_2 = +(between * devi_x * devi_y).toFixed(2);
        param.tech_formula = formula;
        return param;
      } else {
        param.error = "Please fill All fields.";
        return param;
      }
    }

    if (formula === "3") {
      if (matrix) {
        let check = true;
        // split matrix string on ']' to get rows
        let matrixRows = matrix.split("]");
        let rows = matrixRows.length;
        if (rows < 2) {
          param.error = "Please Enter Matrix";
          return param;
        }

        // Extract first row to get column count
        let firstRowStr = matrixRows[0].split("[")[1];
        if (!firstRowStr) {
          param.error = "Invalid Matrix Format";
          return param;
        }
        let firstRow = firstRowStr
          .split(",")
          .map((e) => e.trim())
          .filter((e) => e !== "");
        let rowCount = firstRow.length;

        // Initialize arrays
        let arrayRow = new Array(rowCount).fill(0);
        let arrayAvg = new Array(rowCount).fill(0);

        for (let i = 0; i < rows - 1; i++) {
          let rowParts = matrixRows[i].split("[");
          if (rowParts.length < 2) {
            check = false;
            break;
          }
          let rowValues = rowParts[1]
            .split(",")
            .map((e) => e.trim())
            .filter((e) => e !== "");
          if (rowValues.length !== rowCount) {
            check = false;
            break;
          }

          for (let k = 0; k < rowCount; k++) {
            let val = Number(rowValues[k]);
            if (isNaN(val)) {
              check = false;
            } else {
              arrayRow[k] += val;
              arrayAvg[k] += val;
            }
          }
        }

        // Calculate averages
        for (let i = 0; i < rowCount; i++) {
          arrayAvg[i] = +(arrayAvg[i] / (rows - 1)).toFixed(2);
        }

        // Calculate final rows after subtracting averages
        let finalRows = Array(rows - 1)
          .fill(0)
          .map(() => new Array(rowCount).fill(0));

        for (let i = 0; i < rows - 1; i++) {
          let rowParts = matrixRows[i].split("[");
          let rowValues = rowParts[1]
            .split(",")
            .map((e) => e.trim())
            .filter((e) => e !== "");
          for (let j = 0; j < rowCount; j++) {
            finalRows[i][j] = Number(rowValues[j]) - arrayAvg[j];
          }
        }

        // Transpose rows
        let transRows = Array(rowCount)
          .fill(0)
          .map(() => new Array(rows - 1).fill(0));

        for (let i = 0; i < rowCount; i++) {
          for (let j = 0; j < rows - 1; j++) {
            transRows[i][j] = finalRows[j][i];
          }
        }

        // Multiply transRows and finalRows matrices
        let resultRows = Array(rowCount)
          .fill(0)
          .map(() => new Array(rowCount).fill(0));

        for (let i = 0; i < rowCount; i++) {
          for (let j = 0; j < rowCount; j++) {
            let sum = 0;
            for (let k = 0; k < rows - 1; k++) {
              sum += transRows[i][k] * finalRows[k][j];
            }
            resultRows[i][j] = sum;
          }
        }

        // Format output string
        let output = "";
        for (let i = 0; i < rowCount; i++) {
          output += "[ ";
          for (let j = 0; j < rowCount; j++) {
            let val = +(resultRows[i][j] / (rows - 1)).toFixed(5);
            output += j === rowCount - 1 ? `${val} ] <br>` : `${val} , `;
          }
        }

        if (check) {
          param.tech_output = output;
          param.tech_formula = formula;
          return param;
        } else {
          param.error = "Please Check Your Input";
          return param;
        }
      } else {
        param.error = "Please Enter Matrix";
        return param;
      }
    }

    // If formula not matched
    param.error = "Invalid formula value";
    return param;
  }

  /** getCalculationMeanMedianModeRangeCalculator
   * POST: /api/calculators-lol/mean-median-mode-range
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMeanMedianModeRangeCalculator(body) {
    let x = body.tech_x;

    let result = {};
    let check = true;

    if (!x) {
      check = false;
    }

    x = x.replace(/[\s,\n\r]+/g, ",");
    while (x.includes(",,")) x = x.replace(",,", ",");

    let numbers = x
      .split(",")
      .map((s) => s.trim())
      .filter((s) => s !== "")
      .map(Number);

    for (let val of numbers) {
      if (isNaN(val)) {
        check = false;
        break;
      }
    }

    if (check) {
      numbers.sort((a, b) => a - b);
      let sum = numbers.reduce((a, b) => a + b, 0);
      let count = numbers.length;
      let average = +(sum / count).toFixed(4);

      // Median
      let median;
      if (count % 2 !== 0) {
        median = numbers[Math.floor(count / 2)];
      } else {
        let mid = count / 2;
        median = (numbers[mid] + numbers[mid - 1]) / 2;
      }

      function interpolate(array, position) {
        let floorIdx = Math.floor(position) - 1;
        let ceilIdx = Math.ceil(position) - 1;
        if (floorIdx === ceilIdx) {
          return array[floorIdx];
        } else {
          return (
            array[floorIdx] +
            (position - Math.floor(position)) *
              (array[ceilIdx] - array[floorIdx])
          );
        }
      }

      // Q1 and Q3
      let Q1_pos = (count + 1) / 4;
      let Q3_pos = (3 * (count + 1)) / 4;
      let Q1 = interpolate(numbers, Q1_pos);
      let Q3 = interpolate(numbers, Q3_pos);
      let IQR = Q3 - Q1;

      // Mode
      let freq = {};
      for (let n of numbers) {
        freq[n] = (freq[n] || 0) + 1;
      }

      let maxFreq = Math.max(...Object.values(freq));
      let mode = [];
      let hasRepeating = false;
      for (let key in freq) {
        if (freq[key] > 1 && freq[key] === maxFreq) {
          mode.push(Number(key));
          hasRepeating = true;
        }
      }

      if (!hasRepeating) {
        mode.push("No value appears more than once!");
      }

      result = {
        tech_Q1: Q1,
        tech_Q3: Q3,
        tech_IQR: IQR,
        tech_mode: mode,
        tech_median: median,
        tech_average: average,
        tech_count: count,
        tech_numbers: numbers,
      };
    } else {
      result.error = "Please enter numbers";
    }

    return result;
  }

  /** getCalculationQuartileCalculator
   * POST: /api/calculators-lol/quartile-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationQuartileCalculator(body) {
    let x = body.tech_x;
    let seprate = body.tech_seprate;

    let result = {};
    let check = true;

    if (!x || typeof x !== "string" || x.trim() === "") {
      check = false;
    }

    if (!seprate || typeof seprate !== "string") {
      seprate = " ";
    }

    let values = x
      .split(seprate)
      .map((v) => v.trim())
      .filter((v) => v !== "")
      .map(Number);

    for (let val of values) {
      if (isNaN(val)) {
        check = false;
        break;
      }
    }

    if (check) {
      if (values.length < 4) {
        return { error: "Please! enter 4 or more numbers" };
      }

      values.sort((a, b) => a - b);

      let count = values.length;
      let a1 = values[0];
      let a2 = values[count - 1];

      function quartil(arr) {
        let c = arr.length;
        let middleval = Math.floor((c - 1) / 2);
        let median;
        if (c % 2 !== 0) {
          median = arr[middleval];
        } else {
          let low = arr[middleval];
          let high = arr[middleval + 1];
          median = (low + high) / 2;
        }
        return Number(median.toFixed(1));
      }

      let second = quartil(values);

      let tmp = { first: [], third: [] };
      for (let val of values) {
        if (val < second) {
          tmp.first.push(val);
        } else if (val > second) {
          tmp.third.push(val);
        }
      }

      let first = quartil(tmp.first);
      let third = quartil(tmp.third);

      let min = Math.min(...values);
      let max = Math.max(...values);
      let iter = third - first;

      let sum = values.reduce((a, b) => a + b, 0);
      let average = +(sum / count).toFixed(4);

      let median;
      if (count % 2 !== 0) {
        median = values[Math.floor(count / 2)];
      } else {
        let center = count / 2;
        median = (values[center] + values[center - 1]) / 2;
      }

      let freqMap = {};
      for (let val of values) {
        freqMap[val] = (freqMap[val] || 0) + 1;
      }

      let maxFreq = Math.max(...Object.values(freqMap));
      let mode = Object.keys(freqMap)
        .filter((key) => freqMap[key] === maxFreq)
        .map(Number);

      let m = +(sum / count).toFixed(3);
      let d = values.reduce((acc, val) => acc + Math.pow(val - m, 2), 0);

      let s_d_p = +Math.sqrt(d / count).toFixed(4);
      let s_d_s = +Math.sqrt(d / (count - 1)).toFixed(4);

      result = {
        tech_a1: a1,
        tech_a2: a2,
        tech_first: first,
        tech_second: second,
        tech_third: third,
        tech_iter: iter,
        tech_mode: mode,
        tech_s_d_p: s_d_p,
        tech_s_d_s: s_d_s,
        tech_median: median,
        tech_average: average,
        tech_count: count,
        tech_numbers: values,
      };
    } else {
      result.error = "Please! Check Your Input";
    }

    return result;
  }
  /** getCalculationGeometricMeanCalculator
   * POST: /api/calculators-lol/geometric-mean-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationGeometricMeanCalculator(body) {
    let x = body.tech_x;
    let seprate = body.tech_seprate;

    let result = {};
    let check = true;

    if (!x || typeof x !== "string" || x.trim() === "") {
      return { error: "Please Enter Your Values" };
    }

    if (!seprate || typeof seprate !== "string") {
      seprate = " ";
    }

    let cleaned_input = x.replace(/[^0-9.\-%]/g, " ");
    let numbers = cleaned_input.trim().split(/\s+/);

    check = true;
    let type = "number";

    for (let value of numbers) {
      let clean_value = value.replace("%", "");
      if (isNaN(clean_value)) {
        check = false;
        break;
      }
      if (value.includes("-") || value.includes("%")) {
        type = "percentage";
      }
    }

    if (check) {
      numbers = numbers.map((val) => (val.includes("%") ? val : Number(val)));
      numbers.sort((a, b) => parseFloat(a) - parseFloat(b));
      let last_index = numbers.length - 1;
      let sol = "(";

      if (type === "number") {
        for (let i = 0; i < numbers.length; i++) {
          sol += ` ${numbers[i]}${i !== last_index ? " x" : " )"}`;
        }

        if (numbers.some((n) => n < 0)) {
          return { error: "Please Check Your Input" };
        }
      } else {
        let sol1 = "( ";
        let pro = 1;
        for (let i = 0; i < numbers.length; i++) {
          let value = parseFloat(numbers[i].toString().replace("%", ""));
          let term = 1 + value / 100;
          pro *= term;
          if (i !== last_index) {
            sol += ` (1 + ${value}/100) x`;
            sol1 += `${term} x `;
          } else {
            sol += ` (1 + ${value}/100) )`;
            sol1 += `${term} )`;
          }
        }
        let geo = +((Math.pow(pro, 1 / numbers.length) - 1) * 100).toFixed(4);

        result.tech_textline = "aa gai value";
        result.tech_sol1 = sol1;
        result.tech_pro = pro;
        result.tech_geo = `${geo}%`;
      }

      // For rest of calculations we convert all to numbers
      let numericValues = numbers.map((n) => parseFloat(n));
      let sum = numericValues.reduce((a, b) => a + b, 0);
      let count = numericValues.length;
      let average = +(sum / count).toFixed(4);

      let median;
      if (count % 2 !== 0) {
        median = numericValues[Math.floor(count / 2)];
      } else {
        let center = count / 2;
        median = (numericValues[center] + numericValues[center - 1]) / 2;
      }

      let d = 1;
      for (let val of numericValues) {
        d *= val;
      }

      let freqMap = {};
      for (let val of numericValues) {
        freqMap[val] = (freqMap[val] || 0) + 1;
      }
      let maxFreq = Math.max(...Object.values(freqMap));
      let mode = Object.keys(freqMap)
        .filter((k) => freqMap[k] === maxFreq)
        .map(Number);

      let m = +(sum / count).toFixed(3);

      result.tech_mode = mode;
      result.tech_sol = sol;
      result.tech_median = median;
      result.tech_average = average;
      result.tech_count = count;
      result.tech_tnumbers = numericValues;
      return result;
    } else {
      return { error: "Please Check Your Input" };
    }
  }

  /** getCalculationHarmonicMeanCalculator
   * POST: /api/calculators-lol/harmonic-mean-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationHarmonicMeanCalculator(body) {
    let x = body.tech_x;
    let seprateby = body.tech_seprateby;
    let seprate = body.tech_seprate;

    let result = {};
    let check = true;

    if (!x || typeof x !== "string" || x.trim() === "") {
      return { error: "Please Enter Your Values" };
    }

    // Determine actual separator
    if (seprateby === "space") {
      seprate = " ";
    } else if (seprateby === ",") {
      seprate = ",";
    } else if (!seprate || typeof seprate !== "string") {
      seprate = " "; // default fallback
    }

    let numbers = x
      .split(seprate)
      .map((v) => v.trim())
      .filter((v) => v !== "");

    for (let value of numbers) {
      if (isNaN(value)) {
        check = false;
        break;
      }
    }

    if (check) {
      numbers = numbers.map(Number);
      numbers.sort((a, b) => a - b);
      let last_index = numbers.length - 1;
      let sol = "(";
      let sol1 = "( ";
      let ans = 0;

      for (let i = 0; i < numbers.length; i++) {
        let value = numbers[i];
        let inv = 1 / value;
        ans += inv;

        if (i !== last_index) {
          sol += ` 1/${value} +`;
          sol1 += `${inv} + `;
        } else {
          sol += ` 1/${value} )`;
          sol1 += `${inv} )`;
        }
      }

      let sum = numbers.reduce((a, b) => a + b, 0);
      let count = numbers.length;
      let harmonicMean = +(count / ans).toFixed(5);
      let average = +(sum / count).toFixed(4);

      let median;
      if (count % 2 !== 0) {
        median = numbers[Math.floor(count / 2)];
      } else {
        let mid = count / 2;
        median = (numbers[mid] + numbers[mid - 1]) / 2;
      }

      let d = 1;
      for (let val of numbers) {
        d *= val;
      }

      let freqMap = {};
      for (let val of numbers) {
        freqMap[val] = (freqMap[val] || 0) + 1;
      }
      let maxFreq = Math.max(...Object.values(freqMap));
      let mode = Object.keys(freqMap)
        .filter((k) => freqMap[k] === maxFreq)
        .map(Number);

      result.tech_mode = mode;
      result.tech_sol = sol;
      result.tech_sol1 = sol1;
      result.tech_ans = harmonicMean;
      result.tech_median = median;
      result.tech_average = average;
      result.tech_count = count;
      result.tech_numbers = numbers;
      return result;
    } else {
      return { error: "Please Check Your Input" };
    }
  }

  /** getCalculationIQRCalculator
   * POST: /api/calculators-lol/interquartile-range-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationIQRCalculator(body) {
    let x = body.tech_x;
    let seprateby = body.tech_seprateby;
    let seprate = body.tech_seprate;

    let result = {};
    let check = true;

    if (!x || typeof x !== "string" || x.trim() === "") {
      return { error: "Please Enter Your Values" };
    }

    // Determine actual separator
    if (seprateby === "space") {
      seprate = " ";
    } else if (seprateby === ",") {
      seprate = ",";
    } else if (!seprate || typeof seprate !== "string") {
      seprate = " ";
    }

    let values = x
      .split(seprate)
      .map((v) => v.trim())
      .filter((v) => v !== "");
    for (let v of values) {
      if (isNaN(v)) {
        check = false;
        break;
      }
    }

    if (!check) {
      return { error: "Please! Check Your Input" };
    }

    values = values.map(Number).sort((a, b) => a - b);
    if (values.length < 4) {
      return { error: "Please! enter 4 or more numbers" };
    }

    const quartil = (arr) => {
      const count = arr.length;
      const mid = Math.floor((count - 1) / 2);
      if (count % 2 === 1) {
        return +arr[mid].toFixed(1);
      } else {
        return +((arr[mid] + arr[mid + 1]) / 2).toFixed(1);
      }
    };

    let count = values.length;
    let a1 = values[0];
    let a2 = values[count - 1];
    let second = quartil(values);

    let lowerHalf = values.filter((v) => v < second);
    let upperHalf = values.filter((v) => v > second);

    let first = quartil(lowerHalf);
    let third = quartil(upperHalf);

    let iter = +(third - first).toFixed(4);
    let sum = values.reduce((a, b) => a + b, 0);
    let average = +(sum / count).toFixed(4);

    let median;
    if (count % 2 !== 0) {
      median = values[Math.floor(count / 2)];
    } else {
      let mid = count / 2;
      median = (values[mid] + values[mid - 1]) / 2;
    }

    let freqMap = {};
    for (let v of values) {
      freqMap[v] = (freqMap[v] || 0) + 1;
    }
    let maxFreq = Math.max(...Object.values(freqMap));
    let mode = Object.keys(freqMap)
      .filter((k) => freqMap[k] === maxFreq)
      .map(Number);

    let mean = +(sum / count).toFixed(3);
    let d = 0;
    for (let v of values) {
      d += Math.pow(v - mean, 2);
    }

    let s_d_p = +Math.sqrt(d / count).toFixed(4);
    let s_d_s = +Math.sqrt(d / (count - 1)).toFixed(4);

    result.tech_a1 = a1;
    result.tech_a2 = a2;
    result.tech_first = first;
    result.tech_second = second;
    result.tech_third = third;
    result.tech_iter = iter;
    result.tech_mode = mode;
    result.tech_s_d_p = s_d_p;
    result.tech_s_d_s = s_d_s;
    result.tech_median = median;
    result.tech_average = average;
    result.tech_count = count;
    result.tech_numbers = values;

    return result;
  }

  /** getCalculationSumOfSquaresCalculator
   * POST: /api/calculators-lol/sum-of-squares-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSumOfSquaresCalculator(body) {
    let x = body.tech_x;
    let seprateby = body.tech_seprateby;
    let seprate = body.tech_seprate;

    let result = {};
    let check = true;

    if (!x || typeof x !== "string" || x.trim() === "") {
      return { error: "Please Enter Your Values" };
    }

    // Determine actual separator
    if (seprateby === "space") {
      seprate = " ";
    } else if (seprateby === ",") {
      seprate = ",";
    } else if (!seprate || typeof seprate !== "string") {
      seprate = " ";
    }

    let numbers = x
      .split(seprate)
      .map((v) => v.trim())
      .filter((v) => v !== "");
    for (let v of numbers) {
      if (isNaN(v)) {
        check = false;
        break;
      }
    }

    if (!check) {
      return { error: "Please! Check Your Input" };
    }

    let ns = numbers.map(Number);
    let n = ns.length;
    let s = ns.reduce((a, b) => a + b, 0) / n;

    let ss = 0,
      su = 0,
      so = 0;
    for (let val of ns) {
      ss += Math.pow(val - s, 2);
      su += Math.pow(val, 2);
      so += val;
    }

    let sns = "",
      snns = "",
      soa = "",
      soas = "";
    ns.forEach((val, index) => {
      let diffSquared = Math.pow(val - s, 2);
      let square = Math.pow(val, 2);

      sns += `(${val} - ${s})<sup>2</sup>`;
      snns += `${diffSquared}`;
      soa += `(${val})<sup>2</sup>`;
      soas += `${square}`;

      if (index !== ns.length - 1) {
        sns += " + ";
        snns += " + ";
        soa += " + ";
        soas += " + ";
      }
    });

    result.tech_soas = soas;
    result.tech_soa = soa;
    result.tech_snns = snns;
    result.tech_sns = sns;
    result.tech_s = s;
    result.tech_so = so;
    result.tech_n = n;
    result.tech_su = su;
    result.tech_ss = ss;

    return result;
  }

  /** getCalculationPoissonDistributionCalculator
   * POST: /api/calculators-lol/poisson-distribution-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPoissonDistributionCalculator(body) {
    let x = body.tech_x;
    let mean = body.tech_mean;
    let con = body.tech_con;

    // Helper functions
    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function factorial(n) {
      if (n < 0) return NaN;
      if (n <= 1) return 1;
      let res = 1;
      for (let i = 2; i <= n; i++) res *= i;
      return res;
    }

    function pow(base, exponent) {
      return Math.pow(base, exponent);
    }

    function exp(value) {
      return Math.exp(value);
    }

    function round(value, decimals) {
      return Number(Math.round(value + "e" + decimals) + "e-" + decimals);
    }

    const result = {
      param: {},
    };

    if (x < 0 || x > 440) {
      result.param.error =
        "This calculator is work with 0 to 440 for variable (x)";
      return result.param;
    }

    if (isNumeric(x) && isNumeric(mean) && isNumeric(con)) {
      let chart = "";
      let sum = "";
      let sumofex, power, expo, ans, factVal;

      if (con === "1") {
        factVal = factorial(x);
        expo = round(exp(-1 * mean), 4);
        power = pow(mean, x);
        sumofex = expo * power;
        ans = (exp(-1 * mean) * pow(mean, x)) / factVal;
        result.param.tech_fact = factVal;
      } else if (con === "2" || con === "5") {
        ans = 0;
        sum = "";
        result.param.tech_details = {};

        for (let i = 0; i < x; i++) {
          factVal = factorial(i);
          if (i == 0) {
            result.param.tech_first = (exp(-1 * mean) * pow(mean, i)) / factVal;
          }
          if (i != x - 1) {
            sum += (exp(-1 * mean) * pow(mean, i)) / factVal + " + <br>";
          } else {
            sum += (exp(-1 * mean) * pow(mean, i)) / factVal;
          }
          ans += (exp(-1 * mean) * pow(mean, i)) / factVal;
        }

        result.param.tech_ans = ans;
        result.param.tech_sum = sum;

        if (con == "2") {
          for (let currentX = 0; currentX < x; currentX++) {
            factVal = factorial(currentX);
            expo = round(exp(-1 * mean), 4);
            power = pow(mean, currentX);
            sumofex = expo * power;

            result.param.tech_details[currentX] = {
              fact: factVal,
              sumofex: sumofex,
              power: power,
              expo: expo,
              value: (exp(-1 * mean) * pow(mean, currentX)) / factVal,
            };
          }
        } else if (con == "5") {
          for (let currentX = 0; currentX <= x - 1; currentX++) {
            factVal = factorial(currentX);
            expo = round(exp(-1 * mean), 4);
            power = pow(mean, currentX);
            sumofex = expo * power;

            result.param.tech_details[currentX] = {
              fact: factVal,
              sumofex: sumofex,
              power: power,
              expo: expo,
              value: (exp(-1 * mean) * pow(mean, currentX)) / factVal,
            };
          }
        }
      } else if (con === "3" || con === "4") {
        ans = 0;
        sum = "";
        result.param.tech_details = {};

        for (let i = 0; i <= x; i++) {
          factVal = factorial(i);
          if (i == 0) {
            result.param.tech_first = (exp(-1 * mean) * pow(mean, i)) / factVal;
          }
          if (i != x) {
            sum += (exp(-1 * mean) * pow(mean, i)) / factVal + " + <br>";
          } else {
            sum += (exp(-1 * mean) * pow(mean, i)) / factVal;
          }
          ans += (exp(-1 * mean) * pow(mean, i)) / factVal;
        }

        result.param.tech_ans = ans;
        result.param.tech_sum = sum;

        if (con == "3") {
          for (let currentX = 0; currentX <= x; currentX++) {
            factVal = factorial(currentX);
            expo = round(exp(-1 * mean), 4);
            power = pow(mean, currentX);
            sumofex = expo * power;
            result.param.tech_details[currentX] = {
              fact: factVal,
              sumofex: sumofex,
              power: power,
              expo: expo,
              value: (exp(-1 * mean) * pow(mean, currentX)) / factVal,
            };
          }
        } else {
          for (let currentX = 0; currentX <= x; currentX++) {
            factVal = factorial(currentX);
            expo = round(exp(-1 * mean), 4);
            power = pow(mean, currentX);
            sumofex = expo * power;
            result.param.tech_details[currentX] = {
              fact: factVal,
              sumofex: sumofex,
              power: power,
              expo: expo,
              value: (exp(-1 * mean) * pow(mean, currentX)) / factVal,
            };
          }
        }

        result.param.tech_fact = factVal;
        result.param.tech_sum = sum;
      }

      for (let i = 0; i <= 15; i++) {
        factVal = factorial(i);
        chart += (exp(-1 * mean) * pow(mean, i)) / factVal + ",";
      }

      result.param.tech_sumofex = sumofex;
      result.param.tech_power = power;
      result.param.tech_expo = expo;
      result.param.tech_ans = ans;
      result.param.tech_chart = chart;
      return result.param;
    } else {
      result.param.error = "Please check your input.";
      return result.param;
    }
  }

  /** getCalculationBinomialDistributionCalculator
   * POST: /api/calculators-lol/binomial-distribution-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationBinomialDistributionCalculator(body) {
    let x = body.tech_x;
    let n = body.tech_n;
    let con = body.tech_con;
    let p = body.tech_p;

    // Helper functions
    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function factorial(num) {
      if (num < 0) return NaN;
      if (num <= 1) return 1;
      let result = 1;
      for (let i = 2; i <= num; i++) {
        result *= i;
      }
      return result;
    }

    const result = {
      param: {},
    };

    // Input validation
    if (n < 0 || n > 440) {
      result.param.error = "This calculator works with 0 to 440 for Trials (n)";
      return result.param;
    }
    if (p < 0 || p > 1) {
      result.param.error = "The probability must be between 0 and 1";
      return result.param;
    }
    if (x > n) {
      result.param.error =
        "The number of successes must be less than or equal to the number of trials";
      return result.param;
    }

    if (isNumeric(x) && isNumeric(n) && isNumeric(con) && isNumeric(p)) {
      let ans = 0;
      let table = [];

      // Helper function to calculate combination
      const combination = (n, k) => {
        return factorial(n) / (factorial(k) * factorial(n - k));
      };

      if (con === "1") {
        // Exactly x successes
        const nf = factorial(n);
        const xf = factorial(x);
        const nxf = factorial(n - x);
        ans = (nf / (xf * nxf)) * Math.pow(p, x) * Math.pow(1 - p, n - x);

        // Generate probability table
        for (let i = 0; i <= n; i++) {
          const ifact = factorial(i);
          const nifact = factorial(n - i);
          table.push(
            (factorial(n) / (ifact * nifact)) *
              Math.pow(p, i) *
              Math.pow(1 - p, n - i)
          );
        }
      } else if (con === "2") {
        // Fewer than x successes (x not included)
        for (let i = 0; i <= n; i++) {
          const prob =
            combination(n, i) * Math.pow(p, i) * Math.pow(1 - p, n - i);
          table.push(prob);
          if (i < x) {
            ans += prob;
          }
        }
      } else if (con === "3") {
        // x or fewer successes (x included)
        for (let i = 0; i <= n; i++) {
          const prob =
            combination(n, i) * Math.pow(p, i) * Math.pow(1 - p, n - i);
          table.push(prob);
          if (i <= x) {
            ans += prob;
          }
        }
      } else if (con === "4") {
        // More than x successes (x not included)
        // First generate full table
        for (let i = 0; i <= n; i++) {
          const prob =
            combination(n, i) * Math.pow(p, i) * Math.pow(1 - p, n - i);
          table.push(prob);
        }
        // Then sum probabilities after x
        for (let i = x + 1; i <= n; i++) {
          ans += table[i];
        }
      } else if (con === "5") {
        // x or more successes (x included)
        // First generate full table
        for (let i = 0; i <= n; i++) {
          const prob =
            combination(n, i) * Math.pow(p, i) * Math.pow(1 - p, n - i);
          table.push(prob);
        }
        // Then sum probabilities from x onward
        for (let i = x; i <= n; i++) {
          ans += table[i];
        }
      }

      result.param.tech_ans = ans;
      result.param.tech_table = table;
      return result.param;
    } else {
      result.param.error = "Please check your input";
      return result.param;
    }
  }

  /** getCalculationInvnormCalculator
   * POST: /api/calculators-lol/invnorm-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationInvnormCalculator(body) {
    let sd = parseFloat(body.tech_sd);
    let mean = parseFloat(body.tech_mean);
    let p = parseFloat(body.tech_p);

    let param = {};

    if (p < 0 || p > 1) {
      param.error = "The probability must be between 0 and 1";
      return param;
    }

    if (isNaN(sd) || isNaN(mean) || isNaN(p)) {
      param.error = "Please check your input.";
      return param;
    }

    function zinv(p) {
      const a1 = -39.6968302866538;
      const a2 = 220.946098424521;
      const a3 = -275.928510446969;
      const a4 = 138.357751867269;
      const a5 = -30.6647980661472;
      const a6 = 2.50662827745924;

      const b1 = -54.4760987982241;
      const b2 = 161.585836858041;
      const b3 = -155.698979859887;
      const b4 = 66.8013118877197;
      const b5 = -13.2806815528857;

      const c1 = -0.00778489400243029;
      const c2 = -0.322396458041136;
      const c3 = -2.40075827716184;
      const c4 = -2.54973253934373;
      const c5 = 4.37466414146497;
      const c6 = 2.93816398269878;

      const d1 = 0.00778469570904146;
      const d2 = 0.32246712907004;
      const d3 = 2.445134137143;
      const d4 = 3.75440866190742;

      const p_low = 0.02425;
      const p_high = 1 - p_low;

      let q, r, retVal;

      if (p < 0 || p > 1) {
        return 0;
      } else if (p < p_low) {
        q = Math.sqrt(-2 * Math.log(p));
        retVal =
          (((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6) /
          ((((d1 * q + d2) * q + d3) * q + d4) * q + 1);
      } else if (p <= p_high) {
        q = p - 0.5;
        r = q * q;
        retVal =
          ((((((a1 * r + a2) * r + a3) * r + a4) * r + a5) * r + a6) * q) /
          (((((b1 * r + b2) * r + b3) * r + b4) * r + b5) * r + 1);
      } else {
        q = Math.sqrt(-2 * Math.log(1 - p));
        retVal =
          -(((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6) /
          ((((d1 * q + d2) * q + d3) * q + d4) * q + 1);
      }

      return retVal;
    }

    // Main calculations
    let x1 = zinv(p);
    let ll = -1 * (-1 * mean + sd * x1);
    let above = Math.round(1000000 * ll) / 1000000;

    x1 = zinv(p);
    let ul = mean + sd * x1;
    let blow = Math.round(1000000 * ul) / 1000000;

    let p2 = p / 2;
    x1 = zinv(0.5 - p2);
    ll = x1;
    ul = -1 * x1;
    ll = Math.round((mean + sd * ll) * 1000000) / 1000000;
    ul = Math.round((mean + sd * ul) * 1000000) / 1000000;

    x1 = zinv(p2);
    let ll1 = x1;
    let ul1 = -1 * x1;
    ll1 = Math.round((mean + sd * ll1) * 1000000) / 1000000;
    ul1 = Math.round((mean + sd * ul1) * 1000000) / 1000000;

    param.tech_above = above;
    param.tech_blow = blow;
    param.tech_ll = ll;
    param.tech_ul = ul;
    param.tech_ll1 = ll1;
    param.tech_ul1 = ul1;

    return param;
  }

  /** getCalculationLinearRegressionCalculator
   * POST: /api/calculators-lol/linear-regression-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLinearRegressionCalculator(body) {
    let x = body.tech_x;
    let y = body.tech_y;
    let estimate = body.tech_estimate;

    x = x.replace(/[\s,\n\r]+/g, ",").replace(/,+/g, ",");
    y = y.replace(/[\s,\n\r]+/g, ",").replace(/,+/g, ",");

    let numbers = x
      .split(",")
      .map((v) => v.trim())
      .filter((v) => v !== "");
    let numbersy = y
      .split(",")
      .map((v) => v.trim())
      .filter((v) => v !== "");

    let check =
      numbers.every((v) => !isNaN(v)) && numbersy.every((v) => !isNaN(v));

    let estimateArr = [];
    let checkEstimate = false;
    if (estimate && estimate.trim() !== "") {
      estimateArr = estimate.split(",").map((v) => v.trim());
      checkEstimate = estimateArr.every((v) => !isNaN(v));
    }

    if (!check) {
      return { error: "Please! Check Your Input" };
    }

    if (numbers.length !== numbersy.length) {
      return { error: "Please! Enter same number of values for X and Y" };
    }

    if (numbers.length > 100) {
      return { error: "This calculator support up to 100 number of values" };
    }

    numbers = numbers.map(Number);
    numbersy = numbersy.map(Number);

    const meanx = numbers.reduce((a, b) => a + b, 0) / numbers.length;
    const meany = numbersy.reduce((a, b) => a + b, 0) / numbersy.length;

    let arr1 = [],
      arr2 = [],
      arr3 = [],
      arr4 = [],
      arr5 = [];

    for (let i = 0; i < numbers.length; i++) {
      let dx = numbers[i] - meanx;
      let dy = numbersy[i] - meany;
      arr1.push(Number(dx.toFixed(5)));
      arr2.push(Number((dx * dx).toFixed(5)));
      arr3.push(Number(dy.toFixed(5)));
      arr4.push(Number((dy * dy).toFixed(5)));
      arr5.push(Number((dx * dy).toFixed(5)));
    }

    const ssx = arr2.reduce((a, b) => a + b, 0);
    const sp = arr5.reduce((a, b) => a + b, 0);
    const b = sp / ssx;
    const a = meany - b * meanx;

    let linex = [],
      liney = [];
    for (let i = 0; i <= Math.max(...numbers) + 1; i += 0.1) {
      linex.push(i);
      liney.push(Number((b * i + a).toFixed(5)));
    }

    let result = {
      tech_a: Number(a.toFixed(5)),
      tech_b: Number(b.toFixed(5)),
      tech_meanx: meanx,
      tech_meany: meany,
      tech_arr1: arr1,
      tech_arr2: arr2,
      tech_arr3: arr3,
      tech_arr5: arr5,
      tech_ssx: ssx,
      tech_sp: sp,
      tech_numbers: numbers,
      tech_numbersy: numbersy,
    };

    if (checkEstimate) {
      result.tech_estimate = estimateArr;
    }

    return result;
  }

  /** getCalculationOutliercalculator
   * POST: /api/calculators-lol/outlier-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationOutliercalculator(body) {
    let x = body.tech_x;

    x = x.replace(/[\s,\n\r]+/g, ",").replace(/,+/g, ",");
    let numbers = x
      .split(",")
      .map((v) => v.trim())
      .filter((v) => v !== "");

    let check = numbers.every((v) => !isNaN(v));
    let values = numbers.map(Number).filter((v) => !isNaN(v));

    if (!check) {
      return { error: "Please! Check Your Input" };
    }

    if (values.length < 4) {
      return { error: "Please! enter 4 or more numbers" };
    }

    values.sort((a, b) => a - b);
    let count = values.length;
    let median;

    if (count % 2 !== 0) {
      let center = Math.floor(count / 2);
      median = values[center];
    } else {
      let center = count / 2;
      median = (values[center - 1] + values[center]) / 2;
    }

    function quartile(arr) {
      let count = arr.length;
      let mid = Math.floor((count - 1) / 2);
      if (count % 2 !== 0) {
        return arr[mid];
      } else {
        return (arr[mid] + arr[mid + 1]) / 2;
      }
    }

    let second = quartile(values);

    let lowerHalf = values.filter((v) => v < second);
    let upperHalf = values.filter((v) => v > second);

    let first = quartile(lowerHalf);
    let third = quartile(upperHalf);

    let inner = third - first;
    let in_f1 = first - 1.5 * inner;
    let in_f2 = third + 1.5 * inner;

    let out_f1 = first - 3 * inner;
    let out_f2 = third + 3 * inner;

    let outlier = values.filter((v) => v < in_f1 || v > in_f2);
    let poutlier = values.filter((v) => v < out_f1 || v > out_f2);

    return {
      tech_values: values,
      tech_first: first,
      tech_third: third,
      tech_inner: inner,
      tech_in_f1: in_f1,
      tech_in_f2: in_f2,
      tech_out_f1: out_f1,
      tech_out_f2: out_f2,
      tech_outlier: outlier,
      tech_poutlier: poutlier,
      tech_median: median,
    };
  }

  /** getCalculationQuadraticRegressioncalculator
   * POST: /api/calculators-lol/quadratic-regression-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationQuadraticRegressioncalculator(body) {
    let x = body.tech_x;
    let y = body.tech_y;

    x = x.replace(/[\s,\n\r]+/g, ",").replace(/,+/g, ",");
    y = y.replace(/[\s,\n\r]+/g, ",").replace(/,+/g, ",");

    let numbersx = x
      .split(",")
      .map((v) => v.trim())
      .filter((v) => v !== "");
    let numbersy = y
      .split(",")
      .map((v) => v.trim())
      .filter((v) => v !== "");

    if (numbersx.length !== numbersy.length) {
      return { error: "Please! Enter same number of values for X and Y" };
    }

    let xvalues = [],
      yvalues = [],
      check = true;

    for (let val of numbersx) {
      if (isNaN(val)) check = false;
      xvalues.push(Number(val));
    }

    for (let val of numbersy) {
      if (isNaN(val)) check = false;
      yvalues.push(Number(val));
    }

    if (!check) {
      return { error: "Please! Check Your Input" };
    }

    let count = xvalues.length;
    let meanx = +(xvalues.reduce((a, b) => a + b, 0) / count).toFixed(3);
    let meany = +(yvalues.reduce((a, b) => a + b, 0) / count).toFixed(3);
    let x2 = xvalues.map((v) => v * v);
    let meanx2 = +(x2.reduce((a, b) => a + b, 0) / count).toFixed(3);

    let Sxx = [],
      Sxy = [],
      Sxx2 = [],
      Sx2x2 = [],
      Sx2y = [];

    for (let i = 0; i < count; i++) {
      let xi = xvalues[i];
      let yi = yvalues[i];
      let xi2 = xi * xi;

      Sxx.push((xi - meanx) * (xi - meanx));
      Sxy.push((xi - meanx) * (yi - meany));
      Sxx2.push((xi - meanx) * (xi2 - meanx2));
      Sx2x2.push((xi2 - meanx2) * (xi2 - meanx2));
      Sx2y.push((xi2 - meanx2) * (yi - meany));
    }

    let sum = (arr) => arr.reduce((a, b) => a + b, 0);
    let denom = sum(Sxx) * sum(Sx2x2) - Math.pow(sum(Sxx2), 2);

    let b = (sum(Sxy) * sum(Sx2x2) - sum(Sx2y) * sum(Sxx2)) / denom;
    let c = (sum(Sx2y) * sum(Sxx) - sum(Sxy) * sum(Sxx2)) / denom;
    let a = meany - b * meanx - c * meanx2;

    let SSE = [],
      SST = [];

    for (let i = 0; i < count; i++) {
      let xi = xvalues[i];
      let yi = yvalues[i];
      let predicted = a + b * xi + c * xi * xi;
      SSE.push((yi - predicted) ** 2);
      SST.push((yi - meany) ** 2);
    }

    let r2 = 1 - sum(SSE) / sum(SST);

    return {
      tech_xvalues: xvalues,
      tech_yvalues: yvalues,
      tech_meanx: meanx,
      tech_meanx2: meanx2,
      tech_meany: meany,
      tech_Sxx: Sxx,
      tech_Sxy: Sxy,
      tech_Sxx2: Sxx2,
      tech_Sx2x2: Sx2x2,
      tech_Sx2y: Sx2y,
      tech_SSE: SSE,
      tech_SST: SST,
      tech_a: a,
      tech_b: b,
      tech_c: c,
      tech_r2: r2,
    };
  }

  /** getCalculationPercentilecalculator
   * POST: /api/calculators-lol/percentile-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPercentilecalculator(body) {
    let p = parseFloat(body.p);
    let x = body.x;
    let separate = body.seprate || " ";
    let advancedcheck = body.advancedcheck || false;

    if (!x || typeof x !== "string") {
      return { error: "Please provide input numbers as a string in 'x'" };
    }

    let numbers = x
      .split(separate)
      .map((item) => item.trim())
      .filter((item) => item !== "" && !isNaN(item))
      .map(Number);
    let check =
      numbers.length > 0 &&
      numbers.every((num) => typeof num === "number" && !isNaN(num));

    if (!check) {
      return { error: "Please check your input." };
    }

    numbers.sort((a, b) => a - b);

    if (numbers.length < 2) {
      return { error: "Please! enter 2 or more numbers" };
    }

    if (p < 0 || p > 100) {
      return { error: "Please! Check Your Percentile percentage" };
    }

    let n = numbers.length;
    let p_per = p / 100;

    // Method 1
    let ab = p_per * n;
    let final_ans11 = Math.ceil(ab);
    let xy = final_ans11 - 1;
    let final_ans1 = numbers[xy];

    // Method 2
    let n_sum_method2 = n - 1;
    let ans_method2 = p_per * n_sum_method2 + 1;
    let final_ans2;
    let ans2_method2, ceil_ans2, floor_ans2, diff2, b2, ans_diff2;

    if (!Number.isInteger(ans_method2)) {
      let decimalPart = ans_method2 % 1;
      ceil_ans2 = Math.ceil(ans_method2) - 1;
      floor_ans2 = Math.floor(ans_method2) - 1;
      diff2 = numbers[ceil_ans2] - numbers[floor_ans2];
      b2 = numbers[floor_ans2];
      ans_diff2 = decimalPart * diff2;
      final_ans2 = b2 + ans_diff2;
      ans2_method2 = decimalPart;
    } else {
      final_ans2 = numbers[ans_method2 - 1];
      ans2_method2 = 0;
    }

    // Method 3
    let n_sum = n + 1;
    let ans = n_sum * p_per;
    let final_ans;
    let ans2, ceil_ans, floor_ans, diff, b, ans_diff;

    if (!Number.isInteger(ans)) {
      let decimalPart = ans % 1;
      ceil_ans = Math.ceil(ans) - 1;
      floor_ans = Math.floor(ans) - 1;
      if (ceil_ans >= n) ceil_ans = n - 1;
      if (floor_ans >= n) floor_ans = n - 1;
      diff = numbers[ceil_ans] - numbers[floor_ans];
      b = numbers[floor_ans];
      ans_diff = decimalPart * diff;
      final_ans = b + ans_diff;
      ans2 = decimalPart;
    } else {
      final_ans = numbers[ans - 1];
      ans2 = 0;
    }

    let final_ans3 = [];

    if (advancedcheck === true) {
      for (let i = 0; i <= 100; i += 5) {
        let p_per3 = i / 100;
        let n_sum_method3 = n - 1;
        let ans_method3 = p_per3 * n_sum_method3 + 1;
        let decimalPart3 = ans_method3 % 1;
        let ceil_ans3 = Math.ceil(ans_method3) - 1;
        let floor_ans3 = Math.floor(ans_method3) - 1;
        let diff3 = numbers[ceil_ans3] - numbers[floor_ans3];
        let b3 = numbers[floor_ans3];
        let ans_diff3 = decimalPart3 * diff3;
        final_ans3.push(b3 + ans_diff3);
      }
    }

    return {
      tech_final_ans: final_ans,
      tech_final_ans2: final_ans2,
      tech_final_ans1: final_ans1,
      tech_p: p,
      tech_n: n,
      tech_b: b,
      tech_ans: ans,
      tech_ans2: ans2,
      tech_n_sum: n_sum,
      tech_p_per: p_per,
      tech_numbers: numbers,
      tech_diff: diff,
      tech_ans_diff: ans_diff,
      tech_n_sum_method2: n_sum_method2,
      tech_ans_method2: ans_method2,
      tech_ans2_method2: ans2_method2,
      tech_ans_diff2: ans_diff2,
      tech_ab: ab,
      tech_final_ans11: final_ans11,
      tech_final_ans3: final_ans3.length ? final_ans3 : undefined,
    };
  }

  /** getCalculationStemAndLeafPlotcalculator
   * POST: /api/calculators-lol/stem-leaf-plot-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationStemAndLeafPlotcalculator(body) {
    let x = body.tech_x;

    if (!x) {
      return { error: "Please check your input." };
    }

    x = x.replace(/[\s,\n\r]+/g, ",");
    while (x.includes(",,")) x = x.replace(",,", ",");

    let numbers = x
      .split(",")
      .map((v) => v.trim())
      .filter((v) => v !== "");
    let values = [...numbers].map(Number).sort((a, b) => a - b);

    if (values.length > 1000) {
      return { error: "You can enter up to 1000 numbers" };
    }

    let newObj = {};
    for (let value of values) {
      if (isNaN(value)) {
        return { error: "Please! Enter Valid Input" };
      }
      if (value > 9999) {
        return {
          error: "Single data points limited to 4 digits. (from 1 to 9999)",
        };
      }

      const strVal = String(value);
      if (strVal.length === 1) {
        if (!newObj[0]) newObj[0] = [];
        newObj[0].push(strVal);
      } else {
        const stem = strVal.slice(0, -1);
        const leaf = strVal.slice(-1);
        if (!newObj[stem]) newObj[stem] = [];
        newObj[stem].push(leaf);
      }
    }

    const min = Math.min(...values);
    const max = Math.max(...values);
    const count = values.length;
    const sum = values.reduce((a, b) => a + b, 0);
    const range = max - min;
    const mean = Number((sum / count).toFixed(5));

    let median;
    if (count % 2 !== 0) {
      const center = Math.floor(count / 2);
      median = values[center];
    } else {
      const mid = count / 2;
      median = (values[mid - 1] + values[mid]) / 2;
    }

    const freqMap = {};
    for (let val of values) {
      freqMap[val] = (freqMap[val] || 0) + 1;
    }

    const maxFreq = Math.max(...Object.values(freqMap));
    const mode = Object.keys(freqMap).filter((k) => freqMap[k] === maxFreq);

    const variance =
      values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) /
      (count - 1);
    const SD = Math.sqrt(variance);

    return {
      tech_new: newObj,
      tech_min: min,
      tech_max: max,
      tech_count: count,
      tech_sum: sum,
      tech_range: range,
      tech_mean: mean,
      tech_median: median,
      tech_mode: mode,
      tech_SD: SD,
      tech_var: variance,
    };
  }

  /** getCalculationShannonDiversityIndexcalculator
   * POST: /api/calculators-lol/shannon-diversity-index-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationShannonDiversityIndexcalculator(body) {
    let x = body.tech_x;
    let seprate = body.tech_seprate;

    if (!x) {
      return { error: "Please! Check Your Input" };
    }

    if (!seprate || seprate === "") {
      seprate = " ";
    }

    let numbers = x
      .split(seprate)
      .map((v) => v.trim())
      .filter((v) => v !== "");
    let allNumeric = numbers.every((val) => !isNaN(val));

    if (!allNumeric) {
      return { error: "Please! Check Your Input" };
    }

    numbers = numbers.map(Number);

    let sum = 0;
    let sum_of_squares = 0;
    let sum3 = 0;
    let sum2 = 0;
    let count_number = numbers.length;
    let array_sum = numbers.reduce((a, b) => a + b, 0);
    let array_sum2 = array_sum * array_sum - 1;
    let maximum = Math.max(...numbers);

    for (let i = 0; i < count_number; i++) {
      sum_of_squares = numbers[i] * (numbers[i] - 1);
      let ratio = numbers[i] / array_sum;
      let take_log = Math.log(ratio);
      let final_log = take_log * ratio;
      sum += final_log;
      sum2 += sum_of_squares;
      let calculate_d = (numbers[i] * numbers[i]) / (array_sum * array_sum);
      sum3 += calculate_d;
    }

    let simpson_index = sum2 / array_sum2;

    return {
      tech_shannon_diversity: sum,
      tech_count_elements: Math.log(count_number),
      tech_hitman: count_number,
      tech_sum: array_sum,
      tech_max: maximum,
      tech_simpson_index: simpson_index,
      tech_sum3: sum3,
    };
  }

  /** getCalculationDegreesOfFreedomcalculator
   * POST: /api/calculators-lol/degrees-of-freedom-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDegreesOfFreedomcalculator(body) {
    let sample_size = body.sample_size;
    let sample_size_one = body.sample_size_one;
    let sample_size_two = body.sample_size_two;
    let variance_one = body.variance_one;
    let variance_two = body.variance_two;
    let c1 = body.c1;
    let r1 = body.r1;
    let k1 = body.k1;
    let d1 = body.d1;
    let d2 = body.d2;
    let selection = body.selection;
    let h = body.h;
    let sample_mean = body.sample_mean;
    let standard_deviation_three = body.standard_deviation_three;

    let param = {};
    let degrees_of_freedom;

    switch (selection) {
      case "1":
        if (
          !isNaN(sample_size) &&
          Number.isInteger(+sample_size) &&
          sample_size > 0
        ) {
          degrees_of_freedom = sample_size - 1;
        } else {
          return { error: "Please! Check Your Input" };
        }
        break;

      case "2":
        if (
          !isNaN(sample_size_one) &&
          !isNaN(sample_size_two) &&
          sample_size_one > 0 &&
          sample_size_two > 0
        ) {
          degrees_of_freedom = sample_size_one + sample_size_two;
          degrees_of_freedom = degrees_of_freedom - 2;
          console.log(degrees_of_freedom);
        } else {
          return { error: "Please! Check Your Input" };
        }
        break;

      case "3":
        if (
          !isNaN(sample_size_one) &&
          !isNaN(sample_size_two) &&
          sample_size_one > 0 &&
          sample_size_two > 0 &&
          !isNaN(variance_one) &&
          !isNaN(variance_two)
        ) {
          d1 = variance_one / sample_size_one + variance_two / sample_size_two;
          let d2_sq = Math.pow(d1, 2);
          let d3 =
            (variance_one * variance_one) /
            (Math.pow(sample_size_one, 2) * (sample_size_one - 1));
          let d4 =
            (variance_two * variance_two) /
            (Math.pow(sample_size_two, 2) * (sample_size_two - 1));
          degrees_of_freedom = d2_sq / (d3 + d4);
          param.tech_v1 = Math.sqrt(variance_one);
          param.tech_v2 = Math.sqrt(variance_two);
        } else {
          return { error: "Please! Check Your Input" };
        }
        break;

      case "4": // Chi-square
        if (!isNaN(r1) && !isNaN(c1) && r1 > 0 && c1 > 0) {
          degrees_of_freedom = (r1 - 1) * (c1 - 1);
          param.tech_degrees_of_freedom = degrees_of_freedom;
          return param;
        } else {
          return { error: "Please! Check Your Input" };
        }

      case "5":
        if (!isNaN(sample_size) && !isNaN(k1) && k1 > 0 && sample_size > 0) {
          let d3 = k1 - 1;
          let d2 = sample_size - k1;
          degrees_of_freedom = sample_size - 1;
          param.tech_d2 = d2;
          param.tech_d3 = d3;
        } else {
          return { error: "Please! Check Your Input" };
        }
        break;

      case "6":
        if (
          !isNaN(sample_size) &&
          !isNaN(h) &&
          !isNaN(sample_mean) &&
          !isNaN(standard_deviation_three) &&
          sample_size > 0 &&
          standard_deviation_three > 0
        ) {
          let t_statistic =
            (sample_mean - h) /
            (standard_deviation_three / Math.sqrt(sample_size));
          param.tech_t_statistic = t_statistic;
          degrees_of_freedom = sample_size - 1;
        } else {
          return { error: "Please! Check Your Input" };
        }
        break;

      default:
        return { error: "Invalid selection value" };
    }

    param.tech_degrees_of_freedom = degrees_of_freedom;
    return param;
  }

  /** getCalculationMidrangecalculator
   * POST: /api/calculators-lol/midrange-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMidrangecalculator(body) {
    let x = body.tech_x;

    if (!x || typeof x !== "string") {
      return { error: "Please! Check Your Input" };
    }
    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }
    // Normalize input string
    x = x.replace(/[\s,\n\r]+/g, ",");
    while (x.includes(",,")) {
      x = x.replace(/,,/g, ",");
    }

    let numbers = x
      .split(",")
      .map((str) => str.trim())
      .filter((str) => str !== "");

    for (let val of numbers) {
      if (!isNumeric(val)) {
        return { error: "Please! Check Your Input" };
      }
    }

    let values = numbers.map(Number);
    values.sort((a, b) => a - b);

    let min = Math.min(...values);
    let max = Math.max(...values);
    let count = values.length;
    let sum = values.reduce((acc, cur) => acc + cur, 0);
    let range = max - min;
    let mean = parseFloat((sum / count).toFixed(5));

    let median;
    if (count % 2 !== 0) {
      median = values[Math.floor(count / 2)];
    } else {
      median = (values[count / 2 - 1] + values[count / 2]) / 2;
    }

    // Mode
    let freq = {};
    let mode = [];
    let maxFreq = 0;

    for (let val of values) {
      freq[val] = (freq[val] || 0) + 1;
      if (freq[val] > maxFreq) {
        maxFreq = freq[val];
      }
    }

    for (let key in freq) {
      if (freq[key] === maxFreq) {
        mode.push(Number(key));
      }
    }

    // Variance and Standard Deviation
    let variance =
      values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) /
      (count - 1);
    let SD = Math.sqrt(variance);
    let ans = (min + max) / 2;

    return {
      tech_ans: ans,
      tech_min: min,
      tech_max: max,
      tech_count: count,
      tech_sum: sum,
      tech_range: range,
      tech_mean: mean,
      tech_median: median,
      tech_mode: mode,
      tech_SD: SD,
      tech_var: variance,
    };
  }

  /** getCalculationRSDcalculator
   * POST: /api/calculators-lol/rsd-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRSDcalculator(body) {
    let x = body.tech_x;
    let form = body.tech_form;
    let mean = body.tech_mean;
    let deviation = body.tech_deviation;
    // Helper function
    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }

    if (form === "raw") {
      if (!x || typeof x !== "string") {
        return { error: "Please! Check Your Input" };
      }

      // Normalize input
      x = x.replace(/[\s,\n\r]+/g, ",");
      while (x.includes(",,")) {
        x = x.replace(/,,/g, ",");
      }

      let numbers = x
        .split(",")
        .map((str) => str.trim())
        .filter((str) => str !== "");

      for (let val of numbers) {
        if (!isNumeric(val)) {
          return { error: "Please! Check Your Input" };
        }
      }

      let values = numbers.map(Number).sort((a, b) => a - b);
      let min = Math.min(...values);
      let max = Math.max(...values);
      let count = values.length;
      let sum = values.reduce((a, b) => a + b, 0);
      let range = max - min;
      mean = parseFloat((sum / count).toFixed(5));

      let median;
      if (count % 2 !== 0) {
        median = values[Math.floor(count / 2)];
      } else {
        median = (values[count / 2 - 1] + values[count / 2]) / 2;
      }

      // Mode
      let freq = {};
      let mode = [];
      let maxFreq = 0;

      for (let val of values) {
        freq[val] = (freq[val] || 0) + 1;
        if (freq[val] > maxFreq) {
          maxFreq = freq[val];
        }
      }

      for (let key in freq) {
        if (freq[key] === maxFreq) {
          mode.push(Number(key));
        }
      }

      // Standard deviation, variance
      let d = values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0);
      let s_d = d / (count - 1);
      let psd = d / count;
      let SD = Math.sqrt(s_d);
      let PSD = Math.sqrt(psd);
      let rsd = (SD / mean) * 100;

      return {
        tech_rsd: rsd,
        tech_min: min,
        tech_max: max,
        tech_count: count,
        tech_sum: sum,
        tech_range: range,
        tech_mean: mean,
        tech_median: median,
        tech_mode: mode,
        tech_SD: SD,
        tech_PSD: PSD,
        tech_svar: s_d,
        tech_pvar: psd,
        tech_form: form,
      };
    } else {
      if (isNumeric(mean) && isNumeric(deviation)) {
        let rsd = (deviation / mean) * 100;
        return {
          tech_rsd: rsd,
          tech_form: form,
        };
      } else {
        return { error: "Please! Check Your Input" };
      }
    }
  }
  /** getCalculationChebyshevTheoremcalculator
   * POST: /api/calculators-lol/chebyshevs-theorem-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationChebyshevTheoremcalculator(body) {
    let operations = body.tech_operations;
    let first = body.tech_first;
    let second = body.tech_second;

    let result = {};
    let pehla, final_fans, final_sans;

    if (operations === 3) {
      if (first > 1) {
        if (second > 1) {
          let sq = Math.pow(first, 2);
          let f_ans = second / sq;
          final_fans = f_ans.toFixed(3);
          let s_ans = f_ans * 100;
          final_sans = s_ans >= 100 ? "100" : s_ans.toFixed(2);
          pehla = first;
        } else {
          return { error: "Please variance enter greater than 1" };
        }
      } else {
        return { error: "Please bound enter greater than 1." };
      }
    } else if (operations === 4) {
      if (first > 1) {
        if (second > 1) {
          let sq = Math.pow(first, 2);
          let f_ans = first * 4;
          let aja = 1 / sq;
          final_fans = aja.toFixed(3);
          let s_ans = aja * 100;
          final_sans = s_ans >= 100 ? "100" : s_ans.toFixed(2);
          pehla = f_ans;
        } else {
          return { error: "Please variance enter greater than 1" };
        }
      } else {
        return { error: "Please bound enter greater than 1." };
      }
    } else if (operations === 5) {
      if (first > 1) {
        pehla = Math.pow(first, 2);
        let aja = 1 / pehla;
        final_fans = aja.toFixed(3);
        final_sans = (1 - aja).toFixed(3);
      } else {
        return { error: "Please bound enter greater than 1." };
      }
    } else if (operations === 6) {
      if (first > 1) {
        pehla = 1 - first;
        let aja = 1 / pehla;
        final_fans = aja.toFixed(3);
        final_sans = aja >= 0 ? Math.sqrt(aja).toFixed(3) : "NaN";
      } else {
        return { error: "Please bound enter greater than 1." };
      }
    } else {
      return { error: "Invalid operation code" };
    }

    result.tech_operations = operations;
    result.tech_pehla = pehla;
    result.tech_final_fans = final_fans;
    result.tech_final_sans = final_sans;

    return result;
  }

  /** getCalculationBoxPlotcalculator
   * POST: /api/calculators-lol/box-plot-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationBoxPlotcalculator(body) {
    let x = body.tech_x;
    let seprate = body.tech_seprate;

    function quartil(arr) {
      let count = arr.length;
      let middleval = Math.floor((count - 1) / 2);
      let median;
      if (count % 2) {
        median = arr[middleval];
      } else {
        let low = arr[middleval];
        let high = arr[middleval + 1];
        median = (low + high) / 2;
      }
      return parseFloat(median.toFixed(1));
    }

    if (!x || x.trim() === "") {
      return { error: "Please! Check Your Input" };
    }

    if (!seprate) {
      seprate = " ";
    }

    let check = true;
    x = x.replace(/[\s,\n\r]+/g, ",");
    while (x.includes(",,")) x = x.replace(/,,/g, ",");

    let numbers = x
      .split(",")
      .map((s) => s.trim())
      .filter((s) => s !== "");
    for (let value of numbers) {
      if (isNaN(value)) {
        check = false;
      }
    }

    if (!check) {
      return { error: "Please! Check Your Input" };
    }

    numbers = numbers.map(Number).sort((a, b) => a - b);

    if (numbers.length < 2) {
      return { error: "Please! enter 2 or more numbers" };
    }

    let maximum = Math.max(...numbers);
    let minimum = Math.min(...numbers);
    let second = quartil(numbers);

    let tmp = { first: [], third: [] };
    for (let val of numbers) {
      if (val > second) {
        tmp.third.push(val);
      } else if (val < second) {
        tmp.first.push(val);
      }
    }

    let first = quartil(tmp.first);
    let third = quartil(tmp.third);

    let count = numbers.length;
    let median;
    if (count % 2 !== 0) {
      let center = Math.floor(count / 2);
      median = numbers[center];
    } else {
      let center = count / 2;
      median = (numbers[center] + numbers[center - 1]) / 2;
    }

    return {
      tech_numbers: numbers,
      tech_count: count,
      tech_first: first,
      tech_third: third,
      tech_median: median,
      tech_maximum: maximum,
    };
  }

  /** getCalculationCoinFlipcalculator
   * POST: /api/calculators-lol/coin-flip-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCoinFlipcalculator(body) {
    let flips = Number(body.tech_flips);
    let heads = Number(body.tech_heads);
    let probablity = Number(body.tech_probablity);
    let type = body.tech_type;

    function factorial(num) {
      let result = 1;
      for (let i = num; i >= 1; i--) {
        result *= i;
      }
      return result;
    }

    function total_calculation(flips, heads, prob2) {
      let sub = flips - heads;
      let f4 = factorial(flips);
      let f5 = factorial(heads);
      let f6 = factorial(sub);
      let power = Math.pow(prob2, heads);
      let power2 = Math.pow(1 - prob2, sub);
      return (f4 / (f5 * f6)) * power * power2;
    }

    if (
      !["1", "2", "3"].includes(type) ||
      isNaN(flips) ||
      isNaN(heads) ||
      isNaN(probablity)
    ) {
      return { error: "Please! Check Your Input" };
    }

    if (flips < heads) {
      return {
        error:
          "The number of obtained heads cannot be greater than the number of tosses.",
      };
    }

    if (
      (type === "1" && (flips <= 0 || heads <= 0)) ||
      (type !== "1" && (flips < 0 || heads < 0))
    ) {
      return { error: "Enter Value Greater than zero" };
    }

    if (probablity < 0 || probablity > 1) {
      return { error: "Probablity must be between 0 and 1 inclusive" };
    }

    let sub = flips - heads;
    let f1 = factorial(flips);
    let f2 = factorial(heads);
    let f3 = factorial(sub);
    let powerP = Math.pow(probablity, heads);
    let powerP2 = Math.pow(1 - probablity, sub);
    let ans = (f1 / (f2 * f3)) * powerP * powerP2;

    let param = {
      tech_type: type,
      tech_flips: flips,
      tech_heads: heads,
      tech_probablity: probablity,
      tech_ans: ans,
    };

    if (type === "2") {
      let awa = [];
      for (let i = heads + 1; i <= flips; i++) {
        awa.push(total_calculation(flips, i, probablity));
      }
      param.tech_array_awa = awa;
      param.tech_summer = awa.reduce((a, b) => a + b, 0);
    }

    if (type === "3") {
      let awa = [];
      for (let i = 0; i <= heads; i++) {
        awa.push(total_calculation(flips, i, probablity));
      }
      param.tech_array_awa = awa;
      param.tech_summer = awa.reduce((a, b) => a + b, 0);
    }

    return param;
  }

  /** getCalculationPercentileRankcalculator
   * POST: /api/calculators-lol/percentile-rank-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPercentileRankcalculator(body) {
    let x = body.tech_x;
    let find = Number(body.tech_find);
    let method = Number(body.tech_method);

    if (x && !isNaN(find)) {
      // Clean and normalize input string
      x = x.replace(/[\s,\n\r]+/g, ",");
      while (x.includes(",,")) {
        x = x.replace(/,,/g, ",");
      }

      // Parse numbers
      let numbers = x
        .split(",")
        .map((item) => item.trim())
        .filter((item) => item !== "");
      let values = [];
      let isNum = true;

      for (let i = 0; i < numbers.length; i++) {
        if (!isNaN(numbers[i])) {
          values.push(Number(numbers[i]));
        } else {
          isNum = false;
          break;
        }
      }

      if (isNum) {
        values.sort((a, b) => a - b);
        let count = 0;
        let same = 0;

        for (let i = 0; i < values.length; i++) {
          if (values[i] <= find) count++;
          if (values[i] === find) same++;
        }

        let pr;
        if (method === 1) {
          pr = (count / values.length) * 100;
        } else {
          pr = ((count - 0.5 * same) / values.length) * 100;
        }

        return {
          tech_pr: pr,
          tech_same: same,
          tech_count: count,
          tech_find: find,
          tech_values: values,
        };
      } else {
        return { error: "Please! Enter only numbers" };
      }
    } else {
      return { error: "Please! Check Your Input" };
    }
  }

  /** getCalculationSSEcalculator
   * POST: /api/calculators-lol/sse-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSSEcalculator(body) {
    let x = body.tech_x;
    let y = body.tech_y;

    function sigFig(value, digits) {
      if (value === "") return null;
      if (value === 0) {
        return 0;
      }
      const decimalPlaces =
        digits - Math.floor(Math.log10(Math.abs(value))) - 1;
      return parseFloat(value.toFixed(decimalPlaces));
    }

    if (!x || !y) {
      return { error: "Please! Check Your Input" };
    }

    x = x
      .split(",")
      .map((val) => val.trim())
      .filter((val) => val !== "");
    y = y
      .split(",")
      .map((val) => val.trim())
      .filter((val) => val !== "");
    const n = x.length;

    if (n !== y.length) {
      return {
        error:
          "The number of values should be same in both sample data inputs.",
      };
    }

    let check = true;
    x = x.map((val, i) => {
      if (isNaN(val) || isNaN(y[i])) {
        check = false;
      }
      return Number(val);
    });
    y = y.map(Number);

    if (!check) {
      return { error: "Please! Check Your Input" };
    }

    let xi_sum = 0;
    let yi_sum = 0;
    let xy_sum = 0;

    for (let i = 0; i < n; i++) {
      xi_sum += x[i] ** 2;
      yi_sum += y[i] ** 2;
      xy_sum += x[i] * y[i];
    }

    const x_sum = x.reduce((a, b) => a + b, 0);
    const y_sum = y.reduce((a, b) => a + b, 0);

    const ss_xx = xi_sum - x_sum ** 2 / n;
    const ss_yy = yi_sum - y_sum ** 2 / n;
    const ss_xy = xy_sum - (x_sum * y_sum) / n;
    const beta_1 = ss_xy / ss_xx;
    const beta_0 = y_sum / n - beta_1 * (x_sum / n);
    const ss_r = beta_1 * ss_xy;
    const ss_e = ss_yy - ss_r;

    return {
      tech_x: x,
      tech_y: y,
      tech_n: n,
      tech_x_sum: x_sum,
      tech_xi_sum: xi_sum,
      tech_y_sum: y_sum,
      tech_yi_sum: yi_sum,
      tech_xy_sum: xy_sum,
      tech_ss_xx: ss_xx,
      tech_ss_yy: ss_yy,
      tech_ss_xy: ss_xy,
      tech_beta_1: beta_1,
      tech_beta_0: beta_0,
      tech_ss_r: ss_r,
      tech_ss_e: sigFig(ss_e, 5),
    };
  }

  /** getCalculationPredictionIntervalcalculator
   * POST: /api/calculators-lol/prediction-interval-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPredictionIntervalcalculator(body) {
    let x = body.tech_x;
    let y = body.tech_y;
    let confidence = parseFloat(body.tech_confidence);
    let prediction = parseFloat(body.tech_prediction);

    let number = true;
    let equal = false;
    let array_num = 0;
    let x_sqr = [];
    let y_sqr = [];
    let x_sqr_sum = 0;
    let y_sqr_sum = 0;
    let x_mul_y = [];
    let xy_sum = 0;
    let x_sum = 0;
    let y_sum = 0;

    x = x.replace(/[\s,\n\r]+/g, ",");
    y = y.replace(/[\s,\n\r]+/g, ",");

    let array_x = x
      .split(",")
      .map((val) => val.trim())
      .filter((val) => val !== "");
    let array_y = y
      .split(",")
      .map((val) => val.trim())
      .filter((val) => val !== "");

    let level = 1 - confidence;
    let confidence_per = (confidence * 100).toFixed(0) + "%";

    array_x.forEach((val) => {
      if (isNaN(val)) number = false;
    });
    array_y.forEach((val) => {
      if (isNaN(val)) number = false;
    });

    if (array_x.length === array_y.length) {
      equal = true;
    }

    if (number && equal && !isNaN(confidence) && !isNaN(prediction)) {
      array_x = array_x.map(Number);
      array_y = array_y.map(Number);
      array_num = array_x.length;
      x_sum = array_x.reduce((a, b) => a + b, 0);
      y_sum = array_y.reduce((a, b) => a + b, 0);

      x_sqr = array_x.map((n) => n ** 2);
      y_sqr = array_y.map((n) => n ** 2);

      x_sqr_sum = x_sqr.reduce((a, b) => a + b, 0);
      y_sqr_sum = y_sqr.reduce((a, b) => a + b, 0);

      for (let i = 0; i < array_num; i++) {
        x_mul_y[i] = array_x[i] * array_y[i];
      }

      xy_sum = x_mul_y.reduce((a, b) => a + b, 0);

      let ssxx = parseFloat(
        (x_sqr_sum - (1 / array_num) * x_sum ** 2).toFixed(4)
      );
      let ssyy = parseFloat(
        (y_sqr_sum - (1 / array_num) * y_sum ** 2).toFixed(4)
      );
      let ssxy = parseFloat(
        (xy_sum - (1 / array_num) * x_sum * y_sum).toFixed(4)
      );

      let mean_x = parseFloat((x_sum / array_num).toFixed(4));
      let mean_y = parseFloat((y_sum / array_num).toFixed(4));

      let b1 = parseFloat((ssxy / ssxx).toFixed(4));
      let b0 = parseFloat((mean_y - b1 * mean_x).toFixed(4));
      let Y = parseFloat((b0 + b1 * prediction).toFixed(4));

      let ssRegression = parseFloat((b1 * ssxy).toFixed(4));
      let ssError = parseFloat((ssyy - ssRegression).toFixed(4));
      let mse = parseFloat((ssError / (array_num - 2)).toFixed(4));
      let errorEst = parseFloat(Math.sqrt(mse).toFixed(4));

      let E = parseFloat(
        (
          2.16 *
          Math.sqrt(
            mse * (1 + 1 / array_num + (prediction - mean_x) ** 2 / ssxx)
          )
        ).toFixed(4)
      );

      let piPov = Y - E;
      let piNeg = Y + E;

      return {
        tech_confidence_per: confidence_per,
        tech_level: level,
        tech_prediction: prediction,
        tech_array_num: array_num,
        tech_array_x: array_x,
        tech_array_y: array_y,
        tech_x_sum: x_sum,
        tech_y_sum: y_sum,
        tech_x_sqr: x_sqr,
        tech_y_sqr: y_sqr,
        tech_x_sqr_sum: x_sqr_sum,
        tech_y_sqr_sum: y_sqr_sum,
        tech_x_mul_y: x_mul_y,
        tech_xy_sum: xy_sum,
        tech_ssxx: ssxx,
        tech_ssyy: ssyy,
        tech_ssxy: ssxy,
        tech_mean_x: mean_x,
        tech_mean_y: mean_y,
        tech_b1: b1,
        tech_b0: b0,
        tech_Y: Y,
        tech_ssRegression: ssRegression,
        tech_ssError: ssError,
        tech_mse: mse,
        tech_errorEst: errorEst,
        tech_E: E,
        tech_piPov: piPov,
        tech_piNeg: piNeg,
      };
    } else {
      return { error: "Please! Check Your Input" };
    }
  }

  /** getCalculationScatterPlotMakercalculator
   * POST: /api/calculators-lol/scatter-plot-maker
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationScatterPlotMakercalculator(body) {
    let x = body.tech_x;
    let y = body.tech_y;
    let title = body.tech_title;
    let xaxis = body.tech_xaxis;
    let yaxis = body.tech_yaxis;
    let xmin = body.tech_xmin;
    let xmax = body.tech_xmax;
    let ymin = body.tech_ymin;
    let ymax = body.tech_ymax;
    let position = body.tech_position;
    let align = body.tech_align;

    if ((!x || x.trim() === "") && (!y || y.trim() === "")) {
      return { error: "Please! Check Your Input" };
    }

    x = x.replace(/[\s,\n\r]+/g, ",");
    y = y.replace(/[\s,\n\r]+/g, ",");

    let xArr = x
      .split(",")
      .map((val) => val.trim())
      .filter((val) => val !== "");
    let yArr = y
      .split(",")
      .map((val) => val.trim())
      .filter((val) => val !== "");

    let n = xArr.length;
    if (n !== yArr.length) {
      return {
        error:
          "The number of values should be same in both sample data inputs.",
      };
    }

    let check = true;
    for (let i = 0; i < n; i++) {
      if (isNaN(xArr[i]) || isNaN(yArr[i])) {
        check = false;
      }
    }

    if (!check) {
      return { error: "Invalid numeric values in x or y array." };
    }

    if (!title || title.trim() === "") title = "Scatter Plot";
    if (!xaxis || xaxis.trim() === "") xaxis = "X";
    if (!yaxis || yaxis.trim() === "") yaxis = "Y";

    return {
      tech_x: xArr.map(Number),
      tech_y: yArr.map(Number),
      tech_title: title,
      tech_xaxis: xaxis,
      tech_yaxis: yaxis,
      tech_xmin: xmin,
      tech_xmax: xmax,
      tech_ymin: ymin,
      tech_ymax: ymax,
      tech_position: position,
      tech_align: align,
    };
  }

  /** getCalculationResidualcalculator
   * POST: /api/calculators-lol/residual-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationResidualcalculator(body) {
    let x = body.tech_x;
    let y = body.tech_y;

    if ((!x || x.trim() === "") && (!y || y.trim() === "")) {
      return { error: "Please! Check Your Input" };
    }

    let xArr = x
      .split(",")
      .map((val) => val.trim())
      .filter((val) => val !== "");
    let yArr = y
      .split(",")
      .map((val) => val.trim())
      .filter((val) => val !== "");

    let n = xArr.length;
    if (n !== yArr.length) {
      return {
        error: "The number of values should be same in both data inputs.",
      };
    }

    let check = true;
    for (let i = 0; i < n; i++) {
      if (isNaN(xArr[i]) || isNaN(yArr[i])) {
        check = false;
        break;
      }
    }

    if (!check) {
      return { error: "Please! Check Your Input" };
    }

    xArr = xArr.map(Number);
    yArr = yArr.map(Number);

    let xi_sum = 0,
      yi_sum = 0,
      xy_sum = 0;
    let y_bar = [],
      yy_bar = [];

    for (let i = 0; i < n; i++) {
      xi_sum += xArr[i] ** 2;
      yi_sum += yArr[i] ** 2;
      xy_sum += xArr[i] * yArr[i];
    }

    let x_sum = xArr.reduce((a, b) => a + b, 0);
    let y_sum = yArr.reduce((a, b) => a + b, 0);

    let ss_xx = xi_sum - x_sum ** 2 / n;
    let ss_yy = yi_sum - y_sum ** 2 / n;
    let ss_xy = xy_sum - (x_sum * y_sum) / n;

    let beta_1 = ss_xy / ss_xx;
    let beta_0 = y_sum / n - beta_1 * (x_sum / n);

    for (let i = 0; i < n; i++) {
      let predicted = beta_0 + beta_1 * xArr[i];
      y_bar.push(predicted);
      yy_bar.push(yArr[i] - predicted);
    }

    return {
      tech_x: xArr,
      tech_y: yArr,
      tech_n: n,
      tech_x_sum: x_sum,
      tech_xi_sum: xi_sum,
      tech_y_sum: y_sum,
      tech_yi_sum: yi_sum,
      tech_xy_sum: xy_sum,
      tech_ss_xx: ss_xx,
      tech_ss_yy: ss_yy,
      tech_ss_xy: ss_xy,
      tech_beta_1: beta_1,
      tech_beta_0: beta_0,
      tech_y_bar: y_bar,
      tech_yy_bar: yy_bar,
    };
  }

  /** getCalculationResidualPlotcalculator
   * POST: /api/calculators-lol/residual-plot-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationResidualPlotcalculator(body) {
    let x = body.tech_x;
    let y = body.tech_y;

    if (!x || !y) {
      return { error: "Please! Check Your Input" };
    }

    let xArr = x
      .split(",")
      .map((val) => val.trim())
      .filter((val) => val !== "");
    let yArr = y
      .split(",")
      .map((val) => val.trim())
      .filter((val) => val !== "");

    let n = xArr.length;
    if (n !== yArr.length) {
      return {
        error: "The number of values should be same in both data inputs.",
      };
    }

    let check = true;
    for (let i = 0; i < n; i++) {
      if (isNaN(xArr[i]) || isNaN(yArr[i])) {
        check = false;
        break;
      }
    }

    if (!check) {
      return { error: "Please! Check Your Input" };
    }

    // Convert strings to numbers
    let xNums = xArr.map(Number);
    let yNums = yArr.map(Number);

    let xi_sum = 0;
    let yi_sum = 0;
    let xy_sum = 0;

    for (let i = 0; i < n; i++) {
      xi_sum += xNums[i] ** 2;
      yi_sum += yNums[i] ** 2;
      xy_sum += xNums[i] * yNums[i];
    }

    let x_sum = xNums.reduce((a, b) => a + b, 0);
    let y_sum = yNums.reduce((a, b) => a + b, 0);

    let ss_xx = xi_sum - x_sum ** 2 / n;
    let ss_yy = yi_sum - y_sum ** 2 / n;
    let ss_xy = xy_sum - (x_sum * y_sum) / n;

    let beta_1 = ss_xy / ss_xx;
    let beta_0 = y_sum / n - beta_1 * (x_sum / n);

    let y_bar = [];
    let yy_bar = [];

    for (let i = 0; i < n; i++) {
      let predicted = beta_0 + beta_1 * xNums[i];
      y_bar.push(predicted);
      yy_bar.push(yNums[i] - predicted);
    }

    return {
      tech_x: xNums,
      tech_y: yNums,
      tech_n: n,
      tech_x_sum: x_sum,
      tech_y_sum: y_sum,
      tech_xi_sum: xi_sum,
      tech_yi_sum: yi_sum,
      tech_xy_sum: xy_sum,
      tech_ss_xx: ss_xx,
      tech_ss_yy: ss_yy,
      tech_ss_xy: ss_xy,
      tech_beta_0: beta_0,
      tech_beta_1: beta_1,
      tech_y_bar: y_bar,
      tech_yy_bar: yy_bar,
    };
  }

  /** getCalculationErrorPropagationcalculator
   * POST: /api/calculators-lol/error-propagation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationErrorPropagationcalculator(body) {
    let x = parseFloat(body.tech_x);
    let y = parseFloat(body.tech_y);
    let delta_x = parseFloat(body.tech_delta_x);
    let delta_y = parseFloat(body.tech_delta_y);
    let optionSelect = body.tech_optionSelect;

    if (isNaN(x) || isNaN(y)) {
      return { error: "Please! Check Your Input" };
    }

    let z, delta_z;

    if (optionSelect) {
      if (optionSelect === "addition") {
        z = x + y;
        delta_z = Math.sqrt(Math.pow(delta_x, 2) + Math.pow(delta_y, 2));
      } else if (optionSelect === "subtraction") {
        z = x - y;
        delta_z = Math.sqrt(Math.pow(delta_x, 2) + Math.pow(delta_y, 2));
      } else if (optionSelect === "multiplication") {
        z = x * y;
        delta_z =
          z * Math.sqrt(Math.pow(delta_x / x, 2) + Math.pow(delta_y / y, 2));
      } else if (optionSelect === "division") {
        z = x / y;
        delta_z =
          z * Math.sqrt(Math.pow(delta_x / x, 2) + Math.pow(delta_y / y, 2));
      } else {
        return { error: "Invalid operation type" };
      }
    } else {
      return { error: "Option select is required" };
    }

    return {
      tech_z: z,
      tech_delta_z: delta_z,
    };
  }

  /** getCalculationPieChartcalculator
   * POST: /api/calculators-lol/pie-chart-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPieChartcalculator(body) {
    let choices = body.tech_choices;

    if (!Array.isArray(choices) || choices.length === 0 || isNaN(choices[0])) {
      return { error: "Please! Check Your Input" };
    }

    // Sum of all values
    let sum = choices.reduce((acc, val) => acc + Number(val), 0);

    // Percentages
    let percentage = choices.map((value) => {
      return Math.round((value / sum) * 100 * 100) / 100;
    });

    // Angles in degrees
    let degree = percentage.map((per) => {
      return Math.round((per / 100) * 360);
    });

    // Letters (A, B, C, ...)
    let letters = [];
    for (let i = 0; i < choices.length; i++) {
      letters.push(String.fromCharCode(65 + i));
    }

    // Combine data for charting
    let dataPoints = choices.map((val, i) => ({
      y: val,
      label: letters[i],
    }));

    return {
      tech_letters: letters,
      tech_values: choices,
      tech_percentage: percentage,
      tech_degree: degree,
      tech_new_combine: JSON.stringify(dataPoints),
    };
  }

  /** getCalculationAccuracycalculator
   * POST: /api/calculators-lol/accuracy-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAccuracycalculator(body) {
    let true_positive = body.tech_true_positive?.trim();
    let false_negative = body.tech_false_negative?.trim();
    let false_positive = body.tech_false_positive?.trim();
    let true_negative = body.tech_true_negative?.trim();
    let prevalence = body.tech_prevalence?.trim();
    let sensitivity = body.tech_sensitivity?.trim();
    let specificity = body.tech_specificity?.trim();
    let observed_value = body.tech_observed_value?.trim();
    let accepted_value = body.tech_accepted_value?.trim();
    let method_unit = body.tech_method_unit?.trim();

    // Utility to check numeric
    function isNumeric(val) {
      return !isNaN(parseFloat(val)) && isFinite(val);
    }

    let answer;

    if (method_unit === "Standard method") {
      if (
        isNumeric(true_positive) &&
        isNumeric(false_negative) &&
        isNumeric(false_positive) &&
        isNumeric(true_negative)
      ) {
        let accu_add_sec = Number(true_positive) + Number(true_negative);
        let accu_add_all =
          accu_add_sec + Number(false_positive) + Number(false_negative);
        let accu_div = accu_add_sec / accu_add_all;
        answer = accu_div * 100;
      } else {
        return { error: "Please! Check Your Input" };
      }
    } else if (method_unit === "Prevalence method") {
      if (
        isNumeric(prevalence) &&
        isNumeric(sensitivity) &&
        isNumeric(specificity)
      ) {
        prevalence = Number(prevalence) / 100;
        let accu_se_pre =
          Number(sensitivity) * prevalence +
          Number(specificity) * (1 - prevalence);
        answer = accu_se_pre;
      } else {
        return { error: "Please! Check Your Input" };
      }
    } else {
      if (isNumeric(observed_value) && isNumeric(accepted_value)) {
        if (Number(accepted_value) === 0) {
          return { error: "Accepted value cannot be equal to zero." };
        }
        let per_error = Number(observed_value) - Number(accepted_value);
        let error_per = Math.abs(per_error) / Number(accepted_value);
        answer = error_per * 100;
      } else {
        return { error: "Please! Check Your Input" };
      }
    }

    return {
      tech_answer: answer,
      tech_method_unit: method_unit,
    };
  }

  /** getCalculationSampleSizecalculator
   * POST: /api/calculators-lol/sample-size-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationSampleSizecalculator(body) {
    let population = body.tech_population?.trim();
    let given_unit = body.tech_given_unit?.trim();
    let confidence_unit = body.tech_confidence_unit?.trim();
    let margin = body.tech_margin?.trim();
    let standard = body.tech_standard?.trim();
    let proportion = body.tech_proportion?.trim();
    let n_finite = body.tech_n_finite?.trim();

    function isNumeric(value) {
      return !isNaN(parseFloat(value)) && isFinite(value);
    }

    let param = {};
    let answer;

    // Convert confidence level to Z-score
    const confidenceMap = {
      "70%": 1.04,
      "75%": 1.15,
      "80%": 1.28,
      "85%": 1.44,
      "90%": 1.65,
      "95%": 1.96,
      "98%": 2.33,
      "99%": 2.58,
      "99.9%": 3.29,
    };
    confidence_unit = confidenceMap[confidence_unit] || 4.42;

    if (margin === "0" || proportion === "0") {
      return { error: "Accepted value cannot be equal to zero." };
    }

    if (population === "sample") {
      if (given_unit === "standard") {
        if (isNumeric(margin) && isNumeric(standard)) {
          margin = Number(margin) / 100;
          standard = Number(standard);
          let multiply = confidence_unit * standard;
          let divide = multiply / margin;
          let sub_answer = divide * divide;
          answer = Math.round(sub_answer);

          return {
            tech_margin: margin,
            tech_standard: standard,
            tech_confidence_unit: confidence_unit,
            tech_multiply: multiply,
            tech_divide: divide,
            tech_sub_answer: sub_answer,
            tech_answer: answer,
          };
        } else {
          return { error: "Please! Check Your Input" };
        }
      } else {
        if (isNumeric(margin) && isNumeric(proportion)) {
          margin = Number(margin) / 100;
          proportion = Number(proportion) / 100;
          let con_unit = confidence_unit ** 2;
          let minus = 1 - proportion;
          let marg = margin ** 2;
          let propro_sub = con_unit * proportion;
          let propro = propro_sub * minus;
          let propro_answer = propro / marg;
          answer = Math.round(propro_answer);

          return {
            tech_answer: answer,
            tech_confidence_unit: confidence_unit,
            tech_proportion: proportion,
            tech_margin: margin,
            tech_minus: minus,
            tech_marg: marg,
            tech_con_unit: con_unit,
            tech_propro: propro,
            tech_propro_answer: propro_answer,
          };
        } else {
          return { error: "Please! Check Your Input" };
        }
      }
    } else {
      if (given_unit === "standard") {
        if (isNumeric(margin) && isNumeric(standard) && isNumeric(n_finite)) {
          margin = Number(margin) / 100;
          standard = Number(standard);
          n_finite = Number(n_finite);

          let multiply = confidence_unit * standard;
          let divide = multiply / margin;
          let sub_answer = divide * divide;
          let n_answer = Math.round(sub_answer);
          let a_answer = n_answer * n_finite;
          let b_answer = n_answer + n_finite - 1;
          let answer_s = a_answer / b_answer;
          answer = Math.round(answer_s);

          return {
            tech_n_finite: n_finite,
            tech_margin: margin,
            tech_standard: standard,
            tech_confidence_unit: confidence_unit,
            tech_multiply: multiply,
            tech_divide: divide,
            tech_sub_answer: sub_answer,
            tech_a_answer: a_answer,
            tech_b_answer: b_answer,
            tech_answer: answer,
          };
        } else {
          return { error: "Please! Check Your Input" };
        }
      } else {
        if (isNumeric(margin) && isNumeric(proportion) && isNumeric(n_finite)) {
          margin = Number(margin) / 100;
          proportion = Number(proportion) / 100;
          n_finite = Number(n_finite);

          let con_unit = confidence_unit ** 2;
          let minus = 1 - proportion;
          let marg = margin ** 2;
          let propro_sub = con_unit * proportion;
          let propro = propro_sub * minus;
          let propro_answer = propro / marg;
          let sub_answer = Math.round(propro_answer);
          let a_answer = sub_answer * n_finite;
          let b_answer = sub_answer + n_finite - 1;
          let answer_s = a_answer / b_answer;
          answer = Math.round(answer_s);

          return {
            tech_n_finite: n_finite,
            tech_confidence_unit: confidence_unit,
            tech_proportion: proportion,
            tech_margin: margin,
            tech_minus: minus,
            tech_marg: marg,
            tech_con_unit: con_unit,
            tech_propro: propro,
            tech_propro_answer: propro_answer,
            tech_sub_answer: sub_answer,
            tech_a_answer: a_answer,
            tech_b_answer: b_answer,
            tech_answer: answer,
          };
        } else {
          return { error: "Please! Check Your Input" };
        }
      }
    }
  }

  /** getCalculationZScoreToPercentilecalculator
   * POST: /api/calculators-lol/z-score-to-percentile
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationZScoreToPercentilecalculator(body) {
    let z_score_table = {
      "-3.9": {
        9: 0.00003,
        8: 0.00003,
        7: 0.00004,
        6: 0.00004,
        5: 0.00004,
        4: 0.00004,
        3: 0.00004,
        2: 0.00004,
        1: 0.00005,
        0: 0.00005,
      },
      "-3.8": {
        9: 0.00005,
        8: 0.00005,
        7: 0.00005,
        6: 0.00006,
        5: 0.00006,
        4: 0.00006,
        3: 0.00006,
        2: 0.00007,
        1: 0.00007,
        0: 0.00007,
      },
      "-3.7": {
        9: 0.00008,
        8: 0.00008,
        7: 0.00008,
        6: 0.00008,
        5: 0.00009,
        4: 0.00009,
        3: 0.0001,
        2: 0.0001,
        1: 0.0001,
        0: 0.00011,
      },
      "-3.6": {
        9: 0.00011,
        8: 0.00012,
        7: 0.00012,
        6: 0.00013,
        5: 0.00013,
        4: 0.00014,
        3: 0.00014,
        2: 0.00015,
        1: 0.00015,
        0: 0.00016,
      },
      "-3.5": {
        9: 0.00017,
        8: 0.00017,
        7: 0.00018,
        6: 0.00019,
        5: 0.00019,
        4: 0.0002,
        3: 0.00021,
        2: 0.00022,
        1: 0.00022,
        0: 0.00023,
      },
      "-3.4": {
        9: 0.00024,
        8: 0.00025,
        7: 0.00026,
        6: 0.00027,
        5: 0.00028,
        4: 0.00029,
        3: 0.0003,
        2: 0.00031,
        1: 0.00032,
        0: 0.00034,
      },
      "-3.3": {
        9: 0.00035,
        8: 0.00036,
        7: 0.00038,
        6: 0.00039,
        5: 0.0004,
        4: 0.00042,
        3: 0.00043,
        2: 0.00045,
        1: 0.00047,
        0: 0.00048,
      },
      "-3.2": {
        9: 0.0005,
        8: 0.00052,
        7: 0.00054,
        6: 0.00056,
        5: 0.00058,
        4: 0.0006,
        3: 0.00062,
        2: 0.00064,
        1: 0.00066,
        0: 0.00069,
      },
      "-3.1": {
        9: 0.00071,
        8: 0.00074,
        7: 0.00076,
        6: 0.00079,
        5: 0.00082,
        4: 0.00084,
        3: 0.00087,
        2: 0.0009,
        1: 0.00094,
        0: 0.00097,
      },
      "-3.0": {
        9: 0.001,
        8: 0.00104,
        7: 0.00107,
        6: 0.00111,
        5: 0.00114,
        4: 0.00118,
        3: 0.00122,
        2: 0.00126,
        1: 0.00131,
        0: 0.00135,
      },
      "-2.9": {
        9: 0.00139,
        8: 0.00144,
        7: 0.00149,
        6: 0.00154,
        5: 0.00159,
        4: 0.00164,
        3: 0.00169,
        2: 0.00175,
        1: 0.00181,
        0: 0.00187,
      },
      "-2.8": {
        9: 0.00193,
        8: 0.00199,
        7: 0.00205,
        6: 0.00212,
        5: 0.00219,
        4: 0.00226,
        3: 0.00233,
        2: 0.0024,
        1: 0.00248,
        0: 0.00256,
      },
      "-2.7": {
        9: 0.00264,
        8: 0.00272,
        7: 0.0028,
        6: 0.00289,
        5: 0.00298,
        4: 0.00307,
        3: 0.00317,
        2: 0.00326,
        1: 0.00336,
        0: 0.00347,
      },
      "-2.6": {
        9: 0.00357,
        8: 0.00368,
        7: 0.00379,
        6: 0.00391,
        5: 0.00402,
        4: 0.00415,
        3: 0.00427,
        2: 0.0044,
        1: 0.00453,
        0: 0.00466,
      },
      "-2.5": {
        9: 0.0048,
        8: 0.00494,
        7: 0.00508,
        6: 0.00523,
        5: 0.00539,
        4: 0.00554,
        3: 0.0057,
        2: 0.00587,
        1: 0.00604,
        0: 0.00621,
      },
      "-2.4": {
        9: 0.00639,
        8: 0.00657,
        7: 0.00676,
        6: 0.00695,
        5: 0.00714,
        4: 0.00734,
        3: 0.00755,
        2: 0.00776,
        1: 0.00798,
        0: 0.0082,
      },
      "-2.3": {
        9: 0.00842,
        8: 0.00866,
        7: 0.00889,
        6: 0.00914,
        5: 0.00939,
        4: 0.00964,
        3: 0.0099,
        2: 0.01017,
        1: 0.01044,
        0: 0.01072,
      },
      "-2.2": {
        9: 0.01101,
        8: 0.0113,
        7: 0.0116,
        6: 0.01191,
        5: 0.01222,
        4: 0.01255,
        3: 0.01287,
        2: 0.01321,
        1: 0.01355,
        0: 0.0139,
      },
      "-2.1": {
        9: 0.01426,
        8: 0.01463,
        7: 0.015,
        6: 0.01539,
        5: 0.01578,
        4: 0.01618,
        3: 0.01659,
        2: 0.017,
        1: 0.01743,
        0: 0.01786,
      },
      "-2.0": {
        9: 0.01831,
        8: 0.01876,
        7: 0.01923,
        6: 0.0197,
        5: 0.02018,
        4: 0.02068,
        3: 0.02118,
        2: 0.02169,
        1: 0.02222,
        0: 0.02275,
      },
      "-1.9": {
        9: 0.0233,
        8: 0.02385,
        7: 0.02442,
        6: 0.025,
        5: 0.02559,
        4: 0.02619,
        3: 0.0268,
        2: 0.02743,
        1: 0.02807,
        0: 0.02872,
      },
      "-1.8": {
        9: 0.02938,
        8: 0.03005,
        7: 0.03074,
        6: 0.03144,
        5: 0.03216,
        4: 0.03288,
        3: 0.03362,
        2: 0.03438,
        1: 0.03515,
        0: 0.03593,
      },
      "-1.7": {
        9: 0.03673,
        8: 0.03754,
        7: 0.03836,
        6: 0.0392,
        5: 0.04006,
        4: 0.04093,
        3: 0.04182,
        2: 0.04272,
        1: 0.04363,
        0: 0.04457,
      },
      "-1.6": {
        9: 0.04551,
        8: 0.04648,
        7: 0.04746,
        6: 0.04846,
        5: 0.04947,
        4: 0.0505,
        3: 0.05155,
        2: 0.05262,
        1: 0.0537,
        0: 0.0548,
      },
      "-1.5": {
        9: 0.0559,
        8: 0.0571,
        7: 0.0582,
        6: 0.0594,
        5: 0.0606,
        4: 0.0618,
        3: 0.063,
        2: 0.0643,
        1: 0.0655,
        0: 0.0668,
      },
      "-1.4": {
        9: 0.0681,
        8: 0.0694,
        7: 0.0708,
        6: 0.0721,
        5: 0.0735,
        4: 0.0749,
        3: 0.0764,
        2: 0.0778,
        1: 0.0793,
        0: 0.0808,
      },
      "-1.3": {
        9: 0.0823,
        8: 0.0838,
        7: 0.0853,
        6: 0.0869,
        5: 0.0885,
        4: 0.0901,
        3: 0.0918,
        2: 0.0934,
        1: 0.0951,
        0: 0.0968,
      },
      "-1.2": {
        9: 0.0985,
        8: 0.1003,
        7: 0.102,
        6: 0.1038,
        5: 0.1056,
        4: 0.1075,
        3: 0.1093,
        2: 0.1112,
        1: 0.1131,
        0: 0.1151,
      },
      "-1.1": {
        9: 0.117,
        8: 0.119,
        7: 0.121,
        6: 0.123,
        5: 0.1251,
        4: 0.1271,
        3: 0.1292,
        2: 0.1314,
        1: 0.1335,
        0: 0.1357,
      },
      "-1.0": {
        9: 0.1379,
        8: 0.1401,
        7: 0.1423,
        6: 0.1446,
        5: 0.1469,
        4: 0.1492,
        3: 0.1515,
        2: 0.1539,
        1: 0.1562,
        0: 0.1587,
      },
      "-0.9": {
        9: 0.1611,
        8: 0.1635,
        7: 0.166,
        6: 0.1685,
        5: 0.1711,
        4: 0.1736,
        3: 0.1762,
        2: 0.1788,
        1: 0.1814,
        0: 0.1841,
      },
      "-0.8": {
        9: 0.1867,
        8: 0.1894,
        7: 0.1922,
        6: 0.1949,
        5: 0.1977,
        4: 0.2005,
        3: 0.2033,
        2: 0.2061,
        1: 0.209,
        0: 0.2119,
      },
      "-0.7": {
        9: 0.2148,
        8: 0.2177,
        7: 0.2206,
        6: 0.2236,
        5: 0.2266,
        4: 0.2296,
        3: 0.2327,
        2: 0.2358,
        1: 0.2389,
        0: 0.242,
      },
      "-0.6": {
        9: 0.2451,
        8: 0.2483,
        7: 0.2514,
        6: 0.2546,
        5: 0.2578,
        4: 0.2611,
        3: 0.2643,
        2: 0.2676,
        1: 0.2709,
        0: 0.2743,
      },
      "-0.5": {
        9: 0.2776,
        8: 0.281,
        7: 0.2843,
        6: 0.2877,
        5: 0.2912,
        4: 0.2946,
        3: 0.2981,
        2: 0.3015,
        1: 0.305,
        0: 0.3085,
      },
      "-0.4": {
        9: 0.3121,
        8: 0.3156,
        7: 0.3192,
        6: 0.3228,
        5: 0.3264,
        4: 0.33,
        3: 0.3336,
        2: 0.3372,
        1: 0.3409,
        0: 0.3446,
      },
      "-0.3": {
        9: 0.3483,
        8: 0.352,
        7: 0.3557,
        6: 0.3594,
        5: 0.3632,
        4: 0.3669,
        3: 0.3707,
        2: 0.3745,
        1: 0.3783,
        0: 0.3821,
      },
      "-0.2": {
        9: 0.3859,
        8: 0.3897,
        7: 0.3936,
        6: 0.3974,
        5: 0.4013,
        4: 0.4052,
        3: 0.409,
        2: 0.4129,
        1: 0.4168,
        0: 0.4207,
      },
      "-0.1": {
        9: 0.4247,
        8: 0.4286,
        7: 0.4325,
        6: 0.4364,
        5: 0.4404,
        4: 0.4443,
        3: 0.4483,
        2: 0.4522,
        1: 0.4562,
        0: 0.4602,
      },
      "-0.0": {
        9: 0.4641,
        8: 0.4681,
        7: 0.4721,
        6: 0.4761,
        5: 0.4801,
        4: 0.484,
        3: 0.488,
        2: 0.492,
        1: 0.496,
        0: 0.5,
      },
      "0.0": {
        0: 0.5,
        1: 0.50399,
        2: 0.50798,
        3: 0.51197,
        4: 0.51595,
        5: 0.51994,
        6: 0.52392,
        7: 0.5279,
        8: 0.53188,
        9: 0.53586,
      },
      0.1: {
        0: 0.5398,
        1: 0.5438,
        2: 0.54776,
        3: 0.55172,
        4: 0.55567,
        5: 0.55966,
        6: 0.5636,
        7: 0.56749,
        8: 0.57142,
        9: 0.57535,
      },
      0.2: {
        0: 0.5793,
        1: 0.58317,
        2: 0.58706,
        3: 0.59095,
        4: 0.59483,
        5: 0.59871,
        6: 0.60257,
        7: 0.60642,
        8: 0.61026,
        9: 0.61409,
      },
      0.3: {
        0: 0.61791,
        1: 0.62172,
        2: 0.62552,
        3: 0.6293,
        4: 0.63307,
        5: 0.63683,
        6: 0.64058,
        7: 0.64431,
        8: 0.64803,
        9: 0.65173,
      },
      0.4: {
        0: 0.65542,
        1: 0.6591,
        2: 0.66276,
        3: 0.6664,
        4: 0.67003,
        5: 0.67364,
        6: 0.67724,
        7: 0.68082,
        8: 0.68439,
        9: 0.68793,
      },
      0.5: {
        0: 0.69146,
        1: 0.69497,
        2: 0.69847,
        3: 0.70194,
        4: 0.7054,
        5: 0.70884,
        6: 0.71226,
        7: 0.71566,
        8: 0.71904,
        9: 0.7224,
      },
      0.6: {
        0: 0.72575,
        1: 0.72907,
        2: 0.73237,
        3: 0.73565,
        4: 0.73891,
        5: 0.74215,
        6: 0.74537,
        7: 0.74857,
        8: 0.75175,
        9: 0.7549,
      },
      0.7: {
        0: 0.75804,
        1: 0.76115,
        2: 0.76424,
        3: 0.7673,
        4: 0.77035,
        5: 0.77337,
        6: 0.77637,
        7: 0.77935,
        8: 0.7823,
        9: 0.78524,
      },
      0.8: {
        0: 0.78814,
        1: 0.79103,
        2: 0.79389,
        3: 0.79673,
        4: 0.79955,
        5: 0.80234,
        6: 0.80511,
        7: 0.80785,
        8: 0.81057,
        9: 0.81327,
      },
      0.9: {
        0: 0.81594,
        1: 0.81859,
        2: 0.82121,
        3: 0.82381,
        4: 0.82639,
        5: 0.82894,
        6: 0.83147,
        7: 0.83398,
        8: 0.83646,
        9: 0.83891,
      },
      "1.0": {
        0: 0.84134,
        1: 0.84375,
        2: 0.84614,
        3: 0.84849,
        4: 0.85083,
        5: 0.85314,
        6: 0.85543,
        7: 0.85769,
        8: 0.85993,
        9: 0.86214,
      },
      1.1: {
        0: 0.86433,
        1: 0.8665,
        2: 0.86864,
        3: 0.87076,
        4: 0.87286,
        5: 0.87493,
        6: 0.87698,
        7: 0.879,
        8: 0.881,
        9: 0.88298,
      },
      1.2: {
        0: 0.88493,
        1: 0.88686,
        2: 0.88877,
        3: 0.89065,
        4: 0.89251,
        5: 0.89435,
        6: 0.89617,
        7: 0.89796,
        8: 0.89973,
        9: 0.90147,
      },
      1.3: {
        0: 0.9032,
        1: 0.9049,
        2: 0.90658,
        3: 0.90824,
        4: 0.90988,
        5: 0.91149,
        6: 0.91308,
        7: 0.91466,
        8: 0.91621,
        9: 0.91774,
      },
      1.4: {
        0: 0.91924,
        1: 0.92073,
        2: 0.9222,
        3: 0.92364,
        4: 0.92507,
        5: 0.92647,
        6: 0.92785,
        7: 0.92922,
        8: 0.93056,
        9: 0.93189,
      },
      1.5: {
        0: 0.93319,
        1: 0.93448,
        2: 0.93574,
        3: 0.93699,
        4: 0.93822,
        5: 0.93943,
        6: 0.94062,
        7: 0.94179,
        8: 0.94295,
        9: 0.94408,
      },
      1.6: {
        0: 0.9452,
        1: 0.9463,
        2: 0.94738,
        3: 0.94845,
        4: 0.9495,
        5: 0.95053,
        6: 0.95154,
        7: 0.95254,
        8: 0.95352,
        9: 0.95449,
      },
      1.7: {
        0: 0.95543,
        1: 0.95637,
        2: 0.95728,
        3: 0.95818,
        4: 0.95907,
        5: 0.95994,
        6: 0.9608,
        7: 0.96164,
        8: 0.96246,
        9: 0.96327,
      },
      1.8: {
        0: 0.96407,
        1: 0.96485,
        2: 0.96562,
        3: 0.96638,
        4: 0.96712,
        5: 0.96784,
        6: 0.96856,
        7: 0.96926,
        8: 0.96995,
        9: 0.97062,
      },
      1.9: {
        0: 0.97128,
        1: 0.97193,
        2: 0.97257,
        3: 0.9732,
        4: 0.97381,
        5: 0.97441,
        6: 0.975,
        7: 0.97558,
        8: 0.97615,
        9: 0.9767,
      },
      "2.0": {
        0: 0.97725,
        1: 0.97778,
        2: 0.97831,
        3: 0.97882,
        4: 0.97932,
        5: 0.97982,
        6: 0.9803,
        7: 0.98077,
        8: 0.98124,
        9: 0.98169,
      },
      2.1: {
        0: 0.98214,
        1: 0.98257,
        2: 0.983,
        3: 0.98341,
        4: 0.98382,
        5: 0.98422,
        6: 0.98461,
        7: 0.985,
        8: 0.98537,
        9: 0.98574,
      },
      2.2: {
        0: 0.9861,
        1: 0.98645,
        2: 0.98679,
        3: 0.98713,
        4: 0.98745,
        5: 0.98778,
        6: 0.98809,
        7: 0.9884,
        8: 0.9887,
        9: 0.98899,
      },
      2.3: {
        0: 0.98928,
        1: 0.98956,
        2: 0.98983,
        3: 0.9901,
        4: 0.99036,
        5: 0.99061,
        6: 0.99086,
        7: 0.99111,
        8: 0.99134,
        9: 0.99158,
      },
      2.4: {
        0: 0.9918,
        1: 0.99202,
        2: 0.99224,
        3: 0.99245,
        4: 0.99266,
        5: 0.99286,
        6: 0.99305,
        7: 0.99324,
        8: 0.99343,
        9: 0.99361,
      },
      2.5: {
        0: 0.99379,
        1: 0.99396,
        2: 0.99413,
        3: 0.9943,
        4: 0.99446,
        5: 0.99461,
        6: 0.99477,
        7: 0.99492,
        8: 0.99506,
        9: 0.9952,
      },
      2.6: {
        0: 0.99534,
        1: 0.99547,
        2: 0.9956,
        3: 0.99573,
        4: 0.99585,
        5: 0.99598,
        6: 0.99609,
        7: 0.99621,
        8: 0.99632,
        9: 0.99643,
      },
      2.7: {
        0: 0.99653,
        1: 0.99664,
        2: 0.99674,
        3: 0.99683,
        4: 0.99693,
        5: 0.99702,
        6: 0.99711,
        7: 0.9972,
        8: 0.99728,
        9: 0.99736,
      },
      2.8: {
        0: 0.99744,
        1: 0.99752,
        2: 0.9976,
        3: 0.99767,
        4: 0.99774,
        5: 0.99781,
        6: 0.99788,
        7: 0.99795,
        8: 0.99801,
        9: 0.99807,
      },
      2.9: {
        0: 0.99813,
        1: 0.99819,
        2: 0.99825,
        3: 0.99831,
        4: 0.99836,
        5: 0.99841,
        6: 0.99846,
        7: 0.99851,
        8: 0.99856,
        9: 0.99861,
      },
      "3.0": {
        0: 0.99865,
        1: 0.99869,
        2: 0.99874,
        3: 0.99878,
        4: 0.99882,
        5: 0.99886,
        6: 0.99889,
        7: 0.99893,
        8: 0.99896,
        9: 0.999,
      },
      3.1: {
        0: 0.99903,
        1: 0.99906,
        2: 0.9991,
        3: 0.99913,
        4: 0.99916,
        5: 0.99918,
        6: 0.99921,
        7: 0.99924,
        8: 0.99926,
        9: 0.99929,
      },
      3.2: {
        0: 0.99931,
        1: 0.99934,
        2: 0.99936,
        3: 0.99938,
        4: 0.9994,
        5: 0.99942,
        6: 0.99944,
        7: 0.99946,
        8: 0.99948,
        9: 0.9995,
      },
      3.3: {
        0: 0.99952,
        1: 0.99953,
        2: 0.99955,
        3: 0.99957,
        4: 0.99958,
        5: 0.9996,
        6: 0.99961,
        7: 0.99962,
        8: 0.99964,
        9: 0.99965,
      },
      3.4: {
        0: 0.99966,
        1: 0.99968,
        2: 0.99969,
        3: 0.9997,
        4: 0.99971,
        5: 0.99972,
        6: 0.99973,
        7: 0.99974,
        8: 0.99975,
        9: 0.99976,
      },
      3.5: {
        0: 0.99977,
        1: 0.99978,
        2: 0.99978,
        3: 0.99979,
        4: 0.9998,
        5: 0.99981,
        6: 0.99981,
        7: 0.99982,
        8: 0.99983,
        9: 0.99983,
      },
      3.6: {
        0: 0.99984,
        1: 0.99985,
        2: 0.99985,
        3: 0.99986,
        4: 0.99986,
        5: 0.99987,
        6: 0.99987,
        7: 0.99988,
        8: 0.99988,
        9: 0.99989,
      },
      3.7: {
        0: 0.99989,
        1: 0.9999,
        2: 0.9999,
        3: 0.9999,
        4: 0.99991,
        5: 0.99991,
        6: 0.99992,
        7: 0.99992,
        8: 0.99992,
        9: 0.99992,
      },
      3.8: {
        0: 0.99993,
        1: 0.99993,
        2: 0.99993,
        3: 0.99994,
        4: 0.99994,
        5: 0.99994,
        6: 0.99994,
        7: 0.99995,
        8: 0.99995,
        9: 0.99995,
      },
      3.9: {
        0: 0.99995,
        1: 0.99995,
        2: 0.99996,
        3: 0.99996,
        4: 0.99996,
        5: 0.99996,
        6: 0.99996,
        7: 0.99996,
        8: 0.99997,
        9: 0.99997,
      },
      "4.0": {
        0: 0.99997,
        1: 0.99997,
        2: 0.99997,
        3: 0.99997,
        4: 0.99997,
        5: 0.99997,
        6: 0.99998,
        7: 0.99998,
        8: 0.99998,
        9: 0.99998,
      },
    };

    let result = {};
    let z_score = body.tech_z_score?.toString().trim();

    function isDecimal(val) {
      return !Number.isInteger(Number(val));
    }

    if (!isNaN(z_score)) {
      let score = Math.round(z_score * 10) / 10;
      let inner_score = Math.round(z_score * 100) / 100;
      let res_val;
      let img;

      if (isDecimal(inner_score)) {
        if (z_score >= -3.9 && z_score <= 4.0) {
          let parts = inner_score.toString().split(".");
          let main_jawab = parts[1]?.substring(1, 2) || "0";
          res_val = z_score_table[score.toFixed(1)]?.[main_jawab];
        } else {
          res_val = z_score < -3.9 ? "0" : "1";
        }
      } else {
        let z_score_str = parseFloat(z_score).toFixed(1);
        if (z_score >= -3.9 && z_score <= 4.0) {
          let parts = z_score_str.split(".");
          let main_jawab = parts[1]?.substring(1, 2) || "0";
          res_val = z_score_table[z_score_str]?.[main_jawab];
        } else {
          res_val = z_score < -3.9 ? "0" : "1";
        }
      }

      if (score <= -3.8) {
        img = "-3.5 equal & above.png";
      } else if (score == -3.7) {
        img = "-3.5 equal & above.png";
      } else if (score == -3.6) {
        img = "-3.5 equal & above.png";
      } else if (score == -3.5) {
        img = "-3.5 equal & above.png";
      } else if (score == -3.4) {
        img = "-3.4.png";
      } else if (score == -3.3) {
        img = "-3.3.png";
      } else if (score == -3.2) {
        img = "-3.2.png";
      } else if (score == -3.1) {
        img = "-3.1.png";
      } else if (score == -3) {
        img = "-3.0.png";
      } else if (score == -2.9) {
        img = "-2.9.png";
      } else if (score == -2.8) {
        img = "-2.8.png";
      } else if (score == -2.7) {
        img = "-2.7.png";
      } else if (score == -2.6) {
        img = "-2.6.png";
      } else if (score == -2.5) {
        img = "-2.5.png";
      } else if (score == -2.4) {
        img = "-2.4.png";
      } else if (score == -2.3) {
        img = "-2.3.png";
      } else if (score == -2.2) {
        img = "-2.2.png";
      } else if (score == -2.1) {
        img = "-2.1.png";
      } else if (score == -2) {
        img = "-2.0.png";
      } else if (score == -1.9) {
        img = "-1.9.png";
      } else if (score == -1.8) {
        img = "-1.8.png";
      } else if (score == -1.7) {
        img = "-1.7.png";
      } else if (score == -1.6) {
        img = "-1.6.png";
      } else if (score == -1.5) {
        img = "-1.5.png";
      } else if (score == -1.4) {
        img = "-1.4.png";
      } else if (score == -1.3) {
        img = "-1.3.png";
      } else if (score == -1.2) {
        img = "-1.2.png";
      } else if (score == -1.1) {
        img = "-1.1.png";
      } else if (score == -1) {
        img = "-1.0.png";
      } else if (score == -0.9) {
        img = "-0.9.png";
      } else if (score == -0.8) {
        img = "-0.8.png";
      } else if (score == -0.7) {
        img = "-0.7.png";
      } else if (score == -0.6) {
        img = "-0.6.png";
      } else if (score == -0.5) {
        img = "-0.5.png";
      } else if (score == -0.4) {
        img = "-0.4.png";
      } else if (score == -0.3) {
        img = "-0.3.png";
      } else if (score == -0.2) {
        img = "-0.2.png";
      } else if (score == -0.1) {
        img = "-0.1.png";
      } else if (score == -0) {
        img = "-0.png";
      } else if (score == 0) {
        img = "0.png";
      } else if (score == 0.1) {
        img = "0.1.png";
      } else if (score == 0.2) {
        img = "0.2.png";
      } else if (score == 0.3) {
        img = "0.3.png";
      } else if (score == 0.4) {
        img = "0.4.png";
      } else if (score == 0.5) {
        img = "0.5.png";
      } else if (score == 0.6) {
        img = "0.6.png";
      } else if (score == 0.7) {
        img = "0.7.png";
      } else if (score == 0.8) {
        img = "0.8.png";
      } else if (score == 0.9) {
        img = "0.9.png";
      } else if (score == 1) {
        img = "1.0.png";
      } else if (score == 1.1) {
        img = "1.1.png";
      } else if (score == 1.2) {
        img = "1.2.png";
      } else if (score == 1.3) {
        img = "1.3.png";
      } else if (score == 1.4) {
        img = "1.4.png";
      } else if (score == 1.5) {
        img = "1.5.png";
      } else if (score == 1.6) {
        img = "1.6.png";
      } else if (score == 1.7) {
        img = "1.7.png";
      } else if (score == 1.8) {
        img = "1.8.png";
      } else if (score == 1.9) {
        img = "1.9.png";
      } else if (score == 2) {
        img = "2.0.png";
      } else if (score == 2.1) {
        img = "2.1.png";
      } else if (score == 2.2) {
        img = "2.2.png";
      } else if (score == 2.3) {
        img = "2.3.png";
      } else if (score == 2.4) {
        img = "2.4.png";
      } else if (score == 2.5) {
        img = "2.5.png";
      } else if (score == 2.6) {
        img = "2.6.png";
      } else if (score == 2.7) {
        img = "2.7.png";
      } else if (score == 2.8) {
        img = "2.8.png";
      } else if (score == 2.9) {
        img = "2.9.png";
      } else if (score == 3) {
        img = "3.0.png";
      } else if (score == 3.1) {
        img = "3.1.png";
      } else if (score == 3.2) {
        img = "3.2.png";
      } else if (score == 3.3) {
        img = "3.3.png";
      } else if (score == 3.4) {
        img = "3.4.png";
      } else if (score == 3.5) {
        img = "3.5.png";
      } else if (score == 3.6) {
        img = "3.5.png";
      } else if (score == 3.7) {
        img = "3.5.png";
      } else if (score >= 3.8) {
        img = "3.5.png";
      }
      result.tech_z_score = z_score;
      result.tech_score = score;
      result.tech_res_val = res_val;
      result.tech_img = img;
    } else {
      result.error = "Please! Check Your Input";
    }

    return result;
  }

  /** getCalculationCrossProductcalculator
   * POST: /api/calculators-lol/cross-product-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCrossProductcalculator(body) {
    let a_rep = body.tech_a_rep;
    let ax = body.tech_ax;
    let ay = body.tech_ay;
    let az = body.tech_az;
    let a1 = body.tech_a1;
    let a2 = body.tech_a2;
    let a3 = body.tech_a3;
    let b1 = body.tech_b1;
    let b2 = body.tech_b2;
    let b3 = body.tech_b3;
    let b_rep = body.tech_b_rep;
    let bx = body.tech_bx;
    let by = body.tech_by;
    let bz = body.tech_bz;
    let aa1 = body.tech_aa1;
    let aa2 = body.tech_aa2;
    let aa3 = body.tech_aa3;
    let bb1 = body.tech_bb1;
    let bb2 = body.tech_bb2;
    let bb3 = body.tech_bb3;

    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }
    let check = false;

    if (a_rep === "coor") {
      if (isNumeric(ax) && isNumeric(ay) && isNumeric(az)) {
        check = true;
      } else {
        check = false;
      }
    } else {
      if (
        isNumeric(a1) &&
        isNumeric(a2) &&
        isNumeric(a3) &&
        isNumeric(b1) &&
        isNumeric(b2) &&
        isNumeric(b3)
      ) {
        check = true;
      } else {
        check = false;
      }
    }

    if (b_rep === "coor") {
      if (isNumeric(bx) && isNumeric(by) && isNumeric(bz)) {
        check = true;
      } else {
        check = false;
      }
    } else {
      if (
        isNumeric(aa1) &&
        isNumeric(aa2) &&
        isNumeric(aa3) &&
        isNumeric(bb1) &&
        isNumeric(bb2) &&
        isNumeric(bb3)
      ) {
        check = true;
      } else {
        check = false;
      }
    }

    if (check === true) {
      return {
        tech_cross: "active",
      };
    } else {
      return {
        error: "Please fill all fields.",
      };
    }
  }

  /** getCalculationInstantaneousVelocitycalculator
   * POST: /api/calculators-lol/instantaneous-velocity-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationInstantaneousVelocitycalculator(body) {
    let i_d = body.tech_i_d;
    let i_d_unit = body.tech_i_d_unit;
    let f_d = body.tech_f_d;
    let f_d_unit = body.tech_f_d_unit;
    let i_tt = body.tech_i_tt;
    let i_tt_unit = body.tech_i_tt_unit;
    let f_tt = body.tech_f_tt;
    let f_tt_unit = body.tech_f_tt_unit;

    let result = {};

    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function round(n) {
      return Math.round(n * 100000) / 100000;
    }

    // Convert distances to meters
    if (isNumeric(i_d)) {
      i_d = parseFloat(i_d);
      if (i_d_unit === "cm") i_d = i_d / 100;
      else if (i_d_unit === "km") i_d = i_d / 0.001;
      else if (i_d_unit === "in") i_d = i_d / 39.37;
      else if (i_d_unit === "ft") i_d = i_d / 3.281;
      else if (i_d_unit === "yd") i_d = i_d / 1.0936;
      else if (i_d_unit === "mi") i_d = i_d / 0.0006214;
    }

    if (isNumeric(f_d)) {
      f_d = parseFloat(f_d);
      if (f_d_unit === "cm") f_d = f_d / 100;
      else if (f_d_unit === "km") f_d = f_d / 0.001;
      else if (f_d_unit === "in") f_d = f_d / 39.37;
      else if (f_d_unit === "ft") f_d = f_d / 3.281;
      else if (f_d_unit === "yd") f_d = f_d / 1.0936;
      else if (f_d_unit === "mi") f_d = f_d / 0.0006214;
    }

    // Convert time to seconds
    if (isNumeric(i_tt)) {
      i_tt = parseFloat(i_tt);
      if (i_tt_unit === "min") i_tt = i_tt / 0.016667;
      else if (i_tt_unit === "hrs") i_tt = i_tt / 0.0002778;
    }

    if (isNumeric(f_tt)) {
      f_tt = parseFloat(f_tt);
      if (f_tt_unit === "min") f_tt = f_tt / 0.016667;
      else if (f_tt_unit === "hrs") f_tt = f_tt / 0.0002778;
    }

    if (
      isNumeric(i_d) &&
      isNumeric(f_d) &&
      isNumeric(i_tt) &&
      isNumeric(f_tt)
    ) {
      let s1 = f_d - i_d;
      let s2 = f_tt - i_tt;
      let iv = s1 / s2;

      result.tech_method = "iv";
      result.tech_iv = round(iv);
      result.tech_id = round(i_d);
      result.tech_fd = round(f_d);
      result.tech_itt = round(i_tt);
      result.tech_ftt = round(f_tt);
      result.tech_s1 = round(s1);
      result.tech_s2 = round(s2);
    } else {
      result.error = "Please! Fill All The Fields!";
    }

    return result;
  }

  /** getCalculationPhotonEnergycalculator
   * POST: /api/calculators-lol/photon-energy-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPhotonEnergycalculator(body) {
    let wave = body.tech_wave;
    let freq = body.tech_freq;
    let unit_w = body.tech_unit_w;
    let unit_f = body.tech_unit_f;

    let result = {};
    const h = 6.6260695729e-34; // Planck's constant
    const c = 2.99792458e8; // Speed of light

    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function formatScientific(val) {
      const parts = val.toExponential().split("e");
      return `${parseFloat(parts[0]).toFixed(4)} x 10<sup>${parseInt(
        parts[1]
      )}</sup>`;
    }

    // Check if wave is provided
    if (isNumeric(wave)) {
      wave = parseFloat(wave);
      switch (unit_w) {
        case "Å":
          wave = wave / 1e10;
          break;
        case "nm":
          wave = wave / 1e9;
          break;
        case "μm":
          wave = wave / 1e6;
          break;
        case "mm":
          wave = wave / 1000;
          break;
        case "km":
          wave = wave * 1000;
          break;
      }

      let energy = (h * c) / wave;
      let frequency = energy / h;
      let en = energy;
      let energyFormatted = formatScientific(energy);

      result.tech_energy = energyFormatted;
      result.tech_en = en;
      result.tech_frequency = Math.round(frequency * 1000) / 1000;
      return result;
    } else if (isNumeric(freq)) {
      freq = parseFloat(freq);
      switch (unit_f) {
        case "kHz":
          freq *= 1e3;
          break;
        case "MHz":
          freq *= 1e6;
          break;
        case "GHz":
          freq *= 1e9;
          break;
        case "THz":
          freq *= 1e12;
          break;
        case "RPM":
          freq /= 60;
          break;
      }

      let energy = h * freq;
      let wave = (h * c) / energy;
      let en = energy;
      let energyFormatted = formatScientific(energy);

      result.tech_energy = energyFormatted;
      result.tech_en = en;
      result.tech_wave = Math.round(wave * 1000) / 1000;
      return result;
    } else {
      result.error = "Please fill all fields.";
      return result;
    }
  }

  /** getCalculationDotProductcalculator
   * POST: /api/calculators-lol/dot-product-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDotProductcalculator(body) {
    let input1 = body.tech_input1;
    let input2 = body.tech_input2;

    let result = {};

    let components = input1.split(",").map((v) => v.trim());
    let components2 = input2.split(",").map((v) => v.trim());

    function isNumericArray(arr) {
      return arr.every((val) => !isNaN(val));
    }

    if (!isNumericArray(components) || !isNumericArray(components2)) {
      result.error = "Sets may contain only integers and decimals";
      return result;
    }

    if (components.length !== components2.length) {
      result.error = "The input arrays must have the same length.";
      return result;
    }

    if (input1 && input2) {
      let a = components.map(Number);
      let b = components2.map(Number);

      let products = a.map((val, idx) => val * b[idx]);
      let prod = products.reduce((sum, val) => sum + val, 0);

      let sumSqA = a.reduce((sum, val) => sum + val ** 2, 0);
      let sumSqB = b.reduce((sum, val) => sum + val ** 2, 0);

      let mgntd_a = Math.sqrt(sumSqA);
      let mgntd_b = Math.sqrt(sumSqB);

      let angle = prod / (mgntd_a * mgntd_b);
      let theta = Math.acos(angle);
      let deg = theta * (180 / Math.PI);

      result.tech_components = a;
      result.tech_components2 = b;
      result.tech_mgntd_a = Math.round(mgntd_a * 100) / 100;
      result.tech_mgntd_b = Math.round(mgntd_b * 100) / 100;
      result.tech_prod = prod;
      result.tech_angle = Math.round(angle * 1e7) / 1e7;
      result.tech_deg = Math.round(deg * 1e5) / 1e5;
      return result;
    } else {
      result.error = "Please Fill All The Fields";
      return result;
    }
  }

  /** getCalculationVectorMagnitudecalculator
   * POST: /api/calculators-lol/vector-magnitude-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationVectorMagnitudecalculator(body) {
    let result = {};

    let dem = body.tech_dem;
    let a_rep = body.tech_a_rep;
    let ax = body.tech_ax;
    let ay = body.tech_ay;
    let az = body.tech_az;
    let w = body.tech_w;
    let t = body.tech_t;
    let a1 = body.tech_a1;
    let a2 = body.tech_a2;
    let a3 = body.tech_a3;
    let a4 = body.tech_a4;
    let a5 = body.tech_a5;
    let b1 = body.tech_b1;
    let b2 = body.tech_b2;
    let b3 = body.tech_b3;
    let b4 = body.tech_b4;
    let b5 = body.tech_b5;

    dem = dem?.toString().trim();
    a_rep = a_rep?.toString().trim();
    ax = parseFloat(ax);
    ay = parseFloat(ay);
    az = parseFloat(az);
    w = parseFloat(w);
    t = parseFloat(t);
    a1 = parseFloat(a1);
    a2 = parseFloat(a2);
    a3 = parseFloat(a3);
    a4 = parseFloat(a4);
    a5 = parseFloat(a5);
    b1 = parseFloat(b1);
    b2 = parseFloat(b2);
    b3 = parseFloat(b3);
    b4 = parseFloat(b4);
    b5 = parseFloat(b5);

    function isNumeric(val) {
      return typeof val === "number" && !isNaN(val);
    }

    if (a_rep === "coor") {
      if (dem === "2") {
        if (isNumeric(ax) && isNumeric(ay)) {
          let mag = Math.sqrt(ax ** 2 + ay ** 2);
          result.tech_mag = +mag.toFixed(5);
          return result;
        }
      } else if (dem === "3") {
        if (isNumeric(ax) && isNumeric(ay) && isNumeric(az)) {
          let mag = Math.sqrt(ax ** 2 + ay ** 2 + az ** 2);
          result.tech_mag = +mag.toFixed(5);
          return result;
        }
      } else if (dem === "4") {
        if (isNumeric(ax) && isNumeric(ay) && isNumeric(az) && isNumeric(w)) {
          let mag = Math.sqrt(ax ** 2 + ay ** 2 + az ** 2 + w ** 2);
          result.tech_mag = +mag.toFixed(5);
          return result;
        }
      } else if (dem === "5") {
        if (
          isNumeric(ax) &&
          isNumeric(ay) &&
          isNumeric(az) &&
          isNumeric(w) &&
          isNumeric(t)
        ) {
          let mag = Math.sqrt(ax ** 2 + ay ** 2 + az ** 2 + w ** 2 + t ** 2);
          result.tech_mag = +mag.toFixed(5);
          return result;
        }
      }
    } else {
      // when a_rep != 'coor', calculate vector difference between points a and b
      if (dem === "2") {
        if (isNumeric(a1) && isNumeric(a2) && isNumeric(b1) && isNumeric(b2)) {
          let dx = b1 - a1;
          let dy = b2 - a2;
          let mag = Math.sqrt(dx ** 2 + dy ** 2);
          result.tech_mag = +mag.toFixed(5);
          return result;
        }
      } else if (dem === "3") {
        if (
          isNumeric(a1) &&
          isNumeric(a2) &&
          isNumeric(a3) &&
          isNumeric(b1) &&
          isNumeric(b2) &&
          isNumeric(b3)
        ) {
          let dx = b1 - a1;
          let dy = b2 - a2;
          let dz = b3 - a3;
          let mag = Math.sqrt(dx ** 2 + dy ** 2 + dz ** 2);
          result.tech_mag = +mag.toFixed(5);
          return result;
        }
      } else if (dem === "4") {
        if (
          isNumeric(a1) &&
          isNumeric(a2) &&
          isNumeric(a3) &&
          isNumeric(a4) &&
          isNumeric(b1) &&
          isNumeric(b2) &&
          isNumeric(b3) &&
          isNumeric(b4)
        ) {
          let dx = b1 - a1;
          let dy = b2 - a2;
          let dz = b3 - a3;
          let dw = b4 - a4;
          let mag = Math.sqrt(dx ** 2 + dy ** 2 + dz ** 2 + dw ** 2);
          result.tech_mag = +mag.toFixed(5);
          return result;
        }
      } else if (dem === "5") {
        if (
          isNumeric(a1) &&
          isNumeric(a2) &&
          isNumeric(a3) &&
          isNumeric(a4) &&
          isNumeric(a5) &&
          isNumeric(b1) &&
          isNumeric(b2) &&
          isNumeric(b3) &&
          isNumeric(b4) &&
          isNumeric(b5)
        ) {
          let dx = b1 - a1;
          let dy = b2 - a2;
          let dz = b3 - a3;
          let dw = b4 - a4;
          let dt = b5 - a5;
          let mag = Math.sqrt(dx ** 2 + dy ** 2 + dz ** 2 + dw ** 2 + dt ** 2);
          result.tech_mag = +mag.toFixed(5);
          return result;
        }
      }
    }

    result.error = "Please! Check Your Input";
    return result;
  }

  /** getCalculationProjectileMotioncalculator
   * POST: /api/calculators-lol/projectile-motion-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationProjectileMotioncalculator(body) {
    let method = body.tech_method?.trim();
    let a = parseFloat(body.tech_a);
    let a_unit = body.tech_a_unit?.trim();
    let h = parseFloat(body.tech_h);
    let h_unit = body.tech_h_unit?.trim();
    let v = parseFloat(body.tech_v);
    let v_unit = body.tech_v_unit?.trim();
    let g = parseFloat(body.tech_g);
    let g_unit = body.tech_g_unit?.trim();
    let t = parseFloat(body.tech_t);
    let t_unit = body.tech_t_unit?.trim();

    let param = {};

    const sigFig = (value, digits) => {
      if (value === 0) return 0;
      let d = digits - Math.floor(Math.log10(Math.abs(value))) - 1;
      let decimalPlaces = Math.max(0, Math.min(d, 100)); // Clamp between 0 and 100
      return parseFloat(value.toFixed(decimalPlaces));
    };

    if (
      isFinite(a) &&
      isFinite(h) &&
      isFinite(v) &&
      isFinite(g) &&
      a_unit &&
      h_unit &&
      v_unit &&
      g_unit
    ) {
      // Convert height
      if (h_unit === "cm") {
        h = h / 100;
      } else if (h_unit === "km") {
        h = h / 0.001;
      } else if (h_unit === "in") {
        h = h / 39.37;
      } else if (h_unit === "ft") {
        h = h / 3.281;
      } else if (h_unit === "yd") {
        h = h / 1.0936;
      } else if (h_unit === "mi") {
        h = h / 0.0006214;
      }

      // Convert velocity
      if (v_unit === "kmh") {
        v = v / 3.6;
      } else if (v_unit === "fts") {
        v = v / 3.28;
      } else if (v_unit === "mph") {
        v = v / 2.237;
      }

      // Convert time
      if (isFinite(t)) {
        if (t_unit === "min") {
          t = t * 60;
        } else if (t_unit === "hrs") {
          t = t * 3600;
        }
      }

      // Calculate horizontal and vertical components
      let vx, vy;
      if (a_unit === "deg") {
        vx = v * Math.cos((a * Math.PI) / 180);
        vy = v * Math.sin((a * Math.PI) / 180);
      } else {
        vx = v * Math.cos(a);
        vy = v * Math.sin(a);
      }

      // Convert gravity
      if (g_unit === "g") {
        g = g * 9.807;
      }

      // Perform calculations
      if (method === "tof") {
        let tof =
          h === 0
            ? (2 * vy) / g
            : (vy + Math.sqrt(Math.pow(vy, 2) + 2 * g * h)) / g;

        param.tech_check = "tof";
        param.tech_tof = sigFig(tof, 4);
      } else if (method === "range") {
        let r =
          h === 0
            ? (2 * vx * vy) / g
            : vx * ((vy + Math.sqrt(Math.pow(vy, 2) + 2 * g * h)) / g);

        param.tech_check = "range";
        param.tech_r = sigFig(r, 4);
      } else if (method === "mh") {
        let hmax =
          h === 0 ? Math.pow(vy, 2) / (2 * g) : h + Math.pow(vy, 2) / (2 * g);

        param.tech_check = "mh";
        param.tech_hmax = sigFig(hmax, 4);
      } else if (method === "fp" && isFinite(t)) {
        let x = vx * t;
        let y = h + vy * t - (g * Math.pow(t, 2)) / 2;
        let hv = vx;
        let vv = vy - g * t;
        let vel = Math.sqrt(hv ** 2 + vv ** 2);

        param.tech_check = "fp";
        param.tech_x = sigFig(x, 4);
        param.tech_y = sigFig(y, 4);
        param.tech_hv = sigFig(hv, 4);
        param.tech_vv = sigFig(vv, 4);
        param.tech_vel = sigFig(vel, 4);
      } else {
        return { error: "Please fill all fields." };
      }

      param.tech_g = sigFig(g, 4);
      param.tech_vx = sigFig(vx, 4);
      param.tech_vy = sigFig(vy, 4);
      return param;
    } else {
      return { error: "Please fill all fields." };
    }
  }

  /** getCalculationPotentialEnergycalculator
   * POST: /api/calculators-lol/potential-energy-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPotentialEnergycalculator(body) {
    let cal = body.tech_cal?.trim();
    let mass = parseFloat(body.tech_mass);
    let mass_unit = body.tech_mass_unit?.trim();
    let gravity = parseFloat(body.tech_gravity);
    let gravity_unit = body.tech_gravity_unit?.trim();
    let height = parseFloat(body.tech_height);
    let height_unit = body.tech_height_unit?.trim();
    let pe = parseFloat(body.tech_pe);
    let pe_unit = body.tech_pe_unit?.trim();

    const sigFig = (value, digits) => {
      if (value === 0) return 0;
      let d = digits - Math.floor(Math.log10(Math.abs(value))) - 1;
      let decimalPlaces = Math.max(0, Math.min(d, 100));
      return parseFloat(value.toFixed(decimalPlaces));
    };

    if (isFinite(mass)) {
      if (mass_unit === "ug") {
        mass = mass / 1000000000;
      } else if (mass_unit === "mg") {
        mass = mass * 1000000;
      } else if (mass_unit === "g") {
        mass = mass / 1000;
      } else if (mass_unit === "dag") {
        mass = mass / 100;
      } else if (mass_unit === "t") {
        mass = mass / 0.001;
      } else if (mass_unit === "gr") {
        mass = mass / 15432;
      } else if (mass_unit === "dr") {
        mass = mass / 564.4;
      } else if (mass_unit === "oz") {
        mass = mass / 35.274;
      } else if (mass_unit === "lb") {
        mass = mass / 2.2046;
      } else if (mass_unit === "stone") {
        mass = mass / 0.15747;
      } else if (mass_unit === "us_ton") {
        mass = mass / 0.0011023;
      } else if (mass_unit === "long_ton") {
        mass = mass / 0.0009842;
      } else if (mass_unit === "earths") {
        mass = mass * 5972000000000000000000000;
      } else if (mass_unit === "me") {
        mass = mass / 1097769122809886380500592292548;
      } else if (mass_unit === "u") {
        mass = mass / 602214000000000000000000000;
      } else if (mass_unit === "oz_t") {
        mass = mass / 32.15075;
      }
    }
    if (isFinite(gravity)) {
      if (gravity_unit === "cm_s2") {
        gravity = gravity * 0.01;
      } else if (gravity_unit === "in_s2") {
        gravity = gravity / 39.370078740157;
      } else if (gravity_unit === "mi_h_s") {
        gravity = gravity / 2.24;
      } else if (gravity_unit === "g") {
        gravity = gravity / 0.10193679918451;
      }
    }
    if (isFinite(height)) {
      if (height_unit === "mm") {
        height = height / 1000;
      } else if (height_unit === "cm") {
        height = height / 100;
      } else if (height_unit === "km") {
        height = height / 0.001;
      } else if (height_unit === "in") {
        height = height / 39.37;
      } else if (height_unit === "ft") {
        height = height / 3.281;
      } else if (height_unit === "yd") {
        height = height / 1.0936;
      } else if (height_unit === "mi") {
        height = height / 0.0006214;
      } else if (height_unit === "nmi") {
        height = height / 0.00054;
      }
    }

    let param = {};

    if (
      cal === "mass" &&
      isFinite(gravity) &&
      isFinite(height) &&
      isFinite(pe)
    ) {
      console.log(gravity, height);
      mass = pe * (gravity * height);
      param.tech_ans = sigFig(mass, 4);
      param.tech_unit = "kg";
      param.tech_g = gravity;
      param.tech_h = height;
      param.tech_pe = pe;
    } else if (
      cal === "gravity" &&
      isFinite(mass) &&
      isFinite(height) &&
      isFinite(pe)
    ) {
      gravity = pe * (mass * height);
      param.tech_ans = sigFig(gravity, 4);
      param.tech_unit = "m/s²";
      param.tech_m = mass;
      param.tech_h = height;
      param.tech_pe = pe;
    } else if (
      cal === "height" &&
      isFinite(mass) &&
      isFinite(gravity) &&
      isFinite(pe)
    ) {
      height = pe * (mass * gravity);
      param.tech_ans = sigFig(height, 4);
      param.tech_unit = "m";
      param.tech_m = mass;
      param.tech_g = gravity;
      param.tech_pe = pe;
    } else if (
      cal === "pe" &&
      isFinite(mass) &&
      isFinite(gravity) &&
      isFinite(height)
    ) {
      pe = mass * gravity * height;
      param.tech_ans = sigFig(pe, 4);
      param.tech_unit = "J";
      param.tech_m = mass;
      param.tech_g = gravity;
      param.tech_h = height;
    } else {
      param.error = "Please fill all fields.";
      return param;
    }

    param.tech_cal = cal;
    param.tech_mass = sigFig(mass, 4);
    return param;
  }

  /** getCalculationWavelengthcalculator
   * POST: /api/calculators-lol/wavelength-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationWavelengthcalculator(body) {
    let find = body.tech_find?.trim();
    let velocity = parseFloat(body.tech_velocity);
    let velocity_unit = body.tech_velocity_unit?.trim();
    let frequency = parseFloat(body.tech_frequency);
    let frequency_unit = body.tech_frequency_unit?.trim();
    let wavelength = parseFloat(body.tech_wavelength);
    let wavelength_unit = body.tech_wavelength_unit?.trim();

    let result = {};

    if (!isNaN(wavelength)) {
      if (wavelength_unit === "nm") {
        wavelength = wavelength / 1000000000;
      } else if (wavelength_unit === "um") {
        wavelength = wavelength / 1000000;
      } else if (wavelength_unit === "mm") {
        wavelength = wavelength / 1000;
      } else if (wavelength_unit === "cm") {
        wavelength = wavelength / 100;
      } else if (wavelength_unit === "km") {
        wavelength = wavelength / 0.001;
      } else if (wavelength_unit === "in") {
        wavelength = wavelength / 39.3701;
      } else if (wavelength_unit === "ft") {
        wavelength = wavelength / 3.28084;
      } else if (wavelength_unit === "yd") {
        wavelength = wavelength / 1.093613;
      } else if (wavelength_unit === "mi") {
        wavelength = wavelength / 0.000621371;
      }
    }
    if (!isNaN(frequency)) {
      if (frequency_unit === "khz") {
        frequency = frequency / 0.001;
      } else if (frequency_unit === "mhz") {
        frequency = frequency / 0.000001;
      } else if (frequency_unit === "ghz") {
        frequency = frequency / 0.000000001;
      } else if (frequency_unit === "thz") {
        frequency = frequency / 0.000000000001;
      }
    }
    if (!isNaN(velocity)) {
      if (velocity_unit === "cms") {
        velocity = velocity / 100;
      } else if (velocity_unit === "kmh") {
        velocity = velocity / 3.6;
      } else if (velocity_unit === "fts") {
        velocity = velocity / 3.28084;
      } else if (velocity_unit === "mph") {
        velocity = velocity / 2.236936;
      } else if (velocity_unit === "knots") {
        velocity = velocity / 1.943844;
      } else if (velocity_unit === "c") {
        velocity = velocity / 0.00000000333564;
      }
    }

    if (find === "wavelength" && !isNaN(frequency) && !isNaN(velocity)) {
      wavelength = velocity / frequency;
      const wavenumber = frequency / velocity;
      result = {
        tech_unit: "m",
        tech_ans: wavelength,
        tech_wn: wavenumber.toFixed(12),
        tech_wavelength: wavelength,
        tech_velocity: velocity,
        tech_find: find,
      };
    } else if (find === "frequency" && !isNaN(wavelength) && !isNaN(velocity)) {
      frequency = velocity / wavelength;
      const wavenumber = frequency / velocity;
      result = {
        tech_unit: "Hz",
        tech_ans: frequency,
        tech_wn: wavenumber.toFixed(12),
        tech_wavelength: wavelength,
        tech_velocity: velocity,
        tech_find: find,
      };
    } else if (find === "velocity" && !isNaN(wavelength) && !isNaN(frequency)) {
      velocity = frequency * wavelength;
      const wavenumber = frequency / velocity;
      result = {
        tech_unit: "m/s",
        tech_ans: velocity,
        tech_wn: wavenumber.toFixed(12),
        tech_wavelength: wavelength,
        tech_frequency: frequency,
        tech_find: find,
      };
    } else {
      result = {
        error: "Please fill all fields.",
      };
    }

    return result;
  }

  /** getCalculationSpringConstantcalculator
   * POST: /api/calculators-lol/spring-constant-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationSpringConstantcalculator(body) {
    let selection = body.tech_selection?.trim();
    let val1 = parseFloat(body.tech_spring_constant);
    let val2 = parseFloat(body.tech_spring_displacement);
    let val3 = parseFloat(body.tech_spring_force);
    let spring_displacement_unit = body.tech_spring_displacement_unit?.trim();

    let result = {};

    // Displacement unit conversion to meters
    const convertToMeters = (value, unit) => {
      if (unit === "m") return value;
      if (unit === "mm") return value / 1000;
      if (unit === "cm") return value / 100;
      if (unit === "inches") return value / 39.3701;
      if (unit === "feet") return value / 3.28084;
      if (unit === "yards") return value / 1.093613;
      return value;
    };

    // Displacement unit conversion from meters
    const convertFromMeters = (value, unit) => {
      if (unit === "m") return value;
      if (unit === "mm") return value * 1000;
      if (unit === "cm") return value * 100;
      if (unit === "inches") return value * 39.3701;
      if (unit === "feet") return value * 3.28084;
      if (unit === "yards") return value * 1.093613;
      return value;
    };

    if (selection === "1") {
      if (!isNaN(val1) && !isNaN(val2)) {
        let displacement = convertToMeters(val2, spring_displacement_unit);
        let force = -1 * displacement * val1;
        result.tech_fahad1 = force;
      } else {
        result.error = "Please fill all fields.";
      }
    } else if (selection === "2") {
      if (!isNaN(val2) && !isNaN(val3)) {
        let springConstant = val3 / val2;
        let converted =
          -1 * convertFromMeters(springConstant, spring_displacement_unit);
        result.tech_fahad2 = converted;
      } else {
        result.error = "Please fill all fields.";
      }
    } else if (selection === "3") {
      if (!isNaN(val1) && !isNaN(val3)) {
        let an = val3 / val1;
        result.tech_an = an;
        result.tech_ans = -1 * (an * 1000); // mm
        result.tech_ans1 = -1 * (an * 100); // cm
        result.tech_ans2 = -1 * (an * 39.3701); // inches
        result.tech_ans3 = -1 * (an * 3.28084); // feet
        result.tech_ans4 = -1 * (an * 1.093613); // yards
      } else {
        result.error = "Please fill all fields.";
      }
    }

    return result;
  }

  /** getCalculationDewPointcalculator
   * POST: /api/calculators-lol/dew-point-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDewPointcalculator(body) {
    let to_cal = body.tech_to_cal;
    let temp = parseFloat(body.tech_temp);
    let temp_unit = body.tech_temp_unit;
    let hum = parseFloat(body.tech_hum);
    let dew = parseFloat(body.tech_dew);
    let dew_unit = body.tech_dew_unit;

    let result = {};
    const a = 17.62;
    const b = 243.12;

    // Convert units to °C
    if (temp_unit == "°C") {
      temp_unit = 1;
    } else if (temp_unit == "°F") {
      temp_unit = 2;
    } else if (temp_unit == "K") {
      temp_unit = 3;
    }

    if (dew_unit == "°C") {
      dew_unit = 1;
    } else if (dew_unit == "°F") {
      dew_unit = 2;
    } else if (dew_unit == "K") {
      dew_unit = 3;
    }

    if (to_cal === "1") {
      if (!isNaN(temp) && !isNaN(hum)) {
        if (temp_unit === "2") {
          temp = ((temp - 32) * 5) / 9;
        } else if (temp_unit === "3") {
          temp = temp - 273.15;
        }

        if (temp < -45) {
          result.error =
            "Temperature should be greater than or equal to -45 °C (-49 °F)";
          return result;
        }

        let afun = Math.log(hum / 100) + (a * temp) / (b + temp);
        let dp = (b * afun) / (a - afun);

        result.tech_dew = dp;
      } else {
        result.error = "Please fill all fields.";
      }
    } else if (to_cal === "2") {
      if (!isNaN(dew) && !isNaN(temp)) {
        if (temp_unit === "2") {
          temp = ((temp - 32) * 5) / 9;
        } else if (temp_unit === "3") {
          temp = temp - 273.15;
        }
        if (dew_unit === "2") {
          dew = ((dew - 32) * 5) / 9;
        } else if (dew_unit === "3") {
          dew = dew - 273.15;
        }

        if (temp < -45 || dew < -45) {
          result.error =
            "Temperature should be greater than or equal to -45 °C (-49 °F)";
          return result;
        }

        let rh_numer = 100.0 * Math.exp((a * dew) / (dew + b));
        let rh_denom = Math.exp((a * temp) / (temp + b));
        hum = rh_numer / rh_denom;

        result.tech_hum = hum;
      } else {
        result.error = "Please fill all fields.";
      }
    } else if (to_cal === "3") {
      if (!isNaN(hum) && !isNaN(dew)) {
        if (dew_unit === "2") {
          dew = ((dew - 32) * 5) / 9;
        } else if (dew_unit === "3") {
          dew = dew - 273.15;
        }
        if (dew < -45) {
          result.error =
            "Temperature should be greater than or equal to -45 °C (-49 °F)";
          return result;
        }

        let gamma = (a * dew) / (b + dew);
        let temp_numer = b * (gamma - Math.log(hum / 100));
        let temp_denom = a + Math.log(hum / 100) - gamma;
        temp = temp_numer / temp_denom;

        result.tech_temp = temp;
      } else {
        result.error = "Please fill all fields.";
      }
    }

    return result;
  }

  /** getCalculationWetBulbcalculator
   * POST: /api/calculators-lol/wet-bulb-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationWetBulbcalculator(body) {
    let temp = parseFloat(body.tech_temp);
    let temp_unit = body.tech_temp_unit;
    let temp1 = parseFloat(body.tech_temp1);
    let temp1_unit = body.tech_temp1_unit;
    let hum = parseFloat(body.tech_hum);

    let result = {};

    // Convert units to °C
    if (temp_unit == "°C") {
      temp_unit = 1;
    } else if (temp_unit == "°F") {
      temp_unit = 2;
    } else if (temp_unit == "K") {
      temp_unit = 3;
    }

    if (temp1_unit == "°C") {
      temp1_unit = 1;
    } else if (temp1_unit == "°F") {
      temp1_unit = 2;
    } else if (temp1_unit == "K") {
      temp1_unit = 3;
    }

    if (!isNaN(temp) && !isNaN(hum)) {
      if (temp_unit == "2") {
        temp = ((temp - 32) * 5) / 9;
      } else if (temp_unit == "3") {
        temp = temp - 273.15;
      }

      if (temp < -20 || temp > 50) {
        result.error =
          "This calculator only works for temperatures between -20 °C and 50 °C.";
        return result;
      }

      let ans =
        temp * Math.atan(0.151977 * Math.sqrt(hum + 8.313659)) +
        Math.atan(temp + hum) -
        Math.atan(hum - 1.676331) +
        0.00391838 * Math.pow(hum, 1.5) * Math.atan(0.023101 * hum) -
        4.686035;

      let indoor = 0.7 * ans + 0.3 * temp;
      result.tech_ans = ans;
      result.tech_indoor = indoor;

      if (!isNaN(temp1)) {
        if (temp1_unit === "2") {
          temp1 = ((temp1 - 32) * 5) / 9;
        } else if (temp1_unit === "3") {
          temp1 = temp1 - 273.15;
        }

        let outdoor = 0.7 * ans + 0.2 * temp1 + 0.1 * temp;
        result.tech_outdoor = outdoor;
      }
    } else {
      result.error = "Please fill all fields.";
    }

    return result;
  }

  /** getCalculationTerminalVelocityCalculator
   * POST: /api/calculators-lol/terminal-velocity-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationTerminalVelocityCalculator(body) {
    let shapes = body.tech_shapes;
    let mass = body.tech_mass;
    let mass_unit = body.tech_mass_unit;
    let area = body.tech_area;
    let area_unit = body.tech_area_unit;
    let drag_coefficient = body.tech_drag_coefficient;
    let density = body.tech_density;
    let density_unit = body.tech_density_unit;
    let gravity = body.tech_gravity;
    let gravity_unit = body.tech_gravity_unit;

    function convertMass(value, unit) {
      switch (unit) {
        case "mg":
          return value * 0.000001;
        case "g":
          return value * 0.001;
        case "kg":
          return value * 1;
        case "t":
          return value * 1000;
        case "gr":
          return value * 0.0000648;
        case "oz":
          return value * 0.02835;
        case "lb":
          return value * 0.4536;
        default:
          return null;
      }
    }

    function convertArea(value, unit) {
      switch (unit) {
        case "mm²":
          return value * 0.000001;
        case "cm²":
          return value * 0.001;
        case "m²":
          return value * 1;
        case "in²":
          return value * 1000;
        case "yd²":
          return value * 0.0000648;
        default:
          return null;
      }
    }

    function convertDensity(value, unit) {
      switch (unit) {
        case "kg/m³":
          return value * 1;
        case "lb cu/ft":
          return value * 16.02;
        case "g/cm³":
          return value * 1000;
        case "kg/cm³":
          return value * 1000000;
        default:
          return null;
      }
    }

    function convertGravity(value, unit) {
      switch (unit) {
        case "m/s²":
          return value * 1;
        case "ft/s²":
          return value * 0.3048;
        default:
          return null;
      }
    }

    if (
      !isNaN(mass) &&
      !isNaN(area) &&
      !isNaN(drag_coefficient) &&
      !isNaN(density) &&
      !isNaN(gravity) &&
      mass > 0 &&
      area > 0 &&
      drag_coefficient > 0 &&
      density > 0 &&
      gravity > 0
    ) {
      let m = convertMass(mass, mass_unit);
      let a = convertArea(area, area_unit);
      let f = convertDensity(density, density_unit);
      let d = convertGravity(gravity, gravity_unit);

      let terminal_velocity = Math.sqrt(
        (2 * m * d) / (f * a * drag_coefficient)
      );
      let drag_coefficient_area = a * drag_coefficient;

      return {
        tech_terminal_velocity: terminal_velocity,
        tech_drag_coefficient_area: drag_coefficient_area,
      };
    } else {
      return { error: "Please! Check Your Input" };
    }
  }

  /** getCalculationFrictionCalculator
   * POST: /api/calculators-lol/friction-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationFrictionCalculator(body) {
    let calculate = body.tech_calculate;
    let fr_co = body.tech_fr_co;
    let force = body.tech_force;
    let force_unit = body.tech_force_unit;
    let fr = body.tech_fr;
    let fr_unit = body.tech_fr_unit;
    let mass = body.tech_mass;
    let plane = body.tech_plane;
    let gravity = body.tech_gravity;

    function frictionUnit(unit, value) {
      switch (unit) {
        case "N":
          return value * 1;
        case "kN":
          return value * 1000;
        case "MN":
          return value * 1000000;
        case "GN":
          return value * 1000000000;
        case "TN":
          return value * 1000000000000;
        default:
          return null;
      }
    }

    let result = {};

    if (calculate === "1") {
      // Calculate Friction Coefficient
      if (!isNaN(force) && !isNaN(fr) && force > 0 && fr > 0) {
        let fr_value = frictionUnit(fr_unit, fr);
        let force_value = frictionUnit(force_unit, force);
        let friction_coefficient = fr_value / force_value;
        result.tech_friction_coefficient = friction_coefficient;
      } else {
        return { error: "Please fill all fields." };
      }
    } else if (calculate === "2") {
      // Calculate Normal Force
      if (!isNaN(fr) && !isNaN(fr_co) && fr > 0 && fr_co > 0) {
        let force_value = frictionUnit(fr_unit, fr);
        let calculate_force = force_value / fr_co;
        result.tech_calculate_force = calculate_force;
      } else {
        return { error: "Please fill all fields." };
      }
    } else if (calculate === "3") {
      // Friction
      if (!isNaN(force) && !isNaN(fr_co) && force > 0 && fr_co > 0) {
        let force_value = frictionUnit(force_unit, force);
        let friction = force_value * fr_co;
        result.tech_friction = friction;
      } else {
        return { error: "Please fill all fields." };
      }
    } else if (calculate === "4") {
      // Inclined Plane Friction
      if (
        !isNaN(mass) &&
        !isNaN(plane) &&
        !isNaN(fr_co) &&
        !isNaN(gravity) &&
        mass > 0
      ) {
        if (fr_co > 0 && fr_co < 1) {
          let read = Math.cos((plane * Math.PI) / 180);
          let force_value = fr_co * mass * gravity * read;
          result.tech_friction2 = force_value;
        } else {
          return {
            error:
              "Please! Coefficient of friction should be in the range between 0 and 1",
          };
        }
      } else {
        return { error: "Please fill all fields." };
      }
    } else {
      return { error: "Invalid calculation option." };
    }

    return result;
  }

  /** getCalculationEscapeVelocityCalculator
   * POST: /api/calculators-lol/escape-velocity-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationEscapeVelocityCalculator(body) {
    let planet = body.tech_planet;
    let mass = body.tech_mass;
    let mass_unit = body.tech_mass_unit;
    let radius = body.tech_radius;
    let radius_unit = body.tech_radius_unit;
    let orbit = body.tech_orbit;
    let gravity = body.tech_gravity;
    let galaxy_mass = body.tech_galaxy_mass;
    let find = body.tech_find;
    let escape_velocity = body.tech_escape_velocity;
    let escape_unit = body.tech_escape_unit;

    function planetUnit(unit, value) {
      switch (unit) {
        case "kg":
          return value * 1;
        case "t":
          return value * 1000;
        case "lb":
          return value * 0.453592;
        case "oz":
          return value * 0.0283495;
        default:
          return null;
      }
    }

    function escapeUnit(unit2, value2) {
      switch (unit2) {
        case "m/s":
          return value2 * 1;
        case "km/h":
          return value2 * 0.277778;
        case "mph":
          return value2 * 0.44704;
        case "km/s":
          return value2 * 1000;
        default:
          return null;
      }
    }

    let result = {};

    if (find === "1") {
      // Find Escape Velocity
      if (
        !isNaN(mass) &&
        !isNaN(radius) &&
        !isNaN(orbit) &&
        !isNaN(gravity) &&
        !isNaN(galaxy_mass)
      ) {
        let method = 1;
        let mass_value = planetUnit(mass_unit, mass);
        let first = (2 * gravity * mass_value) / radius;
        let escape_velocity = Math.sqrt(first / 1000) / 1000;
        let second = (gravity * mass_value) / radius;
        let first_cosmic_velocity = Math.sqrt(second / 1000) / 1000;
        let third = orbit * 1.496e11;
        let orbital_speed = Math.sqrt((gravity * galaxy_mass) / third);
        let orbit_period = Math.sqrt(orbit * orbit * orbit);

        result.tech_escape_velocity = escape_velocity;
        result.tech_first_cosmic_velocity = first_cosmic_velocity;
        result.tech_orbital_speed = orbital_speed;
        result.tech_orbital_period = orbit_period;
        result.tech_method = method;
      } else {
        return { error: "Please fill all fields." };
      }
    } else if (find === "2") {
      // Find Mass
      if (
        !isNaN(escape_velocity) &&
        !isNaN(radius) &&
        !isNaN(orbit) &&
        !isNaN(gravity) &&
        !isNaN(galaxy_mass)
      ) {
        let method = 2;
        let escape_value = escapeUnit(escape_unit, escape_velocity);
        let find_mass = (escape_value ** 2 * radius) / (2 * gravity);
        let first_cosmic_velocity = Math.sqrt(2) / escape_value;
        let third = orbit * 1.496e11;
        let orbital_speed = Math.sqrt((gravity * galaxy_mass) / third);
        let orbit_period = Math.sqrt(orbit * orbit * orbit);

        result.tech_method = method;
        result.tech_escape_velocity = escape_velocity;
        result.tech_first_cosmic_velocity = first_cosmic_velocity;
        result.tech_orbital_speed = orbital_speed;
        result.tech_mass_value = find_mass;
        result.tech_orbital_period = orbit_period;
        return result;
      } else {
        return { error: "Please fill all fields." };
      }
    } else if (find === "3") {
      // Find Radius
      if (
        !isNaN(escape_velocity) &&
        !isNaN(mass) &&
        !isNaN(orbit) &&
        !isNaN(gravity) &&
        !isNaN(galaxy_mass)
      ) {
        let method = 3;
        let escape_value = escapeUnit(escape_unit, escape_velocity);
        let mass_value = planetUnit(mass_unit, mass);
        let find_radius = (2 * gravity * mass_value) / escape_value ** 2;
        let radius_value = find_radius / 1000;
        let first_cosmic_velocity = Math.sqrt(2) / escape_value;
        let third = orbit * 1.496e11;
        let orbital_speed = Math.sqrt((gravity * galaxy_mass) / third);
        let orbit_period = Math.sqrt(orbit * orbit * orbit);

        result.tech_method = method;
        result.tech_escape_velocity = escape_velocity;
        result.tech_mass_value = radius_value;
        result.tech_first_cosmic_velocity = first_cosmic_velocity;
        result.tech_orbital_speed = orbital_speed;
        result.tech_orbital_period = orbit_period;
      } else {
        return { error: "Please fill all fields." };
      }
    }

    return result;
  }

  /** getCalculationGravityCalculator
   * POST: /api/calculators-lol/gravity-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationGravityCalculator(body) {
    let calculate = body.tech_calculate;
    let mass_one = body.tech_mass_one;
    let mass_one_unit = body.tech_mass_one_unit;
    let mass_two = body.tech_mass_two;
    let mass_two_unit = body.tech_mass_two_unit;
    let gravitational_force = body.tech_gravitational_force;
    let gravitational_force_unit = body.tech_gravitational_force_unit;
    let distance = body.tech_distance;
    let distance_unit = body.tech_distance_unit;
    let constant = body.tech_constant;
    let latitude = body.tech_latitude;
    let height = body.tech_height;
    let height_unit = body.tech_height_unit;

    const param = {};

    const distance_converts = (unit, value) => {
      const map = {
        nm: value * 1e-9,
        μm: value * 1e-6,
        mm: value * 1e-3,
        cm: value * 1e-2,
        m: value,
        km: value * 1e3,
        in: value * 0.0254,
        ft: value * 0.3048,
        yd: value * 0.9144,
      };
      return map[unit] ?? 0;
    };

    const mass_convert = (unit, value) => {
      const map = {
        g: value * 1e-3,
        kg: value,
        t: value * 1e3,
        oz: value * 0.0283495,
        lb: value * 0.453592,
        stone: value * 6.35029,
        "US ton": value * 907.185,
        "Long ton": value * 1016.047,
        Earths: value * 5.9722e24,
        Suns: value * 1.989e30,
        me: 0,
        mp: 0,
        mn: 0,
      };
      return map[unit] ?? 0;
    };

    const force_converts = (unit, value) => {
      const map = {
        mN: value * 1e-3,
        N: value,
        kN: value * 1e3,
        MN: value * 1e6,
        GN: value * 1e9,
        TN: value * 1e12,
        pdl: value * 0.138255,
        lbf: value * 4.44822,
      };
      return map[unit] ?? 0;
    };

    const height_u = (unit, value) => {
      return unit === "m" ? value * 3.28084 : value;
    };

    let buttler = constant * 0.00000000001;

    if (calculate === "1") {
      // Gravitational Force
      if (mass_one > 0 && mass_two > 0 && distance > 0) {
        let m1 = mass_convert(mass_one_unit, mass_one);
        let m2 = mass_convert(mass_two_unit, mass_two);
        let d = distance_converts(distance_unit, distance);
        let force = (buttler * m1 * m2) / (d * d);
        param.tech_force = force;
      } else {
        return { error: "Please fill all fields." };
      }
    } else if (calculate === "2") {
      // Mass 1
      if (mass_two > 0 && distance > 0 && gravitational_force > 0) {
        let f = force_converts(gravitational_force_unit, gravitational_force);
        let m2 = mass_convert(mass_two_unit, mass_two);
        let d = distance_converts(distance_unit, distance);
        let m1 = (f * d * d) / (buttler * m2);
        param.tech_first_mass = m1;
      } else {
        return { error: "Please fill all fields." };
      }
    } else if (calculate === "3") {
      // Mass 2
      if (mass_one > 0 && distance > 0 && gravitational_force > 0) {
        let f = force_converts(gravitational_force_unit, gravitational_force);
        let m1 = mass_convert(mass_one_unit, mass_one);
        let d = distance_converts(distance_unit, distance);
        let m2 = (f * d * d) / (buttler * m1);
        param.tech_second_mass = m2;
      } else {
        return { error: "Please fill all fields." };
      }
    } else if (calculate === "4") {
      // Distance
      if (mass_one > 0 && mass_two > 0 && gravitational_force > 0) {
        let f = force_converts(gravitational_force_unit, gravitational_force);
        let m1 = mass_convert(mass_one_unit, mass_one);
        let m2 = mass_convert(mass_two_unit, mass_two);
        console.log(buttler, m1, m2, f);
        let d = (buttler * m1 * m2) / f;
        param.tech_distance = d;
      } else {
        return { error: "Please fill all fields." };
      }
    } else if (calculate === "5") {
      // Gravity at latitude/height
      if (!isNaN(latitude) && !isNaN(height)) {
        let h = height_u(height_unit, height);
        let phi = latitude * (Math.PI / 180);
        let g =
          9.780327 *
          (1 +
            0.0053024 * Math.sin(phi) ** 2 -
            0.0000058 * Math.sin(2 * phi) ** 2);
        g += -3.086e-6 * h;
        param.tech_g = g;
      } else {
        return { error: "Please fill all fields." };
      }
    }

    return param;
  }

  /** getCalculationArrowSpeedCalculator
   * POST: /api/calculators-lol/arrow-speed-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationArrowSpeedCalculator(body) {
    let first = body.tech_first;
    let units1 = body.tech_units1;
    let second = body.tech_second;
    let units2 = body.tech_units2;
    let third = body.tech_third;
    let units3 = body.tech_units3;
    let four = body.tech_four;
    let units4 = body.tech_units4;
    let five = body.tech_five;
    let units5 = body.tech_units5;

    function unit1(a, b) {
      if (a === "m/s") return b * 3.281;
      if (a === "km/h") return b / 1.097;
      if (a === "ft/s") return b;
      if (a === "mph") return b * 1.467;
      if (a === "knots") return b * 1.688;
    }

    function unit2(a, b) {
      if (a === "mm") return b / 25.4;
      if (a === "cm") return b / 2.54;
      if (a === "m") return b * 39.37;
      if (a === "km") return b * 39370;
      if (a === "in") return b;
      if (a === "ft") return b * 12;
      if (a === "yd") return b * 36;
      if (a === "mi") return b * 63360;
      if (a === "nmi") return b * 72910;
    }

    function unit3(a, b) {
      if (a === "g") return b / 453.6;
      if (a === "kg") return b * 2.205;
      if (a === "gr") return b / 7000;
      if (a === "oz") return b / 16;
      if (a === "lb") return b;
      if (a === "stone") return b * 14;
    }

    function unit4(a, b) {
      if (a === "mg") return b / 64.799;
      if (a === "g") return b * 15.432;
      if (a === "dag") return b * 154.3;
      if (a === "kg") return b * 15430;
      if (a === "gr") return b;
      if (a === "dr") return b * 60;
      if (a === "oz") return b * 437.5;
      if (a === "lb") return b * 7000;
      if (a === "stone") return b * 98000;
    }

    first = unit1(units1, first);
    second = unit2(units2, second);
    third = unit3(units3, third);
    four = unit4(units4, four);
    five = unit4(units5, five);

    if (
      isFinite(first) &&
      isFinite(second) &&
      isFinite(third) &&
      isFinite(four) &&
      isFinite(five)
    ) {
      let minus1 = second - 30;
      let mul1 = minus1 * 10;
      let div1 = five / 3;
      let part1 = first + mul1 - div1;

      let mul2 = 5 * third;
      let minus2 = four - mul2;
      let div2 = minus2 / 3;
      let minus_mul = div2 * -1;
      let part2 = Math.min(0, minus_mul);

      let speed = part1 + part2;
      let s_ms = speed / 3.281;
      let w_kg = four / 15430;
      let momentum = s_ms * w_kg;
      let sq_speed = Math.pow(s_ms, 2);
      let last_mul = w_kg * sq_speed;
      let k_energy = last_mul / 2;

      return {
        tech_speed: speed,
        tech_momentum: momentum,
        tech_k_energy: k_energy,
      };
    } else {
      return {
        error: "Please fill all fields.",
      };
    }
  }

  /** getCalculationElectricityCostCalculator
   * POST: /api/calculators-lol/electricity-cost-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationElectricityCostCalculator(body) {
    let type = body.tech_unit_type;

    let f_first = body.tech_f_first;
    let f_second = body.tech_f_second;
    let f_third = body.tech_f_third;

    let first = body.tech_first;
    let units1 = body.tech_units1;
    let second = body.tech_second;

    let third = body.tech_third;
    let units3 = body.tech_units3;

    function watt(a, b) {
      if (a === "mW") return b / 1000;
      if (a === "W") return b;
      if (a === "kW") return b * 1000;
      if (a === "MW") return b * 1000000;
      if (a === "GW") return b * 1000000000;
      if (a === "BTU") return b * 0.293071;
      if (a === "hp(l)") return b * 745.7;
    }

    function mont(a, b) {
      if (a === "days") return b * 30.4375;
      if (a === "wks") return b * 4.34821;
      if (a === "mons") return b;
      if (a === "yrs") return b * 0.0833333;
    }

    let answer, cost;

    if (type === "simple") {
      first = watt(units1, first);
      third = mont(units3, third);

      if (isFinite(first) && isFinite(second) && isFinite(third)) {
        let multiply = first * third;
        answer = multiply / 1000;
        cost = answer * second;
      } else {
        return { error: "Please fill all fields." };
      }
    } else if (type === "advance") {
      if (isFinite(f_first) && isFinite(f_second) && isFinite(f_third)) {
        let mul1 = f_second * 30;
        let mul2 = mul1 * f_first;
        answer = mul2 / 1000;
        cost = answer * f_third;
      } else {
        return { error: "Please fill all fields." };
      }
    }

    return {
      tech_answer: answer,
      tech_cost: cost,
    };
  }

  /** getCalculationAirDensityCalculator
   * POST: /api/calculators-lol/air-density-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationAirDensityCalculator(body) {
    let first = body.tech_first;
    let unit1 = body.tech_unit1;
    let second = body.tech_second;
    let unit2 = body.tech_unit2;
    let operations1 = body.tech_operations1;
    let third = body.tech_third;

    let convert1, convert2;
    function pascal(a, b) {
      if ((a = "Pa")) {
        convert1 = b * 1;
      } else if ((a = "mb")) {
        convert1 = b * 100;
      } else if ((a = "bar")) {
        convert1 = b * 100000;
      } else if ((a = "psi")) {
        convert1 = b * 6895;
      } else if ((a = "atm")) {
        convert1 = b * 101325;
      } else if ((a = "torr")) {
        convert1 = b * 133.32;
      } else if ((a = "hPa")) {
        convert1 = b * 100;
      } else if ((a = "kPa")) {
        convert1 = b * 1000;
      } else if ((a = "inHg")) {
        convert1 = b * 3386.4;
      } else if ((a = "mmHg")) {
        convert1 = b * 133.32;
      }
      return convert1;
    }
    function kelvinC(a, b) {
      if ((a = "°C")) {
        convert2 = b * 1;
      } else if ((a = "°F")) {
        convert2 = (b - 32) * 0.55555555555555555555555555555556;
      } else if ((a = "K")) {
        convert2 = b - 273.15;
      }
      return convert2;
    }
    function kelvinK(a, b) {
      if ((a = "°C")) {
        convert2 = b + 274.15;
      } else if ((a = "°F")) {
        convert2 = (b - 32) * 0.55555555555555555555555555555556 + 273.15;
      } else if ((a = "K")) {
        convert2 = b * 1;
      }
      return convert2;
    }

    let result = { tech_operations1: operations1 };

    if (operations1 == "1") {
      first = pascal(unit1, first);
      // console.log(second,'ggg');
      second = kelvinK(unit2, second);

      if (isFinite(first) && isFinite(second)) {
        let mul = second * 287.05;
        console.log(first, mul);
        result.tech_air_density = first / mul;
      } else {
        return { error: "Please fill all fields." };
      }
    } else if (operations1 == "2") {
      first = pascal(unit1, first);
      second = kelvinC(unit2, second);

      if (isFinite(first) && isFinite(second) && isFinite(third)) {
        if (third > 0) {
          let P = first / 6895;
          let T = second * 1.8 + 32 + 459.67;
          let psi = third / 100;
          let Md = 28.97;
          let Mw = 18.0;
          let Rbar = 1545;
          let ps =
            0.08865 *
            Math.exp((-0.002369 * (T - 8375.65) * (T - 491.67)) / (T - 28.818));
          let air_density =
            ((P * Md + psi * ps * (Mw - Md)) / Rbar / T / 12 / 32.174) *
            12 *
            12 *
            12;

          let add = second + 237.3;
          let mul1 = 7.5 * second;
          let div = mul1 / add;
          let base = Math.pow(10, div);
          let p1 = base * 6.1078;
          let pv = p1 * third;
          let pd = first - pv;
          let d_mul1 = 287.058 * first;
          let d_mul2 = third * first;

          let l_div = d_mul1 === 0 ? 0 : pd / d_mul1;
          let r_div = d_mul2 === 0 ? 0 : pv / d_mul2;

          let p = l_div + r_div;
          let a_ln = Math.log10(third / 100);
          let a = a_ln + (17.62 * second) / (243.12 + second);
          let dp = (243.12 * a) / (17.62 - a);

          result.tech_dp = dp;
          result.tech_pv = pv;
          result.tech_pd = pd;
          result.tech_air_density = air_density;
        } else {
          return { error: "Relative humidity must be greater than zero!" };
        }
      } else {
        return { error: "Please fill all fields." };
      }
    }

    return result;
  }

  /** getCalculationTimeofFlightCalculator
   * POST: /api/calculators-lol/time-of-flight-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationTimeofFlightCalculator(body) {
    let a = parseFloat(body.tech_a);
    let a_unit = body.tech_a_unit?.trim();
    let h = parseFloat(body.tech_h);
    let h_unit = body.tech_h_unit?.trim();
    let v = parseFloat(body.tech_v);
    let v_unit = body.tech_v_unit?.trim();
    let g = parseFloat(body.tech_g);
    let g_unit = body.tech_g_unit?.trim();

    let param = {};

    function sigFig(value, digits) {
      if (value === 0) {
        return 0;
      }
      const decimalPlaces =
        digits - Math.floor(Math.log10(Math.abs(value))) - 1;
      return parseFloat(value.toFixed(decimalPlaces));
    }

    if (
      !isNaN(a) &&
      !isNaN(h) &&
      !isNaN(v) &&
      !isNaN(g) &&
      a_unit &&
      h_unit &&
      v_unit &&
      g_unit
    ) {
      // Convert height
      if (h_unit === "cm") h /= 100;
      else if (h_unit === "km") h /= 0.001;
      else if (h_unit === "in") h /= 39.37;
      else if (h_unit === "ft") h /= 3.281;
      else if (h_unit === "yd") h /= 1.0936;
      else if (h_unit === "mi") h /= 0.0006214;

      // Convert velocity
      if (v_unit === "kmh") v /= 3.6;
      else if (v_unit === "fts") v /= 3.28;
      else if (v_unit === "mph") v /= 2.237;

      let vx, vy, sin;
      if (a_unit === "deg") {
        vx = v * Math.cos((a * Math.PI) / 180);
        sin = Math.sin((a * Math.PI) / 180);
        vy = v * sin;
      } else {
        vx = v * Math.cos(a);
        sin = Math.sin(a);
        vy = v * sin;
      }

      // Convert gravity
      if (g_unit === "g") {
        g = g * 9.807;
      }

      let tof;
      if (h === 0) {
        const res = 2 * vy;
        tof = (2 * vy) / g;
        param["res"] = sigFig(res, 4);
      } else {
        const gh = 2 * g * h;
        const pvy = Math.pow(vy, 2);
        const vs2gh = pvy + gh;
        const sqrvs2gh = Math.sqrt(vs2gh);
        const vysqrt = vy + sqrvs2gh;
        tof = vysqrt / g;

        param["tech_pvy"] = pvy;
        param["tech_gh"] = gh;
        param["tech_vs2gh"] = vs2gh;
        param["tech_sqrvs2gh"] = sqrvs2gh;
        param["tech_vysqrt"] = sigFig(vysqrt, 4);
      }

      param["tech_h"] = h;
      param["tech_a"] = a;
      param["tech_sin"] = sigFig(sin, 4);
      param["tech_v"] = sigFig(v, 4);
      param["tech_tof"] = sigFig(tof, 4);
      param["tech_check"] = "tof";
      param["tech_g"] = sigFig(g, 4);
      param["tech_vx"] = sigFig(vx, 4);
      param["tech_vy"] = sigFig(vy, 4);
      return param;
    } else {
      return { error: "Please fill all fields." };
    }
  }

  /** getCalculationFrictionalForceCalculator
   * POST: /api/calculators-lol/frictional-force-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationFrictionalForceCalculator(body) {
    let calculate = body.tech_calculate;
    let fr_co = parseFloat(body.tech_fr_co);
    let force = parseFloat(body.tech_force);
    let force_unit = body.tech_force_unit?.trim();
    let fr = parseFloat(body.tech_fr);
    let fr_unit = body.tech_fr_unit?.trim();
    let mass = parseFloat(body.tech_mass);
    let plane = parseFloat(body.tech_plane);
    let gravity = parseFloat(body.tech_gravity);

    let param = {};

    function frictional_unit(unit, value) {
      switch (unit) {
        case "N":
          return value * 1;
        case "kN":
          return value * 1000;
        case "MN":
          return value * 1000000;
        case "GN":
          return value * 1000000000;
        case "TN":
          return value * 1000000000000;
        default:
          return NaN;
      }
    }

    if (calculate === "1") {
      // Calculate Friction Coefficient
      if (!isNaN(force) && !isNaN(fr) && force > 0 && fr > 0) {
        const fr_value = frictional_unit(fr_unit, fr);
        const force_value = frictional_unit(force_unit, force);
        const friction_coefficient = fr_value / force_value;

        param["tech_friction_coefficient"] = friction_coefficient;
        param["tech_fr_value"] = fr_value;
        param["tech_force_value"] = force_value;
      } else {
        return { error: "Please fill all fields." };
      }
    } else if (calculate === "2") {
      // Calculate Normal Force
      if (!isNaN(fr) && !isNaN(fr_co) && fr > 0 && fr_co > 0) {
        const force_value = frictional_unit(fr_unit, fr);
        const calculate_force = force_value / fr_co;

        param["tech_calculate_force"] = calculate_force;
        param["tech_force_value"] = force_value;
        param["tech_fr_co"] = fr_co;
      } else {
        return { error: "Please fill all fields." };
      }
    } else if (calculate === "3") {
      // Friction Force
      if (!isNaN(force) && !isNaN(fr_co) && force > 0 && fr_co > 0) {
        const force_value = frictional_unit(force_unit, force);
        const friction = force_value * fr_co;

        param["tech_friction"] = friction;
        param["tech_force_value"] = force_value;
        param["tech_fr_co"] = fr_co;
      } else {
        return { error: "Please fill all fields." };
      }
    } else if (calculate === "4") {
      // Inclined Plane Friction
      if (
        !isNaN(mass) &&
        !isNaN(plane) &&
        !isNaN(fr_co) &&
        !isNaN(gravity) &&
        mass > 0
      ) {
        if (fr_co > 0 && fr_co < 1) {
          const read = Math.cos((plane * Math.PI) / 180);
          const force_value = fr_co * mass * gravity * read;

          param["tech_friction2"] = force_value;
          param["tech_mass"] = mass;
          param["tech_fr_co"] = fr_co;
          param["tech_plane"] = plane;
          param["tech_read"] = read;
          param["tech_gravity"] = gravity;
        } else {
          return {
            error: "Please! Coefficient of friction should be between 0 and 1",
          };
        }
      } else {
        return { error: "Please fill all fields." };
      }
    }

    return param;
  }

  /** getCalculationMechanicalEnergyCalculator
   * POST: /api/calculators-lol/mechanical-energy-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMechanicalEnergyCalculator(body) {
    let mass = parseFloat(body.tech_mass);
    let mass_unit = body.tech_mass_unit?.trim();
    let velocity = parseFloat(body.tech_velocity);
    let velocity_unit = body.tech_velocity_unit?.trim();
    let height = parseFloat(body.tech_height);
    let height_unit = body.tech_height_unit?.trim();
    let engergyunit = body.tech_engergyunit?.trim();

    let param = {};

    function unit_kg(a, b) {
      switch (b) {
        case "kg":
          return a * 1;
        case "g":
          return a / 1000;
        case "mg":
          return a / 1000000;
        case "mu-gr":
          return a / 1000000000;
        case "ct":
          return a / 5000;
        case "lbs":
          return a / 2.205;
        case "troy":
          return a * 0.0311;
        case "ozm":
          return a * 0.02834952;
        case "slug":
          return a * 14.594;
        case "ton(short)":
          return a * 907.2;
        default:
          return NaN;
      }
    }

    function unit_ms(a, b) {
      switch (b) {
        case "m/s":
          return a * 1;
        case "ft/min":
          return a / 196.9;
        case "ft/s":
          return a / 3.281;
        case "km/hr":
          return a / 3.6;
        case "knot (int'l)":
          return a / 1.944;
        case "mph":
          return a / 2.237;
        case "miles/hr":
          return a / 1.151;
        case "miles/min":
          return a * 0.447 * 60;
        case "miles/s":
          return a / 1609;
        case "speed of light":
          return a * 299800000;
        default:
          return NaN;
      }
    }

    function unit_m(a, b) {
      switch (b) {
        case "m":
          return a * 1;
        case "AU":
          return a * 149600000000;
        case "cm":
          return a / 100;
        case "km":
          return a * 1000;
        case "ft":
          return a / 3.281;
        case "in":
          return a / 39.37;
        case "mil":
          return a / 39370;
        case "mm":
          return a / 1000;
        case "nm":
          return a / 1000000000;
        case "mile":
          return a * 1609;
        case "parsec":
          return a * 3.086e16;
        case "pm":
          return a / 1000000000000;
        case "yd":
          return a / 1.094;
        default:
          return NaN;
      }
    }

    function energy_unit(a, b) {
      switch (b) {
        case "1":
          return a * 1;
        case "2":
          return a / 1055;
        case "3":
          return a / 1055;
        case "4":
          return a * 0.239006;
        case "5":
          return a * 6.242e18;
        case "6":
          return a * 10000000;
        case "7":
          return a / 1.356;
        case "8":
          return a * 23.73036;
        case "9":
          return a * 0.0000003725061361;
        case "10":
          return a / 4184;
        case "11":
          return a / 3600000;
        case "12":
          return a / 4184000000;
        case "13":
          return a * 1;
        case "14":
          return a / 3600;
        case "15":
          return a * 1;
        default:
          return NaN;
      }
    }

    if (!isNaN(mass) && !isNaN(velocity) && !isNaN(height)) {
      mass = unit_kg(mass, mass_unit);
      velocity = unit_ms(velocity, velocity_unit);
      height = unit_m(height, height_unit);

      let kinatic_eng = 0.5 * mass * velocity ** 2;
      let potentional_eng = mass * 9.8 * height;
      let mechanical_eng = kinatic_eng + potentional_eng;

      let mechanical_energy = energy_unit(mechanical_eng, engergyunit);
      let kinatic_engrgy = energy_unit(kinatic_eng, engergyunit);
      let potentional_engergy = energy_unit(potentional_eng, engergyunit);

      param.tech_mass = mass;
      param.tech_velocity = velocity;
      param.tech_height = height;
      param.tech_kinatic_eng = kinatic_eng;
      param.tech_potentional_eng = potentional_eng;
      param.tech_mechanical_eng = mechanical_eng;
      param.tech_mechanical_energy = mechanical_energy;
      param.tech_kinatic_engrgy = kinatic_engrgy;
      param.tech_potentional_engergy = potentional_engergy;
    } else {
      return { error: "Please fill all fields." };
    }

    return param;
  }

  /** getCalculationIndexOfRefractionCalculation
   * POST: /api/calculators-lol/index-of-refraction-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationIndexOfRefractionCalculation(body) {
    let selection = body.tech_selection?.trim();
    let medium_v = body.tech_medium_v?.trim();
    let medium_value = parseFloat(body.tech_medium_value);
    let medium_value_unit = body.tech_medium_value_unit?.trim();
    let medium_value_unit1 = body.tech_medium_value_unit1?.trim();
    let medium_v2 = body.tech_medium_v2?.trim();
    let medium_value2 = parseFloat(body.tech_medium_value2);

    let param = {};

    function speed_unit(a, b) {
      if (b == "m/s") {
        return a / 1000;
      } else if (b == "km/s") {
        return a * 1;
      } else if (b == "mi/s") {
        return a * 1.609;
      } else if (b == "c") {
        return a * 299800;
      } else {
        return NaN;
      }
    }
    if (selection === "1") {
      if (!isNaN(medium_value) && !isNaN(medium_value2)) {
        medium_value = speed_unit(medium_value, medium_value_unit);
        console.log(medium_value);
        let index_of_refraction = 299792.46 / medium_value;
        param.tech_index_of_refraction = index_of_refraction;
      } else {
        return { error: "Please fill all fields." };
      }
    } else if (selection === "2") {
      if (!isNaN(medium_value) && !isNaN(medium_value2)) {
        medium_value = speed_unit(medium_value, medium_value_unit);

        medium_value2 = speed_unit(medium_value2, medium_value_unit1);

        console.log(medium_value, medium_value2);

        let index_of_refraction = 299792.46 / medium_value;
        let index_of_refraction2 = 299792.46 / medium_value2;
        let reflective_index = index_of_refraction2 / index_of_refraction;
        param.tech_reflective_index = reflective_index;
      } else {
        return { error: "Please fill all fields." };
      }
    } else {
      return { error: "Invalid selection value." };
    }

    return param;
  }

  /** getCalculationWHPtoHPCalculation
   * POST: /api/calculators-lol/whp-to-hp-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationWHPtoHPCalculation(body) {
    let submit = body.tech_type;
    let dt = parseFloat(body.tech_dt);
    let whp = parseFloat(body.tech_whp);
    let dtlf = parseFloat(body.tech_dtlf);
    let ehp = parseFloat(body.tech_ehp);

    let param = {};

    if (submit === "whpToHp") {
      if (!isNaN(dt) && !isNaN(whp)) {
        let hp = whp / (1 - dt);
        param.tech_submit = submit;
        param.tech_whp = whp;
        param.tech_dt = dt;
        param.tech_hp = hp.toFixed(2);
      } else {
        param.error = "Please! Check Your Input";
      }
    } else {
      if (!isNaN(dtlf) && !isNaN(ehp)) {
        whp = ehp / dtlf;
        param.tech_submit = submit;
        param.tech_ehp = ehp;
        param.tech_dtlf = dtlf;
        param.tech_whp = whp.toFixed(2);
      } else {
        param.error = "Please! Check Your Input";
      }
    }

    return param;
  }

  /** getCalculationAverageSpeedCalculation
   * POST: /api/calculators-lol/average-speed-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationAverageSpeedCalculation(body) {
    let t_hours = parseFloat(body.tech_t_hours);
    let t_min = parseFloat(body.tech_t_min);
    let t_sec = parseFloat(body.tech_t_sec);
    let distance = parseFloat(body.tech_distance);
    let distance_unit = body.tech_distance_unit;

    let param = {};

    function speed_unitsadd(a, b) {
      if (b == "miles") {
        return a * 1609;
      } else if (b == "km") {
        return a * 1000;
      } else if (b == "yards") {
        return a / 1.094;
      } else if (b == "foot") {
        return a / 3.281;
      } else if (b == "meters") {
        return a;
      }
      return null;
    }

    if (!isNaN(t_hours) && !isNaN(t_min) && !isNaN(t_sec) && !isNaN(distance)) {
      let dis_val = speed_unitsadd(distance, distance_unit);
      console.log(dis_val);
      let total_seconds = t_hours * 3600 + t_min * 60 + t_sec;
      let ans_mps = dis_val / total_seconds;
      let ans_mphh = ans_mps * 3600;
      let ans_ydph = ans_mps * 3937;
      let ans_ftph = ans_mps * 11810;
      let ans_mph = ans_mps * 2.237;
      let ans_kmh = ans_mps * 3.6;

      param.tech_ans_mps = ans_mps;
      param.tech_ans_mph = ans_mph;
      param.tech_ans_kmh = ans_kmh;
      param.tech_ans_mphh = ans_mphh;
      param.tech_ans_ydph = ans_ydph;
      param.tech_ans_ftph = ans_ftph;
    } else {
      param.error = "Please fill all fields.";
    }

    return param;
  }

  /** getCalculationdBmtoWattsCalculation
   * POST: /api/calculators-lol/dbm-to-watts
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationdBmtoWattsCalculation(body) {
    let calculation = String(body.tech_calculation).trim();
    let input = parseFloat(body.tech_input);
    let param = {};

    if (!isNaN(input)) {
      let answer;
      let unit;

      if (calculation === "1") {
        let divide = input / 10;
        let pow = Math.pow(10, divide);
        answer = pow / 1000;
        unit = "W";
      } else if (calculation === "2") {
        let divide = input / 10;
        let pow = Math.pow(10, divide);
        let watts = pow / 1000;
        answer = watts * 1000;
        unit = "mW";
      } else if (calculation === "3") {
        answer = 10 * Math.log10(input) + 30;
        unit = "dBm";
      } else {
        let miliwatts = input * 1000;
        answer = 10 * Math.log10(miliwatts);
        unit = "dBm";
      }

      param.tech_unit = unit;
      param.tech_answer = answer;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /** getCalculationdCapacitanceCalculation
   * POST: /api/calculators-lol/capacitance-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationdCapacitanceCalculation(body) {
    let area = parseFloat(body.tech_area);
    let area_unit = String(body.tech_area_unit).trim();
    let permittivity = parseFloat(body.tech_permittivity);
    let distance = parseFloat(body.tech_distance);
    let dis_unit = String(body.tech_dis_unit).trim();
    let param = {};

    function areaConvert(a, b) {
      switch (b) {
        case "mm²":
          return a * 1;
        case "cm²":
          return a * 100;
        case "m²":
          return a * 1000000;
        case "in²":
          return a * 645.16;
        case "ft²":
          return a * 92900;
        default:
          return a * 836100; // yd² or fallback
      }
    }

    function disConvert(a, b) {
      switch (b) {
        case "mm":
          return a * 1;
        case "cm":
          return a * 10;
        case "m":
          return a * 1000;
        case "in":
          return a * 25.4;
        case "ft":
          return a * 304.8;
        default:
          return a * 914.4; // yd or fallback
      }
    }

    area = areaConvert(area, area_unit);
    distance = disConvert(distance, dis_unit);

    if (!isNaN(area) && !isNaN(distance) && !isNaN(permittivity)) {
      if (permittivity <= 0) {
        param.error = "Capacitance should be greater than 0";
        return param;
      }

      let mf_ans = (permittivity * area) / distance;
      let f_ans = 0.001 * mf_ans;
      let microf_ans = 1000 * mf_ans;
      let nf_ans = 1000000 * mf_ans;
      let pf_ans = 1000000000 * mf_ans;

      param.tech_mf_ans = mf_ans;
      param.tech_f_ans = f_ans;
      param.tech_microf_ans = microf_ans;
      param.tech_nf_ans = nf_ans;
      param.tech_pf_ans = pf_ans;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /** getCalculationdAngleofDeviationCalculation
   * POST: /api/calculators-lol/angle-of-deviation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationdAngleofDeviationCalculation(body) {
    let incidence = parseFloat(body.tech_incidence);
    let incidence_unit = String(body.tech_incidence_unit).trim();
    let emergence = parseFloat(body.tech_emergence);
    let emergence_unit = String(body.tech_emergence_unit).trim();
    let prism = parseFloat(body.tech_prism);
    let prism_unit = String(body.tech_prism_unit).trim();
    let deviation_unit = String(body.tech_deviation_unit).trim(); // not used, but retained
    let param = {};

    function unitsOfDeviation(value, unit) {
      switch (unit) {
        case "circle":
          return value * 360;
        case "cycle":
          return value * 359.8981;
        case "degree":
          return value;
        case "gon":
          return value * 0.9;
        case "gradian":
          return value * 0.9;
        case "mil":
          return value * 0.05625;
        case "milliradian":
          return value * 0.057296;
        case "minute":
          return value * 0.016667;
        case "minutes of arc":
          return value * 0.016667;
        case "point":
          return value * 11.25;
        case "quadrant":
          return value * 90;
        case "quartercircle":
          return value * 90;
        case "right angle":
          return value * 90;
        case "radian":
          return value * 57.29578;
        case "revolution":
          return value * 360;
        case "turn":
          return value * 360;
        case "second":
          return value * 0.000278;
        case "semicircle":
          return value * 180;
        case "sextant":
          return value * 60;
        case "sign":
          return value * 30;
        default:
          return NaN;
      }
    }

    if (!isNaN(incidence) && !isNaN(emergence) && !isNaN(prism)) {
      incidence = unitsOfDeviation(incidence, incidence_unit);
      emergence = unitsOfDeviation(emergence, emergence_unit);
      prism = unitsOfDeviation(prism, prism_unit);

      let deviation = incidence + emergence - prism;

      param.tech_deviation = deviation;
      param.tech_incidence = incidence;
      param.tech_emergence = emergence;
      param.tech_prism = prism;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /** getCalculationdElectricPotentialCalculation
   * POST: /api/calculators-lol/electric-potential-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationdElectricPotentialCalculation(body) {
    let potential_type = body.tech_potential_type;
    let points = body.tech_points;
    let Q = body.tech_Q;
    let unit_Q = body.tech_unit_Q;
    let charge = body.tech_charge;
    let charge_unit = body.tech_charge_unit;
    let R = body.tech_R;
    let unit_R = body.tech_unit_R;
    let distance = body.tech_distance;
    let distance_unit = body.tech_distance_unit;
    let E = parseFloat(body.tech_E);
    let U = body.tech_U;
    let U_unit = body.tech_U_unit;

    let param = {};

    function convertToCoulomb(value, unit) {
      switch (unit) {
        case "C":
          return value;
        case "e":
          return value * 1.6022e-19;
        case "mC":
          return value * 1e-3;
        case "μC":
          return value * 1e-6;
        case "nC":
          return value * 1e-9;
        case "PC":
          return value * 1e-12;
        default:
          return NaN;
      }
    }

    function convertToMeter(value, unit) {
      switch (unit) {
        case "m":
          return value;
        case "cm":
          return value * 0.01;
        case "mm":
          return value * 0.001;
        case "μm":
          return value * 1e-6;
        case "nm":
          return value * 1e-9;
        case "in":
          return value * 0.0254;
        case "ft":
          return value * 0.3048;
        case "yd":
          return value * 0.9144;
        default:
          return NaN;
      }
    }

    function convertToJoules(value, unit) {
      switch (unit) {
        case "J":
          return value;
        case "kJ":
          return value * 1000;
        case "MJ":
          return value * 1e6;
        case "Wh":
          return value * 3600;
        case "kWh":
          return value * 3.6e6;
        case "kcal":
          return value * 4184;
        case "eV":
          return value * 1.60218e-19;
        default:
          return NaN;
      }
    }

    let v;

    if (potential_type === "single-point") {
      if (
        !isNaN(charge) &&
        !isNaN(distance) &&
        charge_unit &&
        distance_unit &&
        !isNaN(E)
      ) {
        let coulombs = convertToCoulomb(parseFloat(charge), charge_unit);
        let meters = convertToMeter(parseFloat(distance), distance_unit);
        v = (8.99e9 * coulombs) / meters / E;
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }
    } else if (potential_type === "multi-point") {
      if (
        Array.isArray(Q) &&
        Array.isArray(R) &&
        Array.isArray(unit_Q) &&
        Array.isArray(unit_R) &&
        !isNaN(points) &&
        !isNaN(E)
      ) {
        let QR = [];

        for (let i = 0; i < points; i++) {
          let coulombs = convertToCoulomb(parseFloat(Q[i]), unit_Q[i]);
          let meters = convertToMeter(parseFloat(R[i]), unit_R[i]);
          QR[i] = meters > 0 ? coulombs / meters : 0;
        }

        let QRSum = QR.reduce((sum, val) => sum + val, 0);
        v = (8.99e9 * QRSum) / E;
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }
    } else if (potential_type === "difference") {
      if (!isNaN(U) && U_unit && !isNaN(charge) && charge_unit) {
        let coulombs = convertToCoulomb(parseFloat(charge), charge_unit);
        let joules = convertToJoules(parseFloat(U), U_unit);
        v = joules / coulombs;
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }
    } else {
      param.error = "Invalid potential_type";
      return param;
    }

    let scientificNotation = v.toExponential(3);
    let [mantissa, exponent] = scientificNotation.split("e");
    let answer = `${mantissa} X 10<sup>${parseInt(exponent)}</sup>`;

    param.tech_answer = answer;
    return param;
  }

  /** getCalculationdWaveSpeedCalculation
   * POST: /api/calculators-lol/wave-speed-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationdWaveSpeedCalculation(body) {
    let frequency = parseFloat(body.tech_frequency);
    let f_unit = body.tech_f_unit;
    let wavelength = parseFloat(body.tech_wavelength);
    let w_units = body.tech_w_units;

    let param = {};

    if (!isNaN(frequency) && !isNaN(wavelength)) {
      // Frequency unit conversion
      switch (f_unit) {
        case "kHz":
          frequency *= 1e3;
          break;
        case "MHz":
          frequency *= 1e6;
          break;
        case "GHz":
          frequency *= 1e9;
          break;
        case "THz":
          frequency *= 1e12;
          break;
      }

      // Wavelength unit conversion
      switch (w_units) {
        case "nm":
          wavelength *= 1e-9;
          break;
        case "μm":
          wavelength *= 1e-6;
          break;
        case "mm":
          wavelength *= 1e-3;
          break;
        case "cm":
          wavelength *= 1e-2;
          break;
        case "km":
          wavelength *= 1e3;
          break;
        case "in":
          wavelength *= 0.0254;
          break;
        case "ft":
          wavelength *= 0.3048;
          break;
        case "yd":
          wavelength *= 0.9144;
          break;
        case "mi":
          wavelength *= 1609.344;
          break;
      }

      let t = 1 / frequency; // Period
      let vn = 1 / wavelength; // Wavenumber
      let v = frequency * wavelength; // Wave speed

      param.tech_frequency = frequency;
      param.tech_wavelength = wavelength;
      param.tech_t = t;
      param.tech_vn = vn;
      param.tech_v = v;

      return param;
    } else {
      param.error = "Please! Check Your Input";
      return param;
    }
  }

  /** getCalculationdElectricFluxCalculation
   * POST: /api/calculators-lol/electric-flux-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationdElectricFluxCalculation(body) {
    let electric = parseFloat(body.tech_electric?.toString().trim());
    let surface = parseFloat(body.tech_surface?.toString().trim());
    let degree = parseFloat(body.tech_degree?.toString().trim());
    let charge = parseFloat(body.tech_charge?.toString().trim());
    let unit = body.tech_unit?.toString().trim();
    let constant = parseFloat(body.tech_const?.toString().trim());
    let power = parseFloat(body.tech_power?.toString().trim());

    let param = {};

    function sigFig1(value, digits) {
      if (value === 0) return 0;
      let decimalPlaces = digits - Math.floor(Math.log10(Math.abs(value))) - 1;
      return Number(value.toFixed(decimalPlaces));
    }

    if (
      !isNaN(electric) &&
      !isNaN(surface) &&
      !isNaN(degree) &&
      !isNaN(charge) &&
      !isNaN(constant) &&
      !isNaN(power)
    ) {
      // Charge unit conversion
      switch (unit) {
        case "picocoulomb":
          charge *= 0.001;
          break;
        case "microcoulomb":
          charge *= 1000;
          break;
        case "millicoulomb":
          charge *= 1e6;
          break;
        case "coulomb":
          charge *= 1e9;
          break;
        case "elementry":
          charge *= 1.602e-10;
          break;
        case "ampere":
          charge *= 3.6e12;
          break;
        case "milliampere":
          charge *= 3.6e9;
          break;
      }

      // Gauss Law calculation
      let total = constant * Math.pow(10, power);
      let flux = charge / total;

      // Inward flux
      let sum = 180 - degree;
      let cos = Math.cos((sum * Math.PI) / 180);
      let inward = electric * surface * cos;

      // Outward flux
      let cosOutward = Math.cos((degree * Math.PI) / 180);
      let outward = electric * surface * cosOutward;

      param.tech_flux = flux;
      param.tech_inward = sigFig1(inward, 6);
      param.tech_cosoutward = sigFig1(cosOutward, 5);
      param.tech_outward = sigFig1(outward, 6);
      param.tech_electric = electric;
      param.tech_surface = surface;
      param.tech_degree = degree;
      param.tech_charge = charge;
      param.tech_const = constant;
      param.tech_power = power;
      param.tech_cos = sigFig1(cos, 4);
      param.tech_sum = sum;
      return param;
    } else {
      param.error = "Please! Check Your Input";
      return param;
    }
  }

  /** getCalculationdAmpstoWattsCalculation
   * POST: /api/calculators-lol/amps-to-watts-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationdAmpstoWattsCalculation(body) {
    let current_type = body.tech_current_type;
    let current = parseFloat(body.tech_current);
    let current_unit = body.tech_current_unit;
    let voltage_type = body.tech_voltage_type;
    let voltage = parseFloat(body.tech_voltage);
    let voltage_unit = body.tech_voltage_unit;
    let power = parseFloat(body.tech_power);

    let param = {};

    function convertVoltage(value, unit) {
      if (unit === "mV") return value / 1000;
      if (unit === "V") return value;
      return value * 1000; // Assume kV
    }

    function convertCurrent(value, unit) {
      if (unit === "mA") return value / 1000;
      if (unit === "A") return value;
      return value * 1000; // Assume kA
    }

    if (!isNaN(current) && !isNaN(voltage)) {
      current = convertCurrent(current, current_unit);
      voltage = convertVoltage(voltage, voltage_unit);

      let power_ans = 0;

      if (current_type === "DC") {
        power_ans = current * voltage;
      } else if (current_type === "AC") {
        if (!isNaN(power)) {
          power_ans = current * voltage * power;
        } else {
          param.error = "Please! Check Your Input";
          return param;
        }
      } else {
        if (!isNaN(power)) {
          if (voltage_type === "ltl") {
            power_ans = 1.7320508 * current * voltage * power;
          } else {
            power_ans = 3 * current * voltage * power;
          }
        } else {
          param.error = "Please! Check Your Input";
          return param;
        }
      }

      param.tech_power_ans = power_ans;
      return param;
    } else {
      param.error = "Please! Check Your Input";
      return param;
    }
  }

  /** getCalculationdWattstoAmpsCalculation
   * POST: /api/calculators-lol/amps-to-watts-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationdWattstoAmpsCalculation(body) {
    let current_type = body.tech_current_type;
    let power = parseFloat(body.tech_power);
    let power_unit = body.tech_power_unit;
    let voltage_type = body.tech_voltage_type;
    let voltage = parseFloat(body.tech_voltage);
    let voltage_unit = body.tech_voltage_unit;
    let power_factor = parseFloat(body.tech_power_factor);

    let param = {};

    function convert(value, unit) {
      if (unit === "mW" || unit === "mV") return value / 1000;
      if (unit === "W" || unit === "V") return value;
      return value * 1000; // Assume kW/kV
    }

    if (!isNaN(power) && !isNaN(voltage)) {
      power = convert(power, power_unit);
      voltage = convert(voltage, voltage_unit);

      let amps_ans = 0;

      if (current_type === "DC") {
        amps_ans = power / voltage;
      } else if (current_type === "AC") {
        if (!isNaN(power_factor)) {
          amps_ans = power / (voltage * power_factor);
        } else {
          param.error = "Please! Check Your Input";
          return param;
        }
      } else {
        if (!isNaN(power_factor)) {
          if (voltage_type === "ltl") {
            amps_ans = power / (1.7320508 * voltage * power_factor);
          } else {
            amps_ans = power / (3 * voltage * power_factor);
          }
        } else {
          param.error = "Please! Check Your Input";
          return param;
        }
      }

      param.tech_amps_ans = amps_ans;
      return param;
    } else {
      param.error = "Please! Check Your Input";
      return param;
    }
  }

  /** getCalculationdResultantForceCalculation
   * POST: /api/calculators-lol/resultant-force-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationdResultantForceCalculation(body) {
    let forces = body.tech_force;
    let angles = body.tech_angle;

    let param = {};

    function degToRad(degrees) {
      return degrees * (Math.PI / 180);
    }

    function calculateResultantForce(forces, angles) {
      let Fx = 0;
      let Fy = 0;

      for (let i = 0; i < forces.length; i++) {
        Fx += forces[i] * Math.cos(degToRad(angles[i]));
        Fy += forces[i] * Math.sin(degToRad(angles[i]));
      }

      let magnitude = Math.sqrt(Fx ** 2 + Fy ** 2);
      let direction = Math.atan2(Fy, Fx) * (180 / Math.PI);

      return {
        Fx,
        Fy,
        magnitude,
        direction,
      };
    }

    if (Array.isArray(forces) && Array.isArray(angles)) {
      if (forces.length !== angles.length) {
        param.error = "Number of forces and angle must be the same.";
        return param;
      }

      const result = calculateResultantForce(forces, angles);

      param.tech_Horizontal = result.Fx;
      param.tech_Vertical = result.Fy;
      param.tech_Magnitude = result.magnitude;
      param.tech_Direction = result.direction;
      return param;
    } else {
      param.error = "Please! Check Your Input";
      return param;
    }
  }

  /** getCalculationAverageVelocityCalculation
   * POST: /api/calculators-lol/average-velocity-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationAverageVelocityCalculation(body) {
    let x = body.tech_x;
    let y = body.tech_y;
    let ivUnit = body.tech_iv;
    let fvUnit = body.tech_fv;
    let method = body.tech_method;

    let param = {};

    if (isFinite(x) && isFinite(y)) {
      let velocityA = parseFloat(x);
      let velocityB = parseFloat(y);

      // Convert initial velocity to m/s
      if (ivUnit === "ft/s") velocityA /= 3.281;
      else if (ivUnit === "km/h") velocityA /= 3.6;
      else if (ivUnit === "km/s") velocityA *= 1000;
      else if (ivUnit === "mi/s") velocityA *= 1609.35;
      else if (ivUnit === "mph") velocityA /= 2.237;

      // Convert final velocity to m/s
      if (fvUnit === "ft/s") velocityB /= 3.281;
      else if (fvUnit === "km/h") velocityB /= 3.6;
      else if (fvUnit === "km/s") velocityB *= 1000;
      else if (fvUnit === "mi/s") velocityB *= 1609.35;
      else if (fvUnit === "mph") velocityB /= 2.237;

      let iv, fv, ave;

      if (method === "1") {
        iv = `${x} ${ivUnit}`;
        fv = `${y} ${fvUnit}`;
        ave = `${((velocityA + velocityB) / 2).toFixed(5)} m/s`;
      } else if (method === "2") {
        ave = `${x} ${ivUnit}`;
        fv = `${y} ${fvUnit}`;
        iv = `${(velocityA * 2 - velocityB).toFixed(5)} m/s`;
      } else if (method === "3") {
        ave = `${x} ${ivUnit}`;
        iv = `${y} ${fvUnit}`;
        fv = `${(velocityA * 2 - velocityB).toFixed(5)} m/s`;
      } else if (method === "4") {
        iv = `${x} ${ivUnit}`;
        fv = `${y} ${fvUnit}`;
        ave = `${(
          (2 * velocityA * velocityB) /
          (velocityA + velocityB)
        ).toFixed(5)} m/s`;
      }

      param.tech_iv = iv;
      param.tech_fv = fv;
      param.tech_ave = ave;
      return param;
    } else {
      param.error = "Please fill all fields.";
      return param;
    }
  }

  /** getCalculationAmpHourCalculation
   * POST: /api/calculators-lol/amp-hour-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationAmpHourCalculation(body) {
    let find = body.tech_find;
    let vol = parseFloat(body.tech_vol);
    let bc = parseFloat(body.tech_bc);
    let bc_unit = body.tech_bc_unit;
    let wt_hour = parseFloat(body.tech_wt_hour);
    let wt_hour_unit = body.tech_wt_hour_unit;
    let c_rate = parseFloat(body.tech_c_rate);
    let type = body.tech_type;
    let load_size = parseFloat(body.tech_load_size);
    let load_duration = parseFloat(body.tech_load_duration);
    let tempchk = body.tech_temp_chk;
    let agechk = body.tech_age_chk;
    let batteries = body.tech_batteries;

    let param = {};
    let ans, dc;

    // Normalize units
    if (bc_unit === "Ah") bc_unit = 1;
    else if (bc_unit === "mAh") bc_unit = 0.001;

    if (wt_hour_unit === "kJ") wt_hour_unit = 0.2778;
    else if (wt_hour_unit === "MJ") wt_hour_unit = 277.8;
    else if (wt_hour_unit === "Wh") wt_hour_unit = 1;
    else if (wt_hour_unit === "kWh") wt_hour_unit = 1000;

    if (type === "first") {
      if (find === "1") {
        if (isFinite(vol) && isFinite(wt_hour) && isFinite(c_rate)) {
          let wt_val = wt_hour * wt_hour_unit;
          ans = wt_val / vol;
          let bc_val = ans;
          dc = c_rate * bc_val;
        } else {
          param.error = "Please! Check Input";
          return param;
        }
      } else if (find === "2") {
        if (isFinite(bc) && isFinite(wt_hour) && isFinite(c_rate)) {
          let wt_val = wt_hour * wt_hour_unit;
          let bc_val = bc * bc_unit;
          ans = wt_val / bc_val;
          dc = c_rate * bc_val;
        } else {
          param.error = "Please! Check Input";
          return param;
        }
      } else if (find === "3") {
        if (isFinite(bc) && isFinite(vol) && isFinite(c_rate)) {
          let bc_val = bc * bc_unit;
          ans = bc_val * vol;
          dc = c_rate * bc_val;
        } else {
          param.error = "Please! Check Input";
          return param;
        }
      }
      param.tech_find = find;
      param.tech_dc = dc;
      param.tech_c_rate = c_rate;
    } else if (type === "second") {
      if (isFinite(load_size) && isFinite(load_duration)) {
        let E3 = load_size;
        let E4 = load_duration;
        let E9 = agechk === "checked" ? 0.05 : 0;
        let E14 = tempchk === "checked" ? 0.1 : 0;

        let typeValue = 1;
        if (batteries === "gel") typeValue = 1.15;
        else if (batteries === "agm") typeValue = 1.1;
        else if (batteries === "flooded") typeValue = 1.4;

        let E25 = E3 * 20;
        let E26 = E4 / 20;
        let E27 = E9 + E14 + typeValue;
        let E28 = Math.pow(E25, E27);
        let E29 = E28 * E26;
        let E30 = Math.log(E29);
        let E31 = E30 / E27;
        ans = Math.ceil(Math.exp(E31)) * 2;
      } else {
        param.error = "Please! Check Input";
        return param;
      }
    }

    param.tech_type = type;
    param.tech_ans = ans;
    return param;
  }

  /** getCalculationParallelResistorCalculation
   * POST: /api/calculators-lol/parallel-resistor-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationParallelResistorCalculation(body) {
    let mode = body.tech_mode;
    let res_val = body.tech_res_val; // array of values
    let unit = body.tech_unit; // array of corresponding unit multipliers
    let missing = body.tech_missing;
    let mis_unit = body.tech_mis_unit;

    let array = [];

    // Convert mis_unit
    // if (mis_unit === "nm") {
    //   mis_unit = 0.001;
    // } else if (mis_unit === "μm") {
    //   mis_unit = 1;
    // } else if (mis_unit === "mm") {
    //   mis_unit = 1000;
    // } else if (mis_unit === "cm") {
    //   mis_unit = 1000000;
    // }

    //  mΩ   Ω  kΩ  MΩ
    // Convert mis_unit
    if (mis_unit == "mΩ") {
      mis_unit = 0.001;
    } else if (mis_unit == "Ω") {
      mis_unit = 1;
    } else if (mis_unit == "kΩ") {
      mis_unit = 1000;
    } else if (mis_unit == "MΩ") {
      mis_unit = 1000000;
    }

    // Validate and process resistors
    for (let y = 0; y < res_val.length; y++) {
      let val = parseFloat(res_val[y]);
      let scale = parseFloat(unit[y]);

      if (!isFinite(val) || !isFinite(scale)) {
        return { error: "Please fill all fields." };
      }

      if (val === 0) {
        return { error: "Resistor value greater than zero." };
      }

      array.push(1 / (val * scale));
    }

    let lcm = array.reduce((acc, val) => acc + val, 0);
    let main_ans;

    if (mode == "1") {
      main_ans = 1 / lcm;
    } else if (mode == "2") {
      let missingValue = parseFloat(missing) * mis_unit;

      if (!isFinite(missingValue)) {
        return { error: "Please fill all fields." };
      }

      if (missingValue < 0) {
        return { error: "Desired Total Resistance cannot be negative.." };
      }

      main_ans = 1 / (1 / missingValue - lcm);
    }

    let answer, displayUnit;

    if (main_ans > 1000) {
      answer = main_ans / 1000;
      displayUnit = "kΩ";
    } else {
      answer = main_ans;
      displayUnit = "Ω";
    }

    return {
      tech_mode: mode,
      tech_answer: answer,
      tech_unit: displayUnit,
    };
  }

  /** getCalculationAngleofRefractionCalculation
   * POST: /api/calculators-lol/angle-of-refraction-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationAngleofRefractionCalculation(body) {
    let calculation = body.tech_calculation;
    let medium1 = body.tech_medium1;
    let n1 = parseFloat(body.tech_n1);
    let medium2 = body.tech_medium2;
    let n2 = parseFloat(body.tech_n2);
    let angle_first = parseFloat(body.tech_angle_first);
    let angle_f_unit = body.tech_angle_f_unit;
    let angle_second = parseFloat(body.tech_angle_second);
    let angle_s_unit = body.tech_angle_s_unit;

    function convertAngle(unit, value) {
      switch (unit) {
        case "deg":
          return value * 0.0174533;
        case "rad":
          return value * 1;
        case "gon":
          return value * 0.01570796;
        case "tr":
          return value * 6.28319;
        case "arcmin":
          return value * 0.000290888;
        case "arcsec":
          return value * 0.00000484814;
        case "mrad":
          return value * 0.001;
        case "μrad":
          return value * 0.000001;
        case "* π rad":
          return value * 3.14159;
        default:
          return NaN;
      }
    }

    angle_first = convertAngle(angle_f_unit, angle_first);
    angle_second = convertAngle(angle_s_unit, angle_second);

    let jawab;
    if (calculation === "from1") {
      if (
        medium2 &&
        !isNaN(n2) &&
        !isNaN(angle_first) &&
        angle_f_unit &&
        !isNaN(angle_second) &&
        angle_s_unit
      ) {
        jawab = (n2 * Math.sin(angle_second)) / Math.sin(angle_first);
      } else {
        return { error: "Please! Check Your Input" };
      }
    } else if (calculation === "from2") {
      if (
        medium1 &&
        !isNaN(n1) &&
        !isNaN(angle_first) &&
        angle_f_unit &&
        !isNaN(angle_second) &&
        angle_s_unit
      ) {
        jawab = (n1 * Math.sin(angle_first)) / Math.sin(angle_second);
      } else {
        return { error: "Please! Check Your Input" };
      }
    } else if (calculation === "from3") {
      if (
        medium1 &&
        !isNaN(n1) &&
        medium2 &&
        !isNaN(n2) &&
        !isNaN(angle_second) &&
        angle_s_unit
      ) {
        jawab = Math.asin((n2 * Math.sin(angle_second)) / n1);
      } else {
        return { error: "Please! Check Your Input" };
      }
    } else if (calculation === "from4") {
      if (
        medium1 &&
        !isNaN(n1) &&
        medium2 &&
        !isNaN(n2) &&
        !isNaN(angle_first) &&
        angle_f_unit
      ) {
        jawab = Math.asin((n1 * Math.sin(angle_first)) / n2);
      } else {
        return { error: "Please! Check Your Input" };
      }
    }

    return {
      tech_angle_first: angle_first,
      tech_angle_second: angle_second,
      tech_calculation: calculation,
      tech_jawab: jawab,
    };
  }

  /** getCalculationJouleCalculation
   * POST: /api/calculators-lol/joule-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationJouleCalculation(body) {
    let mass = parseFloat(body.tech_mass);
    let mass_unit = parseFloat(body.tech_mass_unit);
    let velocity = parseFloat(body.tech_velocity);
    let velocity_unit = parseFloat(body.tech_velocity_unit);
    let joule_unit_label = body.tech_joule_unit;

    let unit;

    function convertJouleUnit(energy, joule_unit) {
      if (joule_unit == "Joule (J)") {
        unit = energy / 1;
      } else if (joule_unit == "BTU (mean)") {
        unit = energy / 1055.87;
      } else if (joule_unit == "BTU (thermochemical)") {
        unit = energy / 1054.35;
      } else if (joule_unit == "Calorie (SI) (cal)") {
        unit = energy / 4.1868;
      } else if (joule_unit == "Electron volt (eV)") {
        unit = energy / 0.00000000000000000016;
      } else if (joule_unit == "Erg (erg)") {
        unit = energy / 0.0000001;
      } else if (joule_unit == "Foot-pound force") {
        unit = energy / 1.355818;
      } else if (joule_unit == "Foot-poundal") {
        unit = energy / 0.0421;
      } else if (joule_unit == "Horsepower-hour") {
        unit = energy / 2684077.3;
      } else if (joule_unit == "Kilocalorie (SI)(kcal)") {
        unit = energy / 4186.8;
      } else if (joule_unit == "Kilowatt-hour (kW hr)") {
        unit = energy / 3600000;
      } else if (joule_unit == "Ton of TNT") {
        unit = energy / 4200000000;
      } else if (joule_unit == "Volt-coulomb (V Cb)") {
        unit = energy / 1;
      } else if (joule_unit == "Watt-hour (W hr)") {
        unit = energy / 3600;
      } else if (joule_unit == "Watt-second (W sec)") {
        unit = energy / 1;
      }
      return unit;
    }

    if (!isNaN(mass) && !isNaN(velocity)) {
      let massSI = mass * mass_unit;
      let velocitySI = velocity * velocity_unit;
      let velocitySquared = velocitySI * velocitySI;
      let energy = massSI * velocitySquared;
      let convertedEnergy = convertJouleUnit(energy, joule_unit_label);

      if (convertedEnergy === null) {
        return { error: "Unsupported unit type." };
      }

      let answer = 0.5 * convertedEnergy;

      return {
        tech_answer: answer,
      };
    } else {
      return { error: "Please! Check Your Input" };
    }
  }

  /** getCalculationEfficiencyCalculation
   * POST: /api/calculators-lol/efficiency-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationEfficiencyCalculation(body) {
    let solve = body.tech_solve;
    let en_ou = parseFloat(body.tech_en_ou);
    let en_ou_unit = body.tech_en_ou_unit;
    let en_in = parseFloat(body.tech_en_in);
    let en_in_unit = body.tech_en_in_unit;
    let en_ef = parseFloat(body.tech_en_ef);

    function en_convert(value, unit) {
      switch (unit) {
        case "J":
          return value;
        case "kJ":
          return value * 1000;
        case "MJ":
          return value * 1000000;
        case "Wh":
          return value * 3600;
        case "kWh":
          return value * 3600000;
        case "ft-lbs":
          return value * 1.3558;
        case "kcal":
          return value * 4184;
        default:
          return value / 6.242e18; // fallback for unknown unit (e.g., eV)
      }
    }

    en_ou = en_convert(en_ou, en_ou_unit);
    en_in = en_convert(en_in, en_in_unit);

    let answer;

    if (solve === "1") {
      if (!isNaN(en_ou) && !isNaN(en_in)) {
        answer = (en_ou / en_in) * 100;
      } else {
        return { error: "Please! Check Your Input" };
      }
    } else if (solve === "2") {
      if (!isNaN(en_ou) && !isNaN(en_ef)) {
        answer = (en_ou * 100) / en_ef;
      } else {
        return { error: "Please! Check Your Input" };
      }
    } else {
      if (!isNaN(en_in) && !isNaN(en_ef)) {
        answer = (en_ef / 100) * en_in;
      } else {
        return { error: "Please! Check Your Input" };
      }
    }

    return {
      tech_answer: answer,
    };
  }

  /** getCalculationVoltsToJoulesCalculation
   * POST: /api/calculators-lol/volts-to-joules-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationVoltsToJoulesCalculation(body) {
    let volts = parseFloat(body.tech_volts);
    let coulombs = parseFloat(body.tech_coulombs);
    let joules = parseFloat(body.tech_joules);
    let Solve_unit = body.tech_Solve_unit;

    function solveValues(Solve_unit, volts, coulombs, joules) {
      if (Solve_unit === "Joules") {
        return volts * coulombs;
      } else if (Solve_unit === "Volts") {
        return joules / coulombs;
      } else if (Solve_unit === "Coulombs") {
        return joules / volts;
      }
      return null;
    }

    if (!isNaN(volts) && !isNaN(coulombs) && !isNaN(joules)) {
      let answer = solveValues(Solve_unit, volts, coulombs, joules);
      return {
        tech_answer: answer,
      };
    } else {
      return { error: "Please! Check Your Input" };
    }
  }

  /** getCalculationBuoyancyCalculation
   * POST: /api/calculators-lol/buoyancy-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBuoyancyCalculation(body) {
    let density = parseFloat(body.tech_density);
    let volume = parseFloat(body.tech_volume);
    let gravity = parseFloat(body.tech_gravity);

    if (!isNaN(density) && !isNaN(volume) && !isNaN(gravity)) {
      let answer = density * volume * gravity;
      return {
        tech_answer: answer,
      };
    } else {
      return {
        error: "Please! Check Your Input",
      };
    }
  }

  /** getCalculationFPECalculation
   * POST: /api/calculators-lol/fpe-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationFPECalculation(body) {
    let velocity = parseFloat(body.tech_velocity);
    let weight = parseFloat(body.tech_weight);

    if (!isNaN(velocity) && !isNaN(weight)) {
      let answer = (velocity * velocity * weight) / 450240;
      return {
        tech_answer: answer,
      };
    } else {
      return {
        error: "Please! Check Your Input",
      };
    }
  }

  /** getCalculationRelativeHumidityCalculation
   * POST: /api/calculators-lol/relative-humidity-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationRelativeHumidityCalculation(body) {
    let temperature = parseFloat(body.tech_temperature);
    let temperature_unit = body.tech_temperature_unit;
    let point = parseFloat(body.tech_point);
    let point_unit = body.tech_point_unit;

    function framing_units(value, unit) {
      if (unit === "°F") {
        value = ((value - 32) * 5) / 9;
      } else if (unit === "K") {
        value = value - 273.15;
      } else {
        value = value;
      }
      return value;
    }

    if (temperature_unit === "°C" && temperature >= 61) {
      return { error: "temperature should be 60 °C equal or lower" };
    } else if (temperature_unit === "°F" && temperature >= 141) {
      return { error: "Temperature should be lower 140 °F equal or lower" };
    } else if (temperature_unit === "K" && temperature == 0) {
      return { error: "Temperature should be 273.15 k equal or upper" };
    }

    if (!isNaN(temperature) && !isNaN(point)) {
      let tempC = framing_units(temperature, temperature_unit);
      let pointC = framing_units(point, point_unit);
      let Pws = 6.112 * Math.exp((17.67 * tempC) / (tempC + 243.5));
      let Pw = 6.112 * Math.exp((17.67 * pointC) / (pointC + 243.5));
      let answer = (Pw / Pws) * 100;

      return {
        tech_answer: answer,
      };
    } else {
      return { error: "Please! Check Your Input" };
    }
  }

  /** getCalculationFrictionLossCalculation
   * POST: /api/calculators-lol/friction-loss-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationFrictionLossCalculation(body) {
    let pipe_diameter = parseFloat(body.tech_pipe_diameter);
    let pipe_diameter_unit = body.tech_pipe_diameter_unit;
    let pipe_length = parseFloat(body.tech_pipe_length);
    let pipe_length_unit = body.tech_pipe_length_unit;
    let volumetric = parseFloat(body.tech_volumetric);
    let volumetric_unit = body.tech_volumetric_unit;
    let material = parseFloat(body.tech_material);

    let pipe_ans, volumetric_ans;

    function pipeConvert(a, b) {
      if (b === "mm") {
        pipe_ans = a / 1000;
      } else if (b === "cm") {
        pipe_ans = a / 100;
      } else if (b === "m") {
        pipe_ans = a * 1;
      } else if (b === "in") {
        pipe_ans = a / 39.37;
      } else {
        pipe_ans = a / 3.281;
      }
      return pipe_ans;
    }

    function volumetricConvert(a, b) {
      if (b === "1") {
        volumetric_ans = a * 0.0037854;
      } else if (b === "2") {
        volumetric_ans = a * 0.00006309;
      } else if (b === "3") {
        volumetric_ans = a * 0.0000010515;
      } else if (b === "4") {
        volumetric_ans = a * 0.004546;
      } else if (b === "5") {
        volumetric_ans = a * 0.00007577;
      } else if (b === "6") {
        volumetric_ans = a * 0.0000012628;
      } else if (b === "7") {
        volumetric_ans = a * 0.028317;
      } else if (b === "8") {
        volumetric_ans = a * 0.00047195;
      } else if (b === "9") {
        volumetric_ans = a * 0.000007866;
      } else if (b === "10") {
        volumetric_ans = a * 1;
      } else if (b === "11") {
        volumetric_ans = a * 0.016667;
      } else if (b === "12") {
        volumetric_ans = a * 0.0002778;
      } else if (b === "13") {
        volumetric_ans = a * 0.001;
      } else if (b === "14") {
        volumetric_ans = a * 0.000016667;
      } else if (b === "15") {
        volumetric_ans = a * 0.0000002778;
      } else if (b === "16") {
        volumetric_ans = a * 0.000000016667;
      } else {
        volumetric_ans = a * 0.0000000002778;
      }
      return volumetric_ans;
    }

    if (isNaN(pipe_diameter) || isNaN(pipe_length) || isNaN(volumetric)) {
      return { error: "Please! Check Your Input" };
    }

    pipe_diameter = pipeConvert(pipe_diameter, pipe_diameter_unit);
    pipe_length = pipeConvert(pipe_length, pipe_length_unit);

    const unitNames = [
      "US gal/s",
      "US gal/min",
      "US gal/hr",
      "UK gal/s",
      "UK gal/min",
      "UK gal/hr",
      "ft³/s",
      "ft³/min",
      "ft³/hr",
      "m³/s",
      "m³/min",
      "m³/hr",
      "L/s",
      "L/min",
      "L/hr",
      "ml/min",
      "ml/hr",
    ];

    let volumetricIndex = unitNames.indexOf(volumetric_unit);
    volumetric = volumetricConvert(volumetric, volumetricIndex);
    console.log(volumetric, material);
    let up_div = Math.pow(volumetric / material, 1.852);
    let head_loss =
      (10.67 * pipe_length * up_div) / Math.pow(pipe_diameter, 4.87);
    let pressure_loss = (head_loss * 9810) / 100000;

    return {
      tech_head_loss: head_loss,
      tech_pressure_loss: pressure_loss,
      tech_material: material,
    };
  }

  /** getCalculationEnergyCostCalculation
   * POST: /api/calculators-lol/energy-cost-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationEnergyCostCalculation(body) {
    let hours_per_day = parseFloat(body.tech_hours_per_day);
    let power = parseFloat(body.tech_power);
    let power_units = body.tech_power_units;
    let cost = parseFloat(body.tech_cost);
    let cost_units = body.tech_cost_units;
    let currancy = body.tech_currancy;

    if (power_units) {
      if (power_units == "watts (W)") {
        power = power;
      } else if (power_units == "kilowatts (kW)") {
        power = power * 1000;
      }
    }

    if (cost_units && currancy) {
      cost_units = cost_units.replace(currancy + "/", "");
      if (cost_units) {
        if (cost_units == "/rupee") {
          cost = cost * 100;
        } else if (cost_units == "/peso") {
          cost = cost * 100;
        } else if (cost_units == "/pence") {
          cost = cost;
        } else if (cost_units == "/cent") {
          cost = cost;
        }
      }

      // if 'pence' or 'cent', cost stays the same
    }

    if (isNaN(hours_per_day) || isNaN(power) || isNaN(cost)) {
      return { error: "Please! Check Your Input" };
    }

    if (power === 0 || hours_per_day === 0) {
      return { error: "Value cannot be zero! Check Input" };
    }

    let energy_consumed_per_day = (power * hours_per_day) / 1000;
    let energy_cost_per_day = (energy_consumed_per_day * cost) / 100;
    let energy_cost_per_month = energy_cost_per_day * 30;
    let energy_cost_per_year = energy_cost_per_day * 365;

    return {
      tech_energy_cost_per_day: energy_cost_per_day,
      tech_energy_cost_per_month: energy_cost_per_month,
      tech_energy_cost_per_year: energy_cost_per_year,
    };
  }

  /** getCalculationNewtonLawofCoolingCalculation
   * POST: /api/calculators-lol/newtons-law-of-cooling-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationNewtonLawofCoolingCalculation(body) {
    let ambient = parseFloat(body.tech_ambient);
    let ambient_units = body.tech_ambient_units;
    let initial_temperature = parseFloat(body.tech_initial_temperature);
    let initial_temp_units = body.tech_initial_temp_units;
    let area = parseFloat(body.tech_area);
    let area_units = body.tech_area_units;
    let heat_capacity = parseFloat(body.tech_heat_capacity);
    let heat_capacity_units = body.tech_heat_capacity_units;
    let heat_transfer_co = parseFloat(body.tech_heat_transfer_co);
    let heat_transfer_co_units = body.tech_heat_transfer_co_units;
    let temp_after = parseFloat(body.tech_temp_after);
    let temp_after_units = body.tech_temp_after_units;

    if (ambient_units) {
      if (ambient_units == "°C") {
        ambient = ambient;
      } else if (ambient_units == "°F") {
        ambient = ((ambient - 32) * 5) / 9;
      } else if (ambient_units == "K") {
        ambient = ambient - 273.15;
      }
    }
    if (initial_temp_units) {
      if (initial_temp_units == "°C") {
        initial_temperature = initial_temperature;
      } else if (initial_temp_units == "°F") {
        initial_temperature = ((initial_temperature - 32) * 5) / 9;
      } else if (initial_temp_units == "K") {
        initial_temperature = initial_temperature - 273.15;
      }
    }
    if (heat_capacity_units) {
      if (heat_capacity_units == "J/K") {
        heat_capacity = heat_capacity;
      } else if (heat_capacity_units == "J/°C") {
        heat_capacity = heat_capacity;
      } else if (heat_capacity_units == "BTU/°F") {
        heat_capacity = heat_capacity / 0.0005266;
      }
    }
    if (temp_after_units) {
      if (temp_after_units == "sec") {
        temp_after = temp_after;
      } else if (temp_after_units == "min") {
        temp_after = temp_after * 60;
      } else if (temp_after_units == "hrs") {
        temp_after = temp_after * 3600;
      }
    }
    if (heat_transfer_co_units) {
      if (heat_transfer_co_units == "W/(m²·K)") {
        heat_transfer_co = heat_transfer_co;
      } else if (heat_transfer_co_units == "BTU/(h·ft²·°F)") {
        heat_transfer_co = heat_transfer_co * 0.1761;
      }
    }
    if (area_units) {
      if (area_units == "mm²") {
        area = area / 1000000;
      } else if (area_units == "cm²") {
        area = area / 10000;
      } else if (area_units == "m²") {
        area = area;
      } else if (area_units == "km²") {
        area = area * 1000000;
      } else if (area_units == "in²") {
        area = area * 0.00064516;
      } else if (area_units == "ft²") {
        area = area * 0.092903;
      } else if (area_units == "yd²") {
        area = area * 0.836127;
      }
    }

    if (
      isFinite(ambient) &&
      isFinite(initial_temperature) &&
      isFinite(area) &&
      isFinite(heat_capacity) &&
      isFinite(heat_transfer_co) &&
      isFinite(temp_after)
    ) {
      let k = (heat_transfer_co * area) / heat_capacity;
      let temperature =
        ambient + (initial_temperature - ambient) * Math.exp(-k * temp_after);

      return {
        tech_k: k,
        tech_temperature: temperature,
      };
    } else {
      return {
        error: "Please! Check Your Input",
      };
    }
  }

  /** getCalculationWattHourCalculation
   * POST: /api/calculators-lol/watt-hour-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationWattHourCalculation(body) {
    let volt = parseFloat(body.tech_volt);
    let volt_unit = body.tech_volt_unit;
    let charge = parseFloat(body.tech_charge);
    let charge_unit = body.tech_charge_unit;
    let power = parseFloat(body.tech_power);
    let power_unit = body.tech_power_unit;
    let hour = parseFloat(body.tech_hour);
    let hour_unit = body.tech_hour_unit;

    let convert;
    function convertVolt(a, b) {
      if (b == "nv") {
        convert = a * 0.000000001;
      } else if (b == "μV") {
        convert = a * 0.000001;
      } else if (b == "mV") {
        convert = a * 0.001;
      } else if (b == "kV") {
        convert = a * 0.001;
      } else if (b == "MV") {
        convert = a * 1000000;
      } else if (b == "V") {
        convert = a * 1;
      }
      return convert;
    }
    function convertWatt(a, b) {
      if (b == "mW") {
        convert = a * 0.001;
      } else if (b == "W") {
        convert = a * 1;
      } else if (b == "kW") {
        convert = a * 1000;
      } else if (b == "MW") {
        convert = a * 1000000;
      } else if (b == "BTU/h") {
        convert = a * 0.293071;
      } else if (b == "hp(I)") {
        convert = a * 745.7;
      } else if (b == "hp(E)") {
        convert = a * 746;
      }
      return convert;
    }
    function convertHourToHrs(a, b) {
      // ["ms", "sec", "min","hrs","dys","wks","mns","yrs"];
      if (b == "ms") {
        convert = a / 3600000;
      } else if (b == "sec") {
        convert = a / 3600;
      } else if (b == "min") {
        convert = a / 60;
      } else if (b == "hrs") {
        convert = a * 1;
      } else if (b == "dys") {
        convert = a * 24;
      } else if (b == "wks") {
        convert = a * 604800;
      } else if (b == "m") {
        convert = a * 2628000;
      } else if (b == "yrs") {
        convert = a * 31536000;
      }
      return convert;
    }
    function convertChargeToAh(a, b) {
      if (b == "C") {
        convert = a / 3600;
      } else if (b == "Ah") {
        convert = a * 1;
      } else if (b == "mAh") {
        convert = a / 3600000;
      }

      return convert;
    }

    let response = {};

    if (!volt && !charge && !power && !hour) {
      response.error = "Please! Check Your Input";
      return response;
    }

    if (!isNaN(volt) && !isNaN(charge)) {
      volt = convertVolt(volt, volt_unit);
      charge = convertChargeToAh(charge, charge_unit);
      let energy = volt * charge;
      let energy_k = energy / 1000;
      response.tech_type = "energy";
      response.tech_energy = energy;
      response.tech_energy_k = energy_k;
    }

    if (!isNaN(power) && !isNaN(hour)) {
      power = convertWatt(power, power_unit);
      hour = convertHourToHrs(hour, hour_unit);
      let watt_h = parseFloat((power * hour).toFixed(5));
      let watt_hk = parseFloat(((power * hour) / 1000).toFixed(5));
      response.tech_type2 = "watt";
      response.tech_watt_h = watt_h;
      response.tech_watt_hk = watt_hk;
    }

    return response;
  }

  /** getCalculationSpeedofSoundCalculation
   * POST: /api/calculators-lol/speed-of-sound-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationSpeedofSoundCalculation(body) {
    let temperature_air_units = body.tech_temperature_air_units;
    let temperature_air = parseFloat(body.tech_temperature_air);
    let select_unit = body.tech_select_unit; // Currently unused
    let f_values = body.tech_f_values; // Currently unused
    let c_values = body.tech_c_values; // Currently unused

    if (temperature_air_units) {
      if (temperature_air_units == "°C") {
        temperature_air = temperature_air * 1;
      } else if (temperature_air_units == "°F") {
        temperature_air = ((temperature_air - 32) * 5) / 9;
      } else if (temperature_air_units == "K") {
        temperature_air = temperature_air - 273.15;
      }
    }

    let response = {};

    if (isNaN(temperature_air)) {
      response.error = "Please! Check Your Input";
      return response;
    }

    let gamma = 1.4;
    let specificGasConstant = 287;
    let temperatureKelvin = temperature_air + 273.15;

    let speedOfSound = Math.sqrt(
      gamma * specificGasConstant * temperatureKelvin
    );

    response.tech_speedOfSound = speedOfSound.toFixed(2);
    return response;
  }

  /** getCalculationSpecificGravityCalculation
   * POST: /api/calculators-lol/specific-gravity-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationSpecificGravityCalculation(body) {
    let t_fluid = body.tech_t_fluid;
    let density = parseFloat(body.tech_density);
    let density_unit = body.tech_density_unit;

    let response = {};

    function central_unit(density, density_unit) {
      if (density_unit == "kg/m³") {
        density = density;
      } else if (density_unit == "lb/ft³") {
        density = density * 16.0185;
      } else if (density_unit == "lb/yd³") {
        density = density * 0.593276;
      } else if (density_unit == "g/cm³") {
        density = density * 1000;
      } else if (density_unit == "kg/cm³") {
        density = density / 1000000;
      } else if (density_unit == "mg/cm³") {
        density = density * 0.001;
      } else if (density_unit == "g/m³") {
        density = density * 1000;
      } else if (density_unit == "g/dm³") {
        density = density * 100;
      }
      return density;
    }

    if (isNaN(density) || !t_fluid || !density_unit) {
      response.error = "Please! Check Your Input";
      return response;
    }

    if (t_fluid === "ls") {
      let dens = central_unit(density, density_unit);
      if (isNaN(dens)) {
        response.error = "Please! Check Your Input";
        return response;
      }
      let gravity = parseFloat((dens / 1000).toFixed(5));
      response.tech_gravity = gravity;
    } else {
      let gs_gravity = parseFloat((density / 28.96469).toFixed(5));
      response.tech_gs_gravity = gs_gravity;
    }

    return response;
  }

  /** getCalculationScientificNotationCalculator
   * POST: /api/calculators-lol/scientific-notation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationScientificNotationCalculator(body) {
    let type = body.tech_type;
    let nbr1 = body.tech_nbr1;
    let pwr1 = body.tech_pwr1;
    let nbr2 = body.tech_nbr2;
    let pwr2 = body.tech_pwr2;
    let opr = body.tech_opr;
    let nbr = body.tech_nbr;
    let pwr = body.tech_pwr;
    let decimal = body.tech_decimal;
    let e = body.tech_e;

    let result = {};

    if (type === "calculator") {
      if (!isNaN(nbr1) && !isNaN(pwr1) && !isNaN(nbr2) && !isNaN(pwr2)) {
        let num1 = Number(`${nbr1}e${pwr1}`);
        let num2 = Number(`${nbr2}e${pwr2}`);
        let sol;

        if (opr === "+") sol = num1 + num2;
        else if (opr === "-") sol = num1 - num2;
        else if (opr === "*") sol = num1 * num2;
        else if (opr === "/") sol = num1 / num2;

        let e_ans = sol.toExponential(3);
        let [left, right] = sol.toExponential(3).toUpperCase().split("E");
        right = Math.abs(Number(right));

        let ee_ans = `${left[0]}${left[2]}${left[3]}${left[1]}${left[4]}`;
        let ee_p = right - 2;

        result = {
          tech_ans: sol,
          tech_left: left,
          tech_right: right,
          tech_e_ans: e_ans,
          tech_ee_ans: ee_ans,
          tech_ee_p: ee_p,
        };
      } else {
        result.error = "Please Check Your Input.";
      }
    } else {
      if (!isNaN(nbr) && !isNaN(pwr)) {
        let sol = Number(`${nbr}e${pwr}`);
        let e_ans = sol.toExponential(3);
        let [left, right] = sol.toExponential(3).toUpperCase().split("E");
        right = Math.abs(Number(right));

        let ee_ans = `${left[0]}${left[2]}${left[3]}${left[1]}${left[4]}`;
        let ee_p = right - 2;

        result = {
          tech_ans: sol,
          tech_left: left,
          tech_right: right,
          tech_e_ans: e_ans,
          tech_ee_ans: ee_ans,
          tech_ee_p: ee_p,
        };
      } else if (decimal && typeof decimal === "string") {
        let number = decimal
          .replace(/\s+/g, "")
          .replace(/\*/g, "x")
          .replace(/x10\^/, "e");

        let sol = parseFloat(number);

        if (!isNaN(sol) && sol !== 0) {
          let e_ans = sol.toExponential(3);
          let [left, right] = sol.toExponential(3).toUpperCase().split("E");
          right = Math.abs(Number(right));

          let ee_ans = `${left[0]}${left[2]}${left[3]}${left[1]}${left[4]}`;
          let ee_p = right - 2;

          result = {
            tech_ans: sol,
            tech_left: left,
            tech_right: right,
            tech_e_ans: e_ans,
            tech_ee_ans: ee_ans,
            tech_ee_p: ee_p,
          };
        } else {
          result.error =
            "Please! Enter numbers, scientific notation or E notation.\nScientific Notation: 1.35 x 10^3 \nE Notation: 1.35e3";
        }
      } else if (!isNaN(e)) {
        let sol = Number(e);
        let e_ans = sol.toExponential(3);
        let [left, right] = sol.toExponential(3).toUpperCase().split("E");
        right = Math.abs(Number(right));

        let ee_ans = `${left[0]}${left[2]}${left[3]}${left[1]}${left[4]}`;
        let ee_p = right - 2;

        result = {
          tech_ans: sol,
          tech_left: left,
          tech_right: right,
          tech_e_ans: e_ans,
          tech_ee_ans: ee_ans,
          tech_ee_p: ee_p,
        };
      } else {
        result.error = "Please Check Your Input.";
      }
    }

    return result;
  }

  /** getCalculationPrimeFactorizationCalculator
   * POST: /api/calculators-lol/prime-factorization-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPrimeFactorizationCalculator(body) {
    let from = body.tech_from;
    let num = body.tech_num;
    let response = {};

    if (!isNaN(num)) {
      let newnum = Number(num);

      if (newnum > 1000000) {
        response.error = "Number is too large.";
        return response;
      }

      if (from == 1) {
        let newtext = "";
        let csv = "";
        let chk = 2;
        let prime = 0;
        let original = newnum;

        while (chk * chk <= newnum) {
          if (newnum % chk === 0) {
            newtext += chk;
            csv += chk;
            newnum = newnum / chk;

            if (newnum != 1) {
              newtext += " × ";
              csv += " , ";
            }
          } else {
            chk++;
          }
        }

        if (newnum != 1) {
          newtext += newnum;
          csv += newnum;
        }

        if (newtext == "" + num) {
          newtext += " is a Prime number.";
          prime = 1;
        }

        if (prime != 1) {
          let number = num;
          let divid = newtext.split(" × ");
          let tree = `<tr><td class='py-2 text-center'>${number}</td><td class='py-2'>&nbsp;</td></tr>`;
          for (let i = 0; i < divid.length; i++) {
            let value = divid[i];
            if (value != number) {
              number = number / value;
              tree += `<tr><td class='py-2'>| </td><td class='py-2'>\\ </td></tr><tr><td class='py-2'>${number}</td><td class='py-2'>${value}</td></tr>`;
            }
          }
          response.tech_tree = tree;
        }

        response.tech_Factors = newtext;
        response.tech_csv = csv;
        response.tech_prime = prime;
        return response;
      } else if (from == 2) {
        let table = `<td class='py-2'><del class='text-danger'>1</del></td>`;
        let tr = 1;

        for (let i = 2; i <= num; i++) {
          let mm = 0;
          for (let j = 2; j <= i / 2; j++) {
            if (i % j == 0) {
              table += `<td class='py-2'><del class='text-danger'>${i}</del></td>`;
              mm++;
              break;
            }
          }
          if (mm == 0) {
            table += `<td class='py-2'>${i}</td>`;
          }
          if (tr % 10 == 0) {
            table += `</tr><tr>`;
          }
          tr++;
        }

        response.tech_table = table;
        return response;
      } else if (from == 3 || from == 4) {
        let list = "";
        let total = 0;

        for (let i = 2; i <= num; i++) {
          let mm = 0;
          for (let j = 2; j <= i / 2; j++) {
            if (i % j == 0) {
              mm++;
              break;
            }
          }
          if (mm == 0) {
            total++;
            list += `${i},   `;
          }
        }

        response.tech_list = list;
        response.tech_total = total;
        return response;
      } else if (from == 5) {
        function primeCheck(number) {
          if (number == 1) return 0;
          for (let i = 2; i <= number / 2; i++) {
            if (number % i == 0) return 0;
          }
          return 1;
        }

        let prime_check = primeCheck(num);
        response.tech_prime_check = prime_check;
        return response;
      } else if (from == 6) {
        let next, prev;
        let i = num;
        let check_n = 0;

        while (i < 10000000 && check_n != 1) {
          i++;
          let mm = 0;
          for (let j = 2; j <= i / 2; j++) {
            if (i % j == 0) {
              mm++;
              break;
            }
          }
          if (mm == 0) {
            next = i;
            check_n = 1;
          }
        }

        i = num;
        check_n = 0;
        while (i > 2 && check_n != 1) {
          i--;
          let mm = 0;
          for (let j = 2; j <= i / 2; j++) {
            if (i % j == 0) {
              mm++;
              break;
            }
          }
          if (mm == 0) {
            prev = i;
            check_n = 1;
          }
        }

        response.tech_next = next;
        response.tech_prev = prev;
        return response;
      }
    } else {
      response.error = "Please Check Your Input.";
      return response;
    }
  }

  /** getCalculationModuloCalculator
   * POST: /api/calculators-lol/modulo-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationModuloCalculator(body) {
    let x = body.tech_x;
    let y = body.tech_y;
    let response = {};

    if (!isNaN(x) && !isNaN(y)) {
      let mod = x % y;
      response.tech_mod = mod;
      response.tech_agya = "chal thk a";
      return response;
    } else {
      response.error = "Please Check Your Input.";
      return response;
    }
  }

  /** getCalculationMidpointCalculator
   * POST: /api/calculators-lol/midpoint-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMidpointCalculator(body) {
    let x1 = body.tech_x1;
    let x2 = body.tech_x2;
    let y1 = body.tech_y1;
    let y2 = body.tech_y2;

    let response = {};

    if (!isNaN(x1) && !isNaN(x2) && !isNaN(y1) && !isNaN(y2)) {
      let x = (Number(x1) + Number(x2)) / 2;
      let y = (Number(y1) + Number(y2)) / 2;
      let dis =
        Math.round(
          Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)) * 10000
        ) / 10000;

      response.tech_x = x;
      response.tech_y = y;
      response.tech_x1 = x1;
      response.tech_x2 = x2;
      response.tech_y1 = y1;
      response.tech_y2 = y2;
      response.tech_dis = dis;
      return response;
    } else {
      response.error = "Please Check Your Input.";
      return response;
    }
  }

  /** getCalculationSlopeCalculator
   * POST: /api/calculators-lol/slope-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationSlopeCalculator(body) {
    let type = body.tech_type;
    let x1 = body.tech_x1;
    let x2 = body.tech_x2;
    let y1 = body.tech_y1;
    let y2 = body.tech_y2;
    let dis = body.tech_dis;
    let m = body.tech_m;
    let angle = body.tech_angle;
    let x = body.tech_x;
    let y = body.tech_y;
    let b = body.tech_b;

    let result = {};

    x1 = parseFloat(x1);
    x2 = parseFloat(x2);
    y1 = parseFloat(y1);
    y2 = parseFloat(y2);
    dis = parseFloat(dis);
    m = m !== "" ? parseFloat(m) : "";
    angle = angle !== "" ? parseFloat(angle) : "";
    x = parseFloat(x);
    y = parseFloat(y);
    b = parseFloat(b);

    if (type === "2") {
      if (!isNaN(x1) && !isNaN(x2) && !isNaN(y1) && !isNaN(y2)) {
        x = x2 - x1;
        y = y2 - y1;
        let slope = +(y / x).toFixed(4);
        angle = +(Math.atan(slope) * (180 / Math.PI)).toFixed(4);
        let distance = +Math.sqrt(x * x + y * y).toFixed(4);
        b = +(y1 - slope * x1).toFixed(2);

        result = {
          tech_x: x,
          tech_y: y,
          tech_b: b,
          tech_slope: slope,
          tech_angle: angle + " deg",
          tech_distance: distance,
        };
      } else {
        result = { error: "Please fill all fields." };
      }
    } else if (type === "1") {
      if (!isNaN(x1) && !isNaN(y1) && !isNaN(dis)) {
        if (m === "" && angle === "")
          return { error: "Please fill all fields." };

        let slope;
        if (!isNaN(m)) {
          slope = m;
          let d = dis / Math.sqrt(1 + Math.pow(slope, 2));
          var x2r = +(x1 + d).toFixed(4);
          var y2r = +(y1 + slope * d).toFixed(4);
          var x2l = +(x1 - d).toFixed(4);
          var y2l = +(y1 - slope * d).toFixed(4);
          angle = +(Math.atan(slope) * (180 / Math.PI)).toFixed(4);
        } else {
          let a = (angle * Math.PI) / 180;
          slope = +Math.tan(a).toFixed(4);
          let d = dis / Math.sqrt(1 + Math.pow(slope, 2));
          var x2r = +(x1 + d).toFixed(4);
          var y2r = +(y1 + slope * d).toFixed(4);
          var x2l = +(x1 - d).toFixed(4);
          var y2l = +(y1 - slope * d).toFixed(4);
        }

        let xr = x2r - x1;
        let yr = y2r - y1;
        let xl = x2l - x1;
        let yl = y2l - y1;
        b = +(y1 - slope * x1).toFixed(2);

        result = {
          tech_xr: xr,
          tech_yr: yr,
          tech_xl: xl,
          tech_yl: yl,
          tech_x2r: x2r,
          tech_y2r: y2r,
          tech_x2l: x2l,
          tech_y2l: y2l,
          tech_b: b,
          tech_slope: slope,
          tech_angle: angle + " deg",
          tech_distance: dis,
        };
      } else {
        result = { error: "Please fill all fields." };
      }
    } else if (type === "3") {
      if (!isNaN(x1) && !isNaN(y1)) {
        if (m === "" && angle === "")
          return { error: "Please fill all fields." };
        if (x2 === "" && y2 === "") return { error: "Please fill all fields." };

        let slope;
        if (!isNaN(m)) {
          slope = m;
          angle = +(Math.atan(slope) * (180 / Math.PI)).toFixed(4);
        } else {
          let a = (angle * Math.PI) / 180;
          slope = +Math.tan(a).toFixed(4);
        }

        if (!isNaN(x2)) {
          x2 = parseFloat(x2);
          y2 = +(slope * (x2 - x1) + y1).toFixed(4);
        } else {
          y2 = parseFloat(y2);
          x2 = +((y2 - y1) / slope + x1).toFixed(4);
        }

        x = x2 - x1;
        y = y2 - y1;
        let distance = +Math.sqrt(x * x + y * y).toFixed(4);
        b = +(y1 - slope * x1).toFixed(2);

        result = {
          tech_x: x,
          tech_y: y,
          tech_x2: x2,
          tech_y2: y2,
          tech_b: b,
          tech_slope: slope,
          tech_angle: angle + " deg",
          tech_distance: distance,
        };
      } else {
        result = { error: "Please fill all fields." };
      }
    } else if (type === "4") {
      if (!isNaN(x1) && !isNaN(y1)) {
        if (m === "" && angle === "")
          return { error: "Please fill all fields." };

        let slope;
        if (!isNaN(m)) {
          slope = m;
          angle = +(Math.atan(slope) * (180 / Math.PI)).toFixed(4);
        } else {
          let a = (angle * Math.PI) / 180;
          slope = +Math.tan(a).toFixed(4);
        }

        b = +(y1 - slope * x1).toFixed(4);
        result = {
          tech_b: b,
          tech_slope: slope,
          tech_angle: angle + " deg",
        };
      } else {
        result = { error: "Please fill all fields." };
      }
    } else if (type === "line") {
      if (!isNaN(x) && !isNaN(y) && !isNaN(b)) {
        x = x * -1;
        y = y * -1;
        let slope = +(x / y).toFixed(4);
        angle = +(Math.atan(slope) * (180 / Math.PI)).toFixed(4);
        b = +(b / y).toFixed(2);

        result = {
          tech_b: b,
          tech_slope: slope,
          tech_angle: angle + " deg",
        };
      } else {
        result = { error: "Please fill all fields." };
      }
    }

    return result;
  }

  /** getCalculationLongAdditionCalculator
   * POST: /api/calculators-lol/long-addition-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationLongAdditionCalculator(body) {
    let x = body.tech_x;
    let result = {};

    if (x && typeof x === "string") {
      let array = x.split(",").map((item) => item.trim());
      let number = true;
      let numbers = "";

      for (let value of array) {
        if (isNaN(value)) {
          number = false;
          break;
        }
        numbers += value + ", ";
      }

      if (number) {
        let numericArray = array.map(Number);
        let sum = numericArray.reduce((acc, val) => acc + val, 0);
        let total_nbr = numericArray.length;
        sum = sum.toFixed(2);

        result.tech_sum = sum;
        result.tech_numbers = numbers.trim();
        result.tech_total_nbr = total_nbr;
        result.tech_max = Math.max(...numericArray);
        result.tech_min = Math.min(...numericArray);
      } else {
        result.error = "Please Enter Only Numbers.";
      }
    } else {
      result.error = "Please Check Your Input.";
    }

    return result;
  }

  /** getCalculationStandardFormCalculator
   * POST: /api/calculators-lol/standard-form-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationStandardFormCalculator(body) {
    let x = body.tech_x;
    let result = {};

    if (!x || typeof x !== "string") {
      result.error = "Please Check Your Input.";
      return result;
    }

    // Clean up characters
    x = x.replace(/−/g, "-").replace(/×/g, "*");

    // Check for forbidden patterns
    const forbiddenPattern =
      /<|>|&|php|print_r|print|echo|script|≥|𝑥|•|,|g|y|m|=|%/i;
    if (forbiddenPattern.test(x)) {
      result.error = "Please Check Your Input.";
      return result;
    }

    let number, real_num;

    if (!isNaN(x)) {
      number = parseFloat(x);
      real_num = 1;
    } else {
      let nbr = x
        .split(/x\s?10\^|x10\^|\*10\^|\* 10\^/i)
        .map((s) => s.trim())
        .filter(Boolean);

      if (nbr.length > 1) {
        number = parseFloat(nbr[0]) * Math.pow(10, parseFloat(nbr[1]));
        real_num = 0;
      } else {
        try {
          number = eval(x);
          real_num = 1;
        } catch (e) {
          result.error = "Please Check Your Input.";
          return result;
        }
      }
    }

    if (typeof number === "number" && !isNaN(number)) {
      let orderOfMagnitude = getOrderOfMagnitude(number);
      let e_ans = number.toExponential(3);
      let [left, right] = e_ans.toUpperCase().split("E");
      let ee_ans = `${left[0]}${left[2] ?? ""}${left[3] ?? ""}${left[1] ?? ""}${
        left[4] ?? ""
      }`;
      let ee_p = parseInt(right) - 2;

      result.tech_ans = `${left} ×10<sup>${right}</sup>`;
      result.tech_left = left;
      result.tech_right = right;
      result.tech_e_ans = e_ans;
      result.tech_ee_ans = ee_ans;
      result.tech_ee_p = ee_p;
      result.tech_number = number;
      result.tech_real_num = real_num;
    } else {
      result.error = "Please Check Your Input.";
    }

    return result;

    function getOrderOfMagnitude(value) {
      if (value === 0) return null;
      let abs = Math.abs(value);
      let power = 0;
      while (abs >= 10) {
        abs /= 10;
        power++;
      }
      while (abs < 0.1) {
        abs *= 10;
        power--;
      }
      return power;
    }
  }

  /** getCalculationAverageCalculator
   * POST: /api/calculators-lol/average-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationAverageCalculator(body) {
    let x = body.tech_x;
    let more = body.tech_more;
    let seprate = body.tech_seprate;

    let result = {};
    let check = true;

    if (!x || x.trim() === "") {
      check = false;
    }

    // Determine the separator
    if (more === "space") {
      seprate = " ";
    } else if (more === ",") {
      seprate = ",";
    }

    if (!seprate) {
      seprate = " ";
    }

    let numbers = x
      .split(seprate)
      .map((s) => s.trim())
      .filter((s) => s !== "");

    for (let value of numbers) {
      if (isNaN(value)) {
        check = false;
        break;
      }
    }

    if (check) {
      numbers = numbers.map(Number).sort((a, b) => a - b);
      let sum = numbers.reduce((a, b) => a + b, 0);
      let count = numbers.length;
      let average = +(sum / count).toFixed(4);

      // Median
      let median;
      if (count % 2 !== 0) {
        median = numbers[Math.floor(count / 2)];
      } else {
        let mid1 = numbers[count / 2 - 1];
        let mid2 = numbers[count / 2];
        median = (mid1 + mid2) / 2;
      }

      // Mode and table
      let freqMap = {};
      let table = "";
      for (let val of numbers) {
        freqMap[val] = (freqMap[val] || 0) + 1;
      }

      let maxFreq = Math.max(...Object.values(freqMap));
      let mode = Object.keys(freqMap).filter((key) => freqMap[key] === maxFreq);

      for (let key in freqMap) {
        table += `<tr><td class='py-2 border-b'>${key}</td><td class='py-2 border-b'>${
          freqMap[key]
        }</td><td class='py-2 border-b'>${key * freqMap[key]}</td></tr>`;
      }

      // Standard deviations
      let m = +(sum / count).toFixed(3);
      let d = 0;
      for (let value of numbers) {
        d += Math.pow(value - m, 2);
      }

      let s_d_p = +Math.sqrt(d / count).toFixed(4);
      let s_d_s = +Math.sqrt(d / (count - 1)).toFixed(4);

      result.tech_table = table;
      result.tech_mode = mode;
      result.tech_s_d_p = s_d_p;
      result.tech_s_d_s = s_d_s;
      result.tech_median = median;
      result.tech_average = average;
      result.tech_count = count;
      result.tech_d = d;
      result.tech_numbers = numbers;
    } else {
      result.error = "Please Check Your Input.";
    }

    return result;
  }

  /** getCalculationLogAndAntilogCalculator
   * POST: /api/calculators-lol/log-antilog-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationLogAndAntilogCalculator(body) {
    let method = body.tech_method;
    let x = body.tech_x;
    let y = body.tech_y;

    let result = {};
    let check = true;

    if (isNaN(x)) {
      check = false;
    }

    if (check) {
      x = parseFloat(x);
      let base;

      if (method === "log" || method === "ln") {
        if (!isNaN(y)) {
          base = parseFloat(y);
        } else if (y === "e") {
          base = 2.71828;
        } else {
          base = 2.71828;
        }

        let ans = +(Math.log(x) / Math.log(base)).toFixed(5);
        result.tech_ans = ans;
      } else if (method === "anti") {
        if (!isNaN(y)) {
          base = parseFloat(y);
        } else if (y === "e") {
          base = 2.71828;
        } else {
          base = 10;
        }

        let ans = +Math.pow(base, x).toFixed(5);
        result.tech_ans = ans;
      } else {
        result.error = "Invalid method.";
      }
    } else {
      result.error = "Please Check Your Input.";
    }

    return result;
  }

  /** getCalculationCentroidCalculator
   * POST: /api/calculators-lol/centroid-triangle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCentroidCalculator(body) {
    let shap = body.tech_shap;
    let x1 = parseFloat(body.tech_x1);
    let y1 = parseFloat(body.tech_y1);
    let x2 = parseFloat(body.tech_x2);
    let y2 = parseFloat(body.tech_y2);
    let x3 = parseFloat(body.tech_x3);
    let y3 = parseFloat(body.tech_y3);
    let total = parseInt(body.tech_total);

    let result = {};

    if (
      !isNaN(x1) &&
      !isNaN(y1) &&
      !isNaN(x2) &&
      !isNaN(y2) &&
      !isNaN(x3) &&
      !isNaN(y3)
    ) {
      if (shap === "3") {
        let x = +((x1 + x2 + x3) / 3).toFixed(3);
        let y = +((y1 + y2 + y3) / 3).toFixed(3);
        let ans = `${x} , ${y}`;

        result.tech_ans = ans;
        result.tech_x1 = x1;
        result.tech_x2 = x2;
        result.tech_x3 = x1 + x2 + x3;
        result.tech_y1 = y1;
        result.tech_y2 = y2;
        result.tech_y3 = y1 + y2 + y3;
        result.tech_n = 3;
      } else {
        if (!isNaN(total)) {
          let sumX = 0;
          let sumY = 0;
          let x1Expr = "";
          let x2Expr = "";
          let y1Expr = "";
          let y2Expr = "";

          for (let i = 1; i <= total; i++) {
            let xi = parseFloat(body[`tech_x${i}`]);
            let yi = parseFloat(body[`tech_y${i}`]);

            if (isNaN(xi) || isNaN(yi)) {
              result.error = "Please! Check Your Input.";
              return result;
            }

            sumX += xi;
            sumY += yi;

            x1Expr += i !== total ? `x_${i} + ` : `x_${i}`;
            x2Expr += i !== total ? `${xi} + ` : `${xi}`;
            y1Expr += i !== total ? `y_${i} + ` : `y_${i}`;
            y2Expr += i !== total ? `${yi} + ` : `${yi}`;
          }

          let centroidX = +(sumX / total).toFixed(3);
          let centroidY = +(sumY / total).toFixed(3);
          let ans = `${centroidX} , ${centroidY}`;

          result.tech_x1 = x1Expr;
          result.tech_x2 = x2Expr;
          result.tech_x3 = sumX;
          result.tech_y1 = y1Expr;
          result.tech_y2 = y2Expr;
          result.tech_y3 = sumY;
          result.tech_n = total;
          result.tech_ans = ans;
        } else {
          result.error = "Please! Check Your Input.";
        }
      }
    } else {
      result.error = "Please! Check Your Input.";
    }

    return result;
  }

  /** getCalculationQuadraticFormulaCalculator
   * POST: /api/calculators-lol/quadratic-formula-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationQuadraticFormulaCalculator(body) {
    let a = parseFloat(body.tech_a);
    let b = parseFloat(body.tech_b);
    let c = parseFloat(body.tech_c);
    let formula = body.tech_formula;
    let method = body.tech_method;
    let result = {};

    if (!isNaN(a) && !isNaN(b) && !isNaN(c)) {
      let A = a;
      let B, C;

      if (formula === "1") {
        B = b;
        C = c;
      } else if (formula === "2") {
        B = -2 * b * A;
        C = Math.pow(b, 2) * A + c;
      } else if (formula === "3") {
        B = (b + c) * A;
        C = b * c * A;
      }

      let firstx = +((B * -1) / (2 * A)).toFixed(3);
      let firstPart = Math.pow(firstx, 2) * A;
      let secondPart = B * firstx;

      let eq = `${firstPart}${secondPart < 0 ? " " : " + "}${secondPart}${
        C < 0 ? " " : " + "
      }${C}`;
      let yaxis = +eval(eq).toFixed(3);

      result.tech_vertex = `${A}(x ${
        firstx < 0 ? "+ " + -firstx : "- " + firstx
      } )^2 ${yaxis < 0 ? "- " + -yaxis : "+ " + yaxis}`;

      let x1, x2;

      if (method == 2) {
        let dis = Math.pow(B, 2) - 4 * A * C;
        result.tech_dis = dis;
        if (dis > 0) {
          x1 = +((-B + Math.sqrt(dis)) / (2 * A)).toFixed(4);
          x2 = +((-B - Math.sqrt(dis)) / (2 * A)).toFixed(4);
          result.tech_fact = `${A}(x ${x1 < 0 ? "+ " + -x1 : "- " + x1} )(x ${
            x2 < 0 ? "+ " + -x2 : "- " + x2
          } )`;
          result.tech_roots = `x₁ = ${x1} , x₂ = ${x2}`;
        } else if (dis < 0) {
          let real = +(-B / (2 * A)).toFixed(4);
          let imag = +(Math.sqrt(-dis) / (2 * A)).toFixed(4);
          result.tech_fact = `${A}(x - (${real} + ${imag}i) )(x - (${real} - ${imag}i) )`;
          result.tech_roots = `x₁ = ${real} + ${imag}i<br> x₂ = ${real} - ${imag}i`;
        } else {
          x1 = +(-B / (2 * A)).toFixed(4);
          result.tech_fact = `${A}(x ${x1 < 0 ? "+ " + -x1 : "- " + x1})^2`;
          result.tech_roots = `x = ${x1}`;
        }
      } else if (method == 1) {
        let leftSide = B / A;
        let C_ = -C / A;
        let rightSide = C_ + Math.pow(B, 2) / Math.pow(2 * A, 2);

        if (rightSide > 0) {
          x1 = +(-leftSide / 2 + Math.sqrt(rightSide)).toFixed(4);
          x2 = +(-leftSide / 2 - Math.sqrt(rightSide)).toFixed(4);
          result.tech_fact = `${A}(x ${x1 < 0 ? "+ " + -x1 : "- " + x1} )(x ${
            x2 < 0 ? "+ " + -x2 : "- " + x2
          } )`;
          result.tech_roots = `x₁ = ${x1} , x₂ = ${x2}`;
        } else if (rightSide < 0) {
          let real = +(-leftSide / 2).toFixed(4);
          let imag = +Math.sqrt(-rightSide).toFixed(4);
          result.tech_fact = `${A}(x - (${real} + ${imag}i) )(x - (${real} - ${imag}i) )`;
          result.tech_roots = `x₁ = ${real} + ${imag}i<br> x₂ = ${real} - ${imag}i`;
        } else {
          x1 = +(-leftSide / 2).toFixed(4);
          result.tech_fact = `${A}(x ${x1 < 0 ? "+ " + -x1 : "- " + x1})^2`;
          result.tech_roots = `x = ${x1}`;
        }
        if (typeof x1 !== "undefined") result.tech_x1 = x1;
        if (typeof x2 !== "undefined") result.tech_x2 = x2;
      }

      result.tech_B = B;
      result.tech_C = C;
    } else {
      result.error = "Please fill all fields.";
    }

    return result;
  }

  /** getCalculationQuotientAndRemainderCalculator
   * POST: /api/calculators-lol/remainder-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationQuotientAndRemainderCalculator(body) {
    let x = parseFloat(body.tech_x);
    let y = parseFloat(body.tech_y);
    let result = {};

    if (!isNaN(x) && !isNaN(y)) {
      let mod = x % y;
      let q = Math.floor(x / y);

      result.tech_r = mod;
      result.tech_q = q;
    } else {
      result.error = "Please Check Your Input.";
    }

    return result;
  }

  /** getCalculationRoundingCalculator
   * POST: /api/calculators-lol/rounding-numbers-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRoundingCalculator(body) {
    let number = parseFloat(body.tech_number);
    let mode = body.tech_mode; // Currently unused but kept for consistency
    let per = parseInt(body.tech_per);
    let result = {};

    if (!isNaN(number)) {
      // Helper function for rounding with precision (simulating PHP_ROUND_HALF_UP)
      function roundTo(value, places) {
        let factor = Math.pow(10, places);
        return Math.round(value * factor) / factor;
      }

      let ans = roundTo(number, per);
      let one = roundTo(number, 0);
      let two = roundTo(number, -1);
      let three = roundTo(number, -2);
      let four = roundTo(number, -3);

      result.tech_ans = ans;
      result.tech_one = one;
      result.tech_two = two;
      result.tech_three = three;
      result.tech_four = four;
    } else {
      result.error = "Please Check Your Input.";
    }

    return result;
  }

  /** getCalculationFractionToDecimalCalculator
   * POST: /api/calculators-lol/fraction-to-decimal-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationFractionToDecimalCalculator(body) {
    let n1 = parseFloat(body.tech_n1); // whole number part (optional)
    let n2 = parseFloat(body.tech_n2); // numerator
    let d1 = parseFloat(body.tech_d1); // denominator
    let round = parseInt(body.tech_round);
    let result = {};

    if (!isNaN(n2) && !isNaN(d1)) {
      let totalN = n2;
      let totalD = d1;

      if (!isNaN(n1)) {
        if (n1 < 0 && totalN > 0) {
          totalN = -totalN;
        }
        totalN = totalD * n1 + totalN;
      }

      // GCD function
      function gcd(a, b) {
        a = Math.abs(a);
        b = Math.abs(b);
        if (a < b) [a, b] = [b, a];
        if (b === 0) return 1;
        let r = a % b;
        while (r > 0) {
          a = b;
          b = r;
          r = a % b;
        }
        return b;
      }

      // Reduce fraction
      function reduce(num, den) {
        let g = gcd(num, den);
        return [num / g, den / g];
      }

      let ans = +(totalN / totalD).toFixed(round);
      let g = gcd(totalN, totalD);
      let [upr, btm] = reduce(totalN, totalD);

      result.tech_ans = ans;
      result.tech_upr = upr;
      result.tech_totalN = totalN;
      result.tech_totalD = totalD;
      result.tech_g = g;
      result.tech_btm = btm;
    } else {
      result.error = "Please! Check Your Input.";
    }

    return result;
  }

  /** getCalculationDecimalToFractionCalculator
   * POST: /api/calculators-lol/decimal-to-fraction-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDecimalToFractionCalculator(body) {
    let dec = body.tech_dec; // Input decimal number (e.g., "0.75" or "0.666")
    let repeat = parseInt(body.tech_repeat); // Number of repeating digits, if provided
    let result = {};

    // ✅ Input validation
    if (dec === undefined || isNaN(Number(dec))) {
      result.error = "Please! Check Your Input.";
      return result;
    }

    dec = dec.toString(); // Ensure it's a string for splitting
    if (!dec.includes(".")) {
      result.error = "Please provide a decimal number (e.g., 0.75).";
      return result;
    }

    let nbr = dec.split("."); // Split into integer and fractional parts

    if (!isNaN(repeat) && repeat > 0) {
      // 🔁 Handle repeating decimal
      let repeatDigits = nbr[1].slice(-repeat); // Get repeating part from right
      if (repeat > nbr[1].length) {
        result.error = "Please! Check Your Input.";
        return result;
      }

      let input = dec.split(repeatDigits)[0] + `bar(${repeatDigits})`; // Format input with bar notation
      let add = "1";
      let first = dec;
      for (let i = 1; i <= repeat; i++) {
        add += "0"; // Build multiplier like 10, 100, etc.
        first += repeatDigits; // Extend decimal
      }

      let second = Number(first) * Number(add);
      let third = second - Number(first);

      let totalLength = nbr[0].length + nbr[1].length;
      let thirdRounded = Number(
        third.toFixed(totalLength - Math.floor(second).toString().length)
      );

      // Prepare numerator and denominator
      let numParts = thirdRounded.toString().split(".");
      let div = "1";
      if (numParts.length > 1) {
        for (let i = 1; i <= numParts[1].length; i++) div += "0";
      }

      let upr = thirdRounded * Number(div);
      let div_ = Number(div);
      let finalDiv = (Number(add) - 1) * Number(div);

      // Helper function: GCD
      function gcd(a, b) {
        a = Math.abs(a);
        b = Math.abs(b);
        while (b !== 0) {
          [a, b] = [b, a % b];
        }
        return a;
      }

      // Reduce fraction
      function reduce(num, den) {
        let g = gcd(num, den);
        return [num / g, den / g];
      }

      let g = gcd(upr, finalDiv);
      let [uper, btm] = reduce(upr, finalDiv);

      // Final result object
      result.tech_input = input;
      result.tech_last_n = repeatDigits;
      result.tech_second = second;
      result.tech_third = thirdRounded;
      result.tech_add = add;
      result.tech_upr = upr;
      result.tech_div = finalDiv;
      result.tech_div_ = div_;
      result.tech_uper = uper;
      result.tech_btm = btm;
      result.tech_g = g;
      return result;
    } else {
      // 🟡 Non-repeating decimal case
      let div = "1";
      if (nbr.length > 1) {
        for (let i = 1; i <= nbr[1].length; i++) div += "0"; // Build denominator (e.g., 100 for .75)
      }

      let upr = Number(nbr[0] + nbr[1]); // Join integer + fractional
      let finalDiv = Number(div);

      // GCD and reduce
      function gcd(a, b) {
        a = Math.abs(a);
        b = Math.abs(b);
        while (b !== 0) {
          [a, b] = [b, a % b];
        }
        return a;
      }

      function reduce(num, den) {
        let g = gcd(num, den);
        return [num / g, den / g];
      }

      let g = gcd(upr, finalDiv);
      let [uper, btm] = reduce(upr, finalDiv);

      // Final result object
      result.tech_upr = upr;
      result.tech_div = finalDiv;
      result.tech_uper = uper;
      result.tech_btm = btm;
      result.tech_g = g;
      return result;
    }
  }

  /** getCalculationFractionToPercentCalculator
   * POST: /api/calculators-lol/fraction-to-percent-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationFractionToPercentCalculator(body) {
    let n1 = parseFloat(body.tech_n1); // whole number part (optional)
    let n2 = parseFloat(body.tech_n2); // numerator
    let d1 = parseFloat(body.tech_d1); // denominator
    let round = parseInt(body.tech_round);
    let result = {};

    if (!isNaN(n2) && !isNaN(d1)) {
      let totalN = n2;
      let totalD = d1;

      if (!isNaN(n1)) {
        if (n1 < 0 && totalN > 0) {
          totalN = -totalN;
        }
        totalN = totalD * n1 + totalN;
      }

      // GCD function
      function gcd(a, b) {
        a = Math.abs(a);
        b = Math.abs(b);
        if (a < b) [a, b] = [b, a];
        if (b === 0) return 1;
        let r = a % b;
        while (r > 0) {
          a = b;
          b = r;
          r = a % b;
        }
        return b;
      }

      // Reduce fraction
      function reduce(num, den) {
        let g = gcd(num, den);
        return [num / g, den / g];
      }

      let ans = +(totalN / totalD).toFixed(round);
      let g = gcd(totalN, totalD);
      let [upr, btm] = reduce(totalN, totalD);

      result.tech_ans = ans;
      result.tech_upr = upr;
      result.tech_totalN = totalN;
      result.tech_totalD = totalD;
      result.tech_g = g;
      result.tech_btm = btm;
    } else {
      result.error = "Please! Check Your Input.";
    }

    return result;
  }

  /** getCalculationPercentToFractionCalculator
   * POST: /api/calculators-lol/percent-to-fraction-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPercentToFractionCalculator(body) {
    let percent = body.tech_percent;
    let result = {};

    if (percent === undefined || isNaN(Number(percent))) {
      result.error = "Please! Check Your Input.";
      return result;
    }

    let decimal = Number(percent) / 100;
    let decimalStr = decimal.toString();

    let nbr = decimalStr.split(".");
    if (nbr.length < 2) {
      nbr.push("0"); // If no decimal, treat as ".0"
    }

    let div = "1";
    for (let i = 1; i <= nbr[1].length; i++) {
      div += "0";
    }

    let upr = Number(nbr[0] + nbr[1]);
    let den = Number(div);

    function gcd(a, b) {
      a = Math.abs(a);
      b = Math.abs(b);
      while (b !== 0) {
        [a, b] = [b, a % b];
      }
      return a;
    }

    function reduce(num, den) {
      let g = gcd(num, den);
      return [num / g, den / g];
    }

    let g = gcd(upr, den);
    let [uper, btm] = reduce(upr, den);

    result.tech_upr = upr;
    result.tech_div = den;
    result.tech_uper = uper;
    result.tech_btm = btm;
    result.tech_g = g;
    return result;
  }

  /** getCalculationMillionBillionLakhCalculator
   * POST: /api/calculators-lol/million-billion-lakh-crore
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMillionBillionLakhCalculator(body) {
    let from_new = body.tech_from_new ?? false;
    let calFrom_new = body.tech_calFrom_new ?? false;
    let calto_new = body.tech_calto_new ?? false;

    let from = body.tech_from;
    let f_u = body.tech_calFrom;
    let t_u = body.tech_calto;

    if (from_new && !isNaN(from_new)) {
      from = from_new;
    }

    if (calFrom_new) {
      f_u = calFrom_new;
    }

    if (calto_new) {
      t_u = calto_new;
    }

    let result = {};

    if (!isNaN(from)) {
      let from_input = from;
      let f_u_input = f_u;
      let t_u_input = t_u;
      let to = from;
      let t1, t2, t3, t4, t5, t6, t7, t8;

      const unitMultipliers = {
        Hundred: 1,
        Thousand: 10,
        Lakh: 1000,
        Million: 10000,
        Crore: 100000,
        Billion: 10000000,
        Trillion: 10000000000,
        Arab: 10000000,
        Kharab: 1000000000,
      };

      if (f_u === t_u) {
        to = from;
      } else {
        if (unitMultipliers[f_u]) {
          from = from * unitMultipliers[f_u];
        }

        const conversions = {
          to,
          t1: from / 10 + " Thousand",
          t2: from / 1000 + " Lakh",
          t3: from / 10000 + " Million",
          t4: from / 100000 + " Crore",
          t5: from / 10000000 + " Billion",
          t6: from / 10000000000 + " Trillion",
          t7: from / 10000000 + " Arab",
          t8: from / 1000000000 + " Kharab",
        };

        to = unitMultipliers[t_u] ? from / unitMultipliers[t_u] : from;

        ({ t1, t2, t3, t4, t5, t6, t7, t8 } = conversions);
      }

      // Define dummy input arrays for table generation
      const input = [
        "Hundred",
        "Thousand",
        "Lakh",
        "Million",
        "Crore",
        "Billion",
        "Trillion",
        "Arab",
        "Kharab",
      ];
      const numbers = [1, 10, 50, 100, 500, 1000];

      let table = "";
      for (let i = 0; i < 9; i++) {
        let rand1 = input[Math.floor(Math.random() * input.length)];
        let rand2 = input[Math.floor(Math.random() * input.length)];
        let nbr = numbers[Math.floor(Math.random() * numbers.length)];
        table += `<div class='col-span-6 md:col-span-4 lg:col-span-4'>
            <input type='submit' name='submit' class='rounded-lg hover:bg-[#99EA48] cursor-pointer' value='${nbr} ${rand1} to ${rand2}'>
          </div>`;
      }

      result.tech_to = to;
      result.tech_t1 = t1;
      result.tech_t2 = t2;
      result.tech_t3 = t3;
      result.tech_t4 = t4;
      result.tech_t5 = t5;
      result.tech_t6 = t6;
      result.tech_t7 = t7;
      result.tech_t8 = t8;
      result.tech_table = table;
      result.tech_from_input = from_input;
      result.tech_f_u_input = f_u_input;
      result.tech_t_u_input = t_u_input;

      return result;
    } else {
      return { error: "Please Check Your Input." };
    }
  }

  /** getCalculationPointSlopeFormCalculator
   * POST: /api/calculators-lol/point-slope-form-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPointSlopeFormCalculator(body) {
    let point_unit = body.tech_point_unit;
    let x1 = body.tech_x1;
    let y1 = body.tech_y1;
    let m = body.tech_m;
    let sec_x1 = body.tech_sec_x1;
    let sec_y1 = body.tech_sec_y1;
    let sec_x2 = body.tech_sec_x2;
    let sec_y2 = body.tech_sec_y2;

    let result = {};

    if (point_unit === "1") {
      if (!isNaN(x1) && !isNaN(y1) && !isNaN(m)) {
        x1 = -x1;
        y1 = -y1;
        let mn = x1 * m;

        let s = `y ${y1 < 0 ? "- " + Math.abs(y1) : "+ " + y1} = ${m}(x ${
          x1 < 0 ? "- " + Math.abs(x1) : "+ " + x1
        })`;
        let s1 = `(y ${y1 < 0 ? "- " + Math.abs(y1) : "+ " + y1}) = ${m}x ${
          mn < 0 ? "- " + Math.abs(mn) : "+ " + mn
        }`;
        let s2 = `y = ${m}x ${mn < 0 ? "- " + Math.abs(mn) : "+ " + mn} ${
          y1 < 0 ? "+ " + Math.abs(y1) : "- " + y1
        }`;
        let val = mn + y1;
        let s3 = `y = ${m}x ${val < 0 ? "- " + Math.abs(val) : "+ " + val}`;
        let s4 = `${m}x - y ${val < 0 ? "- " + Math.abs(val) : "+ " + val} = 0`;

        result.tech_s = s;
        result.tech_s1 = s1;
        result.tech_s2 = s2;
        result.tech_s3 = s3;
        result.tech_s4 = s4;
      } else {
        return { error: "Please! Check Your Input." };
      }
    } else {
      if (
        !isNaN(sec_x1) &&
        !isNaN(sec_y1) &&
        !isNaN(sec_x2) &&
        !isNaN(sec_y2)
      ) {
        if (sec_x1 == sec_x2) {
          return {
            error: "Please Check Your Input: x1 and x2 cannot be the same.",
          };
        }

        m = (sec_y2 - sec_y1) / (sec_x2 - sec_x1);
        let slope = m;

        sec_x1 = -sec_x1;
        sec_y1 = -sec_y1;
        let mn = sec_x1 * m;

        let s = `(y ${
          sec_y1 < 0 ? "- " + Math.abs(sec_y1) : "+ " + sec_y1
        }) = ${m}(x ${sec_x1 < 0 ? "- " + Math.abs(sec_x1) : "+ " + sec_x1})`;
        let s1 = `(y ${
          sec_y1 < 0 ? "- " + Math.abs(sec_y1) : "+ " + sec_y1
        }) = ${m}x ${mn < 0 ? "- " + Math.abs(mn) : "+ " + mn}`;
        let s2 = `y = ${m}x ${mn < 0 ? "- " + Math.abs(mn) : "+ " + mn} ${
          sec_y1 < 0 ? "+ " + Math.abs(sec_y1) : "- " + sec_y1
        }`;
        let val = mn + sec_y1;
        let s3 = `y = ${m}x ${val < 0 ? "- " + Math.abs(val) : "+ " + val}`;
        let s4 = `${m}x - y ${val < 0 ? "- " + Math.abs(val) : "+ " + val} = 0`;

        result.tech_s = s;
        result.tech_s1 = s1;
        result.tech_s2 = s2;
        result.tech_s3 = s3;
        result.tech_s4 = s4;
        result.tech_slope = slope;
      } else {
        return { error: "Please! Check Your Input." };
      }
    }

    return result;
  }

  /** getCalculationHemisphereCalculator
   * POST: /api/calculators-lol/hemisphere-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationHemisphereCalculator(body) {
    let to_calculate = body.tech_to_calculate;
    let val = parseFloat(body.tech_value);
    let unit = body.tech_unit;
    let rof = parseInt(body.tech_rof);
    let result = {};

    if (!isNaN(val)) {
      let r, c, v, a, b, tsa, pc, pv, pa, pb, ptsa;

      const π = Math.PI;

      if (to_calculate === "rad") {
        r = val + " " + unit;
        c = (2 * π * val).toFixed(rof) + " " + unit;
        v =
          ((2 / 3) * π * Math.pow(val, 3)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>3</sup>";
        a =
          (2 * π * Math.pow(val, 2)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        b =
          (π * Math.pow(val, 2)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        tsa =
          (3 * π * Math.pow(val, 2)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        pc = (2 * val).toFixed(rof) + " π " + unit;
        pv =
          ((2 / 3) * Math.pow(val, 3)).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>3</sup>";
        pa =
          (2 * Math.pow(val, 2)).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        pb =
          Math.pow(val, 2).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        ptsa =
          (3 * Math.pow(val, 2)).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>2</sup>";
      } else if (to_calculate === "vol") {
        r = Math.pow((3 * val) / (2 * π), 1 / 3).toFixed(rof);
        c = (2 * π * r).toFixed(rof) + " " + unit;
        v = val.toFixed(rof) + " " + unit + "<sup class='font-s-14'>3</sup>";
        a =
          (2 * π * Math.pow(r, 2)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        b =
          (π * Math.pow(r, 2)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        tsa =
          (3 * π * Math.pow(r, 2)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        pc = (2 * r).toFixed(rof) + " π " + unit;
        pv =
          ((2 / 3) * Math.pow(r, 3)).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>3</sup>";
        pa =
          (2 * Math.pow(r, 2)).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        pb =
          Math.pow(r, 2).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        ptsa =
          (3 * Math.pow(r, 2)).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        r = r + " " + unit;
      } else if (to_calculate === "tsa") {
        r = Math.sqrt(val / (3 * π)).toFixed(rof);
        c = (2 * π * r).toFixed(rof) + " " + unit;
        v =
          ((2 / 3) * π * Math.pow(r, 3)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>3</sup>";
        a =
          (2 * π * Math.pow(r, 2)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        b =
          (π * Math.pow(r, 2)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        tsa = val.toFixed(rof) + " " + unit + "<sup class='font-s-14'>2</sup>";
        pc = (2 * r).toFixed(rof) + " π " + unit;
        pv =
          ((2 / 3) * Math.pow(r, 3)).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>3</sup>";
        pa =
          (2 * Math.pow(r, 2)).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        pb =
          Math.pow(r, 2).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        ptsa =
          (3 * Math.pow(r, 2)).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        r = r + " " + unit;
      } else if (to_calculate === "csa") {
        r = Math.sqrt(val / (2 * π)).toFixed(rof);
        c = (2 * π * r).toFixed(rof) + " " + unit;
        v =
          ((2 / 3) * π * Math.pow(r, 3)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>3</sup>";
        a = val.toFixed(rof) + " " + unit + "<sup class='font-s-14'>2</sup>";
        b =
          (π * Math.pow(r, 2)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        tsa =
          (3 * π * Math.pow(r, 2)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        pc = (2 * r).toFixed(rof) + " π " + unit;
        pv =
          ((2 / 3) * Math.pow(r, 3)).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>3</sup>";
        pa =
          (2 * Math.pow(r, 2)).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        pb =
          Math.pow(r, 2).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        ptsa =
          (3 * Math.pow(r, 2)).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        r = r + " " + unit;
      } else if (to_calculate === "cf") {
        r = (val / (2 * π)).toFixed(rof);
        c = (2 * π * r).toFixed(rof) + " " + unit;
        v =
          ((2 / 3) * π * Math.pow(r, 3)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>3</sup>";
        a =
          (2 * π * Math.pow(r, 2)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        b = val.toFixed(rof) + " " + unit + "<sup class='font-s-14'>2</sup>";
        tsa =
          (3 * π * Math.pow(r, 2)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        pc = (2 * r).toFixed(rof) + " π " + unit;
        pv =
          ((2 / 3) * Math.pow(r, 3)).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>3</sup>";
        pa =
          (2 * Math.pow(r, 2)).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        pb =
          Math.pow(r, 2).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        ptsa =
          (3 * Math.pow(r, 2)).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        r = r + " " + unit;
      }

      result = {
        tech_radi: r,
        tech_cs: c,
        tech_vs: v,
        tech_as: a,
        tech_bs: b,
        tech_tsas: tsa,
        tech_pcs: pc,
        tech_pvs: pv,
        tech_pas: pa,
        tech_pbs: pb,
        tech_ptsas: ptsa,
      };
    } else {
      result.error = "Please! Check Your Input.";
    }

    return result;
  }

  /** getCalculationDiscriminantCalculator
   * POST: /api/calculators-lol/discriminant-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDiscriminantCalculator(body) {
    let to_calculate = body.tech_to_calculate;
    let value = parseFloat(body.tech_value);
    let value1 = parseFloat(body.tech_value1);
    let value2 = parseFloat(body.tech_value2);
    let value3 = parseFloat(body.tech_value3);
    let value4 = parseFloat(body.tech_value4);

    let param = {};

    if (to_calculate === "2d") {
      if (!isNaN(value) && !isNaN(value1) && !isNaN(value2)) {
        let A = value;
        let B = value1;
        let C = value2;
        let ds = Math.pow(B, 2) - 4 * A * C;
        let nr =
          ds === 0
            ? "The polynomial has a double root."
            : ds > 0
            ? "The polynomial has two distinct real roots"
            : "The polynomial has a pair of conjugate complex roots";

        param.tech_sd = ds;
        param.tech_nrs = nr;
        return param;
      }
    } else if (to_calculate === "3d") {
      if (!isNaN(value) && !isNaN(value1) && !isNaN(value2) && !isNaN(value3)) {
        let A = value;
        let B = value1;
        let C = value2;
        let D = value3;
        let ds =
          Math.pow(B, 2) * Math.pow(C, 2) -
          4 * A * Math.pow(C, 3) -
          4 * Math.pow(B, 3) * D -
          27 * Math.pow(A, 2) * Math.pow(D, 2) +
          18 * A * B * C * D;
        let nr =
          ds === 0
            ? "At least two roots are equal (one root of multiplicity 3 or two distinct real roots) one of which is a double root"
            : ds > 0
            ? "The roots are three distinct real numbers"
            : "There is one real root and two complex conjugate roots";

        param.tech_sd = ds;
        param.tech_nrs = nr;
        return param;
      }
    } else if (to_calculate === "4d") {
      if (
        !isNaN(value) &&
        !isNaN(value1) &&
        !isNaN(value2) &&
        !isNaN(value3) &&
        !isNaN(value4)
      ) {
        let A = value;
        let B = value1;
        let C = value2;
        let D = value3;
        let E = value4;
        let ds =
          256 * Math.pow(A, 3) * Math.pow(E, 3) -
          192 * Math.pow(A, 2) * B * D * Math.pow(E, 2) -
          128 * Math.pow(A, 2) * Math.pow(C, 2) * Math.pow(E, 2) +
          144 * Math.pow(A, 2) * C * Math.pow(D, 2) * E -
          27 * Math.pow(A, 2) * Math.pow(D, 4) +
          144 * A * Math.pow(B, 2) * C * Math.pow(E, 2) -
          6 * A * Math.pow(B, 2) * Math.pow(D, 2) * E -
          80 * A * B * Math.pow(C, 2) * D * E +
          18 * A * B * C * Math.pow(D, 3) +
          16 * A * Math.pow(C, 4) * E -
          4 * A * Math.pow(C, 3) * Math.pow(D, 2) -
          27 * Math.pow(B, 4) * Math.pow(E, 2) +
          18 * Math.pow(B, 3) * C * D * E -
          4 * Math.pow(B, 3) * Math.pow(D, 3) -
          4 * Math.pow(B, 2) * Math.pow(C, 3) * E +
          Math.pow(B, 2) * Math.pow(C, 2) * Math.pow(D, 2);
        let nr =
          ds === 0
            ? "There are two or more equal roots"
            : ds > 0
            ? "There are four distinct real roots or four distinct non-real roots"
            : "There are two distinct real roots and two distinct non-real roots";

        param.tech_sd = ds;
        param.tech_nrs = nr;
        return param;
      }
    }

    param.error = "Please! Check Your Input.";
    return param;
  }

  /** getCalculationEndpointCalculator
   * POST: /api/calculators-lol/endpoint-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationEndpointCalculator(body) {
    let x1 = parseFloat(body.tech_x1);
    let y1 = parseFloat(body.tech_y1);
    let x = parseFloat(body.tech_x);
    let y = parseFloat(body.tech_y);

    let param = {};

    if (!isNaN(x1) && !isNaN(y1) && !isNaN(x) && !isNaN(y)) {
      let x2 = 2 * x - x1;
      let y2 = 2 * y - y1;
      let dis = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
      dis = Math.round(dis * 10000) / 10000;

      param.tech_x2 = x2;
      param.tech_y2 = y2;
      param.tech_dis = dis;
      return param;
    } else {
      param.error = "Please! Check Your Input.";
      return param;
    }
  }

  /** getCalculationSlopeInterceptFormCalculator
   * POST: /api/calculators-lol/slope-intercept-form-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSlopeInterceptFormCalculator(body) {
    let type = body.tech_type;
    let x1 = parseFloat(body.tech_x1);
    let x2 = parseFloat(body.tech_x2);
    let y1 = parseFloat(body.tech_y1);
    let y2 = parseFloat(body.tech_y2);

    let param = {};

    if (type === "2") {
      if (!isNaN(x1) && !isNaN(x2) && !isNaN(y1) && !isNaN(y2)) {
        let x = x2 - x1;
        let y = y2 - y1;
        let slope = parseFloat((y / x).toFixed(4));
        let angle = parseFloat((Math.atan(slope) * (180 / Math.PI)).toFixed(4));
        let distance = parseFloat(
          Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)).toFixed(4)
        );
        let b = parseFloat((y1 - slope * x1).toFixed(2));

        param.tech_x = x;
        param.tech_y = y;
        param.tech_slope = slope;
        param.tech_angle = `${angle} deg`;
        param.tech_distance = distance;
        param.tech_b = b;
      } else {
        param.error = "Please! Check Your Input.";
      }
    } else if (type === "1") {
      let slope = x2; // here x2 is passed as slope

      if (!isNaN(x1) && !isNaN(y1) && !isNaN(slope)) {
        let angle = parseFloat((Math.atan(slope) * (180 / Math.PI)).toFixed(4));
        let b = parseFloat((y1 - slope * x1).toFixed(4));

        param.tech_b = b;
        param.tech_slope = slope;
        param.tech_angle = `${angle} deg`;
      } else {
        param.error = "Please! Check Your Input.";
      }
    } else {
      let b = x1;
      let slope = x2;

      if (!isNaN(b) && !isNaN(slope)) {
        let angle = parseFloat((Math.atan(slope) * (180 / Math.PI)).toFixed(4));

        param.tech_b = b;
        param.tech_slope = slope;
        param.tech_angle = `${angle} deg`;
      } else {
        param.error = "Please! Check Your Input.";
      }
    }

    return param;
  }

  /** getCalculationFactorialCalculator
   * POST: /api/calculators-lol/exponent-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationExponentCalculator(body) {
    let b = body.tech_b;
    let x = body.tech_x;

    let param = {};

    const invalidPattern = /<|>|\&|php|print_r|print|echo|script|=|%/i;

    if (invalidPattern.test(b) || invalidPattern.test(x)) {
      param.error = "Please Enter Valid Input.";
      return param;
    }

    if (b !== undefined && x !== undefined && b !== "" && x !== "") {
      if (b.toString().length <= 7) {
        let expVal = Number(x);
        if (expVal <= 2000) {
          try {
            let base = eval(b);
            let exponent = eval(x);
            let result = Math.pow(base, exponent);

            param.tech_result = result;
            param.tech_b = base;
            param.tech_x = exponent;
            return param;
          } catch (e) {
            param.error = "Invalid expression.";
            return param;
          }
        } else {
          param.error = "Use exponents less than 2000.";
          return param;
        }
      } else {
        param.error = "Enter base less than 7 characters.";
        return param;
      }
    } else {
      param.error = "Please Enter Numbers.";
      return param;
    }
  }

  /** getCalculationSquareRootCalculator
   * POST: /api/calculators-lol/square-root-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSquareRootCalculator(body) {
    let n = body.tech_n;
    let n1 = body.tech_n1;
    let rt = body.tech_rt;
    let selection = body.tech_selection;

    let param = {};

    const invalidPattern = /<|>|&|php|print_r|print|echo|script|=|%/i;
    if (
      invalidPattern.test(n) ||
      invalidPattern.test(n1) ||
      invalidPattern.test(rt)
    ) {
      param.error = "Please Enter Valid Input.";
      return param;
    }

    let num;
    let result;

    if (selection === "1") {
      if (!n) {
        param.error = "Please Enter Numbers";
        return param;
      }
      num = eval(n);
      if (num < 0) {
        num = Math.abs(num);
        param.tech_iota = "iota";
      }
      result = Math.sqrt(num);
      param.tech_check = "sr";
    } else if (selection === "2") {
      if (!n1 || !rt) {
        param.error = "Please Enter Numbers";
        return param;
      }
      num = eval(n1);
      let root = eval(rt);

      if (num < 0 && root < 0) {
        param.error = "Please Enter Positive Numbers";
        return param;
      } else if (num < 0 && root === 2) {
        num = Math.abs(num);
        param.tech_iota = "iota";
      } else if (num < 0 && root % 2 === 0) {
        param.error = "Please Enter Positive Numbers";
        return param;
      } else {
        num = Math.abs(num);
      }

      result = Math.pow(num, 1 / root);
      param.tech_check = "gr";
      param.tech_root = root;
    } else {
      param.error = "Invalid selection";
      return param;
    }

    // Factorization for simplifying roots
    const primeFactor = (n) => {
      let factors = [];
      for (let i = 2; i <= Math.sqrt(n); i++) {
        while (n % i === 0) {
          factors.push(i);
          n /= i;
        }
      }
      if (n > 1) factors.push(n);
      return factors;
    };

    const isPerfectSquare = (n) => Number.isInteger(Math.sqrt(n));

    let radicand = num;
    let factors = primeFactor(radicand);
    let counts = factors.reduce((a, b) => {
      a[b] = (a[b] || 0) + 1;
      return a;
    }, {});

    let final = [],
      product = 1,
      valShow = [];

    for (let [prime, count] of Object.entries(counts)) {
      count = +count;
      if (count === 1) {
        final.push(+prime);
      } else if (count % 2 === 0) {
        final.push(Math.pow(prime, count));
        valShow.push(Math.pow(prime, count));
      } else {
        final.push(Math.pow(prime, count - 1));
        final.push(+prime);
        valShow.push(Math.pow(prime, count - 1));
      }
    }

    for (let v of final) {
      if (!isPerfectSquare(v)) {
        product *= v;
      }
    }

    let sqrShow = valShow.map((v) => Math.sqrt(v));

    // Build factor strings
    let factorArr = final.map((v) => v.toString());
    let productArr = final.map((v) =>
      isPerfectSquare(v) ? Math.sqrt(v).toString() : ""
    );
    let factor = factorArr.join(" * ");
    let factor1 = factorArr
      .map((v, i) => {
        let sq = productArr[i] ? "√" : "";
        return `${v} ${sq}`;
      })
      .join(" * ");

    param.tech_factor = factor;
    param.tech_factor1 = factor1;
    param.tech_product = product;
    param.tech_sqr_show = sqrShow;
    param.tech_result = result;
    param.tech_num = num;

    return param;
  }

  /** getCalculationBinaryCalculator
   * POST: /api/calculators-lol/binary-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationBinaryCalculator(body) {
    let bnr_tpe1 = body.tech_bnr_tpe1;
    let bnr_tpe2 = body.tech_bnr_tpe2;
    let bnr_frs = body.tech_bnr_frs;
    let bnr_sec = body.tech_bnr_sec;
    let bnr_slc = body.tech_bnr_slc;

    let param = {};

    function bnrType(nn, type) {
      if (type === "binary") {
        return parseInt(nn, 2);
      } else if (type === "decimal") {
        return parseInt(nn, 10);
      } else if (type === "hexadecimal") {
        return parseInt(nn, 16);
      } else if (type === "octal") {
        return parseInt(nn, 8);
      }
      return NaN;
    }

    let fN = bnrType(bnr_frs, bnr_tpe1);
    let sN = bnrType(bnr_sec, bnr_tpe2);

    function bnrCal(fN, sN, op) {
      let rN, dc, bn, hx, oc;

      if (op === "add") {
        rN = fN + sN;
      } else if (op === "sub") {
        rN = fN - sN;
      } else if (op === "mult") {
        rN = fN * sN;
      } else if (op === "divd") {
        rN = fN / sN;
      }

      dc = op === "divd" ? Math.round(rN) : rN;
      const absDc = Math.abs(dc);
      const sign = dc < 0 ? "-" : "";

      bn = sign + absDc.toString(2);
      hx = sign + absDc.toString(16).toUpperCase();
      oc = sign + absDc.toString(8);

      return [bn, dc, hx, oc];
    }

    const [bn, dc, hx, oc] = bnrCal(fN, sN, bnr_slc);

    param.tech_bn = bn;
    param.tech_dc = dc;
    param.tech_hx = hx;
    param.tech_oc = oc;

    return param;
  }

  /** getCalculationProportionCalculator
   * POST: /api/calculators-lol/proportion-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationProportionCalculator(body) {
    let a = body.tech_a;
    let b = body.tech_b;
    let c = body.tech_c;
    let d = body.tech_d;

    let param = {};

    if (a && b && c && d) {
      const isNumeric = (n) => !isNaN(parseFloat(n)) && isFinite(n);
      const isAlpha = (v) => typeof v === "string" && /^[a-zA-Z]+$/.test(v);

      if (isNumeric(a) && isNumeric(b) && isNumeric(c) && isNumeric(d)) {
        param.error =
          "Please! Enter the 3 numbers & use any letter for 1 unknown variable.";
        return param;
      } else if (isAlpha(a) && isNumeric(b) && isNumeric(c) && isNumeric(d)) {
        let a_val = (b * c) / d;
        param.tech_a_val = a_val;
      } else if (isNumeric(a) && isAlpha(b) && isNumeric(c) && isNumeric(d)) {
        let b_val = (a * d) / c;
        param.tech_b_val = b_val;
      } else if (isNumeric(a) && isNumeric(b) && isAlpha(c) && isNumeric(d)) {
        let c_val = (a * d) / b;
        param.tech_c_val = c_val;
      } else if (isNumeric(a) && isNumeric(b) && isNumeric(c) && isAlpha(d)) {
        let d_val = (b * c) / a;
        param.tech_d_val = d_val;
      } else {
        param.error = "Please! Check Your Input.";
        return param;
      }

      return param;
    } else {
      param.error = "Please Fill All the Fields!";
      return param;
    }
  }

  /** getCalculationLinearInterpolationCalculator
   * POST: /api/calculators-lol/linear-interpolation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLinearInterpolationCalculator(body) {
    let x1 = body.tech_x1;
    let y1 = body.tech_y1;
    let x2 = body.tech_x2;
    let y2 = body.tech_y2;
    let x3 = body.tech_x3;
    let y3 = body.tech_y3;

    let param = {};

    const isNumeric = (n) => !isNaN(parseFloat(n)) && isFinite(n);

    if (
      !x1 &&
      isNumeric(y1) &&
      isNumeric(x2) &&
      isNumeric(y2) &&
      isNumeric(x3) &&
      isNumeric(y3)
    ) {
      if (x2 != x3 && y1 != y2 && y2 != y3 && y1 != y3) {
        let s1 = y3 - y1;
        let s2 = x2 - x3;
        let s3 = y3 - y2;
        let s4 = s1 * s2;
        let s5 = s4 / s3;
        x1 = s5 + Number(x3);
        Object.assign(param, {
          tech_x1: x1,
          tech_s1: s1,
          tech_s2: s2,
          tech_s3: s3,
          tech_s4: s4,
          tech_s5: s5,
        });
      } else {
        param.error = "2 values should not be same.";
      }
    } else if (
      isNumeric(x1) &&
      !y1 &&
      isNumeric(x2) &&
      isNumeric(y2) &&
      isNumeric(x3) &&
      isNumeric(y3)
    ) {
      if (x1 != x2 && x2 != x3 && x1 != x3 && y2 != y3) {
        let s1 = x2 - x1;
        let s2 = y3 - y2;
        let s3 = x3 - x1;
        let s4 = s1 * s2;
        let s5 = s4 / s3;
        y1 = s5 + Number(y2);
        Object.assign(param, {
          tech_y1: y1,
          tech_s1: s1,
          tech_s2: s2,
          tech_s3: s3,
          tech_s4: s4,
          tech_s5: s5,
        });
      } else {
        param.error = "2 values should not be same.";
      }
    } else if (
      isNumeric(x1) &&
      isNumeric(y1) &&
      !x2 &&
      isNumeric(y2) &&
      isNumeric(x3) &&
      isNumeric(y3)
    ) {
      if (x1 != x3 && y1 != y2 && y2 != y3 && y1 != y3) {
        let s1 = y1 - y2;
        let s2 = x3 - x1;
        let s3 = y1 - y3;
        let s4 = s1 * s2;
        let s5 = s4 / s3;
        x2 = s5 + Number(x1);
        Object.assign(param, {
          tech_x2: x2,
          tech_s1: s1,
          tech_s2: s2,
          tech_s3: s3,
          tech_s4: s4,
          tech_s5: s5,
        });
      } else {
        param.error = "2 values should not be same.";
      }
    } else if (
      isNumeric(x1) &&
      isNumeric(y1) &&
      isNumeric(x2) &&
      !y2 &&
      isNumeric(x3) &&
      isNumeric(y3)
    ) {
      if (x1 != x2 && x2 != x3 && x1 != x3 && y1 != y3) {
        let s1 = x3 - x2;
        let s2 = y3 - y1;
        let s3 = x3 - x2;
        let s4 = s1 * s2;
        let s5 = s4 / s3;
        y2 = s5 + Number(y3);
        Object.assign(param, {
          tech_y2: y2,
          tech_s1: s1,
          tech_s2: s2,
          tech_s3: s3,
          tech_s4: s4,
          tech_s5: s5,
        });
      } else {
        param.error = "2 values should not be same.";
      }
    } else if (
      isNumeric(x1) &&
      isNumeric(y1) &&
      isNumeric(x2) &&
      isNumeric(y2) &&
      !x3 &&
      isNumeric(y3)
    ) {
      if (x1 != x2 && y1 != y2 && y2 != y3 && y1 != y3) {
        let s1 = y3 - y2;
        let s2 = x1 - x2;
        let s3 = y1 - y2;
        let s4 = s1 * s2;
        let s5 = s4 / s3;
        x3 = s5 + Number(x2);
        Object.assign(param, {
          tech_x3: x3,
          tech_s1: s1,
          tech_s2: s2,
          tech_s3: s3,
          tech_s4: s4,
          tech_s5: s5,
        });
      } else {
        param.error = "2 values should not be same.";
      }
    } else if (
      isNumeric(x1) &&
      isNumeric(y1) &&
      isNumeric(x2) &&
      isNumeric(y2) &&
      isNumeric(x3) &&
      !y3
    ) {
      if (x1 != x2 && x2 != x3 && x1 != x3 && y1 != y2) {
        let s1 = x3 - x1;
        let s2 = y2 - y1;
        let s3 = x2 - x1;
        let s4 = s1 * s2;
        let s5 = s4 / s3;
        y3 = s5 + Number(y1);
        Object.assign(param, {
          tech_y3: y3,
          tech_s1: s1,
          tech_s2: s2,
          tech_s3: s3,
          tech_s4: s4,
          tech_s5: s5,
        });
      } else {
        param.error = "2 values should not be same.";
      }
    } else {
      param.error = "Please! Check Your Input.";
    }

    return param;
  }

  /** getCalculationPythagoreanTheoremCalculator
   * POST: /api/calculators-lol/pythagorean-theorem-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPythagoreanTheoremCalculator(body) {
    let one = body.tech_one;
    let two = body.tech_two;
    let forSide = body.tech_for; // renamed to avoid JS keyword `for`
    let nbr = body.tech_nbr;

    let param = {};

    const isNumeric = (n) => !isNaN(parseFloat(n)) && isFinite(n);

    if (isNumeric(one) && isNumeric(two) && isNumeric(nbr)) {
      one = parseFloat(one);
      two = parseFloat(two);
      nbr = parseInt(nbr);

      let a, b, c;

      if (forSide === "a") {
        b = one;
        c = two;
        a = +Math.sqrt(Math.pow(c, 2) - Math.pow(b, 2)).toFixed(nbr);
      } else if (forSide === "b") {
        a = one;
        c = two;
        b = +Math.sqrt(Math.pow(c, 2) - Math.pow(a, 2)).toFixed(nbr);
      } else if (forSide === "c" || forSide === "ar") {
        a = one;
        b = two;
        c = +Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2)).toFixed(nbr);
      } else {
        param.error = 'Invalid "for" parameter.';
        return param;
      }

      let area = +((a * b) / 2).toFixed(nbr);
      let peri = +(a + b + c).toFixed(nbr);
      let h = +((a * b) / c).toFixed(nbr);
      let alfa = +Math.asin(a / c).toFixed(nbr);
      let a_deg = +(alfa * (180 / Math.PI)).toFixed(nbr);
      let beta = +Math.asin(b / c).toFixed(nbr);
      let b_deg = +(beta * (180 / Math.PI)).toFixed(nbr);

      Object.assign(param, {
        tech_a: a,
        tech_b: b,
        tech_c: c,
        tech_area: area,
        tech_peri: peri,
        tech_h: h,
        tech_alfa: alfa,
        tech_a_deg: a_deg,
        tech_beta: beta,
        tech_b_deg: b_deg,
      });
    } else {
      param.error = "Please Check Your Input.";
    }

    return param;
  }

  /** getCalculationUnitCircleCalculator
   * POST: /api/calculators-lol/unit-circle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationUnitCircleCalculator(body) {
    let angle = body.tech_angle;
    let angle_unit = body.tech_angle_unit;

    let param = {};

    const isNumeric = (n) => !isNaN(parseFloat(n)) && isFinite(n);

    if (isNumeric(angle) && angle_unit) {
      angle = parseFloat(angle);

      if (angle_unit === "rad") {
        angle = angle * (180 / Math.PI); // rad to deg
      } else if (angle_unit === "pirad") {
        angle = angle * Math.PI; // π*rad
        angle = angle * (180 / Math.PI); // to deg
      }

      const radians = angle * (Math.PI / 180); // deg to rad
      const sin = Math.sin(radians);
      const cos = Math.cos(radians);
      const tan = Math.tan(radians);

      param.tech_sin = +sin.toFixed(8);
      param.tech_cos = +cos.toFixed(8);
      param.tech_tan = +tan.toFixed(8);
    } else {
      param.error = "Please! Check Your Input.";
    }

    return param;
  }

  /** getCalculationArcLengthCalculator
   * POST: /api/calculators-lol/arc-length-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationArcLengthCalculator(body) {
    let find = body.tech_find;
    let angle = body.tech_angle;
    let angle_unit = body.tech_angle_unit;
    let rad = body.tech_rad;
    let rad_unit = body.tech_rad_unit;
    let diameter = body.tech_diameter;
    let diameter_unit = body.tech_diameter_unit;
    let area = body.tech_area;
    let area_unit = body.tech_area_unit;
    let chrd_len = body.tech_chrd_len;
    let chrd_len_unit = body.tech_chrd_len_unit;
    let seg_height = body.tech_seg_height;
    let seg_height_unit = body.tech_seg_height_unit;

    let param = {};

    function toRadians(degrees) {
      return degrees * (Math.PI / 180);
    }

    // Angle unit conversion
    if (!isNaN(angle)) {
      if (angle_unit === "deg") angle = angle / 57.2958;
      else if (angle_unit === "gon") angle = angle / 63.662;
      else if (angle_unit === "tr") angle = angle / 0.159155;
      else if (angle_unit === "arcmin") angle = angle / 3437.75;
      else if (angle_unit === "arcsec") angle = angle / 206265;
      else if (angle_unit === "mrad") angle = angle / 1000;
      else if (angle_unit === "urad") angle = angle / 1000000;
      else if (angle_unit === "pirad") angle = angle / 0.31831;
    }

    // Convert length units to meters
    function convertToMeters(value, unit) {
      if (isNaN(value)) return value;
      const conversions = {
        mm: 1 / 1000,
        cm: 1 / 100,
        km: 1000,
        in: 1 / 39.3701,
        ft: 1 / 3.28084,
        yd: 1 / 1.093613,
        mi: 1 / 0.000621371,
        nmi: 1 / 0.000539957,
      };
      return value * (conversions[unit] || 1);
    }

    rad = convertToMeters(rad, rad_unit);
    diameter = convertToMeters(diameter, diameter_unit);
    chrd_len = convertToMeters(chrd_len, chrd_len_unit);
    seg_height = convertToMeters(seg_height, seg_height_unit);

    // Area unit conversion to square meters
    if (!isNaN(area)) {
      const conversions = {
        mm2: 1 / 1e6,
        cm2: 1 / 1e4,
        dm2: 1 / 100,
        km2: 1e6,
        in2: 1 / 1550.003,
        ft2: 1 / 10.7639,
        yd2: 1 / 1.19599,
        mi2: 1 / 0.000000386102,
        a: 1 / 0.01,
        da: 1 / 0.001,
        ha: 1 / 0.0001,
        ac: 1 / 0.0002471054,
        s_f: 1 / 0.000140056,
      };
      area *= conversions[area_unit] || 1;
    }

    let arc_len;

    function round(val, dec) {
      return Math.round(val * Math.pow(10, dec)) / Math.pow(10, dec);
    }

    try {
      switch (find) {
        case "0":
          if (!isNaN(angle) && !isNaN(rad)) {
            diameter = rad * 2;
            area = Math.pow(rad, 2) * (angle / 2);
            arc_len = rad * angle;
            chrd_len = 2 * rad * Math.sin(angle / 2);
            Object.assign(param, {
              tech_arc_len: round(arc_len, 5),
              tech_diameter: round(diameter, 3),
              tech_area: round(area, 4),
              tech_chrd_len: round(chrd_len, 3),
            });
          } else throw "Check Input";
          break;
        case "1":
          if (!isNaN(rad) && !isNaN(seg_height)) {
            if (rad < 10) throw "Radius cannot be less than 10!";
            angle = 2 * Math.acos(1 - seg_height / rad);
            diameter = rad * 2;
            area = Math.pow(rad, 2) * (angle / 2);
            arc_len = rad * angle;
            Object.assign(param, {
              tech_arc_len: round(arc_len, 5),
              tech_angle: round(angle, 5),
              tech_diameter: round(diameter, 3),
              tech_area: round(area, 4),
              tech_chrd_len: round(chrd_len, 3),
            });
          } else throw "Check Input";
          break;
        case "2":
          if (!isNaN(rad) && !isNaN(area)) {
            angle = (2 * area) / Math.pow(rad, 2);
            diameter = rad * 2;
            arc_len = rad * angle;
            chrd_len = 2 * rad * Math.sin(angle / 2);
            if (angle_unit === "deg") angle *= 57.2958;
            area = Math.pow(rad, 2) * (angle / 2);
            Object.assign(param, {
              tech_arc_len: round(arc_len, 5),
              tech_angle: round(angle, 4),
              tech_diameter: round(diameter, 3),
              tech_chrd_len: round(chrd_len, 3),
              tech_area: round(area, 3),
            });
          } else throw "Check Input";
          break;
        case "3":
          if (!isNaN(rad) && !isNaN(chrd_len)) {
            area = Math.pow(rad, 2) * (angle / 2);
            angle = (2 * area) / Math.pow(rad, 2);
            diameter = rad * 2;
            arc_len = rad * angle;
            if (angle_unit === "deg") angle *= 57.2958;
            Object.assign(param, {
              tech_arc_len: round(arc_len, 5),
              tech_angle: round(angle, 4),
              tech_diameter: round(diameter, 3),
              tech_area: round(area, 4),
            });
          } else throw "Check Input";
          break;
        case "4":
          if (!isNaN(angle) && !isNaN(diameter)) {
            rad = diameter / 2;
            area = Math.pow(rad, 2) * (angle / 2);
            arc_len = rad * angle;
            Object.assign(param, {
              tech_arc_len: round(arc_len, 5),
              tech_rad: round(rad, 4),
              tech_diameter: round(diameter, 3),
              tech_area: round(area, 4),
            });
          } else throw "Check Input";
          break;
        case "5":
          if (!isNaN(angle) && !isNaN(area)) {
            rad = Math.sqrt((2 * area) / angle);
            diameter = rad * 2;
            arc_len = rad * angle;
            chrd_len = 2 * rad * Math.sin(angle / 2);
            Object.assign(param, {
              tech_arc_len: round(arc_len, 5),
              tech_rad: round(rad, 4),
              tech_diameter: round(diameter, 3),
              tech_chrd_len: round(chrd_len, 3),
            });
          } else throw "Check Input";
          break;
        case "6":
          if (!isNaN(angle) && !isNaN(chrd_len)) {
            rad = chrd_len / (2 * Math.sin(angle / 2));
            diameter = rad * 2;
            area = Math.pow(rad, 2) * (angle / 2);
            arc_len = rad * angle;
            Object.assign(param, {
              tech_arc_len: round(arc_len, 5),
              tech_rad: round(rad, 4),
              tech_diameter: round(diameter, 3),
              tech_area: round(area, 4),
            });
          } else throw "Check Input";
          break;
        default:
          if (!isNaN(chrd_len) && !isNaN(seg_height)) {
            rad = seg_height / 2 + Math.pow(chrd_len, 2) / (8 * seg_height);
            angle = 2 * Math.asin(chrd_len / (2 * rad));
            diameter = rad * 2;
            area = Math.pow(rad, 2) * (angle / 2);
            arc_len = rad * angle;
            Object.assign(param, {
              tech_arc_len: round(arc_len, 5),
              tech_angle: round(angle, 4),
              tech_rad: round(rad, 4),
              tech_diameter: round(diameter, 3),
              tech_area: round(area, 4),
            });
          } else throw "Check Input";
      }

      return param;
    } catch (err) {
      return { error: err };
    }
  }

  /** getCalculationArcsinCalculator
   * POST: /api/calculators-lol/arcsin-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationArcsinCalculator(body) {
    let arcsin = body.tech_arcsin;
    let round = body.tech_round;

    let param = {};

    function DDtoDMS(dec) {
      let [degPart, fracPart] = dec.toString().split(".");
      let deg = parseInt(degPart);
      let min = 0;
      let sec = 0;

      if (fracPart !== undefined) {
        let tempma = parseFloat("0." + fracPart) * 3600;
        min = Math.floor(tempma / 60);
        sec = Math.round(tempma - min * 60 * 1000) / 1000;
      }

      return { deg, min, sec };
    }

    if (!isNaN(arcsin) && !isNaN(round)) {
      let rad = Math.asin(arcsin);
      let deg = rad * (180 / Math.PI);
      let gon = rad * 63.66;
      let tr = rad * 0.15915;
      let arcmin = rad * 3438;
      let arcsec = rad * 206265;
      let mrad = rad * 1000;
      let urad = rad * 1000000;
      let pirad = rad * 0.3183;

      let DMS = DDtoDMS(deg);
      let d = DMS.deg;
      let m = DMS.min;
      let s = DMS.sec;

      param.tech_angle = +deg.toFixed(1);
      param.tech_rad = +rad.toFixed(round);
      param.tech_gon = +gon.toFixed(round);
      param.tech_tr = +tr.toFixed(round);
      param.tech_arcmin = +arcmin.toFixed(round);
      param.tech_arcsec = +arcsec.toFixed(round);
      param.tech_mrad = +mrad.toFixed(round);
      param.tech_urad = +urad.toFixed(round);
      param.tech_pirad = +pirad.toFixed(round);
      param.tech_deg = +d.toFixed(round);
      param.tech_min = +m.toFixed(round);
      param.tech_sec = +s.toFixed(round);
    } else {
      param.error = "Please! Check Your Input.";
    }

    return param;
  }

  /** getCalculationCosineCalculator
   * POST: /api/calculators-lol/cosine-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCosineCalculator(body) {
    let angle = body.tech_angle;
    let angle_unit = body.tech_angle_unit;

    let param = {};

    if (angle !== undefined && angle !== null && angle !== "") {
      let rad;

      if (angle_unit === "deg") {
        rad = angle * (Math.PI / 180);
      } else if (angle_unit === "pirad") {
        rad = angle * Math.PI;
      } else if (angle_unit === "mrad") {
        rad = angle / 1000;
      } else {
        rad = angle; // assume already in radians
      }

      let cos = Math.cos(rad);

      param.tech_cos = +cos.toFixed(8);
    } else {
      param.error = "Please! Check Your Input.";
    }

    return param;
  }

  /** getCalculationSineCalculator
   * POST: /api/calculators-lol/sine-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSineCalculator(body) {
    let angle = body.tech_angle;
    let angle_unit = body.tech_angle_unit;

    let param = {};

    if (!isNaN(angle)) {
      let rad;

      if (angle_unit === "deg") {
        rad = angle * (Math.PI / 180);
      } else if (angle_unit === "pirad") {
        rad = angle * Math.PI;
      } else {
        rad = angle; // assume already in radians
      }

      let sin = Math.sin(rad);

      param.tech_sin = +sin.toFixed(8);
    } else {
      param.error = "Please! Check Your Input.";
    }

    return param;
  }

  /** getCalculationArccosCalculator
   * POST: /api/calculators-lol/arccos-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationArccosCalculator(body) {
    let arccos = body.tech_arccos;
    let round = body.tech_round;

    let param = {};

    if (!isNaN(arccos) && !isNaN(round)) {
      function DDtoDMS(dec) {
        let parts = dec.toString().split(".");
        let deg = parseInt(parts[0]);
        let min = 0,
          sec = 0;

        if (parts.length > 1) {
          let fractional = parseFloat("0." + parts[1]);
          let totalSeconds = fractional * 3600;
          min = Math.floor(totalSeconds / 60);
          sec = +(totalSeconds - min * 60).toFixed(3);
        }

        return { deg, min, sec };
      }

      let rad = Math.acos(arccos);
      let deg = rad * (180 / Math.PI);
      let gon = rad * 63.66;
      let tr = rad * 0.15915;
      let arcmin = rad * 3438;
      let arcsec = rad * 206265;
      let mrad = rad * 1000;
      let urad = rad * 1000000;
      let pirad = rad * 0.3183;

      let DMS = DDtoDMS(deg);
      let d = DMS.deg;
      let m = DMS.min;
      let s = DMS.sec;

      param.tech_angle = +deg.toFixed(1);
      param.tech_rad = +rad.toFixed(round);
      param.tech_gon = +gon.toFixed(round);
      param.tech_tr = +tr.toFixed(round);
      param.tech_arcmin = +arcmin.toFixed(round);
      param.tech_arcsec = +arcsec.toFixed(round);
      param.tech_mrad = +mrad.toFixed(round);
      param.tech_urad = +urad.toFixed(round);
      param.tech_pirad = +pirad.toFixed(round);
      param.tech_deg = +d.toFixed(round);
      param.tech_min = +m.toFixed(round);
      param.tech_sec = +s.toFixed(round);
    } else {
      param.error = "Please! Check Your Input.";
    }

    return param;
  }

  /** getCalculationArctanCalculator
   * POST: /api/calculators-lol/arccos-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationArctanCalculator(body) {
    let arctan = body.tech_arctan;
    let round = body.tech_round;

    let param = {};

    if (!isNaN(arctan) && !isNaN(round)) {
      function DDtoDMS(dec) {
        let parts = dec.toString().split(".");
        let deg = parseInt(parts[0]);
        let min = 0,
          sec = 0;

        if (parts.length > 1) {
          let fractional = parseFloat("0." + parts[1]);
          let totalSeconds = fractional * 3600;
          min = Math.floor(totalSeconds / 60);
          sec = +(totalSeconds - min * 60).toFixed(3);
        }

        return { deg, min, sec };
      }

      let rad = Math.atan(arctan);
      let deg = rad * (180 / Math.PI);
      let gon = rad * 63.66;
      let tr = rad * 0.15915;
      let arcmin = rad * 3438;
      let arcsec = rad * 206265;
      let mrad = rad * 1000;
      let urad = rad * 1000000;
      let pirad = rad * 0.3183;

      let DMS = DDtoDMS(deg);
      let d = DMS.deg;
      let m = DMS.min;
      let s = DMS.sec;

      param.tech_angle = +deg.toFixed(round);
      param.tech_rad = +rad.toFixed(round);
      param.tech_gon = +gon.toFixed(round);
      param.tech_tr = +tr.toFixed(round);
      param.tech_arcmin = +arcmin.toFixed(round);
      param.tech_arcsec = +arcsec.toFixed(round);
      param.tech_mrad = +mrad.toFixed(round);
      param.tech_urad = +urad.toFixed(round);
      param.tech_pirad = +pirad.toFixed(round);
      param.tech_deg = +d.toFixed(round);
      param.tech_min = +m.toFixed(round);
      param.tech_sec = +s.toFixed(round);
    } else {
      param.error = "Please! Check Your Input.";
    }

    return param;
  }

  /** getCalculationTangentCalculator
   * POST: /api/calculators-lol/tangent-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationTangentCalculator(body) {
    let angle = body.tech_angle;
    let angle_unit = body.tech_angle_unit;

    let param = {};

    if (!isNaN(angle)) {
      if (angle_unit === "deg") {
        angle = angle * (Math.PI / 180); // convert to radians
      } else if (angle_unit === "pirad") {
        angle = angle * Math.PI;
      } else if (angle_unit === "mrad") {
        angle = angle / 1000;
      }

      let tan = Math.tan(angle);
      param.tech_tan = +tan.toFixed(8);
    } else {
      param.error = "Please! Check Your Input.";
    }

    return param;
  }

  /** getCalculationSecantCalculator
   * POST: /api/calculators-lol/secant-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationSecantCalculator(body) {
    let angle = body.tech_angle;
    let angle_unit = body.tech_angle_unit;

    let result = {};

    if (typeof angle === "number") {
      let radian;

      if (angle_unit === "deg") {
        radian = angle * (Math.PI / 180); // deg to rad
      } else if (angle_unit === "pirad") {
        radian = angle * Math.PI;
      } else {
        radian = angle; // assume already in radians
      }

      let cosine = Math.cos(radian);
      let sec = 1 / cosine;

      // Handle Infinity or extremely large values
      sec = Math.abs(sec) > 1e10 ? Infinity : sec;

      result.tech_sec = Number(sec.toFixed(8));
    } else {
      result.error = "Please! Check Your Input.";
    }

    return result;
  }

  /** getCalculationCscCalculator
   * POST: /api/calculators-lol/csc-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCscCalculator(body) {
    let angle = body.tech_angle;
    let angle_unit = body.tech_angle_unit;

    let result = {};

    if (!isNaN(angle)) {
      let csc;

      if (angle_unit === "deg") {
        csc = 1 / Math.sin((angle * Math.PI) / 180);
      } else if (angle_unit === "pirad") {
        angle = angle * Math.PI;
        csc = 1 / Math.sin(angle);
      } else {
        csc = 1 / Math.sin(angle);
      }

      result.tech_csc = Number(csc.toFixed(8));
    } else {
      result.error = "Please! Check Your Input.";
    }

    return result;
  }

  /** getCalculationCotangentCalculator
   * POST: /api/calculators-lol/cotangent-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCotangentCalculator(body) {
    let angle = parseFloat(body.tech_angle);
    let angle_unit = body.tech_angle_unit;
    let result = {};

    if (!isNaN(angle)) {
      let cot;

      if (angle_unit === "deg") {
        cot = 1 / Math.tan((angle * Math.PI) / 180);
      } else if (angle_unit === "pirad") {
        angle = angle * Math.PI;
        cot = 1 / Math.tan(angle);
      } else if (angle_unit === "mrad") {
        angle = angle / 1000;
        cot = 1 / Math.tan(angle);
      } else {
        cot = 1 / Math.tan(angle);
      }

      result.tech_cot = Number(cot.toFixed(8));
    } else {
      result.error = "Please! Check Your Input.";
    }

    return result;
  }

  /** getCalculationECalculator
   * POST: /api/calculators-lol/e-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationECalculator(body) {
    let cal = body.tech_cal;
    let x = parseFloat(body.tech_x);
    let a = parseFloat(body.tech_a);
    let result = {};

    if (!isNaN(x)) {
      let exp;

      if (cal === "ex") {
        exp = Math.exp(x);
      } else if (cal === "10x") {
        exp = Math.pow(10, x);
      } else if (cal === "ax" && !isNaN(a)) {
        exp = Math.pow(a, x);
      } else {
        result.error = "Please Check Your Input.";
        return result;
      }

      result.tech_exp = exp;
    } else {
      result.error = "Please Check Your Input.";
    }

    return result;
  }

  /** getCalculationParallelAndPerpendicularlineCalculator
   * POST: /api/calculators-lol/parallel-and-perpendicular-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationParallelAndPerpendicularlineCalculator(body) {
    let a = parseFloat(body.tech_a);
    let b = parseFloat(body.tech_b);
    let c = parseFloat(body.tech_c);
    let form = body.tech_form;
    let method = body.tech_method;
    let p1 = parseFloat(body.tech_p1);
    let p2 = parseFloat(body.tech_p2);

    function new_gcd_(a, b) {
      a = Math.abs(a);
      b = Math.abs(b);
      if (a < b) [a, b] = [b, a];
      if (b === 0) return 1;
      let r = a % b;
      while (r > 0) {
        a = b;
        b = r;
        r = a % b;
      }
      return b;
    }

    function new_reduce(num, den) {
      let g = new_gcd_(num, den);
      return [num / g, den / g];
    }

    let result = {};

    if (!isNaN(a) && !isNaN(b) && !isNaN(p1) && !isNaN(p2)) {
      if (form === "1") {
        if (!isNaN(c)) {
          let y = method === "2" ? b : -b;
          let [upr, btm] = new_reduce(a, y);
          if (btm < 0) {
            btm = Math.abs(btm);
            upr = -upr;
          }

          if (method === "2") {
            let btm_ = upr;
            let upr_ = btm;
            result.upr_ = btm_;
            result.btm_ = upr_;
            btm = btm_;
            upr = upr_;
          }

          let [upr1, btm1] = new_reduce(c, -b);
          if (btm1 < 0) {
            btm1 = Math.abs(btm1);
            upr1 = -upr1;
          }

          let au = -upr * p1;
          let ab = btm * p2;
          au = ab + au;

          let [upr2, btm2] = new_reduce(au, btm);
          if (btm2 < 0) {
            btm2 = Math.abs(btm2);
            upr2 = -upr2;
          }

          Object.assign(result, {
            tech_upr: upr,
            tech_btm: btm,
            tech_upr1: upr1,
            tech_btm1: btm1,
            tech_upr2: upr2,
            tech_btm2: btm2,
            tech_form: form,
            tech_method: method,
            tech_a: a,
            tech_b: b,
            tech_c: c,
            tech_p1: p1,
            tech_p2: p2,
          });
          return result;
        } else {
          return { error: "Please! Check Your Input." };
        }
      } else {
        if (method === "1") {
          let au = -a * p1 + p2;
          Object.assign(result, {
            tech_au: au,
            tech_method: method,
            tech_form: form,
            tech_a: a,
            tech_b: b,
            tech_p1: p1,
            tech_p2: p2,
          });
          return result;
        } else {
          let upr = a < 0 ? 1 : -1;
          let au = Math.abs(a);
          let au1 = -upr * p1;
          let ab = au * p2;
          au1 = ab + au1;
          let [upr2, btm2] = new_reduce(au1, au);
          if (btm2 < 0) {
            btm2 = Math.abs(btm2);
            upr2 = -upr2;
          }
          Object.assign(result, {
            tech_upr: upr,
            tech_au: au,
            tech_form: form,
            tech_method: method,
            tech_upr2: upr2,
            tech_btm2: btm2,
            tech_a: a,
            tech_b: b,
            tech_p1: p1,
            tech_p2: p2,
          });
          return result;
        }
      }
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationCoterminalAngleCalculator
   * POST: /api/calculators-lol/coterminal-angle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCoterminalAngleCalculator(body) {
    let want = parseInt(body.tech_want);
    let unit = parseInt(body.tech_unit);
    let angle = parseFloat(body.tech_angle);
    let angle2 = parseFloat(body.tech_angle2);

    function gcd(a, b) {
      a = Math.abs(a);
      b = Math.abs(b);
      if (a < b) [a, b] = [b, a];
      if (b === 0) return 1;
      let r = a % b;
      while (r > 0) {
        a = b;
        b = r;
        r = a % b;
      }
      return b;
    }

    function reduce(num, den) {
      let g = gcd(num, den);
      return [num / g, den / g];
    }

    let result = {};

    if (unit === 1 && want === 1) {
      let [upr, btm] = reduce(angle, 180);
      let rad = +(upr / btm).toFixed(3);
      result = {
        tech_want: want,
        tech_rad: rad,
        tech_upr: upr,
        tech_btm: btm,
        tech_unit: unit,
        tech_angle: angle,
        tech_angle2: angle2,
      };
    } else if (unit === 2 && want === 1) {
      let deg = +(angle * 180).toFixed(3);
      let two = angle;
      while (two >= 2) {
        two -= 2;
      }

      let pos, neg;
      if (angle >= 2) {
        pos = `${two} π,${two + 2} π,${two + 4} π,${two + 6} π,${
          two + 8
        } π .....`;
        neg = `${two - 2} π,${two - 4} π,${two - 6} π,${two - 8} π,${
          two - 10
        } π .....`;
      } else {
        pos = `${angle + 2} π,${angle + 4} π,${angle + 6} π,${angle + 8} π,${
          angle + 10
        } π .....`;
        neg = `${angle - 2} π,${angle - 4} π,${angle - 6} π,${angle - 8} π,${
          angle - 10
        } π .....`;
      }

      let rem = deg % 360;
      let q = "";
      if (rem > 0 && rem < 90) q = "first quadrant";
      else if (rem === 90) q = "positive y-axis";
      else if (rem > 90 && rem < 180) q = "second quadrant";
      else if (rem === 180) q = "negative x-axis";
      else if (rem > 180 && rem < 270) q = "third quadrant";
      else if (rem === 270) q = "negative y-axis";
      else if (rem > 270) q = "fourth quadrant";
      else if (rem === 0) q = "positive x-axis";

      result = {
        tech_want: want,
        tech_two: two,
        tech_pos: pos,
        tech_neg: neg,
        tech_deg: deg,
        tech_q: q,
        tech_unit: unit,
        tech_angle: angle,
        tech_angle2: angle2,
      };
    } else if (unit === 1 && want === 2) {
      let angle_ = angle % 360;
      let angle2_ = angle2 % 360;
      let check = angle_ === angle2_ ? 1 : 0;
      result = {
        tech_check: check,
        tech_want: want,
        tech_unit: unit,
        tech_angle: angle,
        tech_angle2: angle2,
      };
    } else if (unit === 2 && want === 2) {
      let angle11 = angle * 180;
      let angle22 = angle2 * 180;
      let angle_ = angle11 % 360;
      let angle2_ = angle22 % 360;
      let check = angle_ === angle2_ ? 1 : 0;
      result = {
        tech_check: check,
        tech_want: want,
        tech_unit: unit,
        tech_angle: angle,
        tech_angle2: angle2,
      };
    }

    return result;
  }

  /** getCalculationArithmeticSequenceCalculator
   * POST: /api/calculators-lol/arithmetic-sequences-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationArithmeticSequenceCalculator(body) {
    let first = parseFloat(body.tech_first);
    let diff = parseFloat(body.tech_diff);
    let nth = parseInt(body.tech_nth);

    let result = {};

    if (!isNaN(first) && !isNaN(diff) && !isNaN(nth)) {
      let nth_v = first + (nth - 1) * diff;
      let sum = first;
      let res = `${first}`;

      for (let i = 1; i < 10; i++) {
        sum += diff;
        if (i < 9) {
          res += `, ${sum}`;
        }
        if (i === 9) {
          res += " ....";
        }
      }

      let total = (nth / 2) * (2 * first + (nth - 1) * diff);

      result = {
        tech_first: first,
        tech_diff: diff,
        tech_nth: nth,
        tech_total: total,
        tech_res: res,
        tech_nth_v: nth_v,
      };
    } else {
      result = {
        error: "Please! Check Your Input.",
      };
    }

    return result;
  }

  /** getCalculationDoubleAngleCalculator
   * POST: /api/calculators-lol/double-angle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDoubleAngleCalculator(body) {
    let unit = body.tech_unit;
    let angle = body.tech_angle;

    let result = {};

    function sigFig(value, digits) {
      if (value === 0) {
        return 0;
      }
      const decimalPlaces =
        digits - Math.floor(Math.log10(Math.abs(value))) - 1;
      return +value.toFixed(decimalPlaces);
    }

    if (!isNaN(angle)) {
      angle = parseFloat(angle);
    } else if (typeof angle === "string" && angle.includes("/")) {
      let parts = angle.split("/");
      if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
        angle = parseFloat(parts[0]) / parseFloat(parts[1]);
      } else {
        result.error = "Please! Check Your Input.";
        return result;
      }
    } else {
      result.error = "Please! Check Your Input.";
      return result;
    }

    let deg, red;
    let angle_ = angle;

    if (unit === "1") {
      deg = angle;
      red = (angle * Math.PI) / 180;
    } else if (unit === "2") {
      deg = +((angle * 180) / Math.PI).toFixed(2);
      red = angle;
    } else if (unit === "3") {
      deg = +(angle * 180).toFixed(2);
      result.tech_angle_ = angle_;
      red = (angle * 180 * Math.PI) / 180;
    }

    let sin = 2 * (Math.sin(red).toFixed(5) * Math.cos(red).toFixed(5));
    let cos = 1 - 2 * Math.pow(Math.sin(red).toFixed(5), 2);

    let upper = 2 * Math.tan(red).toFixed(5);
    let bottom = 1 - Math.pow(Math.tan(red).toFixed(5), 2);

    let tan = 0;
    if (upper !== 0 && bottom !== 0) {
      tan = upper / bottom;
    }

    result.tech_sin = sigFig(sin, 6);
    result.tech_cos = sigFig(cos, 6);
    result.tech_tan = sigFig(tan, 6);
    result.tech_deg = deg;
    result.tech_red = red;
    result.tech_angle = angle;
    result.tech_unit = unit;

    return result;
  }

  /** getCalculationHalfAngleCalculator
   * POST: /api/calculators-lol/half-angle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationHalfAngleCalculator(body) {
    let cal = body.tech_cal;
    let angle = body.tech_angle;
    let angle_unit = body.tech_angle_unit;
    let func = body.tech_func;

    const result = {};

    // Helper functions
    function deg2rad(deg) {
      return deg * (Math.PI / 180);
    }

    function rad2deg(rad) {
      return rad * (180 / Math.PI);
    }

    function round(value, decimals) {
      return Number(Math.round(value + "e" + decimals) + "e-" + decimals);
    }

    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }

    if (cal === "angle") {
      if (isNumeric(angle) && angle_unit) {
        let angleInDeg;
        if (angle_unit === "rad") {
          angleInDeg = rad2deg(angle);
          result.tech_angle_u = "rad";
        } else if (angle_unit === "pirad") {
          angleInDeg = rad2deg(angle * Math.PI);
          result.tech_angle_u = "pirad";
        } else {
          angleInDeg = parseFloat(angle);
          result.tech_angle_u = "deg";
        }

        const sinx = Math.sin(deg2rad(angleInDeg));
        const cosx = Math.cos(deg2rad(angleInDeg));
        const tanx = Math.tan(deg2rad(angleInDeg));
        const s1 = 1 - cosx;
        const s2 = s1 / 2;
        const c1 = 1 + cosx;
        const c2 = c1 / 2;
        const t1 = s1 / c1;
        const sinx2 = Math.sqrt(s2);
        const cosx2 = Math.sqrt(c2);
        const tanx2 = Math.sqrt(t1);

        result.tech_sinx = round(sinx, 4);
        result.tech_cosx = round(cosx, 4);
        result.tech_tanx = round(tanx, 4);
        result.tech_sinx2 = round(sinx2, 4);
        result.tech_cosx2 = round(cosx2, 4);
        result.tech_tanx2 = round(tanx2, 4);
        result.tech_s1 = round(s1, 4);
        result.tech_s2 = round(s2, 4);
        result.tech_c1 = round(c1, 4);
        result.tech_c2 = round(c2, 4);
        result.tech_t1 = round(t1, 4);
      } else {
        result.error = "Please! Check Your Input.";
      }
    } else {
      if (isNumeric(func)) {
        let angleInDeg;
        if (cal === "sinx") {
          angleInDeg = rad2deg(Math.asin(func));
        } else if (cal === "cosx") {
          angleInDeg = rad2deg(Math.acos(func));
        } else if (cal === "tanx") {
          angleInDeg = rad2deg(Math.atan(func));
        } else if (cal === "sinx_2") {
          const sinx2 = parseFloat(func);
          const cosx = Math.abs(2 * Math.pow(sinx2, 2) - 1);
          angleInDeg = rad2deg(Math.acos(cosx));
        } else {
          // cosx_2
          const cosx2 = parseFloat(func);
          const cosx = 2 * Math.pow(cosx2, 2) - 1;
          angleInDeg = rad2deg(Math.acos(cosx));
        }

        const sinx = Math.sin(deg2rad(angleInDeg));
        const cosx = Math.cos(deg2rad(angleInDeg));
        const tanx = Math.tan(deg2rad(angleInDeg));
        const s1 = 1 - cosx;
        const s2 = s1 / 2;
        const c1 = 1 + cosx;
        const c2 = c1 / 2;
        const t1 = s1 / c1;
        const sinx2 = Math.sqrt(s2);
        const cosx2 = Math.sqrt(c2);
        const tanx2 = Math.sqrt(t1);
        const angle_rad = deg2rad(angleInDeg);
        const angle_pirad = angleInDeg * 0.005556;

        result.tech_angle_deg = round(angleInDeg, 4);
        result.tech_angle_rad = round(angle_rad, 4);
        result.tech_angle_pirad = round(angle_pirad, 4);
        result.tech_sinx = round(sinx, 4);
        result.tech_cosx = round(cosx, 4);
        result.tech_tanx = round(tanx, 4);
        result.tech_sinx2 = round(sinx2, 4);
        result.tech_cosx2 = round(cosx2, 4);
        result.tech_tanx2 = round(tanx2, 4);
        result.tech_s1 = round(s1, 4);
        result.tech_s2 = round(s2, 4);
        result.tech_c1 = round(c1, 4);
        result.tech_c2 = round(c2, 4);
        result.tech_t1 = round(t1, 4);
      } else {
        result.error = "Please! Check Your Input.";
      }
    }

    return result;
  }

  /** getCalculationPowerSetCalculator
   * POST: /api/calculators-lol/power-set-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPowerSetCalculator(body) {
    let set = body.tech_set;

    let result = {};

    // Input validation
    if (
      /<|>|\&|\+|\-|\(|\)|\{|\}|\[|\]|\||php|print_r|print|echo|sin|cos|tan|arcsin|arccos|arctan|script|=|&|%/i.test(
        set
      )
    ) {
      result.error = "Please Enter Valid Input.";
      return result;
    }

    if (set && set.trim() !== "") {
      set = set.replace(/\s+/g, "").split(",");

      if (set.length >= 10) {
        result.error = "Please Enter maximum 10 numbers.";
        return result;
      }

      // Powerset function
      function powerSet(array) {
        let results = [[]];
        array.forEach((value, key) => {
          results.forEach((subset) => {
            results.push([...subset, value]);
          });
        });

        results.sort((a, b) => {
          if (a.length !== b.length) {
            return a.length - b.length;
          }
          return 0;
        });

        return results;
      }

      let size = set.length;
      let powset = powerSet(set);
      let count = powset.length;

      // Format powerset as string
      let powersetStr = powset
        .map((subset) => `{${subset.join(",")}}`)
        .join(",");

      result.tech_size = size;
      result.tech_powerset = powersetStr;
      result.tech_subsets = count;
      result.tech_pro_subsets = count - 1;
      return result;
    } else {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /** getCalculationVertexFormCalculator
   * POST: /api/calculators-lol/vertex-form-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationVertexFormCalculator(body) {
    let a1 = body.tech_a1;
    let b1 = body.tech_b1;
    let c1 = body.tech_c1;
    let a = body.tech_a;
    let b = body.tech_b;
    let c = body.tech_c;
    let submit = body.tech_type;

    let result = {};
    let A,
      B,
      C,
      variable_ans = "x",
      eq = "";

    if (submit === "standard") {
      if (!a1 || a1 == 0) {
        result.error = "Enter a, In quadratic equation a is not equal 0";
        return result;
      }

      eq += `${a1}x^2`;

      if (b1 && b1 != 0) {
        eq += b1 > 0 ? ` + ${b1}x` : ` ${b1}x`;
      }

      if (c1 == null) c1 = 0;

      if (c1 && c1 != 0) {
        eq += c1 > 0 ? ` + ${c1}` : ` ${c1}`;
      }

      A = Number(a1);
      B = Number(b1) || 0;
      C = Number(c1) || 0;
    } else {
      if (c == null) c = 0;
      if (b == null) b = 0;

      if (!isNaN(a) && a !== "0" && !isNaN(b) && !isNaN(c)) {
        A = Number(a);
        C = Math.pow(b, 2) * A + Number(c);
        B = -1 * b * 2 * A;
      } else {
        result.error = "Please Check Your Input.";
        return result;
      }
    }

    let round3 = C.toString().includes(".")
      ? C.toString().split(".")[1].length
      : 0;
    let firstx = Number(((-1 * B) / (2 * A)).toFixed(3));
    let round1 = firstx.toString().includes(".")
      ? firstx.toString().split(".")[1].length
      : 0;

    let first_part = A * Math.pow(firstx, 2);
    let second_part = B * firstx;

    // Build evaluation string
    if (second_part < 0 && C < 0) {
      eq = `${first_part} ${second_part} ${C}`;
    } else if (second_part < 0 && C >= 0) {
      eq = `${first_part} ${second_part} + ${C}`;
    } else if (second_part >= 0 && C < 0) {
      eq = `${first_part} + ${second_part} ${C}`;
    } else {
      eq = `${first_part} + ${second_part} + ${C}`;
    }

    let yaxis;
    try {
      yaxis = eval(eq); // Safe in this controlled context
    } catch (e) {
      result.error = "Evaluation Error";
      return result;
    }

    yaxis = Number(yaxis.toFixed(3));
    let round2 = yaxis.toString().includes(".")
      ? yaxis.toString().split(".")[1].length
      : 0;

    let vertexStr = `${A}(${variable_ans} ${
      firstx < 0 ? "+ " + -firstx : "- " + firstx
    })^2 ${yaxis < 0 ? "- " + -yaxis : "+ " + yaxis}`;

    result.tech_vertex = vertexStr;
    result.tech_A = A;
    result.tech_B = B;
    result.tech_C = C;
    result.tech_firstx = firstx;
    result.tech_yaxis = yaxis;
    result.tech_round1 = round1;
    result.tech_round2 = round2;
    result.tech_round3 = round3;
    result.tech_variable_ans = variable_ans;
    result.tech_submit = submit;

    return result;
  }

  /** getCalculationSubsetCalculator
   * POST: /api/calculators-lol/subset-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSubsetCalculator(body) {
    let cal_by = body.tech_cal_by;
    let set = body.tech_set;
    let cardinal = body.tech_cardinal;

    let result = {};
    let check = false;
    let size,
      count,
      ne = [];

    // Validation regex
    const invalidPattern =
      /<|>|\&|\+|\-|\(|\)|\{|\}|\[|\]|\||php|print_r|print|echo|sin|cos|tan|arcsin|arccos|arctan|script|=|&|%/i;

    if (cal_by === "elements") {
      if (!set || invalidPattern.test(set)) {
        result.error = "Please Enter Valid Input.";
        return result;
      }

      check = true;
      set = set.replace(/\s/g, "").split(",");

      if (set.length > 10) {
        result.error = "Number of Elements must be less than or equal to 10.";
        return result;
      }

      // Generate powerset
      function powerSet(array) {
        let results = [[]];
        for (let value of array) {
          let temp = [];
          for (let subset of results) {
            temp.push([...subset, value]);
          }
          results = results.concat(temp);
        }

        results.sort((a, b) => a.length - b.length);
        return results;
      }

      size = set.length;
      const powset = powerSet(set);
      count = powset.length;

      let arr = powset.map((sub) => `{${sub.join(",")}}`).join(",");
      result.tech_pw = arr;
    } else if (cal_by === "cardinality") {
      if (!isNaN(cardinal)) {
        check = true;
        if (cardinal > 100) {
          result.error = "Elements must be less than or equal to 100.";
          return result;
        }

        size = Number(cardinal);
        count = Math.pow(2, size);
      } else {
        result.error = "Please! Check Your Input.";
        return result;
      }
    }

    if (check) {
      function factorial(n) {
        let result = 1;
        for (let i = 2; i <= n; i++) {
          result *= i;
        }
        return result;
      }

      let size1 = size;
      for (let i = 0; i <= size; i++) {
        let value = factorial(size) / (factorial(i) * factorial(size1));
        ne.push(value);
        size1--;
      }

      result.tech_subsets = count;
      result.tech_pro_subsets = count - 1;
      result.tech_ne = ne;
      return result;
    } else {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /** getCalculationHyperbolaCalculator
   * POST: /api/calculators-lol/hyperbola-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationHyperbolaCalculator(body) {
    let x = body.tech_x;
    let y = body.tech_y;
    let a = body.tech_a;
    let b = body.tech_b;

    let result = {};

    if (!isNaN(x) && !isNaN(y) && !isNaN(a) && !isNaN(b)) {
      x = Number(x);
      y = Number(y);
      a = Number(a);
      b = Number(b);

      // Perfect square check
      function isPerfectSquare(n) {
        let sqrt = Math.sqrt(n);
        if (Number.isInteger(sqrt)) {
          return sqrt;
        } else {
          return `\\sqrt{${n}}`;
        }
      }

      let c1 = x;
      let c2 = y;
      let as = Math.sqrt(a);
      let bs = Math.sqrt(b);

      let v1 = `${(c1 - as).toFixed(5)} , ${c2}`;
      let v2 = `${(c1 + as).toFixed(5)} , ${c2}`;
      let v21 = +(c2 - bs).toFixed(5);
      let v22 = +(c2 + bs).toFixed(5);

      let c = Math.sqrt(a + b);
      let f1 = `${(c1 - c).toFixed(5)} , ${c2}`;
      let f2 = `${(c1 + c).toFixed(5)} , ${c2}`;
      let ecc = +(c / as).toFixed(5);
      let fp = +(b / c).toFixed(5);

      let dir1 = +(c1 - (a * c) / (a + b)).toFixed(5);
      let dir2 = +(c1 + (a * c) / (a + b)).toFixed(5);
      let fl1 = +(c1 - c).toFixed(5);
      let fl2 = +(c1 + c).toFixed(5);

      let ashow = isPerfectSquare(a);
      let bshow = isPerfectSquare(b);
      let cshow = isPerfectSquare(a + b);

      result = {
        tech_as: as,
        tech_bs: bs,
        tech_v1: v1,
        tech_v2: v2,
        tech_v21: v21,
        tech_v22: v22,
        tech_f1: f1,
        tech_f2: f2,
        tech_ecc: ecc,
        tech_fp: fp,
        tech_dir1: dir1,
        tech_dir2: dir2,
        tech_fl1: fl1,
        tech_fl2: fl2,
        tech_c: c,
        tech_ashow: ashow,
        tech_bshow: bshow,
        tech_cshow: cshow,
      };
    } else {
      result.error = "Please! Check Your Input.";
    }

    return result;
  }

  /** getCalculationGradientCalculator
   * POST: /api/calculators-lol/hyperbola-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationGradientCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let x = body.tech_x;
    let y = body.tech_y;
    let z = body.tech_z;
    let type = body.tech_type;

    let result = {};

    const invalidPattern = /<|>|\&|php|print_r|print|echo|script|=|&|%/i;

    if (!EnterEq || invalidPattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    if (type === "two") {
      if (isNaN(x) || isNaN(y)) {
        return { error: "Please! Check Your Input." };
      }
    } else if (type === "three") {
      if (isNaN(x) || isNaN(y) || isNaN(z)) {
        return { error: "Please! Check Your Input." };
      }
    } else {
      return { error: "Please! Check Your Input." };
    }

    // Prepare and sanitize expression
    let expr = EnterEq.replace(/\s+|%20/g, "")
      .replace(/\+/g, "plus")
      .replace(/[{}]/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^x/g, "exp(x)")
      .replace(/e\^y/g, "exp(y)")
      .replace(/e\^z/g, "exp(z)")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    try {
      const params = { eq: expr, x, y, type };
      if (type === "three") params.z = z;

      const r = await axios.get("http://167.172.134.148/gradient", { params });
      const buf = r.data.split("@@@");

      if (type === "two") {
        const [difs1, difs2, x1, y1, enter, steps, steps1] = buf;
        Object.assign(result, {
          tech_difs1: difs1,
          tech_difs2: difs2,
          tech_x1: +parseFloat(x1).toFixed(5),
          tech_y1: +parseFloat(y1).toFixed(5),
          tech_enter: enter,
          tech_steps: steps,
          tech_steps1: steps1,
        });
      } else {
        const [difs1, difs2, difs3, x1, y1, z1, enter, steps, steps1, steps2] =
          buf;
        Object.assign(result, {
          tech_difs1: difs1,
          tech_difs2: difs2,
          tech_difs3: difs3,
          tech_x1: +parseFloat(x1).toFixed(5),
          tech_y1: +parseFloat(y1).toFixed(5),
          tech_z1: +parseFloat(z1).toFixed(5),
          tech_enter: enter,
          tech_steps: steps,
          tech_steps1: steps1,
          tech_steps2: steps2,
        });
      }

      return result;
    } catch (e) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationMidpointRuleCalculator
   * POST: /api/calculators-lol/midpoint-rule-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMidpointRuleCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let lb = body.tech_lb;
    let ub = body.tech_ub;
    let n = body.tech_n;
    let withVal = body.tech_with;

    let result = {};

    const invalidPattern = /<|>|\&|php|print_r|print|echo|script|=|&|%/i;

    if (!EnterEq || invalidPattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    if (isNaN(lb) || isNaN(ub) || isNaN(n) || lb >= ub) {
      return {
        error:
          lb >= ub
            ? "The lower limit should be less than the upper limit."
            : "Please! Check Your Input.",
      };
    }

    let expr = EnterEq.replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    let diff = (ub - lb) / n;
    let final = parseFloat(lb);
    let limit_a = [final];
    let limit = `${final}`;

    while (final < ub) {
      final += diff;
      limit_a.push(final);
      limit += `, ${final}`;
    }

    try {
      const postData = qs.stringify({
        equ: expr,
        with: withVal,
        ub,
        lb,
        n,
        type: 3,
        diff,
      });

      const response = await axios.post(
        "http://167.172.134.148/new-riemann",
        postData,
        {
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
          },
          timeout: 120000,
        }
      );

      const buffer = response.data;
      const steps = buffer[0].split("HA");

      Object.assign(result, {
        tech_steps: steps,
        tech_res: buffer[1],
        tech_enter: buffer[2],
        tech_ub: ub,
        tech_lb: lb,
        tech_n: n,
        tech_diff: diff,
        tech_limit: limit,
        tech_limit_a: limit_a,
        tech_with: withVal,
      });

      return result;
    } catch (err) {
      console.error("Error during request:", err.message);
      return { error: "Please! Check Your Input.", detail: err.message };
    }
  }

  /** getCalculationMaclaurinSeriesCalculator
   * POST: /api/calculators-lol/maclaurin-series-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMaclaurinSeriesCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let find = body.tech_find;
    let n = body.tech_n;
    let withVal = body.tech_with;

    let point = 0;
    let result = {};

    const invalidPattern = /<|>|\&|php|print_r|print|echo|script|=|&|%/i;

    if (!EnterEq || invalidPattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    if (isNaN(n)) {
      return { error: "Please! Check Your Input." };
    }

    if (find == null) {
      find = "";
    }

    let expr = EnterEq.replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^x/g, "exp(x)")
      .replace(/e\^y/g, "exp(y)")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    try {
      const response = await axios.get("http://167.172.134.148/taylor", {
        params: {
          equ: expr,
          wrt: withVal,
          how: n,
          find: find,
          point: point,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@HA_");

      result.tech_eexe = buffer[0];
      result.tech_enter = buffer[1];
      result.tech_res = buffer[2];
      result.tech_series = buffer[3];

      if (!isNaN(find)) {
        result.tech_efun = buffer[4];
        result.tech_eser = buffer[5];
        result.tech_efv = buffer[6];
        result.tech_fsv = buffer[7];
        result.tech_err = buffer[8];
      }

      return result;
    } catch (err) {
      console.error("Request error:", err.message);
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationDifferenceQuotientCalculator
   * POST: /api/calculators-lol/difference-quotient-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDifferenceQuotientCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let result = {};

    const invalidPattern = /<|>|\&|php|print_r|print|echo|script|=|%/i;
    if (!EnterEq || invalidPattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    let parem = EnterEq.toLowerCase();

    // Clean and sanitize the input
    parem = parem.replace(
      /f\^-1\(x\)=?|f\(x\)=|y=|h\(x\)=|f-1\(2\)=|y=f\(x\)=|=y|∣|%20|\||f\s*\(\s*x\s*\)\s*=|=|f\(x\)|fx=|fx/g,
      ""
    );

    // parem = parem.replace(/f\^-1\(x\)|f\(x\)=|y=|h\(x\)=|f-1\(2\)=|y=f\(x\)=|=y|∣|f\^-1\(x\)=|%20|\||f \( x \ ) =|=|f\(x\)|fx=|fx/g, '');

    const variableMatches = parem.match(/[a-zA-Z]+/g) || [];
    const filteredVars = variableMatches.filter(
      (v) =>
        !["log", "sin", "cos", "tan", "exp", "sqrt", "e", "arctan"].includes(v)
    );
    const uniqueVars = [...new Set(filteredVars)];

    if (uniqueVars.length > 1) {
      return { error: "More than one variable found in the equation" };
    } else if (uniqueVars.length === 0) {
      return { error: "No variable found in the equation." };
    }

    const withVal = uniqueVars[0];

    // Additional formatting
    parem = parem
      .replace(/sqrt\(/gi, "sqrt(")
      .replace(/arctan\(/gi, "atan(")
      .replace(/e\^([a-z0-9\(\)\*\+]+)/gi, "zain($1)")
      .replace(/\^/g, "**")
      .replace(/−/g, "-")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/\[/g, "(")
      .replace(/\]/g, ")")
      .replace(/(\d)([a-z\(])/gi, "$1*$2");

    // f(x + h)
    let parem1 = parem.replace(new RegExp(withVal, "g"), `(${withVal} + h)`);
    parem1 = parem1.replace(/sqrt\(/gi, "sqrt(").replace(/arctan\(/gi, "atan(");

    let final = `((${parem1}) - (${parem}))/h`;

    try {
      const response = await axios.get("http://167.172.134.148/difference", {
        params: {
          equ: parem,
          wrt: withVal,
          equ1: parem1,
          final: final,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      result.tech_with = withVal;
      result.tech_enter = buffer[0];
      result.tech_equ1 = buffer[1];
      result.tech_final = buffer[2];
      result.tech_res = buffer[3];

      return result;
    } catch (err) {
      console.error("Error:", err.message);
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationComplexNumberCalculator
   * POST: /api/calculators-lol/complex-number-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationComplexNumberCalculator(body) {
    let exp = body.tech_exp;
    let result = {};

    const invalidPattern =
      /<|>|&|php|print_r|print|echo|script|=|sin|cos|tan|arcsin|arccos|arctan|%/i;

    // Validation
    if (!exp || invalidPattern.test(exp)) {
      return { error: "Please Enter Valid Input." };
    }

    // Expression cleanup
    let parem = exp;
    parem = parem.replace(/\s+/g, "");
    parem = parem.replace(/%20/g, "");
    parem = parem.replace(/\+/g, "plus");
    parem = parem.replace(/{/g, "(");
    parem = parem.replace(/}/g, ")");
    parem = parem.replace(/e\^sqrt\(x\)/g, "exp(2*x)");
    parem = parem.replace(/e\^/g, "exp");
    parem = parem.replace(/exp\^/g, "exp");
    parem = parem.replace(/\^/g, "**");

    try {
      const response = await axios.get("http://167.172.134.148/complex_num", {
        params: {
          equ: parem,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      result.tech_enter = buffer[0];
      result.tech_expand = buffer[1];
      result.tech_expand1 = buffer[2];
      result.tech_a = buffer[3];
      result.tech_b = buffer[4];
      result.tech_b1 = buffer[5];
      result.tech_r = buffer[6];
      result.tech_theta = buffer[7];
      result.tech_simp = buffer[8];

      return result;
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationWronskianCalculator
   * POST: /api/calculators-lol/wronskian-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationWronskianCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let wrt = body.tech_with;

    let result = {};

    const invalidPattern = /<|>|&|php|print_r|print|echo|script|=|%/i;

    if (!EnterEq || !wrt || invalidPattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    let parem = EnterEq;
    parem = parem.replace(/\s+/g, "");
    parem = parem.replace(/\+/g, "plus");
    parem = parem.replace(/{/g, "(");
    parem = parem.replace(/}/g, ")");
    parem = parem.replace(/e\^sqrt\(x\)/g, "exp(2*x)");
    parem = parem.replace(/e\^x/g, "exp(x)");
    parem = parem.replace(/e\^y/g, "exp(y)");
    parem = parem.replace(/e\^/g, "exp");
    parem = parem.replace(/exp\^/g, "exp");
    parem = parem.replace(/\^/g, "**");

    const funcCount = parem.split(",").length;

    if (funcCount < 2 || funcCount > 5) {
      return {
        error:
          "The number of functions cannot be less than 2 or greater than 5.",
      };
    }

    try {
      const response = await axios.get("http://167.172.134.148/wronskian", {
        params: {
          equ: parem,
          wrt: wrt,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      result.tech_enter = buffer[0];
      result.tech_matrix = buffer[1];
      result.tech_res = buffer[2];

      return result;
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationInverseLaplaceTransformCalculator
   * POST: /api/calculators-lol/inverse-laplace-transform-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationInverseLaplaceTransformCalculator(body) {
    let EnterEq = body.tech_EnterEq;

    let result = {};
    const invalidPattern = /<|>|php|print_r|print|echo|script|=|%|&/i;

    if (!EnterEq || invalidPattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    let parem = EnterEq;
    parem = parem.replace(/\s+/g, "");
    parem = parem.replace(/\+/g, "plus");
    parem = parem.replace(/%20/g, "");
    parem = parem.replace(/{/g, "(");
    parem = parem.replace(/}/g, ")");
    parem = parem.replace(/e\^s/g, "exp(s)");
    parem = parem.replace(/e\^sqrt\(x\)/g, "exp(2*x)");
    parem = parem.replace(/e\^/g, "exp");
    parem = parem.replace(/exp\^/g, "exp");
    parem = parem.replace(/\^/g, "**");

    try {
      const response = await axios.get("http://167.172.134.148/inverse_lap", {
        params: {
          equ: parem,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      result.tech_ans = buffer[0];
      result.tech_enter = buffer[1];

      return result;
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationInverseLaplaceTransformCalculator
   * POST: /api/calculators-lol/summation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSummationCalculator(body) {
    let cal_meth = body.tech_cal_meth;
    let nums = body.tech_nums;
    let eq = body.tech_eq;
    let x = body.tech_x;
    let n = body.tech_n;

    let result = {};
    const invalidPattern =
      /<|>|\&|\+|\-|\(|\)|\{|\}|\[|\]|\||php|print_r|print|echo|script|=|%|sin|cos|tan|arcsin|arccos|arctan/i;

    if (
      (nums && invalidPattern.test(nums)) ||
      (eq && invalidPattern.test(eq)) ||
      (x && invalidPattern.test(x)) ||
      (n && invalidPattern.test(n))
    ) {
      return { error: "Please! Enter Valid Input." };
    }

    if (cal_meth === "simple_sum") {
      if (nums) {
        nums = nums.replace(/\s+/g, "");
        let numArr = nums.split(",").map(Number);
        let sum = numArr.reduce((acc, val) => acc + val, 0);
        let tn = numArr.length;

        result.tech_sum = sum;
        result.tech_tn = tn;
        return result;
      } else {
        return { error: "Please! Check Your Input." };
      }
    } else if (cal_meth === "sigma_sum") {
      if (!eq || !x || !n) {
        return { error: "Please! Check Your Input." };
      }

      let parem = eq;
      parem = parem.replace(/\s+/g, "");
      parem = parem.replace(/%20/g, "");
      parem = parem.replace(/\+/g, "plus");
      parem = parem.replace(/{/g, "(");
      parem = parem.replace(/}/g, ")");
      parem = parem.replace(/e\^sqrt\(x\)/g, "exp(2*x)");
      parem = parem.replace(/e\^/g, "exp");
      parem = parem.replace(/exp\^/g, "exp");
      parem = parem.replace(/\^/g, "**");

      try {
        const response = await axios.get("http://167.172.134.148/summation", {
          params: {
            equ: parem,
            x: x,
            n: n,
          },
          timeout: 120000,
        });

        const buffer = response.data.split("@@@");

        if (buffer[0] === "False") {
          result.tech_cnvrgnt = buffer[0];
          result.tech_enter = buffer[1];
        } else {
          result.tech_cnvrgnt = buffer[0];
          result.tech_enter = buffer[1];
          result.tech_sum = buffer[2];

          let solve = buffer[3].split("###");
          solve.pop();
          result.tech_solve = solve;
          result.tech_tn = solve.length;

          let i_n = buffer[4].split("###");
          i_n.pop();
          result.tech_i_n = i_n;
        }

        return result;
      } catch (err) {
        return { error: "Please! Check Your Input." };
      }
    } else {
      return { error: "Invalid calculation method." };
    }
  }

  /** getCalculationPolarCoordinatesCalculator
   * POST: /api/calculators-lol/polar-coordinates-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPolarCoordinatesCalculator(body) {
    let x = body.tech_x1;
    let y = body.tech_x2;
    let chose = body.tech_chose;

    let result = {};

    if (x === undefined || y === undefined || x === "" || y === "") {
      return { error: "Please Check Your Input." };
    }

    try {
      const response = await axios.get("http://167.172.134.148/polar", {
        params: {
          x: x,
          y: y,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      let angle = parseFloat(buffer[0]);
      let magnitude = parseFloat(buffer[4]);
      let atn = angle / magnitude;

      let one = Math.atan(atn);
      let two = one + Math.PI;

      let x1 = magnitude * Math.cos(angle);
      let y1 = magnitude * Math.sin(angle);

      result.tech_mag = buffer[1];
      result.tech_ex = buffer[2];
      result.tech_ey = buffer[3];
      result.tech_one = one;
      result.tech_x1 = x1;
      result.tech_y1 = y1;
      result.tech_chose = chose;
      result.tech_x = magnitude;
      result.tech_y = angle;
      result.tech_two = two;

      return result;
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationConvolutionCalculator
   * POST: /api/calculators-lol/convolution-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationConvolutionCalculator(body) {
    let seq1 = body.tech_seq1;
    let seq2 = body.tech_seq2;

    if (!seq1 || !seq2) {
      return { error: "Please! Check Your Input." };
    }

    let set1 = seq1
      .split(",")
      .map((s) => s.trim())
      .filter(Boolean);
    let set2 = seq2
      .split(",")
      .map((s) => s.trim())
      .filter(Boolean);

    let isValid = set1.every((n) => !isNaN(n)) && set2.every((n) => !isNaN(n));

    if (!isValid) {
      return { error: "Please! Check Your Input." };
    }

    try {
      const response = await axios.get("http://167.172.134.148/convolution", {
        params: {
          seq1: seq1,
          seq2: seq2,
        },
        timeout: 120000,
      });

      const buffer = response.data;
      let conv = buffer.split("###");
      conv.pop(); // Remove last empty element

      return {
        tech_conv: conv,
      };
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationConvolutionCalculator
   * POST: /api/calculators-lol/convolution-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationJacobianCalculator(body) {
    let xu = body.tech_xu;
    let xu_var = body.tech_xu_var;
    let yv = body.tech_yv;
    let yv_var = body.tech_yv_var;
    let zw = body.tech_zw;
    let zw_var = body.tech_zw_var;
    let submit = body.tech_type;

    // Input security check
    const invalidPattern = /<|>|\&|php|print_r|print|echo|script|=|&|%/i;
    if (
      invalidPattern.test(xu) ||
      invalidPattern.test(yv) ||
      invalidPattern.test(zw)
    ) {
      return { error: "Please Enter Valid Input." };
    }

    if (!xu || !yv) {
      return { error: "Please Check Your Input." };
    }

    // Cleaning helper
    const clean = (str) =>
      str
        .replace(/ /g, "")
        .replace(/%20/g, "")
        .replace(/\+/g, "plus")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**");

    let parem = clean(xu);
    let parem1 = clean(yv);
    let parem2 = zw ? clean(zw) : null;

    try {
      let apiURL = "http://167.172.134.148/jacobian";
      let params = {
        equ: parem,
        equ1: parem1,
        var: xu_var,
        var1: yv_var,
        check: submit,
      };

      if (submit === "three" && parem2) {
        params.equ2 = parem2;
        params.var2 = zw_var;
      }

      const response = await axios.get(apiURL, {
        params,
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      if (submit === "three") {
        return {
          tech_enter: buffer[0],
          tech_enter1: buffer[1],
          tech_enter2: buffer[2],
          tech_jacob: buffer[3],
          tech_dtrmnt: buffer[4],
          tech_var: buffer[5],
          tech_var1: buffer[6],
          tech_var2: buffer[7],
          tech_check: submit,
        };
      } else {
        return {
          tech_enter: buffer[0],
          tech_enter1: buffer[1],
          tech_jacob: buffer[2],
          tech_dtrmnt: buffer[3],
          tech_var: buffer[4],
          tech_var1: buffer[5],
          tech_check: submit,
        };
      }
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationWasherMethodCalculator
   * POST: /api/calculators-lol/convolution-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationWasherMethodCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let EnterEq1 = body.tech_EnterEq1;
    let ub = body.tech_ub;
    let lb = body.tech_lb;

    // Validation: Check required fields and prevent script injection
    const invalidPattern = /<|>|\&|php|print_r|print|echo|script|=|%/i;
    if (
      !EnterEq ||
      !EnterEq1 ||
      invalidPattern.test(EnterEq) ||
      invalidPattern.test(EnterEq1)
    ) {
      return { error: "Please! Check Your Input." };
    }

    if (!isFinite(ub) || !isFinite(lb)) {
      return { error: "Please! Check Your Input." };
    }

    // Function to clean expression
    const clean = (str) =>
      str
        .replace(/ /g, "")
        .replace(/\+/g, "plus")
        .replace(/%20/g, "")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
        .replace(/e\^x/g, "exp(x)")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**");

    let parem = clean(EnterEq);
    let parem1 = clean(EnterEq1);

    // Construct washer formula: (f(x))^2 - (g(x))^2
    let equ = `(${parem})**2-(${parem1})**2`;

    try {
      const response = await axios.get("http://167.172.134.148/washer", {
        params: {
          equ: equ,
          ub: ub,
          lb: lb,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      return {
        tech_step: buffer[0],
        tech_res: buffer[1],
        tech_enter: buffer[2],
        tech_ress: buffer[3],
        tech_ress1: buffer[4],
      };
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationShellMethodCalculator
   * POST: /api/calculators-lol/shell-method-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationShellMethodCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let ub = body.tech_ub;
    let lb = body.tech_lb;
    let withVar = body.tech_with;

    const invalidPattern = /<|>|\&|php|print_r|print|echo|script|=|%/i;
    if (!EnterEq || invalidPattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    if (!isFinite(ub) || !isFinite(lb)) {
      return { error: "Please! Check Your Input." };
    }

    // Expression formatting
    const clean = (str) =>
      str
        .replace(/ /g, "")
        .replace(/\+/g, "plus")
        .replace(/%20/g, "")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
        .replace(/e\^x/g, "exp(x)")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**");

    let parem = clean(EnterEq);
    withVar = withVar?.trim() || "";

    let equ = `2*pi*${withVar}(${parem})`;

    try {
      const response = await axios.get("http://167.172.134.148/shell", {
        params: {
          equ: equ,
          ub: ub,
          lb: lb,
          with: withVar,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      return {
        tech_step: buffer[0],
        tech_res: buffer[1],
        tech_enter: buffer[2],
        tech_ress: buffer[3],
        tech_ress1: buffer[4],
      };
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationImplicitDifferentiationCalculator
   * POST: /api/calculators-lol/implicit-differentiation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationImplicitDifferentiationCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let EnterEq1 = body.tech_EnterEq1;
    let x = body.tech_x;
    let y = body.tech_y;
    let withVar = body.tech_with;

    const invalidPattern = /<|>|\&|php|print_r|print|echo|script|=|%/i;

    if (
      !EnterEq ||
      !EnterEq1 ||
      invalidPattern.test(EnterEq) ||
      invalidPattern.test(EnterEq1)
    ) {
      return { error: "Please! Check Your Input." };
    }

    if (!withVar) {
      return { error: "Please! Check Your Input." };
    }

    const clean = (str) =>
      str
        .replace(/ /g, "")
        .replace(/\+/g, "plus")
        .replace(/%20/g, "")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
        .replace(/e\^x/g, "exp(x)")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**");

    let parem = clean(EnterEq);
    let parem1 = clean(EnterEq1);
    let equ = `(${parem})-(${parem1})`;

    let params = {
      equ: parem,
      equ1: parem1,
      with: withVar,
      main: equ,
    };

    if (!isNaN(x) && !isNaN(y)) {
      params.x = x;
      params.y = y;
    }

    try {
      const response = await axios.get("http://167.172.134.148/implicit", {
        params: params,
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      let result = {
        tech_res: buffer[0],
        tech_enter: buffer[1],
        tech_enter1: buffer[2],
      };

      if (!isNaN(x) && !isNaN(y)) {
        result.tech_resf = buffer[3];
      }

      return result;
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationCriticalPointCalculator
   * POST: /api/calculators-lol/critical-points-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCriticalPointCalculator(body) {
    let EnterEq = body.tech_EnterEq;

    const invalidPattern = /<|>|\&|php|print_r|print|echo|script|=|%/i;
    if (!EnterEq || invalidPattern.test(EnterEq)) {
      return { error: "Please Enter Valid Input." };
    }

    const clean = (str) =>
      str
        .replace(/ /g, "")
        .replace(/\+/g, "plus")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
        .replace(/e\^x/g, "exp(x)")
        .replace(/exp\^/g, "exp")
        .replace(/e\^/g, "exp")
        .replace(/\^/g, "**");

    let parem = clean(EnterEq);
    let wrt = /x/i.test(parem) && /y/i.test(parem) ? "xy" : "x";

    try {
      const response = await axios.get("http://167.172.134.148/critical", {
        params: {
          equ: parem,
          wrt: wrt,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      if (buffer[4] === "\\left[ \\right]") {
        return { error: "No solution exists" };
      }

      let result = {
        tech_buffer: buffer[0],
        tech_ans: buffer[1],
        tech_enter: buffer[2],
        tech_simple: buffer[3],
        tech_root: buffer[4],
      };

      if (wrt === "xy") {
        result.tech_step = buffer[5];
        result.tech_ans1 = buffer[6];
        result.tech_wrt = "xy";
      } else {
        result.tech_mini = buffer[5];
        result.tech_maxi = buffer[6];
      }

      return result;
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationPartialDerivativeCalculator
   * POST: /api/calculators-lol/partial-derivative-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPartialDerivativeCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let withRespectTo = body.tech_with;
    let how = body.tech_how;

    const invalidPattern = /<|>|&|php|print_r|print|echo|script|=|%/i;
    if (!EnterEq || invalidPattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    // Clean up the input expression
    let parem = EnterEq.replace(/ /g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^x/g, "exp(x)")
      .replace(/e\^y/g, "exp(y)")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    let wrt = (withRespectTo || "").trim();
    let howOrder = how;

    try {
      const response = await axios.get("http://167.172.134.148/derivative", {
        params: {
          equ: parem,
          wrt: wrt,
          how: howOrder,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      if (howOrder > 1) {
        return {
          tech_enter: buffer[0],
          tech_final_res: buffer,
        };
      } else {
        return {
          tech_buffer: buffer[0],
          tech_ans: buffer[1],
          tech_enter: buffer[2],
          tech_simple: buffer[3],
        };
      }
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationAbsoluteValueCalculator
   * POST: /api/calculators-lol/absolute-value-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAbsoluteValueCalculator(body) {
    let eq = body.tech_eq;
    let n = body.tech_n;
    let n1 = body.tech_n1;
    let variable = body.tech_var;
    let type = body.tech_type;

    const invalidPattern = /<|>|&|php|print_r|print|echo|script|=|%/i;

    if (type === "m1" && !isNaN(n)) {
      return {
        tech_res: Math.abs(Number(n)),
      };
    } else if (type === "m2" && eq && n1) {
      if (invalidPattern.test(eq)) {
        return { error: "Please Enter Valid Input." };
      }

      const cleanExpression = (str) => {
        return str
          .replace(/ /g, "")
          .replace(/%20/g, "")
          .replace(/\+/g, "plus")
          .replace(/{/g, "(")
          .replace(/}/g, ")")
          .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
          .replace(/e\^/g, "exp")
          .replace(/exp\^/g, "exp")
          .replace(/\^/g, "**");
      };

      let parem = cleanExpression(eq);
      let parem1 = cleanExpression(n1);

      let equ = `(${parem})-(${parem1})`;
      let equ1 = `(${parem})plus(${parem1})`;

      try {
        const response = await axios.get("http://167.172.134.148/absolute", {
          params: {
            eq: equ,
            eq1: equ1,
            var: variable,
            e1: parem,
            e2: parem1,
          },
          timeout: 120000,
        });

        const buffer = response.data.split("@@@");
        let [res, res1, check1, check11, check2, check22] = buffer;

        if (/\|/.test(eq)) {
          check1 = Math.abs(check1);
          check2 = Math.abs(check2);
        } else if (/\|/.test(n1)) {
          check11 = Math.abs(check11);
          check22 = Math.abs(check22);
        }

        return {
          tech_res: res,
          tech_res1: res1,
          tech_check1: check1,
          tech_check11: check11,
          tech_check2: check2,
          tech_check22: check22,
          tech_eq: eq,
          tech_n1: n1,
        };
      } catch (err) {
        return { error: "Please! Check Your Input." };
      }
    } else {
      return { error: "Please Enter Valid Input." };
    }
  }

  /** getCalculationAreaUnderTheCurveCalculator
   * POST: /api/calculators-lol/area-under-the-curve-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAreaUnderTheCurveCalculator(body) {
    let enterEq1 = body.tech_EnterEq1;
    let withRespectTo = body.tech_with;
    let upper = body.tech_upper?.trim();
    let lower = body.tech_lower?.trim();

    if (!enterEq1) {
      return { error: "Please enter any one value." };
    }

    let parem = enterEq1
      .replace(/ /g, "")
      .replace(/\+/g, "plus")
      .replace(/%20/g, "")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^x/g, "exp(x)")
      .replace(/e\^y/g, "exp(y)")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    const normalizeBound = (val) => {
      if (val === "e") return 2.71828;
      return val.replace(/inf|∞/g, "oo");
    };

    upper = normalizeBound(upper);
    lower = normalizeBound(lower);

    try {
      const response = await axios.post(
        "http://167.172.134.148/new-area",
        qs.stringify({
          equ: parem,
          wrt: withRespectTo,
          ub: upper,
          lb: lower,
        }),
        {
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
          },
          timeout: 120000,
        }
      );

      const buffer = response.data;
      parem = parem.replace(/plus/g, "+");
      let readableEq = parem.replace(/\*\*/g, "^");

      return {
        tech_enter: readableEq,
        tech_with: withRespectTo,
        tech_ub: upper,
        tech_lb: lower,
        tech_ans: buffer[0],
        tech_ans1: buffer[1],
        tech_steps: buffer[2],
      };
    } catch (err) {
      return { error: "Backend error: " + err.message };
    }
  }

  /** getCalculationSecondDerivativeCalculator
   * POST: /api/calculators-lol/second-derivative-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSecondDerivativeCalculator(body) {
    let enterEq = body.tech_EnterEq;
    let withRespectTo = body.tech_with;
    let how = 2;

    // Basic input validation
    if (!enterEq || /[<>&]|php|print_r|print|echo|script|=|%/i.test(enterEq)) {
      return { error: "Please! Check Your Input." };
    }

    let parem = enterEq
      .replace(/ /g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^x/g, "exp(x)")
      .replace(/e\^y/g, "exp(y)")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    try {
      const response = await axios.get("http://167.172.134.148/derivative", {
        params: {
          equ: parem,
          wrt: withRespectTo,
          how: how,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      return {
        tech_enter: buffer[0],
        tech_final_res: buffer,
      };
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationDoubleIntegralCalculator
   * POST: /api/calculators-lol/double-integral-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDoubleIntegralCalculator(body) {
    let enterEq = body.tech_EnterEq;
    let withRespectTo = body.tech_with;
    let form = body.tech_form;
    let lbx = body.tech_lbx;
    let ubx = body.tech_ubx;
    let lby = body.tech_lby;
    let uby = body.tech_uby;

    // Basic validation
    if (!enterEq || /[<>&]|php|print_r|print|echo|script|=|%/i.test(enterEq)) {
      return { error: "Please! Check Your Input." };
    }

    if (form === "def") {
      if (!ubx || !lbx || !uby || !lby) {
        return { error: "Please! Check Your Input." };
      }
    }

    let parem = enterEq
      .replace(/ /g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^x/g, "exp(x)")
      .replace(/e\^y/g, "exp(y)")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    let url = "http://167.172.134.148/double_int";
    let params = {
      equ: parem,
      wrt: withRespectTo,
    };

    if (form === "def") {
      params.ubx = ubx.replace(/\+/g, "plus");
      params.lbx = lbx.replace(/\+/g, "plus");
      params.uby = uby.replace(/\+/g, "plus");
      params.lby = lby.replace(/\+/g, "plus");
    }

    try {
      const response = await axios.get(url, {
        params: params,
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      let result = {
        tech_def: form,
        tech_enter: buffer[0],
        tech_final: buffer[1],
        tech_en1: buffer[2],
        tech_en2: buffer[3],
        tech_step1: buffer[4],
        tech_step2: buffer[5],
      };

      if (form === "def") {
        result.tech_finaln = buffer[6];
      }

      return result;
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationTripleIntegralCalculator
   * POST: /api/calculators-lol/double-integral-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTripleIntegralCalculator(body) {
    let enterEq = body.tech_EnterEq;
    let withRespectTo = body.tech_with;
    let form = body.tech_form;
    let lbx = body.tech_lbx;
    let ubx = body.tech_ubx;
    let lby = body.tech_lby;
    let uby = body.tech_uby;
    let lbz = body.tech_lbz;
    let ubz = body.tech_ubz;

    // Input validation
    if (!enterEq || /[<>&]|php|print_r|print|echo|script|=|%/i.test(enterEq)) {
      return { error: "Please! Check Your Input." };
    }

    if (form === "def") {
      if (!ubx || !lbx || !uby || !lby || !ubz || !lbz) {
        return { error: "Please! Check Your Input." };
      }
    }

    // Equation cleanup
    let parem = enterEq
      .replace(/ /g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^x/g, "exp(x)")
      .replace(/e\^y/g, "exp(y)")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    let url = "http://167.172.134.148/triple_int";
    let params = {
      equ: parem,
      wrt: withRespectTo,
    };

    if (form === "def") {
      params.ubx = ubx.replace(/\+/g, "plus");
      params.lbx = lbx.replace(/\+/g, "plus");
      params.uby = uby.replace(/\+/g, "plus");
      params.lby = lby.replace(/\+/g, "plus");
      params.ubz = ubz.replace(/\+/g, "plus");
      params.lbz = lbz.replace(/\+/g, "plus");
    }

    try {
      const response = await axios.get(url, {
        params: params,
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      let result = {
        tech_def: form,
        tech_enter: buffer[0],
        tech_final: buffer[1],
        tech_en1: buffer[2],
        tech_en2: buffer[3],
        tech_en3: buffer[4],
        tech_step1: buffer[5],
        tech_step2: buffer[6],
        tech_step3: buffer[7],
      };

      if (form === "def") {
        result.tech_finaln = buffer[8];
      }

      return result;
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationLimitCalculator
   * POST: /api/calculators-lol/limit-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLimitCalculator(body) {
    let enterEq = body.tech_EnterEq;
    let how = body.tech_how;
    let withRespectTo = body.tech_with;
    let dir = body.tech_dir;

    // Validate input
    if (!enterEq || /[<>&]|php|print_r|print|echo|script|=|%/i.test(enterEq)) {
      return { error: "Please! Check Your Input." };
    }

    if (!withRespectTo || !dir) {
      return { error: "Please! Check Your Input." };
    }

    // Clean expression
    let parem = enterEq
      .replace(/ /g, "")
      .replace(/%20/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    let parem2;
    if (!isNaN(how)) {
      parem2 = how;
    } else if (/inf|pi|e|∞/i.test(how)) {
      parem2 = how.replace(/inf|∞/gi, "oo");
      how = parem2;
      if (parem2 === "e") {
        parem2 = 2.71828;
      }
    } else {
      return { error: "Please! Check Your Input." };
    }

    let parem1 = withRespectTo.trim();
    let parem3 = dir.trim().replace(/\+/g, "plus");

    let check2 = parem.split("/");
    let upr, btm;

    if (check2.length === 2) {
      upr = check2[0].replace(parem1, `(${parem2})`);
      btm = check2[1].replace(parem1, `(${parem2})`);
    }

    try {
      let postData = {
        equ: parem,
        wrt: parem1,
        lim: parem2,
        op: parem3,
      };

      if (check2.length === 2) {
        postData.upr = upr;
        postData.btm = btm;
      }

      const response = await axios.post(
        "http://167.172.134.148/new-limit",
        new URLSearchParams(postData),
        { timeout: 120000 }
      );

      const buffer = response.data;

      let result = {
        tech_ans: buffer[0],
        tech_inf: how,
        tech_with: withRespectTo,
        tech_how: how,
        tech_dir: dir,
        tech_enter: buffer[1],
        tech_put: buffer[1].replace(withRespectTo, `(${how})`),
      };

      if (check2.length === 2) {
        let uprVal = buffer[2];
        let btmVal = buffer[3];
        if (!isNaN(uprVal) && !isNaN(btmVal) && btmVal != 1) {
          result.tech_upr = uprVal;
          result.tech_btm = btmVal;
          result.tech_ser = buffer[4];
        }
      } else {
        result.tech_ser = buffer[2];
      }

      return result;
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationLaplaceTransformCalculator
   * POST: /api/calculators-lol/laplace-transform-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLaplaceTransformCalculator(body) {
    let enterEq = body.tech_EnterEq;

    // Input validation
    if (!enterEq || /[<>&]|php|print_r|print|echo|script|=|%/i.test(enterEq)) {
      return { error: "Please! Check Your Input." };
    }

    // Prepare equation
    let parem = enterEq
      .replace(/ /g, "")
      .replace(/f\(t\)=/g, "")
      .replace(/\+/g, "plus")
      .replace(/%20/g, "")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    try {
      const response = await axios.post(
        "http://167.172.134.148/new-laplace",
        new URLSearchParams({ equ: parem }),
        { timeout: 120000 }
      );

      const buffer = response.data;

      return {
        tech_ans: buffer[0],
        tech_enter: buffer[1],
      };
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationInflectionPointCalculator
   * POST: /api/calculators-lol/inflection-point-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationInflectionPointCalculator(body) {
    let eq = body.tech_eq;

    // Input validation
    if (!eq || /[<>&]|php|print_r|print|echo|script|=|%/i.test(eq)) {
      return { error: "Please! Check Your Input." };
    }

    // Prepare equation
    let parem = eq
      .replace(/ /g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    try {
      const response = await axios.post(
        "http://167.172.134.148/new-inflection",
        new URLSearchParams({ equ: parem }),
        { timeout: 120000 }
      );

      const buffer = response.data;
      const result = {};

      if (buffer.length <= 1) {
        return { error: "Please! Check Your Input." };
      } else if (buffer.length <= 8) {
        result.no = "no";
      } else if (buffer.length === 11) {
        result.tech_ip_1 = "ip_1";
        result.tech_ip1 = parseFloat(buffer[7]).toFixed(3);
        result.tech_ip11 = parseFloat(buffer[8]).toFixed(3);
        result.tech_root = buffer[9];
        result.tech_iptype = buffer[10];
      } else {
        result.tech_ip1 = parseFloat(buffer[7]).toFixed(3);
        result.tech_ip11 = parseFloat(buffer[8]).toFixed(3);
        result.tech_ip2 = parseFloat(buffer[9]).toFixed(3);
        result.tech_ip22 = parseFloat(buffer[10]).toFixed(3);
        result.tech_root = buffer[11];
        result.tech_iptype = buffer[12];
      }

      result.tech_enter = buffer[0];
      result.tech_diff = buffer[1];
      result.tech_step = buffer[2];
      result.tech_diff1 = buffer[3];
      result.tech_step1 = buffer[4];
      result.tech_diff2 = buffer[5];
      result.tech_step2 = buffer[6];

      return result;
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationBinomialTheoremCalculator
   * POST: /api/calculators-lol/binomial-theorem-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationBinomialTheoremCalculator(body) {
    let enterEq = body.tech_enter_eq;
    let x = body.tech_x;

    // Input validation
    if (!enterEq || /[<>&]|php|print_r|print|echo|script|=|%/i.test(enterEq)) {
      return { error: "Please! Check Your Input." };
    }

    if (!isFinite(x)) {
      return { error: "Please! Check Your Input." };
    }

    // Format equation
    let parem = enterEq
      .replace(/ /g, "")
      .replace(/\+/g, "plus")
      .replace(/%20/g, "")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    // Final binomial expression
    parem = `(${parem})**${x}`;

    try {
      const response = await axios.post(
        "http://167.172.134.148/new-binomial",
        new URLSearchParams({
          equ: parem,
          x: x,
        }),
        { timeout: 120000 }
      );

      const buffer = response.data;

      return {
        tech_eq: buffer[1],
        tech_ans: buffer[0],
      };
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationUnitTangentVectorCalculator
   * POST: /api/calculators-lol/unit-tangent-vector-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationUnitTangentVectorCalculator(body) {
    let x = body.tech_x;
    let y = body.tech_y;
    let z = body.tech_z;
    let t = body.tech_t;

    const isInvalid = (val) =>
      !val || /[<>&]|php|print_r|print|echo|script|=|%/i.test(val);

    if (isInvalid(x) || isInvalid(y) || isInvalid(z)) {
      return { error: "Please! Check Your Input." };
    }

    if (!isFinite(t)) {
      return { error: "Please! Check Your Input." };
    }

    const formatExpr = (expr) => {
      return expr
        .replace(/ /g, "")
        .replace(/\+/g, "plus")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**")
        .replace(/e\^sqrt\(x\)/g, "exp(2*x)");
    };

    let parem = formatExpr(x);
    let parem1 = formatExpr(y);
    let parem2 = formatExpr(z);

    const containsTrig = (str) => /sin|cos|tan/i.test(str);
    const checkMethod =
      containsTrig(x) || containsTrig(y) || containsTrig(z)
        ? "method1"
        : "method2";

    try {
      const response = await axios.get("http://167.172.134.148/utvc", {
        timeout: 120000,
        params: {
          eq: parem,
          eq1: parem1,
          eq2: parem2,
          t: t,
          check: checkMethod,
        },
      });

      const buffer = response.data.split("@@@");
      let result = { check: buffer[0] };

      if (buffer[0] === "method1") {
        result.tech_enter = buffer[1];
        result.tech_enter1 = buffer[2];
        result.tech_enter2 = buffer[3];
        result.tech_deriv = buffer[4];
        result.tech_deriv1 = buffer[5];
        result.tech_deriv2 = buffer[6];
        result.tech_steps = buffer[7];
        result.tech_steps1 = buffer[8];
        result.tech_steps2 = buffer[9];
        result.tech_eq_len = buffer[10];
        result.tech_eq1_len = buffer[11];
        result.tech_eq2_len = buffer[12];
        result.tech_eq_solve = buffer[13];
        if (t) {
          result.tech_res = buffer[14];
          result.tech_res1 = buffer[15];
          result.tech_res2 = buffer[16];
        }
        result.t = t;
      } else if (buffer[0] === "method2") {
        result.tech_enter = buffer[1];
        result.tech_enter1 = buffer[2];
        result.tech_enter2 = buffer[3];
        result.tech_deriv = buffer[4];
        result.tech_deriv1 = buffer[5];
        result.tech_deriv2 = buffer[6];
        result.tech_steps = buffer[7];
        result.tech_steps1 = buffer[8];
        result.tech_steps2 = buffer[9];
        result.tech_eq_len = buffer[10];
        result.tech_eq1_len = buffer[11];
        result.tech_eq2_len = buffer[12];
        result.tech_ans = buffer[13];
        result.tech_ans1 = buffer[14];
        result.tech_ans2 = buffer[15];
        result.tech_t = t;
      } else {
        return { error: "Please! Check Your Input." };
      }

      return result;
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationRemainderTheoremCalculator
   * POST: /api/calculators-lol/remainder-theorem-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRemainderTheoremCalculator(body) {
    let num = body.tech_num;
    let denom = body.tech_denom;

    const isInvalid = (val) =>
      !val || /[<>&]|php|print_r|print|echo|script|=|%/i.test(val);

    if (isInvalid(num) || isInvalid(denom)) {
      return { error: "Please Enter Valid Input." };
    }

    const formatExpr = (expr) => {
      return expr
        .replace(/ /g, "")
        .replace(/\+/g, "plus")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**")
        .replace(/e\^sqrt\(x\)/g, "exp(2*x)");
    };

    let parem = formatExpr(num);
    let parem1 = formatExpr(denom);

    try {
      const response = await axios.get("http://167.172.134.148/r_t", {
        timeout: 120000,
        params: {
          eq: parem,
          eq1: parem1,
        },
      });

      const buffer = response.data.split("@@@");
      return {
        tech_enter: buffer[0],
        tech_enter1: buffer[1],
        tech_x: buffer[2],
        tech_ans: buffer[3],
      };
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationFOILCalculator
   * POST: /api/calculators-lol/remainder-theorem-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationFOILCalculator(body) {
    let exp = body.tech_exp;

    if (
      /<|>|&|php|print_r|print|echo|script|=|sin|cos|tan|arcsin|arccos|arctan|%/i.test(
        exp
      )
    ) {
      return { error: "Please Enter Valid Input." };
    }

    if (!exp) {
      return { error: "Please Check Your Input." };
    }

    let parem = exp
      .replace(/ /g, "")
      .replace(/%20/g, "")
      .replace(/plus/g, "+")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    try {
      if (/\*\*2|\*\*3/.test(parem)) {
        let s1 = parem.split("**");
        let opr, a, b;
        let s2 = s1[0].split("+");
        let s2_ = s1[0].split("-");

        if (s2.length === 2) {
          opr = "+";
          let s3 = s2[0].split("(");
          let s4 = s2[1].split(")");
          a = opr + s3[1];
          b = opr + s4[0];
        } else if (s2_.length === 2) {
          opr = "-";
          let s3 = s2_[0].split("(");
          let s4 = s2_[1].split(")");
          a = opr + s3[1];
          b = opr + s4[0];
        }

        let expnt = s1[1];
        let eq = s1[0];
        let par = parem.replace(/\+/g, "plus");

        const response = await axios.get("http://167.172.134.148/foil", {
          timeout: 120000,
          params: {
            equ: par,
            a,
            opr,
            b,
            exp: expnt,
            eq,
          },
        });

        let buffer = response.data.split("@@@");
        return {
          tech_eq: buffer[0],
          tech_ans: buffer[1],
          tech_a: buffer[2],
          tech_b: buffer[3],
          tech_s1: buffer[4],
          tech_s2: buffer[5],
          tech_s3: buffer[6],
          tech_s4: buffer[7],
          tech_equ: buffer[8],
          tech_opr: buffer[9],
          tech_exp: buffer[10],
        };
      } else {
        let s1 = parem.split(")(");
        if (s1.length > 2) {
          return { error: "Please Check Your Input." };
        }

        let s2 = s1[0].split("(");
        let s3 = s1[1].split(")");
        let opr, a, b, opr1, c, d;

        let s4 = s2[1].split("+");
        let s4_ = s2[1].split("-");
        let s5 = s3[0].split("+");
        let s5_ = s3[0].split("-");

        if (s4.length === 2) {
          opr = "plus";
          a = s4[0];
          b = opr + s4[1];
        } else if (s4_.length === 2) {
          opr = "-";
          a = s4_[0];
          b = opr + s4_[1];
        } else if (s4_.length === 3) {
          opr = "-";
          a = opr + s4_[1];
          b = opr + s4_[2];
        }

        if (s5.length === 2) {
          opr1 = "plus";
          c = s5[0];
          d = opr1 + s5[1];
        } else if (s5_.length === 2) {
          opr1 = "-";
          c = s5_[0];
          d = opr1 + s5_[1];
        } else if (s5_.length === 3) {
          opr1 = "-";
          c = opr1 + s5_[1];
          d = opr1 + s5_[2];
        }

        let par = parem.replace(/\+/g, "plus");

        const response = await axios.get("http://167.172.134.148/foil", {
          timeout: 120000,
          params: {
            equ: par,
            a,
            opr,
            b,
            c,
            opr1,
            d,
          },
        });

        let buffer = response.data.split("@@@");
        return {
          tech_eq: buffer[0],
          tech_ans: buffer[1],
          tech_a: buffer[2],
          tech_b: buffer[3],
          tech_c: buffer[4],
          tech_d: buffer[5],
          tech_s1: buffer[6],
          tech_s2: buffer[7],
          tech_s3: buffer[8],
          tech_s4: buffer[9],
          tech_opr: buffer[10],
          tech_opr1: buffer[11],
          tech_check: buffer[12],
        };
      }
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }
  /** getCalculationEulerMethodCalculator
   * POST: /api/calculators-lol/eulers-method-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTrapezoidalRuleCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let lb = body.tech_lb;
    let ub = body.tech_ub;
    let n = body.tech_n;
    let _with = body.tech_with;

    let result = {};

    // Basic validation
    if (!EnterEq || /[<>&=]|php|print_r|print|echo|script|%/i.test(EnterEq)) {
      result.error = "Please! Check Your Input.";
      return result;
    }

    // Check numeric values
    if (!isFinite(lb) || !isFinite(ub) || !isFinite(n)) {
      result.error = "Please! Check Your Input.";
      return result;
    }

    lb = parseFloat(lb);
    ub = parseFloat(ub);
    n = parseInt(n);

    if (lb >= ub) {
      result.error = "The lower limit should be less than the upper limit.";
      return result;
    }

    // Prepare expression
    let parem = EnterEq.replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    let diff = (ub - lb) / n;
    let final = lb;
    let limit_a = [lb];
    let limit = `${final}`;

    while (final < ub) {
      final += diff;
      limit_a.push(final);
      limit += `, ${final}`;
    }

    try {
      const response = await axios.get("http://167.172.134.148/trap", {
        params: {
          equ: parem,
          with: _with,
          lb,
          ub,
          n,
          diff,
        },
        timeout: 120000,
      });

      let buffer = response.data.split("@@@");
      let steps = buffer[0].split("HA");

      result.tech_steps = steps;
      result.tech_res = buffer[1];
      result.tech_enter = buffer[2];
      result.tech_ub = ub;
      result.tech_lb = lb;
      result.tech_n = n;
      result.tech_diff = diff;
      result.tech_limit = limit;
      result.tech_limit_a = limit_a;
      result.tech_with = _with;
      return result;
    } catch (err) {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /** getCalculationNewtonsMethodCalculator
   * POST: /api/calculators-lol/newtons-method-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationNewtonsMethodCalculator(body) {
    let fx = body.tech_fx;
    let fx1 = body.tech_fx1;
    let x0 = body.tech_x0;
    let iter = body.tech_iter;
    let round = body.tech_round;

    let result = {};

    // Validation
    const unsafePattern = /<|>|&|php|print_r|print|echo|script|=|%/i;
    if (!fx || unsafePattern.test(fx)) {
      result.error = "Please Enter Valid Input.";
      return result;
    }

    if (!isFinite(round) || !isFinite(iter) || !isFinite(x0)) {
      result.error = "Please! Check Your Input";
      return result;
    }

    // Clean and prepare fx
    let parem = fx
      .replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/%20/g, "")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    let parem1 = "0";
    if (fx1 && fx1 !== "") {
      if (unsafePattern.test(fx1)) {
        result.error = "Please Enter Valid Input.";
        return result;
      }

      parem1 = fx1
        .replace(/\s+/g, "")
        .replace(/\+/g, "plus")
        .replace(/%20/g, "")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**")
        .replace(/e\^sqrt\(x\)/g, "exp(2*x)");
    }

    // Default round if not numeric
    if (!isFinite(round)) {
      round = 4;
    }

    try {
      const response = await axios.post(
        "http://167.172.134.148/new-newtons",
        new URLSearchParams({
          equ: parem,
          equ1: parem1,
          x: x0,
          iter,
          round,
        }),
        { timeout: 120000 }
      );

      let buffer = response.data;

      if (Array.isArray(buffer)) {
        if (buffer.length === 6) {
          result.tech_enter = buffer[0];
          result.tech_enter1 = buffer[1];
          result.tech_steps = buffer[2];
          result.tech_fx = buffer[3];
          result.tech_fx1 = buffer[4];
          result.tech_res = buffer[5];
          result.tech_round = round;
        } else if (buffer.length === 1) {
          result.error = "Please! Check Your Input.";
          return result;
        } else {
          result.tech_check = "check";
          result.tech_enter = buffer[0];
          result.tech_enter1 = buffer[1];
          result.tech_fx = buffer[2];
          result.tech_fx1 = buffer[3];
          result.tech_res = buffer[4];
          result.tech_round = round;
        }
      } else {
        result.error = "Unexpected response format.";
      }

      return result;
    } catch (error) {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /** getCalculationMeanValueTheoremCalculator
   * POST: /api/calculators-lol/mean-value-theorem-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMeanValueTheoremCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let lb = body.tech_lb;
    let ub = body.tech_ub;
    let withVar = body.tech_with;

    let result = {};
    const unsafePattern = /<|>|&|php|print_r|print|echo|script|=|%/i;

    if (!EnterEq || unsafePattern.test(EnterEq)) {
      result.error = "Please! Check Your Input.";
      return result;
    }

    if (!isFinite(lb) || !isFinite(ub)) {
      result.error = "Please! Check Your Input.";
      return result;
    }

    if (lb >= ub) {
      result.error = "The start interval should be less than the end inverval.";
      return result;
    }

    // Prepare equations
    let parem = EnterEq.replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    let parem1 = parem;
    if (withVar) {
      parem = parem.replace(new RegExp(withVar, "g"), "c");
    }

    try {
      const response = await axios.post(
        "http://167.172.134.148/new-mean",
        new URLSearchParams({
          equ: parem,
          equ1: parem1,
          lb,
          ub,
        }),
        { timeout: 120000 }
      );

      const buffer = response.data;
      const root = String(buffer[4]).replace("[", "").replace("]", "");

      result.tech_enter = buffer[0];
      result.tech_start = buffer[1];
      result.tech_end = buffer[2];
      result.tech_deri = buffer[3];
      result.tech_simple = buffer[5];
      result.tech_ub = ub;
      result.tech_lb = lb;
      result.tech_root = root;
      result.tech_with = withVar;
      return result;
    } catch (error) {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /** getCalculationRiemannSumCalculator
   * POST: /api/calculators-lol/riemann-sum-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRiemannSumCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let lb = body.tech_lb;
    let ub = body.tech_ub;
    let type = body.tech_type;
    let n = body.tech_n;
    let withVar = body.tech_with;

    let result = {};
    const unsafePattern = /<|>|&|php|print_r|print|echo|script|=|%/i;

    if (!EnterEq || unsafePattern.test(EnterEq)) {
      result.error = "Please! Check Your Input.";
      return result;
    }

    if (!isFinite(lb) || !isFinite(ub) || !isFinite(n)) {
      result.error = "Please! Check Your Input.";
      return result;
    }

    if (lb >= ub) {
      result.error = "The lower limit should be less than the upper limit.";
      return result;
    }

    let parem = EnterEq.replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    let diff = (ub - lb) / n;
    let final = lb;
    let limit = `${final}`;
    let limit_a = [];

    if (type !== "2") {
      limit_a.push(lb);
    }

    while (final < ub) {
      final += diff;
      limit_a.push(final);
      limit += `, ${final}`;
    }

    let lb_ = type === "2" ? lb + diff : lb;

    try {
      const response = await axios.post(
        "http://167.172.134.148/new-riemann",
        new URLSearchParams({
          equ: parem,
          with: withVar,
          ub,
          lb: lb_,
          n,
          type,
          diff,
        }),
        { timeout: 120000 }
      );

      const buffer = response.data;
      const steps = buffer[0].split("HA");

      result.tech_steps = steps;
      result.tech_res = buffer[1];
      result.tech_enter = buffer[2];
      result.tech_ub = ub;
      result.tech_lb = lb;
      result.tech_n = n;
      result.tech_type = type;
      result.tech_diff = diff;
      result.tech_limit = limit;
      result.tech_limit_a = limit_a;
      result.tech_with = withVar;
      return result;
    } catch (err) {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /** getCalculationInverseFunctionCalculator
   * POST: /api/calculators-lol/inverse-function-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationInverseFunctionCalculator(body) {
    let equ = body.tech_equ;

    let result = {};
    const unsafePattern = /<|>|&|php|print_r|print|echo|script|=|%/i;

    // Basic validation
    if (!equ || unsafePattern.test(equ)) {
      result.error = "Please Enter Valid Input.";
      return result;
    }

    // Extra variable check (only allow x and sqrt)
    const check = equ.split("sqrt");
    if (check.length === 1 && /[a-df-wA-DF-Wyz%]/.test(equ)) {
      result.error = "Equestion unacceptable variables.";
      return result;
    }

    // Format input
    let main = equ
      .replace(/x/g, "y")
      .replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/%20/g, "")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(y\)/g, "exp(2*y)");

    equ = equ
      .replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/%20/g, "")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(y\)/g, "exp(2*y)");

    let main2 = main;
    main = `${main}-x`;

    try {
      const response = await axios.post(
        "http://167.172.134.148/new-inv_fun",
        new URLSearchParams({
          equ,
          main2,
          main,
        }),
        { timeout: 120000 }
      );

      const buffer = response.data;
      let res = buffer[2].replace("\\left[", "").replace("\\right]", "");

      result.tech_enter = buffer[0];
      result.tech_enter2 = buffer[1];
      result.tech_res = res;
      return result;
    } catch (err) {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /** getCalculationCompositeFunctionCalculator
   * POST: /api/calculators-lol/composite-function-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCompositeFunctionCalculator(body) {
    let one = body.tech_one;
    let two = body.tech_two;
    let point = body.tech_point;

    let result = {};
    const unsafePattern = /<|>|&|php|print_r|print|echo|script|=|%/i;

    // Input validation
    if (
      !one ||
      !two ||
      isNaN(point) ||
      unsafePattern.test(one) ||
      unsafePattern.test(two)
    ) {
      result.error = "Please Enter Valid Input.";
      return result;
    }

    // Compose parem
    let one_ = one.replace(/x/g, "(x)").replace(/x/g, two);
    let parem = one_
      .replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/%20/g, "")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    // Compose parem1
    let two_ = two.replace(/x/g, "(x)").replace(/x/g, one);
    let parem1 = two_
      .replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/%20/g, "")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    try {
      const response = await axios.post(
        "http://167.172.134.148/new-composite",
        new URLSearchParams({
          equ: parem,
          equ1: parem1,
          lim: point.toString(),
        }),
        { timeout: 120000 }
      );

      const buffer = response.data;

      let penter = buffer[1].replace(/x/g, `(${point})`);
      let penter1 = buffer[3].replace(/x/g, `(${point})`);

      parem = parem
        .replace(/plus/g, "+")
        .replace(/\*\*/g, "^")
        .replace(/"/g, "");
      parem1 = parem1
        .replace(/plus/g, "+")
        .replace(/\*\*/g, "^")
        .replace(/"/g, "");

      result.tech_res = buffer[0];
      result.tech_enter = parem;
      result.tech_enter1 = parem1;
      result.tech_enter2 = buffer[1];
      result.tech_penter = penter;
      result.tech_penter1 = penter1;
      result.tech_res1 = buffer[2];
      result.tech_enter3 = buffer[3];
      result.tech_point = point;
      result.tech_one = one;
      result.tech_two = two;

      return result;
    } catch (error) {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /** getCalculationAreaBetweenTwoCurvesCalculator
   * POST: /api/calculators-lol/area-between-two-curves-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAreaBetweenTwoCurvesCalculator(body) {
    let EnterEq1 = body.tech_enter_eq1;
    let EnterEq2 = body.tech_enter_eq2;
    let wrt = body.tech_with;
    let ub = body.tech_upper;
    let lb = body.tech_lower;

    let result = {};
    const unsafePattern = /<|>|&|php|print_r|print|echo|script|=|%/i;

    // Input validation
    if (
      !EnterEq1 ||
      !EnterEq2 ||
      !lb ||
      !ub ||
      unsafePattern.test(EnterEq1) ||
      unsafePattern.test(EnterEq2)
    ) {
      result.error = "Please! Check Your Input.";
      return result;
    }

    // Compose expression
    let parem = `(${EnterEq1})-(${EnterEq2})`
      .replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/%20/g, "")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    // Clean bounds
    ub = ub.toString().replace(/inf|∞/gi, "oo");
    lb = lb.toString().replace(/inf|∞/gi, "oo");
    if (ub === "e") ub = "2.71828";
    if (lb === "e") lb = "2.71828";

    try {
      const response = await axios.post(
        "http://167.172.134.148/new-area",
        new URLSearchParams({
          equ: parem,
          wrt: wrt,
          ub: ub,
          lb: lb,
        }),
        { timeout: 120000 }
      );

      const buffer = response.data;

      parem = parem
        .replace(/plus/g, "+")
        .replace(/\*\*/g, "^")
        .replace(/"/g, "");

      result.tech_enter = parem;
      result.tech_with = wrt;
      result.tech_ub = ub;
      result.tech_lb = lb;
      result.tech_ans = buffer[0];
      result.tech_ans1 = buffer[1];
      result.tech_steps = buffer[2];

      return result;
    } catch (error) {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /** getCalculationZerosCalculator
   * POST: /api/calculators-lol/zeros-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationZerosCalculator(body) {
    let eq = body.tech_eq;
    let param = {};

    // Validation
    let isInvalid =
      /<|>|&|php|print_r|print|echo|script|sin|cos|tan|arcsin|arccos|arctan|%/i;
    if (!eq || isInvalid.test(eq)) {
      return { error: "Please Check Your Input!" };
    }

    // Sanitize input
    let parem = eq
      .replace(/\s+/g, "")
      .replace(/%20/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    // Handle equation formatting
    let splitEq = parem.split("=");
    if (splitEq.length === 2) {
      eq = `(${splitEq[0]})-(${splitEq[1]})`;
    } else {
      eq = splitEq[0];
    }

    try {
      const { data } = await axios.get("http://167.172.134.148/zeros", {
        params: { equ: eq },
        timeout: 120000,
      });

      let buffer = data.split("@@@");
      param.tech_eq = buffer[0];
      param.tech_s2 = buffer[1];
      param.tech_sum = buffer[2];
      param.tech_prod = buffer[3];
      return param;
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationGeometricSequenceCalculator
   * POST: /api/calculators-lol/geometric-sequence-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationGeometricSequenceCalculator(body) {
    let find = body.tech_find;
    let cw = body.tech_cw;
    let a1 = body.tech_a1;
    let r = body.tech_r;
    let n = body.tech_n;
    let an = body.tech_an;
    let sn = body.tech_sn;
    let n1 = body.tech_n1;
    let a_n = body.tech_a_n;

    // Helper to check if value is numeric
    function isNumeric(value) {
      return !isNaN(parseFloat(value)) && isFinite(value);
    }

    let param = {};

    if (find === "gs" && isNumeric(a1) && isNumeric(r) && isNumeric(n)) {
      let an_val = a1 * Math.pow(r, n - 1);
      let sn_val = (a1 * (1 - Math.pow(r, n))) / (1 - r);

      let seq = "";
      for (let i = 1; i <= 10; i++) {
        let sum = Math.pow(a1, i);
        seq += i < 10 ? `${sum}, ` : `${sum} ....`;
      }

      param.tech_an_val = an_val;
      param.tech_sn_val = sn_val;
      param.tech_seq = seq;
    } else if (
      find === "a1" &&
      isNumeric(r) &&
      isNumeric(n1) &&
      isNumeric(a_n)
    ) {
      let a1_val = a_n / Math.pow(r, n1 - 1);
      param.tech_a1_val = a1_val;
    } else if (
      find === "r" &&
      isNumeric(a1) &&
      isNumeric(n1) &&
      isNumeric(a_n)
    ) {
      let r_val = Math.pow(a_n / a1, 1 / (n1 - 1));
      param.tech_r_val = r_val;
    } else if (find === "n" && isNumeric(a1) && isNumeric(r)) {
      if (cw === "nth" && isNumeric(an)) {
        let n_val = Math.log(an / a1) / Math.log(r) + 1;
        param.tech_n_val = n_val;
      } else if (cw === "s_n" && isNumeric(sn)) {
        let numerator = ((sn / a1) * (1 - r) - 1) * -1;
        let n_val = Math.log(numerator) / Math.log(r);
        param.tech_n_val = n_val;
      }
    } else {
      return { error: "Please Check Your Input." };
    }

    return param;
  }

  /** getCalculationTruthTableCalculator
   * POST: /api/calculators-lol/truth-table-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTruthTableCalculator(body) {
    let eq = (body.tech_eq || "").trim();
    let submit = body.tech_submit;

    let param = {};

    // Input validation
    if (
      !eq ||
      /php|print_r|print|echo|script|sin|cos|tan|arcsin|arccos|arctan|%/i.test(
        eq
      )
    ) {
      return { error: "Please Enter Valid Input." };
    }

    if (submit) {
      param.tech_eq = eq;
      return param;
    } else {
      return { error: "Please! Check Your Input" };
    }
  }

  /** getCalculationEvenOddFunctionCalculator
   * POST: /api/calculators-lol/even-odd-function-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationEvenOddFunctionCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let withRespectTo = body.tech_with;

    // Input validation
    if (!EnterEq || /[<>&=]|php|print_r|print|echo|script|%/i.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    // Count and remove '|' if more than one
    let abs = (EnterEq.match(/\|/g) || []).length;
    let mode = null;

    if (abs > 1) {
      EnterEq = EnterEq.replace(/\|/g, "");
      mode = withRespectTo;
    }

    // Equation cleanup
    let parem = EnterEq.trim()
      .replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^x/g, "exp(x)")
      .replace(/e\^y/g, "exp(y)")
      .replace(/e\^/g, " exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    // Replace exp with e, then do substitution for -x
    let newEq = parem.replace(/exp/g, "e");
    let parem1 = newEq.replace(
      new RegExp(withRespectTo, "g"),
      `(-${withRespectTo})`
    );
    parem1 = parem1.replace(/e/g, " exp");

    try {
      const response = await axios.get("http://167.172.134.148/even", {
        params: {
          equ: parem,
          equ1: parem1,
          wrt: withRespectTo,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      return {
        tech_ans: buffer[0],
        tech_enter: buffer[1],
        tech_with: withRespectTo,
        tech_mode: mode,
      };
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationSyntheticDivisionCalculator
   * POST: /api/calculators-lol/synthetic-division-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSyntheticDivisionCalculator(body) {
    let dividend = body.tech_dividend;
    let divisor = body.tech_divisor;

    // Input validation for security
    const unsafePattern =
      /<|>|&|php|print_r|print|echo|script|sin|cos|tan|arcsin|arccos|arctan|%/i;
    if (unsafePattern.test(dividend) || unsafePattern.test(divisor)) {
      return { error: "Please Enter Valid Input." };
    }

    // Divisor pattern check
    const pattern =
      /^\s*(\(?\s*-?\d+(\.\d+)?\s*\)?|)\s*\(?([a-zA-Z])\)?\s*([\+\-])\s*\(?-?\d+(\.\d+)?\)?\s*$/;
    const matches = divisor.match(pattern);
    if (matches) {
      if (!dividend.includes(matches[3])) {
        return {
          error: `Variable ${matches[3]} does not exist in the function`,
        };
      }

      const uniqueVariables = [...new Set(dividend.match(/[a-zA-Z]/g) || [])];
      if (uniqueVariables.length > 1) {
        return { error: "Dividend contains more than one variable" };
      }

      if (!dividend || !divisor) {
        return { error: "Please! Check Your Input" };
      }

      // Clean and transform expressions
      const cleanup = (str) =>
        str
          .replace(/\s+/g, "")
          .replace(/%20/g, "")
          .replace(/\+/g, "plus")
          .replace(/{/g, "(")
          .replace(/}/g, ")")
          .replace(/–/g, "-")
          .replace(/e\^/g, "exp")
          .replace(/exp\^/g, "exp")
          .replace(/\^/g, "**")
          .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

      let parem = cleanup(dividend);
      let parem1 = cleanup(divisor);

      try {
        const response = await axios.get("http://167.172.134.148/synthetic", {
          params: {
            eq: parem,
            eq1: parem1,
          },
          timeout: 120000,
        });

        const buffer = response.data.split("@@@");
        const coeffs = buffer[2].split("###");
        const coeffs1 = buffer[7].split("###");

        return {
          tech_eq: buffer[0],
          tech_eq1: buffer[1],
          tech_coeffs: coeffs,
          tech_divby: buffer[3],
          tech_quot: buffer[4],
          tech_rmnd: buffer[5],
          tech_divby1: buffer[6],
          tech_coeffs1: coeffs1,
        };
      } catch (error) {
        return { error: "Please! Check Your Input." };
      }
    } else {
      return { error: "Please! Check Your Input" };
    }
  }
  /** getCalculationProductRuleDerivativeCalculator
   * POST: /api/calculators-lol/product-rule-derivative-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationProductRuleDerivativeCalculator(body) {
    let EnterEq = body.tech_enter_eq;
    let withRespectTo = body.tech_with;
    let how = body.tech_how;

    // Validation
    const unsafePattern = /<|>|&|php|print_r|print|echo|script|=|%/i;
    if (!EnterEq || unsafePattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    // Clean and transform input
    let parem = EnterEq.replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    let parem1 = withRespectTo;
    let parem2 = how;

    try {
      const response = await axios.get("http://167.172.134.148/derivative", {
        params: {
          equ: parem,
          wrt: parem1,
          how: parem2,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      if (parseInt(how) > 1) {
        return {
          tech_enter: buffer[0],
          tech_final_res: buffer,
          RESULT: 1,
        };
      } else {
        return {
          tech_buffer: buffer[0],
          tech_ans: buffer[1],
          tech_enter: buffer[2],
          tech_simple: buffer[3],
        };
      }
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationOrthocenterCalculator
   * POST: /api/calculators-lol/orthocenter-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationOrthocenterCalculator(body) {
    let x1 = body.tech_x1;
    let y1 = body.tech_y1;
    let x2 = body.tech_x2;
    let y2 = body.tech_y2;
    let x3 = body.tech_x3;
    let y3 = body.tech_y3;

    const result = {};

    if (
      isNaN(x1) ||
      isNaN(y1) ||
      isNaN(x2) ||
      isNaN(y2) ||
      isNaN(x3) ||
      isNaN(y3)
    ) {
      result.error = "Please! Check Your Input.";
      return result;
    }

    let ab1, ab2, bc1, bc2, ca1, ca2;
    let xx;

    const a = y2 - y1;
    const a1 = x2 - x1;
    if (a !== 0 && a1 !== 0) {
      const ab = a / a1;
      ab1 = -1 / ab;
      ab2 = y3 - ab1 * x3;
      xx = `y=${ab1}x${ab2 >= 0 ? "+" + ab2 : ab2}`;
    }

    const b = y3 - y2;
    const b1 = x3 - x2;
    if (b !== 0 && b1 !== 0) {
      const bc = b / b1;
      bc1 = -1 / bc;
      bc2 = y1 - bc1 * x1;
      xx = `y=${bc1}x${bc2 >= 0 ? "+" + bc2 : bc2}`;
    }

    const c = y3 - y1;
    const c1 = x3 - x1;
    if (c !== 0 && c1 !== 0) {
      const ca = c / c1;
      ca1 = -1 / ca;
      ca2 = y2 - ca1 * x2;
      xx = `y=${ca1}x${ca2 >= 0 ? "+" + ca2 : ca2}`;
    }

    if (a !== 0 && a1 !== 0 && b !== 0 && b1 !== 0 && c !== 0 && c1 !== 0) {
      const con = -bc1;
      const con1 = -bc2;
      const ad = con + ab1;
      const ad1 = ab2 + con1;
      const di = ad1 / ad;
      const di1 = -di;
      const y8 = bc1 * di1 + bc2;

      if (isNaN(di1) || isNaN(y8)) {
        result.error = "Please! Check Your Input.";
        return result;
      } else {
        result.tech_x = Number.isInteger(di1)
          ? di1
          : parseFloat(di1.toFixed(5));
        result.tech_y = Number.isInteger(y8) ? y8 : parseFloat(y8.toFixed(5));
      }
    } else if (a !== 0 && a1 !== 0 && b !== 0 && b1 !== 0) {
      const con = -bc1;
      const con1 = -bc2;
      const ad = con + ab1;
      const ad1 = ab2 + con1;
      const di = ad1 / ad;
      const di1 = -di;
      const y8 = bc1 * di1 + bc2;

      if (isNaN(di1) || isNaN(y8)) {
        result.error = "Please! Check Your Input.";
        return result;
      } else {
        result.tech_x = Number.isInteger(di1)
          ? di1
          : parseFloat(di1.toFixed(5));
        result.tech_y = Number.isInteger(y8) ? y8 : parseFloat(y8.toFixed(5));
      }
    } else if (b !== 0 && b1 !== 0 && c !== 0 && c1 !== 0) {
      const con2 = -ca1;
      const con3 = -ca2;
      const ad2 = con2 + bc1;
      const ad3 = bc2 + con3;
      const di = ad3 / ad2;
      const di1 = -di;
      const y8 = ca1 * di1 + ca2;

      if (isNaN(di1) || isNaN(y8)) {
        result.error = "Please! Check Your Input.";
        return result;
      } else {
        result.tech_x = Number.isInteger(di1)
          ? di1
          : parseFloat(di1.toFixed(5));
        result.tech_y = Number.isInteger(y8) ? y8 : parseFloat(y8.toFixed(5));
      }
    } else if (a !== 0 && a1 !== 0 && c !== 0 && c1 !== 0) {
      const con2 = -ab1;
      const con3 = -ab2;
      const ad2 = con2 + ca1;
      const ad3 = ca2 + con3;
      const di = ad3 / ad2;
      const di1 = -di;
      const y8 = ab1 * di1 + ab2;

      if (isNaN(di1) || isNaN(y8)) {
        result.error = "Please! Check Your Input.";
        return result;
      } else {
        result.tech_x = Number.isInteger(di1)
          ? di1
          : parseFloat(di1.toFixed(5));
        result.tech_y = Number.isInteger(y8) ? y8 : parseFloat(y8.toFixed(5));
      }
    } else {
      result.error = "Please! Check Your Input.";
      return result;
    }

    return result;
  }

  /** getCalculationPolynomialLongDivisionCalculator
   * POST: /api/calculators-lol/polynomial-long-division-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPolynomialLongDivisionCalculator(body) {
    let dividend = body.tech_dividend;
    let divisor = body.tech_divisor;

    const result = {};

    // Input validation
    if (!dividend || !divisor) {
      result.error = "Please Enter Valid Input.";
      return result;
    }

    // Check for forbidden characters
    const forbiddenPattern =
      /<|>|&|php|print_r|print|echo|script|sin|cos|tan|arcsin|arccos|arctan|&|%/i;
    if (forbiddenPattern.test(dividend) || forbiddenPattern.test(divisor)) {
      result.error = "Please Enter Valid Input.";
      return result;
    }

    // Process dividend
    let processedDividend = dividend
      .replace(/\s+/g, "")
      .replace(/%20/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    // Process divisor
    let processedDivisor = divisor
      .replace(/\s+/g, "")
      .replace(/%20/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    // Check variable consistency
    if (
      (divisor.includes("x") && dividend.includes("y")) ||
      (divisor.includes("y") && dividend.includes("x"))
    ) {
      result.error = "The divisor and dividend have different variables.";
      return result;
    }

    // Determine variable check
    let check = "";
    if (divisor.includes("x") && divisor.includes("y")) {
      check = "xy";
    } else if (divisor.includes("x") && !divisor.includes("y")) {
      check = "x";
    } else if (divisor.includes("y") && !divisor.includes("x")) {
      check = "y";
    }

    try {
      // Make API request
      const response = await axios.get("http://167.172.134.148/polynomial", {
        params: {
          eq: processedDividend,
          eq1: processedDivisor,
          check: check,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      // Basic results
      result.tech_check = check;
      result.tech_eq = buffer[0];
      result.tech_eq1 = buffer[1];
      result.tech_quot = buffer[2];
      result.tech_rmnd = buffer[3];

      if (check !== "xy") {
        // Additional results for non-xy cases
        const quotient = buffer[4].split("###").filter((item) => item);
        const multiplies = buffer[5].split("###").filter((item) => item);
        const steps = buffer[6].split("###").filter((item) => item);
        const divCoeff = buffer[7].split("###").filter((item) => item);
        const leading_term = buffer[9].split("###").filter((item) => item);

        result.tech_quotient = quotient;
        result.tech_multiplies = multiplies;
        result.tech_steps = steps;
        result.tech_divCoeff = divCoeff;
        result.tech_loop_len = buffer[8];
        result.tech_leading_term = leading_term;
        result.tech_divby_lt = buffer[10];
      }

      return result;
    } catch (error) {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /** getCalculationRadiusOfConvergenceCalculator
   * POST: /api/calculators-lol/radius-of-convergence-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRadiusOfConvergenceCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let wrt = body.tech_with;

    // Trim and validate input
    EnterEq = EnterEq?.trim();
    wrt = wrt?.trim();

    const invalidPattern = /[<>&=]|php|print_r|print|echo|script|%/i;

    if (!EnterEq || invalidPattern.test(EnterEq)) {
      return { error: "Please Enter Valid Input." };
    }

    if (!wrt) {
      return { error: "Please Enter Valid Input." };
    }

    // Clean and transform the equation
    let parem = EnterEq.replace(/ /g, "")
      .replace(/%20/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    let enter = parem;
    let upr = parem.replace(/n/g, "(nplus1)");
    parem = `(${upr})/(${parem})`;

    try {
      const response = await axios.get("http://167.172.134.148/radius", {
        params: {
          equ: parem,
          wrt,
          enter,
        },
        timeout: 120000,
      });

      if (!response || !response.data) {
        return { error: "Please! Check Your Input." };
      }

      let buffer = response.data.split("@@@");

      const result = {
        tech_enter: buffer[0],
        tech_ans: buffer[1],
        tech_equs: buffer[2],
        tech_shareURL: "", // optional: you can build shareURL here if needed
      };

      return result;
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationPowerSeriesCalculator
   * POST: /api/calculators-lol/power-series-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPowerSeriesCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let point = body.tech_point;
    let n = body.tech_n;
    let wrt = body.tech_with;

    EnterEq = EnterEq?.trim();
    point = point?.toString().trim();
    n = n?.toString().trim();
    wrt = wrt?.trim();

    const invalidPattern = /[<>&=]|php|print_r|print|echo|script|%/i;

    if (!EnterEq || invalidPattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    if (!wrt || isNaN(n) || isNaN(point)) {
      return { error: "Please! Check Your Input." };
    }

    // Clean and process EnterEq
    let parem = EnterEq.replace(/ /g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^x/g, "exp(x)")
      .replace(/e\^y/g, "exp(y)")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    try {
      const response = await axios.get("http://167.172.134.148/power_ser", {
        params: {
          equ: parem,
          wrt,
          how: n,
          point,
        },
        timeout: 120000,
      });

      if (!response || !response.data) {
        return { error: "Please! Check Your Input." };
      }

      const buffer = response.data.split("@@@");

      return {
        tech_ans: buffer[0],
        tech_enter: buffer[1],
      };
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationSimpsonRuleCalculator
   * POST: /api/calculators-lol/simpsons-rule-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationSimpsonRuleCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let lb = body.tech_lb;
    let ub = body.tech_ub;
    let n = body.tech_n;
    let wrt = body.tech_with;

    EnterEq = EnterEq?.toString().trim();
    lb = parseFloat(lb);
    ub = parseFloat(ub);
    n = parseInt(n);
    wrt = wrt?.toString().trim();

    const invalidPattern = /[<>&=]|php|print_r|print|echo|script|%/i;

    if (!EnterEq || invalidPattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    if (isNaN(lb) || isNaN(ub) || isNaN(n) || n % 2 !== 0) {
      return { error: "Number of rectangles should be even number." };
    }

    if (lb >= ub) {
      return { error: "The lower limit should be less than the upper limit." };
    }

    // Process equation
    let parem = EnterEq.replace(/ /g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    let diff = (ub - lb) / n;
    let final = lb;
    let limitArray = [lb];
    let limitString = `${lb}`;

    while (final < ub) {
      final = parseFloat((final + diff).toFixed(10)); // avoid floating point issues
      limitArray.push(final);
      limitString += `, ${final}`;
    }

    try {
      const response = await axios.get("http://167.172.134.148/simpsons", {
        params: {
          equ: parem,
          with: wrt,
          lb,
          ub,
          n,
          diff,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      const errorValue = Math.abs((buffer[4] - buffer[1]) / buffer[4]);
      const steps = buffer[0].split("HA");

      return {
        tech_steps: steps,
        tech_res: buffer[1],
        tech_enter: buffer[2],
        tech_int: buffer[3],
        tech_intv: buffer[4],
        tech_errorans: errorValue,
        tech_ub: ub,
        tech_lb: lb,
        tech_n: n,
        tech_diff: diff,
        tech_limit: limitString,
        tech_limit_a: limitArray,
        tech_with: wrt,
      };
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationCurlCalculator
   * POST: /api/calculators-lol/curl-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCurlCalculator(body) {
    let xeq = body.tech_xeq;
    let yeq = body.tech_yeq;
    let zeq = body.tech_zeq;
    let x = body.tech_x;
    let y = body.tech_y;
    let z = body.tech_z;

    xeq = xeq?.toString().trim();
    yeq = yeq?.toString().trim();
    zeq = zeq?.toString().trim();
    const invalidPattern = /[<>&=]|php|print_r|print|echo|script|%/i;

    if (
      !xeq ||
      !yeq ||
      !zeq ||
      invalidPattern.test(xeq) ||
      invalidPattern.test(yeq) ||
      invalidPattern.test(zeq)
    ) {
      return { error: "Please! Check Your Input." };
    }

    const sanitize = (eq) =>
      eq
        .replace(/ /g, "")
        .replace(/\+/g, "plus")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**");

    xeq = sanitize(xeq);
    yeq = sanitize(yeq);
    zeq = sanitize(zeq);

    const isPointProvided = !isNaN(x) && !isNaN(y) && !isNaN(z);

    try {
      const params = isPointProvided
        ? { xeq, yeq, zeq, x, y, z }
        : { xeq, yeq, zeq };

      const response = await axios.get("http://167.172.134.148/curl", {
        params,
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      const result = {
        tech_enx: buffer[0],
        tech_eny: buffer[1],
        tech_enz: buffer[2],
        tech_one: buffer[3],
        tech_two: buffer[4],
        tech_three: buffer[5],
        tech_four: buffer[6],
        tech_five: buffer[7],
        tech_six: buffer[8],
        tech_ans1: buffer[9],
        tech_ans2: buffer[10],
        tech_ans3: buffer[11],
      };

      if (isPointProvided) {
        result.tech_ev1 = buffer[12];
        result.tech_ev2 = buffer[13];
        result.tech_ev3 = buffer[14];
      }

      return result;
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }
  /** getCalculationSaddlePointCalculator
   * POST: /api/calculators-lol/saddle-point-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSaddlePointCalculator(body) {
    let EnterEq = body.tech_EnterEq;

    EnterEq = EnterEq?.toString().trim();
    const invalidPattern = /[<>&=]|php|print_r|print|echo|script|%/i;

    if (!EnterEq || invalidPattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    let parem = EnterEq.replace(/ /g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^x/g, "exp(x)")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    const wrt = "xy";

    try {
      const response = await axios.get("http://167.172.134.148/saddle", {
        params: {
          equ: parem,
          wrt: wrt,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      if (buffer[4] === "\\left[ \\right]") {
        return { error: "no solution exist." };
      }

      return {
        tech_buffer: buffer[0],
        tech_ans: buffer[1],
        tech_enter: buffer[2],
        tech_simple: buffer[3],
        tech_root: buffer[4],
        tech_step: buffer[5],
        tech_ans1: buffer[6],
        tech_step1: buffer[7],
        tech_step2: buffer[8],
        tech_en1: buffer[9],
        tech_en2: buffer[10],
        tech_wrt: "xy",
      };
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationImproperIntegralCalculator
   * POST: /api/calculators-lol/improper-integral-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationImproperIntegralCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let ub = body.tech_ub;
    let lb = body.tech_lb;
    let wrt = body.tech_with;

    EnterEq = EnterEq?.toString().trim();
    const invalidPattern = /[<>&=]|php|print_r|print|echo|script|%/i;

    if (!EnterEq || invalidPattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    if (!ub || !lb || !wrt) {
      return { error: "Please! Check Your Input." };
    }

    // Sanitize expression
    let parem = EnterEq.replace(/ /g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/xe\^/g, "x*e^")
      .replace(/ye\^/g, "y*e^")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    let upper = ub.replace(/\+/g, "plus").replace(/inf|∞/gi, "oo");
    let lower = lb.replace(/\+/g, "plus").replace(/inf|∞/gi, "oo");
    let wrtVar = wrt.trim();

    try {
      const response = await axios.get("http://167.172.134.148/improper", {
        params: {
          equ: parem,
          wrt: wrtVar,
          ub: upper,
          lb: lower,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      return {
        tech_enter: buffer[0],
        tech_int: buffer[1],
        tech_res: buffer[2],
        tech_ans: buffer[3],
        tech_first: buffer[4],
        tech_sec: buffer[5],
        tech_res1: buffer[6],
      };
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }
  /** getCalculationFourierSeriesCalculator
   * POST: /api/calculators-lol/fourier-series-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationFourierSeriesCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let ub = body.tech_ub;
    let lb = body.tech_lb;
    let wrt = body.tech_with;

    EnterEq = EnterEq?.toString().trim();
    const invalidPattern = /[<>&=]|php|print_r|print|echo|script|%/i;

    if (!EnterEq || invalidPattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    if (!ub || !lb || !wrt) {
      return { error: "Please! Check Your Input." };
    }

    // Clean equation
    let parem = EnterEq.replace(/ /g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/xe\^/g, "x*e^")
      .replace(/ye\^/g, "y*e^")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    // Bounds replacement
    let upper = ub.replace(/\+/g, "plus").replace(/inf|∞/gi, "oo");
    let lower = lb.replace(/\+/g, "plus").replace(/inf|∞/gi, "oo");
    let wrtVar = wrt.trim();

    try {
      const response = await axios.get("http://167.172.134.148/fourier", {
        params: {
          equ: parem,
          wrt: wrtVar,
          ub: upper,
          lb: lower,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      return {
        tech_enter: buffer[0],
        tech_a0: buffer[1],
        tech_an: buffer[2],
        tech_bn: buffer[3],
        tech_res: buffer[4],
        tech_t1: buffer[5],
        tech_t2: buffer[6],
        tech_t: buffer[7],
      };
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationDivergenceCalculator
   * POST: /api/calculators-lol/divergence-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDivergenceCalculator(body) {
    let xeq = body.tech_xeq;
    let yeq = body.tech_yeq;
    let zeq = body.tech_zeq;
    let x = body.tech_x;
    let y = body.tech_y;
    let z = body.tech_z;

    const invalidPattern = /[<>&=]|php|print_r|print|echo|script|%/i;

    // Validate inputs
    if (
      !xeq ||
      !yeq ||
      !zeq ||
      invalidPattern.test(xeq) ||
      invalidPattern.test(yeq) ||
      invalidPattern.test(zeq)
    ) {
      return { error: "Please! Check Your Input." };
    }

    const sanitize = (expr) =>
      expr
        .replace(/ /g, "")
        .replace(/\+/g, "plus")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/xe\^/g, "x*e^")
        .replace(/ye\^/g, "y*e^")
        .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**");

    xeq = sanitize(xeq);
    yeq = sanitize(yeq);
    zeq = sanitize(zeq);

    const isValidNumber = (val) => !isNaN(val) && val !== null && val !== "";

    const params = { xeq, yeq, zeq };

    if (isValidNumber(x) && isValidNumber(y) && isValidNumber(z)) {
      params.x = x;
      params.y = y;
      params.z = z;
    }

    try {
      const response = await axios.get("http://167.172.134.148/divergence", {
        params,
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");
      const result = {
        tech_enx: buffer[0],
        tech_eny: buffer[1],
        tech_enz: buffer[2],
        tech_one: buffer[3],
        tech_two: buffer[4],
        tech_three: buffer[5],
      };

      if (isValidNumber(x) && isValidNumber(y) && isValidNumber(z)) {
        result.tech_ev1 = buffer[6];
        result.tech_ev2 = buffer[7];
        result.tech_ev3 = buffer[8];
      }

      return result;
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }
  /** getCalculationLeastToGreatestCalculator
   * POST: /api/calculators-lol/least-to-greatest-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLeastToGreatestCalculator(body) {
    let x = body.tech_x;
    let order = body.tech_order;
    const result = {};

    // Input validation
    if (!x) {
      result.error = "Please! Check Your Input.";
      return result;
    }

    // Check for forbidden characters
    const forbiddenPattern =
      /<|>|&|php|print_r|print|echo|script|=|[a-zA-Z]|&/i;
    if (forbiddenPattern.test(x)) {
      result.error = "Please Enter Valid Input.";
      return result;
    }

    try {
      // Process input string
      const processedX = x.replace(/plus/g, "+");
      const input = processedX.split(",").map((item) => item.trim());

      const filter = {};
      const filter1 = {};

      for (const value of input) {
        let ans;
        const index = value;

        // Check for fractions
        const chech_frac = value.split("/");
        if (chech_frac.length > 1) {
          let up = chech_frac[0];
          const btm = parseFloat(chech_frac[1]);

          // Handle mixed numbers (e.g., "1 1/2")
          const check_up = up.split(" ");
          if (check_up.length > 1) {
            const sahi = parseFloat(check_up[0]);
            up = parseFloat(check_up[1]);

            // Handle negative mixed numbers
            if (sahi < 0 && up > 0) {
              up = up * -1;
            }

            ans = (btm * sahi + up) / btm;
          } else {
            ans = parseFloat(up) / btm;
          }
        } else {
          // Handle percentages and simple expressions
          const processedValue = value
            .replace(/%/g, "/100")
            .replace(/\s+/g, "+");

          // Use safe evaluation (in a real app, consider a more secure expression evaluator)
          ans = eval(processedValue);
        }

        // Validate the result
        if (isNaN(ans)) {
          result.error = "Please Enter Valid Input.";
          return result;
        }

        filter[index] = ans;
        filter1[ans.toString()] = index;
      }

      // Sort the results
      const sorted = { ...filter };
      const sortedArray = Object.entries(sorted);

      if (order === "1") {
        sortedArray.sort((a, b) => a[1] - b[1]);
      } else {
        sortedArray.sort((a, b) => b[1] - a[1]);
      }

      // Convert back to object
      const sortedResult = {};
      for (const [key, value] of sortedArray) {
        sortedResult[key] = value;
      }

      // Prepare response
      result.tech_solve = filter;
      result.tech_order = order;
      result.tech_ans = sortedResult;
      result.tech_filter1 = filter1;

      return result;
    } catch (error) {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /** getCalculationAngleOfElevationCalculator
   * POST: /api/calculators-lol/angle-of-elevation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationAngleOfElevationCalculator(body) {
    let to_cal = body.tech_to_cal;
    let vertical = body.tech_vertical;
    let vertical_unit = body.tech_vertical_unit;
    let hori = body.tech_hori;
    let hori_unit = body.tech_hori_unit;
    let angle = body.tech_angle;
    let angle_unit = body.tech_angle_unit;

    function unitToMeter(value, unit) {
      const conversion = {
        cm: 0.01,
        km: 1000,
        in: 0.0254,
        ft: 0.3048,
        yd: 0.9144,
        mi: 1609.3,
      };
      return value * (conversion[unit] || 1);
    }

    const param = {};

    try {
      if (to_cal === "1") {
        if (isFinite(vertical) && isFinite(hori)) {
          vertical = unitToMeter(Number(vertical), vertical_unit);
          hori = unitToMeter(Number(hori), hori_unit);
          const angleRad = Math.atan(vertical / hori);
          const ang_deg = (angleRad * 180) / Math.PI;
          const grade = vertical / hori;
          const gradep = grade * 100;

          param.tech_angle = angleRad;
          param.tech_ang_deg = ang_deg;
          param.tech_grade = grade;
          param.tech_gradep = gradep;
        } else {
          param.error = "Please! Check Your Input.";
        }
      } else if (to_cal === "2") {
        if (isFinite(angle) && isFinite(hori)) {
          hori = unitToMeter(Number(hori), hori_unit);
          const angleRad =
            angle_unit === "deg"
              ? (Number(angle) * Math.PI) / 180
              : Number(angle);
          const vertical = hori * Math.tan(angleRad);
          const grade = vertical / hori;
          const gradep = grade * 100;

          param.tech_vertical = vertical.toFixed(4) + " " + hori_unit;
          param.tech_grade = grade;
          param.tech_gradep = gradep;
        } else {
          param.error = "Please! Check Your Input.";
        }
      } else {
        if (isFinite(vertical) && isFinite(angle)) {
          vertical = unitToMeter(Number(vertical), vertical_unit);
          const angleRad =
            angle_unit === "deg"
              ? (Number(angle) * Math.PI) / 180
              : Number(angle);
          const hori = vertical / Math.tan(angleRad);
          const grade = vertical / hori;
          const gradep = grade * 100;

          param.tech_hori = hori.toFixed(4) + " " + vertical_unit;
          param.tech_grade = grade;
          param.tech_gradep = gradep;
        } else {
          param.error = "Please! Check Your Input.";
        }
      }
    } catch (e) {
      param.error = "An error occurred during calculation.";
    }

    return param;
  }

  /** getCalculationDilationCalculator
   * POST: /api/calculators-lol/dilation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDilationCalculator(body) {
    let nbr = body.tech_nbr;
    let dil = body.tech_dil;
    let a1 = body.tech_a1;
    let z1 = body.tech_z1;
    let a2 = body.tech_a2;
    let z2 = body.tech_z2;
    let a3 = body.tech_a3;
    let z3 = body.tech_z3;
    let a4 = body.tech_a4;
    let z4 = body.tech_z4;
    let a5 = body.tech_a5;
    let z5 = body.tech_z5;
    let a6 = body.tech_a6;
    let z6 = body.tech_z6;
    let a7 = body.tech_a7;
    let z7 = body.tech_z7;
    let a8 = body.tech_a8;
    let z8 = body.tech_z8;

    nbr = parseInt(nbr);
    dil = parseFloat(dil);

    const aValues = [a1, a2, a3, a4, a5, a6, a7, a8];
    const zValues = [z1, z2, z3, z4, z5, z6, z7, z8];
    const abc = ["A", "B", "C", "D", "E", "F", "G", "H"];

    const param = {};

    let checkInputs = true;

    for (let i = 0; i < nbr; i++) {
      const aVal = parseFloat(aValues[i]);
      const zVal = parseFloat(zValues[i]);

      if (!isFinite(aVal) || !isFinite(zVal)) {
        checkInputs = false;
        break;
      }
    }

    if (isFinite(dil) && checkInputs) {
      param.tech_aval = aValues;
      param.tech_zval = zValues;
      param.tech_abc = abc;
      param.tech_dil = dil;
    } else {
      param.error = "Please! Check Your Input.";
    }

    return param;
  }

  /** getCalculationPercentageIncreaseCalculator
   * POST: /api/calculators-lol/percentage-increase-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPercentageIncreaseCalculator(body) {
    let start = body.tech_start;
    let final = body.tech_final;

    start = parseFloat(start);
    final = parseFloat(final);

    const param = {};

    if (isFinite(start) && isFinite(final)) {
      let ans1 = (final - start) / Math.abs(start);
      let ans = ans1 * 100;
      let dif = final - start;

      param.tech_ans1 = parseFloat(ans1.toFixed(3));
      param.tech_ans = ans;
      param.tech_dif = dif;
    } else {
      param.error = "Please! Check Your Input.";
    }

    return param;
  }

  /** getCalculationPercentageDecreaseCalculator
   * POST: /api/calculators-lol/percentage-decrease-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPercentageDecreaseCalculator(body) {
    let start = body.tech_start;
    let final = body.tech_final;

    start = parseFloat(start);
    final = parseFloat(final);

    const param = {};

    if (isFinite(start) && isFinite(final)) {
      let ans = (final - start) / Math.abs(start);
      ans = ans * -100;
      let dif = final - start;

      param.tech_ans = ans;
      param.tech_dif = dif;
    } else {
      param.error = "Please! Check Your Input.";
    }

    return param;
  }

  /** getCalculationSphereCalculator
   * POST: /api/calculators-lol/sphere-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationSphereCalculator(body) {
    let slct1 = body.tech_slct1;
    let rad = body.tech_rad;
    let pi = body.tech_pi;

    let param = {};

    rad = parseFloat(rad);
    pi = parseFloat(pi);

    if (isFinite(rad) && isFinite(pi)) {
      let volume, surfacearea, circumference;
      let v1, c1, s1;

      if (slct1 === "1") {
        volume = (4 / 3) * pi * rad ** 3;
        surfacearea = pi * rad ** 2;
        circumference = 2 * pi * rad;
        v1 = (4 / 3) * rad ** 3;
        c1 = 2 * rad;
        s1 = c1 ** 2;
      } else if (slct1 === "2") {
        const originalVolume = rad; // input is volume
        rad = Math.cbrt((3 * originalVolume) / (4 * pi));
        volume = originalVolume;
        circumference = Math.pow(pi, 2 / 3) * Math.pow(6 * volume, 1 / 3);
        surfacearea = Math.pow(pi, 1 / 3) * Math.pow(6 * volume, 2 / 3);
        v1 = volume / pi;
        c1 = circumference / pi;
        s1 = surfacearea / pi;
      } else if (slct1 === "3") {
        const originalArea = rad; // input is surface area
        rad = Math.sqrt(originalArea / (4 * pi));
        surfacearea = originalArea;
        circumference = Math.sqrt(pi * surfacearea);
        volume = Math.pow(surfacearea, 1.5) / (6 * Math.sqrt(pi));
        v1 = volume / pi;
        c1 = circumference / pi;
        s1 = surfacearea / pi;
      } else if (slct1 === "4") {
        const originalCirc = rad; // input is circumference
        rad = originalCirc / (2 * pi);
        circumference = originalCirc;
        surfacearea = Math.pow(circumference, 2) / pi;
        volume = Math.pow(circumference, 3) / (6 * pi * pi);
        v1 = volume / pi;
        c1 = circumference / pi;
        s1 = surfacearea / pi;
      }

      param.tech_rad = +rad.toFixed(5);
      param.tech_vol = +volume.toFixed(5);
      param.tech_v1 = +v1.toFixed(5);
      param.tech_c1 = +c1.toFixed(5);
      param.tech_s1 = +s1.toFixed(5);
      param.tech_area = +surfacearea.toFixed(5);
      param.tech_c = +circumference.toFixed(5);
    } else {
      param.error = "Please! Check Your Input.";
    }

    return param;
  }

  /** getCalculationPercentageDifferenceCalculator
   * POST: /api/calculators-lol/percentage-difference-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPercentageDifferenceCalculator(body) {
    let start = parseFloat(body.tech_start);
    let final = parseFloat(body.tech_final);

    let param = {};

    if (isFinite(start) && isFinite(final)) {
      let ans = (Math.abs(start - final) / ((start + final) / 2)) * 100;
      let dif = final - start;

      param.tech_ans = ans;
      param.tech_dif = dif;
    } else {
      param.error = "Please! Check Your Input.";
    }

    return param;
  }

  /** getCalculationStandardFormtoSlopeInterceptFormCalculator
   * POST: /api/calculators-lol/standard-form-to-slope-intercept-form
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationStandardFormtoSlopeInterceptFormCalculator(body) {
    let a = body.tech_a;
    let b = body.tech_b;
    let c = body.tech_c;
    let to = body.tech_to;

    const result = {};

    // Helper functions
    function gcd(a, b) {
      a = Math.abs(a);
      b = Math.abs(b);

      if (a < b) {
        [b, a] = [a, b];
      }
      if (b === 0) {
        return 1;
      }
      let r = a % b;
      while (r > 0) {
        a = b;
        b = r;
        r = a % b;
      }
      return b;
    }

    function reduce(num, den) {
      const g = gcd(num, den);
      return [num / g, den / g];
    }

    function toFrac(num) {
      const numStr = num.toString();
      const parts = numStr.split(".");
      let div = "1";
      let count = 0;

      if (parts.length > 1) {
        count = parts[1].length;
      }

      for (let i = 1; i <= count; i++) {
        div += "0";
      }

      const divNum = parseInt(div);
      let upr;

      if (parts.length > 1) {
        upr = parseInt(parts[0] + parts[1]);
      } else {
        upr = parseInt(numStr);
      }

      return reduce(upr, divNum);
    }

    function lcmofn(numbers, n) {
      let ans = numbers[0];
      for (let i = 1; i < n; i++) {
        ans = (numbers[i] * ans) / gcd(numbers[i], ans);
      }
      return ans;
    }

    try {
      if (to == 1) {
        // Convert standard form to slope-intercept form
        let aNum = parseFloat(a);
        let bNum = parseFloat(b);
        let cNum = parseFloat(c);

        // Handle fractions
        const checkA = a.toString().split("/");
        if (checkA.length === 2) {
          aNum = parseFloat(checkA[0]) / parseFloat(checkA[1]);
        }

        const checkB = b.toString().split("/");
        if (checkB.length === 2) {
          bNum = parseFloat(checkB[0]) / parseFloat(checkB[1]);
        }

        const checkC = c.toString().split("/");
        if (checkC.length === 2) {
          cNum = parseFloat(checkC[0]) / parseFloat(checkC[1]);
        }

        if (isNaN(aNum) || isNaN(bNum) || isNaN(cNum) || bNum === 0) {
          result.error = "Please! Check Your Input.";
          return result;
        }

        const m = (-1 * aNum) / bNum;
        const nb = cNum / bNum;
        const angle =
          Math.round(Math.atan(m) * (180 / Math.PI) * 10000) / 10000;

        result.tech_m = Math.round(m * 100000) / 100000;
        result.tech_nb = Math.round(nb * 100000) / 100000;
        result.tech_angle = angle;
      } else {
        // Convert slope-intercept form to standard form
        let mNum = parseFloat(a);
        let cNum = parseFloat(b);

        // Handle fractions
        const checkA = a.toString().split("/");
        const checkB = b.toString().split("/");

        let upr, btm, upr1, btm1;
        let lcm;

        if (checkA.length === 1 && checkB.length === 1) {
          [upr, btm] = toFrac(mNum);
          [upr1, btm1] = toFrac(cNum);
          lcm = lcmofn([btm, btm1], 2);
        } else if (checkA.length === 2 && checkB.length === 1) {
          upr = parseFloat(checkA[0]);
          btm = parseFloat(checkA[1]);
          [upr1, btm1] = toFrac(cNum);
          lcm = lcmofn([btm, btm1], 2);
        } else if (checkA.length === 1 && checkB.length === 2) {
          [upr, btm] = toFrac(mNum);
          upr1 = parseFloat(checkB[0]);
          btm1 = parseFloat(checkB[1]);
          lcm = lcmofn([btm, btm1], 2);
        } else if (checkA.length === 2 && checkB.length === 2) {
          upr = parseFloat(checkA[0]);
          btm = parseFloat(checkA[1]);
          upr1 = parseFloat(checkB[0]);
          btm1 = parseFloat(checkB[1]);
          lcm = lcmofn([btm, btm1], 2);
        }

        const A = -1 * upr * (lcm / btm);
        const B = 1 * (lcm / btm1);
        const C = upr1 * (lcm / btm1);

        result.tech_A = A;
        result.tech_B = B;
        result.tech_C = C;
      }

      return result;
    } catch (error) {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /** getCalculationPolygonCalculator
   * POST: /api/calculators-lol/polygon-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPolygonCalculator(body) {
    let num1 = body.tech_operations;
    let num2 = body.tech_npolygon;
    let num3 = body.tech_calculation;
    let Label = body.tech_labl;
    let pie = body.tech_pie;
    let unit = body.tech_units;

    const result = {};

    if (isNaN(Label) || isNaN(pie)) {
      result.error = "Please Check Your Input";
      return result;
    }

    let nvalue = num1;

    if (nvalue == 15) {
      nvalue = num2;
      if (isNaN(nvalue) || nvalue <= 0) {
        result.error = "Enter number of polygon:";
        return result;
      }
    }

    let side_a, inradius, circumradius, area, perimeter, interior, extrior;

    try {
      const pieValue = parseFloat(pie);
      const labelValue = parseFloat(Label);
      const nvalueNum = parseFloat(nvalue);

      switch (num3) {
        case "01":
          const num01 = pieValue / nvalueNum;
          const co = 1 / Math.tan(num01);
          const res = 0.5 * labelValue;
          inradius = res * co;
          const se = 1 / Math.cos(num01);
          circumradius = inradius * se;
          const rr = inradius * inradius;
          const nr = nvalueNum * rr;
          const ta = Math.tan(num01);
          area = nr * ta;
          perimeter = nvalueNum * labelValue;
          const sub = nvalueNum - 2;
          const di = sub / nvalueNum;
          interior = di * 180;
          extrior = 360 / nvalueNum;
          side_a = labelValue;
          break;

        case "02":
          const a2 = Math.tan(pieValue / nvalueNum);
          const a0 = 2 * labelValue;
          side_a = a2 * a0;
          const r1 = 0.5 * side_a;
          const r2 = 1 / a2;
          inradius = r1 * r2;
          const R1 = 1 / Math.cos(pieValue / nvalueNum);
          circumradius = inradius * R1;
          const A1 = inradius * inradius;
          const A2 = nvalueNum * A1;
          area = A2 * a2;
          perimeter = nvalueNum * side_a;
          const sub2 = nvalueNum - 2;
          const di2 = sub2 / nvalueNum;
          interior = di2 * 180;
          extrior = 360 / nvalueNum;
          break;

        case "03":
          const Ra = 2 * labelValue;
          const Ra1 = Math.sin(pieValue / nvalueNum);
          side_a = Ra * Ra1;
          inradius = labelValue * Math.cos(pieValue / nvalueNum);
          const RR1 = 1 / Math.cos(pieValue / nvalueNum);
          circumradius = inradius * RR1;
          area =
            nvalueNum * Math.pow(inradius, 2) * Math.tan(pieValue / nvalueNum);
          perimeter = nvalueNum * side_a;
          const sub3 = nvalueNum - 2;
          const di3 = sub3 / nvalueNum;
          interior = di3 * 180;
          extrior = 360 / nvalueNum;
          break;

        case "04":
          nvalue = num1;
          const Aa1 = Math.tan(pieValue / nvalueNum);
          const Aa2 = 4 * Aa1 * labelValue;
          const Aa3 = Aa2 / nvalueNum;
          side_a = Math.sqrt(Aa3);
          const Ar1 = 1 / Math.tan(pieValue / nvalueNum);
          inradius = 0.5 * side_a * Ar1;
          const AR1 = 1 / Math.cos(pieValue / nvalueNum);
          circumradius = inradius * AR1;
          perimeter = nvalueNum * side_a;
          const sub4 = nvalueNum - 2;
          const di4 = sub4 / nvalueNum;
          interior = di4 * 180;
          extrior = 360 / nvalueNum;
          area = labelValue;
          break;

        case "05":
          side_a = labelValue / nvalueNum;
          const pr1 = 1 / Math.tan(pieValue / nvalueNum);
          inradius = 0.5 * side_a * pr1;
          const pR1 = 1 / Math.cos(pieValue / nvalueNum);
          circumradius = inradius * pR1;
          const pA1 = inradius * inradius;
          const pA2 = nvalueNum * pA1;
          const pA3 = Math.tan(pieValue / nvalueNum);
          area = pA2 * pA3;
          const sub5 = nvalueNum - 2;
          const di5 = sub5 / nvalueNum;
          interior = di5 * 180;
          extrior = 360 / nvalueNum;
          perimeter = labelValue;
          break;

        default:
          result.error = "Invalid calculation type";
          return result;
      }

      result.tech_nvalue = nvalue;
      result.tech_side_a = side_a;
      result.tech_inradius = inradius;
      result.tech_circumradius = circumradius;
      result.tech_area = area;
      result.tech_perimeter = perimeter;
      result.tech_interior = interior;
      result.tech_extrior = extrior;
      result.tech_unit = unit;

      return result;
    } catch (error) {
      result.error = "Please Check Your Input";
      return result;
    }
  }

  /** getCalculationGoldenRatioCalculator
   * POST: /api/calculators-lol/golden-ratio-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationGoldenRatioCalculator(body) {
    let selection = body.tech_selection;
    let a = body.tech_a;
    let value = 1.6180339887498;
    let param = {};

    a = parseFloat(a);

    if (isFinite(a)) {
      let longer_section, shorter_section, sum;

      if (selection === "1") {
        longer_section = a;
        shorter_section = a / value;
        sum = shorter_section + a;
      }

      if (selection === "2") {
        shorter_section = a;
        longer_section = value * a;
        sum = longer_section + a;
      }

      if (selection === "3") {
        sum = a;
        longer_section = a / value;
        shorter_section = longer_section / value;
      }

      param.tech_value = value;
      param.tech_a = +a.toFixed(5);
      param.tech_sum = +sum.toFixed(5);
      param.tech_longer_section = +longer_section.toFixed(5);
      param.tech_shorter_section = +shorter_section.toFixed(5);
    } else {
      param.error = "Please Check Your Input.";
    }

    return param;
  }

  /** getCalculationImproperFractionstoMixedNumbersCalculator
   * POST: /api/calculators-lol/improper-fractions-to-mixed-numbers
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationImproperFractionstoMixedNumbersCalculator(body) {
    let uper = body.tech_uper;
    let btm = body.tech_btm;
    let param = {};

    uper = parseFloat(uper);
    btm = parseFloat(btm);

    if (isFinite(uper) && isFinite(btm)) {
      if (uper >= btm) {
        let rem = uper % btm;
        let q = Math.floor(uper / btm);
        param.tech_q = q;
        param.tech_rem = rem;
      } else {
        param.RESULT = 1;
      }
    } else {
      param.error = "Please Check Your Input.";
    }

    return param;
  }

  /** getCalculationMixedNumberstoImproperFractionsCalculator
   * POST: /api/calculators-lol/mixed-numbers-to-improper-fractions
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMixedNumberstoImproperFractionsCalculator(body) {
    let whole = body.tech_whole;
    let uper = body.tech_uper;
    let btm = body.tech_btm;

    let param = {};

    whole = parseFloat(whole);
    uper = parseFloat(uper);
    btm = parseFloat(btm);

    if (isFinite(uper) && isFinite(btm) && isFinite(whole)) {
      let multi = btm * whole;
      let plus = multi + uper;

      param.tech_multi = multi;
      param.tech_plus = plus;
    } else {
      param.error = "Please Check Your Input.";
    }

    return param;
  }

  /** getCalculationLocalMaximaandMinimaCalculator
   * POST: /api/calculators-lol/local-maxima-and-minima-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLocalMaximaandMinimaCalculator(body) {
    let EnterEq = body.tech_equation;

    let param = {};

    // Input validation
    if (
      !EnterEq ||
      typeof EnterEq !== "string" ||
      /[<>&]|php|print_r|print|echo|script|=|%/i.test(EnterEq)
    ) {
      param.error = "Please! Check Your Input.";
      return param;
    }

    // Cleaning and transforming the equation
    let parem = EnterEq.replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^x/g, "exp(x)")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    try {
      let wrt = /y/i.test(parem) && /x/i.test(parem) ? "xy" : "x";

      const response = await axios.get("http://167.172.134.148/local", {
        params: {
          equ: parem,
          wrt: wrt,
        },
        timeout: 120000, // 120 seconds
      });

      const buffer = response.data.split("@@@");

      if (buffer[4] === "\\left[ \\right]") {
        param.error = "No solution exists";
        return param;
      }

      param.tech_buffer = buffer[0];
      param.tech_ans = buffer[1];
      param.tech_enter = buffer[2];
      param.tech_simple = buffer[3];
      param.tech_root = buffer[4];
      param.tech_fac = buffer[7];

      if (wrt === "xy") {
        param.tech_step = buffer[5];
        param.tech_ans1 = buffer[6];
        param.tech_wrt = "xy";
      } else {
        param.tech_mini = buffer[5];
        param.tech_maxi = buffer[6];
      }

      return param;
    } catch (err) {
      param.error = "Please! Check Your Input.";
      return param;
    }
  }

  /** getCalculationLCDCalculator
   * POST: /api/calculators-lol/lcd-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLCDCalculator(body) {
    let x = body.tech_x;
    const result = {};

    if (!x || typeof x !== "string") {
      result.error = "Please! Check Your Input.";
      return result;
    }

    x = x.trim();
    const input = x.split(",");
    const upper = [];
    const btm = [];
    let check = true;

    for (let value of input) {
      value = value.trim();
      const fraction_check = value.split("/");
      if (fraction_check.length === 2) {
        const mixed_check = fraction_check[0].trim().split(" ");
        if (mixed_check.length === 2) {
          const [whole, numerator] = mixed_check.map(Number);
          const denominator = parseFloat(fraction_check[1]);

          if (isNaN(whole) || isNaN(numerator) || isNaN(denominator)) {
            check = false;
            break;
          }

          const up = whole * denominator + numerator;
          upper.push(up);
          btm.push(denominator);
        } else if (mixed_check.length === 1) {
          const num = parseFloat(fraction_check[0]);
          const den = parseFloat(fraction_check[1]);
          if (isNaN(num) || isNaN(den)) {
            check = false;
            break;
          }
          upper.push(num);
          btm.push(den);
        } else {
          check = false;
          break;
        }
      } else if (fraction_check.length === 1) {
        const val = parseFloat(value);
        if (isNaN(val)) {
          check = false;
          break;
        }
        upper.push(val);
        btm.push(1);
      } else {
        check = false;
        break;
      }
    }

    if (!check) {
      result.error = "Please! Check Your Input.";
      return result;
    }

    // GCD function
    function gcd(a, b) {
      return b === 0 ? a : gcd(b, a % b);
    }

    // LCM of array
    function lcmOfArray(arr) {
      return arr.reduce((a, b) => (a * b) / gcd(a, b));
    }

    const lcm = lcmOfArray(btm);
    const multiple = btm.map((den) => lcm / den);

    result.tech_input = input;
    result.tech_upper = upper;
    result.tech_btm = btm;
    result.tech_multiple = multiple;
    result.tech_lcm = lcm;
    return result;
  }

  /** getCalculationUnitRateCalculator
   * POST: /api/calculators-lol/unit-rate-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationUnitRateCalculator(body) {
    let a = parseFloat(body.tech_a);
    let b = parseFloat(body.tech_b);
    let c = body.tech_c; // unused, but extracted for completeness
    let d = body.tech_d; // unused, but extracted for completeness

    const result = {};

    if (!isNaN(a) && !isNaN(b)) {
      if (b !== 0) {
        let ans = a / b;
        let ans2 = ans;
        let ans3 = ans;

        if (ans.toString().includes(".")) {
          ans = ans.toFixed(2);
          ans2 = ans2.toFixed(2);
          ans3 = ans3.toFixed(2);
        }

        result.tech_ans = ans;
        result.tech_ans2 = ans2;
        result.tech_ans3 = ans3;
      } else {
        result.error = "Denominator cannot be zero.";
      }
    } else {
      result.error = "Please! Check Your Input.";
    }

    return result;
  }

  /** getCalculationEquivalentFractionsCalculator
   * POST: /api/calculators-lol/equivalent-fractions-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationEquivalentFractionsCalculator(body) {
    let want_to = parseInt(body.tech_want_to);
    let is_frac = parseInt(body.tech_is_frac);
    let s1 = parseFloat(body.tech_s1);
    let n1 = parseFloat(body.tech_n1);
    let d1 = parseFloat(body.tech_d1);
    let s2 = parseFloat(body.tech_s2);
    let n2 = parseFloat(body.tech_n2);
    let d2 = parseFloat(body.tech_d2);
    let s3 = parseFloat(body.tech_s3);
    let n3 = parseFloat(body.tech_n3);
    let d3 = parseFloat(body.tech_d3);
    let no = parseInt(body.tech_no);

    const result = {};

    function gcd(a, b) {
      a = Math.abs(a);
      b = Math.abs(b);
      if (a < b) [a, b] = [b, a];
      if (b === 0) return 1;
      let r = a % b;
      while (r > 0) {
        a = b;
        b = r;
        r = a % b;
      }
      return b;
    }

    function reduce(num, den) {
      const g = gcd(num, den);
      return [num / g, den / g];
    }

    if (want_to === 1) {
      if (!isNaN(n1) && !isNaN(d1)) {
        let up;
        if (is_frac === 2 && !isNaN(s1)) {
          if (n1 < 0) {
            result.error = "Numerator and denominator must be positive";
            return result;
          }
          up = s1 < 1 ? d1 * s1 - n1 : d1 * s1 + n1;
        } else {
          up = n1;
        }

        if (no > 100) no = 100;

        let upper = [];
        let bottom = [];

        for (let i = 1; i <= no; i++) {
          upper.push(up * i);
          bottom.push(d1 * i);
        }

        result.tech_upper = upper;
        result.tech_bottom = bottom;
        return result;
      } else {
        result.error = "Please Check Your Input";
        return result;
      }
    } else {
      if (!isNaN(n2) && !isNaN(d2) && !isNaN(n3) && !isNaN(d3)) {
        let up1, up2, input1, input2;

        if (is_frac === 2 && !isNaN(s2)) {
          if (n2 < 0) {
            result.error = "Numerator and denominator must be positive";
            return result;
          }
          up1 = s2 < 1 ? d2 * s2 - n2 : d2 * s2 + n2;
          input1 = `${s2} ${n2}/${d2}`;
        } else {
          up1 = n2;
          input1 = `${n2}/${d2}`;
        }

        if (is_frac === 2 && !isNaN(s3)) {
          if (n3 < 0) {
            result.error = "Numerator and denominator must be positive";
            return result;
          }
          up2 = s3 < 1 ? d3 * s3 - n3 : d3 * s3 + n3;
          input2 = `${s3} ${n3}/${d3}`;
        } else {
          up2 = n3;
          input2 = `${n3}/${d3}`;
        }

        const [fupr, fbtm] = reduce(up1, d2);
        const [fupr1, fbtm1] = reduce(up2, d3);

        const same = fupr === fupr1 && fbtm === fbtm1 ? "yes" : "no";
        const sign = same === "yes" ? "=" : "≠";

        result.tech_same = same;
        result.tech_sign = sign;
        result.tech_input1 = input1;
        result.tech_input2 = input2;
        return result;
      } else {
        result.error = "Please Check Your Input";
        return result;
      }
    }
  }

  /** getCalculationComparingFractionsCalculator
   * POST: /api/calculators-lol/comparing-fractions-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationComparingFractionsCalculator(body) {
    let first = body.tech_first;
    let second = body.tech_second;

    const result = {};

    if (!first || !second) {
      result.error = "Please! Check Your Input.";
      return result;
    }

    function parseValue(value) {
      value = value.trim();
      if (value.includes("%")) {
        const num = parseFloat(value.replace("%", ""));
        if (!isNaN(num)) {
          return num / 100;
        } else {
          return null;
        }
      }

      const fracParts = value.split("/");
      if (fracParts.length === 2) {
        const mixedParts = fracParts[0].trim().split(" ");
        if (mixedParts.length === 2) {
          const [whole, numerator] = mixedParts.map(Number);
          const denominator = parseFloat(fracParts[1]);
          if (!isNaN(whole) && !isNaN(numerator) && !isNaN(denominator)) {
            return (whole * denominator + numerator) / denominator;
          } else {
            return null;
          }
        } else if (mixedParts.length === 1) {
          const numerator = parseFloat(fracParts[0]);
          const denominator = parseFloat(fracParts[1]);
          if (!isNaN(numerator) && !isNaN(denominator)) {
            return numerator / denominator;
          } else {
            return null;
          }
        } else {
          return null;
        }
      } else if (fracParts.length > 2) {
        return null;
      } else {
        const num = parseFloat(value);
        return !isNaN(num) ? num : null;
      }
    }

    const nbr1 = parseValue(first);
    const nbr2 = parseValue(second);

    if (nbr1 === null || nbr2 === null) {
      result.error = "Please Enter Valid Input.";
      return result;
    }

    let sign = "=";
    if (nbr1 > nbr2) sign = ">";
    else if (nbr1 < nbr2) sign = "<";

    result.tech_nbr1 = nbr1;
    result.tech_nbr2 = nbr2;
    result.tech_sign = sign;
    return result;
  }

  /** getCalculationTimetoDecimalCalculator
   * POST: /api/calculators-lol/time-to-decimal-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTimetoDecimalCalculator(body) {
    let hh = body.tech_hh;
    let mm = body.tech_mm;
    let ss = body.tech_ss;

    const result = {};

    if (
      (hh === undefined || hh === "") &&
      (mm === undefined || mm === "") &&
      (ss === undefined || ss === "")
    ) {
      result.error = "Please Check Your Input.";
      return result;
    }

    let hour = 0;
    let min = 0;
    let sec = 0;

    if (!isNaN(hh)) {
      hour = parseFloat(hh);
    }
    if (!isNaN(mm)) {
      min = parseFloat(mm);
    }
    if (!isNaN(ss)) {
      sec = parseFloat(ss);
    }

    let hours = hour + min / 60 + sec / 3600;
    let mins = hour * 60 + min + sec / 60;
    let secs = hour * 3600 + min * 60 + sec;

    result.tech_hour = hour.toString().padStart(2, "0");
    result.tech_min = min.toString().padStart(2, "0");
    result.tech_sec = sec.toString().padStart(2, "0");
    result.tech_hours = hours;
    result.tech_mins = mins;
    result.tech_secs = secs;

    return result;
  }

  /** getCalculationPercenttoDecimalCalculator
   * POST: /api/calculators-lol/percent-to-decimal-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPercenttoDecimalCalculator(body) {
    let per = body.tech_per;

    const result = {};

    if (!isNaN(per)) {
      let ans = parseFloat(per) / 100;
      result.tech_ans = ans;
    } else {
      result.error = "Please! Check Your Input.";
    }

    return result;
  }

  /** getCalculationDecimaltoPercentCalculator
   * POST: /api/calculators-lol/decimal-to-percent-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDecimaltoPercentCalculator(body) {
    let per = body.tech_per;

    const result = {};

    if (!isNaN(per)) {
      let ans = parseFloat(per) * 100;
      result.tech_ans = ans;
    } else {
      result.error = "Please! Check Your Input.";
    }

    return result;
  }

  /** getCalculationIntegerCalculator
   * POST: /api/calculators-lol/integer-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationIntegerCalculator(body) {
    let opr = body.tech_opr;
    let a = parseFloat(body.tech_a);
    let b = parseFloat(body.tech_b);

    const result = {};

    if (!isNaN(a) && !isNaN(b)) {
      let ansText = "";
      let ans = "";

      switch (parseInt(opr)) {
        case 1:
          ansText = "a + b = ?";
          ans = `${a} + ${b} = ${a + b}`;
          break;
        case 2:
          ansText = "a - b = ?";
          ans = `${a} - ${b} = ${a - b}`;
          break;
        case 3:
          ansText = "a x b = ?";
          ans = `${a} x ${b} = ${a * b}`;
          break;
        case 4:
          ansText = "a ÷ b = ?";
          ans = `${a} ÷ ${b} = ${b !== 0 ? (a / b).toFixed(5) : "Infinity"}`;
          break;
        case 5:
          ansText = `a<sup class="font-s-14">b</sup> = ?`;
          ans = `${a}<sup class="font-s-14">${b}</sup> = ${Math.pow(a, b)}`;
          break;
        case 6:
          ansText = `<sup class="font-s-14">${b}</sup>√a = ?`;
          ans = `<sup class="font-s-14">${b}</sup>√${a} = ${Math.pow(
            a,
            1 / b
          ).toFixed(5)}`;
          break;
        case 7:
          ansText = `log<sub class="font-s-14">${a}</sub>${b} = ?`;
          ans = `log<sub class="font-s-14">${a}</sub>${b} = ${
            Math.log(b) / Math.log(a)
          }`;
          break;
        default:
          result.error = "Invalid operation";
          return result;
      }

      result.tech_ansText = ansText;
      result.tech_ans = ans;
    } else {
      result.error = "Please! Check Your Input.";
    }

    return result;
  }

  /** getCalculationMultiplicativeInverseCalculator
   * POST: /api/calculators-lol/multiplicative-inverse-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMultiplicativeInverseCalculator(body) {
    let dec = body.tech_dec;
    let is_frac = parseInt(body.tech_is_frac);
    let s1 = parseFloat(body.tech_s1);
    let n1 = parseFloat(body.tech_n1);
    let d1 = parseFloat(body.tech_d1);

    let result = {};
    let check = true;
    let upr, btm;

    if (is_frac === 1) {
      if (!isNaN(dec)) {
        upr = parseFloat(dec);
        btm = 1;
      } else {
        check = false;
      }
    } else if (is_frac === 2) {
      if (!isNaN(n1) && !isNaN(d1)) {
        upr = n1;
        btm = d1;
      } else {
        check = false;
      }
    } else {
      if (!isNaN(s1) && !isNaN(n1) && !isNaN(d1)) {
        if (n1 < 0) {
          result.error = "Numerator and denominator must be positive.";
          return result;
        }
        upr = s1 < 1 ? d1 * s1 - n1 : d1 * s1 + n1;
        btm = d1;
      } else {
        check = false;
      }
    }

    if (check) {
      result.tech_ans = parseFloat((btm / upr).toFixed(8));
      result.tech_upr = upr;
      result.tech_btm = btm;
    } else {
      result.error = "Please Enter Valid Input.";
    }

    return result;
  }

  /** getCalculationInverseModuloCalculator
   * POST: /api/calculators-lol/inverse-modulo-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationInverseModuloCalculator(body) {
    let opr = body.tech_opr;
    let a = body.tech_a;
    let b = body.tech_b;

    a = Number(a);
    b = Number(b);
    opr = Number(opr);

    function xgcd(a, b) {
      let a1 = 1,
        b1 = 0,
        a2 = 0,
        b2 = 1;
      let aneg = 1,
        bneg = 1;
      let flag = false;
      let result = [];

      if (a < 0) {
        a = -a;
        aneg = -1;
      }
      if (b < 0) {
        b = -b;
        bneg = -1;
      }
      if (b > a) {
        [a, b] = [b, a];
        flag = true;
      }

      while (true) {
        let quot = Math.floor(a / b) * -1;
        a %= b;
        a1 += quot * a2;
        b1 += quot * b2;

        if (a === 0 && !flag) return [b * bneg, a2, b2];
        if (a === 0 && flag) return [b * bneg, b2, a2];

        quot = Math.floor(b / a) * -1;
        b %= a;
        a2 += quot * a1;
        b2 += quot * b1;

        if (b === 0 && !flag) return [a * aneg, a1, b1];
        if (b === 0 && flag) return [a * aneg, b1, a1];
      }
    }

    if (isFinite(a) && isFinite(b)) {
      let m = b;
      let res;

      if (opr === 1) {
        let [gcd, inv] = xgcd(a, m);
        if (Math.abs(gcd) === 1) {
          while (inv < 0) inv += m;
          res = inv;
        } else {
          res = "no";
        }
      } else if (opr === 2) {
        let res1 = -a,
          res2 = -a;
        while ((res1 < 0 || res1 >= m) && (res2 < 0 || res2 >= m)) {
          res1 += m;
          res2 -= m;
        }
        res = res1 >= 0 && res1 < m ? res1 : res2;
      }

      return {
        tech_res: res,
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /** getCalculationEquationLineCalculatorCalculator
   * POST: /api/calculators-lol/equation-of-a-line-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationEquationLineCalculatorCalculator(body) {
    let type = body.tech_type;
    let x1 = body.tech_x1;
    let x2 = body.tech_x2;
    let y1 = body.tech_y1;
    let y2 = body.tech_y2;
    let x3 = body.tech_x3;
    let y3 = body.tech_y3;

    let result = {};

    if (type === "2") {
      if (!isNaN(x1) && !isNaN(x2) && !isNaN(y1) && !isNaN(y2)) {
        let x = x2 - x1;
        let y = y2 - y1;
        let slope = +(y / x).toFixed(4);
        let angle = +(Math.atan(slope) * (180 / Math.PI)).toFixed(4);
        let distance = +Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)).toFixed(4);
        let b = +(y1 - slope * x1).toFixed(2);

        result = {
          tech_type: type,
          tech_x: x,
          tech_y: y,
          tech_b: b,
          tech_slope: slope,
          tech_angle: `${angle} deg`,
          tech_distance: distance,
        };
      } else {
        return { error: "Please Check Your Input." };
      }
    } else if (type === "1") {
      let slope = x2;
      if (!isNaN(x1) && !isNaN(y1) && !isNaN(slope)) {
        let angle = +(Math.atan(slope) * (180 / Math.PI)).toFixed(4);
        let b = +(y1 - slope * x1).toFixed(4);

        result = {
          tech_type: type,
          tech_b: b,
          tech_slope: slope,
          tech_angle: `${angle} deg`,
        };
      } else {
        return { error: "Please Check Your Input." };
      }
    } else if (type === "3") {
      let b = x1;
      let slope = x2;
      if (!isNaN(b) && !isNaN(slope)) {
        let angle = +(Math.atan(slope) * (180 / Math.PI)).toFixed(4);

        result = {
          tech_type: type,
          tech_b: b,
          tech_slope: slope,
          tech_angle: `${angle} deg`,
        };
      } else {
        return { error: "Please Check Your Input." };
      }
    } else if (type === "4") {
      if (
        !isNaN(x1) &&
        !isNaN(x2) &&
        !isNaN(y1) &&
        !isNaN(y2) &&
        !isNaN(x3) &&
        !isNaN(y3)
      ) {
        let f_down = y1 - x1;
        let s_down = y2 - x2;
        let t_down = y3 - x3;

        result = {
          tech_type: type,
          tech_f_down: f_down,
          tech_s_down: s_down,
          tech_t_down: t_down,
        };
      } else {
        return { error: "Please Check Your Input." };
      }
    }

    return result;
  }

  /** getCalculationFractionExponentCalculator
   * POST: /api/calculators-lol/fraction-exponent-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationFractionExponentCalculator(body) {
    let x = body.tech_x;
    let n = body.tech_n;
    let d = body.tech_d;

    let result = {};

    if (!isNaN(x) && !isNaN(n) && !isNaN(d)) {
      if (d != 0) {
        if (Number.isInteger(n)) {
          let all_roots = [];
          let answer, a, ans_f;

          if (x >= 0) {
            a = Math.pow(x, n);
            ans_f = n / d;
            answer = Math.pow(x, ans_f);

            let z = x;
            let r_f = Math.pow(x, 2);
            let r = Math.sqrt(r_f);
            let theta = 0;
            let power = 1 / d;
            let r_pow = Math.pow(r, power);

            if (d < 0) d = -1 * d;

            for (let i = 0; i < d; i++) {
              let f_step = 2 * 180 * i;
              let uper_fstep = theta + f_step;
              let f_ans2 = uper_fstep / d;
              let cos_fans2 = Math.cos(f_ans2 * (Math.PI / 180));
              let sin_fans2 = Math.sin(f_ans2 * (Math.PI / 180));
              let cos_fans = +(r_pow * cos_fans2).toFixed(6);
              let sin_fans = +(r_pow * sin_fans2).toFixed(6);
              if (sin_fans < 0) {
                sin_fans = -sin_fans;
                all_roots.push(`${cos_fans}-${sin_fans}i`);
              } else {
                all_roots.push(`${cos_fans}+${sin_fans}i`);
              }
            }
          } else {
            x = -1 * x;
            a = Math.pow(x, n);
            ans_f = n / d;
            answer = Math.pow(x, ans_f) + "i";

            let z = x;
            let r_f = Math.pow(x, 2);
            let r = Math.sqrt(r_f);
            let theta = 0;
            let power = 1 / d;
            let r_pow = Math.pow(r, power);

            for (let i = 0; i < d; i++) {
              let f_step = 2 * 180 * i;
              let uper_fstep = theta + f_step;
              let f_ans2 = uper_fstep / d;
              let cos_fans2 = Math.cos(f_ans2 * (Math.PI / 180));
              let sin_fans2 = Math.sin(f_ans2 * (Math.PI / 180));
              let cos_fans = +(r_pow * cos_fans2).toFixed(6);
              let sin_fans = +(r_pow * sin_fans2).toFixed(6);
              if (sin_fans < 0) {
                sin_fans = -sin_fans;
                all_roots.push(`${cos_fans}-${sin_fans}i`);
              } else {
                all_roots.push(`${cos_fans}+${sin_fans}i`);
              }
            }
          }

          result = {
            tech_all_roots: all_roots,
            tech_a: a,
            tech_ans_f: ans_f,
            tech_answer: answer,
          };
        } else {
          return { error: "Use only integers for the Numerator." };
        }
      } else {
        return { error: "Enter a non-zero Denominator." };
      }
    } else {
      return { error: "Please! Check Your Input." };
    }

    return result;
  }

  /** getCalculationAmplitudeAndPeriodCalculator
   * POST: /api/calculators-lol/amplitude-and-period-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAmplitudeAndPeriodCalculator(body) {
    let trigonometric_unit = body.tech_trigonometric_unit;
    let first_number = body.tech_first_number;
    let second_number = body.tech_second_number;
    let third_number = body.tech_third_number;
    let fourth_number = body.tech_fourth_number;

    let result = {};

    if (
      !isNaN(first_number) &&
      !isNaN(second_number) &&
      !isNaN(third_number) &&
      !isNaN(fourth_number)
    ) {
      if (first_number == 0) {
        return { error: "For A=0, this is not a trigonometric function!" };
      } else if (second_number == 0) {
        return { error: "For B=0, this is not a trigonometric function!" };
      } else {
        result.first_number = first_number;
        result.second_number = 2 / second_number;
        result.third_number = third_number / second_number;
        result.fourth_number = fourth_number;
        result.fifth_number = second_number;
        result.sixth_number = third_number;
        result.operation = trigonometric_unit;
        return result;
      }
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationExponentialGrowthCalculator
   * POST: /api/calculators-lol/exponential-growth-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationExponentialGrowthCalculator(body) {
    let operations = body.tech_operations;
    let first = body.tech_first;
    let second = body.tech_second;
    let third = body.tech_third;
    let four = body.tech_four;
    let t_unit = body.tech_t_unit;

    let result = {};

    function timer(unit, value) {
      switch (unit) {
        case "sec":
          return value / 31540000;
        case "min":
          return value / 525600;
        case "hr":
          return value / 8760;
        case "days":
          return value / 365;
        case "wks":
          return value / 52.143;
        case "mon":
          return value / 12;
        default:
          return value;
      }
    }

    third = timer(t_unit, third);
    let final, jawab;

    if (operations === "1") {
      if (!isNaN(second) && !isNaN(third) && !isNaN(four)) {
        let divide = second / 100;
        let plus = 1 + divide;
        let power = Math.pow(plus, third);
        final = four / power;
        final = final.toFixed(4);
        jawab = "Initial Value (x₀)";
      } else {
        return { error: "Please! Check Your Input." };
      }
    } else if (operations === "2") {
      if (!isNaN(first) && !isNaN(third) && !isNaN(four)) {
        let divide1 = four / first;
        let log_div1 = Math.log(divide1);
        let divide2 = log_div1 / third;
        let antilog = Math.exp(divide2);
        let minus = antilog - 1;
        final = minus * 100;
        final = final.toFixed(4);
        jawab = "Rate of Change (r)";
      } else {
        return { error: "Please! Check Your Input." };
      }
    } else if (operations === "3") {
      if (!isNaN(first) && !isNaN(second) && !isNaN(four)) {
        let divide = four / first;
        let divide2 = second / 100;
        let plus = 1 + divide2;
        let log1 = Math.log(plus);
        let log2 = Math.log(divide);
        final = log2 / log1;
        final = final.toFixed(4);
        jawab = "Elapsed Time (t)";
      } else {
        return { error: "Please! Check Your Input." };
      }
    } else if (operations === "4") {
      if (!isNaN(first) && !isNaN(second) && !isNaN(third)) {
        let divide = second / 100;
        let plus = 1 + divide;
        let power = Math.pow(plus, third);
        final = first * power;
        final = final.toFixed(4);
        jawab = "Final Value x(t)";
      } else {
        return { error: "Please! Check Your Input." };
      }
    }

    result.final = final;
    result.operations = operations;
    result.jawab = jawab;
    return result;
  }

  /** getCalculationPerfectSquareTrinomialCalculator
   * POST: /api/calculators-lol/perfect-square-trinomial-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPerfectSquareTrinomialCalculator(body) {
    let A = body.tech_A;
    let B = body.tech_B;
    let C = body.tech_C;

    let result = {};

    if (!isNaN(A) && !isNaN(B) && !isNaN(C)) {
      let ds = Math.pow(B, 2) - 4 * A * C;
      result.tech_sd = ds;
      return result;
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationPowerReducingFormulaCalculator
   * POST: /api/calculators-lol/power-reducing-formula-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPowerReducingFormulaCalculator(body) {
    let know = body.tech_know;
    let angle = body.tech_angle;
    let angle_unit = body.tech_angle_unit;
    let sinx = body.tech_sinx;
    let cosx = body.tech_cosx;
    let tanx = body.tech_tanx;
    let sin2x = body.tech_sin2x;
    let cos2x = body.tech_cos2x;
    let tan2x = body.tech_tan2x;

    let result = {};

    function degToRad(deg) {
      return (deg * Math.PI) / 180;
    }

    function radToDeg(rad) {
      return (rad * 180) / Math.PI;
    }

    if (know == 1) {
      if (!isNaN(angle)) {
        if (angle_unit === "rad") {
          angle = radToDeg(angle);
        }

        let sin = Math.sin(degToRad(angle));
        let cos = Math.cos(degToRad(angle));
        let tan =
          angle == 90 || angle == 270 ? Infinity : Math.tan(degToRad(angle));
        let sin2 = (1 - Math.cos(2 * degToRad(angle))) / 2;
        let cos2 = (1 + Math.cos(2 * degToRad(angle))) / 2;
        let tan2 = sin2 / cos2;
        let sin3 = (3 * sin - Math.sin(3 * degToRad(angle))) / 4;
        let cos3 = (1 / 4) * Math.cos(3 * degToRad(angle)) + (3 / 4) * cos;
        let tan3 = sin3 / cos3;
        let sin4 =
          (3 -
            4 * Math.cos(2 * degToRad(angle)) +
            Math.cos(4 * degToRad(angle))) /
          8;
        let cos4 =
          (3 +
            4 * Math.cos(2 * degToRad(angle)) +
            Math.cos(4 * degToRad(angle))) /
          8;
        let tan4 = sin4 / cos4;

        Object.assign(result, {
          tech_sin: sin,
          tech_cos: cos,
          tech_tan: tan,
          tech_sin2: sin2,
          tech_cos2: cos2,
          tech_tan2: tan2,
          tech_sin3: sin3,
          tech_cos3: cos3,
          tech_tan3: tan3,
          tech_sin4: sin4,
          tech_cos4: cos4,
          tech_tan4: tan4,
        });

        return result;
      } else {
        return { error: "Please Check Your Input." };
      }
    } else if (know == 2) {
      if (!isNaN(sinx) && !cosx && !tanx && !sin2x && !cos2x && !tan2x) {
        angle = Math.asin(sinx);
      } else if (!sinx && !isNaN(cosx) && !tanx && !sin2x && !cos2x && !tan2x) {
        angle = Math.acos(cosx);
      } else if (!sinx && !cosx && !isNaN(tanx) && !sin2x && !cos2x && !tan2x) {
        angle = Math.atan(tanx);
      } else if (!sinx && !cosx && !tanx && !isNaN(sin2x) && !cos2x && !tan2x) {
        angle = Math.asin(Math.sqrt(sin2x));
      } else if (!sinx && !cosx && !tanx && !sin2x && !isNaN(cos2x) && !tan2x) {
        angle = Math.acos(Math.sqrt(cos2x));
      } else if (!sinx && !cosx && !tanx && !sin2x && !cos2x && !isNaN(tan2x)) {
        angle = Math.atan(Math.sqrt(tan2x));
      } else {
        return { error: "Please Enter any one of the known function values." };
      }

      angle = radToDeg(angle);

      let sin = Math.sin(degToRad(angle));
      let cos = Math.cos(degToRad(angle));
      let tan =
        angle == 90 || angle == 270 ? Infinity : Math.tan(degToRad(angle));
      let sin2 = (1 - Math.cos(2 * degToRad(angle))) / 2;
      let cos2 = (1 + Math.cos(2 * degToRad(angle))) / 2;
      let tan2 = sin2 / cos2;
      let sin3 = (3 * sin - Math.sin(3 * degToRad(angle))) / 4;
      let cos3 = (1 / 4) * Math.cos(3 * degToRad(angle)) + (3 / 4) * cos;
      let tan3 = sin3 / cos3;
      let sin4 =
        (3 -
          4 * Math.cos(2 * degToRad(angle)) +
          Math.cos(4 * degToRad(angle))) /
        8;
      let cos4 =
        (3 +
          4 * Math.cos(2 * degToRad(angle)) +
          Math.cos(4 * degToRad(angle))) /
        8;
      let tan4 = sin4 / cos4;

      Object.assign(result, {
        tech_angle: angle,
        tech_sin: sin,
        tech_cos: cos,
        tech_tan: tan,
        tech_sin2: sin2,
        tech_cos2: cos2,
        tech_tan2: tan2,
        tech_sin3: sin3,
        tech_cos3: cos3,
        tech_tan3: tan3,
        tech_sin4: sin4,
        tech_cos4: cos4,
        tech_tan4: tan4,
      });

      return result;
    }
  }

  /** getCalculationDiamondCalculator
   * POST: /api/calculators-lol/diamond-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDiamondCalculator(body) {
    let factor_a = parseFloat(body.tech_factor_a);
    let factor_b = parseFloat(body.tech_factor_b);
    let product = parseFloat(body.tech_product);
    let sum = parseFloat(body.tech_sum);

    let result = {};
    let facta, factb, pro, su, met;

    if (!isNaN(factor_a) && !isNaN(factor_b) && isNaN(product) && isNaN(sum)) {
      facta = factor_a;
      factb = factor_b;
      pro = factor_a * factor_b;
      su = factor_a + factor_b;
      met = 1;
    } else if (
      !isNaN(factor_a) &&
      !isNaN(product) &&
      isNaN(factor_b) &&
      isNaN(sum)
    ) {
      facta = factor_a;
      factb = parseFloat((product / factor_a).toFixed(3));
      pro = product;
      su = facta + factb;
      met = 2;
    } else if (
      !isNaN(factor_a) &&
      !isNaN(sum) &&
      isNaN(factor_b) &&
      isNaN(product)
    ) {
      facta = factor_a;
      factb = sum - factor_a;
      su = sum;
      pro = facta * factb;
      met = 3;
    } else if (
      !isNaN(factor_b) &&
      !isNaN(product) &&
      isNaN(factor_a) &&
      isNaN(sum)
    ) {
      factb = factor_b;
      facta = parseFloat((product / factor_b).toFixed(2));
      pro = product;
      su = facta + factb;
      met = 4;
    } else if (
      !isNaN(factor_b) &&
      !isNaN(sum) &&
      isNaN(factor_a) &&
      isNaN(product)
    ) {
      factb = factor_b;
      facta = sum - factor_b;
      su = sum;
      pro = facta * factor_b;
      met = 5;
    } else if (
      !isNaN(product) &&
      !isNaN(sum) &&
      isNaN(factor_a) &&
      isNaN(factor_b)
    ) {
      let found = false;
      for (let i = 1; i * i <= product; i++) {
        if (product % i === 0) {
          let j = product / i;
          if (i + j === sum) {
            facta = i;
            factb = j;
            pro = product;
            su = sum;
            met = 6;
            found = true;
            break;
          }
        }
      }
      if (!found) {
        return {
          error: `Cannot find two factors of ${product} that sum equal to ${sum}`,
        };
      }
    } else {
      return { error: "Please! Enter any two values." };
    }

    result.tech_facta = facta;
    result.tech_factb = factb;
    result.tech_pro = pro;
    result.tech_su = su;
    result.tech_met = met;

    return result;
  }

  /** getCalculationCrossMultiplyCalculator
   * POST: /api/calculators-lol/cross-multiply-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCrossMultiplyCalculator(body) {
    let a = parseFloat(body.tech_a);
    let b = parseFloat(body.tech_b);
    let c = parseFloat(body.tech_c);
    let d = parseFloat(body.tech_d);

    let result = {};

    const isA = !isNaN(a);
    const isB = !isNaN(b);
    const isC = !isNaN(c);
    const isD = !isNaN(d);

    const totalInputs = [isA, isB, isC, isD].filter(Boolean).length;

    if (totalInputs === 4) {
      result.error = "Please Enter 3 numbers & leave 1 field empty!";
      return result;
    }

    if (!isA && isB && isC && isD) {
      result.tech_a_val = (b * c) / d;
    } else if (isA && !isB && isC && isD) {
      result.tech_b_val = (a * d) / c;
    } else if (isA && isB && !isC && isD) {
      result.tech_c_val = (a * d) / b;
    } else if (isA && isB && isC && !isD) {
      result.tech_d_val = (b * c) / a;
    } else {
      result.error = "Please! Check Your Input.";
      return result;
    }

    return result;
  }

  /** getCalculationAreaSemicircleCalculator
   * POST: /api/calculators-lol/area-of-a-semicircle
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAreaSemicircleCalculator(body) {
    let radius = parseFloat(body.tech_radius);
    let selection = body.tech_selection;
    let pi = parseFloat(body.tech_pi);
    let units = body.tech_units;

    function convertToCm(unit, val) {
      if (unit === "cm") return val;
      if (unit === "m") return val * 100;
      if (unit === "in") return val * 2.54;
      if (unit === "ft") return val * 30.48;
      if (unit === "yd") return val * 91.44;
      return NaN;
    }

    let result = {};

    let rad, per, da, ac, a;

    if (
      ["1", "2", "3", "4", "6"].includes(selection) &&
      !isNaN(radius) &&
      !isNaN(pi) &&
      radius > 0
    ) {
      let ans = convertToCm(units, radius);

      switch (selection) {
        case "1": // Given Radius
          rad = ans;
          da = rad * 2;
          a = (pi * rad * rad) / 2;
          per = pi * rad + 2 * rad;
          ac = 3.14 * rad;
          break;

        case "2": // Given Diameter
          da = ans;
          rad = da / 2;
          ac = rad * 3.14;
          per = pi * rad + 2 * rad;
          a = (pi * rad * rad) / 2;
          break;

        case "3": // Given Arc Length
          ac = ans;
          rad = ac / pi;
          da = rad * 2;
          per = pi * rad + 2 * rad;
          a = (pi * rad * rad) / 2;
          break;

        case "4": // Given Perimeter
          per = ans;
          rad = per / (pi + 2);
          da = rad * 2;
          ac = rad * pi;
          a = (pi * rad * rad) / 2;
          break;

        case "6": // Given Area
          a = ans;
          rad = Math.sqrt((2 * a) / pi);
          da = rad * 2;
          ac = rad * 3.14;
          per = pi * rad + 2 * rad;
          break;
      }

      result.tech_radius = parseFloat(rad.toFixed(3));
      result.tech_perimeter = parseFloat(per.toFixed(3));
      result.tech_diameter = parseFloat(da.toFixed(3));
      result.tech_arc_length = parseFloat(ac.toFixed(3));
      result.tech_area = parseFloat(a.toFixed(3));
      result.tech_unit = units;
      result.tech_pi = pi;
      result.tech_selection = selection;
      return result;
    } else {
      return { error: "Please! Check Your Input.111" };
    }
  }

  /** getCalculationAreaDegreeandLeadingCoefficientCalculator
   * POST: /api/calculators-lol/degree-and-leading-coefficient
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAreaDegreeandLeadingCoefficientCalculator(body) {
    let equ = body.tech_equ;
    let vari = body.tech_vari;

    let range = [..."abcdefghijklmnopqrstuvwxyz"];

    if (equ && range.includes(vari.toLowerCase())) {
      let input = equ;
      input = input.replace(/ /g, "");
      input = input.replace(/\+/g, "plus");
      input = input.replace(/{/g, "(");
      input = input.replace(/}/g, ")");
      input = input.replace(/xe\^/g, "x*e^");
      input = input.replace(/ye\^/g, "y*e^");
      input = input.replace(/e\^/g, "exp");
      input = input.replace(/exp\^/g, "exp");
      input = input.replace(/\^/g, "**");
      input = input.replace(/e\^sqrt\(x\)/g, "exp(2*x)");

      try {
        const response = await axios.post(
          "http://167.172.134.148/degree",
          new URLSearchParams({ equ: input }),
          {
            timeout: 120000,
          }
        );

        let buffer = response.data;
        input = buffer[1];

        let jawab = buffer[0]
          .trim()
          .replace(/\\left\(/g, "")
          .replace(/\\right\)/g, "")
          .replace(/\\/g, "");

        let parts = jawab.split(",");
        let final = {};

        for (let value of parts) {
          if (value.toLowerCase().includes(vari.toLowerCase())) {
            let index = value.split(vari);
            if (index.length === 2) {
              let keyx = index[0].replace(/ /g, "");
              let valuex = index[1].replace(/[\^{\} ]/g, "");
              if (!valuex && !isNaN(keyx)) {
                final[keyx] = 1;
              } else if (!isNaN(keyx) && !isNaN(valuex)) {
                final[keyx] = parseFloat(valuex);
              }
            }
          }
        }

        if (Object.keys(final).length === 0) {
          return {
            status: "error",
            error: "Please! Check Your Input.",
          };
        } else {
          let degree = Math.max(...Object.values(final));
          let lead = Object.keys(final).find((key) => final[key] === degree);

          return {
            tech_status: "success",
            tech_input: input,
            tech_lead: lead,
            tech_degree: degree,
          };
        }
      } catch (err) {
        return {
          status: "error",
          error: "Please! Check Your Input.",
        };
      }
    } else {
      return {
        status: "error",
        error: "Please! Check Your Input.",
      };
    }
  }

  /** getCalculationEquivalentExpressionsCalculator
   * POST: /api/calculators-lol/equivalent-expressions-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationEquivalentExpressionsCalculator(body) {
    let equ = body.tech_equ;

    if (equ) {
      let input = equ;

      input = input.replace(/ /g, "");
      input = input.replace(/\+/g, "plus");
      input = input.replace(/{/g, "(");
      input = input.replace(/}/g, ")");
      input = input.replace(/xe\^/g, "x*e^");
      input = input.replace(/ye\^/g, "y*e^");
      input = input.replace(/e\^/g, "exp");
      input = input.replace(/exp\^/g, "exp");
      input = input.replace(/\^/g, "**");
      input = input.replace(/e\^sqrt\(x\)/g, "exp(2*x)");

      try {
        const response = await axios.post(
          "http://167.172.134.148/equ_exp",
          new URLSearchParams({ equ: input }),
          {
            timeout: 120000,
          }
        );

        let buffer = response.data;

        return {
          tech_status: "success",
          tech_ans: buffer[1],
        };
      } catch (err) {
        return {
          status: "error",
          error: "Please! Check Your Input.",
        };
      }
    } else {
      return {
        status: "error",
        error: "Please! Check Your Input.",
      };
    }
  }

  /** getCalculationDescartesRuleSignsCalculator
   * POST: /api/calculators-lol/descartes-rule-of-signs-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDescartesRuleSignsCalculator(body) {
    let equ = body.tech_equ;
    let vari = body.tech_vari;

    let range = [..."abcdefghijklmnopqrstuvwxyz"];

    if (equ && range.includes(vari.toLowerCase())) {
      let input = equ;

      input = input.replace(/ /g, "");
      input = input.replace(/\+/g, "plus");
      input = input.replace(/{/g, "(");
      input = input.replace(/}/g, ")");
      input = input.replace(/xe\^/g, "x*e^");
      input = input.replace(/ye\^/g, "y*e^");
      input = input.replace(/e\^/g, "exp");
      input = input.replace(/exp\^/g, "exp");
      input = input.replace(/\^/g, "**");
      input = input.replace(/e\^sqrt\(x\)/g, "exp(2*x)");

      let input1 = input.replace(new RegExp(vari, "g"), `(-${vari})`);

      try {
        const response = await axios.post(
          "http://167.172.134.148/descartes",
          new URLSearchParams({
            equ: input,
            equ1: input1,
            wrt: vari,
          }),
          { timeout: 120000 }
        );

        let buffer = response.data;
        let cof1 = buffer[2].split(",").filter((v) => v.trim() !== "");
        let cof2 = buffer[3].split(",").filter((v) => v.trim() !== "");

        let sign1 = [];
        for (let value of cof1) {
          let num = parseFloat(value.trim());
          if (!isNaN(num)) {
            sign1.push(num < 0 ? "-" : "+");
          } else {
            return {
              status: "error",
              error: "Please! Enter Univariate Polynomial",
            };
          }
        }

        let sign2 = [];
        for (let value of cof2) {
          let num = parseFloat(value.trim());
          if (!isNaN(num)) {
            sign2.push(num < 0 ? "-" : "+");
          } else {
            return {
              status: "error",
              error: "Please! Enter Univariate Polynomial",
            };
          }
        }

        let positive = 0;
        for (let i = 0; i < sign1.length - 1; i++) {
          if (sign1[i] !== sign1[i + 1]) {
            positive++;
          }
        }

        let negative = 0;
        for (let i = 0; i < sign2.length - 1; i++) {
          if (sign2[i] !== sign2[i + 1]) {
            negative++;
          }
        }

        return {
          tech_status: "success",
          tech_input1: buffer[0],
          tech_input2: buffer[1],
          tech_positive: positive,
          tech_negative: negative,
          tech_cof1: cof1,
          tech_cof2: cof2,
        };
      } catch (err) {
        return {
          status: "error",
          error: "Please! Check Your Input.",
        };
      }
    } else {
      return {
        status: "error",
        error: "Please Check Your Input!",
      };
    }
  }

  /** getCalculationFunctionOperationsCalculator
   * POST: /api/calculators-lol/function-operations-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationFunctionOperationsCalculator(body) {
    let fx = body.tech_fx;
    let gx = body.tech_gx;
    let point = body.tech_point;
    let variable = body.tech_variable;

    if (fx && gx) {
      let parem = fx
        .replace(/ /g, "")
        .replace(/−/g, "-")
        .replace(/plus/g, "+")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**");

      let parem1 = gx
        .replace(/ /g, "")
        .replace(/−/g, "-")
        .replace(/plus/g, "+")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**");

      let postData = new URLSearchParams();
      postData.append("fx", parem);
      postData.append("gx", parem1);

      if (!isNaN(point)) {
        postData.append("x", variable);
        postData.append("point", point);
      }

      try {
        const response = await axios.post(
          "http://167.172.134.148/fun-op",
          postData,
          {
            timeout: 120000,
          }
        );

        let buffer = response.data;

        let result = {
          tech_fox: buffer[0],
          tech_gox: buffer[1],
          tech_add: buffer[2],
          tech_sub: buffer[3],
          tech_mul: buffer[4],
          tech_div: buffer[5],
          tech_x: variable,
        };

        if (!isNaN(point)) {
          result.tech_add1 = buffer[6];
          result.tech_sub1 = buffer[7];
          result.tech_mul1 = buffer[8];
          result.tech_div1 = buffer[9];
          result.tech_point = point;
        }

        return result;
      } catch (error) {
        return {
          status: "error",
          error: "Please! Check Your Input.",
        };
      }
    } else {
      return {
        status: "error",
        error: "Please! Check Your Input.",
      };
    }
  }

  /** getCalculationMultiplyingPolynomialsCalculator
   * POST: /api/calculators-lol/function-operations-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMultiplyingPolynomialsCalculator(body) {
    let first = body.tech_first;
    let second = body.tech_second;

    if (first && second) {
      let parem = first
        .replace(/ /g, "")
        .replace(/−/g, "-")
        .replace(/plus/g, "+")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**");

      let parem1 = second
        .replace(/ /g, "")
        .replace(/−/g, "-")
        .replace(/plus/g, "+")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**");

      try {
        const response = await axios.post(
          "http://167.172.134.148/multiplying",
          new URLSearchParams({
            equ: parem,
            equ1: parem1,
          }),
          { timeout: 120000 }
        );

        let buffer = response.data;
        let input1 = buffer[0];
        let input2 = buffer[1];
        let ans = buffer[2];
        let left = buffer[3];
        let right = buffer[4];
        let nextstep = buffer[5];

        nextstep = nextstep
          .replace(/\\left\[/g, "")
          .replace(/\\right\]/g, "")
          .replace(/ /g, "")
          .replace(/\\/g, "")
          .replace(/frac/g, "\\dfrac")
          .replace(/sqrt/g, "\\sqrt")
          .split(",");

        let lefts = left
          .replace(/\\left\(/g, "")
          .replace(/\\right\)/g, "")
          .replace(/ /g, "")
          .replace(/\\/g, "")
          .replace(/frac/g, "\\dfrac")
          .replace(/sqrt/g, "\\sqrt")
          .split(",");

        let rights = right
          .replace(/\\left\(/g, "")
          .replace(/\\right\)/g, "")
          .replace(/ /g, "")
          .replace(/\\/g, "")
          .replace(/frac/g, "\\dfrac")
          .replace(/sqrt/g, "\\sqrt")
          .split(",");

        let step = "";
        let next = "";

        for (let value of lefts) {
          for (let value1 of rights) {
            step += step
              ? ` + (${value}) \\times (${value1})`
              : `(${value}) \\times (${value1})`;
          }
        }

        for (let value of nextstep) {
          next += next ? ` + ( ${value} )` : `( ${value} )`;
        }

        return {
          tech_input1: input1,
          tech_input2: input2,
          tech_step: step,
          tech_next: next,
          tech_ans: ans,
        };
      } catch (error) {
        return {
          error: "Please! Check Your Input.",
        };
      }
    } else {
      return {
        error: "2 values should not be same.",
      };
    }
  }

  /** getCalculationInequalityCalculator
   * POST: /api/calculators-lol/inequality-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationInequalityCalculator(body) {
    let select = body.tech_select;
    let equ1 = body.tech_equ1;
    let con = body.tech_con;
    let equ2 = body.tech_equ2;

    let vari = "x";

    if (!equ1) {
      return { error: "Equation 1 is required." };
    }

    equ1 = equ1.replace(/ /g, "");
    let greater_than_equal_count = (equ1.match(/>=/g) || []).length;
    let less_than_equal_count = (equ1.match(/<=/g) || []).length;
    let less_than_count =
      (equ1.match(/</g) || []).length - less_than_equal_count;
    let greater_than_count =
      (equ1.match(/>/g) || []).length - greater_than_equal_count;
    let equal_count =
      (equ1.match(/=/g) || []).length -
      greater_than_equal_count -
      less_than_equal_count;
    let all_count =
      greater_than_equal_count +
      less_than_equal_count +
      less_than_count +
      greater_than_count +
      equal_count;

    if (all_count > 1) {
      return { error: "Equation has more than one symbol." };
    }

    if (equ1.includes(">=")) equ1 = equ1.replace(">=", "gtae");
    else if (equ1.includes("<=")) equ1 = equ1.replace("<=", "ltae");
    else if (equ1.includes("<")) equ1 = equ1.replace("<", "less");
    else if (equ1.includes(">")) equ1 = equ1.replace(">", "greater");
    else if (equ1.includes("=")) equ1 = equ1.replace("=", "equal");

    let parem = equ1
      .replace(/−/g, "-")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    let form_params = {
      select,
      vari,
      equ: parem,
    };

    if (select === "1") {
      if (!equ2) {
        return { error: "Please! Check Your Input." };
      }

      equ2 = equ2.replace(/ /g, "");
      greater_than_equal_count = (equ2.match(/>=/g) || []).length;
      less_than_equal_count = (equ2.match(/<=/g) || []).length;
      less_than_count = (equ2.match(/</g) || []).length - less_than_equal_count;
      greater_than_count =
        (equ2.match(/>/g) || []).length - greater_than_equal_count;
      equal_count =
        (equ2.match(/=/g) || []).length -
        greater_than_equal_count -
        less_than_equal_count;
      all_count =
        greater_than_equal_count +
        less_than_equal_count +
        less_than_count +
        greater_than_count +
        equal_count;

      if (all_count > 1) {
        return { error: "Second Equation has more than one symbol." };
      }

      if (equ2.includes(">=")) equ2 = equ2.replace(">=", "gtae");
      else if (equ2.includes("<=")) equ2 = equ2.replace("<=", "ltae");
      else if (equ2.includes("<")) equ2 = equ2.replace("<", "less");
      else if (equ2.includes(">")) equ2 = equ2.replace(">", "greater");
      else if (equ2.includes("=")) equ2 = equ2.replace("=", "equal");

      let parem2 = equ2
        .replace(/−/g, "-")
        .replace(/\+/g, "plus")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**")
        .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

      form_params["equ1"] = parem2;
    }

    try {
      const response = await axios.post(
        "http://167.172.134.148/compound",
        new URLSearchParams(form_params),
        {
          timeout: 120000,
        }
      );

      let buffer = response.data;

      let result = {
        tech_solution_inequality: buffer.latex_solution_eq,
        tech_steps: buffer.steps,
      };

      if (buffer.latex_solution_eq_sec) {
        result.tech_latex_solution_eq_sec = buffer.latex_solution_eq_sec;
      }

      if (buffer.steps_sec) {
        result.tech_steps_sec = buffer.steps_sec;
      }

      return result;
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationSolveforxCalculator
   * POST: /api/calculators-lol/solve-for-x-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationSolveforxCalculator(body) {
    let input = body.tech_input;
    let is_equal = body.tech_is_equal;

    if (!input || isNaN(is_equal)) {
      return { error: "Please Enter Valid Input." };
    }

    if (!/x/i.test(input)) {
      return { error: "x is not in the Equestion." };
    }

    let parem = input
      .replace(/ /g, "")
      .replace(/−/g, "-")
      .replace(/plus/g, "+")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    parem += `-(${is_equal})`;

    try {
      const response = await axios.post(
        "http://167.172.134.148/solve-x",
        new URLSearchParams({ equ: parem }),
        { timeout: 120000 }
      );

      let buffer = response.data;
      let ans = buffer[0];

      return {
        tech_ans: ans,
      };
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationSolveforxCalculator
   * POST: /api/calculators-lol/combine-like-terms-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCombiningLikeTermsCalculator(body) {
    let input = body.tech_input;

    if (!input) {
      return { error: "Please Check Your Input" };
    }

    let parem = input
      .replace(/ /g, "")
      .replace(/x=/g, "")
      .replace(/y=/g, "")
      .replace(/−/g, "-")
      .replace(/plus/g, "+")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    try {
      const response = await axios.post(
        "http://167.172.134.148/combine",
        new URLSearchParams({ equ: parem }),
        { timeout: 120000 }
      );

      const [enter, inputLatex, answer] = response.data;

      let like = inputLatex
        .replace(/\\left\(/g, "")
        .replace(/\\right\)/g, "")
        .replace(/ /g, "")
        .replace(/\\/g, "");
      let likes = like.split(",");

      let combine = {};
      likes.forEach((val) => {
        let lowerVal = val.toLowerCase();
        let matched = false;
        for (let ch = 97; ch <= 122; ch++) {
          let key = String.fromCharCode(ch);
          if (lowerVal.includes(key)) {
            combine[key] = combine[key] || [];
            combine[key].push(val);
            matched = true;
            break;
          }
        }
        if (!matched) {
          combine["zcon"] = combine["zcon"] || [];
          combine["zcon"].push(val);
        }
      });

      let powera = {};
      for (let key in combine) {
        combine[key].forEach((val) => {
          if (key !== "zcon") {
            let parts = val.split(`${key}^{`);
            if (parts.length === 2) {
              let base = parts[0].trim() || "1";
              let exponent = parts[1].replace("}", "").trim();
              powera[`${key}^{${exponent}}`] =
                powera[`${key}^{${exponent}}`] || [];
              powera[`${key}^{${exponent}}`].push(base);
            } else {
              let base = val.replace(new RegExp(key, "g"), "").trim() || "1";
              powera[key] = powera[key] || [];
              powera[key].push(base);
            }
          } else {
            powera["zcon"] = powera["zcon"] || [];
            powera["zcon"].push(val.trim());
          }
        });
      }

      let steps = [];
      let final = [];
      let finals = [];
      let ans = "";
      let i = 0;
      let j = 0;

      const sortedKeys = Object.keys(powera).sort();
      for (let key of sortedKeys) {
        let values = powera[key];
        if (!values) continue;

        let step = "";
        let plus =
          values.reduce((sum, val) => sum + Number(val), 0) > 0 ? " + " : "";

        if (key !== "zcon") {
          finals.push(
            plus +
              (values.length > 1 || values[0] !== "1"
                ? values.reduce((sum, val) => sum + Number(val), 0)
                : "") +
              key
          );
        } else {
          finals.push(plus + values.reduce((sum, val) => sum + Number(val), 0));
        }

        if (values.length > 1) step = "Combining like terms ";
        values.forEach((val, idx) => {
          if (values.length > 1) {
            step +=
              idx === 0
                ? `\\( ${val !== "1" ? val : ""}${key} \\)`
                : ` and \\( ${val !== "1" ? val : ""}${key} \\)`;
          }

          i++;
          let sign = Number(val) >= 0 && i > 1 ? " + " : i === 1 ? "" : " ";
          let term =
            val === "1" && key !== "zcon"
              ? key
              : `${val}${key !== "zcon" ? key : ""}`;
          ans += `${sign}${term}`;
          final[j] = (final[j] || "") + `${sign}${term}`;
        });

        steps.push(values.length > 1 ? step : "");
        j++;
      }

      return {
        tech_enter: enter,
        tech_input: inputLatex,
        tech_answer: answer,
        tech_powera: powera,
        tech_steps: steps,
        tech_final: final,
        tech_finals: finals,
        tech_ans: ans,
      };
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationRotationCalculator
   * POST: /api/calculators-lol/rotation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRotationCalculator(body) {
    let point_rotate_one = body.tech_point_rotate_one;
    let point_rotate_two = body.tech_point_rotate_two;
    let angle = body.tech_angle;
    let unit = body.tech_unit;
    let point_around_one = body.tech_point_around_one;
    let point_around_two = body.tech_point_around_two;
    let direction = body.tech_direction;

    // Helper function to check if a value is numeric
    function isNumeric(value) {
      return !isNaN(parseFloat(value)) && isFinite(value);
    }

    const result = {
      param: {},
    };

    if (unit === "radians") {
      if (
        isNumeric(point_rotate_one) &&
        isNumeric(point_rotate_two) &&
        isNumeric(angle) &&
        isNumeric(point_around_one) &&
        isNumeric(point_around_two)
      ) {
        if (direction === "anticlockwise" || direction === "clockwise") {
          let rotationAngle = angle;
          if (direction === "clockwise") {
            rotationAngle = angle * -1;
          } else if (direction === "anticlockwise") {
            rotationAngle = angle * 1;
          }

          const first_point = point_rotate_one - point_around_one;
          const second_point = point_rotate_two - point_around_two;
          const first_part = first_point * Math.cos(rotationAngle);
          const second_part = second_point * Math.sin(rotationAngle);
          const formula = first_part - second_part + point_around_one;
          const third_part = first_point * Math.sin(rotationAngle);
          const fourth_part = second_point * Math.cos(rotationAngle);
          const formula2 = third_part + fourth_part + point_around_two;

          result.param.tech_point_rotate_one = point_rotate_one;
          result.param.tech_point_rotate_two = point_rotate_two;
          result.param.tech_point_around_one = point_around_one;
          result.param.tech_point_around_two = point_around_two;
          result.param.tech_formula_one = formula;
          result.param.tech_formula_two = formula2;
          result.param.tech_angle = rotationAngle;
          result.param.tech_angle2 = rotationAngle;
          result.param.tech_unit = unit;
          result.param.tech_direction = direction;
        }
      } else {
        result.param.error = "Please! Check Your Input.";
        return result.param;
      }
    } else if (unit === "degrees") {
      if (
        isNumeric(point_rotate_one) &&
        isNumeric(point_rotate_two) &&
        isNumeric(angle) &&
        isNumeric(point_around_one) &&
        isNumeric(point_around_two)
      ) {
        if (direction === "anticlockwise" || direction === "clockwise") {
          let rotationAngle = angle;
          if (direction === "clockwise") {
            rotationAngle = angle * -1;
          } else if (direction === "anticlockwise") {
            rotationAngle = angle * 1;
          }

          const first_point = point_rotate_one - point_around_one;
          const second_point = point_rotate_two - point_around_two;
          const sp = (rotationAngle * Math.PI) / 180;
          const first_part = first_point * Math.cos(sp);
          const second_part = second_point * Math.sin(sp);
          const formula = first_part - second_part + point_around_one;
          const third_part = first_point * Math.sin(sp);
          const fourth_part = second_point * Math.cos(sp);
          const formula2 = third_part + fourth_part + point_around_two;

          result.param.tech_point_rotate_one = point_rotate_one;
          result.param.tech_point_rotate_two = point_rotate_two;
          result.param.tech_point_around_one = point_around_one;
          result.param.tech_point_around_two = point_around_two;
          result.param.tech_formula_one = formula;
          result.param.tech_formula_two = formula2;
          result.param.tech_angle = sp;
          result.param.tech_angle2 = rotationAngle;
          result.param.tech_direction = direction;
          result.param.tech_unit = unit;
        }
      } else {
        result.param.error = "Please! Check Your Input.";
        return result.param;
      }
    }

    return result.param;
  }

  /** getCalculationReciprocalCalculator
   * POST: /api/calculators-lol/reciprocal-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationReciprocalCalculator(body) {
    let operations = body.tech_operations;
    let first = body.tech_first;
    let second = body.tech_second;
    let third = body.tech_third;

    let param = {};

    function gcd(a, b) {
      a = Math.abs(a);
      b = Math.abs(b);
      if (a < b) [a, b] = [b, a];
      if (b === 0) return 1;
      let r = a % b;
      while (r > 0) {
        a = b;
        b = r;
        r = a % b;
      }
      return b;
    }

    function reduce(num, den) {
      let g = gcd(num, den);
      return [num / g, den / g];
    }

    if (operations == 1) {
      if (!isNaN(second) && !isNaN(third)) {
        if (second != 0) {
          if (third != 0) {
            let answer = third / second;
            let totalN = second;
            let totalD = third;
            let g = gcd(totalN, totalD);
            let [upr, btm] = reduce(totalN, totalD);
            param.tech_upr = upr;
            param.tech_totalN = totalN;
            param.tech_totalD = totalD;
            param.tech_g = g;
            param.tech_btm = btm;
            param.tech_answer = answer;
          } else {
            param.error = "Denominator cannot be zero.";
            return param;
          }
        } else {
          param.error = "Numerator cannot be zero.";
          return param;
        }
      } else {
        param.error = "Please Check Your Input";
        return param;
      }
    } else if (operations == 2) {
      if (!isNaN(first)) {
        if (first != 0) {
          let zz = first.toString().split(".");
          let answer = 1 / first;
          if (zz.length === 1) {
            param.tech_answer = answer;
          } else if (zz.length === 2) {
            let len = zz[1].length;
            let aja = "0".repeat(len);
            let upper = parseInt("1" + aja);
            let lower = first * upper;
            let totalN = upper;
            let totalD = lower;
            let g = gcd(totalN, totalD);
            let [upr, btm] = reduce(totalN, totalD);
            param.tech_upr = upr;
            param.tech_totalN = totalN;
            param.tech_totalD = totalD;
            param.tech_g = g;
            param.tech_btm = btm;
            param.tech_answer = answer;
            param.tech_upper = upper;
            param.tech_lower = lower;
          }
        } else {
          param.error = "The multiplicative inverse of 0 is undefined.";
          return param;
        }
      } else {
        param.error = "Please Check Your Input";
        return param;
      }
    } else if (operations == 3) {
      if (!isNaN(first) && !isNaN(second) && !isNaN(third)) {
        if (third != 0) {
          let totalD = third;
          let val1 = first;
          let totalN = totalD * val1 + second;
          let g = gcd(totalN, totalD);
          let [upr, btm] = reduce(totalN, totalD);
          param.tech_upr = upr;
          param.tech_totalN = totalN;
          param.tech_totalD = totalD;
          param.tech_g = g;
          param.tech_btm = btm;
        } else {
          param.error = "Denominator cannot be zero.";
          return param;
        }
      } else {
        param.error = "Please Check Your Input";
        return param;
      }
    }

    param.tech_operations = operations;
    return param;
  }

  /** getCalculationCofunctionCalculator
   * POST: /api/calculators-lol/cofunction-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCofunctionCalculator(body) {
    let func = body.tech_func;
    let angle = body.tech_angle;
    let unit = body.tech_unit;

    let param = {};

    if (!isNaN(func) && !isNaN(angle)) {
      let ang = angle;

      if (unit === "rad") {
        angle = (angle * 180) / Math.PI;
      }

      if (angle < 0 || angle > 90) {
        param["error"] =
          "Angle for cofunction identities is 0-90 degrees (or 0 - π/2 in radians).";
        return param;
      }

      let ang1 = 90 - angle;
      if (unit === "rad") {
        ang1 = (ang1 * Math.PI) / 180;
      }

      let ans, ans1;

      switch (parseInt(func)) {
        case 1: // sin
          ans = Math.sin((angle * Math.PI) / 180);
          if (angle == 30) ans1 = " = 1/2";
          else if (angle == 45) ans1 = " = √2/2";
          else if (angle == 60) ans1 = " = √3/2";
          break;
        case 2: // cos
          ans = Math.cos((angle * Math.PI) / 180);
          if (angle == 30) ans1 = " = √3/2";
          else if (angle == 45) ans1 = " = √2/2";
          else if (angle == 60) ans1 = " = 1/2";
          break;
        case 3: // tan
          ans = Math.tan((angle * Math.PI) / 180);
          if (angle == 30) ans1 = " = 1/√3 = √3/3";
          else if (angle == 60) ans1 = " = √3";
          break;
        case 4: // cot
          ans = 1 / Math.tan((angle * Math.PI) / 180);
          if (angle == 30) ans1 = " = √3";
          else if (angle == 60) ans1 = " = 1/√3 = √3/3";
          break;
        case 5: // sec
          ans = 1 / Math.cos((angle * Math.PI) / 180);
          if (angle == 30) ans1 = " = 2√3/3";
          else if (angle == 45) ans1 = " = √2";
          break;
        case 6: // csc
          ans = 1 / Math.sin((angle * Math.PI) / 180);
          if (angle == 45) ans1 = " = √2";
          else if (angle == 60) ans1 = " = 2√3/3";
          break;
        default:
          param["error"] = "Invalid function selected.";
          return param;
      }

      param["tech_ans"] = Number(ans.toFixed(8));
      param["tech_ang"] = Number(ang.toFixed(8));
      param["tech_ang1"] = Number(ang1.toFixed(8));
      if (ans1) param["tech_ans1"] = ans1;

      return param;
    } else {
      param["error"] = "Please Check Your Input.";
      return param;
    }
  }

  /** getCalculationAdditiveInverseCalculator
   * POST: /api/calculators-lol/additive-inverse-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAdditiveInverseCalculator(body) {
    let nbr = body.tech_nbr;

    let param = {};

    if (!isNaN(nbr)) {
      let ans = -1 * nbr;
      param["tech_ans"] = ans;
      return param;
    } else {
      param["error"] = "Please! Check Your Input.";
      return param;
    }
  }

  /** getCalculationMonomialCalculator
   * POST: /api/calculators-lol/monomial-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMonomialCalculator(body) {
    let equ = body.tech_equ;
    let param = {};

    if (equ && equ.trim() !== "") {
      let parem = equ;

      parem = parem.replace(/ /g, "");
      parem = parem.replace(/\+/g, "plus");
      parem = parem.replace(/{/g, "(");
      parem = parem.replace(/}/g, ")");
      parem = parem.replace(/e\^/g, "exp");
      parem = parem.replace(/exp\^/g, "exp");
      parem = parem.replace(/\^/g, "**");
      parem = parem.replace(/e\^sqrt\(x\)/g, "exp(2*x)");

      try {
        const response = await axios.post(
          "http://167.172.134.148/monomial",
          new URLSearchParams({ equ: parem }),
          { timeout: 120000 }
        );

        const buffer = response.data;

        param["tech_ans"] = buffer[1];
        return param;
      } catch (error) {
        param["error"] = "Please! Check Your Input.";
        return param;
      }
    } else {
      param["error"] = "Please! Check Your Input.";
      return param;
    }
  }
  /** getCalculationLongMultiplicationCalculator
   * POST: /api/calculators-lol/long-multiplication-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationLongMultiplicationCalculator(body) {
    let first = body.tech_first;
    let second = body.tech_second;
    let param = {};

    if (!isNaN(first) && !isNaN(second)) {
      let answer1 = first * second;
      let answer;

      let aa = answer1.toString().split(".");

      if (aa.length === 1) {
        answer = answer1.toString();
      } else if (aa.length === 2) {
        answer = aa[0] + aa[1];
      }

      let xx = first.toString().split(".");
      let yy = second.toString().split(".");
      let l1, l2, total;

      if (xx.length === 2) l1 = xx[1].length;
      if (yy.length === 2) l2 = yy[1].length;

      if (l1 && l2) {
        total = l1 + l2;
      } else {
        total = l1 || l2 || 0;
      }

      if (total > 0) {
        param[
          "tech_line1"
        ] = `The following decimals contain overall <b>${total}</b> decimal places`;
        param[
          "tech_line2"
        ] = `You just need to carry out long multiplication as you do with normal integers by ignoring the decimals.`;
        param[
          "tech_line3"
        ] = `In the final final, start from right to left and move up to <b>${total}</b> decimal places to insert the decimal. This is the final answer.`;
      }

      let firstClean = first.toString().replace(".", "");
      let secondClean = second.toString().replace(".", "");

      let absFirst = Math.abs(parseInt(firstClean));
      let absSecond = Math.abs(parseInt(secondClean));

      let answer2 = absFirst * absSecond;
      let f_len = absFirst.toString().length;
      let s_len = absSecond.toString().length;
      let col = answer.length;

      let f_array = absFirst.toString().split("");
      let s_array = absSecond.toString().split("");

      let arr_rev = [];
      let m_j = [];
      let upper, lower;

      if (f_len >= s_len) {
        let rev_array = [...s_array].reverse();
        arr_rev = rev_array;

        arr_rev.forEach((value) => {
          m_j.push(parseInt(value) * absFirst);
        });

        upper = f_array;
        lower = s_array;
      } else {
        let rev_array = [...f_array].reverse();
        arr_rev = rev_array;

        arr_rev.forEach((value) => {
          m_j.push(parseInt(value) * absSecond);
        });

        upper = s_array;
        lower = f_array;
      }

      let final = answer.split("");

      param["tech_upper"] = upper;
      param["tech_lower"] = lower;
      param["tech_col"] = col;
      param["tech_m_j"] = m_j;
      param["tech_final"] = final;
      param["tech_answer"] = answer;
      param["tech_answer1"] = answer1;

      return param;
    } else {
      param["error"] = "Please Check Your Input.";
      return param;
    }
  }

  /** getCalculationDivisibleCalculator
   * POST: /api/calculators-lol/divisible-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDivisibleCalculator(body) {
    let no = body.tech_no;
    let divisible = body.tech_divisible;
    let param = {};

    if (
      !isNaN(no) &&
      !isNaN(divisible) &&
      no > 0 &&
      divisible > 0 &&
      no >= divisible
    ) {
      no = parseInt(no);
      divisible = parseInt(divisible);

      let division = Math.floor(no / divisible);
      let modulus = no % divisible;

      let division_array = division.toString().split("");
      let divisible_array = divisible.toString().split("");
      let number_array = no.toString().split("");
      let counter = 1;
      let com = "";

      for (let i = 0; i < number_array.length; i++) {
        if (i === 0) {
          com = number_array[i];
        }
        if (parseInt(com) < divisible) {
          com = com + number_array[i + 1];
          counter += 1;
        }
      }

      let stokes = com;
      let com_array = com.toString().split("");

      let separate_values = [];
      for (let z = com_array.length; z < number_array.length; z++) {
        separate_values.push(number_array[z]);
      }

      let multiplication = [];
      let p_length = [];
      let tree = [];
      let read = [];
      let extra = [];

      for (let j = 0; j < division_array.length; j++) {
        let mult = divisible * parseInt(division_array[j]);
        multiplication.push(mult);
        let p = parseInt(com) - mult;
        p_length.push(p);
        tree.push(p);

        if (p < divisible) {
          if (typeof separate_values[j] !== "undefined") {
            com = p.toString() + separate_values[j];
            extra.push(com);
          }
        }

        read.push(com);
      }

      param["tech_stokes"] = stokes;
      param["tech_divisible_array"] = divisible_array;
      param["tech_number_array"] = number_array;
      param["tech_number"] = no;
      param["tech_divisible"] = divisible;
      param["tech_division"] = division;
      param["tech_modulus"] = modulus;
      param["tech_multiply"] = multiplication;
      param["tech_read"] = read;
      param["tech_com"] = com;
      param["tech_p_length"] = p_length;
      param["tech_tree_array"] = tree;

      return param;
    } else {
      param["error"] = "Please Enter Valid Input.";
      return param;
    }
  }

  /** getCalculationAverageValueFunctionCalculator
   * POST: /api/calculators-lol/average-value-of-function
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAverageValueFunctionCalculator(body) {
    let fun = body.tech_fun;
    let lb = body.tech_lb;
    let ub = body.tech_ub;

    let param = {};

    if (fun && !isNaN(lb) && !isNaN(ub)) {
      let vari = 0;
      let withVar = "";
      let value = fun
        .replace(/%20/g, "")
        .replace(/ /g, "")
        .replace(/plus/g, "+");

      // Detect the single variable used
      for (let char of "abcdefghijklmnopqrstuvwxyz") {
        if (new RegExp(char, "i").test(value)) {
          vari++;
          withVar = char;
        }
      }

      if (vari !== 1) {
        param["error"] = "The function contains more than one variable.";
        return param;
      }

      if (Number(lb) > Number(ub)) {
        param["error"] = "Upper Limit must be greater than Lower Limit.";
        return param;
      }

      let divide = ub - lb;

      // Format equation string
      let parem = fun;
      parem = parem.replace(/ /g, "");
      parem = parem.replace(/\+/g, "plus");
      parem = parem.replace(/{/g, "(");
      parem = parem.replace(/}/g, ")");
      parem = parem.replace(/e\^/g, "exp");
      parem = parem.replace(/exp\^/g, "exp");
      parem = parem.replace(/\^/g, "**");
      parem = parem.replace(/e\^sqrt\(x\)/g, "exp(2*x)");

      try {
        const response = await axios.post(
          "http://167.172.134.148/avg_fun",
          new URLSearchParams({
            equ: parem,
            wrt: withVar,
            ub: ub,
            lb: lb,
            divide: divide,
          }),
          { timeout: 120000 }
        );

        const buffer = response.data;

        param["tech_input"] = buffer[0];
        param["tech_sim"] = buffer[1];
        param["tech_ans"] = buffer[2];
        param["tech_with"] = withVar;
        param["tech_divide"] = divide;
        return param;
      } catch (err) {
        param["error"] = "Please! Check Your Input.";
        return param;
      }
    } else {
      param["error"] = "Please Check Your Input!";
      return param;
    }
  }

  /** getCalculationProductSumCalculator
   * POST: /api/calculators-lol/product-sum-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationProductSumCalculator(body) {
    let product = body.tech_product;
    let sum = body.tech_sum;
    let param = {};

    if (!isNaN(product) && !isNaN(sum)) {
      let A = 1;
      let B = -1 * sum;
      let C = product;

      let dis = Math.pow(B, 2) - 4 * A * C;

      if (dis > 0) {
        let x1 = Number(((-B + Math.sqrt(dis)) / (2 * A)).toFixed(4));
        let x2 = Number(((-B - Math.sqrt(dis)) / (2 * A)).toFixed(4));

        param["fact"] =
          `${A}(x ${x1 < 0 ? "+ " + Math.abs(x1) : "- " + x1} )` +
          `(x ${x2 < 0 ? "+ " + Math.abs(x2) : "- " + x2} )`;
        param["roots"] = `x₁ = ${x1} , x₂ = ${x2}`;
      } else if (dis < 0) {
        let real = Number((-B / (2 * A)).toFixed(4));
        let imag = Number((Math.sqrt(-dis) / (2 * A)).toFixed(4));

        let x1 = `${real} + ${imag}`;
        let x2 = `${real} - ${imag}`;

        param["tech_fact"] = `${A}(x - (${x1}\\,i) )(x - (${x2}\\,i) )`;
        param["tech_roots"] = `x₁ = ${x1} <i>i</i><br> x₂ = ${x2} <i>i</i>`;
      } else {
        let x1 = Number((-B / (2 * A)).toFixed(4));
        param["tech_fact"] = `${A}(x ${
          x1 < 0 ? "+ " + Math.abs(x1) : "- " + x1
        } )^2`;
        param["tech_roots"] = `x = ${x1}`;
      }

      param["tech_dis"] = dis;
      param["tech_a"] = A;
      param["tech_B"] = B;
      param["tech_C"] = C;
      return param;
    } else {
      param["error"] = "Please Check Your Input!";
      return param;
    }
  }

  /** getCalculationPascalTriangleCalculator
   * POST: /api/calculators-lol/pascals-triangle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPascalTriangleCalculator(body) {
    let method = body.tech_method;
    let row = body.tech_row;
    let to_row = body.tech_to_row;
    let column = body.tech_column;
    let param = {};

    if (method === "1") {
      if (!isNaN(row)) {
        row = parseInt(row);
        if (row >= 0) {
          if (row < 100) {
            param["row"] = row;
          } else {
            param["error"] = "The row must be less than 100.";
            return param;
          }
        } else {
          param["error"] = "The row must be non-negative.";
          return param;
        }
      } else {
        param["error"] = "Please! Check Your Input.";
        return param;
      }
    } else if (method === "2") {
      if (!isNaN(row)) {
        row = parseInt(row);
        if (row >= 0) {
          if (row >= 100) {
            param["error"] = "The row must be less than 100.";
            return param;
          }
        } else {
          param["error"] = "The row must be non-negative.";
          return param;
        }
      } else {
        param["error"] = "Please! Check Your Input.";
        return param;
      }
    } else if (method === "3") {
      if (!isNaN(row) && !isNaN(to_row)) {
        row = parseInt(row);
        to_row = parseInt(to_row);
        if (row >= 0 && to_row >= 0) {
          if (to_row >= row) {
            param["tech_col"] = to_row;
          } else {
            param["error"] =
              "The end-row must be at least equal to the one we started with.";
            return param;
          }
        } else {
          param["error"] = "The row must be non-negative.";
          return param;
        }
      } else {
        param["error"] = "Please! Check Your Input.";
        return param;
      }
    } else if (method === "4") {
      if (!isNaN(row) && !isNaN(column)) {
        row = parseInt(row);
        column = parseInt(column);
        if (row >= column && row > 0 && column > 0) {
          param["tech_column"] = column;
        } else {
          param["error"] = "Enter Row n ≥ Col k ≥ 0.";
          return param;
        }
      } else {
        param["error"] = "Please! Check Your Input.";
        return param;
      }
    }

    param["tech_row"] = row;
    param["tech_method"] = method;
    return param;
  }
  /** getCalculationOrderOfOperationsCalculator
   * POST: /api/calculators-lol/order-of-operations-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationOrderOfOperationsCalculator(body) {
    let expression = body.tech_expression;

    let param = {};

    if (expression !== "") {
      let fixedstring = expression.replace(/ /g, "+");

      if (fixedstring) {
        param["tech_method"] = 1;
        param["tech_expression"] = fixedstring;
        return param;
      } else {
        param["error"] = "Please! Check Input.";
        return param;
      }
    } else {
      param["error"] = "Please! Check Input.";
      return param;
    }
  }
  /** getCalculationCharacteristicPolynomialCalculator
   * POST: /api/calculators-lol/characteristic-polynomial-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCharacteristicPolynomialCalculator(body) {
    let matrix22 = body.tech_matrix22;

    let second_matrix = [];
    for (let i = 1; i <= matrix22; i++) {
      for (let j = 1; j <= matrix22; j++) {
        let key = `tech_matrix3${i}_${j}`;
        if (body.hasOwnProperty(key) && !isNaN(body[key])) {
          second_matrix.push(parseFloat(body[key]));
        }
      }
    }

    let mul = matrix22 * matrix22;
    if (mul !== second_matrix.length) {
      return { error: "Please! Check Your Input." };
    }

    let zain = [];
    for (let i = 0; i < matrix22; i++) {
      zain.push(second_matrix.slice(i * matrix22, (i + 1) * matrix22));
    }

    let advance = [];
    for (let i = 0; i < second_matrix.length; i++) {
      if (i % (matrix22 + 1) === 0) {
        advance.push(`${second_matrix[i]}-λ`);
      } else {
        advance.push(`${second_matrix[i]}`);
      }
    }

    let val_array = [];
    for (let i = 0; i < advance.length; i += matrix22) {
      val_array.push(advance.slice(i, i + matrix22));
    }

    let input = [];
    for (let rowIndex = 0; rowIndex < val_array.length; rowIndex++) {
      let row = val_array[rowIndex];
      for (let i = 0; i < row.length; i++) {
        input.push(row[i]);
        if (i < row.length - 1) {
          input.push(",");
        }
      }
      if (rowIndex < val_array.length - 1) {
        input.push("@@");
      }
    }

    let mat = input.join("");
    let param = {};

    try {
      const response = await axios.post(
        "http://167.172.134.148/characteristic",
        new URLSearchParams({ mat }),
        { timeout: 120000 }
      );

      let buffer = response.data.split("@@@");
      param["tech_answer"] = buffer[0];
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }

    param["tech_matrix"] = val_array;
    param["tech_input_ma"] = zain;
    return param;
  }

  /** getCalculationXAndYInterceptsCalculator
   * POST: /api/calculators-lol/intercepts-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationXAndYInterceptsCalculator(body) {
    let EnterEq = body.tech_EnterEq;

    // Basic validation
    if (!EnterEq || /<|>|&|php|print_r|print|echo|script|%/i.test(EnterEq)) {
      return { error: "Please Enter Valid Input." };
    }

    // Sanitize expression
    let parem = EnterEq.replace(/ /g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/log/g, "ln")
      .replace(/=/g, "-")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    let param = {};

    try {
      const response = await axios.post(
        "http://167.172.134.148/intercepts",
        new URLSearchParams({ equ: parem }),
        { timeout: 120000 }
      );

      const buffer = response.data;

      let equation = buffer[0];
      let xIntercepts = buffer[1]
        .split(",")
        .map((item) => (item === "\\left[ \\right]" ? "0" : `${item},0`));
      let yIntercept =
        buffer[2] === "\\left[ \\right]" ? "0,0" : `0,${buffer[2]}`;
      yIntercept = yIntercept.replace(/\\left\[|\\right\]/g, "");

      param["tech_equation"] = equation;
      param["tech_buffer_zero"] = xIntercepts;
      param["tech_c"] = xIntercepts.length;
      param["tech_buffer_one"] = yIntercept;
      param["tech_method"] = buffer[3];

      return param;
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationDomainAndRangeCalculator
   * POST: /api/calculators-lol/domain-and-range-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDomainAndRangeCalculator(body) {
    let eq = body.tech_eq;

    if (!eq) {
      return { error: "Please Check Your Input." };
    }

    // Input validation
    const invalidPattern =
      /<|>|&|php|print_r|print|echo|script|=|sin|cos|tan|arcsin|arccos|arctan|%/i;
    if (invalidPattern.test(eq)) {
      return { error: "Please Enter Valid Input." };
    }

    // Sanitize equation
    let parem = eq
      .replace(/ /g, "")
      .replace(/\+/g, "plus")
      .replace(/%20/g, "")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    try {
      const response = await axios.post(
        "http://167.172.134.148/domain",
        new URLSearchParams({ equ: parem }),
        { timeout: 120000 }
      );

      const buffer = response.data;

      return {
        tech_domain: buffer[0],
        tech_range: buffer[1],
      };
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationDistanceBetweenTwoPointsCalculator
   * POST: /api/calculators-lol/distance-between-two-points-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDistanceBetweenTwoPointsCalculator(body) {
    let x1 = body.tech_x1;
    let y1 = body.tech_y1;
    let x2 = body.tech_x2;
    let y2 = body.tech_y2;
    if (isNumeric(x1) && isNumeric(y1) && isNumeric(x2) && isNumeric(y2)) {
      let dx = x2 - x1;
      let dy = y2 - y1;
      let ans =
        Math.round(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)) * 10000) /
        10000;

      return {
        tech_ans: ans,
      };
    } else {
      return {
        error: "Please Check Your Input.",
      };
    }

    function isNumeric(value) {
      return !isNaN(parseFloat(value)) && isFinite(value);
    }
  }

  /** getCalculationSASTriangleCalculator
   * POST: /api/calculators-lol/sas-triangle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationSASTriangleCalculator(body) {
    let first = body.tech_first;
    let unit1 = body.tech_unit1;
    let second = body.tech_second;
    let unit2 = body.tech_unit2;
    let third = body.tech_third;
    let unit3 = body.tech_unit3;

    function toCm(unit, value) {
      switch (unit) {
        case "mm":
          return value / 10;
        case "cm":
          return value;
        case "m":
          return value * 100;
        case "in":
          return value * 2.54;
        case "ft":
          return value * 30.48;
        default:
          return NaN;
      }
    }

    function toDeg(unit, value) {
      switch (unit) {
        case "pi":
          return value * 57.2958;
        case "deg":
          return value;
        default:
          return NaN;
      }
    }

    let a = toCm(unit1, first);
    let b = toCm(unit2, second);
    let C = toDeg(unit3, third);

    if ([a, b, C].every((x) => typeof x === "number" && !isNaN(x))) {
      let c = Math.sqrt(
        a ** 2 + b ** 2 - 2 * a * b * Math.cos((C * Math.PI) / 180)
      );
      c = Math.round(c * 1000) / 1000;

      let p = a + b + c;
      let s = p / 2;
      let t = Math.sqrt(s * (s - a) * (s - b) * (s - c));
      t = Math.round(t * 10000) / 10000;

      let h_a = (2 * t) / a;
      let h_b = (2 * t) / b;
      let h_c = (2 * t) / c;

      let alpha =
        (Math.acos((b ** 2 + c ** 2 - a ** 2) / (2 * b * c)) * 180) / Math.PI;
      let beta =
        (Math.acos((a ** 2 + c ** 2 - b ** 2) / (2 * a * c)) * 180) / Math.PI;
      let gamma = 180 - alpha - beta;

      let r = t / s;
      let R = (a * b * c) / (4 * r * s);

      let m_a = Math.sqrt(2 * b ** 2 + 2 * c ** 2 - a ** 2) / 2;
      let m_b = Math.sqrt(2 * c ** 2 + 2 * a ** 2 - b ** 2) / 2;
      let m_c = Math.sqrt(2 * a ** 2 + 2 * b ** 2 - c ** 2) / 2;

      return {
        tech_a: a,
        tech_b: b,
        tech_c: c,
        tech_t: t,
        tech_s: s,
        tech_p: p,
        tech_alpha: alpha,
        tech_beta: beta,
        tech_gema: gamma,
        tech_h_a: h_a,
        tech_h_b: h_b,
        tech_h_c: h_c,
        tech_m_a: m_a,
        tech_m_b: m_b,
        tech_m_c: m_c,
        tech_r: r,
        tech_R: R,
      };
    } else {
      return { error: "Please Check Your Input." };
    }
  }

  /** getCalculationRadiusCircleCalculator
   * POST: /api/calculators-lol/radius-of-a-circle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationRadiusCircleCalculator(body) {
    let operations = body.tech_operations;
    let first = body.tech_first;
    let unit1 = body.tech_unit1;
    let second = body.tech_second;
    let unit2 = body.tech_unit2;

    let foot, centi;
    function conCm(a, b) {
      if (a == "mm") {
        centi = b / 10;
      } else if (a == "cm") {
        centi = b * 1;
      } else if (a == "dm") {
        centi = b * 10;
      } else if (a == "m") {
        centi = b * 100;
      } else if (a == "km") {
        centi = b * 100000;
      } else if (a == "in") {
        centi = b * 2.54;
      } else if (a == "ft") {
        centi = b * 30.48;
      } else if (a == "yd") {
        centi = b * 91.44;
      } else if (a == "mi") {
        centi = b * 160900;
      } else if (a == "nmi") {
        centi = b * 185200;
      }
      return centi;
    }
    function conCmSq(a, b) {
      if (a == "mm²") {
        foot = b / 10;
      } else if (a == "cm²") {
        foot = b * 1;
      } else if (a == "dm²") {
        foot = b * 10;
      } else if (a == "m²") {
        foot = b * 100;
      } else if (a == "km²") {
        foot = b * 100000;
      } else if (a == "in²") {
        foot = b * 2.54;
      } else if (a == "ft²") {
        foot = b * 30.48;
      } else if (a == "yd²") {
        foot = b * 91.44;
      } else if (a == "mi²") {
        foot = b * 160900;
      } else if (a == "a") {
        foot = b * 1000000;
      } else if (a == "da") {
        foot = b * 1000;
      } else if (a == "ha") {
        foot = b * 100000000;
      } else if (a == "ac") {
        foot = b * 40468564.224;
      } else if (a == "sf") {
        foot = b * 71224673.03424;
      }
      return foot;
    }

    let radius, diameter, area, circum;

    if (operations === "1") {
      let converted = conCm(unit1, first);
      if (isFinite(converted)) {
        radius = converted / (2 * 3.14);
        diameter = 2 * radius;
        area = Math.pow(radius, 2) * 3.14;
        return {
          tech_diameter: diameter,
          tech_area: area,
          tech_radius: radius,
        };
      }
    } else if (operations === "2") {
      let converted = conCmSq(unit2, second);
      if (isFinite(converted)) {
        radius = Math.sqrt(converted / 3.14);
        diameter = 2 * radius;
        circum = 2 * 3.14 * radius;
        return {
          tech_diameter: diameter,
          tech_radius: radius,
          tech_circum: circum,
        };
      }
    } else if (operations === "3") {
      let converted = conCm(unit1, first);
      if (isFinite(converted)) {
        radius = converted / 2;
        circum = 2 * 3.14 * radius;
        area = Math.pow(radius, 2) * 3.14;
        return {
          tech_radius: radius,
          tech_circum: circum,
          tech_area: area,
        };
      }
    }

    return { error: "Please Check Your Input." };
  }

  /** getCalculationEquilateralTriangleCalculator
   * POST: /api/calculators-lol/equilateral-triangle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationEquilateralTriangleCalculator(body) {
    let operations = body.tech_operations;
    let first = body.tech_first;
    let unit1 = body.tech_unit1;
    let a, p, s, k, h;

    if (operations === "side" && isFinite(first)) {
      a = first;
      p = a * 3;
      s = (3 * a) / 2;
      k = (1 / 4) * Math.sqrt(3) * Math.pow(a, 2);
      h = (1 / 2) * Math.sqrt(3) * a;
    } else if (operations === "perimeter" && isFinite(first)) {
      a = first / 3;
      p = first;
      s = (3 * a) / 2;
      k = (1 / 4) * Math.sqrt(3) * Math.pow(a, 2);
      h = (1 / 2) * Math.sqrt(3) * a;
    } else if (operations === "semiperimeter" && isFinite(first)) {
      a = (first * 2) / 3;
      p = 3 * a;
      s = first;
      k = (1 / 4) * Math.sqrt(3) * Math.pow(a, 2);
      h = (1 / 2) * Math.sqrt(3) * a;
    } else if (operations === "area" && isFinite(first)) {
      a = 2 * Math.sqrt(first / Math.sqrt(3));
      p = 3 * a;
      s = (3 * a) / 2;
      k = first;
      h = (1 / 2) * Math.sqrt(3) * a;
    } else if (operations === "altitude" && isFinite(first)) {
      a = 2 * Math.sqrt(3) * first;
      p = 3 * a;
      s = (3 * a) / 2;
      k = (1 / 4) * Math.sqrt(3) * Math.pow(a, 2);
      h = first;
    } else {
      return { error: "Please Check Your Input." };
    }

    return {
      tech_a: a,
      tech_k: k,
      tech_p: p,
      tech_s: s,
      tech_h: h,
      tech_unit: unit1,
    };
  }

  /** getCalculationPointOfIntersectionCalculator
   * POST: /api/calculators-lol/point-of-intersection
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPointOfIntersectionCalculator(body) {
    let x1 = parseFloat(body.tech_x1);
    let y1 = parseFloat(body.tech_y1);
    let c1 = parseFloat(body.tech_c1);
    let x2 = parseFloat(body.tech_x2);
    let y2 = parseFloat(body.tech_y2);
    let c2 = parseFloat(body.tech_c2);

    let result = {};

    if (
      !isNaN(x1) &&
      !isNaN(y1) &&
      !isNaN(c1) &&
      !isNaN(x2) &&
      !isNaN(y2) &&
      !isNaN(c2)
    ) {
      if ((x1 === x2 && y1 === y2) || (x1 === y1 && x2 === y2)) {
        result.x = "-Infinity";
        result.y = "Infinity";
        result.error = "Both Lines are Parallel.";
        return result;
      }

      c1 = -c1;
      c2 = -c2;
      let const1 = -c1;
      let const2 = -c2;

      let x = (y1 * c2 - y2 * c1) / (x1 * y2 - x2 * y1);
      let y = (x2 * c1 - x1 * c2) / (x1 * y2 - x2 * y1);

      let x1num = y1 * c2 - y2 * c1;
      let x1den = x1 * y2 - x2 * y1;
      let y1num = x2 * c1 - x1 * c2;
      let y1den = x1 * y2 - x2 * y1;

      let th = 0;
      let Line1 = {};
      let Line2 = {};

      let max = Math.max(Math.abs(x), Math.abs(y));
      th = Math.round(max) + 100;

      for (let i = -th; i < th; i++) {
        Line1[i] = const1 / y1 - (x1 * i) / y1;
        Line2[i] = const2 / y2 - (x2 * i) / y2;
      }

      result.tech_x = x;
      result.tech_y = y;
      result.tech_th = th;
      result.tech_x1num = x1num;
      result.tech_x1den = x1den;
      result.tech_y1num = y1num;
      result.tech_y1den = y1den;
      result.tech_Line1 = Line1;
      result.tech_Line2 = Line2;
      return result;
    } else {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /** getCalculationExponentialFunctionCalculator
   * POST: /api/calculators-lol/exponential-function-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationExponentialFunctionCalculator(body) {
    let t1 = parseFloat(body.tech_t1);
    let y1 = parseFloat(body.tech_y1);
    let t2 = parseFloat(body.tech_t2);
    let y2 = parseFloat(body.tech_y2);
    let point_optional =
      body.tech_point_optional !== undefined
        ? parseFloat(body.tech_point_optional)
        : null;

    let result = {};

    if (!isNaN(t1) && !isNaN(y1) && !isNaN(t2) && !isNaN(y2)) {
      if (y1 !== y2 && t1 !== t2 && y1 > 0 && y2 > 0) {
        let y = y1 / y2;
        let natural_log = Math.log(y);
        let time_minus = t1 - t2;
        let time = 1 / time_minus;
        let k = parseFloat((time * natural_log).toFixed(4));

        let exp_power = -1 * k * t2;
        let e = Math.exp(exp_power);
        let A = parseFloat((y2 * e).toFixed(4));

        let exp_fun =
          point_optional !== null
            ? Math.exp(k * point_optional)
            : Math.exp(k * 2);

        let f = parseFloat((A * exp_fun).toFixed(4));

        result.tech_k = k;
        result.tech_A = A;
        result.tech_f = f;
        return result;
      } else {
        result.error = "Please! Check Your Input.";
        return result;
      }
    } else {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /** getCalculationPowerof10Calculator
   * POST: /api/calculators-lol/exponential-function-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPowerof10Calculator(body) {
    let input = body.tech_input;

    let result = {};

    try {
      // Safely evaluate the input using Function constructor instead of eval
      let exp = Function('"use strict"; return (' + input + ")")();

      if (typeof exp === "number" && !isNaN(exp)) {
        let output = Math.pow(10, exp);
        result.tech_result = output;
        result.tech_x = exp;
      } else {
        result.error = "Please! Check Your Input.";
      }
    } catch (e) {
      result.error = "Please! Check Your Input.";
    }

    return result;
  }

  /** getCalculationSlopePercentageCalculator
   * POST: /api/calculators-lol/slope-percentage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationSlopePercentageCalculator(body) {
    let rise = parseFloat(body.tech_rise);
    let run = parseFloat(body.tech_run);
    let rise_unit = body.tech_rise_unit;
    let run_unit = body.tech_run_unit;

    let result = {};

    // Unit conversion for rise
    if (rise_unit) {
      if (rise_unit == "m") {
        rise = rise;
      } else if (rise_unit == "mm") {
        rise = rise * 1000;
      } else if (rise_unit == "cm") {
        rise = rise * 100;
      } else if (rise_unit == "km") {
        rise = rise * 0.001;
      } else if (rise_unit == "in") {
        rise = rise * 39.37;
      } else if (rise_unit == "ft") {
        rise = rise * 3.281;
      }
    }
    if (run_unit) {
      if (run_unit == "m") {
        run = run;
      } else if (run_unit == "mm") {
        run = run * 1000;
      } else if (run_unit == "cm") {
        run = run * 100;
      } else if (run_unit == "km") {
        run = run * 0.001;
      } else if (run_unit == "in") {
        run = run * 39.37;
      } else if (run_unit == "ft") {
        run = run * 3.281;
      }
    }

    if (!isNaN(rise)) {
      if (run === 0) {
        result.error = "The run cannot be zero.";
        return result;
      }

      let slopePercentage = (rise / run) * 100;
      let slopeAngle = Math.atan(rise / run);
      let slopeAngleDegrees = slopeAngle * (180 / Math.PI);

      result.tech_slopeAngle = slopeAngle;
      result.tech_slopeAngleDegrees = slopeAngleDegrees;
      result.tech_slopePercentage = slopePercentage;
      return result;
    } else {
      result.error = "Please check your input.";
      return result;
    }
  }

  /** getCalculationChangeOfBaseFormulaCalculator
   * POST: /api/calculators-lol/change-of-base-formula-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationChangeOfBaseFormulaCalculator(body) {
    let x = parseFloat(body.tech_x);
    let a = parseFloat(body.tech_a);
    let b = parseFloat(body.tech_b);

    let result = {};

    if (!isNaN(x) && !isNaN(a) && !isNaN(b)) {
      if (a <= 0) {
        result.error =
          "Number of 'a' value cannot be equal to or less than zero.";
        return result;
      }

      if (b <= 0) {
        result.error =
          "Number of 'b' value cannot be equal to or less than zero.";
        return result;
      }

      let log_one = Math.log(x) / Math.log(a); // log base a of x
      let log_two = Math.log(x) / Math.log(b); // log base b of x
      let log_three = Math.log(a) / Math.log(b); // log base b of a

      if (log_three <= 0) {
        result.error =
          "Logarithm of a or b cannot be equal to or less than zero.";
        return result;
      }

      let answer = log_two / log_three;

      result.tech_answer = answer;
      result.tech_log_one = log_one;
      result.tech_log_two = log_two;
      result.tech_log_three = log_three;
      return result;
    } else {
      result.error = "Please Check Your Input.";
      return result;
    }
  }

  /** getCalculationCompletingTheSquareCalculator
   * POST: /api/calculators-lol/completing-the-square-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCompletingTheSquareCalculator(body) {
    let A = parseFloat(body.tech_A);
    let B = parseFloat(body.tech_B);
    let C = parseFloat(body.tech_C);

    let result = {};

    if (!isNaN(A) && !isNaN(B) && !isNaN(C)) {
      if (A === 0) {
        result.error = "A cannot be zero.";
        return result;
      }

      let firstx = +(-B / (2 * A)).toFixed(3);
      let first_part = A * Math.pow(firstx, 2);
      let second_part = B * firstx;

      let eq = "";
      if (second_part < 0 && C < 0) {
        eq = `${first_part} ${second_part} ${C}`;
      } else if (second_part < 0 && C >= 0) {
        eq = `${first_part} ${second_part} + ${C}`;
      } else if (second_part >= 0 && C < 0) {
        eq = `${first_part} + ${second_part} ${C}`;
      } else {
        eq = `${first_part} + ${second_part} + ${C}`;
      }

      let yaxis;
      try {
        yaxis = Function('"use strict"; return (' + eq + ")")();
        yaxis = +yaxis.toFixed(3);
      } catch (e) {
        result.error = "Invalid expression generated.";
        return result;
      }

      let left_side = B / A;
      let C_ = -C / A;
      let right_side = C_ + Math.pow(B, 2) / Math.pow(2 * A, 2);

      let x1, x2;

      if (right_side > 0) {
        x1 = +(-left_side / 2 + Math.sqrt(right_side)).toFixed(4);
        x2 = +(-left_side / 2 - Math.sqrt(right_side)).toFixed(4);
        result.tech_fact =
          `${A}(x ${x1 < 0 ? "+ " + -x1 : "- " + x1})` +
          `(x ${x2 < 0 ? "+ " + -x2 : "- " + x2})`;
        result.tech_roots = `x₁ = ${x1} , x₂ = ${x2}`;
      } else if (right_side < 0) {
        let imaginary = Math.sqrt(-right_side).toFixed(4);
        let base = (-left_side / 2).toFixed(4);
        x1 = `${base} + ${imaginary}`;
        x2 = `${base} - ${imaginary}`;
        result.tech_fact = `${A}(x - (${x1} i))(x - (${x2} i))`;
        result.tech_roots = `x₁ = ${x1} i<br> x₂ = ${x2} i`;
      } else {
        x1 = +(-left_side / 2).toFixed(4);
        result.tech_fact = `${A}(x ${x1 < 0 ? "+ " + -x1 : "- " + x1})^2`;
        result.tech_roots = `x = ${x1}`;
      }

      result.tech_B = B;
      result.tech_C = C;
      result.tech_x1 = x1;
      result.tech_x2 = x2 || null;
      return result;
    } else {
      result.error = "Please Check Your Input.";
      return result;
    }
  }

  /** getCalculationCubeRootCalculator
   * POST: /api/calculators-lol/cube-root-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCubeRootCalculator(body) {
    let number = parseFloat(body.tech_number);
    let result = {};

    if (!isNaN(number)) {
      let cube_root = Math.cbrt(number); // Handles negative numbers correctly
      result.tech_cube_root = cube_root;
      return result;
    } else {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /** getCalculationTruncatedPyramidCalculator
   * POST: /api/calculators-lol/truncated-pyramid-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationTruncatedPyramidCalculator(body) {
    let ubl = parseFloat(body.tech_ubl);
    let ubw = parseFloat(body.tech_ubw);
    let lbl = parseFloat(body.tech_lbl);
    let lbw = parseFloat(body.tech_lbw);
    let height = parseFloat(body.tech_height);

    let result = {};

    if (
      !isNaN(ubl) &&
      !isNaN(ubw) &&
      !isNaN(lbl) &&
      !isNaN(lbw) &&
      !isNaN(height)
    ) {
      let DL = +Math.sqrt(Math.pow(lbl, 2) + Math.pow(lbw, 2)).toFixed(2);
      let DT = +Math.sqrt(Math.pow(ubl, 2) + Math.pow(ubw, 2)).toFixed(2);
      let dia = DL / 2 - DT / 2;
      let HL = +Math.sqrt(Math.pow(dia, 2) + Math.pow(height, 2)).toFixed(2);

      let sL = lbl / 2;
      let sW = lbw / 2;
      let si = ubl / 2;
      let sw = ubw / 2;

      let c1 = sW - sw;
      let c2 = sL - si;

      let slA = +Math.sqrt(Math.pow(c1, 2) + Math.pow(height, 2)).toFixed(2);
      let slB = +Math.sqrt(Math.pow(c2, 2) + Math.pow(height, 2)).toFixed(2);

      let a = +(Math.asin(height / HL) * (180 / Math.PI)).toFixed(2);
      let b = +(Math.atan(height / c1) * (180 / Math.PI)).toFixed(2);
      let c = +(Math.atan(height / c2) * (180 / Math.PI)).toFixed(2);

      result.tech_DL = DL;
      result.tech_DT = DT;
      result.tech_HL = HL;
      result.tech_slA = slA;
      result.tech_slB = slB;
      result.tech_a = a;
      result.tech_b = b;
      result.tech_c = c;
      return result;
    } else {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /** getCalculationMixedNumberCalculator
   * POST: /api/calculators-lol/mixed-number-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMixedNumberCalculator(body) {
    let n1 = parseFloat(body.tech_n1);
    let d1 = parseFloat(body.tech_d1);
    let n2 = parseFloat(body.tech_n2);
    let d2 = parseFloat(body.tech_d2);
    let s1 = parseFloat(body.tech_s1);
    let s2 = parseFloat(body.tech_s2);
    let action = body.tech_action;

    let result = {};

    if (!isNaN(n1) && !isNaN(d1) && !isNaN(n2) && !isNaN(d2)) {
      // Convert to improper fractions if whole parts exist
      if (!isNaN(s1)) {
        if (s1 < 0 && n1 > 0) n1 *= -1;
        n1 = d1 * s1 + n1;
      }
      if (!isNaN(s2)) {
        if (s2 < 0 && n2 > 0) n2 *= -1;
        n2 = d2 * s2 + n2;
      }

      let totalN = 0,
        totalD = 0;

      switch (action) {
        case "+":
          totalN = n1 * d2 + n2 * d1;
          totalD = d1 * d2;
          break;
        case "-":
          totalN = n1 * d2 - n2 * d1;
          totalD = d1 * d2;
          break;
        case "×":
          totalN = n1 * n2;
          totalD = d1 * d2;
          break;
        case "÷":
          totalN = n1 * d2;
          totalD = n2 * d1;
          break;
        default:
          result.error = "Invalid operation";
          return result;
      }

      // GCD and Reduce
      function gcd(a, b) {
        a = Math.abs(a);
        b = Math.abs(b);
        if (b === 0) return 1;
        while (b !== 0) {
          [a, b] = [b, a % b];
        }
        return a;
      }

      function reduce(num, den) {
        let g = gcd(num, den);
        return [num / g, den / g];
      }

      let g = gcd(totalN, totalD);
      let [upr, btm] = reduce(totalN, totalD);

      result.tech_upr = upr;
      result.tech_btm = btm;
      result.tech_N1 = n1;
      result.tech_N2 = n2;
      result.tech_D1 = d1;
      result.tech_D2 = d2;
      result.tech_totalN = totalN;
      result.tech_totalD = totalD;
      result.tech_g = g;

      return result;
    } else {
      result.error = "Please fill all fields.";
      return result;
    }
  }

  /** getCalculationFractionSimplifierCalculator
   * POST: /api/calculators-lol/fraction-simplifier-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationFractionSimplifierCalculator(body) {
    let n1 = parseFloat(body.tech_n1); // Optional whole number
    let n2 = parseFloat(body.tech_n2); // Numerator
    let d1 = parseFloat(body.tech_d1); // Denominator

    let result = {};

    if (!isNaN(n2) && !isNaN(d1)) {
      let totalN = n2;
      let totalD = d1;

      if (!isNaN(n1)) {
        if (n1 < 0 && totalN > 0) {
          totalN *= -1;
        }
        totalN = totalD * n1 + totalN;
      }

      function gcd(a, b) {
        a = Math.abs(a);
        b = Math.abs(b);
        while (b !== 0) {
          [a, b] = [b, a % b];
        }
        return a || 1;
      }

      function reduce(num, den) {
        const g = gcd(num, den);
        return [num / g, den / g];
      }

      const g = gcd(totalN, totalD);
      const [upr, btm] = reduce(totalN, totalD);

      result.tech_upr = upr;
      result.tech_btm = btm;
      result.tech_totalN = totalN;
      result.tech_totalD = totalD;
      result.tech_g = g;
      return result;
    } else {
      result.error = "Please Check Your Input.";
      return result;
    }
  }

  /** getCalculationDeterminantCalculator
   * POST: /api/calculators-lol/determinant-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDeterminantCalculator(body) {
    let det = 0;
    let check = true;

    let dtrmn_slct_method = body.tech_dtrmn_slct_method;

    dtrmn_slct_method = parseInt(dtrmn_slct_method);
    if (![2, 3, 4, 5].includes(dtrmn_slct_method)) {
      return { error: "Matrix size not supported. Only 2x2 to 5x5 supported." };
    }

    let matrix = [];

    for (let i = 0; i < dtrmn_slct_method; i++) {
      let row = [];
      for (let j = 0; j < dtrmn_slct_method; j++) {
        let key = `tech_dtrmn_${i}_${j}`;
        let val = parseFloat(body[key]);
        if (isNaN(val)) {
          return { error: "Please Check Your Input." };
        }
        row.push(val);
      }
      matrix.push(row);
    }

    try {
      det = math.round(math.det(matrix), 6);
      return {
        tech_ans: det,
      };
    } catch (e) {
      return { error: "Determinant could not be calculated." };
    }
  }
  /** getCalculationEigenvectorCalculator
   * POST: /api/calculators-lol/eigenvectors-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationEigenvectorCalculator(body) {
    let matrix = body.tech_matrix;
    let matrix_0_0 = body.tech_matrix_0_0;
    let matrix_0_1 = body.tech_matrix_0_1;
    let matrix_0_2 = body.tech_matrix_0_2;
    let matrix_1_0 = body.tech_matrix_1_0;
    let matrix_1_1 = body.tech_matrix_1_1;
    let matrix_1_2 = body.tech_matrix_1_2;
    let matrix_2_0 = body.tech_matrix_2_0;
    let matrix_2_1 = body.tech_matrix_2_1;
    let matrix_2_2 = body.tech_matrix_2_2;

    function isNumeric(val) {
      return !isNaN(parseFloat(val)) && isFinite(val);
    }

    try {
      let params = {};
      if (
        matrix === "2" &&
        isNumeric(matrix_0_0) &&
        isNumeric(matrix_0_1) &&
        isNumeric(matrix_1_0) &&
        isNumeric(matrix_1_1)
      ) {
        params = {
          matrix,
          matrix_0_0,
          matrix_0_1,
          matrix_1_0,
          matrix_1_1,
        };
      } else if (
        matrix === "3" &&
        isNumeric(matrix_0_0) &&
        isNumeric(matrix_0_1) &&
        isNumeric(matrix_0_2) &&
        isNumeric(matrix_1_0) &&
        isNumeric(matrix_1_1) &&
        isNumeric(matrix_1_2) &&
        isNumeric(matrix_2_0) &&
        isNumeric(matrix_2_1) &&
        isNumeric(matrix_2_2)
      ) {
        params = {
          matrix,
          matrix_0_0,
          matrix_0_1,
          matrix_0_2,
          matrix_1_0,
          matrix_1_1,
          matrix_1_2,
          matrix_2_0,
          matrix_2_1,
          matrix_2_2,
        };
      } else {
        return { error: "Please! Check Your Input." };
      }

      const response = await axios.get("http://167.172.134.148/eigenvectors", {
        params,
      });
      const buffer = response.data.split("@@@");

      if (matrix === "2") {
        return {
          tech_eigvecs: buffer[0],
          tech_d: buffer[1],
          tech_dtrmnt: buffer[2],
          tech_l1: buffer[3],
          tech_l2: buffer[4],
          tech_mul: buffer[5],
          tech_eigvals: buffer[6],
          tech_eigvals1: buffer[7],
          tech_eigvals2: buffer[8],
          tech_a: buffer[9],
          tech_eigvecs1: buffer[10],
          tech_eigvecs2: buffer[11],
          tech_b: buffer[12],
          tech_res1: buffer[13],
          tech_res2: buffer[14],
        };
      } else {
        return {
          tech_eigvecs: buffer[0],
          tech_d: buffer[1],
          tech_dtrmnt: buffer[2],
          tech_l1: buffer[3],
          tech_l2: buffer[4],
          tech_l3: buffer[5],
          tech_mul: buffer[6],
          tech_eigvals: buffer[7],
          tech_eigvals1: buffer[8],
          tech_eigvals2: buffer[9],
          tech_eigvals3: buffer[10],
          tech_a: buffer[11],
          tech_eigvecs1: buffer[12],
          tech_eigvecs2: buffer[13],
          tech_eigvecs3: buffer[14],
          tech_b: buffer[15],
          tech_res1: buffer[16],
          tech_res2: buffer[17],
          tech_res3: buffer[18],
          tech_c: buffer[19],
        };
      }
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }
  /** getCalculationNullSpaceCalculator
   * POST: /api/calculators-lol/null-space-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationNullSpaceCalculator(body) {
    let row = body.tech_row;
    let colum = body.tech_colum;

    let input = "";

    for (let i = 0; i < row; i++) {
      for (let j = 0; j < colum; j++) {
        let key = `tech_matrix_${i}_${j}`;
        if (!isNumeric(body[key])) {
          return { error: "Please enter only numeric values." };
        }

        input += body[key];
        if (j !== colum - 1) input += ",";
      }
      if (i !== row - 1) input += "@@";
    }

    try {
      const response = await axios.get("http://167.172.134.148/null", {
        params: { mat: input },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");
      let reff = buffer[0].replace("\\left( \\left[", "\\left[");
      reff = reff.split("\\left(")[0].split(",");

      return {
        tech_rref: reff[0],
        tech_null: buffer[1],
        tech_enter: buffer[2],
        tech_total: buffer[3],
        tech_input: input,
        tech_row: row,
        tech_colum: colum,
      };
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }

    function isNumeric(val) {
      return !isNaN(parseFloat(val)) && isFinite(val);
    }
  }

  /** getCalculationMatrixMultiplicationCalculator
   * POST: /api/calculators-lol/matrix-multiplication-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMatrixMultiplicationCalculator(body) {
    let rows1 = body.tech_rows1;
    let columns1 = body.tech_columns1;
    let matrix2 = body.tech_matrix2;
    let matrix22 = body.tech_matrix22;

    let r = [],
      m = [],
      l = [];

    function isNumeric(val) {
      return !isNaN(parseFloat(val)) && isFinite(val);
    }

    if (columns1 != matrix2) {
      return {
        error:
          "The number of columns in the first matrix should be equal to the number of rows in the second.",
      };
    }

    // First matrix validation and flattening
    for (let i = 1; i <= rows1; i++) {
      for (let j = 1; j <= columns1; j++) {
        let key = `tech_matrix${i}_${j}`;
        if (body[key] !== undefined && isNumeric(body[key])) {
          r.push(parseFloat(body[key]));
        } else {
          return { error: "Please! Check Your Input.111" };
        }
      }
    }

    // Second matrix validation and flattening
    for (let i = 1; i <= matrix2; i++) {
      for (let j = 1; j <= matrix22; j++) {
        let key = `tech_matrix3${i}_${j}`;
        if (body[key] !== undefined && isNumeric(body[key])) {
          m.push(parseFloat(body[key]));
        } else {
          return { error: "Please! Check Your Input.2222" };
        }
      }
    }

    // Matrix multiplication
    let result = [];
    for (let i = 1; i <= rows1; i++) {
      result[i] = [];
      for (let j = 1; j <= matrix22; j++) {
        result[i][j] = 0;
        for (let k = 1; k <= matrix2; k++) {
          result[i][j] +=
            parseFloat(body[`tech_matrix${i}_${k}`]) *
            parseFloat(body[`tech_matrix3${k}_${j}`]);
        }
        l.push(result[i][j]);
      }
    }

    return {
      tech_r: r,
      tech_l: l,
    };
  }

  /** getCalculationSGPAToPercentageCalculator
   * POST: /api/calculators-lol/sgpa-to-percentage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSGPAToPercentageCalculator(body) {
    let type = body.tech_type;
    let sgp = body.tech_sgp;
    let sgpa = body.tech_sgpa;
    let selection = body.tech_selection;
    let number_of_semesters = body.tech_number_of_semesters;
    let sum = body.tech_sum;

    function isNumeric(val) {
      return !isNaN(parseFloat(val)) && isFinite(val);
    }

    if (type === "first") {
      if (selection === "1") {
        if (isNumeric(sgp)) {
          let single_value = (sgp - 0.75) * 10;
          return {
            tech_final_gpa: single_value,
          };
        } else {
          return { error: "Please Check Your Input." };
        }
      } else if (selection === "2") {
        if (isNumeric(number_of_semesters) && isNumeric(sum)) {
          if (number_of_semesters > 0 && sum > 0) {
            if (number_of_semesters < 25) {
              let semester = number_of_semesters * 10;
              if (sum > semester) {
                return {
                  error: `Sgpa should be within ${semester}`,
                };
              } else {
                let final_result = sum / number_of_semesters;
                return {
                  tech_final_result: final_result,
                };
              }
            } else {
              return { error: "Enter number of semester below 25." };
            }
          } else {
            return { error: "Please! Enter Positive Number." };
          }
        } else {
          return { error: "Please Check Your Input." };
        }
      }
    } else if (type === "second") {
      if (!Array.isArray(sgpa)) {
        return { error: "Please provide SGPA as an array." };
      }

      let count = sgpa.length;
      let total = 0;

      for (let i = 0; i < count; i++) {
        if (isNumeric(sgpa[i])) {
          total += parseFloat(sgpa[i]);
        } else {
          return { error: "Please Check Your Input." };
        }
      }

      let percentage = total / count;
      let final_gpa = (percentage - 0.75) * 10;

      return {
        tech_final_gpa: final_gpa,
        tech_percentage: percentage,
        tech_sgpa: sgpa,
      };
    }

    return { error: "Invalid type." };
  }
  /** getCalculationHexCalculator
   * POST: /api/calculators-lol/hex-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationHexCalculator(body) {
    let type = body.tech_type;
    let bnr_frs = body.tech_bnr_frs;
    let bnr_sec = body.tech_bnr_sec;
    let bnr_slc = body.tech_bnr_slc;
    let options = body.tech_options;
    let nmbr = body.tech_nmbr;

    function bnrCal(fN, sN, op) {
      let rN, binary, decimal, hexa, octal, operate;

      if (op === "add") {
        rN = fN + sN;
        operate = "+";
      } else if (op === "sub") {
        rN = fN - sN;
        operate = "-";
      } else if (op === "mul") {
        rN = fN * sN;
        operate = "×";
      } else if (op === "divide") {
        rN = fN / sN;
        operate = "÷";
      } else {
        return null;
      }

      decimal = rN;
      const absVal = Math.abs(decimal);
      binary = (decimal < 0 ? "-" : "") + parseInt(absVal, 10).toString(2);
      hexa =
        (decimal < 0 ? "-" : "") +
        parseInt(absVal, 10).toString(16).toUpperCase();
      octal = (decimal < 0 ? "-" : "") + parseInt(absVal, 10).toString(8);

      return { binary, decimal, hexa, octal, operate };
    }

    if (type === "first") {
      if (!bnr_frs || !bnr_sec) {
        return { error: "Please! Check Your Input." };
      }

      let fN = parseInt(bnr_frs, 16);
      let sN = parseInt(bnr_sec, 16);
      let result = bnrCal(fN, sN, bnr_slc);

      if (!result) return { error: "Invalid operation." };

      return {
        tech_type: type,
        tech_first_ans1: bnr_frs,
        tech_second_ans1: bnr_sec,
        tech_first_ans: fN,
        tech_second_ans: sN,
        tech_bn: result.binary,
        tech_dc: result.decimal,
        tech_hx: result.hexa,
        tech_oc: result.octal,
        tech_op: result.operate,
      };
    }

    if (type === "second") {
      if (!nmbr) return { error: "Please! Check Your Input." };

      let answer, text;

      switch (options) {
        case "1":
          answer = parseInt(nmbr, 16).toString(10);
          text = "Decimal numeral";
          break;
        case "2":
          answer = parseInt(nmbr, 10).toString(16);
          text = "Hex numeral";
          break;
        case "3":
          answer = parseInt(nmbr, 16).toString(2);
          text = "Binary numeral";
          break;
        case "4":
          answer = parseInt(nmbr, 2).toString(16);
          text = "Hex numeral";
          break;
        default:
          return { error: "Invalid option." };
      }

      return {
        tech_type: type,
        tech_answer: answer,
        tech_text: text,
      };
    }

    return { error: "Please! Check Your Input." };
  }

  /** getCalculationMatrixTransposeCalculator
   * POST: /api/calculators-lol/matrix-transpose-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMatrixTransposeCalculator(body) {
    let matrix2 = parseInt(body.tech_matrix2);
    let matrix22 = parseInt(body.tech_matrix22);
    let second_matrix = [];
    let chuti = [];

    for (let i = 1; i <= matrix2; i++) {
      for (let j = 1; j <= matrix22; j++) {
        const key = `tech_matrix3${i}_${j}`;
        const val = body[key];

        if (val !== undefined && !isNaN(val)) {
          second_matrix.push(Number(val));
          chuti.push(`&${key}=`);
        } else {
          return { error: "Please! Check Your Input." };
        }
      }
    }

    function transpose(A) {
      let rows = A.length;
      if (rows === 0) return A;
      let cols = A[0].length;
      let result = [];

      for (let j = 0; j < cols; j++) {
        result[j] = [];
        for (let i = 0; i < rows; i++) {
          result[j][i] = A[i][j];
        }
      }

      return result;
    }

    const mul = matrix2 * matrix22;

    if (mul === second_matrix.length) {
      const zain = [];
      for (let i = 0; i < matrix2; i++) {
        zain.push(second_matrix.slice(i * matrix22, (i + 1) * matrix22));
      }
      const jawab = transpose(zain);

      return {
        tech_zain: zain,
        tech_jawab: jawab,
        tech_chuti: chuti,
        tech_second_matrix: second_matrix,
      };
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationWeightedAverageCalculator
   * POST: /api/calculators-lol/weighted-average-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationWeightedAverageCalculator(body) {
    let weight = body.tech_weight;
    let value = body.tech_value;

    if (!Array.isArray(weight) || !Array.isArray(value)) {
      return { error: "Input must be arrays of numbers." };
    }

    let i = 0;
    let weight_sum = 0;
    let weighted_average = 0;

    while (i < weight.length && i < value.length) {
      let w = parseFloat(weight[i]);
      let v = parseFloat(value[i]);

      if (!isFinite(w) || !isFinite(v)) {
        return { error: "Please! Check Your Input." };
      }

      weight_sum += w;
      weighted_average += w * v;
      i++;
    }

    if (weight_sum === 0) {
      return { error: "Total weight cannot be zero." };
    }

    let final_ans = weighted_average / weight_sum;

    return {
      tech_weight_sum: weight_sum,
      tech_weighted_average: final_ans,
      tech_wv: weight.length,
      tech_v: value.length,
      tech_values: value,
      tech_weights: weight,
    };
  }

  /** getCalculationTestGradeCalculator
   * POST: /api/calculators-lol/test-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTestGradeCalculator(body) {
    let grades = body.tech_grades;
    let first = body.tech_first;
    let second = body.tech_second;
    let increment = body.tech_increment;
    let aplus = body.tech_aplus;
    let a = body.tech_a;
    let aminus = body.tech_aminus;
    let bplus = body.tech_bplus;
    let b = body.tech_b;
    let bminus = body.tech_bminus;
    let cplus = body.tech_cplus;
    let c = body.tech_c;
    let cminus = body.tech_cminus;
    let dplus = body.tech_dplus;
    let d = body.tech_d;
    let dminus = body.tech_dminus;

    first = parseFloat(first);
    second = parseFloat(second);
    increment = Math.floor(parseFloat(increment));

    if (isNaN(first) || isNaN(second) || isNaN(increment) || increment <= 0) {
      return { error: "Please Check Your Input." };
    }

    let q_array = [],
      i_array = [],
      g_array = [],
      l_array = [],
      letter_ans = "",
      lettertbl = [],
      percenttbl = [];

    for (let j = first; j >= 0; j -= increment) {
      q_array.push(j);
    }

    for (let i = 0; i <= first; i += increment) {
      i_array.push(i);
    }

    let correct = first - second;
    let per = Math.round((100 * correct) / first);

    if (parseInt(grades) === 1) {
      a = parseFloat(a);
      b = parseFloat(b);
      c = parseFloat(c);
      d = parseFloat(d);

      if ([a, b, c, d].some(isNaN)) {
        return { error: "Please Check Your Input." };
      }
      if (a < b || b < c || c < d) {
        return { error: "Grade limits are not in correct descending order." };
      }

      lettertbl = ["A", "B", "C", "D", "F"];
      percenttbl = [a, b, c, d, 0];
    } else if (parseInt(grades) === 2) {
      aplus = parseFloat(aplus);
      a = parseFloat(a);
      aminus = parseFloat(aminus);
      bplus = parseFloat(bplus);
      b = parseFloat(b);
      bminus = parseFloat(bminus);
      cplus = parseFloat(cplus);
      c = parseFloat(c);
      cminus = parseFloat(cminus);
      dplus = parseFloat(dplus);
      d = parseFloat(d);
      dminus = parseFloat(dminus);

      let limits = [
        aplus,
        a,
        aminus,
        bplus,
        b,
        bminus,
        cplus,
        c,
        cminus,
        dplus,
        d,
        dminus,
      ];

      if (limits.some(isNaN)) {
        return { error: "Please Check Your Input." };
      }

      for (let i = 0; i < limits.length - 1; i++) {
        if (limits[i] < limits[i + 1]) {
          return { error: "Grade limits are not in correct descending order." };
        }
      }

      lettertbl = [
        "A+",
        "A",
        "A-",
        "B+",
        "B",
        "B-",
        "C+",
        "C",
        "C-",
        "D+",
        "D",
        "D-",
        "F",
      ];
      percenttbl = [...limits, 0];
    }

    for (let i = 0; i < percenttbl.length; i++) {
      if (per >= percenttbl[i]) {
        letter_ans = lettertbl[i];
        break;
      }
    }

    for (let k = 0; k < q_array.length; k++) {
      let grade = Math.round((100 * q_array[k]) / first);
      for (let i = 0; i < percenttbl.length; i++) {
        if (grade >= percenttbl[i]) {
          l_array.push(lettertbl[i]);
          break;
        }
      }
      g_array.push(grade);
    }

    return {
      tech_first: first,
      tech_correct: correct,
      tech_per: per,
      tech_letter_ans: letter_ans,
      tech_q_array: q_array,
      tech_i_array: i_array,
      tech_g_array: g_array,
      tech_l_array: l_array,
    };
  }

  /** getCalculationMarksPercentageCalculator
   * POST: /api/calculators-lol/marks-percentage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMarksPercentageCalculator(body) {
    let type = body.tech_type;
    let first = body.tech_first;
    let second = body.tech_second;
    let sub_name = body.tech_sub_name; // array
    let s_marks = body.tech_s_marks; // array
    let a_marks = body.tech_a_marks; // array

    let result = {};

    if (type === "first") {
      if (isNumeric(first) && isNumeric(second)) {
        if (parseFloat(first) <= parseFloat(second)) {
          let percent = (parseFloat(first) / parseFloat(second)) * 100;
          result.tech_type = type;
          result.tech_percent = percent;
          return result;
        } else {
          return {
            error: "Total scored marks should be less than out of marks.",
          };
        }
      } else {
        return { error: "Please! Check Your Input" };
      }
    } else if (type === "second") {
      let name_array = [];
      let s_array = [];
      let a_array = [];

      if (
        Array.isArray(sub_name) &&
        Array.isArray(s_marks) &&
        Array.isArray(a_marks)
      ) {
        let y = 0;
        while (
          y < sub_name.length &&
          y < s_marks.length &&
          y < a_marks.length
        ) {
          if (sub_name[y] && isNumeric(s_marks[y]) && isNumeric(a_marks[y])) {
            name_array.push(sub_name[y]);
            s_array.push(parseFloat(s_marks[y]));
            a_array.push(parseFloat(a_marks[y]));
          } else {
            return { error: "Please! Check Your Input" };
          }
          y++;
        }

        let total_scored = s_array.reduce((a, b) => a + b, 0);
        let total_marks = a_array.reduce((a, b) => a + b, 0);
        let percent = (total_scored / total_marks) * 100;

        result.tech_name_array = name_array;
        result.tech_s_array = s_array;
        result.tech_a_array = a_array;
        result.tech_total_scored = total_scored;
        result.tech_total_marks = total_marks;
        result.tech_type = type;
        result.tech_percent = percent;
        return result;
      } else {
        return { error: "Invalid input arrays." };
      }
    }

    function isNumeric(val) {
      return !isNaN(parseFloat(val)) && isFinite(val);
    }
  }

  /** getCalculationDecimalCalculator
   * POST: /api/calculators-lol/decimal-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDecimalCalculator(body) {
    let method = body.tech_method;
    let rounding = body.tech_rounding;
    let a = body.tech_a;
    let b = body.tech_b;

    let result = {};

    if (isNumeric(a) && isNumeric(b)) {
      a = parseFloat(a);
      b = parseFloat(b);
      let ans;
      let res = "";

      switch (method) {
        case "1":
          ans = a + b;
          res = `<p class='mt-2'>a + b = ?</p> <p class='mt-2'>${a} + ${b} = ${ans}</p>`;
          break;
        case "2":
          ans = a - b;
          res = `<p class='mt-2'>a - b = ?</p> <p class='mt-2'>${a} - ${b} = ${ans}</p>`;
          break;
        case "3":
          ans = a * b;
          res = `<p class='mt-2'>a x b = ?</p> <p class='mt-2'>${a} x ${b} = ${ans}</p>`;
          break;
        case "4":
          ans = a / b;
          res = `<p class='mt-2'>a ÷ b = ?</p> <p class='mt-2'>${a} ÷ ${b} = ${ans}</p>`;
          break;
        case "5":
          // Optional decimal adjustment logic (preserved for parity with PHP)
          ans = Math.pow(a, b);
          res = `a<sup class='font-s-14'>b</sup> = ?`;
          break;
        case "6":
          ans = Math.pow(a, 1 / b);
          res = `<sup class='font-s-14'>b</sup>√a = ?`;
          break;
        case "7":
          ans = Math.log(b) / Math.log(a);
          res = `log<sub class='font-s-14'>a</sub>b = ?`;
          break;
        default:
          return { error: "Invalid method selected." };
      }

      if (rounding !== "not" && isNumeric(rounding)) {
        result.round_ans = parseFloat(ans.toFixed(parseInt(rounding)));
      }

      result.tech_ans = ans;
      result.tech_res = res;
      return result;
    } else {
      return { error: "Please! Check Your Input." };
    }

    function isNumeric(val) {
      return !isNaN(parseFloat(val)) && isFinite(val);
    }
  }

  /** getCalculationVennDiagramCalculator
   * POST: /api/calculators-lol/venn-diagram-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationVennDiagramCalculator(body) {
    let submit = (body.tech_selection || "").trim();
    let venn_name = (body.tech_venn_name || "").trim();
    let ta = (body.tech_ta || "").trim();
    let tb = (body.tech_tb || "").trim();
    let a = (body.tech_a || "").trim();
    let b = (body.tech_b || "").trim();
    let u = (body.tech_u || "").trim();
    let c = (body.tech_c || "").trim();
    let venn_name3 = (body.tech_venn_name3 || "").trim();
    let ta3 = (body.tech_ta3 || "").trim();
    let tb3 = (body.tech_tb3 || "").trim();
    let tc3 = (body.tech_tc3 || "").trim();
    let a3 = (body.tech_a3 || "").trim();
    let b3 = (body.tech_b3 || "").trim();
    let c3 = (body.tech_c3 || "").trim();
    let u3 = (body.tech_u3 || "").trim();
    let anb3 = (body.tech_anb3 || "").trim();
    let bnc3 = (body.tech_bnc3 || "").trim();
    let cna3 = (body.tech_cna3 || "").trim();
    let anbnc = (body.tech_anbnc || "").trim();

    let param = {};

    if (submit === "twoset") {
      if (
        venn_name &&
        ta &&
        tb &&
        isNumeric(a) &&
        isNumeric(b) &&
        isNumeric(u) &&
        isNumeric(c)
      ) {
        a = parseFloat(a);
        b = parseFloat(b);
        u = parseFloat(u);
        c = parseFloat(c);

        let a_only = a - c;
        let b_only = b - c;
        let res = a_only + b_only + c;
        let res2set = u - res;

        param = {
          tech_res2set: res2set,
          tech_a: a,
          tech_b: b,
          tech_c: c,
          tech_u: u,
          tech_venn_name: venn_name,
          tech_ta: ta,
          tech_tb: tb,
          tech_res: res,
        };
      } else {
        return { error: "Please! Check Your Input" };
      }
    } else if (submit === "threeset") {
      if (
        venn_name3 &&
        ta3 &&
        tb3 &&
        tc3 &&
        isNumeric(a3) &&
        isNumeric(b3) &&
        isNumeric(c3) &&
        isNumeric(u3) &&
        isNumeric(anb3) &&
        isNumeric(bnc3) &&
        isNumeric(cna3) &&
        isNumeric(anbnc)
      ) {
        a3 = parseFloat(a3);
        b3 = parseFloat(b3);
        c3 = parseFloat(c3);
        u3 = parseFloat(u3);
        anb3 = parseFloat(anb3);
        bnc3 = parseFloat(bnc3);
        cna3 = parseFloat(cna3);
        anbnc = parseFloat(anbnc);

        let ab = anb3 - anbnc;
        let bc = bnc3 - anbnc;
        let ca = cna3 - anbnc;

        let a_only = a3 - (ab + anbnc + ca);
        let b_only = b3 - (bc + anbnc + ab);
        let c_only = c3 - (bc + anbnc + ca);
        let res = a_only + b_only + c_only + ab + bc + ca + anbnc;
        let d = u3 - res;

        param = {
          tech_venn_name3: venn_name3,
          tech_ta3: ta3,
          tech_tb3: tb3,
          tech_tc3: tc3,
          tech_a3: a3,
          tech_b3: b3,
          tech_c3: c3,
          tech_u3: u3,
          tech_anb3: anb3,
          tech_bnc3: bnc3,
          tech_cna3: cna3,
          tech_anbnc: anbnc,
          tech_a_only: a_only,
          tech_b_only: b_only,
          tech_c_only: c_only,
          tech_ab: ab,
          tech_bc: bc,
          tech_ca: ca,
          tech_d: d,
          tech_res: res,
        };
      } else {
        return { error: "Please! Check Your Input" };
      }
    } else {
      return { error: "Please! Check Your Input" };
    }

    return param;

    function isNumeric(val) {
      return !isNaN(parseFloat(val)) && isFinite(val);
    }
  }

  /** getCalculationFundamentalCountingPrincipleCalculator
   * POST: /api/calculators-lol/fundamental-counting-principle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationFundamentalCountingPrincipleCalculator(body) {
    let choices = body.tech_choices; // should be an array

    let result = {};

    if (Array.isArray(choices) && choices.length > 0 && isNumeric(choices[0])) {
      let answer = 1;

      for (let value of choices) {
        if (!isNumeric(value)) {
          return { error: "Please! Check Your Input." };
        }
        answer *= parseFloat(value);
      }

      result.tech_answer = answer;
      result.tech_choices = choices;
      return result;
    } else {
      return { error: "Please! Check Your Input." };
    }

    function isNumeric(val) {
      return !isNaN(parseFloat(val)) && isFinite(val);
    }
  }

  /** getCalculationAveragePercentageCalculator
   * POST: /api/calculators-lol/average-percentage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAveragePercentageCalculator(body) {
    let same_sample = body.tech_same_sample;
    let percentage = body.tech_percentage;
    let sample = body.tech_sample;

    let result = {};
    let check = true;

    // Ensure arrays are filtered for non-empty values
    percentage = Array.isArray(percentage)
      ? percentage.filter(
          (val) => val !== "" && val !== null && val !== undefined
        )
      : [];
    sample = Array.isArray(sample)
      ? sample.filter((val) => val !== "" && val !== null && val !== undefined)
      : [];

    if (same_sample === "yes") {
      if (percentage.length < 2) check = false;
    } else {
      if (percentage.length < 2 || sample.length < 2) check = false;
    }

    if (!check) {
      return { error: "Please! Check Your Input.111" };
    }

    let percents_sum, samples_sum, resultValue;

    if (same_sample === "yes") {
      percents_sum = percentage.reduce((sum, val) => sum + parseFloat(val), 0);
      samples_sum = percentage.length;
    } else {
      let percents = [];
      let percents_show = "";
      let percents_show1 = "";

      for (let i = 0; i < percentage.length; i++) {
        let p = parseFloat(percentage[i]);
        let s = parseFloat(sample[i]);
        let product = p * s;
        percents.push(product);

        let plus = i + 1 !== percentage.length ? " + " : "";
        percents_show += `${p}\\% * ${s}${plus}`;
        percents_show1 += `${product}\\%${plus}`;
      }

      percents_sum = percents.reduce((sum, val) => sum + val, 0);
      samples_sum = sample.reduce((sum, val) => sum + parseFloat(val), 0);

      result.tech_percents_show = percents_show;
      result.tech_percents_show1 = percents_show1;
    }

    result.tech_percentage = percentage;
    result.tech_sample = sample;
    result.tech_percents_sum = percents_sum;
    result.tech_samples_sum = samples_sum;
    result.tech_same_sample = same_sample;
    result.tech_result = percents_sum / samples_sum;

    return result;
  }

  /** getCalculationLinearIndependenceCalculator
   * POST: /api/calculators-lol/linear-independence-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLinearIndependenceCalculator(body) {
    let row = body.tech_row;
    let colum = body.tech_colum;

    let check = true;

    for (let i = 0; i < row; i++) {
      for (let j = 0; j < colum; j++) {
        let key = `tech_matrix_${i}_${j}`;
        if (!isNumeric(body[key])) {
          check = false;
        }
      }
    }

    if (check) {
      return {
        tech_row: row,
        tech_colum: colum,
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }

    function isNumeric(val) {
      return !isNaN(parseFloat(val)) && isFinite(val);
    }
  }

  /** getCalculationPercentChangeCalculator
   * POST: /api/calculators-lol/percentage-change-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPercentChangeCalculator(body) {
    let initial_value = body.tech_initial_value;
    let final_value = body.tech_final_value;

    let result = {};

    if (isNumeric(initial_value) && isNumeric(final_value)) {
      initial_value = parseFloat(initial_value);
      final_value = parseFloat(final_value);

      let difference = final_value - initial_value;
      let answer = (difference / Math.abs(initial_value)) * 100;

      result.tech_answer = answer;
      result.tech_difference = difference;
      return result;
    } else {
      return {
        error: "Please provide both the initial and final values to proceed.",
      };
    }

    function isNumeric(val) {
      return !isNaN(parseFloat(val)) && isFinite(val);
    }
  }

  /** getCalculationTaylorSeriesCalculator
   * POST: /api/calculators-lol/taylor-series-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTaylorSeriesCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let point = body.tech_point;
    let find = body.tech_find ?? "";
    let n = body.tech_n;
    let withVar = body.tech_with;

    let result = {};

    // Input validation
    const unsafePattern = /[<>&]|php|print_r|print|echo|script|=|%/i;
    if (!EnterEq || unsafePattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    if (EnterEq.indexOf(withVar) === -1) {
      return { error: `Variable ${withVar} does not exist in the function` };
    }

    if (!isNumeric(point) || !isNumeric(n)) {
      return { error: "Please! Check Your Input." };
    }

    // Sanitizing the equation
    let parem = EnterEq.replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^x/g, "exp(x)")
      .replace(/e\^y/g, "exp(y)")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    try {
      const response = await axios.get("http://167.172.134.148/taylor", {
        timeout: 120000,
        params: {
          equ: parem,
          wrt: withVar,
          how: n,
          find: find,
          point: point,
        },
      });

      const buffer = response.data.split("@HA_");

      result.tech_eexe = buffer[0];
      result.tech_enter = buffer[1];
      result.tech_res = buffer[2];
      result.tech_series = buffer[3];

      if (isNumeric(find)) {
        result.tech_efun = buffer[4];
        result.tech_eser = buffer[5];
        result.tech_efv = buffer[6];
        result.tech_fsv = buffer[7];
        result.tech_err = buffer[8];
      }

      return result;
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }

    function isNumeric(val) {
      return !isNaN(parseFloat(val)) && isFinite(val);
    }
  }

  /** getCalculationDerivativeCalculator
   * POST: /api/calculators-lol/derivative-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDerivativeCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let withVar = body.tech_with;
    let how = body.tech_how;

    let result = {};

    // Input validation
    const unsafePattern = /[<>&]|php|print_r|print|echo|script|=|%/i;
    if (!EnterEq || unsafePattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    if (!EnterEq || !withVar || !how) {
      return { error: "Please! Check Your Input." };
    }

    // Equation sanitization
    let parem = EnterEq.replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^x/g, "exp(x)")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    try {
      const response = await axios.get("http://167.172.134.148/derivative", {
        timeout: 120000,
        params: {
          equ: parem,
          wrt: withVar,
          how: how,
        },
      });

      const buffer = response.data.split("@@@");

      if (parseInt(how) > 1) {
        result.tech_enter = buffer[0];
        result.tech_final_res = buffer;
      } else {
        result.tech_buffer = buffer[0];
        result.tech_ans = buffer[1];
        result.tech_enter = buffer[2];
        result.tech_simple = buffer[3];
      }

      return result;
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationCircumcenterCalculator
   * POST: /api/calculators-lol/circumcenter-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCircumcenterCalculator(body) {
    let x1 = body.tech_x1;
    let y1 = body.tech_y1;
    let x2 = body.tech_x2;
    let y2 = body.tech_y2;
    let x3 = body.tech_x3;
    let y3 = body.tech_y3;

    let result = {};

    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }

    if (
      isNumeric(x1) &&
      isNumeric(y1) &&
      isNumeric(x2) &&
      isNumeric(y2) &&
      isNumeric(x3) &&
      isNumeric(y3)
    ) {
      x1 = +x1;
      y1 = +y1;
      x2 = +x2;
      y2 = +y2;
      x3 = +x3;
      y3 = +y3;

      // Midpoints and slopes for AB, BC, CA
      let m1x = (x1 + x2) / 2;
      let m1y = (y1 + y2) / 2;
      let m2x = (x2 + x3) / 2;
      let m2y = (y2 + y3) / 2;
      let m3x = (x3 + x1) / 2;
      let m3y = (y3 + y1) / 2;

      let slopeAB = (y2 - y1) / (x2 - x1);
      let slopeBC = (y3 - y2) / (x3 - x2);
      let slopeCA = (y3 - y1) / (x3 - x1);

      let perpAB = -1 / slopeAB;
      let perpBC = -1 / slopeBC;
      let perpCA = -1 / slopeCA;

      let x, y;

      if (isFinite(perpAB) && isFinite(perpBC)) {
        let b1 = m1y - perpAB * m1x;
        let b2 = m2y - perpBC * m2x;
        x = (b2 - b1) / (perpAB - perpBC);
        y = perpAB * x + b1;
      } else if (isFinite(perpBC) && isFinite(perpCA)) {
        let b2 = m2y - perpBC * m2x;
        let b3 = m3y - perpCA * m3x;
        x = (b3 - b2) / (perpBC - perpCA);
        y = perpBC * x + b2;
      } else if (isFinite(perpAB) && isFinite(perpCA)) {
        let b1 = m1y - perpAB * m1x;
        let b3 = m3y - perpCA * m3x;
        x = (b3 - b1) / (perpAB - perpCA);
        y = perpAB * x + b1;
      } else {
        return {
          error: "Cannot calculate circumcenter due to degenerate triangle.",
        };
      }

      result.tech_x = x;
      result.tech_y = y;
      return result;
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  async getCalculationRoofPitchCalculator(body) {
    try {
      let submit = body.tech_submit;
      let x = body.tech_x;
      let y = body.tech_y;
      let unit = body.tech_unit;
      let unit_r = body.tech_unit_r;
      let unit_a = body.tech_unit_a;
      let from = body.tech_from;

      let rise = parseFloat(x);
      let run = parseFloat(y);

      // Validate numeric inputs
      if (isNaN(rise) || isNaN(run)) {
        return {
          error: "Please! Fill all the Input Fields",
        };
      }

      let pitch, rafter, angle, xValue, P;

      // Helper function to convert to meters
      const convertToMeters = (value, unitType) => {
        switch (unitType) {
          case "ft":
            return value / 3.281;
          case "in":
            return value / 39.37;
          case "yd":
            return value / 1.094;
          default:
            return value;
        }
      };

      // Case 1: Rise and Run provided
      if (from === "1") {
        rise = convertToMeters(rise, unit);
        run = convertToMeters(run, unit_r);

        P = `${Math.round(rise * 3.281)}/${Math.round(run * 3.281 * 2)}`;
        pitch = Math.round((rise / run) * 100 * 100) / 100;
        rafter = Math.round(Math.sqrt(rise * rise + run * run) * 100) / 100;
        angle =
          Math.round(Math.atan(pitch / 100) * (180 / Math.PI) * 100) / 100;
        xValue = Math.round((pitch / 100) * 12 * 100) / 100;
      }

      // Case 2: Rise and Rafter provided
      else if (from === "2") {
        rafter = parseFloat(y);
        rise = convertToMeters(rise, unit);
        rafter = convertToMeters(rafter, unit_r);

        run = Math.round(Math.sqrt(rafter * rafter - rise * rise) * 100) / 100;
        P = `${Math.round(rise * 3.281)}/${Math.round(run * 3.281 * 2)}`;
        pitch = Math.round((rise / run) * 100 * 100) / 100;
        angle =
          Math.round(Math.atan(pitch / 100) * (180 / Math.PI) * 100) / 100;
        xValue = Math.round((pitch / 100) * 12 * 100) / 100;
      }

      // Case 3: Run and Rafter provided
      else if (from === "3") {
        run = parseFloat(x);
        rafter = parseFloat(y);
        run = convertToMeters(run, unit);
        rafter = convertToMeters(rafter, unit_r);

        rise = Math.round(Math.sqrt(rafter * rafter - run * run) * 100) / 100;
        P = `${Math.round(rise * 3.281)}/${Math.round(run * 3.281 * 2)}`;
        pitch = Math.round((rise / run) * 100 * 100) / 100;
        angle =
          Math.round(Math.atan(pitch / 100) * (180 / Math.PI) * 100) / 100;
        xValue = Math.round((pitch / 100) * 12 * 100) / 100;
      }

      // Case 4: Rise and Pitch provided
      else if (from === "4") {
        pitch = parseFloat(y);
        rise = convertToMeters(rise, unit);

        run = Math.round((rise / pitch) * 100 * 100) / 100;
        P = `${Math.round(rise * 3.281)}/${Math.round(run * 3.281 * 2)}`;
        rafter = Math.round(Math.sqrt(rise * rise + run * run) * 100) / 100;
        angle =
          Math.round(Math.atan(pitch / 100) * (180 / Math.PI) * 100) / 100;
        xValue = Math.round((pitch / 100) * 12 * 100) / 100;
      }

      // Case 5: Rise and Angle provided
      else if (from === "5") {
        angle = parseFloat(y);
        rise = convertToMeters(rise, unit);

        // Convert angle to radians if in degrees
        if (unit_a === "deg") {
          angle = (angle * Math.PI) / 180;
        }

        pitch = Math.round(Math.tan(angle) * 100 * 100) / 100;
        run = Math.round((rise / pitch) * 100 * 100) / 100;
        P = `${Math.round(rise * 3.281)}/${Math.round(run * 3.281 * 2)}`;
        rafter = Math.round(Math.sqrt(rise * rise + run * run) * 100) / 100;
        xValue = Math.round((pitch / 100) * 12 * 100) / 100;
        angle = (angle * 180) / Math.PI; // Convert back to degrees
      }

      // Case 6: Rise and X (rise per foot) provided
      else if (from === "6") {
        xValue = parseFloat(y);
        rise = convertToMeters(rise, unit);

        pitch = Math.round(((xValue * 100) / 12) * 100) / 100;
        run = Math.round((rise / pitch) * 100 * 100) / 100;
        P = `${Math.round(rise * 3.281)}/${Math.round(run * 3.281 * 2)}`;
        rafter = Math.round(Math.sqrt(rise * rise + run * run) * 100) / 100;
        angle =
          Math.round(Math.atan(pitch / 100) * (180 / Math.PI) * 100) / 100;
      }

      // Case 7: Run and Pitch provided
      else if (from === "7") {
        run = parseFloat(x);
        pitch = parseFloat(y);
        run = convertToMeters(run, unit);

        rise = Math.round(((run * pitch) / 100) * 100) / 100;
        P = `${Math.round(rise * 3.281)}/${Math.round(run * 3.281 * 2)}`;
        rafter = Math.round(Math.sqrt(rise * rise + run * run) * 100) / 100;
        angle =
          Math.round(Math.atan(pitch / 100) * (180 / Math.PI) * 100) / 100;
        xValue = Math.round((pitch / 100) * 12 * 100) / 100;
      }

      // Case 8: Run and Angle provided
      else if (from === "8") {
        run = parseFloat(x);
        angle = parseFloat(y);
        run = convertToMeters(run, unit);

        // Convert angle to radians if in degrees
        if (unit_a === "deg") {
          angle = (angle * Math.PI) / 180;
        }

        pitch = Math.round(Math.tan(angle) * 100 * 100) / 100;
        rise = Math.round(((run * pitch) / 100) * 100) / 100;
        P = `${Math.round(rise * 3.281)}/${Math.round(run * 3.281 * 2)}`;
        rafter = Math.round(Math.sqrt(rise * rise + run * run) * 100) / 100;
        xValue = Math.round((pitch / 100) * 12 * 100) / 100;
        angle = (angle * 180) / Math.PI; // Convert back to degrees
      }

      // Case 9: Run and X (rise per foot) provided
      else if (from === "9") {
        run = parseFloat(x);
        xValue = parseFloat(y);
        run = convertToMeters(run, unit);

        pitch = Math.round(((xValue * 100) / 12) * 100) / 100;
        rise = Math.round(((run * pitch) / 100) * 100) / 100;
        P = `${Math.round(rise * 3.281)}/${Math.round(run * 3.281 * 2)}`;
        rafter = Math.round(Math.sqrt(rise * rise + run * run) * 100) / 100;
        angle =
          Math.round(Math.atan(pitch / 100) * (180 / Math.PI) * 100) / 100;
      }

      // Case 10: Rafter and Pitch provided
      else if (from === "10") {
        rafter = parseFloat(x);
        pitch = parseFloat(y);
        rafter = convertToMeters(rafter, unit);

        // Note: Original code had error - calculating rise from run which wasn't defined
        // Correcting: rafter^2 = rise^2 + run^2 and pitch = rise/run
        // So: rise = rafter * sin(atan(pitch/100))
        const pitchAngle = Math.atan(pitch / 100);
        rise = Math.round(rafter * Math.sin(pitchAngle) * 100) / 100;
        run = Math.round(rafter * Math.cos(pitchAngle) * 100) / 100;

        P = `${Math.round(rise * 3.281)}/${Math.round(run * 3.281 * 2)}`;
        angle = Math.round(pitchAngle * (180 / Math.PI) * 100) / 100;
        xValue = Math.round((pitch / 100) * 12 * 100) / 100;
      }

      // Return calculated values
      return {
        tech_pitch: pitch,
        tech_rise: Math.round(rise * 100) / 100,
        tech_run: Math.round(run * 100) / 100,
        tech_rafter: rafter,
        tech_angle: angle,
        tech_x: xValue,
        tech_P: P,
      };
    } catch (error) {
      console.error("Calculation Error:", error);
      return {
        error: "An error occurred during calculation",
      };
    }
  }

  async getCalculationCubicFeetCalculator(body) {
    try {
      let length = body.tech_length;
      let width = body.tech_width;
      let height = body.tech_height;

      let length_unit = body.tech_length_unit;
      let width_unit = body.tech_width_unit;
      let height_unit = body.tech_height_unit;

      let weight = body.tech_weight;
      let weight_unit = body.tech_weight_unit;

      let quantity = body.tech_quantity;
      let price = body.tech_price;
      let price_unit = body.tech_price_unit;

      let room_unit = body.tech_room_unit;

      let area = body.tech_area;
      let area_unit = body.tech_area_unit;

      const param = {};

      // ========== ROOM UNIT 1 ========== //
      if (room_unit === "1") {
        if (isNumeric(length) && isNumeric(width) && isNumeric(height)) {
          // Helper conversion functions
          function calculate(a, b) {
            switch (b) {
              case "ft":
                return a * 1;
              case "in":
                return a * 0.0833333;
              case "yd":
                return a * 3;
              case "cm":
                return a * 0.0328084;
              case "m":
                return a * 3.28084;
              case "mm":
                return a * 0.003281;
              case "km":
                return a * 3281;
              case "mi":
                return a * 5280;
              case "nmi":
                return a * 6076;
              default:
                return a;
            }
          }

          function calculate2(a, b) {
            return calculate(a, b);
          }

          function converting(a, b) {
            switch (b) {
              case "cm":
                return a * 1;
              case "ft":
                return a * 30.48;
              case "m":
                return a * 100;
              case "in":
                return a * 2.54;
              case "yd":
                return a * 91.44;
              case "km":
                return a * 100000;
              case "mm":
                return a * 0.1;
              case "mi":
                return a * 160934;
              case "nmi":
                return a * 185200;
              default:
                return a;
            }
          }

          const l = calculate(length, length_unit);
          const w = calculate(width, width_unit);
          const h = calculate(height, height_unit);
          let volume = l * w * h;

          const calculate_meter_cube = volume / 35.3147;
          const calculate_cubic_yards = volume * 0.03704;
          const calculate_cubic_inches = volume / 0.0005787;
          const calculate_cubic_centimeters = volume * 28317;

          const v1 = converting(length, length_unit);
          const v2 = converting(width, width_unit);
          const v3 = converting(height, height_unit);
          const volumetric_weight = (v1 * v2 * v3) / 5000;
          const volumetric_weight2 = volumetric_weight * 2.205;

          const v4 = calculate2(length, length_unit);
          const v5 = calculate2(width, width_unit);
          const v6 = calculate2(height, height_unit);

          const twenty_ft = 1165 / (v4 * v5 * v6);
          const fourty_ft = 2350 / (v4 * v5 * v6);
          const fourty_high_cube = 2694 / (v4 * v5 * v6);

          // Quantity
          if (quantity && quantity != 0) {
            volume = volume * quantity;
          }

          // Weight
          if (weight && weight != 0) {
            if (weight_unit == "lbs") {
              param.tech_weight_unit = weight_unit;
              const weight_convert = weight * 0.454;
              param.tech_weight = weight;
              param.tech_weight_convert = weight_convert;
            } else if (weight_unit == "kg") {
              param.tech_weight_unit = weight_unit;
              const weight_convert = weight * 2.205;
              param.tech_weight = weight;
              param.tech_weight_convert = weight_convert;
            }
          }

          // Price
          if (price && price != 0 && weight != "") {
            switch (price_unit) {
              case "ft³":
                price = price * 1;
                break;
              case "yd³":
                price = price * 0.04;
                break;
              case "m³":
                price = price * 0.03;
                break;
              case "cm³":
                price = price * 28316.85;
                break;
              case "in³":
                price = price * 1.728;
                break;
            }
            volume = volume * price;
            param.tech_estimated_price = price;
          }

          param.tech_volume = volume;
          param.tech_cubic_meter = calculate_meter_cube;
          param.tech_cubic_yards = calculate_cubic_yards;
          param.tech_cubic_inches = calculate_cubic_inches;
          param.tech_cubic_centimeters = calculate_cubic_centimeters;
          param.tech_weight = weight;
          param.tech_volumetric_weight = volumetric_weight;
          param.tech_volumetric_weight2 = volumetric_weight2;
          param.tech_twenty_ft = twenty_ft;
          param.tech_fourty_ft = fourty_ft;
          param.tech_fourty_high_cube = fourty_high_cube;
          param.tech_l = l;
          param.tech_w = w;
          param.tech_h = h;
          return param;
        } else {
          return { error: "Please! Check Your Input" };
        }
      }

      // ========== ROOM UNIT 2 ========== //
      else if (room_unit === "2") {
        if (isNumeric(area) && isNumeric(height)) {
          let convert13;
          switch (area_unit) {
            case "ft":
              convert13 = area * 1;
              break;
            case "in":
              convert13 = area * 0.00694444;
              break;
            case "yd":
              convert13 = area * 9;
              break;
            case "cm":
              convert13 = area * 0.00107639;
              break;
            case "m":
              convert13 = area * 10.7639;
              break;
            default:
              convert13 = area;
          }

          function calculate_three(a, b) {
            switch (b) {
              case "ft":
                return a * 1;
              case "in":
                return a * 0.0833333;
              case "yd":
                return a * 3;
              case "cm":
                return a * 0.0328084;
              case "m":
                return a * 3.28084;
              case "mm":
                return a * 0.003281;
              case "km":
                return a * 3281;
              case "mi":
                return a * 5280;
              case "nmi":
                return a * 6076.12;
              default:
                return a;
            }
          }

          const h1 = calculate_three(height, height_unit);
          let volume = convert13 * h1;
          let estimated_price = 0;

          if (price && price != 0) {
            switch (price_unit) {
              case "ft³":
                price = price * 1;
                break;
              case "yd³":
                price = price * 0.04;
                break;
              case "m³":
                price = price * 0.03;
                break;
              case "cm³":
                price = price * 28316.85;
                break;
              case "in³":
                price = price * 1728;
                break;
            }
            estimated_price = volume * price;
          }

          if (quantity && quantity != 0) {
            volume = volume * quantity;
          }

          param.tech_volume = volume;
          const calculate_meter_cube = volume / 35.3147;
          const calculate_cubic_yards = volume * 27;
          const calculate_cubic_inches = volume / 0.0005787;
          const calculate_cubic_centimeters = volume * 28317;

          param.tech_cubic_meter = calculate_meter_cube;
          param.tech_cubic_yards = calculate_cubic_yards;
          param.tech_cubic_inches = calculate_cubic_inches;
          param.tech_cubic_centimeters = calculate_cubic_centimeters;
          param.tech_estimated_price = estimated_price;
          param.tech_h1 = h1;
          param.tech_convert13 = convert13;

          return param;
        } else {
          return { error: "Please! Check Your Input" };
        }
      }

      // Default case
      return { error: "Invalid room_unit" };
    } catch (error) {
      console.error(error);
      return { error: "Server error occurred" };
    }
    // Helper: check numeric
    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }
  }

  async getCalculationFeetAndInchesCalculator(body) {
    // Extract inputs (Laravel-style converted to JS)
    let feet1 = body.tech_feet1;
    let inches1 = body.tech_inches1;
    let operations = body.tech_operations;
    let feet2 = body.tech_feet2;
    let inches2 = body.tech_inches2;

    const ft_unit = "ft";
    const in_unit = "in";
    const baran = 12;

    let result = {};

    // Helper: convert "2 1/2" or "3/4" etc to decimal
    function calculation(inches) {
      let intPart = 0;
      let fracPart = 0;
      const parts = inches.toString().trim().split(" ");
      if (parts.length >= 1) {
        intPart = parseFloat(parts[0]);
      }
      if (parts.length >= 2) {
        const [top, bottom] = parts[1].split("/");
        fracPart = parseFloat(top) / parseFloat(bottom);
      }
      return intPart + fracPart;
    }

    // Helper: convert "1/2" to decimal
    function convertToDecimal(inches) {
      const [num, den] = inches.split("/");
      return Math.round((parseFloat(num) / parseFloat(den)) * 1e6) / 1e6;
    }

    // Helper: convert float back to fraction string
    function float2rat(n, tolerance = 1e-6) {
      let h1 = 1,
        h2 = 0,
        k1 = 0,
        k2 = 1;
      let b = 1 / n;
      do {
        b = 1 / b;
        let a = Math.floor(b);
        let aux = h1;
        h1 = a * h1 + h2;
        h2 = aux;
        aux = k1;
        k1 = a * k1 + k2;
        k2 = aux;
        b = b - a;
      } while (Math.abs(n - h1 / k1) > n * tolerance);

      if (k1 >= 2) {
        const div = h1 / k1;
        const intPart = Math.floor(div);
        const mod = h1 % k1;
        if (intPart >= 1) {
          return `${intPart} ${mod}/${k1}`;
        } else {
          return `${h1}/${k1}`;
        }
      } else if (k1 <= 1) {
        return `${h1}`;
      }
    }

    // --- Validation check ---
    if (!isNaN(feet1) && !isNaN(feet2) && inches1 !== "" && inches2 !== "") {
      // Convert fractional or mixed inputs
      const fractionPattern = /^(?:\d+\/\d+)$/;
      const mixedPattern = /^(\d+(?: \d+\/\d+)?)$/;

      if (fractionPattern.test(inches1) && fractionPattern.test(inches2)) {
        inches1 = convertToDecimal(inches1);
        inches2 = convertToDecimal(inches2);
      } else if (mixedPattern.test(inches1) && mixedPattern.test(inches2)) {
        inches1 = calculation(inches1);
        inches2 = calculation(inches2);
      } else if (mixedPattern.test(inches1) && fractionPattern.test(inches2)) {
        inches1 = calculation(inches1);
        inches2 = convertToDecimal(inches2);
      } else if (fractionPattern.test(inches1) && mixedPattern.test(inches2)) {
        inches1 = convertToDecimal(inches1);
        inches2 = calculation(inches2);
      }

      let ft, in_, ft2, in2, ft_div;

      // --- Operation 1: Addition ---
      if (operations === "1") {
        in_ = parseFloat(inches1) + parseFloat(inches2);
        ft = parseFloat(feet1) + parseFloat(feet2);
        in_ = in_ / baran;
        if (!in_.toString().includes(".")) {
          ft = ft + in_;
        } else {
          const [f, i] = in_.toString().split(".");
          const b = parseFloat("0." + i);
          ft = ft + parseFloat(f);
          in_ = b * baran;
          in_ = float2rat(in_);
        }
      }

      // --- Operation 2: Subtraction ---
      else if (operations === "2") {
        if (feet1 >= feet2 && inches1 >= inches2) {
          in_ = inches1 - inches2;
          ft = feet1 - feet2;
          in_ = in_ / baran;
          if (!in_.toString().includes(".")) {
            ft = ft + in_;
          } else {
            const [f, i] = in_.toString().split(".");
            const b = parseFloat("0." + i);
            ft = ft + parseFloat(f);
            in_ = b * baran;
            in_ = float2rat(in_);
          }
        } else if (feet1 <= feet2 && inches1 <= inches2) {
          in_ = inches1 - inches2;
          ft = feet1 - feet2;
          in_ = in_ / baran;
          if (!in_.toString().includes(".")) {
            ft = ft + in_;
          } else {
            const [f, i] = in_.toString().split(".");
            const b = parseFloat("0." + i);
            ft = ft + parseFloat(f);
            in_ = b * baran;
            in_ = float2rat(in_);
          }
        } else if (feet1 >= feet2 && inches1 <= inches2) {
          while (inches1 < inches2) {
            inches2 -= baran;
            feet2 += 1;
          }
          in_ = inches1 - inches2;
          ft = feet1 - feet2;
          in_ = in_ / baran;
          if (!in_.toString().includes(".")) {
            ft = ft + in_;
          } else {
            const [f, i] = in_.toString().split(".");
            const b = parseFloat("0." + i);
            ft = ft + parseFloat(f);
            in_ = b * baran;
            in_ = float2rat(in_);
          }
        } else if (feet1 <= feet2 && inches1 >= inches2) {
          while (inches1 > inches2) {
            inches1 -= baran;
            feet1 += 1;
          }
          while (inches1 < inches2) {
            inches2 -= baran;
            feet2 += 1;
          }
          in_ = inches1 - inches2;
          ft = feet1 - feet2;
          in_ = in_ / baran;
          if (!in_.toString().includes(".")) {
            ft = ft + in_;
          } else {
            const [f, i] = in_.toString().split(".");
            const b = parseFloat("0." + i);
            ft = ft + parseFloat(f);
            in_ = b * baran;
            in_ = float2rat(in_);
          }
        }
      }

      // --- Operation 3: Multiplication ---
      else if (operations === "3") {
        const ft1 = feet1 * baran;
        const ft2_ = feet2 * baran;
        const fot1 = ft1 + inches1;
        const fot2 = ft2_ + inches2;
        ft2 = fot1 * fot2;
        const in1 = inches1 / baran;
        const in2_ = inches2 / baran;
        const inc1 = in1 + Number(feet1);
        const inc2 = in2_ + Number(feet2);
        const c = inc1 * inc2;
        in2 = Number(c).toFixed(4);
      }

      // --- Operation 4: Division ---
      else if (operations === "4") {
        const ft1 = feet1 * baran;
        const ft21 = feet2 * baran;
        const fot1 = ft1 + inches1;
        const fot2 = ft21 + inches2;
        const a = fot1 / fot2;
        ft_div = Number(a).toFixed(4);
      }

      // Prepare result
      result.tech_ft_unit = ft_unit;
      result.tech_in_unit = in_unit;
      if (ft !== undefined) result.tech_ft = ft;
      if (in_ !== undefined) result.tech_in = in_;
      if (ft2 !== undefined) result.tech_ft2 = ft2;
      if (in2 !== undefined) result.tech_in2 = in2;
      if (ft_div !== undefined) result.tech_ft_div = ft_div;
    } else {
      result.error = "Please! Check Your Inputs";
    }

    return result;
  }

  async getCalculationAcreageCalculator(body) {
    try {
      let to_cal = Number(body.tech_to_cal);
      let length = Number(body.tech_length);
      let length_unit = body.tech_length_unit;
      let width = Number(body.tech_width);
      let width_unit = body.tech_width_unit;
      let area = Number(body.tech_area);
      let area_unit = body.tech_area_unit;
      let price = Number(body.tech_price);
      let price_unit = body.tech_price_unit;
      let currancy = body.tech_currancy;

      let result = {};

      // Calculate Area (when length and width are given)
      if (to_cal === 1) {
        if (!isNaN(length) && !isNaN(width)) {
          // Convert width to meters
          if (width_unit === "cm") {
            width = width * 0.01;
          } else if (width_unit === "in") {
            width = width * 0.0254;
          } else if (width_unit === "ft") {
            width = width * 0.3048;
          } else if (width_unit === "yd") {
            width = width * 0.9144;
          } else if (width_unit === "mm") {
            width = width * 0.001;
          }

          area = Number(width) * Number(length);
          let perimeter = Number(Number(width) * 2 + Number(length) * 2);
          console.log(area, width, length);
          // Calculate price if provided
          if (!isNaN(price) && price > 0) {
            let ans = 0;
            if (price_unit === "/mm²") {
              ans = area * 1000000;
            } else if (price_unit === "/cm²") {
              ans = area * 10000;
            } else if (price_unit === "/m²") {
              ans = area * 1;
            } else if (price_unit === "/in²") {
              ans = area * 1550.003;
            } else if (price_unit === "/ft²") {
              ans = area * 10.7639;
            } else if (price_unit === "/yd²") {
              ans = area * 1.19599;
            } else if (price_unit === "/ac") {
              ans = area * 0.0002471054;
            } else if (price_unit === "/ha") {
              ans = area * 0.0001;
            }
            let final_price = Number(ans) * Number(price);
            result.tech_final_price = final_price;
          }

          result.tech_area = area;
          result.tech_perimeter = perimeter;
          return result;
        } else {
          result.error = "Please! Check Your Inputs";
          return result;
        }
      }

      // Calculate Length (when width and area are given)
      else if (to_cal === 2) {
        if (!isNaN(width) && !isNaN(area)) {
          // Convert width to meters
          if (width_unit === "cm") {
            width = width * 0.01;
          } else if (width_unit === "in") {
            width = width * 0.0254;
          } else if (width_unit === "ft") {
            width = width * 0.3048;
          } else if (width_unit === "yd") {
            width = width * 0.9144;
          } else if (width_unit === "mm") {
            width = width * 0.001;
          }

          // Convert area to square meters
          if (area_unit === "mm²") {
            area = area * 0.000001;
          } else if (area_unit === "cm²") {
            area = area * 0.0001;
          } else if (area_unit === "m²") {
            area = area * 1;
          } else if (area_unit === "in²") {
            area = area * 0.00064516;
          } else if (area_unit === "ft²") {
            area = area * 0.092903;
          } else if (area_unit === "yd²") {
            area = area * 0.836127;
          } else if (area_unit === "ac") {
            area = area * 4046.86;
          } else if (area_unit === "ha") {
            area = area * 10000;
          }

          length = Number(area) / Number(width);
          let perimeter = Number(Number(width) * 2 + Number(length) * 2);

          // Calculate price if provided
          if (!isNaN(price) && price > 0) {
            let ans = 0;
            if (price_unit === "/mm²") {
              ans = area * 1000000;
            } else if (price_unit === "/cm²") {
              ans = area * 10000;
            } else if (price_unit === "/m²") {
              ans = area * 1;
            } else if (price_unit === "/in²") {
              ans = area * 1550.003;
            } else if (price_unit === "/ft²") {
              ans = area * 10.7639;
            } else if (price_unit === "/yd²") {
              ans = area * 1.19599;
            } else if (price_unit === "/ac") {
              ans = area * 0.0002471054;
            } else if (price_unit === "/ha") {
              ans = area * 0.0001;
            }
            let final_price = Number(ans) * Number(price);
            result.tech_final_price = final_price;
          }

          result.tech_length = length;
          result.tech_perimeter = perimeter;
          return result;
        } else {
          result.error = "Please! Check Your Inputs";
          return result;
        }
      }

      // Calculate Width (when length and area are given)
      else if (to_cal === 3) {
        if (!isNaN(length) && !isNaN(area)) {
          // Convert length to meters
          if (length_unit === "cm") {
            length = length * 0.01;
          } else if (length_unit === "in") {
            length = length * 0.0254;
          } else if (length_unit === "ft") {
            length = length * 0.3048;
          } else if (length_unit === "yd") {
            length = length * 0.9144;
          } else if (length_unit === "mm") {
            length = length * 0.001;
          }

          // Convert area to square meters
          if (area_unit === "mm²") {
            area = area * 0.000001;
          } else if (area_unit === "cm²") {
            area = area * 0.0001;
          } else if (area_unit === "m²") {
            area = area * 1;
          } else if (area_unit === "in²") {
            area = area * 0.00064516;
          } else if (area_unit === "ft²") {
            area = area * 0.092903;
          } else if (area_unit === "yd²") {
            area = area * 0.836127;
          } else if (area_unit === "ac") {
            area = area * 4046.86;
          } else if (area_unit === "ha") {
            area = area * 10000;
          }

          width = Number(area) / Number(length);
          let perimeter = Number(Number(width) * 2 + Number(length) * 2);

          // Calculate price if provided
          if (!isNaN(price) && price > 0) {
            let ans = 0;
            if (price_unit === "/mm²") {
              ans = area * 1000000;
            } else if (price_unit === "/cm²") {
              ans = area * 10000;
            } else if (price_unit === "/m²") {
              ans = area * 1;
            } else if (price_unit === "/in²") {
              ans = area * 1550.003;
            } else if (price_unit === "/ft²") {
              ans = area * 10.7639;
            } else if (price_unit === "/yd²") {
              ans = area * 1.19599;
            } else if (price_unit === "/ac") {
              ans = area * 0.0002471054;
            } else if (price_unit === "/ha") {
              ans = area * 0.0001;
            }
            let final_price = Number(ans) * Number(price);
            result.tech_final_price = final_price;
          }

          result.tech_width = width;
          result.tech_perimeter = perimeter;
          return result;
        } else {
          result.error = "Please! Check Your Inputs";
          return result;
        }
      }
    } catch (error) {
      console.error("Error in getCalculationAcreageCalculator:", error);
      return { error: "An error occurred during calculation" };
    }
  }

  async getCalculationRebarCalculator(body) {
    try {
      // Extract all input values from body
      let {
        tech_first,
        tech_units1,
        tech_second,
        tech_units2,
        tech_third,
        tech_units3,
        tech_four,
        tech_units4,
        tech_five,
        tech_units5,
        tech_six,
        tech_units6,
        tech_currancy,
      } = body;

      let param = {};
      let convert, convert2, convert3;
      // 🧩 Remove currency prefix if present
      if (tech_units5 && tech_currancy) {
        tech_units5 = tech_units5.replace(tech_currancy + " ", "");
      }

      // ✅ Helper Functions (Converted from PHP)

      function cm_unit(a, b) {
        if (a == "cm") {
          convert = b * 1;
        } else if (a == "m") {
          convert = b * 100;
        } else if (a == "km") {
          convert = b * 100000;
        } else if (a == "in") {
          convert = b * 2.54;
        } else if (a == "ft") {
          convert = b * 30.48;
        } else if (a == "yd") {
          convert = b * 91.44;
        } else if (a == "mi") {
          convert = b * 30.48;
        }
        return convert;
      }
      function cm_unit2(a, b) {
        if (a == "mm") {
          convert2 = b / 10;
        } else if (a == "cm") {
          convert2 = b * 1;
        } else if (a == "m") {
          convert2 = b * 100;
        } else if (a == "in") {
          convert2 = b * 2.54;
        } else if (a == "ft") {
          convert2 = b * 30.48;
        } else if (a == "yd") {
          convert2 = b * 91.44;
        }
        return convert2;
      }
      function cm_unit3(a, b) {
        if (a == "cm") {
          convert3 = b * 1;
        } else if (a == "m") {
          convert3 = b * 100;
        } else if (a == "in") {
          convert3 = b * 2.54;
        } else if (a == "ft") {
          convert3 = b * 30.48;
        } else if (a == "yd") {
          convert3 = b * 91.44;
        }
        return convert3;
      }

      // ✅ Validate numeric inputs
      if (
        !isNaN(tech_first) &&
        !isNaN(tech_second) &&
        !isNaN(tech_third) &&
        !isNaN(tech_four) &&
        !isNaN(tech_five) &&
        !isNaN(tech_six)
      ) {
        // Convert all to cm
        let first = cm_unit(tech_units1, Number(tech_first));
        let second = cm_unit(tech_units2, Number(tech_second));
        let third = cm_unit2(tech_units3, Number(tech_third));
        let four = cm_unit2(tech_units4, Number(tech_four));
        let five = cm_unit3(tech_units5, Number(tech_five));
        let six = cm_unit3(tech_units6, Number(tech_six));

        // Main calculations
        const mul1 = 2 * four;
        const grid_len = first - mul1;
        const grid_wid = second - mul1;

        const rebar_col = grid_len / third;
        const rebar_row = grid_wid / third;
        const part1 = rebar_col * grid_wid;
        const part2 = rebar_row * grid_len;
        const trl = part1 + part2;

        const price_s = five * six;
        const rebar_pie = trl / six;
        const cost = Math.round(rebar_pie) * price_s;

        // ✅ Return structured result
        param.tech_grid_len = grid_len;
        param.tech_grid_wid = grid_wid;
        param.tech_trl = trl;
        param.tech_rebar_pie = rebar_pie;
        param.tech_cost = cost;
        param.tech_price_s = price_s;
        return param;
      } else {
        return { error: "Please check your input" };
      }
    } catch (err) {
      return { error: err.message || "Something went wrong!" };
    }
  }

  async getCalculationPipeVolumeCalculator(body) {
    try {
      // Extract input values
      let {
        tech_inner_diameter,
        tech_inner_diameter_unit,
        tech_length,
        tech_length_unit,
        tech_density,
        tech_density_unit,
      } = body;

      let param = {};
      let val1, val2;
      function convert_inches2(unit, value) {
        if (unit == "cm") {
          val1 = value * 0.393701;
        } else if (unit == "m") {
          val1 = value * 39.3701;
        } else if (unit == "in") {
          val1 = value * 1;
        } else if (unit == "ft") {
          val1 = value * 12;
        } else if (unit == "yd") {
          val1 = value * 36;
        } else if (unit == "mm") {
          val1 = value * 0.0393701;
        }
        return val1;
      }
      function convert_unit2(unit2, value2) {
        if (unit2 == "kg/m³") {
          val2 = value2 * 0.000036127;
        } else if (unit2 == "kg/dm³") {
          val2 = value2 * 0.036127;
        } else if (unit2 == "kg/L") {
          val2 = value2 * 0.036127292;
        } else if (unit2 == "g/mL") {
          val2 = value2 * 0.036127292;
        } else if (unit2 == "g/cm³") {
          val2 = value2 * 0.036127292;
        } else if (unit2 == "oz/cu in") {
          val2 = value2 * 0.0625;
        } else if (unit2 == "lb/cu in") {
          val2 = value2 * 1;
        } else if (unit2 == "lb/cu ft") {
          val2 = value2 * 0.000578703704;
        } else if (unit2 == "lb/US gal") {
          val2 = value2 * 0.00432900433;
        } else if (unit2 == "g/L") {
          val2 = value2 * 0.00003612729;
        } else if (unit2 == "g/dL") {
          val2 = value2 * 0.00036127292;
        } else if (unit2 == "mg/L") {
          val2 = value2 * 3.6127292e-8;
        }
        return val2;
      }

      // ✅ Validation
      if (
        !isNaN(tech_inner_diameter) &&
        !isNaN(tech_length) &&
        !isNaN(tech_density)
      ) {
        if (tech_inner_diameter > 0 && tech_length > 0) {
          // Convert to inches
          const inv = convert_inches2(
            tech_inner_diameter_unit,
            Number(tech_inner_diameter)
          );
          const lnv = convert_inches2(tech_length_unit, Number(tech_length));

          // Compute volume and weight
          const k = inv / 2;
          const volume = 3.14159265 * k * k * lnv; // cubic inches
          const wv = convert_unit2(tech_density_unit, Number(tech_density));
          const weight = volume * wv;

          // ✅ Return structured response
          param.tech_volume = volume;
          param.tech_weight = weight;
          return param;
        } else {
          return { error: "Please! Enter Positive Value" };
        }
      } else {
        return { error: "Please! Check Your Input" };
      }
    } catch (err) {
      return { error: err.message || "Something went wrong!" };
    }
  }

  async getCalculationMsPlateWeightCalculator(body) {
    try {
      // Shape properties
      let st_type = body.tech_st_type;
      let st_shape = body.tech_st_shape;
      let quantity = body.tech_quantity;

      // Dimension properties
      let length = body.tech_length;
      let length_unit = body.tech_length_unit;
      let width = body.tech_width;
      let width_unit = body.tech_width_unit;
      let thickness = body.tech_thickness;
      let thickness_unit = body.tech_thickness_unit;
      let side = body.tech_side;
      let side_unit = body.tech_side_unit;
      let diameter = body.tech_diameter;
      let diameter_unit = body.tech_diameter_unit;

      // Area properties
      let area = body.tech_area;
      let area_unit = body.tech_area_unit;

      let param = {};
      let val3, ans;
      // ✅ Helper functions
      function centi(unit3, value3) {
        if (unit3 == "mm²") {
          val3 = value3 * 0.01;
        } else if (unit3 == "cm²") {
          val3 = value3 * 1;
        } else if (unit3 == "m²") {
          val3 = value3 * 10000;
        } else if (unit3 == "km²") {
          val3 = value3 * 10000000000;
        } else if (unit3 == "in²") {
          val3 = value3 * 6.452;
        } else if (unit3 == "ft²") {
          val3 = value3 * 929;
        } else if (unit3 == "yd²") {
          val3 = value3 * 8361;
        } else if (unit3 == "mi²") {
          val3 = value3 * 25899881103;
        }
        return val3;
      }
      function convert_to_cmeter(value, unit) {
        if (unit == "cm") {
          ans = value * 1;
        } else if (unit == "mm") {
          ans = value * 0.1;
        } else if (unit == "in") {
          ans = value * 2.54;
        } else if (unit == "ft") {
          ans = value * 30.58;
        } else if (unit == "yd") {
          ans = value * 91.44;
        } else if (unit == "m") {
          ans = value * 100;
        }
        return ans;
      }

      // ✅ Convert numeric safely
      const n = (v) => (isNaN(Number(v)) ? null : Number(v));

      // Assign numeric values
      const _st_type = n(st_type);
      const _st_shape = String(st_shape);
      const _length = n(length);
      const _width = n(width);
      const _thickness = n(thickness);
      const _side = n(side);
      const _diameter = n(diameter);
      const _area = n(area);
      const _quantity = n(quantity);

      let areaResult = 0,
        volume = 0,
        weight = 0;

      // ✅ Shape conditions
      if (_st_shape == "1") {
        if (_length > 0 && _width > 0 && _thickness > 0 && _quantity > 0) {
          const lv = convert_to_cmeter(_length, length_unit);
          const wv = convert_to_cmeter(_width, width_unit);
          const thv = convert_to_cmeter(_thickness, thickness_unit);
          areaResult = lv * wv;
          volume = thv * areaResult;
          weight = _quantity * _st_type * volume;
        } else {
          return { error: "Please! Enter Positive Value" };
        }
      } else if (_st_shape == "2") {
        if (_thickness > 0 && _side > 0 && _quantity > 0) {
          const areaValue = convert_to_cmeter(_side, side_unit) ** 2;
          const thv = convert_to_cmeter(_thickness, thickness_unit);
          volume = thv * areaValue;
          weight = _quantity * _st_type * volume;
          areaResult = areaValue;
        } else {
          return { error: "Please! Enter Positive Value" };
        }
      } else if (_st_shape == "3") {
        if (_thickness > 0 && _diameter > 0 && _quantity > 0) {
          const dv = convert_to_cmeter(_diameter, diameter_unit);
          const div = (dv / 2) ** 2;
          areaResult = div * 3.141592653;
          const thv = convert_to_cmeter(_thickness, thickness_unit);
          volume = thv * areaResult;
          weight = _quantity * _st_type * volume;
        } else {
          return { error: "Please! Enter Positive Value" };
        }
      } else if (_st_shape == "4") {
        if (_area > 0 && _thickness > 0 && _quantity > 0) {
          const areaValue = centi(area_unit, _area);
          const thv = convert_to_cmeter(_thickness, thickness_unit);
          volume = thv * areaValue;
          weight = _quantity * _st_type * volume;
          areaResult = areaValue;
        } else {
          return { error: "Please! Enter Positive Value" };
        }
      } else {
        return { error: "Invalid st_shape option" };
      }

      param.tech_area = areaResult;
      param.tech_volume = volume;
      param.tech_weight = weight;

      return { status: "success", payload: param };
    } catch (err) {
      return { status: "error", payload: { error: err.message } };
    }
  }

  async getCalculationPricePerSquareFootCalculator(body) {
    let calculate = body.tech_calculate;
    let pp = Number(body.tech_pp);
    let area_measure = Number(body.tech_area_measure);
    let area_measure_unit = body.tech_area_measure_unit;
    let pp1 = Number(body.tech_pp1);
    let area_measure1 = Number(body.tech_area_measure1);
    let area_measure_unit1 = body.tech_area_measure_unit1;
    let pp2 = Number(body.tech_pp2);
    let area_measure2 = Number(body.tech_area_measure2);
    let area_measure_unit2 = body.tech_area_measure_unit2;
    let compare = body.tech_compare;
    let compare2 = body.tech_compare2;
    let pp_unit = body.tech_pp_unit;
    let pp1_unit = body.tech_pp1_unit;
    let pp2_unit = body.tech_pp2_unit;

    // helper function for area conversion
    function unitconver(val1, val2) {
      if (val2 === "ft²") return val1 * 1;
      else if (val2 === "m²") return val1 * 10.764;
      else if (val2 === "in²") return val1 * 0.006944;
      else return val1 * 9; // default case
    }

    let param = {};

    try {
      let res, res1, res2;

      // Base calculation
      if (["1", "2", "3"].includes(calculate)) {
        if (!isNaN(pp) && !isNaN(area_measure)) {
          if (area_measure > 0) {
            let am = unitconver(area_measure, area_measure_unit);
            if (calculate === "1" || calculate === "2") res = pp / am;
            else if (calculate === "3") res = pp * am;

            param.tech_pp_unit = pp_unit;
          } else {
            param.error = "Square Footage must be greater than zero";
            return param;
          }
        } else {
          param.error = "Please! Check Input";
          return param;
        }
      }

      // Comparison 1
      if (compare === "2") {
        if (["1", "2", "3"].includes(calculate)) {
          if (!isNaN(pp1) && !isNaN(area_measure1)) {
            if (area_measure1 > 0) {
              let am1 = unitconver(area_measure1, area_measure_unit1);
              if (calculate === "1" || calculate === "2") res1 = pp1 / am1;
              else if (calculate === "3") res1 = pp1 * am1;

              param.tech_pp1_unit = pp1_unit;
              param.tech_res1 = res1;
              param.tech_compare = compare;
            } else {
              param.error = "Square Footage must be greater than zero";
              return param;
            }
          } else {
            param.error = "Please! Check Input";
            return param;
          }
        }
      }

      // Comparison 2
      if (compare2 === "2") {
        if (["1", "2", "3"].includes(calculate)) {
          if (!isNaN(pp2) && !isNaN(area_measure2)) {
            if (area_measure2 > 0) {
              let am2 = unitconver(area_measure2, area_measure_unit2);
              if (calculate === "1" || calculate === "2") res2 = pp2 / am2;
              else if (calculate === "3") res2 = pp2 * am2;

              param.tech_pp2_unit = pp2_unit;
              param.tech_res2 = res2;
              param.tech_compare2 = compare2;
            } else {
              param.error = "Square Footage must be greater than zero";
              return param;
            }
          } else {
            param.error = "Please! Check Input";
            return param;
          }
        }
      }

      param.tech_res = res;
      param.tech_calculate = calculate;
      return param;
    } catch (err) {
      return { error: err.message || "Unexpected Error" };
    }
  }

  async getCalculationMaterialCalculator(body) {
    const operations = body.tech_operations;
    const ex_drop = body.tech_ex_drop;
    const first = body.tech_first;
    const units1 = body.tech_units1;
    const second = body.tech_second;
    const units2 = body.tech_units2;
    const third = body.tech_third;
    const units3 = body.tech_units3;
    const four = body.tech_four;
    const units4 = body.tech_units4;
    const five = body.tech_five;
    const units5 = body.tech_units5;
    const six = body.tech_six;
    const units6 = body.tech_units6;
    const seven = body.tech_seven;
    const units7 = body.tech_units7;
    const currancy = body.tech_currancy;

    const param = {};
    let convert1;
    function feet(unit, value) {
      if (unit == "in") {
        return value; // Already in inches
      } else if (unit == "ft") {
        return value * 12; // Convert feet to inches
      } else if (unit == "cm") {
        return value * 0.3937; // Convert centimeters to inches
      } else if (unit == "m") {
        return value * 39.3701; // Convert meters to inches
      } else if (unit == "yd") {
        return value * 36; // Convert yards to inches
      } else {
        return "Invalid unit";
      }
    }
    function feet2(unit, value) {
      if (unit == "in³") {
        return value; // Already in inches
      } else if (unit == "ft³") {
        return value * 12; // Convert feet to inches
      } else if (unit == "cm³") {
        return value * 0.3937; // Convert centimeters to inches
      } else if (unit == "m³") {
        return value * 39.3701; // Convert meters to inches
      } else if (unit == "yd³") {
        return value * 36; // Convert yards to inches
      } else {
        return "Invalid unit";
      }
    }
    function lb(a, b) {
      if (a == "lb") {
        // dd(a,b);
        convert1 = b * 1;
      } else if (a == "t") {
        convert1 = b * 2000;
      } else if (a == "long t") {
        convert1 = b * 2240;
      } else if (a == "kg") {
        convert1 = b * 2.205;
      }
      return convert1;
    }

    // Clean currency symbols
    const cleanUnit6 = units6?.replace(currancy + " ", "");
    const cleanUnit7 = units7?.replace(currancy + " ", "");

    let area, volume, weight;

    // 🔹 Operation 1
    if (operations === "1") {
      if (!isNaN(first) && !isNaN(second) && !isNaN(third)) {
        const f1 = feet(units1, Number(first));
        const f2 = feet(units2, Number(second));
        const f3 = feet(units3, Number(third));

        area = f1 * f2;
        volume = area * f3;
        weight = ex_drop * (volume / 1728);

        param.tech_area = area;
        param.tech_volume = volume;
      } else {
        return { error: "Please! Check Your Input" };
      }
    }

    // 🔹 Operation 2
    else if (operations === "2") {
      if (!isNaN(third) && !isNaN(four)) {
        const f3 = feet(units3, Number(third));
        const f4 = feet(units4, Number(four));

        volume = f4 * f3;
        weight = ex_drop * (volume / 1728);

        param.tech_volume = volume;
      } else {
        return { error: "Please! Check Your Input" };
      }
    }

    // 🔹 Operation 3
    else if (operations === "3") {
      if (!isNaN(five)) {
        const f5 = feet2(units5, Number(five));
        volume = f5;
        weight = ex_drop * (volume / 1728);
      } else {
        return { error: "Please! Check Your Input" };
      }
    }

    // 🔹 Cost Mass Calculation
    if (!isNaN(six)) {
      const s6 = lb(cleanUnit6, Number(six));
      console.log(s6);
      param.tech_cost_mass = s6 * weight;
    }

    // 🔹 Cost Volume Calculation
    if (!isNaN(seven)) {
      const s7 = feet2(cleanUnit7, Number(seven));
      param.tech_cost_volume = volume * s7;
    }

    param.tech_weight = weight;

    return param;
  }

  async getCalculationRetainingWallCalculator(body) {
    let wall_length = body.tech_wall_length;
    let wall_length_unit = body.tech_wall_length_unit;
    let wall_height = body.tech_wall_height;
    let wall_height_unit = body.tech_wall_height_unit;
    let block_height = body.tech_block_height;
    let block_height_unit = body.tech_block_height_unit;
    let block_length = body.tech_block_length;
    let block_length_unit = body.tech_block_length_unit;
    let wall_block_price = body.tech_wall_block_price;
    let cap_height = body.tech_cap_height;
    let cap_height_unit = body.tech_cap_height_unit;
    let cap_length = body.tech_cap_length;
    let cap_length_unit = body.tech_cap_length_unit;
    let cap_block_price = body.tech_cap_block_price;
    let backfill_thickness = body.tech_backfill_thickness;
    let backfill_thickness_unit = body.tech_backfill_thickness_unit;
    let backfill_length = body.tech_backfill_length;
    let backfill_length_unit = body.tech_backfill_length_unit;
    let backfill_height = body.tech_backfill_height;
    let backfill_height_unit = body.tech_backfill_height_unit;
    let backfill_price = body.tech_backfill_price;
    let backfill_price_unit = body.tech_backfill_price_unit;
    let currancy = body.tech_currancy;

    const param = {};

    // Remove currency symbol
    const clean_backfill_price_unit = backfill_price_unit?.replace(
      currancy + " ",
      ""
    );

    // 🔹 Convert to meter
    function convert_to_meter(unit, value) {
      let ans = 0;
      if (unit == "cm") ans = value / 100;
      else if (unit == "m") ans = value;
      else if (unit == "in") ans = value / 39.37;
      else if (unit == "ft") ans = value / 3.281;
      else if (unit == "yd") ans = value / 1.094;
      else if (unit == "dm") ans = value / 10;
      return ans;
    }

    // 🔹 Convert to price unit (same as Laravel)
    function convert_to_price_unit(unit, value) {
      let ans = 0;
      if (unit == "dag") ans = value * 100;
      else if (unit == "lb") ans = value * 2.205;
      else if (unit == "kg") ans = value;
      else if (unit == "t") ans = value / 1000;
      else if (unit == "oz") ans = value * 35.274;
      else if (unit == "stone") ans = value / 6.35;
      else if (unit == "Us ton") ans = value / 907.2;
      else if (unit == "Long ton") ans = value / 1016;
      // ⚠️ Laravel returns nothing if unit doesn't match — we replicate that:
      else ans = 0;
      return ans;
    }

    if (
      !isNaN(wall_height) &&
      !isNaN(block_height) &&
      !isNaN(cap_length) &&
      !isNaN(backfill_thickness) &&
      !isNaN(backfill_height) &&
      !isNaN(backfill_length) &&
      !isNaN(backfill_price) &&
      !isNaN(block_length) &&
      !isNaN(cap_block_price) &&
      !isNaN(wall_block_price) &&
      !isNaN(wall_length)
    ) {
      const wall_height_m = convert_to_meter(
        wall_height_unit,
        Number(wall_height)
      );
      const block_height_m = convert_to_meter(
        block_height_unit,
        Number(block_height)
      );
      const wall_length_m = convert_to_meter(
        wall_length_unit,
        Number(wall_length)
      );
      const block_length_m = convert_to_meter(
        block_length_unit,
        Number(block_length)
      );
      const cap_length_m = convert_to_meter(
        cap_length_unit,
        Number(cap_length)
      );
      const backfill_thickness_m = convert_to_meter(
        backfill_thickness_unit,
        Number(backfill_thickness)
      );
      const backfill_length_m = convert_to_meter(
        backfill_length_unit,
        Number(backfill_length)
      );
      const backfill_height_m = convert_to_meter(
        backfill_height_unit,
        Number(backfill_height)
      );

      const block_rows = Math.ceil(wall_height_m / block_height_m);
      const block_columns = Math.ceil(wall_length_m / block_length_m);
      const blocks = block_columns * (block_rows - 1);
      const blocks_price = blocks * wall_block_price;

      const caps = wall_length_m / cap_length_m;
      const caps_price = caps * cap_block_price;

      const backfill_volume =
        backfill_thickness_m * backfill_length_m * backfill_height_m;
      const backfill_weight = 1346 * backfill_volume;

      // ✅ Match Laravel: invalid unit should make price 0
      const backfill_weight_unit = convert_to_price_unit(
        clean_backfill_price_unit,
        backfill_weight
      );
      const backfill_total_price =
        backfill_weight_unit > 0 ? backfill_weight_unit * backfill_price : 0;

      const total_cost = backfill_total_price + blocks_price + caps_price;

      param.tech_blocks = Math.ceil(blocks);
      param.tech_blocks_price = Math.ceil(blocks_price);
      param.tech_caps = Math.ceil(caps);
      param.tech_caps_price = Math.ceil(caps_price);
      param.tech_backfill_volume = Number(backfill_volume.toFixed(3));
      param.tech_backfill_weight = Math.ceil(backfill_weight);
      param.tech_backfill_total_price = Math.ceil(backfill_total_price);
      param.tech_total_cost = Math.ceil(total_cost);

      return param;
    } else {
      return { error: "Please! Check Your Input" };
    }
  }

  async getCalculationSquareyardsCalculator(body) {
    let first = body.tech_first;
    let unit1 = body.tech_unit1;
    let second = body.tech_second;
    let unit2 = body.tech_unit2;
    let third = body.tech_third;
    let unit3 = body.tech_unit3;
    let currancy = body.tech_currancy;

    const param = {};

    // Remove currency symbol (like "$ " etc.)
    unit3 = unit3?.replace(currancy + " ", "");

    // --- Convert length to centimeters ---
    function con_cm(a, b) {
      if (a === "mm") {
        return b / 10;
      } else if (a === "cm") {
        return b * 1;
      } else if (a === "m") {
        return b * 100;
      } else if (a === "in") {
        return b * 2.54;
      } else if (a === "ft") {
        return b * 30.48;
      } else if (a === "yd") {
        return b * 91.44;
      }
      return b;
    }

    // --- Convert area to square centimeters ---
    function con_cm_sq(a, b) {
      if (a === "mm²") {
        return b / 10;
      } else if (a === "cm²") {
        return b * 1;
      } else if (a === "dm") {
        return b * 10;
      } else if (a === "m²") {
        return b * 100;
      } else if (a === "km²") {
        return b * 100000;
      } else if (a === "in²") {
        return b * 2.54;
      } else if (a === "ft²") {
        return b * 30.48;
      } else if (a === "yd²") {
        return b * 91.44;
      } else if (a === "a") {
        return b * 1000000;
      } else if (a === "da") {
        return b * 1000;
      } else if (a === "ha") {
        return b * 100000000;
      } else if (a === "ac") {
        return b * 40468564.224;
      }
      return b;
    }

    // --- Validate numeric inputs ---
    if (!isNaN(first) && !isNaN(second) && !isNaN(third)) {
      first = con_cm(unit1, Number(first));
      second = con_cm(unit2, Number(second));
      third = con_cm_sq(unit3, Number(third));

      const yd_ans = first * second;
      const price = yd_ans * third;

      param.tech_yd_ans = yd_ans;
      param.tech_price = price;

      return param;
    } else {
      return { error: "Please! Check Your Input" };
    }
  }

  async getCalculationBrickCalculator(body) {
    const param = {};

    // Extract inputs
    let wall_type = body.tech_wall_type?.trim();
    let wall_length = Number(body.tech_wall_length);
    let wall_length_unit = body.tech_wall_length_unit?.trim();
    let wall_width = Number(body.tech_wall_width);
    let wall_width_unit = body.tech_wall_width_unit?.trim();
    let wall_height = Number(body.tech_wall_height);
    let wall_height_unit = body.tech_wall_height_unit?.trim();

    // Brick Fields
    let brick_type = body.tech_brick_type?.trim();
    let brick_wastage = Number(body.tech_brick_wastage);
    let mortar_joint_thickness = Number(body.tech_mortar_joint_thickness);
    let mortar_joint_thickness_unit =
      body.tech_mortar_joint_thickness_unit?.trim();
    let brick_length = Number(body.tech_brick_length);
    let brick_length_unit = body.tech_brick_length_unit?.trim();
    let brick_width = Number(body.tech_brick_width);
    let brick_width_unit = body.tech_brick_width_unit?.trim();
    let brick_height = Number(body.tech_brick_height);
    let brick_height_unit = body.tech_brick_height_unit?.trim();

    // Mortar Fields
    let with_motar = body.tech_with_motar?.trim();
    let wet_volume = Number(body.tech_wet_volume);
    let wet_volume_unit = body.tech_wet_volume_unit?.trim();
    let mortar_wastage = Number(body.tech_mortar_wastage);
    let mortar_ratio = body.tech_mortar_ratio?.trim();
    let bag_size = Number(body.tech_bag_size);
    let bag_size_unit = body.tech_bag_size_unit?.trim();

    // Cost Fields
    let price_per_brick = Number(body.tech_price_per_brick);
    let price_of_cement = Number(body.tech_price_of_cement);
    let price_sand_per_volume = Number(body.tech_price_sand_per_volume);
    let price_sand_volume_unit = body.tech_price_sand_volume_unit?.trim();
    let currancy = body.tech_currancy;

    // Remove currency symbol
    price_sand_volume_unit = price_sand_volume_unit?.replace(
      currancy + " ",
      ""
    );
    let ans;
    // ---------------------- Conversion Functions ----------------------
    function convert_to_meter(unit, value) {
      if (unit == "cm") {
        ans = value / 100;
      } else if (unit == "m") {
        ans = value;
      } else if (unit == "in") {
        ans = value / 39.37;
      } else if (unit == "ft") {
        ans = value / 3.281;
      } else if (unit == "yd") {
        ans = value / 1.094;
      } else if (unit == "dm") {
        ans = value / 10;
      } else if (unit == "mm") {
        ans = value / 1000;
      }
      return ans;
    }
    function convert_to_millimeter(unit, value) {
      if (unit == "cm") {
        ans = value * 10;
      } else if (unit == "m") {
        ans = value * 1000;
      } else if (unit == "in") {
        ans = value * 25.4;
      } else if (unit == "ft") {
        ans = value * 304.8;
      } else if (unit == "yd") {
        ans = value * 914.4;
      } else if (unit == "dm") {
        ans = value * 100;
      } else if (unit == "mm") {
        ans = value;
      }
      return ans;
    }
    function convert_to_kilo(unit, value) {
      if (unit == "g") {
        ans = value / 1000;
      } else if (unit == "lb") {
        ans = value / 2.205;
      } else if (unit == "t") {
        ans = value * 1000;
      } else if (unit == "stone") {
        ans = value * 6.35029;
      } else if (unit == "kg") {
        ans = value;
      }
      return ans;
    }
    function convert_to_meter_cube(unit, value) {
      if (unit == "cm³") {
        ans = value / 1000000;
      } else if (unit == "cu_ft") {
        ans = value / 35.315;
      } else if (unit == "cu_yd") {
        ans = value / 1.308;
      } else if (unit == "m³") {
        ans = value;
      }
      return ans;
    }

    // ---------------------- Validation ----------------------
    if (
      !isNaN(wall_width) &&
      !isNaN(mortar_joint_thickness) &&
      !isNaN(brick_width)
    ) {
      if (
        wall_length >= 0 &&
        wall_width >= 0 &&
        wall_height >= 0 &&
        mortar_joint_thickness >= 0 &&
        brick_wastage >= 0 &&
        brick_length >= 0 &&
        brick_width >= 0 &&
        brick_height >= 0 &&
        price_per_brick >= 0
      ) {
        // Convert wall & brick dimensions
        wall_length = convert_to_meter(wall_length_unit, wall_length);
        wall_width = convert_to_meter(wall_width_unit, wall_width);
        wall_height = convert_to_meter(wall_height_unit, wall_height);
        mortar_joint_thickness = convert_to_meter(
          mortar_joint_thickness_unit,
          mortar_joint_thickness
        );

        // Wall area
        const wall_area = wall_length * wall_height;

        // Brick conversion
        if (brick_type === "1" || brick_type === 1) {
          brick_length = convert_to_meter(brick_length_unit, brick_length);
          brick_height = convert_to_meter(brick_height_unit, brick_height);
          brick_width = convert_to_meter(brick_width_unit, brick_width);
        } else {
          const brick_array = brick_type.split("x");
          brick_length = convert_to_meter("in", Number(brick_array[0]));
          brick_height = convert_to_meter("in", Number(brick_array[1]));
        }

        // Brick area
        const brick_sum =
          (brick_length + mortar_joint_thickness) *
          (brick_height + mortar_joint_thickness);
        let no_of_bricks = Math.ceil(wall_area / brick_sum);
        const wastage = Math.ceil((brick_wastage * no_of_bricks) / 100);
        let no_of_bricks_with_wastage = Math.round(no_of_bricks + wastage);

        if (wall_type === "double") {
          no_of_bricks *= 2;
          no_of_bricks_with_wastage *= 2;
        }

        // Cost of bricks
        const cost_of_bricks = price_per_brick * no_of_bricks_with_wastage;

        // Without mortar
        if (with_motar === "no") {
          param.tech_wall_area = wall_area;
          param.tech_no_of_bricks = no_of_bricks;
          param.tech_no_of_bricks_with_wastage = no_of_bricks_with_wastage;
          param.tech_cost_of_bricks = cost_of_bricks;
          return param;
        }

        // With mortar
        else if (with_motar === "yes") {
          if (
            !isNaN(wet_volume) &&
            !isNaN(mortar_wastage) &&
            !isNaN(bag_size) &&
            !isNaN(price_of_cement) &&
            !isNaN(price_sand_per_volume)
          ) {
            if (
              wet_volume >= 0 &&
              mortar_wastage >= 0 &&
              bag_size >= 0 &&
              price_of_cement >= 0 &&
              price_sand_per_volume >= 0
            ) {
              // Mortar calculations
              wet_volume = convert_to_meter_cube(wet_volume_unit, wet_volume);
              const dry_volume = wet_volume + (52 * wet_volume) / 100;
              const dry_volume_wastage = (mortar_wastage * dry_volume) / 100;
              const dry_volume_with_wastage = dry_volume + dry_volume_wastage;

              // Mortar ratio
              const ratio = mortar_ratio.split(":").map(Number);
              const cement_ratio = ratio[0];
              const sand_ratio = ratio[1];
              const total_ratio = cement_ratio + sand_ratio;

              const volume_of_cement = Number(
                (
                  (dry_volume_with_wastage * cement_ratio) /
                  total_ratio
                ).toFixed(4)
              );
              const weight_of_cement = volume_of_cement * 1440;
              bag_size = convert_to_kilo(bag_size_unit, bag_size);
              const number_of_bags = Math.ceil(weight_of_cement / bag_size);

              const volume_of_sand = Number(
                ((dry_volume_with_wastage * sand_ratio) / total_ratio).toFixed(
                  4
                )
              );

              const sand_vol_converted = convert_to_meter_cube(
                price_sand_volume_unit,
                price_sand_per_volume
              );
              const price_of_sand = sand_vol_converted * volume_of_sand;
              const price_for_cement = number_of_bags * price_of_cement;
              const mortar_cost = price_for_cement + price_of_sand;

              const total_cost = cost_of_bricks + mortar_cost;

              // Results
              param.tech_wall_area = wall_area;
              param.tech_no_of_bricks = no_of_bricks;
              param.tech_no_of_bricks_with_wastage = no_of_bricks_with_wastage;
              param.tech_cost_of_bricks = cost_of_bricks;
              param.tech_dry_volume = dry_volume;
              param.tech_dry_volume_with_wastage = dry_volume_with_wastage;
              param.tech_volume_of_cement = volume_of_cement;
              param.tech_number_of_bags = number_of_bags;
              param.tech_volume_of_sand = volume_of_sand;
              param.tech_mortar_cost = mortar_cost;
              param.tech_total_cost = total_cost;

              return param;
            } else {
              return { error: "Please! Enter Positive Values" };
            }
          } else {
            return { error: "Please! Check Your Input" };
          }
        }
      } else {
        return { error: "Please! Enter Positive Values" };
      }
    } else {
      return { error: "Please! Check Your Input" };
    }
  }

  async getCalculationMetalRoofCostCalculator(body) {
    try {
      let type = body.tech_type;
      let r_length = body.tech_r_length;
      let rl_units = body.tech_rl_units;
      let r_width = body.tech_r_width;
      let rw_units = body.tech_rw_units;
      let roof_pitch = body.tech_roof_pitch;
      let p_length = body.tech_p_length;
      let pl_units = body.tech_pl_units;
      let p_width = body.tech_p_width;
      let pw_units = body.tech_pw_units;
      let cost = body.tech_cost;

      // Roof pitch conversion table
      const roofPitch = {
        "1:12": { value: 1.003 },
        "2:12": { value: 1.014 },
        "3:12": { value: 1.031 },
        "4:12": { value: 1.054 },
        "5:12": { value: 1.083 },
        "6:12": { value: 1.118 },
        "7:12": { value: 1.158 },
        "8:12": { value: 1.202 },
        "9:12": { value: 1.25 },
        "10:12": { value: 1.302 },
        "11:12": { value: 1.357 },
        "12:12": { value: 1.414 },
        "13:12": { value: 1.474 },
        "14:12": { value: 1.537 },
        "15:12": { value: 1.601 },
        "16:12": { value: 1.667 },
        "17:12": { value: 1.734 },
        "18:12": { value: 1.803 },
        "19:12": { value: 1.873 },
        "20:12": { value: 1.944 },
        "21:12": { value: 2.016 },
        "22:12": { value: 2.088 },
        "23:12": { value: 2.162 },
        "24:12": { value: 2.236 },
        "25:12": { value: 2.311 },
        "26:12": { value: 2.386 },
        "27:12": { value: 2.462 },
        "28:12": { value: 2.539 },
        "29:12": { value: 2.615 },
        "30:12": { value: 2.693 },
      };

      // Convert to feet based on unit
      const roofUnit = (input, unit) => {
        if (unit == "cm") return input * 0.03281;
        if (unit == "dm") return input * 0.3281;
        if (unit == "m") return input * 3.281;
        if (unit == "in") return input * 0.08333;
        if (unit == "yd") return input * 3;
        return input; // default case (already feet)
      };

      // Ensure numeric input
      if (
        !isNaN(r_length) &&
        !isNaN(r_width) &&
        !isNaN(p_length) &&
        !isNaN(p_width) &&
        !isNaN(cost)
      ) {
        // Convert all lengths/widths to feet
        if (rl_units) r_length = roofUnit(Number(r_length), rl_units);
        if (rw_units) r_width = roofUnit(Number(r_width), rw_units);
        if (pl_units) p_length = roofUnit(Number(p_length), pl_units);
        if (pw_units) p_width = roofUnit(Number(p_width), pw_units);

        let r_area, p_area, panel, expense, value;

        if (type == "yes") {
          // Without roof pitch
          r_area = r_length * r_width;
          p_area = p_length * p_width;
          panel = Math.round(r_area / p_area);
          expense = cost * panel;
        } else if (type === "no") {
          // With roof pitch
          const Detail = roofPitch[roof_pitch];
          if (!Detail) {
            return { error: "Invalid roof pitch option" };
          }
          value = Detail.value;
          r_area = r_length * r_width * value;
          p_area = p_length * p_width;
          panel = Math.round(r_area / p_area);
          expense = cost * panel;
        } else {
          return { error: "Invalid type value" };
        }

        // ✅ Final structured response
        const result = {
          tech_type: type,
          tech_r_length: r_length,
          tech_r_width: r_width,
          tech_p_length: p_length,
          tech_p_width: p_width,
          tech_cost: cost,
          tech_r_area: r_area,
          tech_p_area: p_area,
          tech_panel: panel,
          tech_expense: expense,
        };

        if (type == "no") {
          result.tech_roof_pitch = roof_pitch;
          result.tech_value = value;
        }

        return result;
      } else {
        return { error: "Please! Check Your Input" };
      }
    } catch (err) {
      return { error: "An unexpected error occurred", details: err.message };
    }
  }

  async getCalculationRoofReplacementCostCalculator(body) {
    try {
      const size1 = body.tech_size1;
      const size2 = body.tech_size2;
      const slop = body.tech_slop;
      const difficulty = body.tech_difficulty;
      const existing = body.tech_existing;
      const floor = body.tech_floor;
      const material = body.tech_material;
      const region = body.tech_region;

      // ✅ Validate numeric input
      if (isNaN(size1) || isNaN(size2)) {
        return { error: "Please! Check Your Inputs" };
      }

      // ✅ Prepare form data
      const formData = new URLSearchParams();
      formData.append("size1", size1);
      formData.append("device", "desk");
      formData.append("size2", size2);
      formData.append("material", material);
      formData.append("slop", slop);
      formData.append("difficulty", difficulty);
      formData.append("sky", "");
      formData.append("ridge", "");
      formData.append("floor", floor);
      formData.append("existing", existing);
      formData.append("region", region);

      // ✅ Make POST request with axios
      const response = await axios.post(
        "https://www.roofcalc.org/scripts/calc-widget-test.php",
        formData,
        {
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
            Cookie: "PHPSESSID=9886c1db5ddcc7f383052a97e803ef26",
          },
          httpsAgent: new (
            await import("https")
          ).Agent({
            rejectUnauthorized: false, // ⚠️ Disable SSL verification like in PHP
          }),
          timeout: 10000, // 10 seconds timeout
        }
      );

      const data = response.data;

      // ✅ Extract all $ amounts using regex (like preg_match_all)
      const matches = data.match(/\$[0-9,]+/g);
      const result = matches || [];

      // ✅ Return structured output
      return {
        tech_result: result,
      };
    } catch (error) {
      // ✅ Error handling
      return {
        error: error.response
          ? `API Error: ${error.response.statusText}`
          : `Request Error: ${error.message}`,
      };
    }
  }

  async getCalculationSquareInchesCalculator(body) {
    let length = body.tech_length;
    let l_units = body.tech_l_units;
    let width = body.tech_width;
    let w_units = body.tech_w_units;
    let price = body.tech_price;

    // Convert to numbers where needed
    length = Number(length);
    width = Number(width);
    price = Number(price);

    // Helper function to convert to inches
    function squareToInches(value, unit) {
      if (unit == "ft") return value * 12;
      if (unit == "in") return value * 1;
      if (unit == "yd") return value * 36;
      if (unit == "cm") return value / 2.54;
      if (unit == "m") return value * 39.37;
      if (unit == "mi") return value / 1000;
      if (unit == "km") return value * 39370;
      if (unit == "mm") return value / 25.4; // Added mm conversion
      return NaN;
    }

    const param = {};

    if (!isNaN(length) && !isNaN(width)) {
      const lengthInches = squareToInches(length, l_units);
      const widthInches = squareToInches(width, w_units);

      if (isNaN(lengthInches) || isNaN(widthInches)) {
        param.error = "Invalid unit type";
        return param;
      }

      const square_inches = lengthInches * widthInches;
      param.tech_square_inches = square_inches;

      if (!isNaN(price)) {
        param.tech_cost = square_inches * price;
      }

      return param;
    } else {
      param.error = "Please! Check Your Inputs";
      return param;
    }
  }

  async getCalculationSodCalculator(body) {
    const method = body.tech_method;
    const length = body.tech_length;
    const length_unit = body.tech_length_unit;
    const width = body.tech_width;
    const width_unit = body.tech_width_unit;
    const area = body.tech_area;
    const area_unit = body.tech_area_unit;
    const price = body.tech_price;

    let param = {};

    // Helper function to round to significant figures
    function sigFig3(value, digits) {
      if (value === 0) return 0;
      const decimalPlaces =
        digits - Math.floor(Math.log10(Math.abs(value))) - 1;
      return Number(value.toFixed(decimalPlaces));
    }

    let total_area, rolls, pallets, acres;

    if (method === "lw" && !isNaN(length) && !isNaN(width)) {
      let l = Number(length);
      let w = Number(width);

      // ✅ Convert length units to feet
      if (length_unit == "cm") l = l / 30.48;
      else if (length_unit == "m") l = l / 0.3048;
      else if (length_unit == "km") l = l / 0.0003048;
      else if (length_unit == "in") l = l / 12;
      else if (length_unit == "yd") l = l / 0.33333;
      else if (length_unit == "mi") l = l / 0.0001894;

      // ✅ Convert width units to feet
      if (width_unit == "cm") w = w / 30.48;
      else if (width_unit == "m") w = w / 0.3048;
      else if (width_unit == "km") w = w / 0.0003048;
      else if (width_unit == "in") w = w / 12;
      else if (width_unit == "yd") w = w / 0.33333;
      else if (width_unit == "mi") w = w / 0.0001894;

      if (length_unit === "m" && width_unit === "m") {
        l = l * 0.3048;
        w = w * 0.3048;

        total_area = l * w;
        rolls = total_area + 1;
        pallets = total_area / 40;
        acres = total_area * 0.0001;
        param["tech_meter"] = "meter";
      } else {
        total_area = l * w;
        rolls = total_area / 10;
        pallets = total_area / 450;
        acres = total_area * 0.000022957;
      }
    } else if (method === "area" && !isNaN(area)) {
      let a = Number(area);

      // ✅ Area conversion to square feet
      if (area_unit == "km²") a = a / 0.0000000929;
      else if (area_unit == "yd²") a = a / 0.1111;
      else if (area_unit == "mi²") a = a / 0.00000003587;
      else if (area_unit == "a") a = a / 0.000929;
      else if (area_unit == "da") a = a / 0.0000929;
      else if (area_unit == "ha") a = a / 0.0001;
      else if (area_unit == "ac") a = a / 0.000022957;
      else if (area_unit == "soccer fields") a = a / 0.000013012;

      if (area_unit === "m²" || area_unit === "ha") {
        total_area = a;
        rolls = total_area;
        pallets = total_area / 40;
        acres = total_area * 0.0001;
        param["tech_meter"] = "meter";
      } else {
        total_area = a;
        rolls = total_area / 10;
        pallets = total_area / 450;
        acres = total_area * 0.000022957;
      }
    } else {
      param["error"] = "Please! Check Your Input";
      return param;
    }

    // ✅ Cost calculation
    if (!isNaN(price)) {
      const cost = price * rolls;
      const cost_ft2 = cost / total_area;
      param["tech_cost"] = cost.toFixed(2);
      param["tech_cost_ft2"] = cost_ft2.toFixed(2);
    }

    // ✅ Final results
    param["tech_total_area"] = Number(total_area).toLocaleString();
    param["tech_rolls"] = Number(rolls).toLocaleString();
    param["tech_pallets"] = pallets.toFixed(2);
    param["tech_acres"] = acres.toFixed(3);

    return param;
  }

  async getCalculationConcreteBlockCalculator(body) {
    const width = body.tech_width;
    const height = body.tech_height;
    const width_unit = body.tech_width_unit;
    const height_unit = body.tech_height_unit;
    const block_size = body.tech_block_size;
    const block_price = body.tech_block_price;

    let param = {};

    let w = Number(width);
    let h = Number(height);
    let price = Number(block_price);

    // ✅ Unit conversion for height
    if (height_unit) {
      if (height_unit == "cm") {
        h = h * 0.3937;
      } else if (height_unit == "mm") {
        h = h * 0.03937;
      } else if (height_unit == "m") {
        h = h * 39.37;
      } else if (height_unit == "in") {
        // Already inches
      } else if (height_unit == "ft") {
        h = h * 12;
      }
    }

    // ✅ Unit conversion for width
    if (width_unit) {
      if (width_unit == "cm") {
        w = w * 0.3937;
      } else if (width_unit == "mm") {
        w = w * 0.03937;
      } else if (width_unit == "m") {
        w = w * 39.37;
      } else if (width_unit == "in") {
        // Already inches
      } else if (width_unit == "ft") {
        w = w * 12;
      }
    }

    // ✅ Validation
    if (!isNaN(w) && !isNaN(h) && !isNaN(price)) {
      const wall_area = w * h;
      let block_area = 0;

      // ✅ Block size mapping
      if (block_size == "16x8") {
        block_area = 16 * 8;
      } else if (block_size == "8x8") {
        block_area = 8 * 8;
      } else if (block_size == "12x8") {
        block_area = 12 * 8;
      } else if (block_size == "8x4") {
        block_area = 8 * 4;
      } else if (block_size == "12x4") {
        block_area = 12 * 4;
      } else if (block_size == "16x4") {
        block_area = 16 * 4;
      } else {
        param["error"] = "Invalid block size.";
        return param;
      }

      // ✅ Calculations
      const blocks_needed = Math.round(wall_area / block_area);
      const total_block_cost = blocks_needed * price;
      const mortar_estimation = Math.ceil(blocks_needed / 100) * 3;

      // ✅ Assign results
      param["tech_wall_area"] = wall_area;
      param["tech_blocks_needed"] = blocks_needed;
      param["tech_total_block_cost"] = total_block_cost;
      param["tech_mortar_estimation"] = mortar_estimation;
    } else {
      param["error"] = "Please check input.";
      return param;
    }

    return param;
  }

  async getCalculationCarpetCalculator(body) {
    const shape = body.tech_shape;
    const length = body.tech_length;
    const length_unit = body.tech_length_unit;
    const width = body.tech_width;
    const width_unit = body.tech_width_unit;
    const radius = body.tech_radius;
    const radius_unit = body.tech_radius_unit;
    const axis_a = body.tech_axis_a;
    const axis_a_unit = body.tech_axis_a_unit;
    const axis_b = body.tech_axis_b;
    const axis_b_unit = body.tech_axis_b_unit;
    const side = body.tech_side;
    const side_unit = body.tech_side_unit;
    const sides = body.tech_sides;
    const sides_unit = body.tech_sides_unit;
    const carpet = body.tech_carpet;
    const carpet_unit = body.tech_carpet_unit;
    const price = body.tech_price;
    const price_unit = body.tech_price_unit;
    const currancy = body.tech_currancy;

    let param = {};

    // 🔹 Clean values
    let l = Number(length);
    let w = Number(width);
    let r = Number(radius);
    let a = Number(axis_a);
    let b = Number(axis_b);
    let s = Number(side);
    let ss = Number(sides);
    let c = Number(carpet);
    let p = Number(price);

    // 🔹 Remove currency symbol from price_unit
    let cleanPriceUnit = price_unit
      ? price_unit.replace(currancy + " ", "")
      : "";

    // 🔹 Unit conversion for carpet dimensions
    function carpetUnits(value, unit) {
      if (unit === "cm") {
        return value / 100;
      } else if (unit === "dm") {
        return value / 10;
      } else if (unit === "in") {
        return value * 0.0254;
      } else if (unit === "ft") {
        return value * 0.3048;
      } else if (unit === "yd") {
        return value * 0.9144;
      } else {
        return value; // assume meters
      }
    }

    // 🔹 Unit conversion for price
    function priceUnits(value, unit) {
      if (unit === "cm²") {
        return value / 10000;
      } else if (unit === "dm²") {
        return value / 100;
      } else if (unit === "in²") {
        return value / 1550.0031;
      } else if (unit === "ft²") {
        return value / 10.7639;
      } else if (unit === "yd²") {
        return value / 1.19599;
      } else {
        return value; // assume m²
      }
    }

    let answer = null;
    let sub_answer = null;

    // 🔹 Shape-based logic
    if (shape === "Rectangle") {
      if (isFinite(l) && isFinite(w) && isFinite(p)) {
        l = carpetUnits(l, length_unit);
        w = carpetUnits(w, width_unit);
        answer = l * w;
        sub_answer = answer * p;
      } else {
        param["error"] = "Please! Check Your Input";
        return param;
      }
    } else if (shape === "Circle") {
      if (isFinite(r) && isFinite(p)) {
        r = carpetUnits(r, radius_unit);
        answer = Math.PI * Math.pow(r, 2);
        sub_answer = answer * p;
      } else {
        param["error"] = "Please! Check Your Input";
        return param;
      }
    } else if (shape === "Ellipse") {
      if (isFinite(a) && isFinite(b) && isFinite(p)) {
        a = carpetUnits(a, axis_a_unit);
        b = carpetUnits(b, axis_b_unit);
        answer = a * b * Math.PI;
        sub_answer = answer * p;
      } else {
        param["error"] = "Please! Check Your Input";
        return param;
      }
    } else if (shape === "Pentagon") {
      if (isFinite(s) && isFinite(p)) {
        s = carpetUnits(s, side_unit);
        answer = (s * s * Math.sqrt(25 + 10 * Math.sqrt(5))) / 4;
        sub_answer = answer * p;
      } else {
        param["error"] = "Please! Check Your Input";
        return param;
      }
    } else if (shape === "Hexagon") {
      if (isFinite(ss) && isFinite(p)) {
        ss = carpetUnits(ss, sides_unit);
        answer = (3 / 2) * Math.sqrt(3) * Math.pow(ss, 2);
        sub_answer = answer * p;
      } else {
        param["error"] = "Please! Check Your Input";
        return param;
      }
    } else {
      if (isFinite(c) && isFinite(p)) {
        answer = priceUnits(c, carpet_unit);
        sub_answer = answer * p;
      } else {
        param["error"] = "Please! Check Your Input";
        return param;
      }
    }

    // ✅ Final response
    param["tech_answer"] = answer;
    param["tech_sub_answer"] = sub_answer;

    return param;
  }

  async getCalculationCylinderVolumeCalculator(body) {
    try {
      let f_height = body.tech_f_height;
      let f_height_units = body.tech_f_height_units;
      let f_radius = body.tech_f_radius;
      let f_radius_units = body.tech_f_radius_units;
      let s_height = body.tech_s_height;
      let s_height_units = body.tech_s_height_units;
      let external = body.tech_external;
      let external_units = body.tech_external_units;
      let internal = body.tech_internal;
      let internal_units = body.tech_internal_units;

      // Helper function: convert all to centimeters
      function convert_unit(unit, value) {
        if (!unit) return value;
        value = Number(value);

        switch (unit) {
          case "cm":
            return value;
          case "mm":
            return value / 0.1;
          case "m":
            return value * 100;
          case "km":
            return value * 100000;
          case "in":
            return value * 2.54;
          case "ft":
            return value * 30.48;
          case "yd":
            return value * 91.44;
          case "mi":
            return value * 160934.4;
          default:
            return value;
        }
      }

      // Validate all numeric inputs
      if (
        isNaN(f_height) ||
        isNaN(f_radius) ||
        isNaN(s_height) ||
        isNaN(external) ||
        isNaN(internal)
      ) {
        return { error: "Please! Check Your Input" };
      }

      // Convert units
      f_height = convert_unit(f_height_units, f_height);
      f_radius = convert_unit(f_radius_units, f_radius);
      s_height = convert_unit(s_height_units, s_height);
      external = convert_unit(external_units, external);
      internal = convert_unit(internal_units, internal);

      // Calculate volumes
      const vol1 = Math.PI * Math.pow(f_radius, 2) * f_height;
      const vol2 =
        (Math.PI * s_height * (Math.pow(external, 2) - Math.pow(internal, 2))) /
        4;

      return {
        tech_vol1: vol1,
        tech_vol2: vol2,
      };
    } catch (err) {
      return { error: "Server error occurred" };
    }
  }

  async getCalculationFramingCalculator(body) {
    try {
      let wall = body.tech_wall;
      let wall_unit = body.tech_wall_unit;
      let spacing = body.tech_spacing;
      let spacing_unit = body.tech_spacing_unit;
      let price = body.tech_price;
      let estimated = body.tech_estimated;

      // Helper function to convert to meters
      function framing_units(value, unit) {
        value = Number(value);
        switch (unit) {
          case "cm":
            return value / 100;
          case "dm":
            return value / 10;
          case "in":
            return value * 0.0254;
          case "ft":
            return value * 0.3048;
          case "yd":
            return value * 0.9144;
          case "m":
          default:
            return value;
        }
      }

      // Validate numeric inputs
      if (isNaN(wall) || isNaN(spacing) || isNaN(price) || isNaN(estimated)) {
        return { error: "Please! Check Your Input" };
      }

      // Convert units
      wall = framing_units(wall, wall_unit);
      spacing = framing_units(spacing, spacing_unit);

      // Prevent divide-by-zero
      if (spacing == 0) {
        return { error: "oc spacing cannot be equal to zero" };
      }

      // Calculations
      const answer = wall / spacing + 1; // number of studs
      const wastages = answer * (estimated / 100);
      const wastage = wastages * price;
      const studs = price * answer;
      const sub_answer = studs + wastage; // total cost including wastage

      return {
        tech_answer: answer,
        tech_sub_answer: sub_answer,
      };
    } catch (err) {
      return { error: "Server error occurred" };
    }
  }

  async getCalculationRoofingCalculator(body) {
    try {
      let length = body.tech_length;
      let length_units = body.tech_length_units;
      let width = body.tech_width;
      let width_units = body.tech_width_units;
      let pitch = body.tech_pitch;
      let price = body.tech_price;
      let price_units = body.tech_price_units;

      // Convert value to meters
      function conversion(unit, value) {
        value = Number(value);
        switch (unit) {
          case "cm":
            return value / 100;
          case "m":
            return value;
          case "in":
            return value * 0.0254;
          case "ft":
            return value * 0.3048;
          case "yd":
            return value * 0.9144;
          default:
            return value;
        }
      }

      // Convert price per area to price per m²
      if (price_units) {
        price = Number(price);
        switch (price_units) {
          case "m²":
            price = price;
            break;
          case "mm²":
            price /= 0.000001;
            break;
          case "cm²":
            price /= 0.0001;
            break;
          case "in²":
            price /= 0.00064516;
            break;
          case "ft²":
            price /= 0.09290304;
            break;
          case "yd²":
            price /= 0.83612736;
            break;
        }
      }

      // Validate inputs
      if (isNaN(length) || isNaN(width) || isNaN(pitch) || isNaN(price)) {
        return { error: "Please check input." };
      }

      // Convert units to meters
      length = conversion(length_units, length);
      width = conversion(width_units, width);

      // Core calculations
      const house_area = length * width;
      const slop = (pitch * 12) / 100;
      const pitch_rad = Math.atan(pitch / 100);
      const pitch_deg = (pitch_rad * 180) / Math.PI;
      const roof_area = house_area / Math.cos((pitch_deg * Math.PI) / 180);
      const cost = roof_area * price;

      // Return results
      return {
        tech_house_area: house_area,
        tech_slop: slop,
        tech_pitch_deg: pitch_deg,
        tech_roof_area: roof_area,
        tech_cost: cost,
      };
    } catch (err) {
      return { error: "Server error occurred" };
    }
  }

  async getCalculationDeckingCalculator(body) {
    let deck_length = body.tech_deck_length;
    let deck_length_unit = body.tech_deck_length_unit;
    let deck_width = body.tech_deck_width;
    let deck_width_unit = body.tech_deck_width_unit;
    let board_length = body.tech_board_length;
    let board_length_unit = body.tech_board_length_unit;
    let board_width = body.tech_board_width;
    let board_width_unit = body.tech_board_width_unit;
    let material = body.tech_material;
    let price = body.tech_price;
    let Cost = body.tech_Cost;

    // Trim all string inputs
    deck_length = deck_length?.toString().trim();
    deck_length_unit = deck_length_unit?.toString().trim();
    deck_width = deck_width?.toString().trim();
    deck_width_unit = deck_width_unit?.toString().trim();
    board_length = board_length?.toString().trim();
    board_length_unit = board_length_unit?.toString().trim();
    board_width = board_width?.toString().trim();
    board_width_unit = board_width_unit?.toString().trim();
    material = material?.toString().trim();
    price = price?.toString().trim();
    Cost = Cost?.toString().trim();

    // Convert to numbers
    deck_length = Number(deck_length);
    deck_width = Number(deck_width);
    board_length = Number(board_length);
    board_width = Number(board_width);
    price = Number(price);
    Cost = Number(Cost);

    // Helper function for unit conversion
    function unit_change(value, unit) {
      if (unit == "cm") {
        return value * 30.48;
      } else if (unit == "m") {
        return value / 3.28084;
      } else if (unit == "in") {
        return value * 12;
      } else if (unit == "ft") {
        return value;
      }
      return value;
    }

    const result = {};

    // Validate numeric inputs
    if (
      !isFinite(deck_length) ||
      !isFinite(deck_width) ||
      !isFinite(board_length) ||
      !isFinite(board_width) ||
      !isFinite(price) ||
      !isFinite(Cost)
    ) {
      result.error = "Please check your input";
      return result;
    }

    // Zero-value validations
    if (deck_length == 0) {
      result.error = "length value cannot be equal to zero";
      return result;
    }
    if (deck_width == 0) {
      result.error = "width value cannot be equal to zero";
      return result;
    }
    if (board_length == 0) {
      result.error = "length value cannot be equal to zero";
      return result;
    }
    if (board_width == 0) {
      result.error = "width value cannot be equal to zero";
      return result;
    }
    if (price == 0) {
      result.error = "price per board value cannot be equal to zero";
      return result;
    }
    if (Cost == 0) {
      result.error = "cost of fasteners value cannot be equal to zero";
      return result;
    }

    // Unit conversions
    deck_length = unit_change(deck_length, deck_length_unit);
    deck_width = unit_change(deck_width, deck_width_unit);
    board_length = unit_change(board_length, board_length_unit);
    board_width = unit_change(board_width, board_width_unit);

    // Calculations
    const size_deck = deck_length * deck_width; // ans 1
    const size_board = board_length * board_width; // ans 2
    const numbers = Math.round((size_deck / size_board) * 1.1); // ans 3
    const materialValue = size_deck / 100;
    const nails = materialValue * 350; // ans 4
    const clips = nails / 2; // ans 5
    const price_boards = numbers * price; // ans 6
    const Cost_boards = price_boards + Cost; // ans 7

    // Build response
    result.tech_size_deck = size_deck;
    result.tech_size_board = size_board;
    result.tech_numbers = numbers;
    result.tech_nails = nails;
    result.tech_clips = clips;
    result.tech_price_boards = price_boards;
    result.tech_Cost_boards = Cost_boards;

    return result;
  }

  async getCalculationSonotubeCalculator(body) {
    let size_unit = body.tech_size_unit;
    let height = body.tech_height;
    let height_unit = body.tech_height_unit;
    let quantity = body.tech_quantity;
    let concerete_mix_unit = body.tech_concerete_mix_unit;
    let density = body.tech_density;
    let density_unit = body.tech_density_unit;
    let concrete_ratio_unit = body.tech_concrete_ratio_unit;
    let bag_size = body.tech_bag_size;
    let bag_size_unit = body.tech_bag_size_unit;
    let waste = body.tech_waste;
    let Cost_bag_mix = body.tech_Cost_bag_mix;
    let Cost_of_cement = body.tech_Cost_of_cement;
    let Cost_of_cement_unit = body.tech_Cost_of_cement_unit;
    let Cost_of_sand = body.tech_Cost_of_sand;
    let Cost_of_sand_unit = body.tech_Cost_of_sand_unit;
    let Cost_of_gravel = body.tech_Cost_of_gravel;
    let Cost_of_gravel_unit = body.tech_Cost_of_gravel_unit;

    // Trim all inputs
    const trimVal = (v) => (typeof v === "string" ? v.trim() : v);
    size_unit = trimVal(size_unit);
    height = Number(trimVal(height));
    height_unit = trimVal(height_unit);
    quantity = Number(trimVal(quantity));
    concerete_mix_unit = trimVal(concerete_mix_unit);
    density = Number(trimVal(density));
    density_unit = trimVal(density_unit);
    concrete_ratio_unit = trimVal(concrete_ratio_unit);
    bag_size = Number(trimVal(bag_size));
    bag_size_unit = trimVal(bag_size_unit);
    waste = Number(trimVal(waste));
    Cost_bag_mix = Number(trimVal(Cost_bag_mix));
    Cost_of_cement = Number(trimVal(Cost_of_cement));
    Cost_of_cement_unit = trimVal(Cost_of_cement_unit);
    Cost_of_sand = Number(trimVal(Cost_of_sand));
    Cost_of_sand_unit = trimVal(Cost_of_sand_unit);
    Cost_of_gravel = Number(trimVal(Cost_of_gravel));
    Cost_of_gravel_unit = trimVal(Cost_of_gravel_unit);

    const result = {};

    // Size mapping
    const sizeMap = {
      "6 (15.24 cm)": 6 / 2,
      "8 (20.32 cm)": 8 / 2,
      "10 (25.40 cm)": 10 / 2,
      "12 (30.48 cm)": 12 / 2,
      "14 (35.56 cm)": 14 / 2,
      "16 (40.64 cm)": 16 / 2,
      "18 (45.72 cm)": 18 / 2,
      "20 (50.80 cm)": 20 / 2,
      "22 (55.88 cm)": 22 / 2,
      "24 (60.96 cm)": 24 / 2,
      "26 (66.04 cm)": 26 / 2,
      "28 (71.12 cm)": 28 / 2,
      "30 (76.20 cm)": 30 / 2,
      "32 (81.28 cm)": 32 / 2,
      "34 (86.36 cm)": 34 / 2,
      "36 (91.44 cm)": 36 / 2,
      "40 (101.60 cm)": 40 / 2,
      "42 (106.68 cm)": 42 / 2,
      "48 (121.91 cm)": 48 / 2,
      "54 (137.16 cm)": 54 / 2,
      "60 (152.40 cm)": 60 / 2,
    };
    const size = sizeMap[size_unit] ?? 0;

    // Helper conversions
    const section_height = (val, unit) => {
      if (unit === "cm") return val * 2.54;
      if (unit === "m") return val / 39.37;
      if (unit === "in") return val;
      if (unit === "ft") return val / 12;
      if (unit === "yd") return val / 36;
      return val;
    };

    const section_density = (val, unit) => {
      if (unit === "kg/m³") return val * 16.01846;
      if (unit === "lb/cu ft") return val;
      if (unit === "lb/cu yd") return val * 27;
      if (unit === "g/cm³") return val * 0.01601846;
      return val;
    };

    const section_bag_size = (val, unit) => {
      if (unit === "kg") return val;
      if (unit === "lb") return val * 2.205;
      return val;
    };

    const section_two = (val, unit) => {
      if (unit === "cm³") return val * 28320;
      if (unit === "m³") return val / 35.315;
      if (unit === "cu ft") return val;
      if (unit === "cu yd") return val / 27;
      return val;
    };

    // Input validation
    if (!isFinite(height) || !isFinite(quantity)) {
      return { error: "Please! Check Your Input" };
    }

    if (height === 0) return { error: "height value cannot be equal to zero" };
    if (quantity === 0)
      return { error: "quantity value cannot be equal to zero" };

    // Volume calculation
    const heightIn = section_height(height, height_unit);
    const radius = size * size;
    const volume = (Math.round(3.1415 * radius * heightIn) / 1728) * quantity;

    // CASE 1: Pre-mixed concrete bags
    if (concerete_mix_unit === "I'll get pre-mixed concrete bags") {
      if (
        !isFinite(density) ||
        !isFinite(bag_size) ||
        !isFinite(waste) ||
        !isFinite(Cost_bag_mix)
      ) {
        return { error: "Please! Check Your Input" };
      }
      if (density === 0)
        return { error: "concrete density value cannot be equal to zero" };
      if (bag_size === 0)
        return { error: "bag size value cannot be equal to zero" };
      if (waste === 0) return { error: "waste value cannot be equal to zero" };
      if (Cost_bag_mix === 0)
        return {
          error:
            "Cost of each bag of pre-mix concrete value cannot be equal to zero",
        };

      const densityz = section_density(density, density_unit);
      const weight = volume * densityz;
      const bagSize = section_bag_size(bag_size, bag_size_unit);
      const bagEffective = bagSize * (1 - waste / 100);
      const bags = Math.round(weight / 2.205 / bagEffective);
      const costTotal = Cost_bag_mix * bags;
      const perUnit = Number((costTotal / volume).toFixed(2));
      const costPerColumn = perUnit * volume;

      result.tech_weghits = weight;
      result.tech_bagsz = bags;
      result.tech_per_units = perUnit;
      result.tech_cost_per_colums = costPerColumn;
      result.tech_total_costz = costPerColumn;
    }

    // CASE 2: Manual concrete mix
    else {
      if (
        !isFinite(waste) ||
        !isFinite(Cost_of_cement) ||
        !isFinite(Cost_of_sand) ||
        !isFinite(Cost_of_gravel)
      ) {
        return { error: "Please! Check Your Input" };
      }

      if (waste === 0) return { error: "waste value cannot be equal to zero" };
      if (Cost_of_cement === 0)
        return {
          error: "cost of cement per volume value cannot be equal to zero",
        };
      if (Cost_of_sand === 0)
        return {
          error: "cost of sand per volume value cannot be equal to zero",
        };
      if (Cost_of_gravel === 0)
        return {
          error: "cost of gravel per volume value cannot be equal to zero",
        };

      const total_volume = volume * (1 + waste / 100);
      const value_cement = (total_volume * 1) / (size * 2);

      let ratio_of_sand = 0;
      let ratio_of_gravel = 0;

      if (concrete_ratio_unit === "1:5:10 (5.0 MPa or 725 psi)") {
        ratio_of_sand = 5;
        ratio_of_gravel = 10;
      } else if (concrete_ratio_unit === "1:4:8 (7.5 MPa or 1085 psi)") {
        ratio_of_sand = 4;
        ratio_of_gravel = 8;
      } else if (concrete_ratio_unit === "1:3:6 (10.0 MPa or 1450 psi)") {
        ratio_of_sand = 3;
        ratio_of_gravel = 6;
      } else if (concrete_ratio_unit === "1:2:4 (15.0 MPa or 2175 psi)") {
        ratio_of_sand = 2;
        ratio_of_gravel = 4;
      } else if (concrete_ratio_unit === "1:1.5:3 (20.0 MPa or 2900 psi)") {
        ratio_of_sand = 1.5;
        ratio_of_gravel = 3;
      }

      const value_sand = (total_volume * ratio_of_sand) / (size * 2);
      const value_gravel = (total_volume * ratio_of_gravel) / (size * 2);

      const cementCost =
        section_two(Cost_of_cement, Cost_of_cement_unit) * value_cement;
      const sandCost =
        section_two(Cost_of_sand, Cost_of_sand_unit) * value_sand;
      const gravelCost =
        section_two(Cost_of_gravel, Cost_of_gravel_unit) * value_gravel;
      const total_cost = cementCost + sandCost + gravelCost;

      result.tech_total_volume = total_volume;
      result.tech_value_cement = value_cement;
      result.tech_value_sand = value_sand;
      result.tech_value_gravel = value_gravel;
      result.tech_total_costszz = total_cost;
    }

    // Final output
    result.tech_volume = volume;
    return result;
  }

  async getCalculationGravelCalculator(body) {
    try {
      let from = body.tech_from;
      let to_calculate = body.tech_to_calculate;
      let length = body.tech_length;
      let l_unit = body.tech_l_unit;
      let volume = body.tech_volume;
      let v_unit = body.tech_v_unit;
      let width = body.tech_width;
      let w_unit = body.tech_w_unit;
      let area = body.tech_area;
      let a_unit = body.tech_a_unit;
      let depth = body.tech_depth;
      let d_unit = body.tech_d_unit;
      let density = body.tech_density;
      let dn_unit = body.tech_dn_unit;
      let price = body.tech_price;
      let p_unit = body.tech_p_unit;
      let currancy = body.tech_currancy;
      let diameter = body.tech_diameter;
      let dia_unit = body.tech_dia_unit;

      const param = {};

      // Clean price unit
      if (p_unit) p_unit = p_unit.replace(`${currancy} `, "");

      // ✅ Helper function for unit conversions
      const convertToFeet = (value, unit) => {
        if (unit === "in") return value / 12;
        if (unit === "yd") return value * 3;
        if (unit === "cm") return value / 30.48;
        if (unit === "m") return value * 3.28084;
        return value;
      };

      const convertDensity = (value, unit) => {
        if (unit === "lb/yd³") return value / 27;
        if (unit === "t/yd³") return value / 74.074;
        if (unit === "kg/m³") return value / 16.018;
        return value;
      };

      const convertPriceWeight = (weight, priceUnit) => {
        if (priceUnit === "kg") return weight / 2.205;
        if (priceUnit === "g") return weight * 453.59;
        if (priceUnit === "t") return weight / 2205;
        return weight;
      };

      // ===============================
      // 🟢 RECTANGULAR SECTION
      // ===============================
      if (from == "rec") {
        // ---- CASE 1: Length, Width, Depth ----
        if (to_calculate == "1") {
          if (isNaN(length) || isNaN(width) || isNaN(depth) || isNaN(density)) {
            param.error = "Please! Check Your Input";
            return param;
          }

          length = convertToFeet(length, l_unit);
          width = convertToFeet(width, w_unit);
          depth = convertToFeet(depth, d_unit);
          density = convertDensity(density, dn_unit);

          const area = +(length * width).toFixed(3);
          const volume = +(depth * area).toFixed(3);
          const weight = +(density * volume).toFixed(3);

          if (price) {
            let p_weight = convertPriceWeight(weight, p_unit);
            param.tech_price = +(p_weight * price).toFixed(3);
          }

          Object.assign(param, {
            tech_area: area,
            tech_weight: weight,
            tech_volume: volume,
          });
          return param;
        }

        // ---- CASE 2: Area, Depth ----
        if (to_calculate == "2") {
          if (isNaN(area) || isNaN(depth) || isNaN(density)) {
            param.error = "Please! Check Your Input";
            return param;
          }

          if (a_unit === "m²") area = area * 10.764;
          else if (a_unit === "yd²") area = area * 9;

          depth = convertToFeet(depth, d_unit);
          density = convertDensity(density, dn_unit);

          const volume = +(depth * area).toFixed(3);
          const weight = +(density * volume).toFixed(3);

          if (price) {
            let p_weight = convertPriceWeight(weight, p_unit);
            param.tech_price = +(p_weight * price).toFixed(3);
          }

          Object.assign(param, {
            tech_area: area,
            tech_weight: weight,
            tech_volume: volume,
          });
          return param;
        }

        // ---- CASE 3: Volume ----
        if (to_calculate == "3") {
          if (isNaN(volume) || isNaN(density)) {
            param.error = "Please! Check Your Input";
            return param;
          }

          if (v_unit === "m³") volume = volume * 35.315;
          else if (v_unit === "yd³") volume = volume * 27;

          density = convertDensity(density, dn_unit);
          const weight = +(density * volume).toFixed(3);

          if (price) {
            let p_weight = convertPriceWeight(weight, p_unit);
            param.tech_price = +(p_weight * price).toFixed(3);
          }

          Object.assign(param, {
            tech_weight: weight,
            tech_volume: volume,
          });
          return param;
        }
      }

      // ===============================
      // 🟢 CIRCULAR SECTION
      // ===============================
      else {
        if (isNaN(diameter) || isNaN(density)) {
          param.error = "Please! Check Your Input";
          return param;
        }

        diameter = convertToFeet(diameter, dia_unit);
        depth = convertToFeet(depth, d_unit);
        density = convertDensity(density, dn_unit);

        const area = Math.PI * Math.pow(diameter / 2, 2);
        const volume = +(depth * area).toFixed(3);
        const weight = +(density * volume).toFixed(3);

        if (price) {
          let p_weight = convertPriceWeight(weight, p_unit);
          param.tech_price = +(p_weight * price).toFixed(3);
        }

        Object.assign(param, {
          tech_area: area,
          tech_weight: weight,
          tech_volume: volume,
        });
        return param;
      }
    } catch (error) {
      return { error: "An unexpected error occurred", message: error.message };
    }
  }

  async getCalculationMulchCalculator(body) {
    try {
      const param = {};

      // Extract all values from body
      const m_shape = body["tech_m-shape"];
      const length = parseFloat(body.tech_length);
      const length_unit = body.tech_length1;
      const width = parseFloat(body.tech_width);
      const width_unit = body.tech_width1;
      const area = parseFloat(body["tech_sqr-ft"]);
      const area_unit = body["tech_sqr-ft1"];
      const depth = parseFloat(body.tech_depth);
      const depth_unit = body.tech_depth1;
      const bag_size = parseFloat(body.tech_bag_size);
      const bag_size1 = body.tech_bag_size1;
      const price_bag = parseFloat(body.tech_price_bag);
      const m_type = body["tech_m-type"];
      const check = body.tech_check;
      const g = body.tech_g;
      const diameter = parseFloat(body.tech_diameter);
      const diameter_unit = body.tech_diameter1;
      const side1 = parseFloat(body.tech_side1);
      const side1_unit = body.tech_side11;
      const side2 = parseFloat(body.tech_side2);
      const side2_unit = body.tech_side21;
      // Helper functions
      function isNumeric(value) {
        return !isNaN(parseFloat(value)) && isFinite(value);
      }

      function round(value, decimals) {
        return Number(Math.round(value + "e" + decimals) + "e-" + decimals);
      }

      function convertToFeet(value, unit) {
        switch (unit) {
          case "in":
            return value / 12;
          case "yd":
            return value * 3;
          case "cm":
            return value / 30.48;
          case "m":
            return value * 3.281;
          case "ft":
          default:
            return value;
        }
      }

      function convertToInches(value, unit) {
        switch (unit) {
          case "ft":
            return value * 12;
          case "yd":
            return value * 36;
          case "cm":
            return value / 2.54;
          case "m":
            return value * 39.37;
          case "in":
          default:
            return value;
        }
      }

      function convertBagSize(bagSize, unit) {
        switch (unit) {
          case "m³":
            return bagSize * 35.315;
          case "cu yd":
            return bagSize * 27;
          case "liters":
            return bagSize / 28.317;
          case "cu ft":
          default:
            return bagSize;
        }
      }

      // Rectangle/Square shape
      if (m_shape === "0") {
        // Using length and width
        if (check === "g1_value" || g === "g1") {
          if (isNumeric(length) && isNumeric(width) && isNumeric(depth)) {
            let convertedLength = convertToFeet(length, length_unit);
            let convertedWidth = convertToFeet(width, width_unit);
            let convertedDepth = convertToInches(depth, depth_unit);

            const garden_size = convertedLength * convertedWidth;
            const cubic_yards =
              (convertedLength * convertedWidth * convertedDepth) / 324;
            const cubic_ft = cubic_yards * 27;
            const cubic_meters = cubic_yards / 1.308;
            const liters = cubic_meters * 1000;

            // Calculate bags needed
            if (isNumeric(bag_size)) {
              let convertedBagSize = convertBagSize(bag_size, bag_size1);
              const size = cubic_ft / convertedBagSize;
              param.tech_size = round(size, 2);

              if (isNumeric(price_bag)) {
                const total_cost = price_bag * size;
                param.tech_total_cost = round(total_cost, 2);
              }
            }

            // Calculate based on mulch type
            if (m_type === "6") {
              const size1 = (garden_size / 235) * convertedDepth * 2;
              param.tech_size1 = round(size1, 2);
              if (isNumeric(price_bag)) {
                const total_cost1 = price_bag * size1;
                param.tech_total_cost1 = round(total_cost1, 2);
              }
            }

            if (m_type === "10") {
              const size1 = (garden_size / 235) * convertedDepth;
              param.tech_size1 = round(size1, 2);
              if (isNumeric(price_bag)) {
                const total_cost1 = price_bag * size1;
                param.tech_total_cost1 = round(total_cost1, 2);
              }
            }

            param.tech_garden_size = round(garden_size, 2);
            param.tech_cubic_yards = round(cubic_yards, 2);
            param.tech_cubic_ft = round(cubic_ft, 2);
            param.tech_cubic_meters = round(cubic_meters, 2);
            param.tech_liters = round(liters, 2);

            return param;
          } else {
            param.error = "Please! Check Your Input";
            return param;
          }
        }
        // Using area directly
        else {
          if (isNumeric(area) && isNumeric(depth)) {
            let convertedArea = area;

            if (area_unit === "acres") {
              area = area * 43560;
            }

            let convertedDepth = depth;

            const cubic_yards = (convertedArea * convertedDepth) / 324;
            const cubic_ft = cubic_yards * 27;
            const cubic_meters = cubic_yards / 1.308;
            const liters = cubic_meters * 1000;

            // Calculate bags needed
            if (isNumeric(bag_size)) {
              let convertedBagSize = convertBagSize(bag_size, bag_size1);
              const size = cubic_ft / convertedBagSize;
              param.tech_size = round(size, 2);

              if (isNumeric(price_bag)) {
                const total_cost = price_bag * size;
                param.tech_total_cost = round(total_cost, 2);
              }
            }

            // Calculate based on mulch type
            if (m_type === "6") {
              const size1 = (convertedArea / 235) * convertedDepth * 2;
              param.tech_size1 = round(size1, 2);
              if (isNumeric(price_bag)) {
                const total_cost1 = price_bag * size1;
                param.tech_total_cost1 = round(total_cost1, 2);
              }
            }

            if (m_type === "10") {
              const size1 = (convertedArea / 235) * convertedDepth;
              param.tech_size1 = round(size1, 2);
              if (isNumeric(price_bag)) {
                const total_cost1 = price_bag * size1;
                param.tech_total_cost1 = round(total_cost1, 2);
              }
            }

            param.tech_garden_size = round(convertedArea, 2);
            param.tech_cubic_yards = round(cubic_yards, 2);
            param.tech_cubic_ft = round(cubic_ft, 2);
            param.tech_cubic_meters = round(cubic_meters, 2);
            param.tech_liters = round(liters, 2);
            return param;
          } else {
            param.error = "Please! Check Your Input";
            return param;
          }
        }
      }
      // Circle shape
      else if (m_shape === "1") {
        if (isNumeric(diameter) && isNumeric(depth)) {
          let convertedDiameter = convertToFeet(diameter, diameter_unit);
          let convertedDepth = convertToInches(depth, depth_unit);

          const radius = convertedDiameter * 0.5;
          const garden_size = radius * radius * 3.1452;
          const cubic_yards = ((convertedDepth / 12) * garden_size) / 27;
          const cubic_ft = cubic_yards * 27;
          const cubic_meters = cubic_yards / 1.308;
          const liters = cubic_meters * 1000;

          // Calculate bags needed
          if (isNumeric(bag_size)) {
            let convertedBagSize = convertBagSize(bag_size, bag_size1);
            const size = cubic_ft / convertedBagSize;
            param.tech_size = round(size, 2);

            if (isNumeric(price_bag)) {
              const total_cost = price_bag * size;
              param.tech_total_cost = round(total_cost, 2);
            }
          }

          // Calculate based on mulch type
          if (m_type === "6") {
            const size1 = (garden_size / 235) * convertedDepth * 2;
            param.size1 = round(size1, 2);
            if (isNumeric(price_bag)) {
              const total_cost1 = price_bag * size1;
              param.tech_total_cost1 = round(total_cost1, 2);
            }
          }

          if (m_type === "10") {
            const size1 = (garden_size / 235) * convertedDepth;
            param.tech_size1 = round(size1, 2);
            if (isNumeric(price_bag)) {
              const total_cost1 = price_bag * size1;
              param.tech_total_cost1 = round(total_cost1, 2);
            }
          }

          param.tech_garden_size = round(garden_size, 0);
          param.tech_cubic_yards = round(cubic_yards, 2);
          param.tech_cubic_ft = round(cubic_ft, 2);
          param.tech_cubic_meters = round(cubic_meters, 2);
          param.tech_liters = round(liters, 2);
          return param;
        } else {
          param.error = "Please! Check Your Input";
          return param;
        }
      }
      // Triangle shape
      else if (m_shape === "2") {
        if (isNumeric(side1) && isNumeric(side2) && isNumeric(depth)) {
          let convertedSide1 = convertToFeet(side1, side1_unit);
          let convertedSide2 = convertToFeet(side2, side2_unit);
          let convertedDepth = convertToInches(depth, depth_unit);

          const garden_size = convertedSide1 * convertedSide2 * 0.5;
          const cubic_yards = ((convertedDepth / 12) * garden_size) / 27;
          const cubic_ft = cubic_yards * 27;
          const cubic_meters = cubic_yards / 1.308;
          const liters = cubic_meters * 1000;

          // Calculate bags needed
          if (isNumeric(bag_size)) {
            let convertedBagSize = convertBagSize(bag_size, bag_size1);
            const size = cubic_ft / convertedBagSize;
            param.tech_size = round(size, 2);

            if (isNumeric(price_bag)) {
              const total_cost = price_bag * size;
              param.tech_total_cost = round(total_cost, 2);
            }
          }

          // Calculate based on mulch type
          if (m_type === "6") {
            const size1 = (garden_size / 235) * convertedDepth * 2;
            param.tech_size1 = round(size1, 2);
            if (isNumeric(price_bag)) {
              const total_cost1 = price_bag * size1;
              param.tech_total_cost1 = round(total_cost1, 2);
            }
          }

          if (m_type === "10") {
            const size1 = (garden_size / 235) * convertedDepth;
            param.tech_size1 = round(size1, 2);
            if (isNumeric(price_bag)) {
              const total_cost1 = price_bag * size1;
              param.tech_total_cost1 = round(total_cost1, 2);
            }
          }

          param.tech_garden_size = round(garden_size, 2);
          param.tech_cubic_yards = round(cubic_yards, 2);
          param.tech_cubic_ft = round(cubic_ft, 2);
          param.tech_cubic_meters = round(cubic_meters, 2);
          param.tech_liters = round(liters, 2);

          return param;
        } else {
          param.error = "Please! Check Your Input";
          return param;
        }
      }

      param.error = "Invalid shape selected";
      return param;
    } catch (error) {
      console.error("Error in mulch calculation:", error);
      return { error: "An error occurred during calculation" };
    }
  }

  async getCalculationSandCalculator(body) {
    let length = parseFloat(body.tech_length);
    let length_unit = body.tech_length_unit;
    let width = parseFloat(body.tech_width);
    let width_unit = body.tech_width_unit;
    let area = parseFloat(body.tech_area);
    let area_unit = body.tech_area_unit;
    let depth = parseFloat(body.tech_depth);
    let depth_unit = body.tech_depth_unit;
    let volume = parseFloat(body.tech_volume);
    let volume_unit = body.tech_volume_unit;
    let density = parseFloat(body.tech_density);
    let density_unit = body.tech_density_unit;
    let mass_price = parseFloat(body.tech_mass_price);
    let mass_price_unit = body.tech_mass_price_unit;
    let volume_price = parseFloat(body.tech_volume_price);
    let volume_price_unit = body.tech_volume_price_unit;
    const shape = body.tech_shape;
    let g = body.tech_g;
    let diameter = parseFloat(body.tech_diameter);
    let diameter_unit = body.tech_diameter_unit;
    let c_price = parseFloat(body.tech_c_price);
    const hiddencurrancy = body.tech_hiddencurrancy || "";

    let param = {};

    // Area unit conversions
    if (area_unit === "mm²") {
      area_unit = "mm2";
    } else if (area_unit === "cm²") {
      area_unit = "cm2";
    } else if (area_unit === "m²") {
      area_unit = "m2";
    } else if (area_unit === "in²") {
      area_unit = "in2";
    } else if (area_unit === "ft²") {
      area_unit = "ft2";
    } else if (area_unit === "yd²") {
      area_unit = "yd2";
    } else if (area_unit === "hectares") {
      area_unit = "ha";
    } else if (area_unit === "acres") {
      area_unit = "ac";
    } else if (area_unit === "soccer fields") {
      area_unit = "sf";
    }

    // Volume unit conversions
    if (volume_unit === "mm³") {
      volume_unit = "mm3";
    } else if (volume_unit === "cm³") {
      volume_unit = "cm3";
    } else if (volume_unit === "m³") {
      volume_unit = "m3";
    } else if (volume_unit === "in³") {
      volume_unit = "in3";
    } else if (volume_unit === "ft³") {
      volume_unit = "ft3";
    } else if (volume_unit === "yd³") {
      volume_unit = "yd3";
    }

    // Density unit conversions
    if (density_unit === "kg/m³") {
      density_unit = "kg_m3";
    } else if (density_unit === "t/m³") {
      density_unit = "t_m3";
    } else if (density_unit === "g/cm³") {
      density_unit = "g_cm3";
    } else if (density_unit === "oz/in³") {
      density_unit = "oz_in3";
    } else if (density_unit === "lb/in³") {
      density_unit = "lb_in3";
    } else if (density_unit === "lb/ft³") {
      density_unit = "lb_ft3";
    } else if (density_unit === "lb/yd³") {
      density_unit = "lb_yd3";
    }

    // Mass price unit conversions
    if (mass_price_unit === hiddencurrancy + "µg") {
      mass_price_unit = "ug";
    } else if (mass_price_unit === hiddencurrancy + "mg") {
      mass_price_unit = "mg";
    } else if (mass_price_unit === hiddencurrancy + "g") {
      mass_price_unit = "g";
    } else if (mass_price_unit === hiddencurrancy + "kg") {
      mass_price_unit = "kg";
    } else if (mass_price_unit === hiddencurrancy + "t") {
      mass_price_unit = "t";
    } else if (mass_price_unit === hiddencurrancy + "lb") {
      mass_price_unit = "lb";
    } else if (mass_price_unit === hiddencurrancy + "stone") {
      mass_price_unit = "stone";
    } else if (mass_price_unit === hiddencurrancy + "US ton") {
      mass_price_unit = "us_ton";
    } else if (mass_price_unit === hiddencurrancy + "Long ton") {
      mass_price_unit = "long_ton";
    }

    // Volume price unit conversions
    if (volume_price_unit === hiddencurrancy + "mm³") {
      volume_price_unit = "mm3";
    } else if (volume_price_unit === hiddencurrancy + "cm³") {
      volume_price_unit = "cm3";
    } else if (volume_price_unit === hiddencurrancy + "m³") {
      volume_price_unit = "m3";
    } else if (volume_price_unit === hiddencurrancy + "in³") {
      volume_price_unit = "in3";
    } else if (volume_price_unit === hiddencurrancy + "ft³") {
      volume_price_unit = "ft3";
    } else if (volume_price_unit === hiddencurrancy + "yd³") {
      volume_price_unit = "yd3";
    }

    // Rectangle Shape
    if (shape === "0") {
      // Method 1
      if (g === "g1") {
        if (
          !isNaN(length) &&
          !isNaN(width) &&
          !isNaN(depth) &&
          !isNaN(density)
        ) {
          // Conversion of length units in feet
          if (length_unit === "mm") {
            length = length / 305;
          }
          if (length_unit === "cm") {
            length = length / 30.48;
          }
          if (length_unit === "m") {
            length = length * 3.281;
          }
          if (length_unit === "in") {
            length = length / 12;
          }
          if (length_unit === "yd") {
            length = length * 3;
          }

          // Conversion of width units in feet
          if (width_unit === "mm") {
            width = width / 305;
          }
          if (width_unit === "cm") {
            width = width / 30.48;
          }
          if (width_unit === "m") {
            width = width * 3.281;
          }
          if (width_unit === "in") {
            width = width / 12;
          }
          if (width_unit === "yd") {
            width = width * 3;
          }

          // Conversion of depth units in feet
          if (depth_unit === "in") {
            depth = depth / 12;
          }
          if (depth_unit === "yd") {
            depth = depth * 3;
          }
          if (depth_unit === "cm") {
            depth = depth / 30.48;
          }
          if (depth_unit === "m") {
            depth = depth * 3.281;
          }

          // Conversion of density units in pound/cubic feet
          if (density_unit === "kg_m3") {
            density = density * 0.062428;
          }
          if (density_unit === "t_m3" || density_unit === "g_cm3") {
            density = density * 62.428;
          }
          if (density_unit === "oz_in3") {
            density = density * 108;
          }
          if (density_unit === "lb_in3") {
            density = density * 1728;
          }
          if (density_unit === "lb_yd3") {
            density = density * 0.037037;
          }

          // Calculation
          area = length * width;
          volume = area * depth;
          let weight = volume * density;
          weight = weight * 0.000453592;

          // Conversion of volume units for display
          const mm3 = volume * 28316847;
          const cm3 = volume * 28316.85;
          const m3 = volume * 0.02831685;
          const in3 = volume * 1728;
          const yd3 = volume * 0.037037;

          // Conversion of weight units for display
          const grams = weight * 1000000;
          const kg = weight * 1000;
          const oz = weight * 35273.96;
          const lb = weight * 2204.623;
          const stone = weight * 157.473;
          const us_ton = weight * 1.102311;
          const long_ton = weight * 0.984207;

          param = {
            tech_mm3: Math.round(mm3 * 100) / 100,
            tech_cm3: Math.round(cm3 * 100) / 100,
            tech_m3: Math.round(m3 * 100) / 100,
            tech_in3: Math.round(in3 * 100) / 100,
            tech_yd3: Math.round(yd3 * 100) / 100,
            tech_g: Math.round(grams * 100) / 100,
            tech_kg: Math.round(kg * 100) / 100,
            tech_oz: Math.round(oz * 100) / 100,
            tech_lb: Math.round(lb * 100) / 100,
            tech_stone: Math.round(stone * 100) / 100,
            tech_us_ton: Math.round(us_ton * 100) / 100,
            tech_long_ton: Math.round(long_ton * 100) / 100,
            tech_volume: Math.round(volume * 10000) / 10000,
            tech_weight: Math.round(weight * 10000) / 10000,
          };

          if (!isNaN(mass_price) && mass_price > 0) {
            let adjusted_mass_price = mass_price;

            if (mass_price_unit === "ug") {
              adjusted_mass_price = mass_price * 1000000000000;
            }
            if (mass_price_unit === "mg") {
              adjusted_mass_price = mass_price * 1000000000;
            }
            if (mass_price_unit === "g") {
              adjusted_mass_price = mass_price * 1000000;
            }
            if (mass_price_unit === "dag") {
              adjusted_mass_price = mass_price * 100000;
            }
            if (mass_price_unit === "kg") {
              adjusted_mass_price = mass_price * 1000;
            }
            if (mass_price_unit === "gr") {
              adjusted_mass_price = mass_price * 15432358.35;
            }
            if (mass_price_unit === "dr") {
              adjusted_mass_price = mass_price * 564383.39;
            }
            if (mass_price_unit === "oz") {
              adjusted_mass_price = mass_price * 35273.96;
            }
            if (mass_price_unit === "lb") {
              adjusted_mass_price = mass_price * 2204.62;
            }
            if (mass_price_unit === "stone") {
              adjusted_mass_price = mass_price * 157.47;
            }
            if (mass_price_unit === "us_ton") {
              adjusted_mass_price = mass_price * 1.1;
            }
            if (mass_price_unit === "long_ton") {
              adjusted_mass_price = mass_price / 0.98;
            }

            const cost = adjusted_mass_price * weight;
            param.tech_cost = Math.round(cost * 100) / 100;
          }

          // Conversion of volume price units in feet
          if (!isNaN(volume_price) && volume_price > 0) {
            let adjusted_volume_price = volume_price;

            if (volume_price_unit === "mm3") {
              adjusted_volume_price = volume_price * 764554857.98;
            }
            if (volume_price_unit === "cm3") {
              adjusted_volume_price = volume_price * 764554.86;
            }
            if (volume_price_unit === "m3") {
              adjusted_volume_price = volume_price * 0.76;
            }
            if (volume_price_unit === "in3") {
              adjusted_volume_price = volume_price * 46656;
            }
            if (volume_price_unit === "yd3") {
              adjusted_volume_price = volume_price * 27;
            }

            const adjusted_weight = weight / 1.22;
            const cost = adjusted_volume_price * adjusted_weight;
            param.tech_cost = Math.round(cost * 100) / 100;
          }

          console.log(param);
          return param;
        } else {
          param.error = "please check your inputs...";
          return param;
        }
      }
      // Method 2
      else if (g === "g2") {
        if (!isNaN(area) && !isNaN(depth) && !isNaN(density)) {
          // Conversion of area units in square feet
          if (area_unit === "mm2") {
            area = area * 0.0000107639;
          }
          if (area_unit === "cm2") {
            area = area * 0.00107639;
          }
          if (area_unit === "m2") {
            area = area * 10.7639;
          }
          if (area_unit === "in2") {
            area = area * 0.00694444;
          }
          if (area_unit === "yd2") {
            area = area * 9;
          }
          if (area_unit === "ha") {
            area = area * 107639;
          }
          if (area_unit === "ac") {
            area = area * 43560;
          }
          if (area_unit === "sf") {
            area = area * 76854.3;
          }

          // Conversion of depth units in feet
          if (depth_unit === "in") {
            depth = depth / 12;
          }
          if (depth_unit === "yd") {
            depth = depth * 3;
          }
          if (depth_unit === "cm") {
            depth = depth / 30.48;
          }
          if (depth_unit === "m") {
            depth = depth * 3.281;
          }

          // Conversion of density units in pound/cubic feet
          if (density_unit === "kg_m3") {
            density = density * 0.062428;
          }
          if (density_unit === "t_m3" || density_unit === "g_cm3") {
            density = density * 62.428;
          }
          if (density_unit === "oz_in3") {
            density = density * 108;
          }
          if (density_unit === "lb_in3") {
            density = density * 1728;
          }
          if (density_unit === "lb_yd3") {
            density = density * 0.037037;
          }

          // Calculation
          volume = area * depth;
          let weight = volume * density;
          weight = weight * 0.000453592;

          // Conversion of volume units for display
          const mm3 = volume * 28316847;
          const cm3 = volume * 28316.85;
          const m3 = volume * 0.02831685;
          const in3 = volume * 1728;
          const yd3 = volume * 0.037037;

          // Conversion of weight units for display
          const grams = weight * 1000000;
          const kg = weight * 1000;
          const oz = weight * 35273.96;
          const lb = weight * 2204.623;
          const stone = weight * 157.473;
          const us_ton = weight * 1.102311;
          const long_ton = weight * 0.984207;

          param = {
            tech_mm3: Math.round(mm3 * 100) / 100,
            tech_cm3: Math.round(cm3 * 100) / 100,
            tech_m3: Math.round(m3 * 100) / 100,
            tech_in3: Math.round(in3 * 100) / 100,
            tech_yd3: Math.round(yd3 * 100) / 100,
            tech_g: Math.round(grams * 100) / 100,
            tech_kg: Math.round(kg * 100) / 100,
            tech_oz: Math.round(oz * 100) / 100,
            tech_lb: Math.round(lb * 100) / 100,
            tech_stone: Math.round(stone * 100) / 100,
            tech_us_ton: Math.round(us_ton * 100) / 100,
            tech_long_ton: Math.round(long_ton * 100) / 100,
            tech_volume: Math.round(volume * 10000) / 10000,
            tech_weight: Math.round(weight * 10000) / 10000,
          };

          if (!isNaN(mass_price) && mass_price > 0) {
            let adjusted_mass_price = mass_price;

            if (mass_price_unit === "ug") {
              adjusted_mass_price = mass_price * 1000000000000;
            }
            if (mass_price_unit === "mg") {
              adjusted_mass_price = mass_price * 1000000000;
            }
            if (mass_price_unit === "g") {
              adjusted_mass_price = mass_price * 1000000;
            }
            if (mass_price_unit === "dag") {
              adjusted_mass_price = mass_price * 100000;
            }
            if (mass_price_unit === "kg") {
              adjusted_mass_price = mass_price * 1000;
            }
            if (mass_price_unit === "gr") {
              adjusted_mass_price = mass_price * 15432358.35;
            }
            if (mass_price_unit === "dr") {
              adjusted_mass_price = mass_price * 564383.39;
            }
            if (mass_price_unit === "oz") {
              adjusted_mass_price = mass_price * 35273.96;
            }
            if (mass_price_unit === "lb") {
              adjusted_mass_price = mass_price * 2204.62;
            }
            if (mass_price_unit === "stone") {
              adjusted_mass_price = mass_price * 157.47;
            }
            if (mass_price_unit === "us_ton") {
              adjusted_mass_price = mass_price * 1.1;
            }
            if (mass_price_unit === "long_ton") {
              adjusted_mass_price = mass_price / 0.98;
            }

            const cost = adjusted_mass_price * weight;
            param.tech_cost = Math.round(cost * 100) / 100;
          }

          // Conversion of volume price units in feet
          if (!isNaN(volume_price) && volume_price > 0) {
            let adjusted_volume_price = volume_price;

            if (volume_price_unit === "mm3") {
              adjusted_volume_price = volume_price * 764554857.98;
            }
            if (volume_price_unit === "cm3") {
              adjusted_volume_price = volume_price * 764554.86;
            }
            if (volume_price_unit === "m3") {
              adjusted_volume_price = volume_price * 0.76;
            }
            if (volume_price_unit === "in3") {
              adjusted_volume_price = volume_price * 46656;
            }
            if (volume_price_unit === "yd3") {
              adjusted_volume_price = volume_price * 27;
            }

            const adjusted_weight = weight / 1.22;
            const cost = adjusted_volume_price * adjusted_weight;
            param.tech_cost = Math.round(cost * 100) / 100;
          }

          console.log(param);
          return param;
        } else {
          param.error = "please check your inputs...";
          return param;
        }
      }
      // Method 3
      else {
        if (!isNaN(volume) && !isNaN(density)) {
          // Conversion of volume units in cubic feet
          if (volume_unit === "mm3") {
            volume = volume * 0.0000000353147;
          }
          if (volume_unit === "cm3") {
            volume = volume * 0.0000353147;
          }
          if (volume_unit === "m3") {
            volume = volume * 35.3147;
          }
          if (volume_unit === "in3") {
            volume = volume * 0.000578704;
          }
          if (volume_unit === "yd3") {
            volume = volume * 27;
          }

          // Conversion of density units in pound/cubic feet
          if (density_unit === "kg_m3") {
            density = density * 0.062428;
          }
          if (density_unit === "t_m3" || density_unit === "g_cm3") {
            density = density * 62.428;
          }
          if (density_unit === "oz_in3") {
            density = density * 108;
          }
          if (density_unit === "lb_in3") {
            density = density * 1728;
          }
          if (density_unit === "lb_yd3") {
            density = density * 0.037037;
          }

          // Calculation
          let weight = volume * density;
          weight = weight * 0.000453592;

          // Conversion of weight units for display
          const grams = weight * 1000000;
          const kg = weight * 1000;
          const oz = weight * 35273.96;
          const lb = weight * 2204.623;
          const stone = weight * 157.473;
          const us_ton = weight * 1.102311;
          const long_ton = weight * 0.984207;

          param = {
            tech_: Math.round(grams * 100) / 100,
            tech_kg: Math.round(kg * 100) / 100,
            tech_oz: Math.round(oz * 100) / 100,
            tech_lb: Math.round(lb * 100) / 100,
            tech_stone: Math.round(stone * 100) / 100,
            tech_us_ton: Math.round(us_ton * 100) / 100,
            tech_long_ton: Math.round(long_ton * 100) / 100,
            tech_weight: Math.round(weight * 10000) / 10000,
          };

          if (!isNaN(mass_price) && mass_price > 0) {
            let adjusted_mass_price = mass_price;

            if (mass_price_unit === "ug") {
              adjusted_mass_price = mass_price * 1000000000000;
            }
            if (mass_price_unit === "mg") {
              adjusted_mass_price = mass_price * 1000000000;
            }
            if (mass_price_unit === "g") {
              adjusted_mass_price = mass_price * 1000000;
            }
            if (mass_price_unit === "dag") {
              adjusted_mass_price = mass_price * 100000;
            }
            if (mass_price_unit === "kg") {
              adjusted_mass_price = mass_price * 1000;
            }
            if (mass_price_unit === "gr") {
              adjusted_mass_price = mass_price * 15432358.35;
            }
            if (mass_price_unit === "dr") {
              adjusted_mass_price = mass_price * 564383.39;
            }
            if (mass_price_unit === "oz") {
              adjusted_mass_price = mass_price * 35273.96;
            }
            if (mass_price_unit === "lb") {
              adjusted_mass_price = mass_price * 2204.62;
            }
            if (mass_price_unit === "stone") {
              adjusted_mass_price = mass_price * 157.47;
            }
            if (mass_price_unit === "us_ton") {
              adjusted_mass_price = mass_price * 1.1;
            }
            if (mass_price_unit === "long_ton") {
              adjusted_mass_price = mass_price / 0.98;
            }

            const cost = adjusted_mass_price * weight;
            param.tech_cost = Math.round(cost * 100) / 100;
          }

          // Conversion of volume in required units
          if (!isNaN(volume_price) && volume_price > 0) {
            let converted_volume = volume;

            if (volume_price_unit === "mm3") {
              converted_volume = volume * 28316847;
            }
            if (volume_price_unit === "cm3") {
              converted_volume = volume * 28316.85;
            }
            if (volume_price_unit === "m3") {
              converted_volume = volume * 0.02831685;
            }
            if (volume_price_unit === "in3") {
              converted_volume = volume * 1728;
            }
            if (volume_price_unit === "yd3") {
              converted_volume = volume * 0.037037;
            }

            const cost = volume_price * converted_volume;
            param.tech_cost = Math.round(cost * 100) / 100;
          }

          console.log(param);
          return param;
        } else {
          param.error = "please check your inputs...";
          return param;
        }
      }
    }

    // Circle Shape
    if (shape === "1") {
      if (!isNaN(diameter) && !isNaN(depth)) {
        // Conversion of diameter units in feet
        if (diameter_unit === "in") {
          diameter = diameter / 12;
        }
        if (diameter_unit === "yd") {
          diameter = diameter * 3;
        }
        if (diameter_unit === "cm") {
          diameter = diameter / 30.48;
        }
        if (diameter_unit === "m") {
          diameter = diameter * 3.281;
        }

        // Conversion of depth units in feet
        if (depth_unit === "in") {
          depth = depth * 0.0833333;
        }
        if (depth_unit === "yd") {
          depth = depth * 3;
        }
        if (depth_unit === "cm") {
          depth = depth * 0.0328084;
        }
        if (depth_unit === "m") {
          depth = depth * 3.28084;
        }

        // Calculation
        const radius = diameter / 2;
        const circle_area = Math.PI * Math.pow(radius, 2);
        volume = circle_area * depth;
        let weight = volume * 100;
        weight = weight * 0.000453592;

        // Conversion of volume units for display
        const mm3 = volume * 28316847;
        const cm3 = volume * 28316.85;
        const m3 = volume * 0.02831685;
        const in3 = volume * 1728;
        const yd3 = volume * 0.037037;

        // Conversion of weight units for display
        const grams = weight * 1000000;
        const kg = weight * 1000;
        const oz = weight * 35274;
        const lb = weight * 2204.62;
        const stone = weight * 157.473;
        const us_ton = weight * 1.10231;
        const long_ton = weight * 0.984207;

        param = {
          tech_mm3: Math.round(mm3 * 10000) / 10000,
          tech_cm3: Math.round(cm3 * 10000) / 10000,
          tech_m3: Math.round(m3 * 10000) / 10000,
          tech_in3: Math.round(in3 * 10000) / 10000,
          tech_yd3: Math.round(yd3 * 10000) / 10000,
          tech_g: Math.round(grams * 100) / 100,
          tech_kg: Math.round(kg * 100) / 100,
          tech_oz: Math.round(oz * 100) / 100,
          tech_lb: Math.round(lb * 100) / 100,
          tech_stone: Math.round(stone * 100) / 100,
          tech_us_ton: Math.round(us_ton * 100) / 100,
          tech_long_ton: Math.round(long_ton * 100) / 100,
          tech_volume: Math.round(volume * 10000) / 10000,
          tech_weight: Math.round(weight * 10000) / 10000,
        };

        // Calculation of price unit
        if (!isNaN(c_price) && c_price > 0) {
          const cost = c_price * weight;
          param.tech_cost = Math.round(cost * 100) / 100;
        }
        return param;
      } else {
        param.error = "please check your inputs...";
        return param;
      }
    }

    // If no valid shape
    param.error = "Invalid shape value";
    return param;
  }

  async getCalculationAsphaltCalculator(body) {
    try {
      const submit = body.tech_submit;
      const cal = body.tech_cal;
      let length = parseFloat(body.tech_length);
      const length_unit = body.tech_length_unit;
      let width = parseFloat(body.tech_width);
      const width_unit = body.tech_width_unit;
      let area = parseFloat(body.tech_area);
      const area_unit = body.tech_area_unit;
      let depth = parseFloat(body.tech_depth);
      const depth_unit = body.tech_depth_unit;
      let volume = parseFloat(body.tech_volume);
      const volume_unit = body.tech_volume_unit;
      let density = parseFloat(body.tech_density);
      const density_unit = body.tech_density_unit;
      let cs_depth = parseFloat(body.tech_cs_depth);
      const cs_depth_unit = body.tech_cs_depth_unit;
      let depth_dr = parseFloat(body.tech_depth_dr);
      const depth_dr_unit = body.tech_depth_dr_unit;
      let cost = parseFloat(body.tech_cost);
      const cost_unit = body.tech_cost_unit;

      const result = {};

      if (submit) {
        // Unit conversions
        if (isNumeric(length)) {
          if (length_unit === "km") {
            length = length / 0.001;
          } else if (length_unit === "ft") {
            length = length / 3.281;
          } else if (length_unit === "yd") {
            length = length / 1.0936;
          } else if (length_unit === "mi") {
            length = length / 0.0006214;
          }
        }

        if (isNumeric(width)) {
          if (width_unit === "km") {
            width = width / 0.001;
          } else if (width_unit === "ft") {
            width = width / 3.281;
          } else if (width_unit === "yd") {
            width = width / 1.0936;
          } else if (width_unit === "mi") {
            width = width / 0.0006214;
          }
        }

        if (isNumeric(area)) {
          if (area_unit === "km2") {
            area = area / 0.000001;
          } else if (area_unit === "in2") {
            area = area / 1550;
          } else if (area_unit === "ft2") {
            area = area / 10.764;
          }
        }

        if (isNumeric(depth)) {
          if (depth_unit === "mm") {
            depth = depth / 10;
          } else if (depth_unit === "m") {
            depth = depth / 0.01;
          } else if (depth_unit === "in") {
            depth = depth / 0.3937;
          } else if (depth_unit === "ft") {
            depth = depth / 0.03281;
          }
        }

        if (isNumeric(volume)) {
          if (volume_unit === "cu_ft") {
            volume = volume / 35.315;
          } else if (volume_unit === "us_gal") {
            volume = volume / 264.17;
          } else if (volume_unit === "uk_gal") {
            volume = volume / 219.97;
          }
        }

        if (isNumeric(density)) {
          if (density_unit === "lb_cu_ft") {
            density = density / 0.06243;
          }
        }

        if (isNumeric(cs_depth)) {
          if (cs_depth_unit === "mm") {
            cs_depth = cs_depth / 25.4;
          } else if (cs_depth_unit === "cm") {
            cs_depth = cs_depth / 2.54;
          } else if (cs_depth_unit === "m") {
            cs_depth = cs_depth / 0.0254;
          } else if (cs_depth_unit === "ft") {
            cs_depth = cs_depth / 0.08333;
          }
        }

        if (isNumeric(depth_dr)) {
          // CORRECTION: Use depth_dr_unit instead of cs_depth_unit
          if (depth_dr_unit === "mm") {
            depth_dr = depth_dr / 25.4;
          } else if (depth_dr_unit === "cm") {
            depth_dr = depth_dr / 2.54;
          } else if (depth_dr_unit === "m") {
            depth_dr = depth_dr / 0.0254;
          } else if (depth_dr_unit === "ft") {
            depth_dr = depth_dr / 0.08333;
          }
        }

        if (isNumeric(cost)) {
          if (cost_unit === "kg") {
            cost = cost * 1000;
          } else if (cost_unit === "lb") {
            cost = cost * 2204.62;
          } else if (cost_unit === "us_ton") {
            cost = cost * 1.1;
          } else if (cost_unit === "long_ton") {
            cost = cost * 0.98;
          }
        }

        // Calculations based on calculation type
        if (
          cal === "lwt" &&
          isNumeric(length) &&
          isNumeric(width) &&
          isNumeric(depth) &&
          isNumeric(density)
        ) {
          const calcArea = length * width;
          const calcVolume = (calcArea * depth) / 100;
          const asphalt = calcVolume * density * 0.001;
          const kg = asphalt * 1000;
          const lb = asphalt * 2204.6;
          const us_ton = asphalt * 1.1023;
          const long_ton = asphalt * 0.9842;

          result.tech_area = calcArea;
          result.tech_volume = calcVolume;
          result.tech_asphalt = round(asphalt, 5);
          result.tech_kg = kg;
          result.tech_lb = lb;
          result.tech_us_ton = us_ton;
          result.tech_long_ton = long_ton;

          if (isNumeric(cost)) {
            result.tech_total_cost = cost * asphalt;
          }
        } else if (
          cal === "at" &&
          isNumeric(area) &&
          isNumeric(depth) &&
          isNumeric(density)
        ) {
          const calcVolume = (area * depth) / 100;
          const asphalt = calcVolume * density * 0.001;
          const kg = asphalt * 1000;
          const lb = asphalt * 2204.6;
          const us_ton = asphalt * 1.1023;
          const long_ton = asphalt * 0.9842;

          result.tech_volume = calcVolume;
          result.tech_asphalt = round(asphalt, 5);
          result.tech_kg = kg;
          result.tech_lb = lb;
          result.tech_us_ton = us_ton;
          result.tech_long_ton = long_ton;

          if (isNumeric(cost)) {
            result.tech_total_cost = cost * asphalt;
          }
        } else if (cal === "vad" && isNumeric(volume) && isNumeric(density)) {
          const asphalt = volume * density * 0.001;
          const kg = asphalt * 1000;
          const lb = asphalt * 2204.6;
          const us_ton = asphalt * 1.1023;
          const long_ton = asphalt * 0.9842;

          result.tech_asphalt = round(asphalt, 5);
          result.tech_kg = kg;
          result.tech_lb = lb;
          result.tech_us_ton = us_ton;
          result.tech_long_ton = long_ton;

          if (isNumeric(cost)) {
            result.tech_total_cost = cost * asphalt;
          }
        } else if (
          cal === "csn" &&
          isNumeric(area) &&
          isNumeric(depth) &&
          isNumeric(cs_depth)
        ) {
          const calcVolume = (area * depth) / 100;
          const asphalt = calcVolume * 2400 * 0.001;
          const calcArea = area / 0.0929;
          const stone = (calcArea * cs_depth) / 180;
          const kg = asphalt * 1000;
          const lb = asphalt * 2204.6;
          const us_ton = asphalt * 1.1023;
          const long_ton = asphalt * 0.9842;

          result.tech_asphalt = round(asphalt, 5);
          result.tech_stone = round(stone, 5);
          result.tech_kg = kg;
          result.tech_lb = lb;
          result.tech_us_ton = us_ton;
          result.tech_long_ton = long_ton;

          if (isNumeric(cost)) {
            result.tech_total_cost = cost * asphalt;
          }
        } else if (
          cal === "dtbr" &&
          isNumeric(area) &&
          isNumeric(depth) &&
          isNumeric(depth_dr)
        ) {
          const calcVolume = (area * depth) / 100;
          const asphalt = calcVolume * density * 0.001;
          // CORRECTION: Convert area from m² to ft² for dirt calculation
          const calcAreaFt2 = area / 0.0929;
          const dirt = (calcAreaFt2 * depth_dr) / 320;

          const kg = asphalt * 1000;
          const lb = asphalt * 2204.6;
          const us_ton = asphalt * 1.1023;
          const long_ton = asphalt * 0.9842;

          result.tech_asphalt = round(asphalt, 5);
          result.tech_dirt = round(dirt, 5);
          result.tech_kg = kg;
          result.tech_lb = lb;
          result.tech_us_ton = us_ton;
          result.tech_long_ton = long_ton;

          if (isNumeric(cost)) {
            result.total_cost = cost * asphalt;
          }
        } else {
          result.error = "Please! Check Your Input";
          return result;
        }

        return result;
      } else {
        result.error = "Please! Check Your Input";
        return result;
      }
    } catch (error) {
      console.error("Error in asphalt calculation:", error);
      return { error: "An error occurred during calculation" };
    }
    // Helper functions
    function isNumeric(value) {
      return !isNaN(parseFloat(value)) && isFinite(value);
    }

    function round(value, decimals) {
      return Number(Math.round(value + "e" + decimals) + "e-" + decimals);
    }
  }

  async getCalculationSquareFootageCalculator(body) {
    try {
      let width = body.tech_width;
      let axisa = body.tech_axisa;
      let axisb = body.tech_axisb;
      let inner_length_unit = body.tech_inner_length_unit;
      let axisa_unit = body.tech_axisa_unit;
      let axisb_unit = body.tech_axisb_unit;
      let shape_unit = body.tech_shape_unit;
      let sidealength = body.tech_sidealength;
      let sideblength = body.tech_sideblength;
      let quantity = body.tech_quantity;
      let height = body.tech_height;
      let length = body.tech_length;
      let inner_length = body.tech_inner_length;
      let inner_width = body.tech_inner_width;
      let length_unit = body.tech_length_unit;
      let width_unit = body.tech_width_unit;
      let diameter = body.tech_diameter;
      let diameter_unit = body.tech_diameter_unit;
      let inner_diameter = body.tech_inner_diameter;
      let inner_diameter_unit = body.tech_inner_diameter_unit;
      let inner_width_unit = body.tech_inner_width_unit;
      let border_width = body.tech_border_width;
      let border_width_unit = body.tech_border_width_unit;
      let sidealength_unit = body.tech_sidealength_unit;
      let sideblength_unit = body.tech_sideblength_unit;
      let sideclength_unit = body.tech_sideclength_unit;
      let sideclength = body.tech_sideclength;
      let radius = body.tech_radius;
      let radius_unit = body.tech_radius_unit;
      let angle = body.tech_angle;
      let sides = body.tech_sides;
      let outer_diameter = body.tech_outer_diameter;
      let outer_diameter_unit = body.tech_outer_diameter_unit;
      let height_unit = body.tech_height_unit;
      let base_unit = body.tech_base_unit;
      let base = body.tech_base;
      let room_unit = body.tech_room_unit;
      let price = body.tech_price;
      let price_unit = body.tech_price_unit;

      // Unit conversion helper
      function calculate(unit, value) {
        if (unit === "in") return value * 0.0833333;
        if (unit === "ft") return value * 1;
        if (unit === "yd") return value * 3;
        if (unit === "mm") return value * 0.00328084;
        if (unit === "cm") return value * 0.0328084;
        if (unit === "m") return value * 3.28084;
        return value;
      }

      let i = 0;
      let sum = 0;
      let param = {};

      if (room_unit === "1" || room_unit === "2") {
        while (i < shape_unit.length) {
          let area = 0;

          switch (shape_unit[i]) {
            case "sq":
              if (!isNaN(sidealength[i]) && !isNaN(quantity)) {
                let conv = calculate(sidealength_unit[i], sidealength[i]);
                area = conv * conv * quantity;
              } else return { error: "Please! Check Your Input." };
              break;

            case "rec":
              if (!isNaN(length[i]) && !isNaN(width[i]) && !isNaN(quantity)) {
                let l = calculate(length_unit[i], length[i]);
                let w = calculate(width_unit[i], width[i]);
                area = l * w * quantity;
              } else return { error: "Please! Check Your Input." };
              break;

            case "recbor":
              if (
                !isNaN(inner_width[i]) &&
                !isNaN(inner_length[i]) &&
                !isNaN(border_width[i]) &&
                !isNaN(quantity)
              ) {
                let l = calculate(inner_length_unit[i], length[i]);
                let w = calculate(inner_width_unit[i], inner_width[i]);
                let b = calculate(border_width_unit[i], border_width[i]);
                let inner_area = l * w;
                let total_area = (l + 2 * b) * (w + 2 * b);
                area = total_area - inner_area;
              } else return { error: "Please! Check Your Input." };
              break;

            case "tra":
              if (
                !isNaN(sidealength[i]) &&
                !isNaN(sideblength[i]) &&
                !isNaN(height[i]) &&
                !isNaN(quantity)
              ) {
                let a = calculate(sidealength_unit[i], sidealength[i]);
                let b = calculate(sideblength_unit[i], sideblength[i]);
                let h = calculate(height_unit[i], height[i]);
                area = ((a + b) / 2) * h;
              } else return { error: "Please! Check Your Input." };
              break;

            case "para":
              if (!isNaN(base[i]) && !isNaN(height[i]) && !isNaN(quantity)) {
                let b = calculate(base_unit[i], base[i]);
                let h = calculate(height_unit[i], height[i]);
                area = b * h;
              } else return { error: "Please! Check Your Input." };
              break;

            case "tri":
              if (
                !isNaN(sidealength[i]) &&
                !isNaN(sideblength[i]) &&
                !isNaN(sideclength[i]) &&
                !isNaN(quantity)
              ) {
                let a = calculate(sidealength_unit[i], sidealength[i]);
                let b = calculate(sideblength_unit[i], sideblength[i]);
                let c = calculate(sideclength_unit[i], sideclength[i]);
                area =
                  (1 / 4) *
                  Math.sqrt(
                    (a + b + c) * (b + c - a) * (c + a - b) * (a + b - c)
                  );
              } else return { error: "Please! Check Your Input." };
              break;

            case "cir":
              if (!isNaN(diameter[i]) && !isNaN(quantity)) {
                let d = calculate(diameter_unit[i], diameter[i]);
                area = 3.14 * Math.pow(d / 2, 2);
              } else return { error: "Please! Check Your Input." };
              break;

            case "ell":
              if (!isNaN(axisa[i]) && !isNaN(axisb[i]) && !isNaN(quantity)) {
                let a = calculate(axisa_unit[i], axisa[i]);
                let b = calculate(axisb_unit[i], axisb[i]);
                area = 3.14 * a * b;
              } else return { error: "Please! Check Your Input." };
              break;

            case "sec":
              if (!isNaN(radius[i]) && !isNaN(angle[i]) && !isNaN(quantity)) {
                let r = calculate(radius_unit[i], radius[i]);
                area = 3.14 * r * r * (angle[i] / 360);
              } else return { error: "Please! Check Your Input." };
              break;

            case "hex":
              if (!isNaN(sidealength[i]) && !isNaN(quantity)) {
                let s = calculate(sidealength_unit[i], sidealength[i]);
                area = (3 * Math.sqrt(3) * Math.pow(s, 2)) / 2;
              } else return { error: "Please! Check Your Input." };
              break;

            case "oct":
              if (!isNaN(sidealength[i]) && !isNaN(quantity)) {
                let s = calculate(sidealength_unit[i], sidealength[i]);
                area = 2 * Math.pow(s, 2) * (1 + Math.sqrt(2));
              } else return { error: "Please! Check Your Input." };
              break;

            case "ann":
              if (
                !isNaN(inner_diameter[i]) &&
                !isNaN(outer_diameter[i]) &&
                !isNaN(quantity)
              ) {
                let outer = calculate(
                  outer_diameter_unit[i],
                  outer_diameter[i]
                );
                let inner = calculate(
                  inner_diameter_unit[i],
                  inner_diameter[i]
                );
                area = 3.14 * (Math.pow(outer / 2, 2) - Math.pow(inner / 2, 2));
              } else return { error: "Please! Check Your Input." };
              break;

            case "cirborder":
              if (
                !isNaN(border_width[i]) &&
                !isNaN(inner_diameter[i]) &&
                !isNaN(quantity)
              ) {
                let inner = calculate(
                  inner_diameter_unit[i],
                  inner_diameter[i]
                );
                let border = calculate(border_width_unit[i], border_width[i]);
                let outer_d = inner + 2 * border;
                let outer_area = 3.14 * Math.pow(outer_d / 2, 2);
                let inner_area = 3.14 * Math.pow(inner / 2, 2);
                area = outer_area - inner_area;
              } else return { error: "Please! Check Your Input." };
              break;
          }

          sum += area;
          i++;
        }

        // Price handling
        if (price !== "" && !isNaN(price)) {
          let convert_price = 0;
          if (price_unit === "ft²") convert_price = price * 1;
          else if (price_unit === "yd²") convert_price = price * 0.11;
          else if (price_unit === "m²") convert_price = price * 0.09;

          param.tech_ans = sum;
          param.tech_sqyards = sum * 0.11111;
          param.tech_sqmeters = sum * 0.092903;
          param.tech_acres = sum * 0.0000229568;
          param.tech_cost = sum * convert_price;
          return param;
        } else {
          param.tech_ans = sum * quantity;
          param.tech_sqyards = sum * 0.11111;
          param.tech_sqmeters = sum * 0.092903;
          param.tech_acres = sum * 0.0000229568;
          return param;
        }
      }

      return { error: "Please! Check Your Input." };
    } catch (error) {
      return { error: "An unexpected error occurred: " + error.message };
    }
  }

  async getCalculationConcreteCalculator(body) {
    try {
      let operations = body.tech_operations;
      let first = parseFloat(body.tech_first);
      let second = parseFloat(body.tech_second);
      let third = parseFloat(body.tech_third);
      let four = parseFloat(body.tech_four);
      let five = parseFloat(body.tech_five);
      let fiveb = parseFloat(body.tech_fiveb);
      let quantity = parseFloat(body.tech_quantity);
      let units1 = body.tech_units1;
      let units2 = body.tech_units2;
      let units3 = body.tech_units3;
      let units4 = body.tech_units4;
      let units5 = body.tech_units5;
      let price_unit = body.tech_price_unit;
      let price = parseFloat(body.tech_price);

      let result = {};

      // Price unit conversion
      if (price_unit === "ft³") {
        price_unit = "1";
      } else if (price_unit === "yd³") {
        price_unit = "2";
      } else if (price_unit === "m³") {
        price_unit = "3";
      }

      // Helper function for unit conversion to feet
      function calculate_con(a, b) {
        let convert;
        if (b === "ft") {
          convert = a * 1;
        } else if (b === "in") {
          convert = a * 0.0833333;
        } else if (b === "yd") {
          convert = a * 3;
        } else if (b === "cm") {
          convert = a * 0.0328084;
        } else if (b === "m") {
          convert = a * 3.28084;
        }
        return convert;
      }

      let cubic_feet, cubic_yard, cubic_meter;

      // Operation 3: Rectangular/Square Slab
      if (operations === "3") {
        if (
          !isNaN(first) &&
          !isNaN(second) &&
          !isNaN(third) &&
          !isNaN(quantity)
        ) {
          first = calculate_con(first, units1);
          second = calculate_con(second, units2);
          third = calculate_con(third, units3);
          cubic_feet = first * second * third;
          cubic_yard = cubic_feet / 27;
          cubic_meter = cubic_feet * 0.0283;
          // console.log(cubic_feet,cubic_yard,cubic_meter);
        } else {
          return { error: "Please! Check Your Input" };
        }
      }
      // Operation 4: Circular Slab
      else if (operations === "4") {
        if (!isNaN(first) && !isNaN(second) && !isNaN(quantity)) {
          first = calculate_con(first, units1);
          second = calculate_con(second, units2);
          let sq_val = second / 2;
          let final_val = sq_val * sq_val;
          let area = 3.14 * final_val;
          cubic_feet = first * area;
          cubic_yard = cubic_feet / 27;
          cubic_meter = cubic_feet * 0.0283;
        } else {
          return { error: "Please! Check Your Input" };
        }
      }
      // Operation 5: Wall
      else if (operations === "5") {
        if (
          !isNaN(first) &&
          !isNaN(second) &&
          !isNaN(third) &&
          !isNaN(quantity)
        ) {
          first = calculate_con(first, units1);
          second = calculate_con(second, units2);
          third = calculate_con(third, units3);
          cubic_feet = first * second * third;
          cubic_yard = cubic_feet / 27;
          cubic_meter = cubic_feet * 0.0283;
        } else {
          return { error: "Please! Check Your Input" };
        }
      }
      // Operation 6: Footing
      else if (operations === "6") {
        if (
          !isNaN(first) &&
          !isNaN(second) &&
          !isNaN(third) &&
          !isNaN(quantity)
        ) {
          first = calculate_con(first, units1);
          second = calculate_con(second, units2);
          third = calculate_con(third, units3);
          cubic_feet = first * second * third;
          cubic_yard = cubic_feet / 27;
          cubic_meter = cubic_feet * 0.0283;
        } else {
          return { error: "Please! Check Your Input" };
        }
      }
      // Operation 7: Column
      else if (operations === "7") {
        if (
          !isNaN(first) &&
          !isNaN(second) &&
          !isNaN(third) &&
          !isNaN(quantity)
        ) {
          first = calculate_con(first, units1);
          second = calculate_con(second, units2);
          third = calculate_con(third, units3);
          cubic_feet = first * second * third;
          cubic_yard = cubic_feet / 27;
          cubic_meter = cubic_feet * 0.0283;
        } else {
          return { error: "Please! Check Your Input" };
        }
      }
      // Operation 8: Circular Column
      else if (operations === "8") {
        if (!isNaN(first) && !isNaN(second) && !isNaN(quantity)) {
          first = calculate_con(first, units1);
          second = calculate_con(second, units2);
          let area = 3.14 * Math.pow(second / 2, 2);
          cubic_feet = first * area;
          cubic_yard = cubic_feet / 27;
          cubic_meter = cubic_feet * 0.0283;
        } else {
          return { error: "Please! Check Your Input" };
        }
      }
      // Operation 9: Stairs (with fiveb)
      else if (operations === "9") {
        if (
          !isNaN(first) &&
          !isNaN(second) &&
          !isNaN(third) &&
          !isNaN(four) &&
          !isNaN(fiveb) &&
          !isNaN(quantity)
        ) {
          first = calculate_con(first, units1);
          second = calculate_con(second, units2);
          third = calculate_con(third, units3);
          four = calculate_con(four, units4);
          let middle = second * fiveb;
          let step1 = first * middle * four;
          let step2 = third * middle * four;
          cubic_feet = step1 + step2;
          cubic_yard = cubic_feet / 27;
          cubic_meter = cubic_feet * 0.0283;
        } else {
          return { error: "Please! Check Your Input" };
        }
      }
      // Operation 10: Curb/Gutter
      else if (operations === "10") {
        if (
          !isNaN(first) &&
          !isNaN(second) &&
          !isNaN(third) &&
          !isNaN(four) &&
          !isNaN(five) &&
          !isNaN(quantity)
        ) {
          first = calculate_con(first, units1);
          second = calculate_con(second, units2);
          third = calculate_con(third, units3);
          four = calculate_con(four, units4);
          five = calculate_con(five, units5);
          let mid = second + four;
          let step1 = first * mid * five;
          let step2 = third * four * five;
          cubic_feet = step1 + step2;
          cubic_yard = cubic_feet / 27;
          cubic_meter = cubic_feet * 0.0283;
        } else {
          return { error: "Please! Check Your Input" };
        }
      } else {
        return { error: "Please! Check Your Input" };
      }

      // Apply quantity
      if (!isNaN(quantity)) {
        cubic_feet = cubic_feet * quantity;
        cubic_yard = cubic_yard * quantity;
        cubic_meter = cubic_meter * quantity;
      }

      // Calculate price based on unit
      if (!isNaN(price) && price > 0) {
        if (price_unit === "1") {
          let ft_price = cubic_feet * price;
          result.tech_ft_price = parseFloat(ft_price.toFixed(2));
        } else if (price_unit === "2") {
          let yd_price = cubic_yard * price;
          result.tech_yd_price = parseFloat(yd_price.toFixed(2));
        } else if (price_unit === "3") {
          let m_price = cubic_meter * price;
          result.tech_m_price = parseFloat(m_price.toFixed(2));
        }
      }

      // Format cubic values
      cubic_feet = parseFloat(cubic_feet.toFixed(2));
      cubic_yard = parseFloat(cubic_yard.toFixed(2));
      cubic_meter = parseFloat(cubic_meter.toFixed(2));

      // Calculate weight in pounds and kilograms
      let lb = 133 * parseInt(cubic_feet);
      let kg = parseInt(cubic_meter) * 2130;
      // Calculate bags needed (40lb, 60lb, 80lb)
      let lb_40 = parseFloat((lb / 40).toFixed(2));
      let lb_60 = parseFloat((lb / 60).toFixed(2));
      let lb_80 = parseFloat((lb / 80).toFixed(2));
      let kg_40 = parseFloat((kg / 40).toFixed(2));
      let kg_60 = parseFloat((kg / 60).toFixed(2));
      let kg_80 = parseFloat((kg / 80).toFixed(2));

      // Build result object
      result = {
        ...result,
        tech_lb: lb,
        tech_kg: kg,
        tech_lb_40: lb_40,
        tech_lb_60: lb_60,
        tech_lb_80: lb_80,
        tech_kg_40: kg_40,
        tech_kg_60: kg_60,
        tech_kg_80: kg_80,
        tech_cubic_feet: cubic_feet,
        tech_cubic_yard: cubic_yard,
        tech_cubic_meter: cubic_meter,
      };

      return { status: "success", payload: result };
    } catch (err) {
      return { status: "error", message: err.message };
    }
  }

  async getCalculationPaverCalculator(body) {
    try {
      let operations = body.tech_operations;
      let first = body.tech_first;
      let second = body.tech_second;
      let third = body.tech_third;
      let four = body.tech_four;
      let fiveb = body.tech_fiveb;
      let units1 = body.tech_units1;
      let units2 = body.tech_units2;
      let units3 = body.tech_units3;
      let units4 = body.tech_units4;
      let price = body.tech_price;
      let cost = body.tech_cost;
      let cost_unit = body.tech_cost_unit;
      let currancy = body.tech_currancy;
      let price_unit = body.tech_price_unit;
      // Parse numbers safely
      first = Number(first) || 0;
      second = Number(second) || 0;
      third = Number(third) || 0;
      four = Number(four) || 0;
      fiveb = Number(fiveb) || 0;
      price = Number(price) || 0;
      cost = Number(cost) || 0;
      currancy = currancy || ""; // ✅ ensure it’s a string

      // Normalize price and cost units (support null currancy)
      if (price_unit === currancy + "ft²" || price_unit === "ft²")
        price_unit = "1";
      else if (price_unit === currancy + "m²" || price_unit === "m²")
        price_unit = "2";

      if (cost_unit === currancy + "ft²" || cost_unit === "ft²")
        cost_unit = "1";
      else if (cost_unit === currancy + "m²" || cost_unit === "m²")
        cost_unit = "2";

      // Unit converter
      function unit_convertc(a, b) {
        a = Number(a);
        if (isNaN(a)) return 0;
        switch (b) {
          case "ft":
            return a * 1;
          case "in":
            return a * 0.0833333;
          case "yd":
            return a * 3;
          case "cm":
            return a * 0.0328084;
          case "m":
            return a * 3.28084;
          case "mi":
            return a * 5280;
          case "km":
            return a * 3281;
          case "mm":
            return a * 0.00328084;
          default:
            return 0;
        }
      }

      let area_ans = 0,
        patio_area_ans = 0,
        no_paver = 0,
        price_p = 0,
        cost_p = 0,
        total_cost = 0;
      const result = {};

      // Operation 3
      if (operations == "3") {
        if (first && second) {
          first = unit_convertc(first, units1);
          second = unit_convertc(second, units2);
          third = unit_convertc(third, units3);
          four = unit_convertc(four, units4);
          patio_area_ans = third * four;
          area_ans = first * second;
        } else return { error: "Please! Check Your Input" };
      }

      // Operation 4
      else if (operations == "4") {
        if (first && second && fiveb) {
          first = unit_convertc(first, units1);
          second = unit_convertc(second, units2);
          third = unit_convertc(third, units3);
          four = unit_convertc(four, units4);
          area_ans = first * second * fiveb;
          patio_area_ans = third * four;
        } else return { error: "Please! Check Your Input" };
      }

      // Operation 5
      else if (operations == "5") {
        if (first) {
          first = unit_convertc(first, units1);
          const sq_val = first / 2;
          const final_val = sq_val * sq_val;
          area_ans = 3.14 * final_val;
          third = unit_convertc(third, units3);
          four = unit_convertc(four, units4);
          patio_area_ans = third * four;
        } else return { error: "Please! Check Your Input" };
      }

      // Safe rounding
      area_ans = Number(area_ans.toFixed(7)) || 0;
      patio_area_ans = Number(patio_area_ans.toFixed(7)) || 0;

      // Paver count
      if (area_ans > 0 && patio_area_ans > 0) {
        const no_p = area_ans / patio_area_ans;
        no_paver = Math.ceil(no_p);
      }

      result.tech_area_ans = area_ans;
      result.tech_patio_area_ans = patio_area_ans;
      result.tech_no_paver = no_paver;

      // Price & cost calculation
      if (price > 0) {
        price_p = price * no_paver;
        result.tech_price_p = Number(price_p.toFixed(2));

        if (price > 0 && cost > 0) {
          if (cost_unit === "1") cost_p = cost * area_ans * 1;
          else if (cost_unit === "2") cost_p = cost * area_ans * 10.7639;

          cost_p = Number(cost_p.toFixed(2)) || 0;
          result.tech_cost_p = cost_p;

          total_cost = price_p + cost_p;
          result.tech_total_cost = Number(total_cost.toFixed(2));
        } else {
          return { error: "Please enter both cost and price" };
        }
      }

      return result;
    } catch (error) {
      console.error("Calculation Error:", error);
      return { error: "Internal Server Error" };
    }
  }

  async getCalculationFenceCalculator(body) {
    try {
      let f_length = body.tech_f_length;
      let fl_units = body.tech_fl_units;
      let post_space = body.tech_post_space;
      let po_units = body.tech_po_units;
      let first = body.tech_first;
      let units1 = body.tech_units1;
      let second = body.tech_second;
      let p_width = body.tech_p_width;
      let pw_units = body.tech_pw_units;
      let p_spacing = body.tech_p_spacing;
      let ps_units = body.tech_ps_units;
      let third = body.tech_third;
      let units3 = body.tech_units3;
      let four = body.tech_four;
      let units4 = body.tech_units4;
      let drop1 = body.tech_drop1;
      let drop2 = body.tech_drop2;
      let drop3 = body.tech_drop3;
      const param = {};

      // ---- Helper Conversion Functions ----
      function convert_units(a, b) {
        if (b == "ft") return a * 1;
        else if (b == "in") return a * 0.0833333;
        else if (b == "yd") return a * 3;
        else if (b == "cm") return a * 0.0328084;
        else if (b == "m") return a * 3.28084;
        else if (b == "mi") return a * 5280;
        else if (b == "km") return a * 3281;
        return a;
      }

      function fconvert_inches(a, b) {
        if (b == "ft") return a * 12;
        else if (b == "in") return a;
        else if (b == "yd") return a * 36;
        else if (b == "cm") return a / 2.54;
        else if (b == "m") return a * 39.37;
        else if (b == "mi") return a / 1000;
        else if (b == "km") return a * 39370;
        return a;
      }

      // ---- Fence Length & Posts ----
      if (isNaN(f_length) || isNaN(post_space)) {
        return { error: "Please! Enter the data" };
      }

      let fLen = convert_units(Number(f_length), fl_units);
      let postSpace = convert_units(Number(post_space), po_units);
      fLen += 0.4;
      postSpace += 0.4;
      fLen = Math.round(fLen);
      postSpace = Math.round(postSpace);

      let no_post = fLen / postSpace + 1;
      no_post += 0.4;
      no_post = Math.round(no_post);
      const no_sections = no_post - 1;

      // ---- Height Calculation ----
      let post_heigth = 0;
      let fence_heigth = 0;

      if (isNaN(first)) return { error: "Please! Enter the data" };

      if (drop1 == "2") {
        const val = convert_units(Number(first), units1);
        post_heigth = (val * 1.5).toFixed(2);
      } else if (drop1 === "1") {
        const val = convert_units(Number(first), units1);
        post_heigth = val.toFixed(2);
        fence_heigth = (val / 1.5).toFixed(2);
      }

      // ---- Rails Calculation ----
      let no_rails = 0;
      let rails_section = 0;

      if (isNaN(second)) return { error: "Please! Enter the data" };

      if (drop2 == "2") {
        no_rails = second * no_sections;
      } else if (drop2 == "1") {
        if (no_sections == 0)
          return {
            error: "Your answer is 0 and 0 cannot be divided by a number",
          };
        rails_section = second / no_sections;
      }

      // ---- Pickets ----
      if (isNaN(p_width) || isNaN(p_spacing))
        return { error: "Please! Enter the data" };

      const pWidth = fconvert_inches(Number(p_width), pw_units);
      const pSpacing = fconvert_inches(Number(p_spacing), ps_units);
      const fLen2 = fLen * 12;
      let no_pickets = fLen2 / (pWidth + pSpacing);
      no_pickets += 0.4;
      no_pickets = Math.round(no_pickets);

      // ---- Concrete Volume ----
      let c_volume = 0;
      if (drop3 == "1") {
        if (isNaN(third) || isNaN(four))
          return { error: "Please! Enter the data" };

        const thirdVal = fconvert_inches(Number(third), units3);
        const fourVal = fconvert_inches(Number(four), units4);
        const postH2 = Number(post_heigth) * 12;
        const buried = postH2 / 3;
        const p_volume = thirdVal * fourVal * buried;
        const h_volume = thirdVal * 3 * (fourVal * 3) * buried;
        c_volume = (h_volume - p_volume) * no_post;
      } else if (drop3 == "2") {
        if (isNaN(third)) return { error: "Please! Enter the data" };

        const thirdVal = fconvert_inches(Number(third), units3);
        const postH2 = Number(post_heigth) * 12;
        const radius = thirdVal / 2;
        const sq_radius = radius * radius;
        const buried = postH2 / 3;
        const p_volume = sq_radius * buried * 3.14;
        const c_radius = radius * 3;
        const sq_cradius = c_radius * c_radius;
        const h_volume = sq_cradius * buried * 3.14;
        c_volume = (h_volume - p_volume) * no_post;
      }

      // ---- Final Volume Units ----
      let ft_volume = 0;
      let yd_volume = 0;
      if (c_volume) {
        ft_volume = (c_volume / 1728).toFixed(2);
        yd_volume = (c_volume / 46656).toFixed(2);
      }

      // ---- Prepare Response ----
      if (no_post) param.tech_no_post = no_post;
      if (no_sections) param.tech_no_sections = no_sections;
      if (post_heigth) param.tech_post_heigth = Number(post_heigth);
      if (fence_heigth) param.tech_fence_heigth = Number(fence_heigth);
      if (no_rails) param.tech_no_rails = no_rails;
      if (rails_section) param.tech_rails_section = rails_section;
      if (no_pickets) param.tech_no_pickets = no_pickets;
      if (c_volume) param.tech_c_volume = c_volume;
      if (ft_volume) param.tech_ft_volume = ft_volume;
      if (yd_volume) param.tech_yd_volume = yd_volume;

      return {
        status: "success",
        payload: param,
      };
    } catch (error) {
      console.error("Calculation Error:", error);
      return { status: "error", message: error.message };
    }
  }

  async getCalculationTopSoilCalculator(body) {
    try {
      let length = body.tech_length;
      let width = body.tech_width;
      let depth = body.tech_depth;
      let area = body.tech_area;
      let length_unit = body.tech_length_unit;
      let width_unit = body.tech_width_unit;
      let depth_unit = body.tech_depth_unit;
      let area_unit = body.tech_area_unit;
      let calculation_unit = body.tech_calculation_unit;
      let purchase_unit = body.tech_purchase_unit;
      let bag_size = body.tech_bag_size;
      let bag_size_unit = body.tech_bag_size_unit;
      let price_per_bag = body.tech_price_per_bag;
      let price_per_ton = body.tech_price_per_ton;

      const ton = 0.05;
      const result = {};

      // ---------------- Conversion Functions ----------------

      function calculate10(a, b) {
        switch (b) {
          case "ft":
            return a * 1;
          case "in":
            return a * 0.0833333;
          case "yd":
            return a * 3;
          case "cm":
            return a * 0.0328084;
          case "m":
            return a * 3.28084;
          case "km":
            return a * 3281;
          case "mi":
            return a * 5280;
          default:
            return 0;
        }
      }

      function volume(c, d) {
        switch (c) {
          case "sq ft":
            return d * 1;
          case "sq yd":
            return d * 9;
          case "sq m":
            return d * 0.836127;
          default:
            return 0;
        }
      }

      function calculate_feet(e, f) {
        switch (e) {
          case "cu ft":
            return [f * 1, 20.02];
          case "cu yd":
            return [f * 27, 0.74];
          case "cu m":
            return [f * 35.3147, 0.57];
          case "lbs":
            return [f * 0.016018614545451, 2000];
          case "kg":
            return [f * 0.035315, 907.18];
          case "liters":
            return [f * 0.0353147, 566.99];
          default:
            return [0, 0];
        }
      }

      // ---------------- Main Calculations ----------------
      let calculation = 0;

      // Case 1: Length × Width × Depth
      if (calculation_unit == "1") {
        if (
          !isNaN(length) &&
          !isNaN(width) &&
          !isNaN(depth) &&
          length > 0 &&
          width > 0 &&
          depth > 0
        ) {
          const lengthValue = calculate10(Number(length), length_unit);
          const widthValue = calculate10(Number(width), width_unit);
          const depthValue = calculate10(Number(depth), depth_unit);
          calculation = lengthValue * widthValue * depthValue;
        } else {
          return { error: "Please! Check Your Input" };
        }
      }

      // Case 2: Area × Depth
      if (calculation_unit == "2") {
        if (!isNaN(area) && !isNaN(depth) && area > 0 && depth > 0) {
          const depthValue = calculate10(Number(depth), depth_unit);
          const areaValue = volume(area_unit, Number(area));
          calculation = depthValue * areaValue;
        } else {
          return { error: "Please! Check Your Input" };
        }
      }

      // ---------------- Purchase Unit Calculations ----------------

      if (purchase_unit == "1") {
        // CASE: Only volume given
        if (!bag_size && !price_per_bag) {
          return {
            tech_calculation: calculation,
            tech_bag1: calculation / 0.75,
            tech_bag2: calculation / 1,
            tech_bag3: calculation / 1.5,
            tech_bag4: calculation / 2,
            tech_bag5: calculation / 3,
            tech_bag6: calculation / 25,
          };
        }

        // CASE: Bag size given, no price
        if (bag_size && !price_per_bag) {
          if (!isNaN(bag_size) && bag_size > 0) {
            const number_of_bags = calculate_feet(
              bag_size_unit,
              Number(bag_size)
            );
            const calculate_number_of_bags = calculation / number_of_bags[0];
            return {
              tech_calculation: calculation,
              tech_number_of_bags: calculate_number_of_bags,
              tech_bag_size_unit: bag_size_unit,
            };
          } else {
            return { error: "Please! Enter Number Only Number" };
          }
        }

        // CASE: Bag size + price both given
        if (bag_size && price_per_bag) {
          if (
            !isNaN(bag_size) &&
            !isNaN(price_per_bag) &&
            bag_size > 0 &&
            price_per_bag > 0
          ) {
            const number_of_bags = calculate_feet(
              bag_size_unit,
              Number(bag_size)
            );
            const calculate_number_of_bags = calculation / number_of_bags[0];
            const total_cost = Number(price_per_bag) * calculate_number_of_bags;
            return {
              tech_calculation: calculation,
              tech_number_of_bags: calculate_number_of_bags,
              tech_total_cost: total_cost,
              tech_bag_size: bag_size,
              tech_price_per_bag: price_per_bag,
              tech_price_in_ton: (price_per_bag * number_of_bags[1]) / bag_size,
              tech_bag_size_unit: bag_size_unit,
            };
          } else {
            return { error: "Please! Enter Number Only Number" };
          }
        }

        // CASE: Only price given
        if (price_per_bag && !bag_size) {
          if (!isNaN(price_per_bag) && price_per_bag > 0) {
            return {
              tech_calculation: calculation,
            };
          } else {
            return { error: "Please! Enter Number Only Number" };
          }
        }
      }

      // CASE: Purchase unit = ton
      if (purchase_unit == "2") {
        if (!isNaN(price_per_ton) && price_per_ton > 0) {
          const calculate_cost = calculation * ton;
          return {
            tech_calculate_cost: calculate_cost,
            tech_calculation: calculation,
          };
        }
      }

      return { error: "Please! Check Your Input or Purchase Unit" };
    } catch (error) {
      console.error("Calculation Error (Topsoil):", error);
      return { error: "Calculation Failed", message: error.message };
    }
  }

  async getCalculationCubicYardCalculator(body) {
    try {
      let operations = body.tech_operations;
      let first = body.tech_first;
      let second = body.tech_second;
      let third = body.tech_third;
      let four = body.tech_four;
      let quantity = body.tech_quantity;
      let units1 = body.tech_units1;
      let units2 = body.tech_units2;
      let units3 = body.tech_units3;
      let units4 = body.tech_units4;
      let price_unit = body.tech_price_unit;
      let price = body.tech_price;
      let extra_area = body.tech_extra_area;
      let extra_units = body.tech_extra_units;
      let currancy = body.tech_currancy;

      const param = {};

      // Remove currency symbols from price_unit
      if (currancy && price_unit) {
        price_unit = price_unit.replace(currancy, "").trim();
      }

      // Conversion: linear
      const calculate = (a, b) => {
        switch (b) {
          case "ft":
            return a * 1;
          case "in":
            return a * 0.0833333;
          case "yd":
            return a * 3;
          case "cm":
            return a * 0.0328084;
          case "m":
            return a * 3.28084;
          default:
            return 0;
        }
      };

      // Conversion: square
      const calculate_square = (x, y) => {
        switch (y) {
          case "ft²":
            return x * 1;
          case "in²":
            return x * 0.00694444;
          case "yd²":
            return x * 9;
          case "cm²":
            return x * 0.00107639;
          case "m²":
            return x * 10.7639;
          default:
            return 0;
        }
      };

      // Helper: format numbers
      const fmt = (num) => (isNaN(num) ? 0 : Number(num.toFixed(2)));

      let cubic_feet = 0,
        cubic_yard = 0,
        cubic_meter = 0,
        cubic_cm = 0,
        cubic_in = 0;
      let estimated_price = null;

      // ------------------- OPERATION CASES -------------------
      const π = 3.14;

      switch (operations) {
        case "3": {
          if ([first, second, third, quantity].every(Number)) {
            first = calculate(+first, units1);
            second = calculate(+second, units2);
            third = calculate(+third, units3);
            cubic_feet = first * second * third;
          } else return { error: "Please check your input" };
          break;
        }

        case "4": {
          if ([first, second, quantity].every(Number)) {
            first = calculate(+first, units1);
            second = calculate(+second, units2);
            cubic_feet = first * Math.pow(second, 2);
          } else return { error: "Please check your input" };
          break;
        }

        case "5": {
          if ([first, second, third, four, quantity].every(Number)) {
            first = calculate(+first, units1);
            second = calculate(+second, units2);
            third = calculate(+third, units3);
            four = calculate(+four, units4);
            const inner = second * third;
            const border = four * 2;
            const total = (second + border) * (third + border);
            const diff = total - inner;
            cubic_feet = first * diff;
          } else return { error: "Please check your input" };
          break;
        }

        case "6": {
          if ([first, second, quantity].every(Number)) {
            first = calculate(+first, units1);
            second = calculate(+second, units2);
            const area = π * Math.pow(second / 2, 2);
            cubic_feet = first * area;
          } else return { error: "Please check your input" };
          break;
        }

        case "7": {
          if ([first, second, third, quantity].every(Number)) {
            first = calculate(+first, units1);
            second = calculate(+second, units2);
            third = calculate(+third, units3);
            const outerD = second + 2 * third;
            const outerA = π * Math.pow(outerD / 2, 2);
            const innerA = π * Math.pow(second / 2, 2);
            const area = outerA - innerA;
            cubic_feet = first * area;
          } else return { error: "Please check your input" };
          break;
        }

        case "8": {
          if ([first, second, third, quantity].every(Number)) {
            first = calculate(+first, units1);
            second = calculate(+second, units2);
            third = calculate(+third, units3);
            const outerA = π * Math.pow(second / 2, 2);
            const innerA = π * Math.pow(third / 2, 2);
            const area = outerA - innerA;
            cubic_feet = first * area;
          } else return { error: "Please check your input" };
          break;
        }

        case "9": {
          if ([first, second, third, four, quantity].every(Number)) {
            first = calculate(+first, units1);
            second = calculate(+second, units2);
            third = calculate(+third, units3);
            four = calculate(+four, units4);
            const a1 = second + third + four;
            const a2 = third + four - second;
            const a3 = four + second - third;
            const a4 = second + third - four;
            const area = 0.25 * Math.sqrt(a1 * a2 * a3 * a4);
            cubic_feet = first * area;
          } else return { error: "Please check your input" };
          break;
        }

        case "10": {
          if ([first, second, third, four, quantity].every(Number)) {
            first = calculate(+first, units1);
            second = calculate(+second, units2);
            third = calculate(+third, units3);
            four = calculate(+four, units4);
            const avg = (second + third) / 2;
            const area = avg * four;
            cubic_feet = first * area;
          } else return { error: "Please check your input" };
          break;
        }

        case "11": {
          if ([first, quantity].every(Number)) {
            first = calculate(+first, units1);
            cubic_feet = Math.pow(first, 3);
          } else return { error: "Please check your input" };
          break;
        }

        case "12": {
          if ([first, second, quantity].every(Number)) {
            first = calculate(+first, units1);
            second = calculate(+second, units2);
            cubic_feet = Math.pow(first, 2) * second * π;
          } else return { error: "Please check your input" };
          break;
        }

        case "13": {
          if ([first, second, third, quantity].every(Number)) {
            first = calculate(+first, units1);
            second = calculate(+second, units2);
            third = calculate(+third, units3);
            if (first > second) {
              const area = π * (Math.pow(first, 2) - Math.pow(second, 2));
              cubic_feet = third * area;
            } else {
              return {
                error: "Outer Radius must be greater than Inner Radius",
              };
            }
          } else return { error: "Please check your input" };
          break;
        }

        case "14": {
          if ([first, quantity].every(Number)) {
            first = calculate(+first, units1);
            cubic_feet = (2 * π * Math.pow(first, 3)) / 3;
          } else return { error: "Please check your input" };
          break;
        }

        case "15": {
          if ([first, second, quantity].every(Number)) {
            first = calculate(+first, units1);
            second = calculate(+second, units2);
            cubic_feet = π * Math.pow(first, 2) * (second / 3);
          } else return { error: "Please check your input" };
          break;
        }

        case "16": {
          if ([extra_area, second, quantity].every(Number)) {
            const area = calculate_square(+extra_area, extra_units);
            second = calculate(+second, units2);
            cubic_feet = (area * second) / 3;
          } else return { error: "Please check your input" };
          break;
        }

        case "17": {
          if ([extra_area, second, quantity].every(Number)) {
            const area = calculate_square(+extra_area, extra_units);
            second = calculate(+second, units2);
            cubic_feet = area * second;
          } else return { error: "Please check your input" };
          break;
        }

        default:
          return { error: "Invalid operation" };
      }

      // ------------------- Common Calculations -------------------
      cubic_yard = cubic_feet / 27;
      cubic_meter = cubic_feet * 0.0283;
      cubic_cm = cubic_feet * 28317;
      cubic_in = cubic_feet * 1728;

      if (quantity) {
        cubic_feet *= +quantity;
        cubic_yard *= +quantity;
        cubic_meter *= +quantity;
        cubic_cm *= +quantity;
        cubic_in *= +quantity;
      }

      // ------------------- Price Calculation -------------------
      if (!isNaN(price)) {
        if (price_unit == "ft³") {
          estimated_price = fmt(cubic_feet * price);
        } else if (price_unit == "yd³") {
          estimated_price = fmt(cubic_yard * price);
        } else if (price_unit == "m³") {
          estimated_price = fmt(cubic_meter * price);
        }
      }

      // ------------------- Final Response -------------------
      return {
        tech_cubic_feet: fmt(cubic_feet),
        tech_cubic_yard: fmt(cubic_yard),
        tech_cubic_meter: fmt(cubic_meter),
        tech_cubic_cm: fmt(cubic_cm),
        tech_cubic_in: fmt(cubic_in),
        ...(estimated_price && { tech_estimated_price: estimated_price }),
      };
    } catch (error) {
      console.error("Calculation Error (Cubic Yard):", error);
      return { error: "Calculation Failed", message: error.message };
    }
  }

  async getCalculationTileCalculator(body) {
    try {
      let {
        tech_area_length: area_length,
        tech_area_length_unit: area_length_unit,
        tech_area_width: area_width,
        tech_area_width_unit: area_width_unit,
        tech_tile_length: tile_length,
        tech_tile_length_unit: tile_length_unit,
        tech_tile_width: tile_width,
        tech_tile_width_unit: tile_width_unit,
        tech_gap_size: gap_size,
        tech_gap_size_unit: gap_size_unit,
        tech_waste: waste,
        tech_price: price,
        tech_price_unit: price_unit,
        tech_box_size: box_size,
        tech_total_area: total_area,
        tech_total_area_unit: total_area_unit,
        tech_calculation_unit: calculation_unit,
        tech_currency: currency,
      } = body;

      const param = {};

      // Price unit ko normalize karein
      if (price_unit === `${currency}tile`) {
        price_unit = "tile";
      } else if (price_unit === `${currency}box`) {
        price_unit = "box";
      } else if (price_unit === `${currency}inch²`) {
        price_unit = "in²";
      } else if (price_unit === `${currency}feet²`) {
        price_unit = "ft²";
      } else if (price_unit === `${currency}yard²`) {
        price_unit = "yd²";
      } else if (price_unit === `${currency}acre`) {
        price_unit = "ac";
      } else if (price_unit === `${currency}meter²`) {
        price_unit = "m²";
      }

      // Helper function: Convert to inches
      const convertInches = (value, unit) => {
        const conversions = {
          ft: value * 12,
          in: value * 1,
          yd: value * 36,
          cm: value * 0.393701,
          m: value * 39.3701,
          mm: value * 0.0393701,
        };
        return conversions[unit] || 0;
      };

      // Helper function: Convert to feet
      const convertFeet = (unit, value) => {
        const conversions = {
          ft: value * 1,
          in: value * 0.0833333,
          yd: value * 3,
          cm: value * 0.0328084,
          m: value * 3.28084,
          mm: value * 0.00328084,
        };
        return conversions[unit] || 0;
      };

      // Helper function: Captain (area conversion)
      const captain = (unit, value) => {
        const conversions = {
          ft: value * 144,
          m: value * 1550,
          yd: value * 9,
          in: value * 1,
          cm: value * 0.155,
        };
        return conversions[unit] || 0;
      };

      let area_length_value, area_width_value, a1;

      // Calculation based on unit type
      if (calculation_unit === "1" || calculation_unit === 1) {
        if (!isNaN(area_length) && !isNaN(area_width)) {
          area_length_value = convertInches(
            parseFloat(area_length),
            area_length_unit
          );
          area_width_value = convertInches(
            parseFloat(area_width),
            area_width_unit
          );
          a1 = area_length_value * area_width_value;
        } else {
          param.error = "Please! Check Your Input";
          return param;
        }
      } else if (calculation_unit === "2" || calculation_unit === 2) {
        if (!isNaN(total_area)) {
          area_length_value = captain(total_area_unit, parseFloat(total_area));
          area_width_value = 1;
          a1 = area_length_value * area_width_value;
        } else {
          param.error = "Please! Check Your Input";
          return param;
        }
      }

      // Tile calculations
      if (
        !isNaN(tile_length) &&
        !isNaN(tile_width) &&
        !isNaN(gap_size) &&
        !isNaN(waste)
      ) {
        const tile_length_value = convertInches(
          parseFloat(tile_length),
          tile_length_unit
        );
        const tile_width_value = convertInches(
          parseFloat(tile_width),
          tile_width_unit
        );
        const gap_size_value = convertInches(
          parseFloat(gap_size),
          gap_size_unit
        );

        const a2 =
          (tile_length_value + gap_size_value) *
          (tile_width_value + gap_size_value);
        let formula = a1 / a2;

        // Add waste percentage
        if (waste !== "" && waste != null) {
          const diff = (parseFloat(waste) / 100) * formula;
          formula = formula + diff;
        }

        const final_formula = formula;

        // Calculate Area Size
        const size1 = convertFeet(area_length_unit, parseFloat(area_length));
        const size2 = convertFeet(area_width_unit, parseFloat(area_width));
        const calculate_size = size1 * size2;

        // Box size calculation
        if (box_size !== "" && box_size != null) {
          if (parseFloat(box_size) < 0) {
            param.error = "Please! Enter Positive Value";
            return param;
          } else if (!isNaN(box_size)) {
            const calculate_box_size = final_formula / parseFloat(box_size);
            param.calculate_box_size = calculate_box_size;
          } else {
            param.error = "Please! Check Your Input";
            return param;
          }
        }

        // Price calculation
        if (price !== "" && price != null) {
          if (parseFloat(price) < 0) {
            param.error = "Please! Enter Positive Value";
            return param;
          } else if (!isNaN(price)) {
            let p;

            if (price_unit === "tile") {
              p = final_formula * parseFloat(price);
            } else if (price_unit === "box") {
              if (!isNaN(box_size) && box_size !== "" && box_size != null) {
                p = (final_formula / parseFloat(box_size)) * parseFloat(price);
              } else {
                param.error = "Please Fill Box Value";
                return param;
              }
            } else if (price_unit === "in²") {
              p = parseFloat(price) * 144;
            } else if (price_unit === "ft²") {
              p = parseFloat(price) * calculate_size;
            } else if (price_unit === "yd²") {
              p = parseFloat(price) * 0.11;
            } else if (price_unit === "ac") {
              p = parseFloat(price) * 0.0000229568;
            } else if (price_unit === "m²") {
              p = parseFloat(price) * 0.09;
            }

            param.tech_price_per_tile = p;
          } else {
            param.error = "Enter values greater than zero";
            return param;
          }
        }

        param.tech_calculate_size = calculate_size;
        param.tech_formula = final_formula;

        return param;
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }
    } catch (error) {
      console.error("Error in tile calculator:", error);
      return { error: "Calculation failed. Please check your inputs." };
    }
  }

  async getCalculationFlooringCalculator(body) {
    try {
      let room_length = body.tech_room_length;
      let room_length_unit = body.tech_room_length_unit;
      let room_width = body.tech_room_width;
      let room_width_unit = body.tech_room_width_unit;
      let cost = body.tech_cost;
      let cost_unit = body.tech_cost_unit;
      let waste_factor = body.tech_waste_factor;
      let currancy = body.tech_currancy;

      if (currancy && typeof cost_unit === "string") {
        cost_unit = cost_unit.replace(currancy, "").trim();
      }

      // ----------------- Helper Conversions -----------------
      function unit_convert1(unit, value) {
        switch (unit) {
          case "cm":
            return value * 0.01;
          case "m":
            return value * 1;
          case "in":
            return value * 0.0254;
          case "ft":
            return value * 0.3048;
          default:
            return 0;
        }
      }

      function unit_convert2(unit, value) {
        switch (unit.trim()) {
          case "ft²":
            return 10.76 * value;
          case "yd²":
            return 1.2 * value;
          case "m²":
            return 1 * value;
          default:
            return 0;
        }
      }

      // ----------------- Step 2: Calculate area -----------------
      let sum = 0;

      // ensure arrays (just like Laravel's multi-input handling)
      if (!Array.isArray(room_length)) room_length = [room_length];
      if (!Array.isArray(room_width)) room_width = [room_width];
      if (!Array.isArray(room_length_unit))
        room_length_unit = [room_length_unit];
      if (!Array.isArray(room_width_unit)) room_width_unit = [room_width_unit];

      for (let i = 0; i < room_length.length && i < room_width.length; i++) {
        const lenUnit = room_length_unit[i];
        const widUnit = room_width_unit[i];
        const lenVal = Number(room_length[i]);
        const widVal = Number(room_width[i]);

        if (isNaN(lenVal) || isNaN(widVal)) {
          return { error: "Please! Check Your Input" };
        }

        const length_value = unit_convert1(lenUnit, lenVal);
        const width_value = unit_convert1(widUnit, widVal);

        sum += length_value * width_value;
      }

      // ----------------- Step 3: Handle price & waste -----------------
      let result = {};

      const hasCost = cost !== undefined && cost !== "" && !isNaN(cost);
      const hasWaste =
        waste_factor !== undefined &&
        waste_factor !== "" &&
        !isNaN(waste_factor);

      if (hasCost && !hasWaste) {
        const cost_value = unit_convert2(cost_unit, Number(cost));
        result.tech_price = +(cost_value * sum).toFixed(6);
        result.tech_area = +sum.toFixed(6);
        result.tech_total_material = +sum.toFixed(6);
      } else if (hasCost && hasWaste) {
        const cost_value = unit_convert2(cost_unit, Number(cost));
        const waste_calc = (sum * Number(waste_factor)) / 100;
        result.tech_area = +sum.toFixed(6);
        result.tech_total_material = +(sum + waste_calc).toFixed(6);
        result.tech_price = +(result.tech_total_material * cost_value).toFixed(
          6
        );
      } else {
        result.tech_area = +sum.toFixed(6);
        result.tech_total_material = +sum.toFixed(6);
      }

      // ----------------- Step 4: Final Output -----------------
      result.RESULT = 1;
      return result;
    } catch (err) {
      console.error("Calculation Error:", err);
      return { error: "Server error occurred" };
    }
  }

  async getCalculationWallpaperCalculator(body) {
    try {
      // Extract body values
      let type = body.tech_type;
      let room_length = body.tech_room_length;
      let room_length_unit = body.tech_room_length_unit;
      let room_width = body.tech_room_width;
      let room_width_unit = body.tech_room_width_unit;
      let room_height = body.tech_room_height;
      let room_height_unit = body.tech_room_height_unit;
      let door_height = body.tech_door_height;
      let door_height_unit = body.tech_door_height_unit;
      let door_width = body.tech_door_width;
      let door_width_unit = body.tech_door_width_unit;
      let no_of_doors = body.tech_no_of_doors;
      let window_height = body.tech_window_height;
      let window_height_unit = body.tech_window_height_unit;
      let window_width = body.tech_window_width;
      let window_width_unit = body.tech_window_width_unit;
      let no_of_windows = body.tech_no_of_windows;
      let roll_length = body.tech_roll_length;
      let roll_length_unit = body.tech_roll_length_unit;
      let roll_width = body.tech_roll_width;
      let roll_width_unit = body.tech_roll_width_unit;
      let cost = body.tech_cost;
      let pattern = body.tech_pattern;
      let pattern_unit = body.tech_pattern_unit;
      let wall_width = body.tech_wall_width;
      let wall_width_unit = body.tech_wall_width_unit;
      let wall_height = body.tech_wall_height;
      let wall_height_unit = body.tech_wall_height_unit;

      // Convert to numbers where needed
      room_length = Number(room_length);
      room_width = Number(room_width);
      room_height = Number(room_height);
      door_height = Number(door_height);
      door_width = Number(door_width);
      no_of_doors = Number(no_of_doors);
      window_height = Number(window_height);
      window_width = Number(window_width);
      no_of_windows = Number(no_of_windows);
      roll_length = Number(roll_length);
      roll_width = Number(roll_width);
      cost = Number(cost);
      pattern = Number(pattern);
      wall_width = Number(wall_width);
      wall_height = Number(wall_height);

      const param = {};

      // Unit conversion helper
      function unit_convert(unit, value) {
        switch (unit) {
          case "cm":
            return value * 0.01;
          case "m":
            return value * 1;
          case "in":
            return value * 0.0254;
          case "ft":
            return value * 0.3048;
          case "yd":
            return value * 0.9144;
          default:
            return 0;
        }
      }

      let wall_area = 0;
      let wall_height_value = 0;

      // --- Type 1 (Single Wall) ---
      if (type == "1") {
        if (
          !isNaN(wall_width) &&
          !isNaN(wall_height) &&
          wall_width > 0 &&
          wall_height > 0
        ) {
          const wall_width_value = unit_convert(wall_width_unit, wall_width);
          wall_height_value = unit_convert(wall_height_unit, wall_height);
          wall_area = wall_height_value * wall_width_value;
        } else {
          return { error: "Please! Check Your Input" };
        }
      }

      // --- Type 2 (Room with Four Walls) ---
      else if (type == "2") {
        if (
          !isNaN(room_length) &&
          !isNaN(room_width) &&
          !isNaN(room_height) &&
          room_length > 0 &&
          room_width > 0 &&
          room_height > 0
        ) {
          const rlv = unit_convert(room_length_unit, room_length);
          const rwv = unit_convert(room_width_unit, room_width);
          wall_height_value = unit_convert(room_height_unit, room_height);
          wall_area = (rlv + rwv + rlv + rwv) * wall_height_value;
        } else {
          return { error: "Please! Check Your Input" };
        }
      }

      // --- Door Area ---
      let door_area = 0;
      if (
        !isNaN(door_height) &&
        !isNaN(door_width) &&
        !isNaN(no_of_doors) &&
        door_height > 0 &&
        door_width > 0 &&
        no_of_doors > 0
      ) {
        const door_width_value = unit_convert(door_width_unit, door_width);
        const door_height_value = unit_convert(door_height_unit, door_height);
        door_area = door_height_value * door_width_value * no_of_doors;
      } else {
        return { error: "Please! Check Your Input" };
      }

      // --- Window Area ---
      let window_area = 0;
      if (
        !isNaN(window_height) &&
        !isNaN(window_width) &&
        !isNaN(no_of_windows) &&
        window_height > 0 &&
        window_width > 0 &&
        no_of_windows > 0
      ) {
        const window_width_value = unit_convert(
          window_width_unit,
          window_width
        );
        const window_height_value = unit_convert(
          window_height_unit,
          window_height
        );
        window_area = window_height_value * window_width_value * no_of_windows;
      } else {
        return { error: "Please! Check Your Input" };
      }

      // --- Roll Area ---
      let roll_area = 0;
      if (!isNaN(roll_length) && !isNaN(roll_width) && !isNaN(pattern)) {
        const roll_width_value = unit_convert(roll_width_unit, roll_width);
        const roll_length_value = unit_convert(roll_length_unit, roll_length);
        roll_area = roll_width_value * roll_length_value;
      } else {
        return { error: "Please! Check Your Input" };
      }

      // --- Final Calculations ---
      const adjusted_wall_area = wall_area - door_area - window_area;
      const number_of_rolls = adjusted_wall_area / roll_area;

      let costs = 0;
      if (cost !== "" && !isNaN(cost)) {
        costs = number_of_rolls * cost;
      }

      // --- Response ---
      return {
        status: "success",
        payload: {
          tech_area: wall_area,
          tech_door_area: door_area,
          tech_window_area: window_area,
          tech_adjusted_height: Number(wall_height_value.toFixed(2)),
          tech_adjusted_wall_area: adjusted_wall_area,
          tech_number_of_rolls: number_of_rolls,
          tech_costs: costs,
        },
      };
    } catch (error) {
      return { status: "error", message: error.message };
    }
  }

  async getCalculationStudCalculator(body) {
    try {
      // Destructure input body
      let want = body.tech_want;
      let wall_end_stud = body.tech_wall_end_stud;
      let wall_on = body.tech_wall_on;
      let hight = body.tech_hight;
      let hight_unit = body.tech_hight_unit;
      let length = body.tech_length;
      let length_unit = body.tech_length_unit;
      let stud_spacing = body.tech_stud_spacing;
      let stud_spacing_unit = body.tech_stud_spacing_unit;
      let stud_width = body.tech_stud_width;
      let stud_width_unit = body.tech_stud_width_unit;
      let rim_joist_width = body.tech_rim_joist_width;
      let rim_joist_width_unit = body.tech_rim_joist_width_unit;
      let subfloor_thickness = body.tech_subfloor_thickness;
      let subfloor_thickness_unit = body.tech_subfloor_thickness_unit;
      let estimated_waste = body.tech_estimated_waste;
      let stud_price = body.tech_stud_price;

      // Convert numeric inputs
      wall_end_stud = Number(wall_end_stud);
      hight = Number(hight);
      length = Number(length);
      stud_spacing = Number(stud_spacing);
      stud_width = Number(stud_width);
      rim_joist_width = Number(rim_joist_width);
      subfloor_thickness = Number(subfloor_thickness);
      estimated_waste = Number(estimated_waste);
      stud_price = Number(stud_price);

      // Unit conversion function
      function convert_to_in(unit, value) {
        if (unit === "in") return value;
        else if (unit === "cm") return value / 2.54;
        else if (unit === "ft") return value * 12;
        return 0;
      }

      // Validation
      if (
        want &&
        !isNaN(wall_end_stud) &&
        !isNaN(hight) &&
        !isNaN(length) &&
        !isNaN(stud_spacing)
      ) {
        const length_in = convert_to_in(length_unit, length);
        const hight_in = convert_to_in(hight_unit, hight);
        const stud_spacing_in = convert_to_in(stud_spacing_unit, stud_spacing);

        // Studs calculation
        const studs = Math.ceil(
          length_in / stud_spacing_in + 1 + wall_end_stud
        );
        const studs_cost = studs * stud_price;
        const total_cost = studs_cost + (studs_cost * estimated_waste) / 100;

        // Finished length of studs (in feet)
        const finished_length_of_studs = Number(
          ((hight_in - 2 * 2.75) / 12).toFixed(2)
        );

        // Wall area (in ft²)
        const wall_area = hight_in * length_in;
        const wall_area_ft = wall_area / 144;

        // Lumber calculations
        const lumber8 = Math.ceil(length_in / 12 / 8);
        const lumber10 = Math.ceil(length_in / 12 / 10);
        const lumber12 = Math.ceil(length_in / 12 / 12);

        // Response object
        const param = {
          tech_studs: studs,
          tech_total_cost: total_cost,
          tech_finished_length_of_studs: finished_length_of_studs,
          tech_wall_area_ft: wall_area_ft,
          tech_lumber8: lumber8,
          tech_lumber10: lumber10,
          tech_lumber12: lumber12,
        };

        // If want = sheet or all
        if (want === "sheet" || want === "all") {
          if (!isNaN(rim_joist_width) && !isNaN(subfloor_thickness)) {
            const rim_joist_width_in = convert_to_in(
              rim_joist_width_unit,
              rim_joist_width
            );
            const subfloor_thickness_in = convert_to_in(
              subfloor_thickness_unit,
              subfloor_thickness
            );
            const extra =
              ((rim_joist_width_in + subfloor_thickness_in) * length_in) / 144;
            const sheets_req = Number(((wall_area_ft + extra) / 32).toFixed(3));

            param.tech_sheets_req = sheets_req;
          } else {
            return { error: "Please! Check Your Input" };
          }
        }

        // If want = board or all
        if (want === "board" || want === "all") {
          if (!isNaN(stud_width)) {
            const stud_width_in = convert_to_in(stud_width_unit, stud_width);
            const board_footage = (stud_width_in * 96) / 12;
            param.tech_board_footage = board_footage;
          } else {
            return { error: "Please! Check Your Input" };
          }
        }

        // Final output
        return {
          status: "success",
          payload: {
            ...param,
          },
        };
      } else {
        return { error: "Please! Check Your Input" };
      }
    } catch (error) {
      return { status: "error", message: error.message };
    }
  }

  async getCalculationRampCalculator(body) {
    try {
      let appli = body.tech_appli;
      let unit = body.tech_unit;
      let unit0 = body.tech_unit0;
      let unit1 = body.tech_unit1;
      let unit2 = body.tech_unit2;
      let r_type = body.tech_r_type;
      let no = body.tech_no;
      let no1 = body.tech_no1;
      let no2 = body.tech_no2;
      let width = body.tech_width;
      let calc = body.tech_calc;

      appli = appli?.trim();
      unit = unit?.trim();
      unit0 = unit0?.trim();
      unit1 = unit1?.trim();
      unit2 = unit2?.trim();
      r_type = r_type?.trim();
      calc = calc?.trim();

      const param = {};

      // -------------------- CASE 1: calc == "one" --------------------
      if (calc === "one") {
        if (!isNaN(no)) {
          no = parseFloat(no);
          let r, ramplength;

          switch (appli) {
            case "a":
              r = 1 / 12;
              ramplength = no * 12;
              break;
            case "b":
              r = 1 / 16;
              ramplength = no * 16;
              break;
            case "c":
              r = 1 / 20;
              ramplength = no * 20;
              break;
            case "d":
              r = 2 / 12;
              ramplength = (no * 12) / 2;
              break;
            case "e":
              r = 3 / 12;
              ramplength = (no * 12) / 3;
              break;
            default:
              return { error: "Invalid appli value" };
          }

          const grade = r * 100;
          const rad = Math.atan(r);
          const deg = (rad * 180) / Math.PI;
          let runs = Math.sqrt(Math.pow(ramplength, 2) - Math.pow(no, 2));

          const millirad = rad * 1000;
          const microrad = rad * 1000000;
          const minarc = rad * ((60 * 180) / Math.PI);
          const secarc = rad * ((3600 * 180) / Math.PI);
          const gradian = rad * (200 / Math.PI);
          const turns = rad / (2 * Math.PI);
          let pirad = deg * (Math.PI / 180);
          pirad = pirad / Math.PI;

          param.tech_millirad = Number(millirad.toFixed(1));
          param.tech_microrad = Math.round(microrad);
          param.tech_secarc = Math.round(secarc);
          param.tech_gradian = Number(gradian.toFixed(2));
          param.tech_turns = Number(turns.toFixed(5));
          param.tech_pirad = Number(pirad.toFixed(5));
          param.tech_minarc = Math.round(minarc);
          param.tech_grade = Number(grade.toFixed(2));
          param.tech_r_type = r_type;
          param.tech_appli = appli;
          param.tech_runs = Number(runs.toFixed(3));
          param.tech_unit = unit;
          param.tech_deg = Number(deg.toFixed(2));
          param.tech_rad = Number(rad.toFixed(4));
          param.tech_ramplength = ramplength;

          return { status: "success", payload: param };
        } else {
          return { error: "Please! Check your input" };
        }
      }

      // -------------------- CASE 2: calc != "one" --------------------
      else {
        function ramp(unit, value) {
          value = parseFloat(value);
          switch (unit) {
            case "mm":
              return value / 10;
            case "cm":
              return value * 1;
            case "m":
              return value * 100;
            case "in":
              return value * 2.54;
            case "ft":
              return value * 30.48;
            default:
              return value;
          }
        }

        no1 = ramp(unit0, no1);
        no2 = ramp(unit1, no2);
        width = ramp(unit2, width);

        if (!isNaN(no) && !isNaN(no2) && !isNaN(width)) {
          no = parseFloat(no);
          const Hypotenuse1 = Math.pow(no1, 2) + Math.pow(no2, 2);
          const Hypotenuse = Math.sqrt(Hypotenuse1);
          const alpha1 =
            Math.pow(no2, 2) + Math.pow(Hypotenuse, 2) - Math.pow(no1, 2);
          const alpha2 = alpha1 / (2 * no2 * Hypotenuse);
          const alpha = Math.acos(alpha2) * (180 / Math.PI);
          const beta = 90 - alpha;
          const area = no1 * no2 + width * (no1 + no2 + Hypotenuse);
          const volume = (no1 * no2 * width) / 2;
          const sv = area / volume;

          param.tech_unit = unit;
          param.tech_Hypotenuse = Number(Hypotenuse.toFixed(3));
          param.tech_Hypotenuse1 = Hypotenuse1;
          param.tech_alpha = Number(alpha.toFixed(3));
          param.tech_alpha2 = Number(alpha2.toFixed(3));
          param.tech_alpha1 = Number(alpha1.toFixed(3));
          param.tech_beta = Number(beta.toFixed(4));
          param.tech_area = Number(area.toFixed(3));
          param.tech_volume = Number(volume.toFixed(3));
          param.tech_sv = Number(sv.toFixed(3));
          param.tech_no1 = no1;
          param.tech_no2 = no2;
          param.tech_width = width;

          return { status: "success", payload: param };
        } else {
          return { error: "Please! Check your input" };
        }
      }
    } catch (error) {
      return { error: "Server error occurred", details: error.message };
    }
  }

  async getCalculationSquareMeterCalculator(body) {
    try {
      let volume_select = body.tech_volume_select;
      let length = body.tech_length;
      let l_units = body.tech_l_units;
      let width = body.tech_width;
      let w_units = body.tech_w_units;
      let side = body.tech_side;
      let s_units = body.tech_s_units;
      let quantity = body.tech_quantity;
      let price = body.tech_price;

      const param = {};

      // Parse & sanitize inputs
      volume_select = parseInt(volume_select);
      length = parseFloat(length);
      width = parseFloat(width);
      side = parseFloat(side);
      quantity = quantity ? parseFloat(quantity) : 1;
      price =
        price !== undefined && price !== null && price !== ""
          ? parseFloat(price)
          : null;

      // ✅ Conversion function to meters
      function meterconvert(value, unit) {
        switch (unit) {
          case "mm":
            return value / 1000;
          case "cm":
            return value / 100;
          case "in":
            return value / 39.37;
          case "ft":
            return value / 3.281;
          case "yd":
            return value / 1.094;
          default:
            return value;
        }
      }

      // Convert all dimensions to meters
      const length_m = meterconvert(length, l_units);
      const width_m = meterconvert(width, w_units);
      const side_m = meterconvert(side, s_units);

      let res = 0;
      let cost = 0;

      // ✅ CASE 1: Rectangle (volume_select = 1)
      if (volume_select === 1) {
        if (isNaN(length_m)) {
          return { error: "Please! Check Your Inputs" };
        }

        res = width_m * length_m;
        if (isNaN(price)) {
          res = res * quantity;
        } else {
          cost = price * res;
        }
      }

      // ✅ CASE 2: Square (volume_select = 2)
      else if (volume_select === 2) {
        res = Math.pow(width_m, 2);
        if (isNaN(price)) {
          res = res * quantity;
        } else {
          cost = price * res;
        }
      }

      // ✅ CASE 3: Circle (volume_select = 3)
      else if (volume_select === 3) {
        if (isNaN(length_m)) {
          return { error: "Please! Check Your Inputs" };
        }

        const radi = length_m / 2;
        res = 3.1416 * Math.pow(radi, 2);
        if (isNaN(price)) {
          res = res * quantity;
        } else {
          cost = price * res;
        }
      }

      // ✅ CASE 4: Triangle (default)
      else {
        if (isNaN(length_m) || isNaN(width_m) || isNaN(side_m)) {
          return { error: "Please! Check Your Inputs" };
        }

        res =
          0.25 *
          Math.sqrt(
            (length_m + width_m + side_m) *
              (-length_m + width_m + side_m) *
              (length_m - width_m + side_m) *
              (length_m + width_m - side_m)
          );

        if (isNaN(price)) {
          res = res * quantity;
        } else {
          cost = price * res;
        }
      }

      // ✅ Prepare final output
      if (!isNaN(price)) {
        param.tech_res = Number(res.toFixed(6));
        param.tech_cost = Number(cost.toFixed(6));
      } else {
        param.tech_res = Number(res.toFixed(6));
      }

      return { status: "success", payload: param };
    } catch (error) {
      return { error: "Server error occurred", details: error.message };
    }
  }

  async getCalculationStoneCalculator(body) {
    // Extract and trim input values
    const selection = (body.tech_selection || "").toString().trim();
    const length = (body.tech_length || "").toString().trim();
    const length_unit = (body.tech_length_unit || "").toString().trim();
    const width = (body.tech_width || "").toString().trim();
    const width_unit = (body.tech_width_unit || "").toString().trim();
    const area = (body.tech_area || "").toString().trim();
    const area_unit = (body.tech_area_unit || "").toString().trim();
    const depth = (body.tech_depth || "").toString().trim();
    const depth_unit = (body.tech_depth_unit || "").toString().trim();
    const volume = (body.tech_volume || "").toString().trim();
    const volume_unit = (body.tech_volume_unit || "").toString().trim();
    const material = (body.tech_material || "").toString().trim();
    let price = (body.tech_price || "").toString().trim();
    let price_unit = (body.tech_price_unit || "").toString().trim();
    const currancy = body.tech_currancy || "";

    // Remove currency from price_unit
    if (currancy) {
      price_unit = price_unit.replace(currancy + " ", "");
    }

    const result = {};

    // Helper function: Convert units to feet
    function unit_ft(a, b) {
      let ans1 = 0;
      if (b === "cm") {
        ans1 = a / 30.48;
      } else if (b === "m") {
        ans1 = a * 3.281;
      } else if (b === "in") {
        ans1 = a / 12;
      } else if (b === "yd") {
        ans1 = a * 3;
      } else if (b === "ft") {
        ans1 = a * 1;
      }
      return ans1;
    }

    // Helper function: Convert area units to ft²
    function unit_area(aa, bb) {
      let ans2 = 0;
      if (bb === "ft²") {
        ans2 = aa * 1;
      } else if (bb === "yd²") {
        ans2 = aa * 9;
      } else if (bb === "m²") {
        ans2 = aa * 10.764;
      }
      return ans2;
    }

    // Helper function: Convert volume units to ft³
    function unit_vol(a, b) {
      let ans3 = 0;
      if (b === "ft³") {
        ans3 = a * 1;
      } else if (b === "yd³") {
        ans3 = a * 27;
      } else if (b === "m³") {
        ans3 = a * 35.315;
      }
      return ans3;
    }

    // Helper function: Calculate material tons (imperial)
    function material_val(a, b) {
      let tons1 = 0,
        tons2 = 0;

      // Convert to string for comparison
      const matStr = b.toString();

      if (matStr === "105") {
        tons1 = a * 1.4;
        tons2 = a * 1.7;
      } else if (matStr === "150") {
        tons1 = a * 1.5;
        tons2 = a * 1.7;
      } else if (matStr === "160") {
        tons1 = a * 1.5;
        tons2 = a * 1.7;
      } else if (matStr === "145") {
        tons1 = a * 1.3;
        tons2 = a * 1.5;
      } else if (matStr === "168") {
        tons1 = a * 1.5;
        tons2 = a * 1.7;
      } else if (matStr === "188") {
        tons1 = a * 1;
        tons2 = a * 1.3;
      } else if (matStr === "100") {
        tons1 = a * 1.7;
        tons2 = a * 2;
      }
      return [tons1, tons2];
    }

    // Helper function: Calculate material tons (metric)
    function material_m(a, b) {
      let tons1 = 0,
        tons2 = 0;

      // Convert to string for comparison
      const matStr = b.toString();

      if (matStr === "105") {
        tons1 = a * 1.66;
        tons2 = a * 2.02;
      } else if (matStr === "150") {
        tons1 = a * 1.78;
        tons2 = a * 2.02;
      } else if (matStr === "160") {
        tons1 = a * 1;
        tons2 = a * 2.02;
      } else if (matStr === "145") {
        tons1 = a * 1.54;
        tons2 = a * 1.78;
      } else if (matStr === "168") {
        tons1 = a * 1.78;
        tons2 = a * 2.02;
      } else if (matStr === "188") {
        tons1 = a * 1.19;
        tons2 = a * 1.54;
      } else if (matStr === "100") {
        tons1 = a * 2.02;
        tons2 = a * 2.34;
      }
      return [tons1, tons2];
    }

    // Main calculation logic
    let cubicyd1 = 0,
      array = [0, 0];

    if (selection == "1") {
      // Length x Width x Depth calculation
      if (
        !isNaN(parseFloat(length)) &&
        !isNaN(parseFloat(width)) &&
        !isNaN(parseFloat(depth))
      ) {
        const lengthFt = unit_ft(parseFloat(length), length_unit);
        const widthFt = unit_ft(parseFloat(width), width_unit);
        const depthFt = unit_ft(parseFloat(depth), depth_unit);
        const cubicyd = lengthFt * widthFt * depthFt;
        cubicyd1 = cubicyd / 27;
        array = material_val(cubicyd1, material);
        result.tech_cubicyd1 = cubicyd1;
        result.tech_array = array;
      } else {
        result.error = "Please! Check Your Input";
        return result;
      }
    } else if (selection == "2") {
      // Area x Depth calculation
      if (!isNaN(parseFloat(area)) && !isNaN(parseFloat(depth))) {
        const areaFt = unit_area(parseFloat(area), area_unit);
        const depthFt = unit_ft(parseFloat(depth), depth_unit);
        let cubicyd;
        if (area_unit === "3" && depth_unit === "m") {
          cubicyd = (areaFt / 10.764) * (depthFt / 3.281);
        } else {
          cubicyd = areaFt * depthFt;
        }
        cubicyd1 = cubicyd / 27;
        array = material_val(cubicyd1, material);
        result.tech_array = array;
        result.tech_cubicyd1 = cubicyd1;
      } else {
        result.error = "Please! Check Your Input";
        return result;
      }
    } else if (selection == "3") {
      // Volume calculation
      if (!isNaN(parseFloat(volume))) {
        if (volume_unit === "1") {
          cubicyd1 = parseFloat(volume) / 27;
          array = material_val(cubicyd1, material);
        } else if (volume_unit === "2") {
          cubicyd1 = parseFloat(volume);
          array = material_val(cubicyd1, material);
        } else {
          cubicyd1 = parseFloat(volume);
          array = material_m(cubicyd1, material);
        }
        result.tech_cubicyd1 = cubicyd1;
        result.tech_array = array;
      } else {
        result.error = "Please! Check Your Input";
        return result;
      }
    }

    // Price calculation
    if (!isNaN(parseFloat(price)) && array) {
      const priceNum = parseFloat(price);
      if (price_unit === "per ton") {
        const price_ton = array.map((v) => v * priceNum);
        result.tech_price_ton = price_ton;
      } else {
        const price_cu = priceNum * cubicyd1;
        result.tech_price_cu = price_cu;
      }
      result.tech_price = priceNum;
    }

    return result;
  }

  async getCalculationRoomSizeCalculator(body) {
    try {
      let submit = body.tech_name;
      let lenght_f = body.tech_lenght_f;
      let lenght_in = body.tech_lenght_in;
      let width_f = body.tech_width_f;
      let width_in = body.tech_width_in;
      let perce = body.tech_perce;
      let lenght_m = body.tech_lenght_m;
      let width_m = body.tech_width_m;
      let param = {};

      // Check which mode we are in: 'feet' or 'meter'
      if (submit === "feet") {
        const lengthCount = lenght_f.length;
        const widthCount = width_f.length;

        let lenght_foot = 0;

        for (let i = 0; i < Math.min(lengthCount, widthCount); i++) {
          const lf = lenght_f[i] === "" ? 0 : Number(lenght_f[i]);
          const li = lenght_in[i] === "" ? 0 : Number(lenght_in[i]);
          const wf = width_f[i] === "" ? 0 : Number(width_f[i]);
          const wi = width_in[i] === "" ? 0 : Number(width_in[i]);

          // Validate numeric inputs
          if ((isNaN(lf) && isNaN(li)) || (isNaN(wf) && isNaN(wi))) {
            param.error = "Please! Check Your Input";
            return param;
          }

          const lengthInFeet = lf + li / 12;
          const widthInFeet = wf + wi / 12;
          lenght_foot += lengthInFeet * widthInFeet;
        }

        const f_r_s = lenght_foot;
        if (perce != 0 && f_r_s != 0) {
          const p = (Number(perce) / 100) * f_r_s;
          const perc = f_r_s + p;
          param["perc"] = perc;
        }

        param["f_r_s"] = f_r_s;
      } else if (submit === "meter") {
        const lengthCount = lenght_m.length;
        const widthCount = width_m.length;

        let m_lenght_sum = 0;

        for (let i = 0; i < Math.min(lengthCount, widthCount); i++) {
          const lm = Number(lenght_m[i]);
          const wm = Number(width_m[i]);

          if (isNaN(lm) || isNaN(wm)) {
            param.error = "Please! Check Your Input";
            return param;
          }

          m_lenght_sum += lm * wm;
        }

        const m_r_s = m_lenght_sum;

        if (perce != 0 && m_r_s != 0) {
          const p = (Number(perce) / 100) * m_r_s;
          const perc = m_r_s + p;
          param["perc"] = perc;
        }

        param["m_r_s"] = m_r_s;
      }

      // Common params
      param["submit"] = submit;
      param["perce"] = perce;
      param["RESULT"] = 1;

      return param;
    } catch (error) {
      return { error: "An error occurred during calculation." };
    }
  }

  async getCalculationTankVolumeCalculator(body) {
    const {
      tech_operations: operations,
      tech_first: first,
      tech_second: second,
      tech_third: third,
      tech_four: four,
      tech_units1: units1,
      tech_units2: units2,
      tech_units3: units3,
      tech_units4: units4,
      tech_fill_units: fill_units,
      tech_fill: fill,
    } = body;

    const result = {};
    // Unit conversion function

    function inchesConvert(value, unit) {
      const conversions = {
        ft: value * 12,
        in: value * 1,
        cm: value / 2.54,
        m: value * 39.37,
        mm: value / 25.4,
      };
      return conversions[unit] || value;
    }

    let v_tank, v_fill, per_ans;

    try {
      // Operation 3: Horizontal Cylinder
      if (operations == "3") {
        if (!isNaN(first) && !isNaN(second)) {
          const length = inchesConvert(parseFloat(first), units1);
          const diameter = inchesConvert(parseFloat(second), units2);
          const r = diameter / 2;
          const sq_r = Math.pow(r, 2);
          v_tank = 3.14 * sq_r * length;
          // console.log(v_tank);
          if (!isNaN(fill)) {
            const fillHeight = inchesConvert(parseFloat(fill), fill_units);
            console.log(fillHeight);
            if (fillHeight <= diameter) {
              const a_ans1 = r - fillHeight;
              const f_ans1 = a_ans1 / r;
              const acoc_ans = Math.acos(f_ans1);
              const angle_ans = 2 * acoc_ans;
              const sin_ans = Math.sin(angle_ans);
              const angle_sin = angle_ans - sin_ans;
              v_fill = 0.5 * sq_r * angle_sin * length;
              per_ans = (fillHeight / diameter) * 100;
            } else {
              return { error: "It seems your tank is over filled." };
            }
          }
        } else {
          return { error: "Invalid input values." };
        }
      }

      // Operation 4: Vertical Cylinder
      else if (operations == "4") {
        if (!isNaN(first) && !isNaN(second)) {
          const height = inchesConvert(parseFloat(first), units1);
          const diameter = inchesConvert(parseFloat(second), units2);
          const r = diameter / 2;
          const sq_r = Math.pow(r, 2);
          v_tank = Math.PI * sq_r * height;

          if (!isNaN(fill)) {
            const fillHeight = inchesConvert(parseFloat(fill), fill_units);
            if (fillHeight <= height) {
              v_fill = Math.PI * sq_r * fillHeight;
              per_ans = (fillHeight / height) * 100;
            } else {
              return { error: "It seems your tank is over filled." };
            }
          }
        } else {
          return { error: "Invalid input values." };
        }
      }

      // Operation 5: Rectangular Tank
      else if (operations == "5") {
        if (!isNaN(first) && !isNaN(second) && !isNaN(third)) {
          const height = inchesConvert(parseFloat(first), units1);
          const width = inchesConvert(parseFloat(second), units2);
          const length = inchesConvert(parseFloat(third), units3);
          v_tank = height * width * length;

          if (!isNaN(fill)) {
            const fillHeight = inchesConvert(parseFloat(fill), fill_units);
            if (fillHeight <= height) {
              v_fill = width * length * fillHeight;
              per_ans = (fillHeight / height) * 100;
            } else {
              return { error: "It seems your tank is over filled." };
            }
          }
        } else {
          return { error: "Invalid input values." };
        }
      }

      // Operation 6: Horizontal Capsule
      else if (operations == "6") {
        if (!isNaN(first) && !isNaN(second) && !isNaN(third)) {
          const height = inchesConvert(parseFloat(first), units1);
          const width = inchesConvert(parseFloat(second), units2);
          const length = inchesConvert(parseFloat(third), units3);

          if (width > height) {
            const r = height / 2;
            const sq_r = Math.pow(r, 2);
            const a = width - height;
            const ra = 2 * r * a;
            const pi_sqr = Math.PI * sq_r;
            v_tank = (pi_sqr + ra) * length;

            if (!isNaN(fill)) {
              const fillHeight = inchesConvert(parseFloat(fill), fill_units);
              if (fillHeight <= height) {
                const a_ans1 = r - fillHeight;
                const f_ans1 = a_ans1 / r;
                const acoc_ans = Math.acos(f_ans1);
                const angle_ans = 2 * acoc_ans;
                const sin_ans = Math.sin(angle_ans);
                const angle_sin = angle_ans - sin_ans;
                const v_segment = 0.5 * sq_r * angle_sin * length;
                const v_fill3 = a * length * fillHeight;
                v_fill = v_segment + v_fill3;
                per_ans = (fillHeight / height) * 100;
              } else {
                return { error: "It seems your tank is over filled." };
              }
            }
          } else {
            return { error: "Width must be greater than height" };
          }
        } else {
          return { error: "Invalid input values." };
        }
      }

      // Operation 7: Vertical Capsule
      else if (operations == "7") {
        if (!isNaN(first) && !isNaN(second) && !isNaN(third)) {
          const height = inchesConvert(parseFloat(first), units1);
          const width = inchesConvert(parseFloat(second), units2);
          const length = inchesConvert(parseFloat(third), units3);

          if (height > width) {
            const r = width / 2;
            const sq_r = Math.pow(r, 2);
            const a = height - width;
            const h_r = height - r;
            const ra = 2 * r * a;
            const pi_sqr = Math.PI * sq_r;
            v_tank = (pi_sqr + ra) * length;

            if (!isNaN(fill)) {
              const fillHeight = inchesConvert(parseFloat(fill), fill_units);
              if (fillHeight <= height) {
                if (fillHeight < r) {
                  const a_ans1 = r - fillHeight;
                  const f_ans1 = a_ans1 / r;
                  const acoc_ans = Math.acos(f_ans1);
                  const angle_ans = 2 * acoc_ans;
                  const sin_ans = Math.sin(angle_ans);
                  const angle_sin = angle_ans - sin_ans;
                  v_fill = 0.5 * sq_r * angle_sin * length;
                } else if (fillHeight > r && fillHeight < a) {
                  const f_r = fillHeight - r;
                  const v_fill_1 = 0.5 * Math.PI * sq_r * length;
                  const v_fill_2 = f_r * length * width;
                  v_fill = v_fill_1 + v_fill_2;
                } else if (h_r < height && fillHeight < height) {
                  const a_ans1 = r - fillHeight;
                  const f_ans1 = a_ans1 / r;
                  const acoc_ans = Math.acos(f_ans1);
                  const angle_ans = 2 * acoc_ans;
                  const sin_ans = Math.sin(angle_ans);
                  const angle_sin = angle_ans - sin_ans;
                  const v_segment =
                    Math.PI * sq_r * length - 0.5 * sq_r * angle_sin * length;
                  v_fill = v_tank - v_segment;
                }
                per_ans = (fillHeight / height) * 100;
              } else {
                return { error: "It seems your tank is over filled." };
              }
            }
          } else {
            return { error: "Height must be greater than Width" };
          }
        } else {
          return { error: "Invalid input values." };
        }
      }

      // Operation 8: Horizontal Dish Ends
      else if (operations == "8") {
        if (!isNaN(first) && !isNaN(second)) {
          const length = inchesConvert(parseFloat(first), units1);
          const diameter = inchesConvert(parseFloat(second), units2);
          const r = diameter / 2;
          const sq_r = Math.pow(r, 2);
          const pi_sqr = Math.PI * sq_r;
          const ra = 1.33333333333 * r;
          const ra_a = ra + length;
          v_tank = pi_sqr * ra_a;

          if (!isNaN(fill)) {
            const fillHeight = inchesConvert(parseFloat(fill), fill_units);
            if (fillHeight <= diameter) {
              const a_ans1 = r - fillHeight;
              const f_ans1 = a_ans1 / r;
              const acoc_ans = Math.acos(f_ans1);
              const angle_ans = 2 * acoc_ans;
              const sin_ans = Math.sin(angle_ans);
              const angle_sin = angle_ans - sin_ans;
              const v_segment = 0.5 * sq_r * angle_sin * length;

              let v_fill2 =
                fillHeight < diameter ? v_segment : v_tank - v_segment;

              const sq_fill = Math.pow(fillHeight, 2);
              const pi_fill = Math.PI * sq_fill;
              const step1_ans = pi_fill / 3;
              const d1 = 1.5 * diameter;
              const step2_ans = d1 - fillHeight;
              const step_ans = step1_ans * step2_ans;
              v_fill = v_fill2 + step_ans;
              per_ans = (fillHeight / diameter) * 100;
            } else {
              return { error: "It seems your tank is over filled." };
            }
          }
        } else {
          return { error: "Invalid input values." };
        }
      }

      // Operation 9: Vertical Dish Ends
      else if (operations == "9") {
        if (!isNaN(first) && !isNaN(second)) {
          const length = inchesConvert(parseFloat(first), units1);
          const diameter = inchesConvert(parseFloat(second), units2);
          const r = diameter / 2;
          const sq_r = Math.pow(r, 2);
          const pi_sqr = Math.PI * sq_r;
          const ra = 1.33333333333 * r;
          const ra_a = ra + length;
          v_tank = pi_sqr * ra_a;

          if (!isNaN(fill)) {
            const fillHeight = inchesConvert(parseFloat(fill), fill_units);
            const condition = length + diameter;
            const r_length = r + length;

            if (fillHeight <= condition) {
              if (fillHeight < r) {
                const sq_fill = Math.pow(fillHeight, 2);
                const pi_fill = Math.PI * sq_fill;
                const step1_ans = pi_fill / 3;
                const d1 = 1.5 * diameter;
                const step2_ans = d1 - fillHeight;
                v_fill = step1_ans * step2_ans;
              } else if (fillHeight > r && fillHeight < r_length) {
                const sq_c = Math.pow(r, 3);
                const stepans = fillHeight - r;
                v_fill =
                  0.6666666666 * Math.PI * sq_c + Math.PI * sq_r * stepans;
              } else if (r_length < fillHeight) {
                const sq_fill = Math.pow(fillHeight, 2);
                const pi_fill = Math.PI * sq_fill;
                const step1_ans = pi_fill / 3;
                const d1 = 1.5 * diameter;
                const step_ans = length + diameter - fillHeight;
                const step3 = d1 - step_ans;
                const final_step = step1_ans * step3;
                v_fill = v_tank - final_step;
              }
              per_ans = (fillHeight / condition) * 100;
            } else {
              return { error: "It seems your tank is over filled." };
            }
          }
        } else {
          return { error: "Invalid input values." };
        }
      }

      // Operation 12: Horizontal Oval
      else if (operations == "12") {
        if (!isNaN(first) && !isNaN(second) && !isNaN(third)) {
          const height = inchesConvert(parseFloat(first), units1);
          const width = inchesConvert(parseFloat(second), units2);
          const length = inchesConvert(parseFloat(third), units3);
          const h4 = height / 4;
          v_tank = Math.PI * width * length * h4;

          if (!isNaN(fill)) {
            const fillHeight = inchesConvert(parseFloat(fill), fill_units);
            if (fillHeight <= height) {
              const w4 = width / 4;
              const sq_fill = Math.pow(fillHeight, 2);
              const sq_h = Math.pow(height, 2);
              const square_f = fillHeight / height;
              const square_s = sq_fill / sq_h;
              const sq_ans = 4 * square_f - 4 * square_s;
              const square_ans = Math.sqrt(sq_ans);
              const fh = 2 * square_f;
              const ans_1 = 1 - fh;
              const a_ans_1 = Math.acos(ans_1);
              const answer1 = a_ans_1 - ans_1;
              const final_ans2 = answer1 * square_ans;
              v_fill = height * length * w4 * final_ans2;
              if (v_fill < 0) {
                v_fill = v_fill * -1;
              }
              per_ans = (fillHeight / height) * 100;
            } else {
              return { error: "It seems your tank is over filled." };
            }
          }
        } else {
          return { error: "Invalid input values." };
        }
      }

      // Operation 13: Vertical Cylinder with Cone Bottom
      else if (operations == "13") {
        if (!isNaN(first) && !isNaN(second) && !isNaN(third) && !isNaN(four)) {
          const topDia = inchesConvert(parseFloat(first), units1);
          const botDia = inchesConvert(parseFloat(second), units2);
          const cylHeight = inchesConvert(parseFloat(third), units3);
          const coneHeight = inchesConvert(parseFloat(four), units4);

          if (topDia > botDia) {
            const R_top = topDia / 2;
            const sq_Rtop = Math.pow(R_top, 2);
            const v_cylinder = Math.PI * sq_Rtop * cylHeight;

            const R_bot = botDia / 2;
            const sq_Rbot = Math.pow(R_bot, 2);
            const main_part = sq_Rtop + R_top * R_bot + sq_Rbot;
            const v_frustum = 0.3333333333 * Math.PI * coneHeight * main_part;

            v_tank = v_frustum + v_cylinder;

            if (!isNaN(fill)) {
              const fillHeight = parseFloat(fill);
              if (fillHeight <= coneHeight) {
                const diff = topDia - botDia;
                const z2 = botDia / diff;
                const z = coneHeight * z2;
                const fill_z = fillHeight + z;
                const con_z = coneHeight + z;
                const diff2 = fill_z / con_z;
                const R = 0.5 * topDia * diff2;
                const square_R = Math.pow(R, 2);
                const Answ = square_R + R * R_bot + sq_Rbot;
                v_fill = 0.333333333 * Math.PI * coneHeight * Answ;
                per_ans = (fillHeight / coneHeight) * 100;
              } else if (fillHeight > coneHeight) {
                const radi = topDia - botDia;
                const radius = radi / 2;
                const radius_sq = Math.pow(radius, 2);
                const ans1 = fillHeight - coneHeight;
                const c_volume = Math.PI * radius_sq * ans1;
                v_fill = v_frustum + c_volume;
              }
            }
          } else {
            return {
              error: "Top diameter should be bigger than bottom diameter.",
            };
          }
        } else {
          return { error: "Invalid input values." };
        }
      }

      // Operation 14: Vertical Cylinder with Cone Top
      else if (operations == "14") {
        if (!isNaN(first) && !isNaN(second) && !isNaN(third) && !isNaN(four)) {
          const topDia = inchesConvert(parseFloat(first), units1);
          const botDia = inchesConvert(parseFloat(second), units2);
          const cylHeight = inchesConvert(parseFloat(third), units3);
          const coneHeight = inchesConvert(parseFloat(four), units4);

          if (botDia > topDia) {
            const R_top = topDia / 2;
            const sq_Rtop = Math.pow(R_top, 2);
            const v_cylinder = Math.PI * sq_Rtop * cylHeight;

            const R_bot = botDia / 2;
            const sq_Rbot = Math.pow(R_bot, 2);
            const main_part = sq_Rtop + R_top * R_bot + sq_Rbot;
            const v_frustum = 0.3333333333 * Math.PI * coneHeight * main_part;

            v_tank = v_frustum + v_cylinder;

            if (!isNaN(fill)) {
              const fillHeight = parseFloat(fill);
              if (fillHeight <= coneHeight) {
                const diff = topDia - botDia;
                const z2 = botDia / diff;
                const z = coneHeight * z2;
                const fill_z = fillHeight + z;
                const con_z = coneHeight + z;
                const diff2 = fill_z / con_z;
                const R = 0.5 * topDia * diff2;
                const square_R = Math.pow(R, 2);
                const Answ = square_R + R * R_bot + sq_Rbot;
                v_fill = 0.333333333 * Math.PI * coneHeight * Answ;
                per_ans = (fillHeight / coneHeight) * 100;
              } else if (fillHeight > coneHeight) {
                const radi = topDia - botDia;
                const radius = radi / 2;
                const radius_sq = Math.pow(radius, 2);
                const ans1 = fillHeight - coneHeight;
                const c_volume = Math.PI * radius_sq * ans1;
                v_fill = v_frustum + c_volume;
              }
            }
          } else {
            return {
              error: "Bottom diameter should be bigger than top diameter.",
            };
          }
        } else {
          return { error: "Invalid input values." };
        }
      }

      // Operation 15: Cone
      else if (operations == "15") {
        if (!isNaN(first) && !isNaN(second) && !isNaN(third)) {
          const topDia = inchesConvert(parseFloat(first), units1);
          const botDia = inchesConvert(parseFloat(second), units2);
          const height = inchesConvert(parseFloat(third), units3);

          if (topDia > botDia) {
            const R_top = topDia / 2;
            const sq_Rtop = Math.pow(R_top, 2);
            const R_bot = botDia / 2;
            const sq_Rbot = Math.pow(R_bot, 2);
            const main_part = sq_Rtop + R_top * R_bot + sq_Rbot;
            v_tank = 0.3333333333 * Math.PI * height * main_part;

            if (!isNaN(fill)) {
              const fillHeight = inchesConvert(parseFloat(fill), fill_units);
              if (fillHeight <= topDia) {
                const diff = topDia - botDia;
                const z2 = botDia / diff;
                const z = height * z2;
                const fill_z = fillHeight + z;
                const con_z = z + height;
                const fill_con = fill_z / con_z;
                const R = 0.5 * topDia * fill_con;
                const square_R = Math.pow(R, 2);
                const Answ = square_R + R * R_bot + sq_Rbot;
                v_fill = 0.333333333 * Math.PI * height * Answ;
                per_ans = (fillHeight / four) * 100;
              } else {
                return { error: "It seems your tank is over filled." };
              }
            }
          } else {
            return {
              error: "Top diameter should be bigger than bottom diameter.",
            };
          }
        } else {
          return { error: "Invalid input values." };
        }
      }

      // Operation 16: Sphere
      else if (operations == "16") {
        if (!isNaN(first)) {
          const diameter = inchesConvert(parseFloat(first), units1);
          const r = diameter / 2;
          const cube_r = Math.pow(r, 3);
          v_tank = 1.333333333 * Math.PI * cube_r;

          if (!isNaN(fill)) {
            const fillHeight = inchesConvert(parseFloat(fill), fill_units);
            if (fillHeight < diameter) {
              const r2 = fillHeight / 2;
              const cube_r2 = Math.pow(r2, 3);
              v_fill = 1.333333333 * Math.PI * cube_r2;
              per_ans = (fillHeight / four) * 100;
            } else {
              return { error: "It seems your tank is over filled." };
            }
          }
        } else {
          return { error: "Invalid input values." };
        }
      }

      // Convert volumes to different units
      if (v_tank !== undefined) {
        result.tech_v_tank = v_tank;
        result.tech_v_feet = v_tank / 1728;
        result.tech_v_liter = v_tank / 61.024;
        result.tech_v_meter = v_tank / 61024;
        result.tech_us_gallons = v_tank / 231;
        result.tech_v_yard = v_tank / 46656;
        result.tech_v_cm = v_tank * 16.387;
      }

      if (v_fill !== undefined) {
        result.tech_v_fill = v_fill;
        result.tech_v_feet_fill = v_fill / 1728;
        result.tech_v_liter_fill = v_fill / 61.024;
        result.tech_v_meter_fill = v_fill / 61024;
        result.tech_us_gallons_fill = v_fill / 231;
        result.tech_v_yard_fill = v_fill / 46656;
        result.tech_v_cm_fill = v_fill * 16.387;
        result.tech_per_ans = per_ans;
      }

      return result;
    } catch (error) {
      return { error: "Calculation error: " + error.message };
    }
  }

  async getCalculationDaysSinceDateCalculator(body) {
    try {
      const day = parseInt(body.tech_day);
      const month = parseInt(body.tech_month);
      const year = parseInt(body.tech_year);
      const day1 = parseInt(body.tech_day1);
      const month1 = parseInt(body.tech_month1);
      const year1 = parseInt(body.tech_year1);

      // Create dates
      let date1 = dayjs.utc(`${year}-${month}-${day}`, "YYYY-M-D");
      let date2 = dayjs.utc(`${year1}-${month1}-${day1}`, "YYYY-M-D");

      // Ensure correct order
      if (date2.isBefore(date1)) {
        const temp = date1;
        date1 = date2;
        date2 = temp;
      }

      // Total days (same as Laravel)
      const totaldays = date2.diff(date1, "day");

      let workingDays = 0;
      let holidays = 0;
      let currentDate = date1;

      // Loop until the day BEFORE date2 (to match Laravel)
      while (currentDate.isBefore(date2, "day")) {
        const dayOfWeek = currentDate.day(); // 0=Sun, 6=Sat
        if (dayOfWeek === 0 || dayOfWeek === 6) {
          holidays++;
        } else {
          workingDays++;
        }
        currentDate = currentDate.add(1, "day");
      }

      return {
        workingDays,
        holidays,
        totaldays,
      };
    } catch (error) {
      console.error("Error in getCalculationDaysSinceDateCalculator:", error);
      return { error: "Invalid input or calculation error." };
    }
  }

  async getCalculationhowManyDaysUntilMyBirthdayCalculator(body) {
    try {
      // ✅ Define the Age class inside the function
      class Age {
        constructor() {
          this.age = "";
        }

        calculateAge(timestamp) {
          const now = dayjs.utc();
          const birthDate = dayjs.utc(timestamp);

          let age = now.year() - birthDate.year();
          const monthDiff = now.month() - birthDate.month();
          const dayDiff = now.date() - birthDate.date();

          if (monthDiff < 0 || (monthDiff === 0 && dayDiff < 0)) {
            age--;
          }

          this.age = age;
        }

        getAge2() {
          return this.age;
        }

        getRank(rank) {
          const strRank = String(rank);
          const last = parseInt(strRank.slice(-1));
          const secLast = parseInt(strRank.slice(-2, -1));
          let ext;

          if (last > 3 || last === 0) ext = "th";
          else if (last === 3) ext = "rd";
          else if (last === 2) ext = "nd";
          else ext = "st";

          if (
            (last === 1 && secLast === 1) ||
            (last === 2 && secLast === 1) ||
            (last === 3 && secLast === 1)
          ) {
            ext = "th";
          }

          return `${rank}${ext}`;
        }
      }

      // ✅ Extract input values
      const day = parseInt(body.tech_day);
      const month = parseInt(body.tech_month);
      const year = parseInt(body.tech_year);

      // ✅ Validate DOB
      const dob = dayjs.utc(`${year}-${month}-${day}`, "YYYY-M-D");
      if (!dob.isValid()) {
        return { error: "Invalid date of birth" };
      }

      // ✅ Calculate age
      const ageObj = new Age();
      ageObj.calculateAge(dob.toDate().getTime());
      const age = ageObj.getAge2();

      // ✅ Get current date
      const now = dayjs.utc();

      // ✅ Find next birthday
      let nextBirthday = dayjs.utc(`${now.year()}-${month}-${day}`, "YYYY-M-D");
      if (nextBirthday.isBefore(now)) {
        nextBirthday = nextBirthday.add(1, "year");
      }

      // ✅ Calculate differences
      const daysUntilNextBirthday = nextBirthday.diff(now, "day");
      const diffInHours = nextBirthday.diff(now, "hour");
      const diffInMinutes = nextBirthday.diff(now, "minute");
      const diffInMonths = nextBirthday.diff(now, "month");

      // ✅ Build and return response
      return {
        tech_nextBirthday: nextBirthday.format("YYYY-MM-DD"),
        tech_dob: dob.format("MM-DD-YYYY"),
        tech_age: age,
        tech_diffInHours: diffInHours,
        tech_diffInMinutes: diffInMinutes,
        tech_diffInMonths: diffInMonths,
        tech_daysUntilNextBirthday: daysUntilNextBirthday,
      };
    } catch (error) {
      console.error("Error:", error);
      return { error: "Internal server error" };
    }
  }

  async getCalculationhowManymonthsLeftIntheYearCalculator(body) {
    try {
      const day = parseInt(body.tech_day);
      const month = parseInt(body.tech_month);
      const year = parseInt(body.tech_year);

      // Create current date in UTC
      const now = dayjs.utc(`${year}-${month}-${day}`, "YYYY-M-D");
      if (!now.isValid()) {
        return { error: "Invalid date provided" };
      }

      // Check leap year
      const isLeap = now.isLeapYear();
      const daysInYear = isLeap ? 366 : 365;
      const weeksInYear = 52;

      // End of current year
      const endOfYear = dayjs.utc(`${year}-12-31T23:59:59Z`);

      // Calculate differences
      const daysRemaining = endOfYear.diff(now, "day");
      const weeksRemaining = endOfYear.diff(now, "week");
      const remainingDaysAfterWeeks = daysRemaining - weeksRemaining * 7;

      const monthsRemaining = endOfYear.diff(now, "month");
      const remainingDaysAfterMonths = daysRemaining - monthsRemaining * 30; // Approximation

      const hoursRemaining = endOfYear.diff(now, "hour");

      return {
        tech_now: now.format("MM-DD-YYYY"),
        tech_isLeapYear: isLeap,
        tech_daysInYear: daysInYear,
        tech_weeksInYear: weeksInYear,
        tech_daysRemaining: daysRemaining,
        tech_weeksRemaining: weeksRemaining,
        tech_remainingDaysAfterWeeks: remainingDaysAfterWeeks,
        tech_monthsRemaining: monthsRemaining,
        tech_remainingDaysAfterMonths: remainingDaysAfterMonths,
        tech_hoursRemaining: hoursRemaining,
      };
    } catch (error) {
      console.error("Error calculating months left:", error);
      return { error: "Internal Server Error" };
    }
  }

  async getCalculationhowManyWeeksLeftIntheYearCalculator(body) {
    try {
      const day = parseInt(body.tech_day);
      const month = parseInt(body.tech_month);
      const year = parseInt(body.tech_year);

      // Validate input
      const now = dayjs.utc(`${year}-${month}-${day}`, "YYYY-M-D");
      if (!now.isValid()) {
        return { error: "Invalid date provided" };
      }

      // Check leap year
      const isLeap = now.isLeapYear();
      const daysInYear = isLeap ? 366 : 365;
      const weeksInYear = 52;

      // End of current year
      const endOfYear = dayjs.utc(`${year}-12-31T23:59:59Z`);

      // Calculate differences
      const daysRemaining = endOfYear.diff(now, "day");
      const weeksRemaining = endOfYear.diff(now, "week");
      const remainingDaysAfterWeeks = daysRemaining - weeksRemaining * 7;

      const monthsRemaining = endOfYear.diff(now, "month");
      const remainingDaysAfterMonths = daysRemaining - monthsRemaining * 30; // Approximation
      const hoursRemaining = endOfYear.diff(now, "hour");

      // Return results (same structure as Laravel version)
      return {
        tech_now: now.format("MM-DD-YYYY"),
        tech_isLeapYear: isLeap,
        tech_daysInYear: daysInYear,
        tech_weeksInYear: weeksInYear,
        tech_daysRemaining: daysRemaining,
        tech_weeksRemaining: weeksRemaining,
        tech_remainingDaysAfterWeeks: remainingDaysAfterWeeks,
        tech_monthsRemaining: monthsRemaining,
        tech_remainingDaysAfterMonths: remainingDaysAfterMonths,
        tech_hoursRemaining: hoursRemaining,
      };
    } catch (error) {
      console.error("Error calculating weeks left:", error);
      return { error: "Internal Server Error" };
    }
  }

  async getCalculationMonthFromNowCalculator(body) {
    try {
      const number = parseInt(body.tech_number);
      const current = body.tech_current;

      if (!isNaN(number)) {
        if (number >= 1 || number == 0) {
          const date1 = dayjs.utc(current);
          const dateAfterAddingMonths = date1.add(number, "month");

          const isLeap = dateAfterAddingMonths.isLeapYear();
          const daysInYear = isLeap ? 366 : 365;
          const weeksInYear = 52;
          const currentWeekOfYear = dateAfterAddingMonths.isoWeek(); // ✅ ISO-based week number
          const currentDayOfYear = dateAfterAddingMonths.dayOfYear();

          return {
            tech_date_name: dateAfterAddingMonths.format("dddd"),
            tech_t_date: dateAfterAddingMonths.format("MMMM D, YYYY"),
            tech_daysInYear: daysInYear,
            tech_weeksInYear: weeksInYear,
            tech_currentWeekOfYear: currentWeekOfYear,
            tech_currentDayOfYear: currentDayOfYear,
          };
        } else if (number <= -1) {
          const date2 = dayjs.utc(current);
          const dateAfterSubtractingMonths = date2.subtract(
            Math.abs(number),
            "month"
          );

          const isLeap = dateAfterSubtractingMonths.isLeapYear();
          const daysInYear = isLeap ? 366 : 365;
          const weeksInYear = 52;
          const currentWeekOfYear = dateAfterSubtractingMonths.isoWeek(); // ✅ ISO-based week number
          const currentDayOfYear = dateAfterSubtractingMonths.dayOfYear();

          return {
            tech_date_name: dateAfterSubtractingMonths.format("dddd"),
            tech_t_date: dateAfterSubtractingMonths.format("MMMM D, YYYY"),
            tech_daysInYear: daysInYear,
            tech_weeksInYear: weeksInYear,
            tech_currentWeekOfYear: currentWeekOfYear,
            tech_currentDayOfYear: currentDayOfYear,
          };
        }
      } else {
        return { error: "Please add Number of Months" };
      }
    } catch (error) {
      console.error("Error in getCalculationMonthFromNowCalculator:", error);
      return { error: "Internal Server Error" };
    }
  }

  async getCalculationWeeksBetweenDatesCalculator(body) {
    try {
      const day = parseInt(body.tech_day);
      const month = parseInt(body.tech_month);
      const year = parseInt(body.tech_year);
      const day1 = parseInt(body.tech_day1);
      const month1 = parseInt(body.tech_month1);
      const year1 = parseInt(body.tech_year1);

      // Create UTC dates
      const date1 = dayjs.utc(`${year}-${month}-${day}`, "YYYY-M-D");
      const date2 = dayjs.utc(`${year1}-${month1}-${day1}`, "YYYY-M-D");

      // Validate both dates
      if (!date1.isValid() || !date2.isValid()) {
        return { error: "Invalid date(s) provided" };
      }

      // Calculate absolute difference in days
      const totalDays = Math.abs(date2.diff(date1, "day"));
      const weeks = Math.floor(totalDays / 7);
      const days = totalDays % 7;

      // Return result (mimicking Laravel's structure)
      return {
        tech_date1: date1.format("YYYY-MM-DD"),
        tech_date2: date2.format("YYYY-MM-DD"),
        tech_weeks: weeks,
        tech_days: days,
      };
    } catch (error) {
      console.error(
        "Error in getCalculationWeeksBetweenDatesCalculator:",
        error
      );
      return { error: "Internal Server Error" };
    }
  }

  async getCalculationJuliansDateCalculator(body) {
    const result = {};

    const day = parseInt(body.tech_day);
    const month = parseInt(body.tech_month);
    const year = parseInt(body.tech_year);
    const timecheck = body.tech_timecheck;
    const julian = parseFloat(body.tech_julian);

    // Format date string
    const dob = `${year.toString().padStart(4, "0")}-${month
      .toString()
      .padStart(2, "0")}-${day.toString().padStart(2, "0")}`;

    // Format date1 (e.g., "Monday, January 01, 2024")
    const date1Obj = new Date(year, month - 1, day);
    const date1 = date1Obj.toLocaleDateString("en-US", {
      weekday: "long",
      year: "numeric",
      month: "long",
      day: "2-digit",
    });

    if (timecheck === "stat") {
      // Gregorian to Julian Date conversion
      let adjYear = year;
      let adjMonth = month;

      if (adjMonth <= 2) {
        adjYear -= 1;
        adjMonth += 12;
      }

      const A = Math.floor(adjYear / 100);
      const B = 2 - A + Math.floor(A / 4);
      const julianDate =
        Math.floor(365.25 * (adjYear + 4716)) +
        Math.floor(30.6001 * (adjMonth + 1)) +
        day +
        B -
        1524.5;

      result.tech_julianDate = julianDate;
    } else {
      // Julian Date to Gregorian conversion
      if (!julian && julian !== 0) {
        return { error: "Please Enter Julian Date" };
      }

      let adjJulian = julian + 0.5;
      const Z = Math.floor(adjJulian);
      const F = adjJulian - Z;

      let A;
      if (Z < 2299161) {
        A = Z;
      } else {
        const alpha = Math.floor((Z - 1867216.25) / 36524.25);
        A = Z + 1 + alpha - Math.floor(alpha / 4);
      }

      const B = A + 1524;
      const C = Math.floor((B - 122.1) / 365.25);
      const D = Math.floor(365.25 * C);
      const E = Math.floor((B - D) / 30.6001);

      let calcDay = B - D - Math.floor(30.6001 * E) + F;

      let calcMonth;
      if (E < 14) {
        calcMonth = E - 1;
      } else {
        calcMonth = E - 13;
      }

      let calcYear;
      if (calcMonth > 2) {
        calcYear = C - 4716;
      } else {
        calcYear = C - 4715;
      }

      calcYear = Math.floor(calcYear);
      calcMonth = Math.floor(calcMonth);
      calcDay = Math.floor(calcDay);

      // Calculate day of week using standard Julian Day formula
      // This matches PHP's internal calculation
      const jd = Math.floor(julian + 0.5);
      const dayOfWeekIndex = (jd + 4) % 7;
      const dayNames = [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
      ];
      const monthNames = [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December",
      ];

      const dayOfWeek = dayNames[dayOfWeekIndex];
      const monthName = monthNames[calcMonth - 1];
      const dayStr = calcDay.toString().padStart(2, "0");

      // Format: "Tuesday, -4712 July 27"
      const jul_date = `${dayOfWeek}, ${calcYear} ${monthName} ${dayStr}`;

      result.tech_jul_date = jul_date;
    }

    result.tech_date1 = date1;

    return result;
  }

  async getCalculationDaysLeftInTheYearCalculator(body) {
    try {
      const day = parseInt(body.tech_day);
      const month = parseInt(body.tech_month);
      const year = parseInt(body.tech_year);

      if (isNaN(day) || isNaN(month) || isNaN(year)) {
        return { error: "Invalid date input" };
      }

      // ✅ Create proper date
      const dob = dayjs.utc(`${year}-${month}-${day}`, "YYYY-M-D");
      if (!dob.isValid()) {
        return { error: "Invalid date format" };
      }

      const date1 = dob.format("dddd, MMMM DD, YYYY");
      const now = dob; // same as Carbon($date1)

      // ✅ Leap year check
      const leapYear = now.isLeapYear();
      const daysInYear = leapYear ? 366 : 365;

      // ✅ End of the year
      const endOfYear = dayjs.utc(`${year}-12-31 23:59:59`);

      // ✅ Differences
      const daysRemaining = endOfYear.diff(now, "day");
      const weeksRemaining = endOfYear.diff(now, "week");
      const remainingDaysAfterWeeks = daysRemaining - weeksRemaining * 7;

      const monthsRemaining = endOfYear.diff(now, "month");
      const remainingDaysAfterMonths = daysRemaining - monthsRemaining * 30;

      const hoursRemaining = endOfYear.diff(now, "hour");

      // ✅ Prepare result
      const result = {
        tech_date1: date1,
        tech_now: now.format("MM-DD-YYYY"),
        tech_daysRemaining: daysRemaining,
        tech_weeksRemaining: weeksRemaining,
        tech_remainingDaysAfterWeeks: remainingDaysAfterWeeks,
        tech_monthsRemaining: monthsRemaining,
        tech_remainingDaysAfterMonths: remainingDaysAfterMonths,
        tech_hoursRemaining: hoursRemaining,
        tech_isLeapYear: leapYear,
        tech_daysInYear: daysInYear,
      };

      return { status: "success", payload: result };
    } catch (error) {
      return { status: "fail", message: error.message };
    }
  }

  /**
   * getCalculationDaysAgoCalculator: Service Method
   * POST: /api/calculators-lol/days-ago-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDaysAgoCalculator(body) {
    try {
      const number = parseInt(body.tech_number);
      const current = body.tech_current; // e.g., "2025-10-18"

      if (isNaN(number)) {
        return { error: "Please add Number of Weeks" };
      }

      const date = dayjs.utc(current, "YYYY-MM-DD");
      if (!date.isValid()) {
        return { error: "Invalid current date" };
      }

      let targetDate;

      // ✅ Match Laravel logic:
      if (number <= -1 || number === 0) {
        // Add days (abs of negative number)
        targetDate = date.add(Math.abs(number), "day");
      } else if (number >= 1) {
        // Subtract days
        targetDate = date.subtract(number, "day");
      }

      const isLeap = targetDate.isLeapYear();
      const daysInYear = isLeap ? 366 : 365;
      const weeksInYear = 52;
      const currentWeekOfYear = targetDate.week();
      const currentDayOfYear = targetDate.dayOfYear();

      const result = {
        tech_date_name: targetDate.format("dddd"),
        tech_t_date: targetDate.format("MMMM D, YYYY"),
        tech_daysInYear: daysInYear,
        tech_weeksInYear: weeksInYear,
        tech_currentWeekOfYear: currentWeekOfYear,
        tech_currentDayOfYear: currentDayOfYear,
      };

      return { status: "success", payload: result };
    } catch (error) {
      return { status: "fail", message: error.message };
    }
  }

  /**
   * getCalculationWeeksAgoCalculator: Service Method
   * POST: /api/calculators-lol/weeks-ago-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationWeeksAgoCalculator(body) {
    try {
      // ✅ Support both Laravel-style and tech_ prefix
      const number = parseInt(body.tech_number);
      const current = body.tech_current; // e.g. "2025-10-26"

      if (isNaN(number)) {
        return {
          status: "success",
          payload: { error: "Please add Number of Weeks" },
        };
      }

      const date = dayjs.utc(current, "YYYY-MM-DD");
      if (!date.isValid()) {
        return {
          status: "success",
          payload: { error: "Invalid current date" },
        };
      }

      let targetDate;

      // ✅ Laravel logic replication
      if (number <= -1 || number === 0) {
        targetDate = date.add(Math.abs(number), "week");
      } else if (number >= 1) {
        targetDate = date.subtract(number, "week");
      }

      const isLeap = targetDate.isLeapYear();
      const daysInYear = isLeap ? 366 : 365;
      const weeksInYear = 52;
      const currentWeekOfYear = targetDate.week();
      const currentDayOfYear = targetDate.dayOfYear();

      const result = {
        tech_date_name: targetDate.format("dddd"),
        tech_t_date: targetDate.format("MMMM D, YYYY"),
        tech_daysInYear: daysInYear,
        tech_weeksInYear: weeksInYear,
        tech_currentWeekOfYear: currentWeekOfYear,
        tech_currentDayOfYear: currentDayOfYear,
      };

      return { status: "success", payload: result };
    } catch (error) {
      return { status: "fail", message: error.message };
    }
  }

  /**
   * getCalculationYearsAgoCalculator: Service Method
   * POST: /api/calculators-lol/years-ago-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationYearsAgoCalculator(body) {
    try {
      const number = parseInt(body.tech_number);
      const current = body.tech_current; // e.g. "2025-10-26"

      // ✅ Validate inputs
      if (isNaN(number)) {
        return { error: "Please add Number of Years" };
      }

      const dateNow = dayjs.utc(current, "YYYY-MM-DD");
      if (!dateNow.isValid()) {
        return { error: "Invalid current date" };
      }

      let targetDate;

      // ✅ Case 1: Subtract years if number >= 1
      if (number >= 1) {
        targetDate = dateNow.subtract(number, "year");
      }
      // ✅ Case 2: Add years if number < 0
      else {
        targetDate = dateNow.add(Math.abs(number), "year");
      }

      // ✅ Calculate differences
      const daysDifference = Math.abs(dateNow.diff(targetDate, "day"));
      const weeksDifference = Math.abs(dateNow.diff(targetDate, "week"));
      const monthsDifference = Math.abs(dateNow.diff(targetDate, "month"));

      // ✅ Build response
      const result = {
        tech_DayOfYear: daysDifference,
        tech_WeekOfYear: weeksDifference,
        tech_diffInMonths: monthsDifference,
        tech_date_name: targetDate.format("dddd"), // Day name
        tech_t_date: targetDate.format("MMMM D, YYYY"), // Example: October 18, 2025
      };

      return result;
    } catch (error) {
      return { error: error.message };
    }
  }
  /**
   * getCalculationHoursAgoCalculator: Service Method
   * POST: /api/calculators-lol/hours-ago-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationHoursAgoCalculator(body) {
    try {
      const hours = parseInt(body.tech_hours);
      const minutes = parseInt(body.tech_minutes);
      const seconds = parseInt(body.tech_seconds);
      const hrs = parseInt(body.tech_hrs);
      const min = parseInt(body.tech_min);

      // ✅ Create base time from inputs (use UTC)
      let current = dayjs.utc().hour(hours).minute(minutes).second(seconds);

      // ✅ Validate input
      if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) {
        return { error: "Invalid current time" };
      }

      let result = {};

      // ✅ Case 1: Subtract time if current >= 1
      if (hours >= 1 || minutes >= 1 || seconds >= 1) {
        const timeSubtract = current
          .subtract(hrs, "hour")
          .subtract(min, "minute");

        const t_date = timeSubtract.format("MMMM D, YYYY");
        const days = Math.abs(current.diff(timeSubtract, "day"));

        result.tech_days = days;
        result.tech_t_date = t_date;
        result.tech_time = timeSubtract.format("hh:mm A");
      }
      // ✅ Case 2: Add time if current < 1
      else {
        const timeAdd = current
          .add(Math.abs(hrs), "hour")
          .add(Math.abs(min), "minute");

        const t_date = timeAdd.format("MMMM D, YYYY");
        const days = Math.abs(current.diff(timeAdd, "day"));

        result.tech_days = days;
        result.tech_t_date = t_date;
        result.tech_time = timeAdd.format("hh:mm A");
      }

      return result;
    } catch (error) {
      return { error: error.message };
    }
  }

  /**
   * getCalculationTimeUntilCalculator: Service Method
   * POST: /api/calculators-lol/time-until-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTimeUntilCalculator(body) {
    try {
      const currentInput = body.tech_current; // e.g. "2025-10-18 10:30:00"
      const nextInput = body.tech_next; // e.g. "2025-12-25 12:00:00"

      // ✅ Parse dates in UTC
      const currentTime = dayjs.utc(currentInput);
      const nextTime = dayjs.utc(nextInput);
      const today = dayjs.utc();

      // ✅ Validate date inputs
      if (!currentTime.isValid() || !nextTime.isValid()) {
        return { error: "Please enter valid dates" };
      }

      // ✅ Ensure next date is not in the past
      if (nextTime.isBefore(today)) {
        return { error: "Next date cannot be less than today's date." };
      }

      // ✅ Total seconds difference
      const totalSeconds = nextTime.diff(currentTime, "second");

      // ✅ Break down into time units
      const years = Math.floor(totalSeconds / (365 * 24 * 60 * 60));
      const months = Math.floor(
        (totalSeconds % (365 * 24 * 60 * 60)) / (30 * 24 * 60 * 60)
      );
      const days = Math.floor(
        (totalSeconds % (30 * 24 * 60 * 60)) / (24 * 60 * 60)
      );
      const hours = Math.floor((totalSeconds % (24 * 60 * 60)) / (60 * 60));
      const minutes = Math.floor((totalSeconds % (60 * 60)) / 60);
      const seconds = totalSeconds % 60;

      // ✅ Return structured response
      return {
        tech_years: years,
        tech_months: months,
        tech_days: days,
        tech_hours: hours,
        tech_minutes: minutes,
        tech_seconds: seconds,
      };
    } catch (error) {
      return { error: error.message };
    }
  }

  /**
   * getCalculationHoursFromNowCalculator: Service Method
   * POST: /api/calculators-lol/hours-from-now
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationHoursFromNowCalculator(body) {
    try {
      const hours = parseInt(body.tech_hours);
      const minutes = parseInt(body.tech_minuts);
      const seconds = parseInt(body.tech_sec);
      const hrs = parseInt(body.tech_hrs);
      const min = parseInt(body.tech_min);

      // ✅ Create initial time (UTC)
      const date1 = dayjs.utc().hour(hours).minute(minutes).second(seconds);

      // ✅ Add given hours and minutes
      const hoursAdding = date1.add(hrs, "hour").add(min, "minute");

      // ✅ Return formatted data
      return {
        tech_original_time: date1.format("HH:mm:ss"),
        tech_new_time: hoursAdding.format("HH:mm:ss"),
        tech_full_date: hoursAdding.format("YYYY-MM-DD HH:mm:ss"),
      };
    } catch (error) {
      return { error: error.message };
    }
  }

  /**
   * getCalculationyearFromTodayCalculator: Service Method
   * POST: /api/calculators-lol/years-from-today
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationyearFromTodayCalculator(body) {
    try {
      const number = parseInt(body.tech_number);
      const current = body.tech_current; // e.g. "2025-10-26"

      if (isNaN(number)) {
        return { error: "Please add Number of Years" };
      }

      const date1 = dayjs.utc(current);

      let dateAfterAddingYear;
      if (number >= 1 || number === 0) {
        // ✅ Add years
        dateAfterAddingYear = date1.add(number, "year");
      } else {
        // ✅ Subtract years
        dateAfterAddingYear = date1.subtract(Math.abs(number), "year");
      }

      // ✅ Calculate differences
      const daysDifference = Math.abs(date1.diff(dateAfterAddingYear, "day"));
      const weeksDifference = Math.abs(date1.diff(dateAfterAddingYear, "week"));

      // ✅ Format output
      return {
        tech_: number >= 0 ? weeksDifference : `-${weeksDifference}`,
        tech_DayOfYear: number >= 0 ? daysDifference : `-${daysDifference}`,
        tech_date_name: dateAfterAddingYear.format("dddd"),
        tech_t_date: dateAfterAddingYear.format("MMMM D, YYYY"),
        // Optional formats if needed:
        tech_uk_date: dateAfterAddingYear.format("D MMMM, YYYY"),
        tech_number_format: dateAfterAddingYear.format("DD/MM/YY"),
        tech_usa_num: dateAfterAddingYear.format("MM/DD/YY"),
        tech_iso: dateAfterAddingYear.format("YYYY-MM-DD"),
      };
    } catch (error) {
      return { error: error.message };
    }
  }

  /**
   * getCalculationWeekFromTodayCalculator: Service Method
   * POST: /api/calculators-lol/time-until-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationWeekFromTodayCalculator(body) {
    try {
      const number = parseInt(body.tech_number);
      const current = body.tech_current; // e.g. "2025-10-26"

      if (isNaN(number)) {
        return { error: "Please add Number of Weeks" };
      }

      const date = dayjs.utc(current);
      let resultDate;

      // ✅ Add or subtract weeks
      if (number >= 1 || number === 0) {
        resultDate = date.add(number, "week");
      } else {
        resultDate = date.subtract(Math.abs(number), "week");
      }

      // ✅ Leap year check
      const isLeapYear =
        (resultDate.year() % 4 === 0 && resultDate.year() % 100 !== 0) ||
        resultDate.year() % 400 === 0;

      const daysInYear = isLeapYear ? 366 : 365;
      const weeksInYear = 52;

      // ✅ Compute week/day of year manually
      const startOfYear = resultDate.startOf("year");
      const currentDayOfYear = resultDate.diff(startOfYear, "day") + 1;
      const currentWeekOfYear = Math.ceil(currentDayOfYear / 7);

      // ✅ Build output
      return {
        tech_date_name: resultDate.format("dddd"),
        tech_t_date: resultDate.format("MMMM D, YYYY"),
        tech_daysInYear: daysInYear,
        tech_weeksInYear: weeksInYear,
        tech_currentWeekOfYear: currentWeekOfYear,
        tech_currentDayOfYear: currentDayOfYear,
        // Optional formats:
        tech_uk_date: resultDate.format("D MMMM, YYYY"),
        tech_number: resultDate.format("DD/MM/YY"),
        tech_usa_num: resultDate.format("MM/DD/YY"),
        tech_iso: resultDate.format("YYYY-MM-DD"),
      };
    } catch (error) {
      return { error: error.message };
    }
  }

  /**
   * getCalculationDaysFromTodayCalculator: Service Method
   * POST: /api/calculators-lol/days-from-today
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDaysFromTodayCalculator(body) {
    try {
      const number = parseInt(body.tech_number);
      const current = body.tech_current; // e.g. "2025-10-26"

      if (isNaN(number)) {
        return { error: "Please add Number of days" };
      }

      const date = dayjs.utc(current);
      let resultDate;

      // ✅ Add or subtract days based on input
      if (number >= 1 || number === 0) {
        resultDate = date.add(number, "day");
      } else if (number <= -1) {
        resultDate = date.subtract(Math.abs(number), "day");
      }

      // ✅ Prepare output (same as Laravel)
      return {
        tech_date_name: resultDate.format("dddd"),
        tech_t_date: resultDate.format("MMMM D, YYYY"), // e.g., October 20, 2025
        tech_uk_date: resultDate.format("D MMMM, YYYY"), // e.g., 20 October, 2025
        tech_number: resultDate.format("DD/MM/YY"), // e.g., 20/10/25
        tech_usa_num: resultDate.format("MM/DD/YY"), // e.g., 10/20/25
        tech_iso: resultDate.format("YYYY-MM-DD"), // e.g., 2025-10-20
      };
    } catch (error) {
      return { error: error.message };
    }
  }

  /**
   * getCalculationWeekCalculator: Service Method
   * POST: /api/calculators-lol/week-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationWeekCalculator(body) {
    try {
      const current = body.tech_current; // e.g., "2025-10-26"
      const next = body.tech_next; // optional
      const number = parseInt(body.tech_number);
      const stype = body.tech_stype; // "s_date" | "e_date" | undefined

      const date1 = dayjs.utc(current);

      if (stype == "s_date") {
        // ➕ Add weeks
        if (isNaN(number)) {
          return { error: "Please input Number of weeks" };
        }
        const addedDate = date1.add(number, "week");
        return { tech_adding: addedDate.format("MMMM D, YYYY") };
      } else if (stype == "e_date") {
        // ➖ Subtract weeks
        if (isNaN(number)) {
          return { error: "Please input Number of weeks" };
        }
        const subtractedDate = date1.subtract(number, "week");
        return { tech_subbtract: subtractedDate.format("MMMM D, YYYY") };
      } else {
        // 🔄 Difference in weeks between two dates
        const date2 = dayjs.utc(next);
        if (!date2.isValid() || !date1.isValid()) {
          return { error: "Invalid date(s) provided" };
        }

        const totalDays = Math.abs(date1.diff(date2, "day"));
        const weeks = Math.floor(totalDays / 7);
        return { tech_weeks: weeks };
      }
    } catch (error) {
      return { error: error.message };
    }
  }

  /**
   * getCalculationDaysUntilCalculator: Service Method
   * POST: /api/calculators-lol/days-until-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDaysUntilCalculator(body) {
    try {
      const current = body.tech_current;
      const next = body.tech_next;
      const startEvent = body.tech_startEvent;
      const inc_all = body.tech_inc_all;
      const inc_day = body.tech_inc_day;
      const weekDay = body.tech_weekDay; // array or single value

      if (!current || !next) {
        return { error: "Please! Check Your Input" };
      }

      const date1 = dayjs.utc(current);
      const date2 = dayjs.utc(next);

      if (!date1.isValid() || !date2.isValid()) {
        return { error: "Invalid date(s) provided" };
      }

      // Calculate difference
      const totaldays = Math.abs(date2.diff(date1, "day"));
      const weeks = Math.floor(totaldays / 7);
      const days = totaldays % 7;
      const months = Math.abs(date2.diff(date1, "month"));

      let adjTotalDays = totaldays;
      let adjDays = days;
      let hours = 0;

      // ➕ Include one extra day
      if (inc_day) {
        adjDays += 1;
        adjTotalDays += 1;
      }

      // ⚙️ Handle "Include All" and "Selected Weekdays"
      if (!inc_all) {
        if (!weekDay || weekDay.length === 0) {
          adjDays = 0;
          hours = 0;
        } else {
          const selectedDays = Array.isArray(weekDay) ? weekDay : [weekDay];
          const additionalDays = selectedDays.length;

          if (additionalDays > 0) {
            adjDays = weeks * additionalDays + adjDays;
            hours = adjDays * 24;
          }
        }
      }

      // ✅ Final response
      return {
        tech_totaldays: adjTotalDays,
        tech_months: months,
        tech_weeks: weeks,
        tech_days: adjDays,
        tech_hours: hours,
      };
    } catch (error) {
      return { error: error.message };
    }
  }

  /**
   * getCalculationDaysElapsedTimeCalculator: Service Method
   * POST: /api/calculators-lol/elapsed-time-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDaysElapsedTimeCalculator(body) {
    try {
      // Extract all inputs
      const main_units = body.tech_main_units?.trim();
      const elapsed_start = parseFloat(body.tech_elapsed_start);
      const elapsed_start_one = parseFloat(body.tech_elapsed_start_one);
      const elapsed_start_sec = parseFloat(body.tech_elapsed_start_sec);
      const elapsed_start_three = parseFloat(body.tech_elapsed_start_three);
      const elapsed_start_unit = body.tech_elapsed_start_unit?.trim();

      const elapsed_end = parseFloat(body.tech_elapsed_end);
      const elapsed_end_one = parseFloat(body.tech_elapsed_end_one);
      const elapsed_end_sec = parseFloat(body.tech_elapsed_end_sec);
      const elapsed_end_three = parseFloat(body.tech_elapsed_end_three);
      const elapsed_end_unit = body.tech_elapsed_end_unit?.trim();

      const clock_format = body.tech_clock_format?.trim();
      let clock_hour = parseFloat(body.tech_clock_hour);
      let clock_minute = parseFloat(body.tech_clock_minute);
      let clock_second = parseFloat(body.tech_clock_second);
      const clock_start_unit = body.tech_clock_start_unit?.trim();
      let clock_hur = parseFloat(body.tech_clock_hur);
      let clock_mints = parseFloat(body.tech_clock_mints);
      let clock_secs = parseFloat(body.tech_clock_secs);
      const clock_end_unit = body.tech_clock_end_unit?.trim();

      // Helper functions
      const time_unit = (value, unit) => {
        if (unit === "sec") return value;
        if (unit === "mins") return value * 60;
        if (unit === "hrs") return value * 3600;
        return value;
      };

      const other_time = (v1, v2, unit) => {
        if (unit === "mins/sec") return v1 * 60 + v2;
        if (unit === "hrs/mins") return v1 * 3600 + v2 * 60;
        return 0;
      };

      const other_time_sec = (v1, v2, v3, unit) => {
        if (unit === "hrs/mins/sec") return v1 * 3600 + v2 * 60 + v3;
        return 0;
      };

      let hours = 0,
        minutes = 0,
        seconds = 0,
        answer = 0;

      // ───────────────────────────────────────────────
      // 🧮 CASE 1: "elapsed" (unit-based calculation)
      // ───────────────────────────────────────────────
      if (main_units == "elapsed") {
        if (
          [
            elapsed_start,
            elapsed_start_one,
            elapsed_start_sec,
            elapsed_start_three,
            elapsed_end,
            elapsed_end_one,
            elapsed_end_sec,
            elapsed_end_three,
          ].every((v) => !isNaN(v))
        ) {
          let start, end;

          // Convert start time
          if (["sec", "mins", "hrs"].includes(elapsed_start_unit)) {
            start = time_unit(elapsed_start, elapsed_start_unit);
          } else if (elapsed_start_unit === "hrs/mins/sec") {
            start = other_time_sec(
              elapsed_start_one,
              elapsed_start_sec,
              elapsed_start_three,
              elapsed_start_unit
            );
          } else {
            start = other_time(
              elapsed_start_one,
              elapsed_start_sec,
              elapsed_start_unit
            );
          }

          // Convert end time
          if (["sec", "mins", "hrs"].includes(elapsed_end_unit)) {
            end = time_unit(elapsed_end, elapsed_end_unit);
          } else if (elapsed_end_unit === "hrs/mins/sec") {
            end = other_time_sec(
              elapsed_end_one,
              elapsed_end_sec,
              elapsed_end_three,
              elapsed_end_unit
            );
          } else {
            end = other_time(
              elapsed_end_one,
              elapsed_end_sec,
              elapsed_end_unit
            );
          }

          if (end < start) {
            return {
              error: "The end time should be greater than the start time",
            };
          }

          answer = end - start;
          hours = Math.floor(answer / 3600);
          minutes = Math.floor((answer % 3600) / 60);
          seconds = answer % 60;
        } else {
          return { error: "Please! Check Your Input" };
        }
      }

      // ───────────────────────────────────────────────
      // 🕐 CASE 2: CLOCK FORMAT (12hr or 24hr)
      // ───────────────────────────────────────────────
      else {
        if (clock_format == "24") {
          if (
            [
              clock_hour,
              clock_minute,
              clock_second,
              clock_hur,
              clock_mints,
              clock_secs,
            ].every((v) => !isNaN(v))
          ) {
            if (clock_hour > clock_hur)
              return { error: "End time must be later than start time." };
            if (clock_hour >= 24)
              return { error: "Start time hour must be less than 24." };
            if (clock_minute >= 60)
              return { error: "Start time minute must be less than 60." };
            if (clock_second >= 60)
              return { error: "Start time second must be less than 60." };
            if (clock_hur >= 24)
              return { error: "End time hour must be less than 24." };
            if (clock_mints >= 60)
              return { error: "End time minute must be less than 60." };
            if (clock_secs >= 60)
              return { error: "End time second must be less than 60." };

            const start_seconds =
              clock_hour * 3600 + clock_minute * 60 + clock_second;
            const end_seconds =
              clock_hur * 3600 + clock_mints * 60 + clock_secs;

            answer = end_seconds - start_seconds;
            hours = Math.floor(answer / 3600);
            minutes = Math.floor((answer % 3600) / 60);
            seconds = answer % 60;
          } else {
            return { error: "Please! Check Your Input" };
          }
        }

        // ───────────────────────────────────────────────
        // 12-hour clock format
        // ───────────────────────────────────────────────
        else {
          if (
            [
              clock_hour,
              clock_minute,
              clock_second,
              clock_hur,
              clock_mints,
              clock_secs,
            ].every((v) => !isNaN(v))
          ) {
            if (clock_hour >= 12)
              return { error: "Start clock time hour should be less than 12" };
            if (clock_minute >= 60)
              return { error: "Start clock minute should be less than 60" };
            if (clock_second >= 60)
              return { error: "Start clock second should be less than 60" };
            if (clock_hur >= 12)
              return { error: "End clock time hour should be less than 12" };
            if (clock_mints >= 60)
              return { error: "End clock minute should be less than 60" };
            if (clock_secs >= 60)
              return { error: "End clock second should be less than 60" };

            // Convert 12-hour to 24-hour format
            if (clock_start_unit === "PM" && clock_hour !== 12)
              clock_hour += 12;
            if (clock_end_unit === "PM" && clock_hur !== 12) clock_hur += 12;

            const start_time =
              clock_hour * 3600 + clock_minute * 60 + clock_second;
            const end_time = clock_hur * 3600 + clock_mints * 60 + clock_secs;

            answer = end_time - start_time;

            // Handle negative duration (PM → AM transition)
            if (answer < 0) answer += 24 * 60 * 60;

            hours = Math.floor(answer / 3600);
            minutes = Math.floor((answer % 3600) / 60);
            seconds = answer % 60;
          } else {
            return { error: "Please! Check Your Input" };
          }
        }
      }

      // ✅ Final result
      return {
        tech_hours: hours,
        tech_minutes: minutes,
        tech_seconds: seconds,
        tech_answer: answer,
      };
    } catch (error) {
      return { error: error.message };
    }
  }

  /**
   * getCalculationAddTimeCalculator: Service Method
   * POST: /api/calculators-lol/add-time-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationAddTimeCalculator(body) {
    try {
      // ✅ Extract inputs safely (arrays or falsy)
      let inhour = body.tech_inhour || false;
      let inminutes = body.tech_inminutes || false;
      let inseconds = body.tech_inseconds || false;
      let inmiliseconds = body.tech_inmiliseconds || false;

      let checkbox1 = body.tech_checkbox1 || false;
      let checkbox2 = body.tech_checkbox2 || false;
      let checkbox3 = body.tech_checkbox3 || false;
      let checkbox4 = body.tech_checkbox4 || false;

      let count_val = parseInt(body.tech_count_val);

      // ✅ Helper: Convert milliseconds into h:m:s:ms
      function convertMilliseconds(milliseconds) {
        let seconds = 0;
        let minutes = 0;
        let hours = 0;

        if (milliseconds >= 1000) {
          seconds += Math.floor(milliseconds / 1000);
          milliseconds %= 1000;
        }

        if (seconds >= 60) {
          minutes += Math.floor(seconds / 60);
          seconds %= 60;
        }

        if (minutes >= 60) {
          hours += Math.floor(minutes / 60);
          minutes %= 60;
        }

        return [hours, minutes, seconds, milliseconds];
      }

      // ✅ Initialize totals
      let time_hour = 0;
      let time_minutes = 0;
      let time_seconds = 0;
      let time_miliseconds = 0;

      let hour_list = [];
      let min_list = [];
      let sec_list = [];
      let mili_list = [];

      for (let i = 0; i < count_val; i++) {
        // 🧩 Handle checkboxes (if unchecked, make value 0)
        let h = checkbox1 ? inhour?.[i] || 0 : 0;
        let m = checkbox2 ? inminutes?.[i] || 0 : 0;
        let s = checkbox3 ? inseconds?.[i] || 0 : 0;
        let ms = checkbox4 ? inmiliseconds?.[i] || 0 : 0;

        // ✅ Convert empty strings to 0 and ensure numeric
        h = h === "" ? 0 : parseFloat(h);
        m = m === "" ? 0 : parseFloat(m);
        s = s === "" ? 0 : parseFloat(s);
        ms = ms === "" ? 0 : parseFloat(ms);

        if (!isNaN(h) && !isNaN(m) && !isNaN(s) && !isNaN(ms)) {
          time_hour += h;
          time_minutes += m;
          time_seconds += s;
          time_miliseconds += ms;

          hour_list.push(h);
          min_list.push(m);
          sec_list.push(s);
          mili_list.push(ms);
        } else {
          return { error: "Please! Check Your Input" };
        }
      }

      // ✅ Convert overflow milliseconds to h:m:s
      let [hours, minutes, seconds, remainingMilliseconds] =
        convertMilliseconds(time_miliseconds);
      time_hour += hours;
      time_minutes += minutes;
      time_seconds += seconds;
      time_miliseconds = remainingMilliseconds;

      // ✅ Normalize minutes and seconds
      if (time_minutes >= 60) {
        time_hour += Math.floor(time_minutes / 60);
        time_minutes %= 60;
      }

      if (time_seconds >= 60) {
        time_minutes += Math.floor(time_seconds / 60);
        time_seconds %= 60;
        if (time_minutes >= 60) {
          time_hour += Math.floor(time_minutes / 60);
          time_minutes %= 60;
        }
      }

      // ✅ Final result
      return {
        tech_hour_list: hour_list,
        tech_min_list: min_list,
        tech_sec_list: sec_list,
        tech_mili_list: mili_list,
        tech_time_hour: time_hour,
        tech_time_minutes: time_minutes,
        tech_time_seconds: time_seconds,
        tech_time_miliseconds: time_miliseconds,
      };
    } catch (err) {
      return { error: err.message };
    }
  }

  /**
   * getCalculationTimeDurationCalculator: Service Method
   * POST: /api/calculators-lol/time-duration-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTimeDurationCalculator(body) {
    const result = {};
    // Extract and trim input values
    const t_start_h = String(body.tech_t_start_h || "").trim();
    const t_start_m = String(body.tech_t_start_m || "").trim();
    const t_start_s = String(body.tech_t_start_s || "").trim();
    const t_start_ampm = String(body.tech_t_start_ampm || "").trim();
    const t_end_h = String(body.tech_t_end_h || "").trim();
    const t_end_m = String(body.tech_t_end_m || "").trim();
    const t_end_s = String(body.tech_t_end_s || "").trim();
    const t_end_ampm = String(body.tech_t_end_ampm || "").trim();
    const start_date = String(body.tech_start_date || "").trim();
    const end_date = String(body.tech_end_date || "").trim();
    const d_start_h = String(body.tech_d_start_h || "").trim();
    const d_start_m = String(body.tech_d_start_m || "").trim();
    const d_start_s = String(body.tech_d_start_s || "").trim();
    const d_start_ampm = String(body.tech_d_start_ampm || "").trim();
    const d_end_h = String(body.tech_d_end_h || "").trim();
    const d_end_m = String(body.tech_d_end_m || "").trim();
    const d_end_s = String(body.tech_d_end_s || "").trim();
    const d_end_ampm = String(body.tech_d_end_ampm || "").trim();
    const submit = String(body.tech_submit || "").trim();
    const calculator_time = String(body.tech_calculator_time || "").trim();

    let start_time_res, end_time_res, days_ans;

    if (calculator_time == "date_cal") {
      // Time Calculator Logic - FIXED: Use actual dates from input
      let start_h = parseInt(t_start_h);
      let start_m = parseInt(t_start_m);
      let start_s = parseInt(t_start_s);
      let end_h = parseInt(t_end_h);
      let end_m = parseInt(t_end_m);
      let end_s = parseInt(t_end_s);

      // Validation
      if (isNaN(start_h) || start_h > 23 || start_h < 0) {
        result.error = "Please enter a valid Start Hour.";
        return result;
      }
      if (isNaN(end_h) || end_h > 23 || end_h < 0) {
        result.error = "Please enter a valid End Hour.";
        return result;
      }
      if (isNaN(start_m) || start_m > 59 || start_m < 0 || t_start_m === "") {
        result.error = "Please enter a valid Start Minute.";
        return result;
      }
      if (isNaN(end_m) || end_m > 59 || end_m < 0 || t_end_m === "") {
        result.error = "Please enter a valid End Minute.";
        return result;
      }
      if (isNaN(start_s) || start_s > 59 || start_s < 0 || t_start_s === "") {
        result.error = "Please enter a valid Start Second.";
        return result;
      }
      if (isNaN(end_s) || end_s > 59 || end_s < 0 || t_end_s === "") {
        result.error = "Please enter a valid End Second.";
        return result;
      }

      // Handle empty or 0 hours
      if (!start_h || start_h === 0) {
        start_h = 12;
      }
      if (!end_h || end_h === 0) {
        end_h = 12;
      }

      // Format time components
      const formatted_start_h = String(start_h).padStart(2, "0");
      const formatted_start_m = String(start_m).padStart(2, "0");
      const formatted_start_s = String(start_s).padStart(2, "0");

      // Build start time
      let start_time_str;
      if (start_h <= 12) {
        start_time_str = `${formatted_start_h}:${formatted_start_m}:${formatted_start_s} ${t_start_ampm}`;
        start_time_res = moment(start_time_str, "hh:mm:ss a");
      } else {
        start_time_str = `${formatted_start_h}:${formatted_start_m}:${formatted_start_s}`;
        start_time_res = moment(start_time_str, "HH:mm:ss");
      }

      // Format end time components
      const formatted_end_h = String(end_h).padStart(2, "0");
      const formatted_end_m = String(end_m).padStart(2, "0");
      const formatted_end_s = String(end_s).padStart(2, "0");

      // Build end time
      let end_time_str;
      if (end_h <= 12) {
        end_time_str = `${formatted_end_h}:${formatted_end_m}:${formatted_end_s} ${t_end_ampm}`;
        end_time_res = moment(end_time_str, "hh:mm:ss a");
      } else {
        end_time_str = `${formatted_end_h}:${formatted_end_m}:${formatted_end_s}`;
        end_time_res = moment(end_time_str, "HH:mm:ss");
      }

      // FIXED: Use actual dates from input instead of hardcoded dates
      start_time_res = moment(
        `${start_date} ${start_time_res.format("HH:mm:ss")}`
      );
      end_time_res = moment(`${end_date} ${end_time_res.format("HH:mm:ss")}`);

      // Calculate day difference
      days_ans = Math.floor(end_time_res.diff(start_time_res, "days", true));
    } else {
      // Date Calculator Logic
      let start_h = parseInt(d_start_h);
      let start_m = parseInt(d_start_m);
      let start_s = parseInt(d_start_s);
      let end_h = parseInt(d_end_h);
      let end_m = parseInt(d_end_m);
      let end_s = parseInt(d_end_s);

      // Validation
      if (isNaN(start_h) || start_h > 23 || start_h < 0) {
        result.error = "Please enter a valid Start Hour.";
        return result;
      }
      if (isNaN(end_h) || end_h > 23 || end_h < 0) {
        result.error = "Please enter a valid End Hour.";
        return result;
      }
      if (isNaN(start_m) || start_m > 59 || start_m < 0 || d_start_m === "") {
        result.error = "Please enter a valid Start Minute.";
        return result;
      }
      if (isNaN(end_m) || end_m > 59 || end_m < 0 || d_end_m === "") {
        result.error = "Please enter a valid End Minute.";
        return result;
      }
      if (isNaN(start_s) || start_s > 59 || start_s < 0 || d_start_s === "") {
        result.error = "Please enter a valid Start Second.";
        return result;
      }
      if (isNaN(end_s) || end_s > 59 || end_s < 0 || d_end_s === "") {
        result.error = "Please enter a valid End Second.";
        return result;
      }

      // Handle empty or 0 hours
      if (!start_h || start_h === 0) {
        start_h = 12;
      }
      if (!end_h || end_h === 0) {
        end_h = 12;
      }

      // Format time components (using d_ variables for date calculator)
      const formatted_start_h = String(start_h).padStart(2, "0");
      const formatted_start_m = String(start_m).padStart(2, "0");
      const formatted_start_s = String(start_s).padStart(2, "0");

      // Build start time
      let start_time_str;
      if (start_h <= 12) {
        start_time_str = `${formatted_start_h}:${formatted_start_m}:${formatted_start_s} ${d_start_ampm}`;
        const start_time_temp = moment(start_time_str, "hh:mm:ss a");
        start_time_str = start_time_temp.format("HH:mm:ss");
      } else {
        start_time_str = `${formatted_start_h}:${formatted_start_m}:${formatted_start_s}`;
      }

      // Format end time components
      const formatted_end_h = String(end_h).padStart(2, "0");
      const formatted_end_m = String(end_m).padStart(2, "0");
      const formatted_end_s = String(end_s).padStart(2, "0");

      // Build end time
      let end_time_str;
      if (end_h <= 12) {
        end_time_str = `${formatted_end_h}:${formatted_end_m}:${formatted_end_s} ${d_end_ampm}`;
        const end_time_temp = moment(end_time_str, "hh:mm:ss a");
        end_time_str = end_time_temp.format("HH:mm:ss");
      } else {
        end_time_str = `${formatted_end_h}:${formatted_end_m}:${formatted_end_s}`;
      }

      // Combine dates with times
      start_time_res = moment(`${start_date} ${start_time_str}`);
      end_time_res = moment(`${end_date} ${end_time_str}`);

      // Calculate day difference
      const dStart = moment(start_date);
      const dEnd = moment(end_date);
      days_ans = dEnd.diff(dStart, "days");
    }

    // Calculate duration
    const duration = moment.duration(end_time_res.diff(start_time_res));

    const days = Math.floor(duration.asDays());
    const hours = duration.hours();
    const minutes = duration.minutes();
    const seconds = duration.seconds();

    // Calculate totals
    const total_days = parseFloat(duration.asDays().toFixed(2));
    const total_hours = parseFloat(duration.asHours().toFixed(2));
    const total_minutes = parseFloat(duration.asMinutes().toFixed(2));
    const total_seconds = parseFloat(duration.asSeconds().toFixed(2));

    // Prepare result
    result.tech_days_ans = days;
    result.tech_hours = hours;
    result.tech_minutes = minutes;
    result.tech_seconds = seconds;
    result.tech_total_days = total_days;
    result.tech_total_hours = total_hours;
    result.tech_total_minutes = total_minutes;
    result.tech_total_seconds = total_seconds;
    result.tech_calculator_time = submit;
    return {
      status: "success",
      payload: result,
    };
  }



  /**
   * getCalculationDaysUntilCalculator: Service Method
   * POST: /api/calculators-lol/birth-year-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationBirthYearCalculator(body) {
    try {
      const date = body.tech_date;
      const age = parseFloat(body.tech_age);
      const ageUnit = body.tech_age_unit;
      const choose = body.tech_choose;
      const submit = body.tech_submit;

      // ✅ Validation check (similar to Laravel)
      if (!date || isNaN(age) || !ageUnit || !choose || !submit) {
        return { error: "Please! Check Your Input" };
      }

      let newDate = dayjs(date);
      if (!newDate.isValid()) {
        return { error: "Invalid date" };
      }

      // ✅ Subtract based on age unit
      switch (ageUnit) {
        case "years":
          newDate = newDate.subtract(age, "year");
          break;
        case "months":
          newDate = newDate.subtract(age, "month");
          break;
        case "weeks":
          newDate = newDate.subtract(age, "week");
          break;
        case "days":
          newDate = newDate.subtract(age, "day");
          break;
        case "hours":
          newDate = newDate.subtract(age, "hour");
          break;
        case "minutes":
          newDate = newDate.subtract(age, "minute");
          break;
        case "second":
          newDate = newDate.subtract(age, "second");
          break;
        default:
          return { error: "Invalid age unit" };
      }

      // ✅ Extract the year
      let newYear = newDate.year();

      // ✅ Apply "before" logic (same as Laravel)
      if (choose === "before") {
        newYear = newYear - 1;
      }

      // ✅ Return same format as Laravel
      return {
        tech_newYear: newYear,
      };
    } catch (error) {
      return { error: error.message };
    }
  }

  /**
   * getCalculationWorkingDaysCalculator: Service Method
   * POST: /api/calculators-lol/working-days-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationWorkingDaysCalculator(body) {
    try {
      const start_date = body.tech_start_date?.trim();
      const end_date = body.tech_end_date?.trim();
      const working_days = body.tech_working_days?.trim(); // "Exclude weekends", "Exclude only Sunday", "Include all days"
      const include_end_date = body.tech_include_end_date?.trim(); // "Yes" or "No"
      const submit = body.tech_submit;

      // ✅ Validation
      if (!start_date || !end_date) {
        return { error: "Please provide both the starting and ending dates" };
      }

      const start = dayjs(start_date, "YYYY-MM-DD");
      const end = dayjs(end_date, "YYYY-MM-DD");

      if (!start.isValid() || !end.isValid()) {
        return { error: "Invalid date format" };
      }

      // ✅ Helper function (same as PHP’s calculateWorkingDays)
      function calculateWorkingDays(startDate, endDate, type) {
        let result = 0;
        let current = startDate;

        while (current.isBefore(endDate) || current.isSame(endDate, "day")) {
          const currentDay = current.day(); // 0 = Sunday, 6 = Saturday

          if (type === "Exclude weekends") {
            if (currentDay !== 6 && currentDay !== 0) result++;
          } else if (type === "Exclude only Sunday") {
            if (currentDay !== 0) result++;
          } else if (type === "Include all days") {
            result++;
          }

          current = current.add(1, "day");
        }

        return result;
      }

      // ✅ Calculate working days
      let result = 0;

      if (working_days == "Exclude weekends") {
        result = calculateWorkingDays(start, end, "Exclude weekends");
      } else if (working_days == "Exclude only Sunday") {
        result = calculateWorkingDays(start, end, "Exclude only Sunday");
      } else {
        // Include all days
        result = Math.ceil(end.diff(start, "day"));
      }

      // ✅ Handle "Include end date" toggle
      if (include_end_date == "No") {
        result--;
      }

      // ✅ Ensure result not negative
      if (result < 0) result = 0;

      // ✅ Return result
      return {
        status: "success",
        payload: {
          tech_answer: result,
          tech_result: 1,
        },
      };
    } catch (error) {
      return { error: error.message };
    }
  }

  /**
   * getCalculationDeadlineCalculator: Service Method
   * POST: /api/calculators-lol/deadline-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDeadlineCalculator(body) {
    try {
      const date = body.tech_date?.trim();
      const period = body.tech_period?.trim();
      const number = body.tech_number ? parseFloat(body.tech_number) : null;
      const before_after = body.tech_before_after?.trim();

      let param = {};

      // ✅ Validation
      if (!date || isNaN(number)) {
        param.error = "Please check your input.";
        return param;
      }

      const parsedDate = dayjs(date, "YYYY-MM-DD", true);
      if (!parsedDate.isValid()) {
        param.error = "Invalid date format. Please use YYYY-MM-DD.";
        return param;
      }

      // ✅ Determine period
      let interval;
      if (period === "Days") {
        interval = "day";
      } else if (period === "Weeks") {
        interval = "week";
      } else if (period === "Years") {
        interval = "year";
      } else {
        param.error = "Invalid period. Please select Days, Weeks, or Years.";
        return param;
      }

      // ✅ Apply before/after logic
      let resultDate;
      if (before_after === "Before") {
        resultDate = parsedDate.subtract(number, interval);
      } else {
        resultDate = parsedDate.add(number, interval);
      }

      // ✅ Format final result
      const formatted = resultDate.format("MMM DD, YYYY");

      param.tech_answer = formatted;
      return param;
    } catch (error) {
      return { error: "An unexpected error occurred: " + error.message };
    }
  }

  /**
   * getCalculationMonthCalculator: Service Method
   * POST: /api/calculators-lol/month-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMonthCalculator(body) {
    try {
      // Extract & sanitize inputs
      const start_date = body.tech_start_date
        ? body.tech_start_date.trim()
        : "";
      const end_date = body.tech_end_date ? body.tech_end_date.trim() : "";

      if (!start_date || !end_date) {
        return { error: "Please! Check Your Input" };
      }

      // Parse dates
      const start = dayjs.utc(start_date);
      const end = dayjs.utc(end_date);

      if (!start.isValid() || !end.isValid()) {
        return { error: "Invalid date format" };
      }

      // Ensure correct order
      const from = start.isBefore(end) ? start : end;
      const to = start.isBefore(end) ? end : start;

      // Calculate difference
      const yearsDiff = to.diff(from, "year");
      const monthsDiff = to.diff(from.add(yearsDiff, "year"), "month");
      const daysDiff = to.diff(
        from.add(yearsDiff, "year").add(monthsDiff, "month"),
        "day"
      );

      const totalMonths = yearsDiff * 12 + monthsDiff;

      return {
        tech_months: totalMonths,
        tech_days: daysDiff,
      };
    } catch (error) {
      return { error: "Something went wrong", details: error.message };
    }
  }

  /**
   * getCalculationReadingTimeCalculator: Service Method
   * POST: /api/calculators-lol/reading-time-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationReadingTimeCalculator(body) {
    try {
      // Extract input and sanitize
      const reading_speed = body.tech_reading_speed
        ? body.tech_reading_speed.trim()
        : "";
      const read_pages = parseFloat(body.tech_read_pages);
      const book_unit = body.tech_book_unit ? body.tech_book_unit.trim() : "";
      const book_leng = parseFloat(body.tech_book_leng);
      const daily_reading = parseFloat(body.tech_daily_reading);
      const total_unit = body.tech_total_unit
        ? body.tech_total_unit.trim()
        : "";
      const time_unit = body.tech_time_unit ? body.tech_time_unit.trim() : "";
      const reading_unit = body.tech_reading_unit
        ? body.tech_reading_unit.trim()
        : "";
      const period_unit = body.tech_period_unit
        ? body.tech_period_unit.trim()
        : "";

      // ✅ Validate numeric inputs
      if (!isFinite(read_pages) || !isFinite(book_leng)) {
        return { error: "Please! Check Your Input" };
      }

      let adjusted_read_pages = read_pages;
      if (book_unit === "hr") {
        adjusted_read_pages = read_pages / 60;
      }

      // Base answer (minutes)
      let answer = book_leng / adjusted_read_pages;
      let answer_main = "";

      // ✅ Handle total unit conversion
      if (total_unit === "min") {
        answer_main = `${answer} min`;
      } else if (total_unit === "hr") {
        answer = answer / 60;
        answer = parseFloat(answer.toFixed(3));
        answer_main = `${answer} hrs`;
      } else if (total_unit === "min/hr") {
        const hours = Math.floor(answer / 60);
        const minutes = Math.round(answer % 60);
        answer_main = `${hours} hrs ${minutes} min`;
      }

      let total_daily_reading = "";
      let period_spent = "";

      // ✅ Handle daily reading and period conversions
      if (isFinite(daily_reading)) {
        const dly_reading = answer / book_leng;
        const dly_reading_min = dly_reading * 1440;
        let total_daily_reading_val = daily_reading / dly_reading_min;
        let period_spent_val = (answer / daily_reading) * 1440;

        // --- Convert total_daily_reading ---
        switch (reading_unit) {
          case "min":
            total_daily_reading = `${total_daily_reading_val.toFixed(3)} min`;
            break;
          case "hr":
            total_daily_reading = `${(total_daily_reading_val * 60).toFixed(
              3
            )} hrs`;
            break;
          case "day":
            total_daily_reading = `${(total_daily_reading_val * 1440).toFixed(
              3
            )} days`;
            break;
          case "week":
            total_daily_reading = `${(total_daily_reading_val * 10080).toFixed(
              3
            )} wks`;
            break;
          case "month":
            total_daily_reading = `${(total_daily_reading_val * 43800).toFixed(
              3
            )} mons`;
            break;
          case "year":
            total_daily_reading = `${(total_daily_reading_val * 525600).toFixed(
              3
            )} yrs`;
            break;
        }

        // --- Convert period_spent ---
        const minutesPerYear = 365 * 24 * 60;
        const minutesPerMonth = 30 * 24 * 60;
        const minutesPerWeek = 7 * 24 * 60;
        const minutesPerDay = 24 * 60;

        switch (period_unit) {
          case "min":
            period_spent = `${period_spent_val} min`;
            break;
          case "hr":
            period_spent = `${(period_spent_val / 60).toFixed(1)} hrs`;
            break;
          case "day":
            period_spent = `${(period_spent_val / 1440).toFixed(1)} day`;
            break;
          case "week":
            period_spent = `${(period_spent_val / 10080).toFixed(1)} wks`;
            break;
          case "month":
            period_spent = `${(period_spent_val / 43800).toFixed(1)} mons`;
            break;
          case "year":
            period_spent = `${(period_spent_val / 525600).toFixed(1)} yrs`;
            break;
          case "minutes/hour": {
            const hours = Math.floor(period_spent_val / 60);
            const minutes = Math.floor(period_spent_val % 60);
            period_spent = `${hours} hr ${minutes} min`;
            break;
          }
          case "year/month/day": {
            const years = Math.floor(period_spent_val / minutesPerYear);
            let remaining = period_spent_val % minutesPerYear;
            const months = Math.floor(remaining / minutesPerMonth);
            remaining = remaining % minutesPerMonth;
            const days = Math.floor(remaining / minutesPerDay);
            period_spent = `${years} year ${months} mon ${days} day`;
            break;
          }
          case "week/day": {
            const weeks = Math.floor(period_spent_val / minutesPerWeek);
            const days = Math.floor(
              (period_spent_val % minutesPerWeek) / minutesPerDay
            );
            period_spent = `${weeks} week ${days} day`;
            break;
          }
          case "day/hour/minutes": {
            const days = Math.floor(period_spent_val / minutesPerDay);
            let remaining = period_spent_val % minutesPerDay;
            const hours = Math.floor(remaining / 60);
            const minutes = Math.floor(remaining % 60);
            period_spent = `${days} day, ${hours} hr, ${minutes} min`;
            break;
          }
        }
      }

      // ✅ Final Response
      return {
        tech_answer: answer_main,
        tech_total_daily_reading: total_daily_reading,
        tech_period_spent: period_spent,
      };
    } catch (error) {
      return { error: "Something went wrong", details: error.message };
    }
  }

  /**
   * getCalculationMilitaryTimeConverterCalculator: Service Method
   * POST: /api/calculators-lol/military-time-converter
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMilitaryTimeConverterCalculator(body) {
    const conversion = body.tech_conversion;
    const military_time = body.tech_military_time;
    const hours = body.tech_hours;
    const hur = body.tech_hur;
    const min = body.tech_min;
    const am_pm = body.tech_am_pm;

    function eng_time(num) {
      const reading = [
        "zero ",
        "one ",
        "two ",
        "three ",
        "four ",
        "five ",
        "six ",
        "seven ",
        "eight ",
        "nine ",
        "ten ",
        "eleven ",
        "twelve ",
        "thirteen ",
        "fourteen ",
        "fifteen ",
        "sixteen ",
        "seventeen ",
        "eighteen ",
        "nineteen ",
        "twenty ",
        "twenty-one ",
        "twenty-two ",
        "twenty-three ",
        "twenty-four ",
        "twenty-five ",
        "twenty-six ",
        "twenty-seven ",
        "twenty-eight ",
        "twenty-nine ",
        "thirty ",
        "thirty-one ",
        "thirty-two ",
        "thirty-three ",
        "thirty-four ",
        "thirty-five ",
        "thirty-six ",
        "thirty-seven ",
        "thirty-eight ",
        "thirty-nine ",
        "forty ",
        "forty-one ",
        "forty-two ",
        "forty-three ",
        "forty-four ",
        "forty-five ",
        "forty-six ",
        "forty-seven ",
        "forty-eight ",
        "forty-nine ",
        "fifty ",
        "fifty-one ",
        "fifty-two ",
        "fifty-three ",
        "fifty-four ",
        "fifty-five ",
        "fifty-six ",
        "fifty-seven ",
        "fifty-eight ",
        "fifty-nine ",
      ];

      let f_two = num.substring(0, 2); // hour
      let l_two = num.substring(2, 4); // minute
      let hr = reading[parseInt(f_two)];
      let minText = reading[parseInt(l_two)];

      // ✅ Always prefix "zero" when hour < 10
      if (parseInt(f_two) < 10) {
        hr = "zero " + hr.trim() + " ";
      }

      return hr + minText;
    }

    if (conversion === "1") {
      if (isNaN(military_time)) {
        return { status: "error", message: "Please! Check Your Input" };
      }

      const originalInput = military_time.toString();
      const padded = originalInput.padStart(4, "0");
      const hourStr = padded.slice(0, padded.length - 2);
      const minuteStr = padded.slice(-2);
      const hour = parseInt(hourStr);
      const minute = parseInt(minuteStr);

      if (hour < 0 || hour >= 24 || minute < 0 || minute >= 60) {
        return { status: "error", message: "Please! Check Your Input" };
      }

      const chubees_ghante = `${hourStr}:${minuteStr}`;
      const bara_ghante = dayjs(chubees_ghante, "HH:mm").format("h:mm a");
      const eng_word = eng_time(`${hourStr}${minuteStr}`);

      return {
        status: "success",
        payload: {
          tech_military_time: originalInput,
          tech_eng_word: eng_word.trim(),
          tech_bara_ghante: bara_ghante,
          tech_chubees_ghante: chubees_ghante,
        },
      };
    }

    // Convert 12-hour or 24-hour time to military
    else if (conversion === "2") {
      if (isNaN(hur) || isNaN(min)) {
        return { status: "error", message: "Please! Check Your Input" };
      }

      if (hours === "24h") {
        const hrStr = hur.toString().padStart(2, "0");
        const minStr = min.toString().padStart(2, "0");
        const time = hrStr + minStr;
        const chubees_ghante = `${hrStr}:${minStr}`;
        const eng_word = eng_time(time);

        return {
          status: "success",
          payload: {
            tech_bara_ghante: chubees_ghante,
            tech_chubees_ghante: chubees_ghante,
            tech_military_time: time,
            tech_eng_word: eng_word.trim(),
          },
        };
      } else if (hours === "12h") {
        const hrStr = hur.toString().padStart(2, "0");
        const minStr = min.toString().padStart(2, "0");
        const time = `${hrStr}:${minStr} ${am_pm}`;
        const hrs_ans = dayjs(time, "hh:mm a").format("HH");
        const min_ans = dayjs(time, "hh:mm a").format("mm");
        const chubees_ghante = `${hrs_ans}:${min_ans}`;
        const military_time = hrs_ans + min_ans;
        const eng_word = eng_time(military_time);

        return {
          status: "success",
          payload: {
            tech_military_time: military_time,
            tech_eng_word: eng_word.trim(),
            tech_bara_ghante: time,
            tech_chubees_ghante: chubees_ghante,
          },
        };
      }
    }

    return { status: "error", message: "Invalid conversion type" };
  }

  /**
   * getCalculationDateDurationCalculator: Service Method
   * POST: /api/calculators-lol/date-duration-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  // dateDurationCalculator.js
  async getCalculationDateDurationCalculator(body) {
    const s_date = body.tech_s_date;
    const e_date = body.tech_e_date;
    const checkbox = body.tech_checkbox;

    const result = {};

    if (!s_date || !e_date) {
      result.error = "Please! Check Your Input.";
      return result;
    }

    let start = dayjs(s_date, "YYYY-MM-DD");
    let end = dayjs(e_date, "YYYY-MM-DD");

    // ✅ Include end date if checkbox is true
    let displayEnd = end;
    if (checkbox) {
      end = end.add(1, "day"); // Include end date in calculation
      displayEnd = end.subtract(1, "day"); // But display original end date
    }

    // Swap if start is after end
    if (start.isAfter(end)) {
      [start, end] = [end, start];
    }

    const fromFormatted = start.format("MMM DD, YYYY");
    const toFormatted = displayEnd.format("MMM DD, YYYY");

    // Calculate year, month, day difference manually
    let tempStart = start.clone();
    let years = 0,
      months = 0,
      days = 0;

    while (tempStart.add(1, "year").isSameOrBefore(end)) {
      tempStart = tempStart.add(1, "year");
      years++;
    }

    while (tempStart.add(1, "month").isSameOrBefore(end)) {
      tempStart = tempStart.add(1, "month");
      months++;
    }

    while (tempStart.add(1, "day").isSameOrBefore(end)) {
      tempStart = tempStart.add(1, "day");
      days++;
    }

    // Total seconds between
    const diffInSeconds = Math.abs(end.unix() - start.unix());

    // Remove seconds from Y/M/D
    const totalUsedSec =
      years * 365 * 24 * 60 * 60 +
      months * 30 * 24 * 60 * 60 +
      days * 24 * 60 * 60;
    const remaining = diffInSeconds - totalUsedSec;

    const hrs = Math.floor(remaining / 3600);
    const mins = Math.floor((remaining % 3600) / 60);
    const secs = remaining % 60;

    return {
      tech_from: fromFormatted,
      tech_to: toFormatted,
      tech_years: years,
      tech_months: months,
      tech_days: days,
      tech_hours: hrs,
      tech_minutes: mins,
      tech_seconds: secs,
    };
  }

  /**
   * getCalculationLeadTimeCalculator: Service Method
   * POST: /api/calculators-lol/date-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLeadTimeCalculator(body) {
    try {
      // ✅ Extract inputs safely
      let tech_type = body.tech_type;
      let tech_pre_time = parseFloat(body.tech_pre_time);
      let tech_pre_units = body.tech_pre_units?.replace("<", "") || "";
      let tech_p_time = parseFloat(body.tech_p_time);
      let tech_p_units = body.tech_p_units?.replace("<", "") || "";
      let tech_post_time = parseFloat(body.tech_post_time);
      let tech_post_units = body.tech_post_units?.replace("<", "") || "";
      let tech_place_time = body.tech_place_time;
      let tech_receive_time = body.tech_receive_time;
      let tech_s_delay = parseFloat(body.tech_s_delay);
      let tech_supply_units = body.tech_supply_units?.replace("<", "") || "";
      let tech_r_delay = parseFloat(body.tech_r_delay);
      let tech_r_units = body.tech_r_units?.replace("<", "") || "";

      // ✅ Return error if no type
      if (!tech_type) {
        return { status: "error", message: "Please! Check Your Input" };
      }

      // ✅ Default response object
      let result = {
        tech_type,
      };

      // 🏭 Type: manufac
      if (tech_type === "manufac") {
        if (
          isNaN(tech_pre_time) ||
          isNaN(tech_p_time) ||
          isNaN(tech_post_time)
        ) {
          return { status: "error", message: "Please! Check Your Input" };
        }

        // ❌ Laravel does not convert units here
        // ✅ Just sum raw numbers directly
        let tech_manufac = tech_pre_time + tech_p_time + tech_post_time;

        result.tech_pre_time = tech_pre_time;
        result.tech_p_time = tech_p_time;
        result.tech_post_time = tech_post_time;
        result.tech_manufac = tech_manufac;
      }

      // 🕒 Type: order
      else if (tech_type === "order") {
        if (!tech_place_time || !tech_receive_time) {
          return { status: "error", message: "Please! Check Your Input" };
        }

        const from_time = new Date(tech_place_time).getTime();
        const to_time = new Date(tech_receive_time).getTime();

        // ✅ Difference in minutes
        const diff_minutes = Math.round(Math.abs(to_time - from_time) / 60000);

        // ✅ Convert minutes to readable hours/minutes
        const hours = Math.floor(diff_minutes / 60);
        const minutes = diff_minutes % 60;
        const time_diff = `${hours} Hours ${minutes} Minutes`;

        result.tech_timeDiff = time_diff;
        result.tech_diff_minutes = diff_minutes;
      }

      // 🚚 Type: supply
      else if (tech_type === "supply") {
        if (isNaN(tech_s_delay) || isNaN(tech_r_delay)) {
          return { status: "error", message: "Please! Check Your Input" };
        }

        // ❌ Laravel does not convert units
        // ✅ Just add both numbers directly
        let tech_supply = tech_s_delay + tech_r_delay;

        result.tech_s_delay = tech_s_delay;
        result.tech_r_delay = tech_r_delay;
        result.tech_supply = tech_supply;
      }

      // ❌ Invalid type
      else {
        return { status: "error", message: "Please! Check Your Input" };
      }
      return {
        result,
      };
    } catch (error) {
      return {
        status: "error",
        message: error.message,
      };
    }
  }

  /**
   * getCalculationTimeSpanCalculator: Service Method
   * POST: /api/calculators-lol/time-span-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationTimeSpanCalculator(body) {
    try {
      // ✅ Extract inputs
      let clock_format = body.tech_clock_format;
      let s_hour = parseInt(body.tech_s_hour);
      let s_min = parseInt(body.tech_s_min);
      let s_sec = parseInt(body.tech_s_sec);
      let s_ampm = body.tech_s_ampm;
      let e_hour = parseInt(body.tech_e_hour);
      let e_min = parseInt(body.tech_e_min);
      let e_sec = parseInt(body.tech_e_sec);
      let e_ampm = body.tech_e_ampm;

      // ✅ Validate inputs
      if (
        isNaN(s_hour) ||
        isNaN(s_min) ||
        isNaN(s_sec) ||
        isNaN(e_hour) ||
        isNaN(e_min) ||
        isNaN(e_sec)
      ) {
        return { status: "error", message: "Please! Check Your Input" };
      }

      // ✅ Helper: convert 12h -> 24h
      function to24Hour(hour, ampm) {
        if (ampm === "pm" && hour < 12) return hour + 12;
        if (ampm === "am" && hour === 12) return 0;
        return hour;
      }

      // ✅ Helper: zero-pad
      function pad(num) {
        return String(num).padStart(2, "0");
      }

      // ✅ Convert start/end to total seconds
      let startSeconds, endSeconds;

      if (clock_format == 12) {
        if (!s_ampm || !e_ampm) {
          return { status: "error", message: "Please! Check Your Input" };
        }
        startSeconds = to24Hour(s_hour, s_ampm) * 3600 + s_min * 60 + s_sec;
        endSeconds = to24Hour(e_hour, e_ampm) * 3600 + e_min * 60 + e_sec;
      } else {
        startSeconds = s_hour * 3600 + s_min * 60 + s_sec;
        endSeconds = e_hour * 3600 + e_min * 60 + e_sec;
      }

      // ✅ Calculate differences
      let diffSeconds = endSeconds - startSeconds;
      let absDiff = Math.abs(diffSeconds);

      let h = Math.floor(absDiff / 3600);
      let m = Math.floor((absDiff % 3600) / 60);
      let s = Math.floor(absDiff % 60);

      // ✅ Laravel format ke according values set karein
      let tech_first_to_second,
        tech_first_to_second_over_night,
        tech_second_to_first,
        tech_second_to_first_over_night;

      if (diffSeconds >= 0) {
        // Normal case
        tech_first_to_second = `${pad(h)}:${pad(m)}:${pad(s)}`; // "05:00:00"
        tech_first_to_second_over_night = `${pad(h + 24)}:${pad(m)}:${pad(s)}`; // "29:00:00"
        tech_second_to_first = `-${pad(h)}:${pad(m)}:${pad(s)}`; // "-05:00:00"
        tech_second_to_first_over_night = `${pad(24 - h)}:${pad(m)}:${pad(s)}`; // "19:00:00"
      } else {
        // Reverse case
        tech_first_to_second = `-${pad(h)}:${pad(m)}:${pad(s)}`; // "-05:00:00"
        tech_first_to_second_over_night = `${pad(24 - h)}:${pad(m)}:${pad(s)}`; // "19:00:00"
        tech_second_to_first = `${pad(h)}:${pad(m)}:${pad(s)}`; // "05:00:00"
        tech_second_to_first_over_night = `${pad(h + 24)}:${pad(m)}:${pad(s)}`; // "29:00:00"
      }

      // ✅ Final result exactly matching Laravel format
      return {
        status: "success",
        payload: {
          tech_first_to_second: tech_first_to_second,
          tech_first_to_second_over_night: tech_first_to_second_over_night,
          tech_second_to_first: tech_second_to_first,
          tech_second_to_first_over_night: tech_second_to_first_over_night,
        },
      };
    } catch (error) {
      return { status: "error", message: error.message };
    }
  }

  /**
   * getCalculationTimeCalculator: Service Method
   * POST: /api/calculators-lol/time-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTimeCalculator(body) {
    const locale = body.locale || "en";
    let submitt;
    if (locale === "en") {
      return handleEnglishLocale(body);
    } else {
      return handleUrduLocale(body);
    }

    function handleEnglishLocale(body) {
      const submitt = body.tech_sim_adv;

      if (submitt === "time_first") {
        return calculateTimeAddSubtract(body);
      } else if (submitt === "time_second") {
        return calculateDateTimeAddSubtract(body);
      } else if (submitt === "time_third") {
        return calculateTimeExpression(body);
      } else {
        return { error: "please check your input" };
      }
    }

    function calculateTimeAddSubtract(body) {
      let t_days = body.tech_t_days;
      let t_hours = body.tech_t_hours;
      let t_min = body.tech_t_min;
      let t_sec = body.tech_t_sec;
      let t_method = body.tech_t_method;
      let te_days = body.tech_te_days;
      let te_hours = body.tech_te_hours;
      let te_min = body.tech_te_min;
      let te_sec = body.tech_te_sec;

      // Validation for time 1
      if (!t_days && !t_hours && !t_min && !t_sec) {
        return { error: "Please enter any input at time 1" };
      }

      // Set defaults
      t_days = t_days || 0;
      t_hours = t_hours || 0;
      t_min = t_min || 0;
      t_sec = t_sec || 0;

      // Validation for time 2
      if (!te_days && !te_hours && !te_min && !te_sec) {
        return { error: "Please enter any input at time 2" };
      }

      te_days = te_days || 0;
      te_hours = te_hours || 0;
      te_min = te_min || 0;
      te_sec = te_sec || 0;

      let seconds, min, hour, days, method;

      if (t_method === "plus") {
        seconds = parseInt(t_sec) + parseInt(te_sec);
        min = parseInt(t_min) + parseInt(te_min);
        hour = parseInt(t_hours) + parseInt(te_hours);
        days = parseInt(t_days) + parseInt(te_days);

        while (seconds >= 60) {
          min += 1;
          seconds -= 60;
        }
        while (min >= 60) {
          hour += 1;
          min -= 60;
        }
        while (hour >= 24) {
          days += 1;
          hour -= 24;
        }
        method = "+";
      } else {
        t_days = parseInt(t_days);
        t_hours = parseInt(t_hours);
        t_min = parseInt(t_min);
        t_sec = parseInt(t_sec);
        te_days = parseInt(te_days);
        te_hours = parseInt(te_hours);
        te_min = parseInt(te_min);
        te_sec = parseInt(te_sec);

        if (t_days > te_days) {
          if (te_sec > t_sec) {
            t_sec += 60;
            t_min -= 1;
          }
          if (te_min > t_min) {
            t_min += 60;
            t_hours -= 1;
          }
          if (te_hours > t_hours) {
            t_hours += 24;
            t_days -= 1;
          }
        }

        seconds = t_sec - te_sec;
        min = t_min - te_min;
        hour = t_hours - te_hours;
        days = t_days - te_days;

        while (seconds >= 60) {
          min += 1;
          seconds -= 60;
        }
        while (min >= 60) {
          hour += 1;
          min -= 60;
        }
        while (hour >= 24) {
          days += 1;
          hour -= 24;
        }
        method = "-";
      }

      let totalDays = min + seconds / 60;
      totalDays = hour + totalDays / 60;
      totalDays = days + totalDays / 24;

      const totalHours = totalDays * 24;
      const totalMin = totalDays * 24 * 60;
      const totalSec = totalDays * 24 * 60 * 60;

      return {
        tech_submitt: submitt,
        tech_t_method: method,
        tech_t_sec: parseInt(body.t_sec) || 0,
        tech_t_min: parseInt(body.t_min) || 0,
        tech_t_hours: parseInt(body.t_hours) || 0,
        tech_t_days: parseInt(body.t_days) || 0,
        tech_te_sec: parseInt(body.te_sec) || 0,
        tech_te_min: parseInt(body.te_min) || 0,
        tech_te_hours: parseInt(body.te_hours) || 0,
        tech_te_days: parseInt(body.te_days) || 0,
        tech_totalDays: totalDays,
        tech_totalHours: totalHours,
        tech_totalMin: totalMin,
        tech_totalSec: totalSec,
        tech_seconds: seconds,
        tech_min: min,
        tech_hour: hour,
        tech_days: days,
      };
    }

    function calculateDateTimeAddSubtract(body) {
      let td_date = body.tech_td_date;
      let t_hours = body.tech_t_hours;
      let t_min = body.tech_t_min;
      let t_sec = body.tech_t_sec;
      let td_method = body.tech_td_method;
      let td_days = body.tech_td_days;
      let td_hours = body.tech_td_hours;
      let td_min = body.tech_td_min;
      let td_sec = body.tech_td_sec;
      let am_pm = body.tech_am_pm;

      if (!isNumeric(t_hours) || !isNumeric(t_min) || !isNumeric(t_sec)) {
        return { error: "Please provide a valid start time." };
      }

      if (!td_date) {
        return { error: "Please! Enter Start Date." };
      }

      // Default values
      const addSec = parseInt(td_sec) || 0;
      const addMin = parseInt(td_min) || 0;
      const addHours = parseInt(td_hours) || 0;
      const addDays = parseInt(td_days) || 0;

      // Time string banao - t_hours, t_min, t_sec se (NOT ts_hours!)
      let time;
      if (am_pm == "am" || am_pm == "pm") {
        time = `${t_hours}:${t_min}:${t_sec} ${am_pm}`;
      } else {
        time = `${t_hours}:${t_min}:${t_sec}`;
      }

      const date = td_date;
      const dateTime = date;

      // Method set karo
      let method;
      if (td_method == "plus") {
        method = "add";
      } else {
        method = "subtract";
      }

      // Laravel format: strtotime("$dateTime $time ...")
      let resDate = moment(`${dateTime} ${time}`, "YYYY-MM-DD h:m:s A");

      // Add/Subtract in exact Laravel sequence
      resDate = resDate[method](addDays, "days");
      resDate = resDate[method](addHours, "hours");
      resDate = resDate[method](addMin, "minutes");
      resDate = resDate[method](addSec, "seconds");

      // Format output
      const finalDate = resDate.format("MMMM, DD, YYYY");
      const resDay = resDate.format("dddd");
      let resTime = resDate.format("hh:mm:ss A");

      if (am_pm == "24") {
        resTime = resDate.format("HH:mm:ss");
      }

      return {
        tech_finalDate: finalDate,
        tech_resTime: resTime,
        tech_resDay: resDay,
      };
    }

    function calculateTimeExpression(body) {
      let input = body.tech_input;

      if (!input) {
        return { error: "please check your input" };
      }

      const components = input.split(/\s*([\+\-\*\/])\s*/);
      let totalDuration = 0; // Total duration in seconds

      for (let i = 0; i < components.length; i++) {
        const part = components[i];

        if (i % 2 === 0) {
          const matches = [...part.matchAll(/(\d+)([dhms])/g)];
          let duration = 0;

          for (const match of matches) {
            const value = parseInt(match[1]);
            const unit = match[2];

            switch (unit) {
              case "d":
                duration += value * 86400;
                break;
              case "h":
                duration += value * 3600;
                break;
              case "m":
                duration += value * 60;
                break;
              case "s":
                duration += value;
                break;
            }
          }

          if (i === 0 || components[i - 1] === "+") {
            totalDuration += duration;
          } else if (components[i - 1] === "-") {
            totalDuration -= duration;
          } else if (components[i - 1] === "*" || components[i - 1] === "/") {
            return { error: "please check your input" };
          }
        }
      }

      const days = Math.floor(totalDuration / 86400);
      const hours = Math.floor((totalDuration % 86400) / 3600);
      const minutes = Math.floor((totalDuration % 3600) / 60);
      const seconds = totalDuration % 60;

      const totleresult = `${days}d ${hours}h ${minutes}m ${seconds}s`;
      const secondsResult = totalDuration;
      const mintsResult = totalDuration / 60;
      const hoursResult = totalDuration / 3600;
      const daysResult = totalDuration / 86400;

      return {
        tech_totleresult: totleresult,
        tech_days: days,
        tech_hours: hours,
        tech_minutes: minutes,
        tech_seconds: seconds,
        tech_secondsResult: secondsResult,
        tech_mintsResult: mintsResult,
        tech_hoursResult: hoursResult,
        tech_daysResult: daysResult,
      };
    }

    function handleUrduLocale(body) {
      const time_type = body.tech_time_type;

      if (time_type == "1") {
        return calculateTimeAddSubtractUrdu(body);
      } else if (time_type == "2") {
        return calculateTimeDifference(body);
      } else if (time_type == "3") {
        return calculateDateTimeFromStart(body);
      } else if (time_type == "4") {
        return calculateDateTimeDifference(body);
      }

      return { error: "Invalid time_type" };
    }

    function calculateTimeAddSubtractUrdu(body) {
      let t_days = body.tech_t_days;
      let t_hours = body.tech_t_hours;
      let t_min = body.tech_t_min;
      let t_sec = body.tech_t_sec;
      let t_method = body.tech_t_method;

      let te_days = body.tech_te_days;
      let te_hours = body.tech_te_hours;
      let te_min = body.tech_te_min;
      let te_sec = body.tech_te_sec;

      // Convert to arrays if not already
      te_sec = Array.isArray(te_sec) ? te_sec : [te_sec];
      te_min = Array.isArray(te_min) ? te_min : [te_min];
      te_hours = Array.isArray(te_hours) ? te_hours : [te_hours];
      te_days = Array.isArray(te_days) ? te_days : [te_days];

      // Validation
      if (!t_days && !t_hours && !t_min && !t_sec) {
        return { error: "Please enter any input at time 1" };
      }

      t_days = t_days || 0;
      t_hours = t_hours || 0;
      t_min = t_min || 0;
      t_sec = t_sec || 0;

      if (
        !te_days.length &&
        !te_hours.length &&
        !te_min.length &&
        !te_sec.length
      ) {
        return { error: "Please enter any input at time 2" };
      }

      const sumArray = (arr) =>
        arr.reduce((a, b) => parseInt(a || 0) + parseInt(b || 0), 0);

      let seconds, min, hour, days, method;

      if (t_method === "plus") {
        seconds = parseInt(t_sec) + sumArray(te_sec);
        min = parseInt(t_min) + sumArray(te_min);
        hour = parseInt(t_hours) + sumArray(te_hours);
        days = parseInt(t_days) + sumArray(te_days);

        while (seconds >= 60) {
          min += 1;
          seconds -= 60;
        }
        while (min >= 60) {
          hour += 1;
          min -= 60;
        }
        while (hour >= 24) {
          days += 1;
          hour -= 24;
        }
        method = "+";
      } else {
        t_days = parseInt(t_days);
        t_hours = parseInt(t_hours);
        t_min = parseInt(t_min);
        t_sec = parseInt(t_sec);

        const te_days_sum = sumArray(te_days);
        const te_hours_sum = sumArray(te_hours);
        const te_min_sum = sumArray(te_min);
        const te_sec_sum = sumArray(te_sec);

        if (t_days > te_days_sum) {
          if (te_sec_sum > t_sec) {
            t_sec += 60;
            t_min -= 1;
          }
          if (te_min_sum > t_min) {
            t_min += 60;
            t_hours -= 1;
          }
          if (te_hours_sum > t_hours) {
            t_hours += 24;
            t_days -= 1;
          }
        }

        seconds = t_sec - te_sec_sum;
        min = t_min - te_min_sum;
        hour = t_hours - te_hours_sum;
        days = t_days - te_days_sum;

        while (seconds >= 60) {
          min += 1;
          seconds -= 60;
        }
        while (min >= 60) {
          hour += 1;
          min -= 60;
        }
        while (hour >= 24) {
          days += 1;
          hour -= 24;
        }
        method = "-";
      }

      let totalDays = min + seconds / 60;
      totalDays = hour + totalDays / 60;
      totalDays = days + totalDays / 24;

      const totalHours = totalDays * 24;
      const totalMin = totalDays * 24 * 60;
      const totalSec = totalDays * 24 * 60 * 60;

      return {
        tech_t_method: method,
        tech_t_sec: parseInt(body.tech_t_sec) || 0,
        tech_t_min: parseInt(body.tech_t_min) || 0,
        tech_t_hours: parseInt(body.tech_t_hours) || 0,
        tech_t_days: parseInt(body.tech_t_days) || 0,
        tech_te_sec: te_sec,
        tech_te_min: te_min,
        tech_te_hours: te_hours,
        tech_te_days: te_days,
        tech_totalDays: totalDays,
        tech_totalHours: totalHours,
        tech_totalMin: totalMin,
        tech_totalSec: totalSec,
        tech_seconds: seconds,
        tech_min: min,
        tech_hour: hour,
        tech_days: days,
      };
    }

    function calculateTimeDifference(body) {
      let startTime = body.tech_s_time;
      let endTime = body.tech_e_time;

      if (!startTime || !endTime) {
        return { error: "Please Add Both Time." };
      }

      const start = moment(startTime, "HH:mm:ss");
      let end = moment(endTime, "HH:mm:ss");

      if (end.isBefore(start)) {
        end.add(1, "day");
      }

      const duration = moment.duration(end.diff(start));

      return {
        tech_hours: duration.hours(),
        tech_minutes: duration.minutes(),
        tech_seconds: duration.seconds(),
      };
    }

    function calculateDateTimeFromStart(body) {
      let s_date = body.tech_s_date;
      let et_time = body.tech_et_time;
      let st_days = body.tech_st_days;
      let st_hours = body.tech_st_hours;
      let st_min = body.tech_st_min;
      let st_sec = body.tech_st_sec;
      let td_method = body.tech_td_method;

      if (!s_date || !et_time) {
        return { error: "Please Enter Time." };
      }

      const days = st_days || 0;
      const hours = st_hours || 0;
      const minutes = st_min || 0;
      const seconds = st_sec || 0;

      if (
        !isNumeric(days) ||
        !isNumeric(hours) ||
        !isNumeric(minutes) ||
        !isNumeric(seconds)
      ) {
        return { error: "Please Fill all the Input Fields." };
      }

      let startDateTime = moment(`${s_date} ${et_time}`);

      if (td_method === "plus") {
        startDateTime
          .add(days, "days")
          .add(hours, "hours")
          .add(minutes, "minutes")
          .add(seconds, "seconds");
      } else {
        startDateTime
          .subtract(days, "days")
          .subtract(hours, "hours")
          .subtract(minutes, "minutes")
          .subtract(seconds, "seconds");
      }

      return {
        tech_formattedDate: startDateTime.format("YYYY-MM-DD"),
        tech_formattedTime: startDateTime.format("hh:mm:ss A"),
      };
    }

    function calculateDateTimeDifference(body) {
      let fs_date = body.tech_fs_date;
      let ft_time = body.tech_ft_time;
      let fe_date = body.tech_fe_date;
      let fe_time = body.tech_fe_time;

      if (!fs_date || !ft_time || !fe_date || !fe_time) {
        return { error: "Please Fill all the Fields." };
      }

      const startDateTime = moment(`${fs_date} ${ft_time}`);
      const endDateTime = moment(`${fe_date} ${fe_time}`);

      const duration = moment.duration(endDateTime.diff(startDateTime));

      return {
        tech_days: Math.floor(duration.asDays()),
        tech_hours: duration.hours(),
        tech_minutes: duration.minutes(),
        tech_seconds: duration.seconds(),
      };
    }
    function isNumeric(value) {
      return !isNaN(parseFloat(value)) && isFinite(value);
    }
  }

  /**
   * getCalculationDateCalculator: Service Method
   * POST: /api/calculators-lol/date-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    
  async getCalculationDateCalculator(body) {
    try {
      let dateTypes = body.dateTypes;
      // Date Duration fields
      let s_date_duration = body.s_date_duration;
      let e_date_duration = body.e_date_duration;
      let checkbox_duration = body.checkbox_duration;
      // Date Calculator fields
      let add_date_date = body.add_date_date;
      let date_method = body.date_method;
      let date_years = body.date_years;
      let date_months = body.date_months;
      let date_weeks = body.date_weeks;
      let date_days = body.date_days;
      let repeat = body.repeat;
      let add_hrs_f = body.add_hrs_f;
      let add_min_f = body.add_min_f;
      let add_sec_f = body.add_sec_f;
      let add_hrs_s = body.add_hrs_s;
      let add_min_s = body.add_min_s;
      let add_sec_s = body.add_sec_s;
      // Simple/Advanced fields
      let sim_adv = body.sim_adv;
      let s_date = body.s_date;
      let e_date = body.e_date;
      let add_date = body.add_date;
      let method = body.method;
      let years = body.years;
      let months = body.months;
      let weeks = body.weeks;
      let days = body.days;
      let end_inc = body.end_inc;
      let sat_inc = body.sat_inc;
      let holiday_c = body.holiday_c;
      let weekend_c = body.weekend_c;
      let cal_bus = body.cal_bus;
      let ex_in = body.ex_in;
      let satting = body.satting;
      // Weekday checkboxes
      let sun = body.sun;
      let mon = body.mon;
      let tue = body.tue;
      let wed = body.wed;
      let thu = body.thu;
      let fri = body.fri;
      let sat = body.sat;
      // Holiday checkboxes
      let nyd = body.nyd;
      let ind = body.ind;
      let vetd = body.vetd;
      let cheve = body.cheve;
      let chirs = body.chirs;
      let nye = body.nye;
      let mlkd = body.mlkd;
      let psd = body.psd;
      let memd = body.memd;
      let labd = body.labd;
      let cold = body.cold;
      let thankd = body.thankd;
      let blkf = body.blkf;
      // Custom holidays
      let total_i = body.total_i;
      let total_j = body.total_j;
      let d = body.d;
      let m = body.m;
      let n = body.n;

      const locale = body.locale || "en";

      if (locale !== "en") {
        // Date Duration Calculation
        if (dateTypes === "date_duration") {
          return this.calculateDateDuration({
            s_date_duration,
            e_date_duration,
            checkbox_duration,
          });
        }

        // Date Calculator
        else if (dateTypes === "date_calculator") {
          return this.calculateDateWithTime({
            add_date: add_date_date,
            method: date_method,
            years: date_years,
            months: date_months,
            weeks: date_weeks,
            days: date_days,
            repeat: repeat,
            add_hrs_f: add_hrs_f,
            add_min_f: add_min_f,
            add_sec_f: add_sec_f,
            add_hrs_s: add_hrs_s,
            add_min_s: add_min_s,
            add_sec_s: add_sec_s,
          });
        }

        // Simple/Advanced Calculator
        else {
          if (sim_adv === "simple") {
            return this.calculateSimpleDate({
              s_date: s_date,
              e_date: e_date,
              end_inc: end_inc,
              sat_inc: sat_inc,
              holiday_c: holiday_c,
              ex_in: ex_in,
              satting: satting,
              sun: sun,
              mon: mon,
              tue: tue,
              wed: wed,
              thu: thu,
              fri: fri,
              sat: sat,
              nyd: nyd,
              ind: ind,
              vetd: vetd,
              cheve: cheve,
              chirs: chirs,
              nye: nye,
              mlkd: mlkd,
              psd: psd,
              memd: memd,
              labd: labd,
              cold: cold,
              thankd: thankd,
              blkf: blkf,
              total_i: total_i,
              total_j: total_j,
              d: d,
              m: m,
              n: n,
            });
          } else if (cal_bus) {
            return this.calculateBusinessDays({
              add_date: add_date,
              days: days,
              method: method,
              weekend_c: weekend_c,
              nyd: nyd,
              ind: ind,
              vetd: vetd,
              cheve: cheve,
              chirs: chirs,
              nye: nye,
              mlkd: mlkd,
              psd: psd,
              memd: memd,
              labd: labd,
              cold: cold,
              thankd: thankd,
              blkf: blkf,
              total_j: total_j,
              d: d,
              m: m,
              n: n,
            });
          } else if (sim_adv === "advance") {
            return this.calculateAdvancedDate({
              add_date: add_date,
              method: method,
              years: years,
              months: months,
              weeks: weeks,
              days: days,
            });
          }
        }
      } else {
        // English locale - Date Calculator
        return this.calculateDateWithTime({
          add_date: add_date,
          method: method,
          years: years,
          months: months,
          weeks: weeks,
          days: days,
          repeat: repeat,
          add_hrs_f: add_hrs_f,
          add_min_f: add_min_f,
          add_sec_f: add_sec_f,
          add_hrs_s: add_hrs_s,
          add_min_s: add_min_s,
          add_sec_s: add_sec_s,
        });
      }

      return { error: "Invalid request" };
    } catch (error) {
      console.error("Date Calculator Error:", error);
      return { error: "An error occurred during calculation" };
    }
  }
  // Date Duration Calculation
  calculateDateDuration({
    s_date_duration,
    e_date_duration,
    checkbox_duration,
  }) {
    if (!s_date_duration || !e_date_duration) {
      return { error: "Please! Check Your Input.1111" };
    }

    let startDate = s_date_duration;
    let endDate = e_date_duration;

    if (checkbox_duration) {
      endDate = moment(e_date_duration).add(1, "day").format("YYYY-MM-DD");
    }

    const start = moment(startDate);
    const end = moment(endDate);

    const duration = moment.duration(end.diff(start));

    const years = duration.years();
    const months = duration.months();
    const days = duration.days();
    const hours = duration.hours();
    const minutes = duration.minutes();
    const seconds = duration.seconds();

    return {
      RESULT: 1,
      from: start.format("MMM DD, YYYY"),
      to: end.format("MMM DD, YYYY"),
      years: years,
      months: months,
      days: days,
      hours: hours,
      minutes: minutes,
      seconds: seconds,
    };
  }
  // Date Calculator with Time
  calculateDateWithTime({
    add_date,
    method,
    years = 0,
    months = 0,
    weeks = 0,
    days = 0,
    repeat = 1,
    add_hrs_f = 0,
    add_min_f = 0,
    add_sec_f = 0,
    add_hrs_s = 0,
    add_min_s = 0,
    add_sec_s = 0,
  }) {
    if (!add_date || !method) {
      return { error: "Please! Check Your Input." };
    }

    const hasTime =
      add_hrs_f ||
      add_min_f ||
      add_sec_f ||
      add_hrs_s ||
      add_min_s ||
      add_sec_s;

    // Initialize base date with time if provided
    let baseDate = moment(add_date);

    if (hasTime) {
      baseDate
        .hour(parseInt(add_hrs_f) || 0)
        .minute(parseInt(add_min_f) || 0)
        .second(parseInt(add_sec_f) || 0);
    }

    const fromDate = baseDate.format(
      hasTime ? "dddd, MMM DD, YYYY hh:mm:ss A" : "dddd, MMM DD, YYYY"
    );
    const results = [];

    // Clone base date for iterations
    let currentDate = baseDate.clone();

    for (let i = 0; i < repeat; i++) {
      if (method === "add") {
        currentDate.add({
          years: parseInt(years) || 0,
          months: parseInt(months) || 0,
          weeks: parseInt(weeks) || 0,
          days: parseInt(days) || 0,
          hours: parseInt(add_hrs_s) || 0,
          minutes: parseInt(add_min_s) || 0,
          seconds: parseInt(add_sec_s) || 0,
        });
      } else {
        currentDate.subtract({
          years: parseInt(years) || 0,
          months: parseInt(months) || 0,
          weeks: parseInt(weeks) || 0,
          days: parseInt(days) || 0,
          hours: parseInt(add_hrs_s) || 0,
          minutes: parseInt(add_min_s) || 0,
          seconds: parseInt(add_sec_s) || 0,
        });
      }

      // Clone current date to avoid mutation issues
      results.push(
        currentDate
          .clone()
          .format(
            hasTime ? "dddd, MMM DD, YYYY hh:mm:ss A" : "dddd, MMM DD, YYYY"
          )
      );
    }

    return {
      RESULT: 1,
      from: fromDate,
      method: method,
      years: String(years).padStart(2, "0"),
      months: String(months).padStart(2, "0"),
      weeks: String(weeks).padStart(2, "0"),
      days: String(days).padStart(2, "0"),
      ans: results,
      repeat: String(repeat),
      ...(hasTime && {
        add_hrs_f: String(add_hrs_f).padStart(2, "0"),
        add_min_f: String(add_min_f).padStart(2, "0"),
        add_sec_f: String(add_sec_f).padStart(2, "0"),
        add_hrs_s: String(add_hrs_s).padStart(2, "0"),
        add_min_s: String(add_min_s).padStart(2, "0"),
        add_sec_s: String(add_sec_s).padStart(2, "0"),
      }),
    };
  }
  // Simple Date Calculation (with workdays/holidays)
  calculateSimpleDate(params) {
    // const { s_date, e_date, end_inc } = params;
    let s_date = params.s_date;
    let e_date = params.e_date;
    let end_inc = params.end_inc;

    if (!s_date || !e_date) {
      return { error: "Please enter start and end date" };
    }

    let startDate = moment(s_date);
    let endDate = moment(e_date);

    if (end_inc) {
      endDate.add(1, "day");
    }

    const workdaysData = this.getWorkdays(startDate, endDate, params);

    const duration = moment.duration(endDate.diff(startDate));

    return {
      from: startDate.format("MMM DD, YYYY"),
      to: endDate.format("MMM DD, YYYY"),
      count_days: "active",
      years: duration.years(),
      months: duration.months(),
      days: duration.days(),
      hours: duration.hours(),
      minutes: duration.minutes(),
      seconds: duration.seconds(),
      getworkdays: workdaysData,
      t_days:
        workdaysData.workdays + workdaysData.weekend + workdaysData.holidays,
      ...workdaysData.extraData,
    };
  }

  // Business Days Calculator
  calculateBusinessDays(params) {
    // const { add_date, days, method, weekend_c } = params;
    let add_date = params.add_date;
    let days = params.days;
    let method = params.method;
    let weekend_c = params.weekend_c;

    if (!isNaN(days) && add_date) {
      let date = moment(add_date);
      let businessDays = parseInt(days);
      let weekends = 0;
      let holidays = 0;

      if (weekend_c === "no") {
        // Skip weekends
        const direction = method === "+" ? 1 : -1;
        let count = 0;

        while (count < businessDays) {
          date.add(direction, "days");
          const dayOfWeek = date.day();

          if (dayOfWeek === 0 || dayOfWeek === 6) {
            weekends++;
          } else {
            count++;
          }
        }
      } else {
        // Include holidays logic here
        const holidaysList = this.getHolidaysList(params, date.year());
        // Implementation similar to PHP version
      }

      return {
        from: moment(add_date).format("dddd, MMM DD, YYYY"),
        from_s: moment(add_date).format("MMM DD, YYYY"),
        date: date.format("dddd, MMM DD, YYYY"),
        date_e: date.format("MMM DD, YYYY"),
        holidays: holidays,
        weekends: weekends,
      };
    }

    return { error: "Please Check Your Input" };
  }

  // Advanced Date Calculation
  calculateAdvancedDate({
    add_date,
    method,
    years = 0,
    months = 0,
    weeks = 0,
    days = 0,
  }) {
    if (!isNaN(years) || !isNaN(months) || !isNaN(weeks) || !isNaN(days)) {
      const date = moment(add_date);
      const operation = method === "+" ? "add" : "subtract";

      date[operation]({
        years: parseInt(years) || 0,
        months: parseInt(months) || 0,
        weeks: parseInt(weeks) || 0,
        days: parseInt(days) || 0,
      });

      const description = `${
        method === "+" ? "Added" : "Subtracted"
      } ${years} years, ${months} months, ${weeks} weeks, ${days} days`;

      return {
        from: moment(add_date).format("dddd, MMM DD, YYYY"),
        from_s: moment(add_date).format("MMM DD, YYYY"),
        add_days: "active",
        date: date.format("dddd, MMM DD, YYYY"),
        des: description,
      };
    }

    return { error: "Please Check Your Input" };
  }

  // Get Workdays Helper
  getWorkdays(startDate, endDate, params) {
    // const { sat_inc, holiday_c } = params;
    let sat_inc = params.sat_inc;
    let holiday_c = params.holiday_c;

    let workdays = 0;
    let weekend = 0;
    let holidays = 0;
    const holidayDates = [];

    if (holiday_c === "yes") {
      // Build holiday list
      const holidaysList = this.getHolidaysList(
        params,
        startDate.year(),
        endDate.year()
      );

      // Count days
      let current = startDate.clone();
      while (current.isSameOrBefore(endDate)) {
        const dayOfWeek = current.day();
        const isWeekend = dayOfWeek === 0 || (dayOfWeek === 6 && !sat_inc);
        const isHoliday = holidaysList.some((h) =>
          current.isSame(h.date, "day")
        );

        if (isWeekend) {
          weekend++;
        } else if (isHoliday) {
          holidays++;
          holidayDates.push(current.format("dddd, MMM DD, YYYY"));
        } else {
          workdays++;
        }

        current.add(1, "day");
      }
    } else {
      // Simple calculation without holidays
      let current = startDate.clone();
      while (current.isSameOrBefore(endDate)) {
        const dayOfWeek = current.day();
        const isWeekend = dayOfWeek === 0 || (dayOfWeek === 6 && !sat_inc);

        if (isWeekend) {
          weekend++;
        } else {
          workdays++;
        }

        current.add(1, "day");
      }
    }

    return {
      workdays: workdays,
      weekend: weekend,
      holidays: holidays,
      get_holi: holidayDates,
      extraData: {},
    };
  }

  // Get Holidays List
  getHolidaysList(params, startYear, endYear = startYear) {
    const holidays = [];
    // const { nyd, ind, vetd, cheve, chirs, nye, mlkd, psd, memd, labd, cold, thankd, blkf } = params;
    let nyd = params.nyd;
    let ind = params.ind;
    let vetd = params.vetd;
    let cheve = params.cheve;
    let chirs = params.chirs;
    let nye = params.nye;
    let mlkd = params.mlkd;
    let psd = params.psd;
    let memd = params.memd;
    let labd = params.labd;
    let cold = params.cold;
    let thankd = params.thankd;
    let blkf = params.blkf;

    for (let year = startYear; year <= endYear; year++) {
      // Fixed date holidays
      if (nyd)
        holidays.push({
          date: moment(`${year}-01-01`),
          name: "New Year's Day",
        });
      if (ind)
        holidays.push({
          date: moment(`${year}-07-04`),
          name: "Independence Day",
        });
      if (vetd)
        holidays.push({ date: moment(`${year}-11-11`), name: "Veteran's Day" });
      if (cheve)
        holidays.push({ date: moment(`${year}-12-24`), name: "Christmas Eve" });
      if (chirs)
        holidays.push({ date: moment(`${year}-12-25`), name: "Christmas" });
      if (nye)
        holidays.push({
          date: moment(`${year}-12-31`),
          name: "New Year's Eve",
        });

      // Floating holidays
      if (mlkd)
        holidays.push({
          date: this.getNthWeekday(year, 0, 1, 3),
          name: "M. L. King Day",
        });
      if (psd)
        holidays.push({
          date: this.getNthWeekday(year, 1, 1, 3),
          name: "President's Day",
        });
      if (memd)
        holidays.push({
          date: this.getNthWeekday(year, 4, 1, -1),
          name: "Memorial Day",
        });
      if (labd)
        holidays.push({
          date: this.getNthWeekday(year, 8, 1, 1),
          name: "Labor Day",
        });
      if (cold)
        holidays.push({
          date: this.getNthWeekday(year, 9, 1, 2),
          name: "Columbus Day",
        });
      if (thankd)
        holidays.push({
          date: this.getNthWeekday(year, 10, 4, 4),
          name: "Thanksgiving",
        });
      if (blkf)
        holidays.push({
          date: this.getNthWeekday(year, 10, 5, 4),
          name: "Black Friday",
        });
    }

    return holidays;
  }

  // Get Nth Weekday of Month
  getNthWeekday(year, month, weekday, n) {
    // month: 0-11, weekday: 0-6 (0=Sunday), n: 1-5 or -1 for last
    const date = moment({ year, month, day: 1 });

    if (n === -1) {
      // Last occurrence
      date.endOf("month");
      while (date.day() !== weekday) {
        date.subtract(1, "day");
      }
    } else {
      // Nth occurrence
      let count = 0;
      while (count < n) {
        if (date.day() === weekday) count++;
        if (count < n) date.add(1, "day");
      }
    }

    return date;
  }
    /**
   * getCalculationHypergeometricCalculator: Service Method
   * POST: /api/calculators-lol/hypergeometric-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
      async getCalculationHypergeometricCalculator(body) {
        // const { p: N, sp: K, s: n, ss: k, method, inc, rep, fun } = body;
        let N = body.tech_p;
        let K = body.tech_sp;
        let n = body.tech_s;
        let k = body.tech_ss;
        let method = body.tech_method;
        let inc = body.tech_inc;
        let rep = body.tech_rep;
        let fun = body.tech_fun;
        const result = {};
        
        // Validate required fields
        if (!isNumeric(N) || !isNumeric(K) || !isNumeric(n) || !isNumeric(k)) {
          result.error = "Please fill All fields.";
          return result;
        }

        // Calculate mean, variance, and standard deviation
        const mean = parseFloat(((n * K) / N).toFixed(6));
        const variance = (n * (K / N) * ((N - K) / N) * ((N - n) / (N - 1)));
        const sd = parseFloat(Math.sqrt(variance).toFixed(6));

        // Validation checks
        if (n > N) {
          result.error = "(N) Must be Greater Than (n).";
          return result;
        }
        if (K > N) {
          result.error = "(N) Must be Greater Than (K).";
          return result;
        }
        if (k > n) {
          result.error = "(n) Must be Greater Than (k).";
          return result;
        }

        // Helper function to check if value is numeric
        function isNumeric(val) {
          return !isNaN(parseFloat(val)) && isFinite(val);
        }

        // Factorial function
        function factorial(n) {
          if (n <= 1) return 1;
          let fact = 1;
          for (let i = 2; i <= n; i++) {
            fact *= i;
          }
          return fact;
        }
        // Combinations function
        function combinations(n, k) {
          if (n < k) return 0;
          return Number(factorial(n) / (factorial(k) * factorial(n - k)));
        }

        // Method 1: Single calculations
        if (method == '1') {
          const first = combinations(K, k);
          const second = combinations(N - K, n - k);
          const third = combinations(N, n);
          const a = parseFloat(((first * second) / third).toFixed(6));

          let b = 0;
          for (let i = 0; i < k; i++) {
            const f = combinations(K, i);
            const s = combinations(N - K, n - i);
            const t = combinations(N, n);
            b += (f * s) / t;
          }

          let c = 0;
          for (let i = 0; i <= k; i++) {
            const f = combinations(K, i);
            const s = combinations(N - K, n - i);
            const t = combinations(N, n);
            c += (f * s) / t;
          }

          let d = 0;
          for (let i = n; i > k; i--) {
            const f = combinations(K, i);
            const s = combinations(N - K, n - i);
            const t = combinations(N, n);
            d += (f * s) / t;
          }

          let e = 0;
          for (let i = n; i >= k; i--) {
            const f = combinations(K, i);
            const s = combinations(N - K, n - i);
            const t = combinations(N, n);
            e += (f * s) / t;
          }

          result.tech_a = a;
          result.tech_mean = mean;
          result.tech_b = parseFloat(b.toFixed(6));
          result.tech_variance = parseFloat(variance.toFixed(6));
          result.tech_sd = sd;
          result.tech_c = parseFloat(c.toFixed(6));
          result.tech_d = parseFloat(d.toFixed(6));
          result.tech_e = parseFloat(e.toFixed(6));
          result.tech_method = 1;
          return result;
        } 
        // Method 2: Table generation
              else {
          if (!isNumeric(inc) || !isNumeric(rep) || rep > 20) {
            result.error = "Input Error";
            return result;
          }

          const increment = parseFloat(inc);
          const repetitions = parseInt(rep);
          let currentK = parseFloat(k);
          let table = '';
          let chart = '';
          let xval = '';
          // Function 1: Probability mass function
          if (fun == '1') {
            for (let i = 1; i <= repetitions; i++) {
              // Convert currentK to integer for combinations calculation
              const kInt = Math.round(currentK);
              const first = combinations(K, kInt);
              const second = combinations(N - K, n - kInt);
              const third = combinations(N, n);
              const a = (first * second) / third;
              chart += a + ',';
              xval += kInt + ',';
              table += `<tr><td class="py-2 border-b">${kInt}</td><td class="py-2 border-b">${a}</td><td class="py-2 border-b">${a * 100}%</td></tr>`;
              currentK += increment;
            }
          }

          // Function 2: Cumulative distribution (<=)
          if (fun == '2') {
            for (let j = 1; j <= repetitions; j++) {
              const kInt = Math.round(currentK);
              let a = 0;
              
              for (let i = 0; i <= kInt; i++) {
                const first = combinations(K, i);
                const second = combinations(N - K, n - i);
                const third = combinations(N, n);
                a += (first * second) / third;
              }
              
              chart += a + ',';
              xval += kInt + ',';
              table += `<tr><td class="py-2 border-b">${kInt}</td><td class="py-2 border-b">${a}</td><td class="py-2 border-b">${a * 100}%</td></tr>`;
              currentK += increment;
            }
          }

          // Function 3: Cumulative distribution (>=)
          if (fun == '3') {
            for (let j = 1; j < repetitions; j++) {
              const kInt = Math.round(currentK);
              let a = 0;
              
              for (let i = n; i >= kInt; i--) {
                const first = combinations(K, i);
                const second = combinations(N - K, n - i);
                const third = combinations(N, n);
                a += (first * second) / third;
              }
              
              chart += a + ',';
              xval += kInt + ',';
              table += `<tr><td class="py-2 border-b">${kInt}</td><td class="py-2 border-b">${a}</td><td class="py-2 border-b">${a * 100}%</td></tr>`;
              currentK += increment;
            }
          }

          result.tech_mean = mean;
          result.tech_sd = sd;
          result.tech_variance = parseFloat(variance.toFixed(6));
          result.tech_table = table;
          result.tech_chart = chart;
          result.tech_xval = xval;
          result.tech_method = 2;
          result.RESULT = 1;
          return result;
        }
      }


   /**
   * getCalculationZScoreCalculator: Service Method
   * POST: /api/calculators-lol/z-score-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
      async getCalculationZScoreCalculator(body) {
      const z_table = {
        '-4.0': { 9: 0.00002, 8: 0.00002, 7: 0.00002, 6: 0.00002, 5: 0.00003, 4: 0.00003, 3: 0.00003, 2: 0.00003, 1: 0.00003, 0: 0.00003 },
        '-3.9': { 9: 0.00003, 8: 0.00003, 7: 0.00004, 6: 0.00004, 5: 0.00004, 4: 0.00004, 3: 0.00004, 2: 0.00004, 1: 0.00005, 0: 0.00005 },
        '-3.8': { 9: 0.00005, 8: 0.00005, 7: 0.00005, 6: 0.00006, 5: 0.00006, 4: 0.00006, 3: 0.00006, 2: 0.00007, 1: 0.00007, 0: 0.00007 },
        '-3.7': { 9: 0.00008, 8: 0.00008, 7: 0.00008, 6: 0.00008, 5: 0.00009, 4: 0.00009, 3: 0.00010, 2: 0.00010, 1: 0.00010, 0: 0.00011 },
        '-3.6': { 9: 0.00011, 8: 0.00012, 7: 0.00012, 6: 0.00013, 5: 0.00013, 4: 0.00014, 3: 0.00014, 2: 0.00015, 1: 0.00015, 0: 0.00016 },
        '-3.5': { 9: 0.00017, 8: 0.00017, 7: 0.00018, 6: 0.00019, 5: 0.00019, 4: 0.00020, 3: 0.00021, 2: 0.00022, 1: 0.00022, 0: 0.00023 },
        '-3.4': { 9: 0.00024, 8: 0.00025, 7: 0.00026, 6: 0.00027, 5: 0.00028, 4: 0.00029, 3: 0.00030, 2: 0.00031, 1: 0.00032, 0: 0.00034 },
        '-3.3': { 9: 0.00035, 8: 0.00036, 7: 0.00038, 6: 0.00039, 5: 0.00040, 4: 0.00042, 3: 0.00043, 2: 0.00045, 1: 0.00047, 0: 0.00048 },
        '-3.2': { 9: 0.00050, 8: 0.00052, 7: 0.00054, 6: 0.00056, 5: 0.00058, 4: 0.00060, 3: 0.00062, 2: 0.00064, 1: 0.00066, 0: 0.00069 },
        '-3.1': { 9: 0.00071, 8: 0.00074, 7: 0.00076, 6: 0.00079, 5: 0.00082, 4: 0.00084, 3: 0.00087, 2: 0.00090, 1: 0.00094, 0: 0.00097 },
        '-3.0': { 9: 0.00100, 8: 0.00104, 7: 0.00107, 6: 0.00111, 5: 0.00114, 4: 0.00118, 3: 0.00122, 2: 0.00126, 1: 0.00131, 0: 0.00135 },
        '-2.9': { 9: 0.00139, 8: 0.00144, 7: 0.00149, 6: 0.00154, 5: 0.00159, 4: 0.00164, 3: 0.00169, 2: 0.00175, 1: 0.00181, 0: 0.00187 },
        '-2.8': { 9: 0.00193, 8: 0.00199, 7: 0.00205, 6: 0.00212, 5: 0.00219, 4: 0.00226, 3: 0.00233, 2: 0.00240, 1: 0.00248, 0: 0.00256 },
        '-2.7': { 9: 0.00264, 8: 0.00272, 7: 0.00280, 6: 0.00289, 5: 0.00298, 4: 0.00307, 3: 0.00317, 2: 0.00326, 1: 0.00336, 0: 0.00347 },
        '-2.6': { 9: 0.00357, 8: 0.00368, 7: 0.00379, 6: 0.00391, 5: 0.00402, 4: 0.00415, 3: 0.00427, 2: 0.00440, 1: 0.00453, 0: 0.00466 },
        '-2.5': { 9: 0.00480, 8: 0.00494, 7: 0.00508, 6: 0.00523, 5: 0.00539, 4: 0.00554, 3: 0.00570, 2: 0.00587, 1: 0.00604, 0: 0.00621 },
        '-2.4': { 9: 0.00639, 8: 0.00657, 7: 0.00676, 6: 0.00695, 5: 0.00714, 4: 0.00734, 3: 0.00755, 2: 0.00776, 1: 0.00798, 0: 0.00820 },
        '-2.3': { 9: 0.00842, 8: 0.00866, 7: 0.00889, 6: 0.00914, 5: 0.00939, 4: 0.00964, 3: 0.00990, 2: 0.01017, 1: 0.01044, 0: 0.01072 },
        '-2.2': { 9: 0.01101, 8: 0.01130, 7: 0.01160, 6: 0.01191, 5: 0.01222, 4: 0.01255, 3: 0.01287, 2: 0.01321, 1: 0.01355, 0: 0.01390 },
        '-2.1': { 9: 0.01426, 8: 0.01463, 7: 0.01500, 6: 0.01539, 5: 0.01578, 4: 0.01618, 3: 0.01659, 2: 0.01700, 1: 0.01743, 0: 0.01786 },
        '-2.0': { 9: 0.01831, 8: 0.01876, 7: 0.01923, 6: 0.01970, 5: 0.02018, 4: 0.02068, 3: 0.02118, 2: 0.02169, 1: 0.02222, 0: 0.02275 },
        '-1.9': { 9: 0.02330, 8: 0.02385, 7: 0.02442, 6: 0.02500, 5: 0.02559, 4: 0.02619, 3: 0.02680, 2: 0.02743, 1: 0.02807, 0: 0.02872 },
        '-1.8': { 9: 0.02938, 8: 0.03005, 7: 0.03074, 6: 0.03144, 5: 0.03216, 4: 0.03288, 3: 0.03362, 2: 0.03438, 1: 0.03515, 0: 0.03593 },
        '-1.7': { 9: 0.03673, 8: 0.03754, 7: 0.03836, 6: 0.03920, 5: 0.04006, 4: 0.04093, 3: 0.04182, 2: 0.04272, 1: 0.04363, 0: 0.04457 },
        '-1.6': { 9: 0.04551, 8: 0.04648, 7: 0.04746, 6: 0.04846, 5: 0.04947, 4: 0.05050, 3: 0.05155, 2: 0.05262, 1: 0.05370, 0: 0.05480 },
        '-1.5': { 9: 0.0559, 8: 0.0571, 7: 0.0582, 6: 0.0594, 5: 0.0606, 4: 0.0618, 3: 0.0630, 2: 0.0643, 1: 0.0655, 0: 0.0668 },
        '-1.4': { 9: 0.0681, 8: 0.0694, 7: 0.0708, 6: 0.0721, 5: 0.0735, 4: 0.0749, 3: 0.0764, 2: 0.0778, 1: 0.0793, 0: 0.0808 },
        '-1.3': { 9: 0.0823, 8: 0.0838, 7: 0.0853, 6: 0.0869, 5: 0.0885, 4: 0.0901, 3: 0.0918, 2: 0.0934, 1: 0.0951, 0: 0.0968 },
        '-1.2': { 9: 0.0985, 8: 0.1003, 7: 0.1020, 6: 0.1038, 5: 0.1056, 4: 0.1075, 3: 0.1093, 2: 0.1112, 1: 0.1131, 0: 0.1151 },
        '-1.1': { 9: 0.1170, 8: 0.1190, 7: 0.1210, 6: 0.1230, 5: 0.1251, 4: 0.1271, 3: 0.1292, 2: 0.1314, 1: 0.1335, 0: 0.1357 },
        '-1.0': { 9: 0.1379, 8: 0.1401, 7: 0.1423, 6: 0.1446, 5: 0.1469, 4: 0.1492, 3: 0.1515, 2: 0.1539, 1: 0.1562, 0: 0.1587 },
        '-0.9': { 9: 0.1611, 8: 0.1635, 7: 0.1660, 6: 0.1685, 5: 0.1711, 4: 0.1736, 3: 0.1762, 2: 0.1788, 1: 0.1814, 0: 0.1841 },
        '-0.8': { 9: 0.1867, 8: 0.1894, 7: 0.1922, 6: 0.1949, 5: 0.1977, 4: 0.2005, 3: 0.2033, 2: 0.2061, 1: 0.2090, 0: 0.2119 },
        '-0.7': { 9: 0.2148, 8: 0.2177, 7: 0.2206, 6: 0.2236, 5: 0.2266, 4: 0.2296, 3: 0.2327, 2: 0.2358, 1: 0.2389, 0: 0.2420 },
        '-0.6': { 9: 0.2451, 8: 0.2483, 7: 0.2514, 6: 0.2546, 5: 0.2578, 4: 0.2611, 3: 0.2643, 2: 0.2676, 1: 0.2709, 0: 0.2743 },
        '-0.5': { 9: 0.2776, 8: 0.2810, 7: 0.2843, 6: 0.2877, 5: 0.2912, 4: 0.2946, 3: 0.2981, 2: 0.3015, 1: 0.3050, 0: 0.3085 },
        '-0.4': { 9: 0.3121, 8: 0.3156, 7: 0.3192, 6: 0.3228, 5: 0.3264, 4: 0.3300, 3: 0.3336, 2: 0.3372, 1: 0.3409, 0: 0.3446 },
        '-0.3': { 9: 0.3483, 8: 0.3520, 7: 0.3557, 6: 0.3594, 5: 0.3632, 4: 0.3669, 3: 0.3707, 2: 0.3745, 1: 0.3783, 0: 0.3821 },
        '-0.2': { 9: 0.3829, 8: 0.3897, 7: 0.3936, 6: 0.3974, 5: 0.4013, 4: 0.4052, 3: 0.4090, 2: 0.4129, 1: 0.4168, 0: 0.4207 },
        '-0.1': { 9: 0.4247, 8: 0.4286, 7: 0.4325, 6: 0.4364, 5: 0.4404, 4: 0.4443, 3: 0.4483, 2: 0.4522, 1: 0.4562, 0: 0.4602 },
        '-0.0': { 9: 0.4641, 8: 0.4681, 7: 0.4721, 6: 0.4761, 5: 0.4801, 4: 0.4840, 3: 0.4880, 2: 0.4920, 1: 0.4960, 0: 0.5000 },
        '0.0': { 0: 0.50000, 1: 0.50399, 2: 0.50798, 3: 0.51197, 4: 0.51595, 5: 0.51994, 6: 0.52392, 7: 0.52790, 8: 0.53188, 9: 0.53586 },
        '0.1': { 0: 0.53980, 1: 0.54380, 2: 0.54776, 3: 0.55172, 4: 0.55567, 5: 0.55966, 6: 0.56360, 7: 0.56749, 8: 0.57142, 9: 0.57535 },
        '0.2': { 0: 0.57930, 1: 0.58317, 2: 0.58706, 3: 0.59095, 4: 0.59483, 5: 0.59871, 6: 0.60257, 7: 0.60642, 8: 0.61026, 9: 0.61409 },
        '0.3': { 0: 0.61791, 1: 0.62172, 2: 0.62552, 3: 0.62930, 4: 0.63307, 5: 0.63683, 6: 0.64058, 7: 0.64431, 8: 0.64803, 9: 0.65173 },
        '0.4': { 0: 0.65542, 1: 0.65910, 2: 0.66276, 3: 0.66640, 4: 0.67003, 5: 0.67364, 6: 0.67724, 7: 0.68082, 8: 0.68439, 9: 0.68793 },
        '0.5': { 0: 0.69146, 1: 0.69497, 2: 0.69847, 3: 0.70194, 4: 0.70540, 5: 0.70884, 6: 0.71226, 7: 0.71566, 8: 0.71904, 9: 0.72240 },
        '0.6': { 0: 0.72575, 1: 0.72907, 2: 0.73237, 3: 0.73565, 4: 0.73891, 5: 0.74215, 6: 0.74537, 7: 0.74857, 8: 0.75175, 9: 0.75490 },
        '0.7': { 0: 0.75804, 1: 0.76115, 2: 0.76424, 3: 0.76730, 4: 0.77035, 5: 0.77337, 6: 0.77637, 7: 0.77935, 8: 0.78230, 9: 0.78524 },
        '0.8': { 0: 0.78814, 1: 0.79103, 2: 0.79389, 3: 0.79673, 4: 0.79955, 5: 0.80234, 6: 0.80511, 7: 0.80785, 8: 0.81057, 9: 0.81327 },
        '0.9': { 0: 0.81594, 1: 0.81859, 2: 0.82121, 3: 0.82381, 4: 0.82639, 5: 0.82894, 6: 0.83147, 7: 0.83398, 8: 0.83646, 9: 0.83891 },
        '1.0': { 0: 0.84134, 1: 0.84375, 2: 0.84614, 3: 0.84849, 4: 0.85083, 5: 0.85314, 6: 0.85543, 7: 0.85769, 8: 0.85993, 9: 0.86214 },
        '1.1': { 0: 0.86433, 1: 0.86650, 2: 0.86864, 3: 0.87076, 4: 0.87286, 5: 0.87493, 6: 0.87698, 7: 0.87900, 8: 0.88100, 9: 0.88298 },
        '1.2': { 0: 0.88493, 1: 0.88686, 2: 0.88877, 3: 0.89065, 4: 0.89251, 5: 0.89435, 6: 0.89617, 7: 0.89796, 8: 0.89973, 9: 0.90147 },
        '1.3': { 0: 0.90320, 1: 0.90490, 2: 0.90658, 3: 0.90824, 4: 0.90988, 5: 0.91149, 6: 0.91308, 7: 0.91466, 8: 0.91621, 9: 0.91774 },
        '1.4': { 0: 0.91924, 1: 0.92073, 2: 0.92220, 3: 0.92364, 4: 0.92507, 5: 0.92647, 6: 0.92785, 7: 0.92922, 8: 0.93056, 9: 0.93189 },
        '1.5': { 0: 0.93319, 1: 0.93448, 2: 0.93574, 3: 0.93699, 4: 0.93822, 5: 0.93943, 6: 0.94062, 7: 0.94179, 8: 0.94295, 9: 0.94408 },
        '1.6': { 0: 0.94520, 1: 0.94630, 2: 0.94738, 3: 0.94845, 4: 0.94950, 5: 0.95053, 6: 0.95154, 7: 0.95254, 8: 0.95352, 9: 0.95449 },
        '1.7': { 0: 0.95543, 1: 0.95637, 2: 0.95728, 3: 0.95818, 4: 0.95907, 5: 0.95994, 6: 0.96080, 7: 0.96164, 8: 0.96246, 9: 0.96327 },
        '1.8': { 0: 0.96407, 1: 0.96485, 2: 0.96562, 3: 0.96638, 4: 0.96712, 5: 0.96784, 6: 0.96856, 7: 0.96926, 8: 0.96995, 9: 0.97062 },
        '1.9': { 0: 0.97128, 1: 0.97193, 2: 0.97257, 3: 0.97320, 4: 0.97381, 5: 0.97441, 6: 0.97500, 7: 0.97558, 8: 0.97615, 9: 0.97670 },
        '2.0': { 0: 0.97725, 1: 0.97778, 2: 0.97831, 3: 0.97882, 4: 0.97932, 5: 0.97982, 6: 0.98030, 7: 0.98077, 8: 0.98124, 9: 0.98169 },
        '2.1': { 0: 0.98214, 1: 0.98257, 2: 0.98300, 3: 0.98341, 4: 0.98382, 5: 0.98422, 6: 0.98461, 7: 0.98500, 8: 0.98537, 9: 0.98574 },
        '2.2': { 0: 0.98610, 1: 0.98645, 2: 0.98679, 3: 0.98713, 4: 0.98745, 5: 0.98778, 6: 0.98809, 7: 0.98840, 8: 0.98870, 9: 0.98899 },
        '2.3': { 0: 0.98928, 1: 0.98956, 2: 0.98983, 3: 0.99010, 4: 0.99036, 5: 0.99061, 6: 0.99086, 7: 0.99111, 8: 0.99134, 9: 0.99158 },
        '2.4': { 0: 0.99180, 1: 0.99202, 2: 0.99224, 3: 0.99245, 4: 0.99266, 5: 0.99286, 6: 0.99305, 7: 0.99324, 8: 0.99343, 9: 0.99361 },
        '2.5': { 0: 0.99379, 1: 0.99396, 2: 0.99413, 3: 0.99430, 4: 0.99446, 5: 0.99461, 6: 0.99477, 7: 0.99492, 8: 0.99506, 9: 0.99520 },
        '2.6': { 0: 0.99534, 1: 0.99547, 2: 0.99560, 3: 0.99573, 4: 0.99585, 5: 0.99598, 6: 0.99609, 7: 0.99621, 8: 0.99632, 9: 0.99643 },
        '2.7': { 0: 0.99653, 1: 0.99664, 2: 0.99674, 3: 0.99683, 4: 0.99693, 5: 0.99702, 6: 0.99711, 7: 0.99720, 8: 0.99728, 9: 0.99736 },
        '2.8': { 0: 0.99744, 1: 0.99752, 2: 0.99760, 3: 0.99767, 4: 0.99774, 5: 0.99781, 6: 0.99788, 7: 0.99795, 8: 0.99801, 9: 0.99807 },
        '2.9': { 0: 0.99813, 1: 0.99819, 2: 0.99825, 3: 0.99831, 4: 0.99836, 5: 0.99841, 6: 0.99846, 7: 0.99851, 8: 0.99856, 9: 0.99861 },
        '3.0': { 0: 0.99865, 1: 0.99869, 2: 0.99874, 3: 0.99878, 4: 0.99882, 5: 0.99886, 6: 0.99889, 7: 0.99893, 8: 0.99896, 9: 0.99900 },
        '3.1': { 0: 0.99903, 1: 0.99906, 2: 0.99910, 3: 0.99913, 4: 0.99916, 5: 0.99918, 6: 0.99921, 7: 0.99924, 8: 0.99926, 9: 0.99929 },
        '3.2': { 0: 0.99931, 1: 0.99934, 2: 0.99936, 3: 0.99938, 4: 0.99940, 5: 0.99942, 6: 0.99944, 7: 0.99946, 8: 0.99948, 9: 0.99950 },
        '3.3': { 0: 0.99952, 1: 0.99953, 2: 0.99955, 3: 0.99957, 4: 0.99958, 5: 0.99960, 6: 0.99961, 7: 0.99962, 8: 0.99964, 9: 0.99965 },
        '3.4': { 0: 0.99966, 1: 0.99968, 2: 0.99969, 3: 0.99970, 4: 0.99971, 5: 0.99972, 6: 0.99973, 7: 0.99974, 8: 0.99975, 9: 0.99976 },
        '3.5': { 0: 0.99977, 1: 0.99978, 2: 0.99978, 3: 0.99979, 4: 0.99980, 5: 0.99981, 6: 0.99981, 7: 0.99982, 8: 0.99983, 9: 0.99983 },
        '3.6': { 0: 0.99984, 1: 0.99985, 2: 0.99985, 3: 0.99986, 4: 0.99986, 5: 0.99987, 6: 0.99987, 7: 0.99988, 8: 0.99988, 9: 0.99989 },
        '3.7': { 0: 0.99989, 1: 0.99990, 2: 0.99990, 3: 0.99990, 4: 0.99991, 5: 0.99991, 6: 0.99992, 7: 0.99992, 8: 0.99992, 9: 0.99992 },
        '3.8': { 0: 0.99993, 1: 0.99993, 2: 0.99993, 3: 0.99994, 4: 0.99994, 5: 0.99994, 6: 0.99994, 7: 0.99995, 8: 0.99995, 9: 0.99995 },
        '3.9': { 0: 0.99995, 1: 0.99995, 2: 0.99996, 3: 0.99996, 4: 0.99996, 5: 0.99996, 6: 0.99996, 7: 0.99996, 8: 0.99997, 9: 0.99997 },
        '4.0': { 0: 0.99997, 1: 0.99997, 2: 0.99997, 3: 0.99997, 4: 0.99997, 5: 0.99997, 6: 0.99998, 7: 0.99998, 8: 0.99998, 9: 0.99998 }
      };
      const result = {};
      // Helper function to check if value is numeric
      const isNumeric = (val) => !isNaN(parseFloat(val)) && isFinite(val);
      // Helper function to get Z-URL
      const getZUrl = (rz) => {
        if (rz < -0.126 && rz > -0.376) return 'z_score_-0.25';
        if (rz < -0.375 && rz > -0.626) return 'z_score_-0.5';
        if (rz < -0.625 && rz > -0.876) return 'z_score_-0.75';
        if (rz < -0.875 && rz > -1.126) return 'z_score_-1';
        if (rz < -1.125 && rz > -1.376) return 'z_score_-1.25';
        if (rz < -1.375 && rz > -1.626) return 'z_score_-1.5';
        if (rz < -1.625 && rz > -1.876) return 'z_score_-1.75';
        if (rz < -1.875 && rz > -2.126) return 'z_score_-2';
        if (rz < -2.125 && rz > -2.376) return 'z_score_-2.25';
        if (rz < -2.375 && rz > -2.626) return 'z_score_-2.5';
        if (rz < -2.625 && rz > -2.876) return 'z_score_-2.75';
        if (rz < -2.875 && rz > -3.126) return 'z_score_-3';
        if (rz < -3.125 && rz > -3.376) return 'z_score_-3.25';
        if (rz < -3.375 && rz > -3.626) return 'z_score_-3.5';
        if (rz < -3.625 && rz > -3.876) return 'z_score_-3.75';
        if (rz < -3.875 && rz > -4.126) return 'z_score_-4';
        if (rz < -4.125) return 'z_score_-4.25';
        if (rz > -0.126 && rz < 0.125) return 'z_score_0';
        if (rz > 0.124 && rz < 0.375) return 'z_score_0.25';
        if (rz > 0.374 && rz < 0.625) return 'z_score_0.5';
        if (rz > 0.624 && rz < 0.875) return 'z_score_0.75';
        if (rz > 0.874 && rz < 1.125) return 'z_score_1';
        if (rz > 1.124 && rz < 1.375) return 'z_score_1.25';
        if (rz > 1.374 && rz < 1.625) return 'z_score_1.5';
        if (rz > 1.624 && rz < 1.875) return 'z_score_1.75';
        if (rz > 1.874 && rz < 2.125) return 'z_score_2';
        if (rz > 2.124 && rz < 2.375) return 'z_score_2.25';
        if (rz > 2.374 && rz < 2.625) return 'z_score_2.5';
        if (rz > 2.624 && rz < 2.875) return 'z_score_2.75';
        if (rz > 2.874 && rz < 3.125) return 'z_score_3';
        if (rz > 3.124 && rz < 3.375) return 'z_score_3.25';
        if (rz > 3.374 && rz < 3.625) return 'z_score_3.5';
        if (rz > 3.624 && rz < 3.875) return 'z_score_3.75';
        if (rz > 3.874 && rz < 4.125) return 'z_score_4';
        if (rz > 4.124) return 'z_score_4.25';
      };
      // Calculate for 'dp' (Data Point)
      if (body.tech_to_calculate == 'dp') {
        if (isNumeric(body.tech_dsvalue) && isNumeric(body.tech_pmvalue) && isNumeric(body.tech_psdvalue)) {
          const x = parseFloat(body.tech_dsvalue);
          const u = parseFloat(body.tech_pmvalue);
          const o = parseFloat(body.tech_psdvalue);
          const ms = x - u;
          let rz = (x - u) / o;

          const rzStr = rz.toString();
          const rzCheck = rzStr.split('');
          let rzVal1, rzVal2;

          if (rzCheck.length > 1) {
            if (rz < 0) {
              if (rzCheck.length === 2) {
                rzVal1 = `${rzCheck[0]}${rzCheck[1]}.0`;
                rzVal2 = 0;
              } else {
                if (rzStr.length > 3) {
                  rzVal1 = `${rzCheck[0]}${rzCheck[1]}${rzCheck[2]}${rzCheck[3]}`;
                }
                if (rzStr.length > 4) {
                  rzVal2 = parseInt(rzCheck[4]);
                } else {
                  rzVal2 = 0;
                }
              }
            } else {
              if (rzStr.length > 2) {
                rzVal1 = `${rzCheck[0]}${rzCheck[1]}${rzCheck[2]}`;
              }
              if (rzStr.length > 3) {
                rzVal2 = parseInt(rzCheck[3]);
              } else {
                rzVal2 = 0;
              }
            }
          } else {
            rzVal1 = `${rzCheck[0]}.0`;
            rzVal2 = 0;
          }

          let ltpv, rtpv;

          if (rz >= 4.1) {
            ltpv = 1;
            rtpv = 0;
          } else if (rz <= -4.1) {
            ltpv = 0;
            rtpv = 1;
          } else {
            ltpv = parseFloat((z_table[rzVal1]?.[rzVal2] || 0).toFixed(5));
            rtpv = parseFloat((1 - ltpv).toFixed(5));
          }

          const ttcl = ltpv - rtpv;
          const ttpv = 1 - Math.abs(ttcl);
          const zUrl = getZUrl(rz);

          result.tech_z_url = zUrl;
          result.tech_ltpv = Math.abs(ltpv);
          result.tech_rtpv = Math.abs(rtpv);
          result.tech_ttpv = Math.abs(ttpv);
          result.tech_ttcl = Math.abs(ttcl);
          result.tech_ms = ms;
          result.tech_rz = parseFloat(rz.toFixed(4));
          return result;
        } else {
          result.error = "Please fill all fields.";
          return result;
        }
      }
      // Calculate for 'sm' (Sample Mean)
      if (body.tech_to_calculate == 'sm') {
        if (isNumeric(body.tech_snvalue) && isNumeric(body.tech_pmvalue) && 
            isNumeric(body.tech_psdvalue) && isNumeric(body.tech_smvalue)) {
          const x = parseFloat(body.tech_smvalue);
          const n = parseFloat(body.tech_snvalue);
          const u = parseFloat(body.tech_pmvalue);
          const o = parseFloat(body.tech_psdvalue);
          const rz = (x - u) / (o / Math.sqrt(n));
          const ms = x - u;
          const sq = Math.sqrt(n);
          const mv = o / sq;

          result.tech_ms = ms;
          result.tech_mv = mv;
          result.tech_sq = sq;
          result.tech_rz = parseFloat(rz.toFixed(4));
          return result;
        } else {
          result.error = "Please fill all fields.";
          return result;
        }
      }
      // Calculate for 'ds' (Data Set)
      if (body.tech_to_calculate == 'ds') {
        let check = true;

        if (!body.tech_x || !body.tech_pmvalue || !body.tech_psdvalue) {
          check = false;
        }

        const numbers = body.tech_x
          .split(',')
          .map(val => val.trim())
          .filter(val => val !== '');

        for (const value of numbers) {
          if (!isNumeric(value)) {
            check = false;
            break;
          }
        }

        if (check === true) {
          const n = numbers.length;
          const arr = numbers.map(val => parseFloat(val));
          const sum = arr.reduce((acc, val) => acc + val, 0);
          const avg = sum / n;
          const u = parseFloat(body.tech_pmvalue);
          const o = parseFloat(body.tech_psdvalue);
          const rz = (avg - u) / (o / Math.sqrt(n));

          let a = '';
          arr.forEach((value, index) => {
            if (index !== arr.length - 1) {
              a += ` ${value} +`;
            } else {
              a += ` ${value} `;
            }
          });

          const sm = avg - u;
          const sq = Math.sqrt(n);
          const dv = o / sq;

          result.tech_avg = avg;
          result.tech_n = n;
          result.tech_a = a;
          result.tech_sum = sum;
          result.tech_sm = sm;
          result.tech_sq = sq;
          result.tech_dv = dv;
          result.tech_rz = parseFloat(rz.toFixed(4));
          return result;
        } else {
          result.error = "Please fill all fields.";
          return result;
        }
      }
      // Calculate for 'p' (P-Value)
      if (body.tech_to_calculate == 'p') {
        if (isNumeric(body.tech_pvalue)) {
          const pva = parseFloat(body.tech_pvalue);

          if (pva > 0 && pva < 1) {
            result.tech_pva = pva;
            return result;
          } else {
            result.error = "Please Input value from 0 to 1.";
            return result;
          }
        } else {
          result.error = "Please Put P Value.";
          return result;
        }
      }
      return result;
    }
  
       /**
   * getCalculationCorrelationCoefficientCalculator: Service Method
   * POST: /api/calculators-lol/z-score-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async getCalculationCorrelationCoefficientCalculator(body) {
        let x = body.tech_x;
        let y = body.tech_y;
        let method = body.tech_method;

        let check = true;
        const param = {};

        // Check if x and y are empty
        if (!x || !y) {
            check = false;
        }

        // Process x values
        let xStr = x.replace(/[ ,\n\r]/g, ',');
        while (xStr.includes(',,')) {
            xStr = xStr.replace(',,', ',');
        }
        
        let numbers = xStr.split(',')
            .map(val => val.trim())
            .filter(val => val !== '');
        
        // Validate x numbers
        for (const value of numbers) {
            if (isNaN(value) || value === '') {
                check = false;
            }
        }
        numbers = numbers.map(val => parseFloat(val));

        // Process y values
        let yStr = y.replace(/[ ,\n\r]/g, ',');
        while (yStr.includes(',,')) {
            yStr = yStr.replace(',,', ',');
        }
        
        let numbersy = yStr.split(',')
            .map(val => val.trim())
            .filter(val => val !== '');
        
        // Validate y numbers
        for (const value of numbersy) {
            if (isNaN(value) || value === '') {
                check = false;
            }
        }
        numbersy = numbersy.map(val => parseFloat(val));

        if (check === true) {
            // Significant figures helper function
            const sigFig = (value, digits) => {
                let decimalPlaces;
                if (value === 0) {
                    decimalPlaces = digits - 1;
                } else if (value < 0) {
                    decimalPlaces = digits - Math.floor(Math.log10(value * -1)) - 1;
                } else {
                    decimalPlaces = digits - Math.floor(Math.log10(value)) - 1;
                }
                return parseFloat(value.toFixed(decimalPlaces));
            };

            if (numbers.length === numbersy.length) {
                let meanx, meany, countx, arr1, arr2, arr3, arr4, arr5, final;

                if (method == 1) {
                    // Pearson correlation
                    countx = numbers.length;
                    const county = numbersy.length;
                    meanx = numbers.reduce((a, b) => a + b, 0) / countx;
                    meany = numbersy.reduce((a, b) => a + b, 0) / county;

                    arr1 = [];
                    arr2 = [];
                    arr3 = [];
                    arr4 = [];
                    arr5 = [];

                    for (let i = 0; i < countx; i++) {
                        arr1.push(numbers[i] - meanx);
                        arr2.push(Math.pow(numbers[i] - meanx, 2));
                        arr3.push(numbersy[i] - meany);
                        arr4.push(Math.pow(numbersy[i] - meany, 2));
                        arr5.push((numbers[i] - meanx) * (numbersy[i] - meany));
                    }

                    const sumx = numbers.reduce((a, b) => a + b, 0);
                    const sumy = numbersy.reduce((a, b) => a + b, 0);
                    const mx = Math.sqrt(arr2.reduce((a, b) => a + b, 0) / countx);
                    const my = Math.sqrt(arr4.reduce((a, b) => a + b, 0) / countx);
                    final = (1 / countx) * (arr5.reduce((a, b) => a + b, 0) / (mx * my));
                } else {
                    // Spearman rank correlation
                    let rank1 = [];
                    let rank2 = [];

                    // Calculate ranks for x
                    for (let i = 0; i < numbers.length; i++) {
                        let count = numbers.length;
                        for (let j = 0; j < numbers.length; j++) {
                            if (numbers[i] !== numbers[j]) {
                                if (numbers[j] >= numbers[i]) {
                                    count--;
                                }
                            }
                        }
                        rank1.push(count);
                    }

                    // Calculate ranks for y
                    for (let i = 0; i < numbersy.length; i++) {
                        let count = numbersy.length;
                        for (let j = 0; j < numbersy.length; j++) {
                            if (numbersy[i] !== numbersy[j]) {
                                if (numbersy[j] >= numbersy[i]) {
                                    count--;
                                }
                            }
                        }
                        rank2.push(count);
                    }

                    // Handle tied ranks for rank2
                    const countValues = (arr) => {
                        const counts = {};
                        arr.forEach(val => {
                            counts[val] = (counts[val] || 0) + 1;
                        });
                        return counts;
                    };

                    let double = {};
                    const arrc = countValues(rank2);
                    for (const [key, value] of Object.entries(arrc)) {
                        if (value > 1) {
                            const div = [];
                            for (let i = 0; i < value; i++) {
                                div.push(parseInt(key) - i);
                            }
                            double[key] = div.reduce((a, b) => a + b, 0) / value;
                        }
                    }

                    let nrank2;
                    if (Object.keys(double).length !== 0) {
                        nrank2 = [...rank2];
                        for (const [key1, value1] of Object.entries(double)) {
                            for (let i = 0; i < rank2.length; i++) {
                                if (parseInt(key1) === rank2[i]) {
                                    nrank2[i] = value1;
                                }
                            }
                        }
                    }

                    // Handle tied ranks for rank1
                    let double1 = {};
                    const arrc1 = countValues(rank1);
                    for (const [key, value] of Object.entries(arrc1)) {
                        if (value > 1) {
                            const div1 = [];
                            for (let i = 0; i < value; i++) {
                                div1.push(parseInt(key) - i);
                            }
                            double1[key] = div1.reduce((a, b) => a + b, 0) / value;
                        }
                    }

                    let nrank1;
                    if (Object.keys(double1).length !== 0) {
                        nrank1 = [...rank1];
                        for (const [key1, value1] of Object.entries(double1)) {
                            for (let i = 0; i < rank1.length; i++) {
                                if (parseInt(key1) === rank1[i]) {
                                    nrank1[i] = value1;
                                }
                            }
                        }
                    }

                    const input1 = nrank1 || rank1;
                    const input2 = nrank2 || rank2;
                    numbers = input1;
                    numbersy = input2;

                    countx = numbers.length;
                    const county = numbersy.length;
                    meanx = numbers.reduce((a, b) => a + b, 0) / countx;
                    meany = numbersy.reduce((a, b) => a + b, 0) / county;

                    arr1 = [];
                    arr2 = [];
                    arr3 = [];
                    arr4 = [];
                    arr5 = [];

                    for (let i = 0; i < countx; i++) {
                        arr1.push(numbers[i] - meanx);
                        arr2.push(Math.pow(numbers[i] - meanx, 2));
                        arr3.push(numbersy[i] - meany);
                        arr4.push(Math.pow(numbersy[i] - meany, 2));
                        arr5.push((numbers[i] - meanx) * (numbersy[i] - meany));
                    }

                    const sumx = numbers.reduce((a, b) => a + b, 0);
                    const sumy = numbersy.reduce((a, b) => a + b, 0);
                    const mx = Math.sqrt(arr2.reduce((a, b) => a + b, 0) / countx);
                    const my = Math.sqrt(arr4.reduce((a, b) => a + b, 0) / countx);
                    final = (1 / countx) * (arr5.reduce((a, b) => a + b, 0) / (mx * my));
                }

                param.tech_numbers = numbers;
                param.tech_numbersy = numbersy;
                param.tech_method = method;
                param.tech_meanx = meanx;
                param.tech_meany = meany;
                param.tech_countx = countx;
                param.tech_arr1 = arr1;
                param.tech_arr2 = arr2;
                param.tech_arr3 = arr3;
                param.tech_arr4 = arr4;
                param.tech_arr5 = arr5;
                param.tech_final = final;
                param.tech_x = xStr;
                param.tech_y = yStr;
                return param;
            } else {
                param.error = "Please! Enter same number of scores for X and Y";
                return param;
            }
        } else {
            param.error = "Please check your input.";
            return param;
        }
    }


     /**
   * getCalculationPValueCalculator: Service Method
   * POST: /api/calculators-lol/p-value-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async getCalculationPValueCalculator(body) {
       let tail = body.tech_tail;
        let testType = body.tech_with; 
        let score = body.tech_score;
        let deg = body.tech_deg;
        let deg2 = body.tech_deg2;
        let level = body.tech_level;
        let degree_freedom = body.tech_degree_freedom;

        const result = {};

        if (testType === undefined) {
          result.error = "Please! Check Your Input";
          return result;
      }


        // Z-distribution functions
        function zcdf(z) {
            let y, x, w;

            if (z === 0.0) {
                x = 0.0;
            } else {
                y = 0.5 * Math.abs(z);
                if (y > (6 * 0.5)) {
                    x = 1.0;
                } else if (y < 1.0) {
                    w = y * y;
                    x = ((((((((0.000124818987 * w
                        - 0.001075204047) * w + 0.005198775019) * w
                        - 0.019198292004) * w + 0.059054035642) * w
                        - 0.151968751364) * w + 0.319152932694) * w
                        - 0.531923007300) * w + 0.797884560593) * y * 2.0;
                } else {
                    y -= 2.0;
                    x = (((((((((((((-0.000045255659 * y
                        + 0.000152529290) * y - 0.000019538132) * y
                        - 0.000676904986) * y + 0.001390604284) * y
                        - 0.000794620820) * y - 0.002034254874) * y
                        + 0.006549791214) * y - 0.010557625006) * y
                        + 0.011630447319) * y - 0.009279453341) * y
                        + 0.005353579108) * y - 0.002141268741) * y
                        + 0.000535310849) * y + 0.999936657524;
                }
            }
            return z > 0.0 ? ((x + 1.0) * 0.5) : ((1.0 - x) * 0.5);
        }

        function zpval(score, tail) {
            let pval;
            if (tail === '0') {
                pval = 2 * zcdf(Math.abs(score) * (-1));
            } else if (tail === '-1') {
                pval = zcdf(score);
            } else if (tail === '2') {
                pval = 1 - zcdf(score);
            }
            return pval;
        }

        // Gamma and Beta functions
        function gammaln(x) {
            const cof = [
                76.18009172947146,
                -86.50532032941677,
                24.01409824083091,
                -1.231739572450155,
                0.1208650973866179e-2,
                -0.5395239384953e-5
            ];
            let ser = 1.000000000190015;
            let xx = x;
            let y = x;
            let tmp = (y = xx = x) + 5.5;
            tmp -= (xx + 0.5) * Math.log(tmp);
            for (let j = 0; j < 6; j++)
                ser += cof[j] / ++y;
            return Math.log(2.5066282746310005 * ser / xx) - tmp;
        }

        function betacf(x, a, b) {
            const fpmin = 1e-30;
            let m = 1;
            const qab = a + b;
            const qap = a + 1;
            const qam = a - 1;
            let c = 1;
            let d = 1 - qab * x / qap;
            let m2, aa, del, h;

            if (Math.abs(d) < fpmin)
                d = fpmin;
            d = 1 / d;
            h = d;

            for (m = 1; m <= 100; m++) {
                m2 = 2 * m;
                aa = m * (b - m) * x / ((qam + m2) * (a + m2));
                d = 1 + aa * d;
                if (Math.abs(d) < fpmin)
                    d = fpmin;
                c = 1 + aa / c;
                if (Math.abs(c) < fpmin)
                    c = fpmin;
                d = 1 / d;
                h *= d * c;
                aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
                d = 1 + aa * d;
                if (Math.abs(d) < fpmin)
                    d = fpmin;
                c = 1 + aa / c;
                if (Math.abs(c) < fpmin)
                    c = fpmin;
                d = 1 / d;
                del = d * c;
                h *= del;
                if (Math.abs(del - 1.0) < 3e-7)
                    break;
            }

            return h;
        }

        function ibeta(x, a, b) {
          // console.log('Inside ibeta:', x, a, b);
            const bt = (x === 0 || x === 1) ? 0 :
                Math.exp(gammaln(a + b) - gammaln(a) -
                    gammaln(b) + a * Math.log(x) + b *
                    Math.log(1 - x));
            if (x < 0 || x > 1)
                return false;
            if (x < (a + 1) / (a + b + 2))
                return bt * betacf(x, a, b) / a;

            return 1 - bt * betacf(1 - x, b, a) / b;
        }

        function tpval(t, df, alt) {
          // console.log(t,df,alt);
          let pval;
          if (alt == '0') {
            pval = 2 * tcdf(Math.abs(t) * (-1), df);
           
          } else if (alt == '-1') {
            pval = tcdf(t, df);
          } else if (alt == '2') {
                pval = 1 - tcdf(t, df);
                // console.log(pval,'bilal');
              }
            return pval;
        }

             // T-distribution functions
        function tcdf(x, dof) {
          const changenumber = Number(dof);
          const xnumberx = Number(x);
          const dof2 = changenumber / 2;
          // const bilalalal = x + Math.sqrt(x * x + dof);
          // console.log(xnumberx,dof,dof2,'gggg');
            // -0.02 3 1.5 gggg
            return ibeta((xnumberx + Math.sqrt(xnumberx * xnumberx + changenumber)) / (2 * Math.sqrt(xnumberx * xnumberx + changenumber)), dof2, dof2);
        }
        // Chi-square functions
        function lowRegGamma(a, x) {
            const aln = gammaln(a);
            let ap = a;
            let sum = 1 / a;
            let del = sum;
            let b = x + 1 - a;
            let c = 1 / 1.0e-30;
            let d = 1 / b;
            let h = d;
            let i = 1;
            const ITMAX = -~(Math.log((a >= 1) ? a : 1 / a) * 8.5 + a * 0.4 + 17);
            let an;

            if (x < 0 || a <= 0) {
                return 0;
            } else if (x < a + 1) {
                for (i = 1; i <= ITMAX; i++) {
                    sum += del *= x / ++ap;
                }
                return (sum * Math.exp(x * (-1) + a * Math.log(x) - (aln)));
            }
            for (; i <= ITMAX; i++) {
                an = i * (-1) * (i - a);
                b += 2;
                d = an * d + b;
                c = b + an / c;
                d = 1 / d;
                h *= d * c;
            }

            return (1 - h * Math.exp(x * (-1) + a * Math.log(x) - (aln)));
        }

        function chicdf(x, dof) {
            if (x < 0)
                return 0;
            return lowRegGamma(dof / 2, x / 2);
        }

        function chipval(chi, df, alt) {
            let pval;
            if (alt == '0') {
                const x = chicdf(chi, df);
                if (x <= 0.5) {
                    pval = 2 * x;
                } else {
                    pval = 2 * (1 - x);
                }
            } else if (alt <= '-1') {
                pval = chicdf(chi, df);
            } else if (alt >= '1') {
                pval = 1 - chicdf(chi, df);
            }
            return pval;
        }

        // F-distribution functions
        function Fcdf(x, df1, df2) {
            // console.log(x,df1,df2);
            const hellox = Number(x);
            const hellodf1 = Number(df1);
            const hellodf2 = Number(df2);
            if (x < 0)
                return 0;
            return ibeta((hellodf1 * hellox) / (hellodf1 * hellox + hellodf2), hellodf1 / 2, hellodf2 / 2);
        }

        function Fpval(F, df1, df2, alt) {
          // console.log(F,df1,df2,alt);
            let pval;
            if (alt == '0') {
                const x = Fcdf(F, df1, df2);
                if (x <= 0.5) {
                    pval = 2 * x;
                } else {
                    pval = 2 * (1 - x);
                }
            } else if (alt <= '-1') {
                pval = Fcdf(F, df1, df2);
            } else if (alt <= '1') {
                pval = 1 - Fcdf(F, df1, df2);
            }
            return pval;
        }

        // Pearson correlation functions
        function calculateTStatistic(r, n) {
            return (r * Math.sqrt(n - 2)) / Math.sqrt(1 - r * r);
        }

        function betaIncomplete(x, a, b) {
            const gammalns = (x) => {
                const cof = [
                    76.18009172947146,
                    -86.50532032941677,
                    24.01409824083091,
                    -1.231739572450155,
                    0.1208650973866179e-2,
                    -0.5395239384953e-5
                ];
                let y = x;
                let tmp = x + 5.5;
                tmp -= (x + 0.5) * Math.log(tmp);
                let ser = 1.000000000190015;
                for (let j = 0; j < 6; j++) ser += cof[j] / ++y;
                return -tmp + Math.log(2.5066282746310005 * ser / x);
            };

            const betacfs = (x, a, b) => {
                const MAXIT = 100;
                const EPS = 3.0e-7;
                const FPMIN = 1.0e-30;
                const qab = a + b;
                const qap = a + 1.0;
                const qam = a - 1.0;
                let c = 1.0;
                let d = 1.0 - qab * x / qap;
                if (Math.abs(d) < FPMIN) d = FPMIN;
                d = 1.0 / d;
                let h = d;
                for (let m = 1, m2 = 2; m <= MAXIT; m++, m2 += 2) {
                    let aa = m * (b - m) * x / ((qam + m2) * (a + m2));
                    d = 1.0 + aa * d;
                    if (Math.abs(d) < FPMIN) d = FPMIN;
                    c = 1.0 + aa / c;
                    if (Math.abs(c) < FPMIN) c = FPMIN;
                    d = 1.0 / d;
                    h *= d * c;
                    aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
                    d = 1.0 + aa * d;
                    if (Math.abs(d) < FPMIN) d = FPMIN;
                    c = 1.0 + aa / c;
                    if (Math.abs(c) < FPMIN) c = FPMIN;
                    d = 1.0 / d;
                    h *= d * c;
                }
                return h;
            };

            const bt = (x == 0 || x == 1) ? 0 :
                Math.exp(gammalns(a + b) - gammalns(a) - gammalns(b) + a * Math.log(x) + b * Math.log(1 - x));
            if (x < 0.0 || x > 1.0) return 0.0;
            if (x < (a + 1.0) / (a + b + 2.0))
                return bt * betacfs(x, a, b) / a;
            else
                return 1.0 - bt * betacfs(1.0 - x, b, a) / b;
        }

        function tDistCDFs(t, df) {
            const x = df / (df + t * t);
            const a = df / 2.0;
            const b = 0.5;
            const betaIncompleteResult = betaIncomplete(x, a, b);
            return 1.0 - 0.5 * betaIncompleteResult;
        }

        function calculatePValue(t, df) {
            return 2 * (1 - tDistCDFs(t, df));
        }

        function pValueFromPearson(r, n) {
            const t = calculateTStatistic(r, n);
            const df = n - 2;
            return calculatePValue(t, df);
        }

        // Validation
        if (level < 0 || level > 1) {
            result.error = "Significance level must be a number between 0 and 1";
            return result;
        }

        let p;

        // Calculate p-value based on test type
        if (testType === 'z') {
            if (!isFinite(score) || !isFinite(level)) {
                result.error = "Please! Check Your Input";
                return result;
            }
            p = zpval(score, tail);
        } else if (testType === 't') {
            if (!isFinite(score) || !isFinite(deg) || !isFinite(level)) {
                result.error = "Please! Check Your Input";
                return result;
            }
            p = tpval(score, deg, tail);
            // console.log(p,score,deg,tail,'gagagagag');
        } else if (testType === 'chi') {
            if (!isFinite(score) || !isFinite(deg) || !isFinite(level)) {
                result.error = "Please! Check Your Input";
                return result;
            }
            p = chipval(score, deg, deg);
        } else if (testType === 'f') {
            if (!isFinite(score) || !isFinite(deg) || !isFinite(deg2) || !isFinite(level)) {
                result.error = "Please! Check Your Input";
                return result;
            }
            if (deg2 < 0) {
                result.error = "Your values for degrees of freedom cannot be negative.";
                return result;
            }
            p = Fpval(score, deg, deg2, level);
        } else if (testType === 'r') {
            if (!isFinite(score) || !isFinite(deg) || !isFinite(level)) {
                result.error = "Please! Check Your Input";
                return result;
            }
            if (score < -1 || score > 1 || deg <= 2) {
                result.error = "score must be between -1 and 1 and deg must be greater than 2";
                return result;
            }
            p = pValueFromPearson(score, deg);
        } else if (testType === 'q') {
            if (isFinite(score) && isFinite(deg) && isFinite(degree_freedom) && !isFinite(level)) {
                result.error = "Please! Check Your Input";
                return result;
            }
            if (deg < 2 || deg > 30) {
                result.error = "Degree of freedom must be between 2 and 30.";
                return result;
            }
            if (degree_freedom < 3) {
                result.error = "Degrees of freedom must be greater than or equal to 3.";
                return result;
            }
            result.tech_score = score;
            result.tech_deg = deg;
            result.tech_degree_freedom = degree_freedom;
            result.tech_level = level;
            return result;
        }

        // Determine interpretation
        const inter = p <= level ? '' : 'not';

        // Round p-value if decimal
        if (p.toString().includes('.')) {
            p = Math.round(p * 10000000) / 10000000;
        }

        result.tech_tail = tail;
        result.tech_inter = inter;
        result.tech_level = level;
        result.tech_p = p;
        result.RESULT = 1;

        return result;
    }


      /**
   * getCalculationProbabilityDensityFunctionCalculator: Service Method
   * POST: /api/calculators-lol/probability-density-function
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async  getCalculationProbabilityDensityFunctionCalculator(body) {
      const result = {};
      
      const select = body.tech_select;
      const a = parseFloat(body.tech_a);
      const b = parseFloat(body.tech_b);
      const c = parseFloat(body.tech_c);

      try {
          if (select == 1) {
              // Beta Distribution
              if (isNumeric(a) && isNumeric(b) && isNumeric(c)) {
                  if (c < 0 || c > 1) {
                      result.error = "x Must be greater than 0 and less than 1";
                      return result;
                  }
                  
                  const paramA = (a - 1).toString();
                  const paramB = (b - 1).toString();
                  const parem = `t**(${paramA})(1-t)**(${paramB})`;
                  
                  try {
                      const params = new URLSearchParams();
                      params.append('equ', parem);
                      params.append('wrt', 't');
                      params.append('lb', '0');
                      params.append('ub', '1');
                      
                      const response = await axios.post("http://167.172.134.148/only_integral", params, {
                          headers: {
                              'Content-Type': 'application/x-www-form-urlencoded'
                          },
                          timeout: 120000
                      });
                      
                      const buffer = response.data;
                        const B = parseFloat(buffer[0]);
                      const ans = (1 / B) * Math.pow(c, (a - 1)) * Math.pow((1 - c), (b - 1));
                      
                      result.tech_ans = ans;
                      return result;
                  } catch (error) {
                      console.error('Select 1 Error:', error.message);
                      result.error = "Server Busy! Please try again later";
                      return result;
                  }
              } else {
                  result.error = "Please! Check Your Input";
                  return result;
              }
          } 
          else if (select == 2) {
              // Chi-Square Distribution
              if (isNumeric(a) && isNumeric(b)) {
                  const paramA = ((a / 2) - 1).toString();
                  const parem = `t**(${paramA})exp(-t)`;
                  
                  try {
                      const params = new URLSearchParams();
                      params.append('equ', parem);
                      params.append('wrt', 't');
                      params.append('lb', '0');
                      params.append('ub', 'oo');
                      
                      const response = await axios.post("http://167.172.134.148/only_integral", params, {
                          headers: {
                              'Content-Type': 'application/x-www-form-urlencoded'
                          },
                          timeout: 120000
                      });
                      
                      const buffer = response.data;
                      const B = parseFloat(buffer[0]);
                      const ans = (1 / (Math.pow(2, (a / 2)) * B)) * Math.pow(b, ((a / 2) - 1)) * Math.exp((-1 * b) / 2);
                      
                      result.tech_ans = ans;
                      return result;
                  } catch (error) {
                      console.error('Select 2 Error:', error.message);
                      result.error = "Server Busy! Please try again later";
                      return result;
                  }
              } else {
                  result.error = "Please! Check Your Input";
                  return result;
              }
          } 
          else if (select == 3) {
              // F Distribution
              if (isNumeric(a) && isNumeric(b) && isNumeric(c)) {
                  const paramA = Math.abs((a / 2) - 1).toString();
                  const paramB = Math.abs((b / 2) - 1).toString();
                  const parem = `t**(${paramA})(1-t)**(${paramB})`;
                  
                  try {
                      const params = new URLSearchParams();
                      params.append('equ', parem);
                      params.append('wrt', 't');
                      params.append('lb', '0');
                      params.append('ub', '1');
                      
                      const response = await axios.post("http://167.172.134.148/only_integral", params, {
                          headers: {
                              'Content-Type': 'application/x-www-form-urlencoded'
                          },
                          timeout: 120000
                      });
                      
                      const buffer = response.data;
                      const B = parseFloat(buffer[0]);
                      
                      // Calculate numerator and denominator separately for debugging
                      const numerator = Math.sqrt((Math.pow(a * c, a) * Math.pow(b, b)) / Math.pow(a * c + b, (a + b)));
                      const denominator = c * B;
                      const ans = numerator / denominator;
                      
                        result.tech_ans = ans;
                      return result;
                  } catch (error) {
                      console.error('Select 3 Error:', error.message);
                      result.error = "Server Busy! Please try again later";
                      return result;
                  }
              } else {
                  result.error = "Please! Check Your Input";
                  return result;
              }
          } 
          else if (select == 4) {
              // Non-central t Distribution
              if (isNumeric(a) && isNumeric(b) && isNumeric(c)) {
                  const paramA = ((a / 2) - 1).toString();
                  const parem = `t**(${paramA})exp(-t)`;
                  
                  const u = b;
                  const v = a;
                  const x = c;
                  const uxValue = (u * x).toString();
                  const x2PlusV = (Math.pow(x, 2) + v).toString();
                  const parem1 = `y**(${v})*exp( -1/2 * ( y- ((${uxValue}) / (sqrt(${x2PlusV}) ) ))**2)`;
                  
                  try {
                      const params = new URLSearchParams();
                      params.append('equ', parem);
                      params.append('equ1', parem1);
                      params.append('wrt', 't');
                      params.append('wrt1', 'y');
                      params.append('lb', '0');
                      params.append('ub', 'oo');
                      
                      const response = await axios.post("http://167.172.134.148/only_integral", params, {
                          headers: {
                              'Content-Type': 'application/x-www-form-urlencoded'
                          },
                          timeout: 120000
                      });
                      
                      const buffer = response.data;
                        const B = parseFloat(buffer[0]);
                            const int = parseFloat(buffer[1]);
                      const up1 = Math.pow(v, v / 2) * Math.exp(-1 * ((v * Math.pow(u, 2)) / (2 * (Math.pow(x, 2) + v))));
                      const btm = up1 / (Math.sqrt(Math.PI) * B * Math.pow(2, ((v - 1) / 2)) * Math.pow((Math.pow(x, 2) + v), ((v + 1) / 2)));
                      const ans = int * btm;
                      
                        result.tech_ans = ans;
                      return result;
                  } catch (error) {
                      console.error('Select 4 Error:', error.message);
                      result.error = "Server Busy! Please try again later";
                      return result;
                  }
              } else {
                  result.error = "Please! Check Your Input";
                  return result;
              }
          } 
          else if (select == 5) {
              // Normal Distribution
              if (isNumeric(a) && isNumeric(b) && isNumeric(c)) {
                  const ans = (1 / Math.sqrt(2 * Math.PI * Math.pow(b, 2))) * Math.exp(-1 * (Math.pow(c - a, 2) / (2 * Math.pow(b, 2))));
                  
                  result.tech_ans = ans;
                  return result;
              } else {
                  result.error = "Please! Check Your Input";
                  return result;
              }
          } 
          else if (select == 6) {
              // Standard Normal Distribution
              if (isNumeric(c)) {
                  const ans = (1 / Math.sqrt(2 * Math.PI)) * Math.exp((-1 / 2) * Math.pow(c, 2));
                  
                result.tech_ans = ans;
                  return result;
              } else {
                  result.error = "Please! Check Your Input";
                  return result;
              }
          } 
          else if (select == 7) {
              // Student's t Distribution
              if (isNumeric(a) && isNumeric(b)) {
                  const paramA = ((a / 2) - 1).toString();
                  const paramB = (((a + 1) / 2) - 1).toString();
                  const parem = `t**(${paramA})exp(-t)`;
                  const parem1 = `t**(${paramB})exp(-t)`;
                  
                  try {
                      const params = new URLSearchParams();
                      params.append('equ', parem);
                      params.append('equ1', parem1);
                      params.append('wrt', 't');
                      params.append('lb', '0');
                      params.append('ub', 'oo');
                      
                      const response = await axios.post("http://167.172.134.148/only_integral", params, {
                          headers: {
                              'Content-Type': 'application/x-www-form-urlencoded'
                          },
                          timeout: 120000
                      });
                      
                      const buffer = response.data;
                        const B = parseFloat(buffer[0]);
                            const B1 = parseFloat(buffer[1]);
                      const ans = (B1 / (Math.sqrt(a * Math.PI) * B)) * Math.pow((1 + (Math.pow(b, 2) / a)), (-1 / 2 * (a + 1)));
                      
                    result.tech_ans = ans;
                      return result;
                  } catch (error) {
                      console.error('Select 7 Error:', error.message);
                      result.error = "Server Busy! Please try again later";
                      return result;
                  }
              } else {
                  result.error = "Please! Check Your Input";
                  return result;
              }
          } 
          else if (select == 8) {
              // Uniform Distribution
              if (isNumeric(a) && isNumeric(b) && isNumeric(c)) {
                  let ans;
                  if (c >= a && c <= b) {
                      ans = 1 / (b - a);
                  } else {
                      ans = 0;
                  }
                  
                  result.tech_ans = ans;
                  return result;
              } else {
                  result.error = "Please! Check Your Input";
                  return result;
              }
          }
          
          result.error = "Invalid selection";
          return result;
          
      } catch (error) {
          console.error('Main Error:', error.message);
          result.error = "An error occurred: " + error.message;
          return result;
      }
      
      // Helper function to check if value is numeric
      function isNumeric(value) {
          return !isNaN(parseFloat(value)) && isFinite(value);
      }
  }


      /**
   * getCalculationeffectSizeCalculator: Service Method
   * POST: /api/calculators-lol/effect-size-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async getCalculationeffectSizeCalculator(body) {
      const result = {};
      
      // Extract and trim all request parameters
      const effectType = body.tech_effect_type?.toString().trim();
      const ronding = parseInt(body.tech_ronding?.toString().trim()) || 2;
      const c_x1 = parseFloat(body.tech_c_x1?.toString().trim());
      const c_s = parseFloat(body.tech_c_s?.toString().trim());
      const c_pm = parseFloat(body.tech_c_pm?.toString().trim());
      const x1 = parseFloat(body.tech_x1?.toString().trim());
      const x2 = parseFloat(body.tech_x2?.toString().trim());
      const n1 = parseFloat(body.tech_n1?.toString().trim());
      const n2 = parseFloat(body.tech_n2?.toString().trim());
      const s1 = parseFloat(body.tech_s1?.toString().trim());
      const s2 = parseFloat(body.tech_s2?.toString().trim());
      const p1 = parseFloat(body.tech_p1?.toString().trim());
      const p2 = parseFloat(body.tech_p2?.toString().trim());
      const ph_x2 = parseFloat(body.tech_ph_x2?.toString().trim());
      const ph_n1 = parseFloat(body.tech_ph_n1?.toString().trim());
      const cr_x2 = parseFloat(body.tech_cr_x2?.toString().trim());
      const cr_n1 = parseFloat(body.tech_cr_n1?.toString().trim());
      const row = parseFloat(body.tech_row?.toString().trim());
      const col = parseFloat(body.tech_col?.toString().trim());
      const ssr = parseFloat(body.tech_ssr?.toString().trim());
      const sst = parseFloat(body.tech_sst?.toString().trim());
      const ssg = parseFloat(body.tech_ssg?.toString().trim());
      const et_sst = parseFloat(body.tech_et_sst?.toString().trim());
      const r2f = parseFloat(body.tech_r2f?.toString().trim());
      const f2r = parseFloat(body.tech_f2r?.toString().trim());
      const t_value = parseFloat(body.tech_t_value?.toString().trim());
      const df = parseFloat(body.tech_df?.toString().trim());

      if (!effectType) {
          result.error = "Please! Check Your Input";
          return result;
      }

      const isNumeric = (value) => !isNaN(value) && isFinite(value);

      try {
          if (effectType === 'cohen2e') {
              if (isNumeric(x1) && isNumeric(x2) && isNumeric(n1) && 
                  isNumeric(n2) && isNumeric(s1) && isNumeric(s2)) {
                  
                  const s1pow = Math.pow(s1, 2);
                  const s2pow = Math.pow(s2, 2);
                  const res = (n1 - 1) * Math.pow(s1, 2) + (n2 - 1) * Math.pow(s2, 2);
                  const res2 = n1 + n2 - 2;
                  const sqr = res / res2;
                  const sqrt = Math.sqrt(sqr);
                  const x1x2 = Math.abs(x1 - x2);
                  const d = x1x2 / sqrt;
                  const cohen2e = parseFloat(d.toFixed(ronding));

                  Object.assign(result, {
                      tech_x1:x1, 
                      tech_x2:x2, 
                      tech_n1:n1, 
                      tech_n2:n2, 
                      tech_s1:s1, 
                      tech_s2:s2, 
                      tech_s1pow:s1pow, 
                      tech_s2pow:s2pow,
                      tech_res:res, 
                      tech_res2:res2, 
                      tech_sqr:sqr, 
                      tech_sqrt:sqrt, 
                      tech_x1x2:x1x2, 
                      tech_d:d, 
                      tech_cohen2e:cohen2e
                  });
              } else {
                  result.error = "Please! Check Your Input";
                  return result;
              }
          } 
          else if (effectType === 'cohen2u') {
              if (isNumeric(x1) && isNumeric(x2) && isNumeric(n1) && 
                  isNumeric(n2) && isNumeric(s1) && isNumeric(s2)) {
                  
                  const s1pow = Math.pow(s1, 2);
                  const s2pow = Math.pow(s2, 2);
                  const res = s1pow + s2pow;
                  const sqr = res / 2;
                  const sqrt = Math.sqrt(sqr);
                  const x1x2 = Math.abs(x1 - x2);
                  const d = Math.abs(x1 - x2) / sqrt;
                  const cohen2u = parseFloat(d.toFixed(ronding));

                  Object.assign(result, {
                      tech_x1:x1, 
                      tech_x2:x2, 
                      tech_n1:n1, 
                      tech_n2:n2, 
                      tech_s1:s1, 
                      tech_s2:s2, 
                      tech_s1pow:s1pow, 
                      tech_s2pow:s2pow,
                      tech_res:res, 
                      tech_sqr:sqr, 
                      tech_sqrt:sqrt, 
                      tech_x1x2:x1x2, 
                      tech_d:d, 
                      tech_cohen2u:cohen2u
                  });
              } else {
                  result.error = "Please! Check Your Input";
                  return result;
              }
          } 
          else if (effectType === 'cohen') {
              if (isNumeric(c_x1) && isNumeric(c_s) && isNumeric(c_pm)) {
                  const d = c_x1 - c_pm;
                  const c = Math.abs(d);
                  const res = Math.abs(d) / c_s;
                  const cohen = parseFloat(res.toFixed(ronding));

                  Object.assign(result, { 
                    tech_c_x1:c_x1, 
                    tech_c_s:c_s, 
                    tech_c_pm:c_pm, 
                    tech_res:res, 
                    tech_c:c, 
                    tech_d:d, 
                    tech_cohen:cohen
                   });
              } else {
                  result.error = "Please! Check Your Input";
                  return result;
              }
          } 
          else if (effectType === 'h') {
              if (isNumeric(p1) && isNumeric(p2)) {
                  const p1sqr = Math.sqrt(p1);
                  const p2sqr = Math.sqrt(p2);
                  const arcp1 = Math.asin(p1sqr);
                  const arcp2 = Math.asin(p2sqr);
                  const res = 2 * (Math.asin(p1sqr) - Math.asin(p2sqr));
                  const h = parseFloat(res.toFixed(ronding));

                  Object.assign(result, { 
                    tech_p1:p1, 
                    tech_p2:p2, 
                    tech_p1sqr:p1sqr, 
                    tech_p2sqr:p2sqr, 
                    tech_arcp1:arcp1, 
                    tech_arcp2:arcp2, 
                    tech_h:h 
                  });
              } else {
                  result.error = "Please! Check Your Input";
                  return result;
              }
          } 
          else if (effectType === 'phi') {
              if (isNumeric(ph_x2) && isNumeric(ph_n1)) {
                  const res = ph_x2 / ph_n1;
                  const p = Math.sqrt(res);
                  const phi = parseFloat(p.toFixed(ronding));

                  Object.assign(result, { 
                    tech_ph_x2:ph_x2, 
                    tech_ph_n1:ph_n1, 
                    tech_res:res, 
                    tech_p:p, 
                    tech_phi:phi 
                  });
              } else {
                  result.error = "Please! Check Your Input";
                  return result;
              }
          } 
          else if (effectType === 'cramer') {
              if (isNumeric(cr_x2) && isNumeric(cr_n1) && isNumeric(row) && isNumeric(col)) {
                  const r = row - 1;
                  const c = col - 1;
                  const min = Math.min(r, c);
                  const res = cr_n1 * min;
                  const v = cr_x2 / res;
                  const x = Math.sqrt(v);
                  const cramer = parseFloat(x.toFixed(ronding));

                  Object.assign(result, { 
                    tech_cr_x2:cr_x2, 
                    tech_cr_n1:cr_n1, 
                    tech_row:row, 
                    tech_col:col, 
                    tech_r:r, 
                    tech_c:c, 
                    tech_min:min, 
                    tech_res:res, 
                    tech_v:v, 
                    tech_cramer:cramer 
                  });
              } else {
                  result.error = "Please! Check Your Input";
                  return result;
              }
          } 
          else if (effectType === 'r2') {
              if (isNumeric(ssr) && isNumeric(sst)) {
                  const r = ssr / sst;
                  const res = 1 - r;
                  const f2 = r / res;
                  const r2 = parseFloat(f2.toFixed(ronding));

                  Object.assign(result, { 
                    tech_ssr:ssr, 
                    tech_sst:sst, 
                    tech_r:r, 
                    tech_res:res, 
                    tech_f2:f2, 
                    tech_r2:r2 
                  });
              } else {
                  result.error = "Please! Check Your Input";
                  return result;
              }
          } 
          else if (effectType === 'eta2') {
              if (isNumeric(ssg) && isNumeric(et_sst)) {
                  const et = ssg / et_sst;
                  const res = 1 - et;
                  const e = et / res;
                  const eta2 = parseFloat(e.toFixed(ronding));

                  Object.assign(result, { 
                    tech_ssg:ssg, 
                    tech_et_sst:et_sst, 
                    tech_et:et, 
                    tech_res:res, 
                    tech_eta2:eta2
                   });
              } else {
                  result.error = "Please! Check Your Input";
                  return result;
              }
          } 
          else if (effectType === 'r2f') {
              if (isNumeric(row)) {
                  const res = 1 - r2f;
                  const r = r2f / res;
                  const rf = parseFloat(r.toFixed(ronding));

                  Object.assign(result, { 
                    tech_r2f:r2f, 
                    tech_res:res, 
                    tech_r:r, 
                    tech_rf:rf 
                  });
              } else {
                  result.error = "Please! Check Your Input";
                  return result;
              }
          } 
          else if (effectType === 'f2r') {
              if (isNumeric(f2r)) {
                  const res = 1 + f2r;
                  const f = f2r / res;
                  const fr = parseFloat(f.toFixed(ronding));

                  Object.assign(result, { 
                    tech_f2r:f2r, 
                    tech_res:res, 
                    tech_f:f, 
                    tech_fr:fr
                   });
              } else {
                  result.error = "Please! Check Your Input";
                  return result;
              }
          } 
          else if (effectType === 'dr') {
              if (isNumeric(t_value) && isNumeric(df)) {
                  const res = 2 * t_value;
                  const t = Math.pow(t_value, 2);
                  const res2 = t + df;
                  const ry = t / res2;
                  const ryres = Math.sqrt(ry);
                  const dfsqr = Math.sqrt(df);
                  const d = res / dfsqr;
                  const dr = parseFloat(d.toFixed(ronding));
                  const r = parseFloat(ryres.toFixed(ronding));

                  Object.assign(result, { 
                    tech_t_value:t_value, 
                    tech_df:df, 
                    tech_res:res, 
                    tech_d:d, 
                    tech_dr:dr, 
                    tech_dfsqr:dfsqr, 
                    tech_t:t, 
                    tech_res2:res2, 
                    tech_ry:ry,
                    tech_r:r 
                  });
              } else {
                  result.error = "Please! Check Your Input";
                  return result;
              }
          } 
          else {
              result.error = "Please! Check Your Input";
              return result;
          }

          result.tech_effect_type = effectType;
          return result;

      } catch (error) {
          result.error = "Calculation error: " + error.message;
          return result;
      }
  }

  
  /**
   * getCalculationDecileCalculator: Service Method
   * POST: /api/calculators-lol/decile-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async getCalculationDecileCalculator(body) {
      const x = body.tech_x;
      const decile = body.tech_decile;

      const param = {};
      let check = true;

      // Check if x is empty
      if (!x || x.trim() === '') {
          check = false;
      }

      // Replace spaces, commas, and newlines with commas
      let cleanedX = x.replace(/[\s,\n\r]+/g, ',');
      
      // Remove consecutive commas
      while (cleanedX.includes(',,')) {
          cleanedX = cleanedX.replace(/,,/g, ',');
      }

      // Split and filter the numbers
      const numbers = cleanedX
          .split(',')
          .map(val => val.trim())
          .filter(val => val !== '');

      // Validate all values are numeric
      for (const value of numbers) {
          if (isNaN(value) || value === '') {
              check = false;
              break;
          }
      }

      if (check === true) {
          // Chunk array into pairs of 2
          const sortArray = [];
          for (let i = 0; i < numbers.length; i += 2) {
              sortArray.push(numbers.slice(i, i + 2));
          }

          // Create ans_list by combining pairs with decimal point (keep as strings like PHP)
          const ansList = [];
          for (const value of sortArray) {
              if (value.length === 2) {
                  ansList.push(value[0] + '.' + value[1]);
              } else {
                  ansList.push(value[0]);
              }
          }

          const totalValues = sortArray.length;
          const decilePos = ((totalValues + 1) * (decile / 10));

          let mainAns;

          // Check if decile position is not a whole number
          if (!Number.isInteger(decilePos)) {
              const floorVal = Math.floor(decilePos);
              const ceilVal = Math.ceil(decilePos);
              const listFloorVal = ansList[floorVal - 1]; // Can be undefined if floorVal is 0
              const listCeilVal = ansList[ceilVal - 1];   // Can be undefined if ceilVal exceeds array length
              const floorMinus = decilePos - floorVal;
              
              // Convert to numbers for calculation
              // PHP treats null/undefined as 0 in arithmetic operations
              const numFloorVal = listFloorVal ? parseFloat(listFloorVal) : 0;
              const numCeilVal = listCeilVal ? parseFloat(listCeilVal) : 0;
              
              mainAns = numFloorVal + floorMinus * (numCeilVal - numFloorVal);
              
              param.tech_floor_val = floorVal;
              param.tech_ceil_val = ceilVal;
              param.tech_list_floor_val = listFloorVal || null;
              param.tech_list_ceil_val = listCeilVal || null;
              param.tech_floor_minus = floorMinus;
          } else {
              mainAns = parseFloat(ansList[decilePos - 1]);
          }

          param.tech_main_ans = mainAns;
          param.tech_total_values = totalValues;
          param.tech_ans_list = ansList;
          param.tech_decile_pos = decilePos;
      } else {
          param.error = "Please! Check Your Input";
          return param;
      }

      return param;
  }

    /**
   * getCalculationPertCalculator: Service Method
   * POST: /api/calculators-lol/pert-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPertCalculator(body) {
      const optimistic = String(body.tech_optimistic || '').trim();
      const optimistic_one = String(body.tech_optimistic_one || '').trim();
      const optimistic_sec = String(body.tech_optimistic_sec || '').trim();
      const optimistic_unit = String(body.tech_optimistic_unit || '').trim();
      const pessimistic = String(body.tech_pessimistic || '').trim();
      const pessimistic_one = String(body.tech_pessimistic_one || '').trim();
      const pessimistic_sec = String(body.tech_pessimistic_sec || '').trim();
      const pessimistic_unit = String(body.tech_pessimistic_unit || '').trim();
      const most = String(body.tech_most || '').trim();
      const most_one = String(body.tech_most_one || '').trim();
      const most_sec = String(body.tech_most_sec || '').trim();
      const most_unit = String(body.tech_most_unit || '').trim();
      const desired = String(body.tech_desired || '').trim();
      const desired_one = String(body.tech_desired_one || '').trim();
      const desired_sec = String(body.tech_desired_sec || '').trim();
      const desired_unit = String(body.tech_desired_unit || '').trim();
      const output_unit = String(body.tech_output_unit || '').trim();
      const deviation_unit = String(body.tech_deviation_unit || '').trim();

      const param = {};

      // Helper function: time_unit
      function time_unit(optimistic, optimistic_unit) {
        let value = parseFloat(optimistic);
        if (optimistic_unit == "hrs") {
          value = value * 24;
        } else if (optimistic_unit == "days") {
          value = value * 1;
        } else if (optimistic_unit == "wks") {
          value = value / 7;
        } else if (optimistic_unit == "mos") {
          value = value / 30.417;
        } else if (optimistic_unit == "yrs") {
          value = value / 365;
        }
        return value;
      }

      // Helper function: other_time
      function other_time(optimistic_one, optimistic_sec, optimistic_unit) {
        let value;
        const val1 = parseFloat(optimistic_one);
        const val2 = parseFloat(optimistic_sec);
        
        if (optimistic_unit == "yrs/mos") {
          value = (val1 * 365) + (val2 * 30.417);
        } else if (optimistic_unit == "wks/days") {
          value = (val1 * 7) + val2;
        } else if (optimistic_unit == "days/hrs") {
          value = val1 + (val2 / 24);
        }
        return value;
      }

      // Helper function: secore
      function secore(x) {
        const pi = 3.1415927;
        const a = (8 * (pi - 3)) / (3 * pi * (4 - pi));
        const x2 = x * x;
        const ax2 = a * x2;
        const num = (4 / pi) + ax2;
        const denom = 1 + ax2;
        const inner = (-x2) * num / denom;
        const secore2 = 1 - Math.exp(inner);
        return Math.sqrt(secore2);
      }

      // Helper function: cdf
      function cdf(n) {
        if (n < 0) {
          return (1 - secore(n / Math.sqrt(2))) / 2;
        } else {
          return (1 + secore(n / Math.sqrt(2))) / 2;
        }
      }

      // Validation
      if (!isNaN(optimistic) && !isNaN(pessimistic) && !isNaN(most) && !isNaN(desired)) {
        
        // Process optimistic
        let optimistic_val;
        if (optimistic_unit === "yrs/mos" || optimistic_unit === "wks/days" || optimistic_unit === "days/hrs") {
          if (!isNaN(optimistic_one) && !isNaN(optimistic_sec)) {
            optimistic_val = other_time(optimistic_one, optimistic_sec, optimistic_unit);
            param.tech_optimistic = optimistic_val;
          } else {
            param.error = "Please! Check Your Input";
            return param;
          }
        } else {
          optimistic_val = time_unit(optimistic, optimistic_unit);
        }

        // Process pessimistic
        let pessimistic_val;
        if (pessimistic_unit === "yrs/mos" || pessimistic_unit === "wks/days" || pessimistic_unit === "days/hrs") {
          if (!isNaN(pessimistic_one) && !isNaN(pessimistic_sec)) {
            pessimistic_val = other_time(pessimistic_one, pessimistic_sec, pessimistic_unit);
            param.tech_pessimistic = pessimistic_val;
          } else {
            param.error = "Please! Check Your Input";
            return param;
          }
        } else {
          pessimistic_val = time_unit(pessimistic, pessimistic_unit);
        }

        // Process most
        let most_val;
        if (most_unit === "yrs/mos" || most_unit === "wks/days" || most_unit === "days/hrs") {
          if (!isNaN(most_one) && !isNaN(most_sec)) {
            most_val = other_time(most_one, most_sec, most_unit);
            param.tech_most = most_val;
          } else {
            param.error = "Please! Check Your Input";
            return param;
          }
        } else {
          most_val = time_unit(most, most_unit);
        }

        // Process desired
        let desired_val;
        if (desired_unit === "yrs/mos" || desired_unit === "wks/days" || desired_unit === "days/hrs") {
          if (!isNaN(desired_one) && !isNaN(desired_sec)) {
            desired_val = other_time(desired_one, desired_sec, desired_unit);
            param.tech_desired = desired_val;
          } else {
            param.error = "Please! Check Your Input";
            return param;
          }
        } else {
          desired_val = time_unit(desired, desired_unit);
        }

        // Calculate PERT
        const multi = 4 * most_val;
        const add = optimistic_val + multi + pessimistic_val;
        const sub = add / 6;
        const main_answer = time_unit(sub, output_unit);

        const standard = pessimistic_val - optimistic_val;
        if (standard === 0) {
          param.error = "Optimistic or Pessimistic value note same";
          return param;
        } else {
          const sta_answer = standard / 6;
          const sub_answer = time_unit(sta_answer, deviation_unit);
          const score = desired_val - main_answer;
          const main_score = score / sub_answer;
          const ans = cdf(main_score) * 100;
          
          param.tech_add = add;
          param.tech_main_answer = main_answer;
          param.tech_sub_answer = sub_answer;
          param.tech_ans = ans;
        }
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }

      return param;
    }


        /**
   * getCalculationAnovaCalculator: Service Method
   * POST: /api/calculators-lol/anova-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

   async getCalculationAnovaCalculator(body) {
    const submit = body.tech_type;
    const param = {};

    if (submit === 'one_way') {
        const k = parseInt(body.tech_k);
        let check = true;

        // Validate input data
        for (let x = 1; x <= k; x++) {
            const group = body[`tech_group${x}`];
            if (!group) continue;
            
            const groups = group.split(',').map(item => item.trim());
            for (const value of groups) {
                if (isNaN(parseFloat(value))) {
                    check = false;
                    break;
                }
            }
            if (!check) break;
        }

        if (check === true) {
            let alph = '';
            let alph2 = '';
            let alph_sum = '';
            let alph_sum2 = '';
            
            // Generate table headers
            for (let i = 1; i <= k; i++) {
                alph += `<th class='p-2 border text-center text-blue'>Group ${i}</th>`;
                alph2 += `<th class='p-2 border text-center text-blue'>(Group ${i})²</th>`;
            }

            let table = `<table class='w-full' style='border-collapse: collapse'><thead><tr class='bg-sky'>${alph}</tr></thead><tbody>`;
            let table1 = `<table class='w-full' style='border-collapse: collapse'><thead><tr class='bg-sky'>${alph2}</tr></thead><tbody>`;
            let table2 = `<table class='w-full' style='border-collapse: collapse'><thead><tr class='bg-sky'><th colspan='7' class='bb_1 p-2 border text-center text-blue'>Data Summary</th></tr></thead><thead><tr class='bg-gray'><th class='p-2 border text-center text-blue'>Groups</th><th class='p-2 border text-center text-blue'>N</th><th class='p-2 border text-center text-blue'>∑x</th><th class='p-2 border text-center text-blue'>Mean</th><th class='p-2 border text-center text-blue'>∑x²</th><th class='p-2 border text-center text-blue'>Std. Dev.</th><th class='p-2 border text-center text-blue'>Std. Error</th></tr></thead><tbody>`;

            let v = 0;
            let std_dev = 0;
            let n_sum = 0;
            let mean_sum = 0;
            let total_sum = 0;
            let total_sum2 = 0;
            const trs = [];
            const trs1 = [];
            const groupData = [];

            // Process each group
            for (let i = 1; i <= k; i++) {
                const group = body[`tech_group${i}`];
                const groups = group.split(',').map(item => parseFloat(item.trim()));
                const n = groups.length;
                const sum = groups.reduce((a, b) => a + b, 0);
                let sum2 = 0;
                const mean = sum / n;

                // Calculate variance
                let groupV = 0;
                groups.forEach(value => {
                    groupV += Math.pow(value - mean, 2);
                    sum2 += Math.pow(value, 2);
                });

                std_dev = Math.sqrt(groupV / (n - 1));
                const std_error = std_dev / Math.sqrt(n);

                // Store group data
                groupData.push({
                    n: n,
                    sum: sum,
                    mean: mean,
                    sum2: sum2,
                    std_dev: std_dev,
                    variance: groupV
                });

                // Build table rows
                groups.forEach((value, key) => {
                    if (trs[key]) {
                        trs[key] += `<td class='p-2 border text-center'>${value}</td>`;
                    } else {
                        trs[key] = `<td class='p-2 border text-center'>${value}</td>`;
                    }

                    if (trs1[key]) {
                        trs1[key] += `<td class='p-2 border text-center text-blue'>${Math.pow(value, 2)}</td>`;
                    } else {
                        trs1[key] = `<td class='p-2 border text-center text-blue'>${Math.pow(value, 2)}</td>`;
                    }
                });

                table2 += `<tr class='bg-white'><td class='p-2 border text-center'>Group ${i}</td><td class='p-2 border text-center'>${n}</td><td class='p-2 border text-center'>${sum}</td><td class='p-2 border text-center'>${mean}</td><td class='p-2 border text-center'>${sum2}</td><td class='p-2 border text-center'>${std_dev.toFixed(4)}</td><td class='p-2 border text-center'>${std_error.toFixed(4)}</td></tr>`;

                v = 0;
                n_sum += n;
                mean_sum += mean;
                total_sum += sum;
                total_sum2 += sum2;
                alph_sum += `<th class='p-2 border text-center text-blue'>∑Group ${i} = ${sum}</th>`;
                alph_sum2 += `<th class='p-2 border text-center text-blue'>∑(Group${i})² = ${sum2}</th>`;
            }

            // Build tables
            for (let i = 0; i < trs.length; i++) {
                table += `<tr class='bg-white'>${trs[i]}</tr>`;
                table1 += `<tr class='bg-white'>${trs1[i]}</tr>`;
            }

            mean_sum = mean_sum / k;
            table += `<tr class='bg-sky'>${alph_sum}</tr></tbody></table>`;
            table1 += `<tr class='bg-sky'>${alph_sum2}</tr></tbody></table>`;
            table2 += `<tr class='bg-sky'><th class='p-2 border text-center text-blue'>Total</th><th class='p-2 border text-center text-blue'>${n_sum}</th><th class='p-2 border text-center text-blue'>${total_sum}</th><th class='p-2 border text-center text-blue'>${mean_sum}</th><th class='p-2 border text-center text-blue'>${total_sum2}</th><th class='p-2 border text-center text-blue'>&nbsp;</th><th class='p-2 border text-center text-blue'>&nbsp;</th></tr></tbody></table>`;

            // Calculate SSB and SSW - EXACT BUG REPRODUCTION
            let s1 = '';
            let s2 = '';
            let ssb = 0;
            let ssw = 0;

            // The BUG in Laravel: v variable is reused and not reset properly
            let buggyV = 0;
            for (let i = 1; i <= k; i++) {
                const group = body[`tech_group${i}`];
                const groups = group.split(',').map(item => parseFloat(item.trim()));
                const n = groups.length;
                const sum = groups.reduce((a, b) => a + b, 0);
                const mean = sum / n;

                // BUG: v is not reset properly for each group in Laravel
                groups.forEach(value => {
                    buggyV += Math.pow(value - mean, 2);
                });

                const buggyStdDev = Math.sqrt(buggyV / (n - 1));

                // Build formula strings with the BUG
                if (i < k) {
                    s1 += `${n} * (${mean} - ${mean_sum})^2 + `;
                    s2 += `(${n} - 1) * (${buggyStdDev.toFixed(4)})^2 + `;
                } else {
                    s1 += `${n} * (${mean} - ${mean_sum})^2`;
                    s2 += `${n} * (${mean} - ${mean_sum})^2`; // Last group uses wrong formula
                }

                ssb += n * Math.pow((mean - mean_sum), 2);
                
                // BUG: v should be reset here but it's not in Laravel
                // In Laravel: v = 0; is outside the loop but should be inside
            }

            // Correct SSW calculation (despite the bug in formula display)
            ssw = 0;
            for (let i = 0; i < groupData.length; i++) {
                ssw += groupData[i].variance;
            }

            param.tech_k = k;
            param.tech_N = n_sum;
            param.tech_table = table;
            param.tech_table1 = table1;
            param.tech_table2 = table2;
            param.tech_s1 = s1;
            param.tech_s2 = s2;
            param.tech_ssb = parseFloat(ssb.toFixed(4));
            param.tech_ssw = parseFloat(ssw.toFixed(4));
            return param;
        } else {
            param.error = "Please! Check Your Input";
            return param;
        }
   } else if (submit === 'two_way') {
        const rows = parseInt(body.tech_rows);
        const columns = parseInt(body.tech_columns);
        let check = true;

        // Validate input data
        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < columns; j++) {
                const input = body[`tech_td_${i}_${j}`];
                if (!input) continue;
                
                const inputs = input.split(',').map(item => item.trim());
                for (const value of inputs) {
                    if (isNaN(parseFloat(value))) {
                        check = false;
                        break;
                    }
                }
                if (!check) break;
            }
            if (!check) break;
        }

        if (check === true) {
            let head = '';
            let head2 = '';
            let p3_s1 = '';
            let p3_s2 = '';
            let p3_s3 = '';
            let C = 0;
            let p4_s1 = '';
            let p4_s2 = '';
            let p4_s3 = '';
            let D = 0;
            let n = 0;
            let summ = 0;
            const sumxa = [];
            
            let table = `<table class='w-full' style='border-collapse: collapse'><thead><tr class='bg-gray'><th class='p-2 border text-center text-blue'>Observation</th>`;
            let table1 = `<table class='w-full' style='border-collapse: collapse'><thead><tr class='bg-gray'><th class='p-2 border text-center text-blue'>Observation</th>`;

            // Generate table headers
            for (let i = 0; i < columns; i++) {
                table += `<th class='p-2 border text-center text-blue'>Group ${i + 1}</th>`;
                table1 += `<th class='p-2 border text-center text-blue'>Group ${i + 1}</th>`;
            }

            table += `</tr></thead><tbody>`;
            table1 += `<th class='p-2 border text-center text-blue'>Row Total</th></tr></thead><tbody>`;

            let p5_s1 = '';
            let p5_s2 = '';
            let E = 0;

            // Process rows and columns
            for (let i = 0; i < rows; i++) {
                table += `<tr class='bg-white'><td class='p-2 border text-center'>${i + 1}</td>`;
                table1 += `<tr class='bg-white'><td class='p-2 border text-center'>${i + 1}</td>`;
                
                let sum1 = 0;
                let nr = 0;
                let nc = 0;

                for (let j = 0; j <= columns; j++) {
                    if (j !== columns) {
                        const input = body[`tech_td_${i}_${j}`];
                        table += `<td class='p-2 border text-center'>${input}</td>`;
                        
                        const inputs = input.split(',').map(item => parseFloat(item.trim()));
                        const sum = inputs.reduce((a, b) => a + b, 0);
                        table1 += `<td class='p-2 border text-center'>${sum}</td>`;
                        
                        sum1 += sum;
                        
                        if (sumxa[j] === undefined) {
                            sumxa[j] = 0;
                        }
                        sumxa[j] += sum;
                        
                        nr += inputs.length;
                        nc = inputs.length;
                        n += inputs.length;
                        summ += sum;

                        if (i === rows - 1 && j === columns - 1) {
                            p4_s1 += `\\dfrac {(${sum})^2}{${nc}}`;
                            p4_s2 += `\\dfrac {${Math.pow(sum, 2)}}{${nc}}`;
                            p4_s3 += parseFloat((Math.pow(sum, 2) / nc).toFixed(4));
                        } else {
                            p4_s1 += `\\dfrac {(${sum})^2}{${nc}} + `;
                            p4_s2 += `\\dfrac {${Math.pow(sum, 2)}}{${nc}} + `;
                            p4_s3 += parseFloat((Math.pow(sum, 2) / nc).toFixed(4)) + ' + ';
                        }
                        
                        D += Math.pow(sum, 2) / nc;
                    } else {
                        if (sumxa[j] === undefined) {
                            sumxa[j] = 0;
                        }
                        sumxa[j] += sum1;
                        table1 += `<td class='p-2 border text-center'><b>${sum1}</b></td>`;
                    }
                }

                if (i === rows - 1) {
                    p3_s1 += `\\dfrac {(${sum1})^2}{${nr}}`;
                    p3_s2 += `\\dfrac {${Math.pow(sum1, 2)}}{${nr}}`;
                    p3_s3 += parseFloat((Math.pow(sum1, 2) / nr).toFixed(4));
                } else {
                    p3_s1 += `\\dfrac {(${sum1})^2}{${nr}} + `;
                    p3_s2 += `\\dfrac {${Math.pow(sum1, 2)}}{${nr}} + `;
                    p3_s3 += parseFloat((Math.pow(sum1, 2) / nr).toFixed(4)) + ' + ';
                }

                C += Math.pow(sum1, 2) / nr;
                table += `</tr>`;
                table1 += `</tr>`;
            }

            p5_s1 += `\\dfrac {(${summ})^2}{${n}}`;
            p5_s2 += `\\dfrac {${Math.pow(summ, 2)}}{${n}}`;
            E += parseFloat((Math.pow(summ, 2) / n).toFixed(4));
            
            table += `</tbody></table>`;
            table1 += `<tr class='bg-white'><td class='p-2 border text-center'><b>Col Total</b></td>`;
            
            sumxa.forEach((value, key) => {
                table1 += `<td class='p-2 border text-center'><b>${value}</b></td>`;
            });
            
            table1 += `</tr></tbody></table>`;

            // Calculate additional parameters - FIXED p1 calculation
            let p1 = '';
            let p2_s1 = '';
            let p2_s2 = '';
            let p2_s3 = '';
            let A = 0;
            let B = 0;

            for (let i = 0; i < columns; i++) {
                let nc = 0;
                for (let j = 0; j < rows; j++) {
                    const input = body[`tech_td_${j}_${i}`];
                    const inputs = input.split(',').map(item => parseFloat(item.trim()));
                    nc += inputs.length;
                }

                if (i === columns - 1) {
                    p2_s1 += `\\dfrac {(${sumxa[i]})^2}{${nc}}`;
                    p2_s2 += `\\dfrac {${Math.pow(sumxa[i], 2)}}{${nc}}`;
                    p2_s3 += parseFloat((Math.pow(sumxa[i], 2) / nc).toFixed(4));
                } else {
                    p2_s1 += `\\dfrac {(${sumxa[i]})^2}{${nc}} + `;
                    p2_s2 += `\\dfrac {${Math.pow(sumxa[i], 2)}}{${nc}} + `;
                    p2_s3 += parseFloat((Math.pow(sumxa[i], 2) / nc).toFixed(4)) + ' + ';
                }

                B += Math.pow(sumxa[i], 2) / nc;
            }

            // FIXED: Build p1 like Laravel - show all values properly
            const allValues = [];
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < columns; j++) {
                    const input = body[`tech_td_${i}_${j}`];
                    const inputs = input.split(',').map(item => parseFloat(item.trim()));
                    allValues.push(...inputs.map(val => ({ value: val, squared: Math.pow(val, 2) })));
                }
            }

            // Calculate A
            allValues.forEach(item => {
                A += item.squared;
            });

            // Build p1 string like Laravel
            const showFirst = 3; // Show first 3 values
            const showLast = 3;  // Show last 3 values
            
            for (let idx = 0; idx < allValues.length; idx++) {
                const val = allValues[idx].value;
                
                if (idx < showFirst) {
                    // Show first few values
                    p1 += `${val}^2 + `;
                } else if (idx === showFirst && allValues.length > showFirst + showLast) {
                    // Show "..." if there are many values
                    p1 += `... + `;
                } else if (idx >= allValues.length - showLast) {
                    // Show last few values
                    if (idx === allValues.length - 1) {
                        p1 += `${val}^2`;
                    } else {
                        p1 += `${val}^2 + `;
                    }
                }
            }

            param.tech_rows = rows;
            param.tech_columns = columns;
            param.tech_table = table;
            param.tech_table1 = table1;
            param.tech_p1 = p1;
            param.tech_A = A;
            param.tech_p2_s1 = p2_s1;
            param.tech_p2_s2 = p2_s2;
            param.tech_p2_s3 = p2_s3;
            param.tech_B = B;
            param.tech_p3_s1 = p3_s1;
            param.tech_p3_s2 = p3_s2;
            param.tech_p3_s3 = p3_s3;
            param.tech_C = C;
            param.tech_p4_s1 = p4_s1;
            param.tech_p4_s2 = p4_s2;
            param.tech_p4_s3 = p4_s3;
            param.tech_D = D;
            param.tech_p5_s1 = p5_s1;
            param.tech_p5_s2 = p5_s2;
            param.tech_E = E;
            param.tech_n = n;

            return param;
        } else {
            param.error = "Please! Check Your Input";
            return param;
        }
    } else {
        param.error = "Please! Check Your Input";
        return param;
    }
}

        /**
   * getCalculationTestStatisticCalculator: Service Method
   * POST: /api/calculators-lol/test-statistic-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTestStatisticCalculator(body) {
      try {
        let test_radio = body.tech_test_radio;
        let row_data = body.tech_row_data;
        let row_data1 = body.tech_row_data1;
        let mean = body.tech_mean;
        let sem = body.tech_sem;
        let n = body.tech_n;
        let mean1 = body.tech_mean1;
        let sem1 = body.tech_sem1;
        let n1 = body.tech_n1;
        let mean_sec = body.tech_mean_sec;
        let sd_sec = body.tech_sd_sec;
        let n_sec = body.tech_n_sec;
        let mean_sec1 = body.tech_mean_sec1;
        let sd_sec1 = body.tech_sd_sec1;
        let n_sec2 = body.tech_n_sec2;


        const result = {};

        // Helper function: Calculate standard deviation
        function standardDeviation(array) {
          const n = array.length;
          if (n === 0) return 0;
          const mean = array.reduce((sum, val) => sum + val, 0) / n;
          const variance = array.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / n;
          return Math.sqrt(variance);
        }

        // Helper function: Log Gamma approximation
        function logGamma(x) {
          const cof = [
            76.18009172947146,
            -86.50532032941677,
            24.01409824083091,
            -1.231739572450155,
            0.001208650973866179,
            -0.000005395239384953
          ];
          let y = x;
          let tmp = x + 5.5;
          tmp -= (x + 0.5) * Math.log(tmp);
          let ser = 1.000000000190015;
          for (let j = 0; j < 6; j++) {
            ser += cof[j] / ++y;
          }
          return -tmp + Math.log(2.5066282746310005 * ser / x);
        }

        // Helper function: Beta continued fraction
        function betaCf(x, a, b) {
          const MAXIT = 100;
          const EPS = 3.0e-7;
          const FPMIN = 1.0e-30;
          
          const qab = a + b;
          const qap = a + 1;
          const qam = a - 1;
          let c = 1;
          let d = 1 - qab * x / qap;
          
          if (Math.abs(d) < FPMIN) d = FPMIN;
          d = 1 / d;
          let h = d;
          
          for (let m = 1; m <= MAXIT; m++) {
            const m2 = 2 * m;
            let aa = m * (b - m) * x / ((qam + m2) * (a + m2));
            d = 1 + aa * d;
            if (Math.abs(d) < FPMIN) d = FPMIN;
            c = 1 + aa / c;
            if (Math.abs(c) < FPMIN) c = FPMIN;
            d = 1 / d;
            h *= d * c;
            aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
            d = 1 + aa * d;
            if (Math.abs(d) < FPMIN) d = FPMIN;
            c = 1 + aa / c;
            if (Math.abs(c) < FPMIN) c = FPMIN;
            d = 1 / d;
            const del = d * c;
            h *= del;
            if (Math.abs(del - 1) < EPS) break;
          }
          return h;
        }

        // Helper function: Incomplete Beta function
        function betaInc(x, a, b) {
          const bt = (x === 0 || x === 1) ? 0 : 
            Math.exp(logGamma(a + b) - logGamma(a) - logGamma(b) + 
            a * Math.log(x) + b * Math.log(1 - x));
          
          if (x < 0.5) {
            return bt * betaCf(x, a, b) / a;
          } else {
            return 1 - bt * betaCf(1 - x, b, a) / b;
          }
        }

        // Helper function: T-distribution (two-tailed p-value)
        function tDist(t, df) {
          const x = df / (t * t + df);
          const a = 0.5 * betaInc(x, 0.5 * df, 0.5);
          return 2 * a;
        }

        // SECTION 1: Raw Data Input
        if (test_radio === "data") {
          if (!row_data || !row_data1) {
            return { error: "Please! Check Your Input" };
          }

          // Convert data strings to arrays
          const group1 = row_data
            .split('\n')
            .map(val => val.trim())
            .filter(val => val !== '')
            .map(val => parseFloat(val));

          const group2 = row_data1
            .split('\n')
            .map(val => val.trim())
            .filter(val => val !== '')
            .map(val => parseFloat(val));

          // Group 1 calculations
          const mean1 = group1.reduce((sum, val) => sum + val, 0) / group1.length;
          const sd1 = Math.sqrt(
            group1.reduce((sum, val) => sum + Math.pow(val - mean1, 2), 0) / 
            (group1.length - 1)
          );
          const sem1 = sd1 / Math.sqrt(group1.length);
          const n1Val = group1.length;

          // Group 2 calculations
          const mean2 = group2.reduce((sum, val) => sum + val, 0) / group2.length;
          const sd2 = Math.sqrt(
            group2.reduce((sum, val) => sum + Math.pow(val - mean2, 2), 0) / 
            (group2.length - 1)
          );
          const sem2 = sd2 / Math.sqrt(group2.length);
          const n2Val = group2.length;

          // Statistical calculations
          const df = n1Val + n2Val - 2;
          const variance1 = sd1 * sd1;
          const variance2 = sd2 * sd2;
          const pooledVariance = ((n1Val - 1) * variance1 + (n2Val - 1) * variance2) / df;
          const standardError = Math.sqrt(pooledVariance * (1 / n1Val + 1 / n2Val));
          const tValue = Math.abs((mean1 - mean2) / standardError);
          const pValue = tDist(tValue, df);

          Object.assign(result, {
            tech_mean1:mean1, 
            tech_mean2:mean2, 
            tech_sd1:sd1, 
            tech_sd2:sd2, 
            tech_sem1:sem1, 
            tech_sem2:sem2,
            tech_n1: n1Val, 
            tech_n2: n2Val, 
            tech_df:df, 
            tech_tValue:tValue,
            tech_standardError:standardError, 
            tech_variance1:variance1, 
            tech_variance2:variance2,
            tech_pooledVariance:pooledVariance, 
            tech_pValue:pValue
          });
        }
        
        // SECTION 2: SEM Input
        else if (test_radio === "sem") {
          if (!isNumeric(mean) || !isNumeric(sem) || !isNumeric(n) ||
              !isNumeric(mean1) || !isNumeric(sem1) || !isNumeric(n1)) {
            return { error: "Please! Check Your Input" };
          }

          const mean1Val = parseFloat(mean);
          const sem1Val = parseFloat(sem);
          const n1Val = parseFloat(n);
          const mean2Val = parseFloat(mean1);
          const sem2Val = parseFloat(sem1);
          const n2Val = parseFloat(n1);

          // Calculate variances from SEM
          const variance1 = Math.pow(sem1Val, 2) * n1Val;
          const variance2 = Math.pow(sem2Val, 2) * n2Val;

          // Calculate SD from variances
          const sd1 = Math.sqrt(variance1);
          const sd2 = Math.sqrt(variance2);

          // Calculate SEM from SD
          const sem1Calculated = sd1 / Math.sqrt(n1Val);
          const sem2Calculated = sd2 / Math.sqrt(n2Val);

          // Statistical calculations
          const df = n1Val + n2Val - 2;
          const pooledVariance = ((n1Val - 1) * variance1 + (n2Val - 1) * variance2) / df;
          const standardError = Math.sqrt(pooledVariance * (1 / n1Val + 1 / n2Val));
          const tValue = Math.abs((mean1Val - mean2Val) / standardError);
          const pValue = tDist(tValue, df);

          Object.assign(result, {
            tech_mean1: mean1Val.toFixed(2),
            tech_mean2: mean2Val.toFixed(2),
            tech_sd1: sd1.toFixed(2),
            tech_sd2: sd2.toFixed(2),
            tech_sem1: sem1Calculated.toFixed(2),
            tech_sem2: sem2Calculated.toFixed(2),
            tech_n1: n1Val.toFixed(2),
            tech_n2: n2Val.toFixed(2),
            tech_df: df.toFixed(2),
            tech_tValue: tValue.toFixed(2),
            tech_standardError: standardError.toFixed(2),
            tech_variance1: variance1.toFixed(2),
            tech_variance2: variance2.toFixed(2),
            tech_pooledVariance: pooledVariance.toFixed(2),
            tech_pValue:pValue
          });
        }
        
        // SECTION 3: SD Input
        else if (test_radio === "sd") {
          if (!isNumeric(mean_sec) || !isNumeric(sd_sec) || !isNumeric(n_sec) ||
              !isNumeric(mean_sec1) || !isNumeric(sd_sec1) || !isNumeric(n_sec2)) {
            return { error: "Please! Check Your Input" };
          }

          const mean1Val = parseFloat(mean_sec);
          const sd1Val = parseFloat(sd_sec);
          const n1Val = parseFloat(n_sec);
          const mean2Val = parseFloat(mean_sec1);
          const sd2Val = parseFloat(sd_sec1);
          const n2Val = parseFloat(n_sec2);

          // Calculations
          const variance1 = sd1Val * sd1Val;
          const variance2 = sd2Val * sd2Val;
          const sem1Calculated = sd1Val / Math.sqrt(n1Val);
          const sem2Calculated = sd2Val / Math.sqrt(n2Val);
          const df = n1Val + n2Val - 2;
          const pooledVariance = ((n1Val - 1) * variance1 + (n2Val - 1) * variance2) / df;
          const standardError = Math.sqrt(pooledVariance * (1 / n1Val + 1 / n2Val));
          const tValue = Math.abs((mean1Val - mean2Val) / standardError);
          const pValue = tDist(tValue, df);

          Object.assign(result, {
            tech_mean1: mean1Val,
            tech_mean2: mean2Val,
            tech_sd1: sd1Val,
            tech_sd2: sd2Val,
            tech_sem1: sem1Calculated,
            tech_sem2: sem2Calculated,
            tech_n1: n1Val,
            tech_n2: n2Val,
             tech_df:df, 
             tech_tValue:tValue, 
             tech_standardError:standardError,
            tech_variance1:variance1, 
            tech_variance2:variance2,
            tech_pooledVariance:pooledVariance, 
            tech_pValue:pValue
          });
        }

        result.tech_test_radio = test_radio;
        return result;

      } catch (error) {
        console.error('Error in calculation:', error);
        return { error: 'Calculation failed. Please check your input.' };
        
      }
      // Helper function to check if value is numeric
      function isNumeric(value) {
        return value !== null && value !== undefined && value !== '' && !isNaN(parseFloat(value));
      }
  }


    /**
   * getCalculationPooledVarianceCalculator: Service Method
   * POST: /api/calculators-lol/pooled-variance-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async  getCalculationPooledVarianceCalculator(body) {
      const result = {};
      
      // Extract and trim inputs
      const type = body.tech_type?.toString().trim() || '';
      const ronding = parseInt(body.tech_ronding) || 2;
      const option = body.tech_option?.toString().trim() || '';
      const s1 = body.tech_s1?.toString().trim() || '';
      const s2 = body.tech_s2?.toString().trim() || '';
      const n1 = body.tech_n1?.toString().trim() || '';
      const n2 = body.tech_n2?.toString().trim() || '';
      const g1 = body.tech_g1?.toString().trim() || '';
      const g2 = body.tech_g2?.toString().trim() || '';

      // Validation
      if (!type) {
        return { error: "Please! Check Your Input" };
      }

      result.type = type;
      result.option = option;

      // EQUAL VARIANCE - SUMMARY STATISTICS
      if (type === 'equal' && option === 'sum') {
        if (!isNumeric(s1) || !isNumeric(s2) || !isNumeric(n1) || !isNumeric(n2)) {
          return { error: "Please! Check Your Input" };
        }

        const n1Val = parseFloat(n1);
        const n2Val = parseFloat(n2);
        const s1Val = parseFloat(s1);
        const s2Val = parseFloat(s2);

        const ps1 = Math.pow(s1Val, 2);
        const ps2 = Math.pow(s2Val, 2);
        const n1_1 = n1Val - 1;
        const n2_1 = n2Val - 1;
        const devn1 = 1 / n1Val;
        const devn2 = 1 / n2Val;
        const devres = devn1 + devn2;
        const sqrdevres = round(Math.sqrt(devres), ronding);
        const n1s1 = n1_1 * ps1;
        const n2s2 = n2_1 * ps2;
        const res = n1s1 + n2s2;
        const devi = n1Val + n2Val - 2;
        const sp2 = round(res / devi, ronding);
        const sqrsp2 = round(Math.sqrt(sp2), ronding);
        const sp = round(sqrsp2 * sqrdevres, ronding);

        Object.assign(result, {
          n1: n1Val, s1: s1Val, n2: n2Val, s2: s2Val,
          n1_1, n2_1, devn1, devn2, devres, sqrdevres,
          ps1, ps2, devi, n1s1, n2s2, res, sp2, sp, sqrsp2,
          RESULT: 1
        });
      }
      
      // EQUAL VARIANCE - RAW DATA
      else if (type === 'equal' && option === 'raw') {
        if (!g1 || !g2) {
          return { error: "Please! Check Your Input" };
        }

        // Process Group 1
        const group1Data = processRawData(g1, option, ronding);
        if (group1Data.error) return group1Data;

        // Process Group 2
        const group2Data = processRawData(g2, option, ronding);
        if (group2Data.error) return group2Data;

        // Pooled calculations
        const pv = group1Data.ress12 + group2Data.ress22;
        const pvr = group1Data.i + group2Data.i1 - 2;
        const pvres = round(pv / pvr, ronding);
        const sqrpvres = round(Math.sqrt(pvres), ronding);
        const resdev = group1Data.devn1 + group2Data.devn12;
        const sqrresdev = round(Math.sqrt(resdev), ronding);
        const seres = round(sqrpvres * sqrresdev, ronding);

        Object.assign(result, {
          i: group1Data.i, v: group1Data.v, sum: group1Data.sum,
          table: group1Data.table, ar_sum: group1Data.ar_sum,
          vsqrt: group1Data.vsqrt, vrres: group1Data.vrres,
          s12: group1Data.s12, ress12: group1Data.ress12,
          devn1: group1Data.devn1, countn: group1Data.countn,
          i1: group2Data.i1, v1: group2Data.v1, sum1: group2Data.sum1,
          table1: group2Data.table1, ar_sum1: group2Data.ar_sum1,
          vsqrt1: group2Data.vsqrt1, vrres1: group2Data.vrres1,
          s22: group2Data.s22, ress22: group2Data.ress22,
          devn12: group2Data.devn12, countn1: group2Data.countn1,
          pv, pvres, sqrpvres, resdev, sqrresdev, seres,
          RESULT: 1
        });
      }
      
      // UNEQUAL VARIANCE - SUMMARY STATISTICS
      else if (type === 'unequal' && option === 'sum') {
        if (!isNumeric(s1) || !isNumeric(s2) || !isNumeric(n1) || !isNumeric(n2)) {
          return { error: "Please! Check Your Input" };
        }

        const n1Val = parseFloat(n1);
        const n2Val = parseFloat(n2);
        const s1Val = parseFloat(s1);
        const s2Val = parseFloat(s2);

        const ps1 = Math.pow(s1Val, 2);
        const ps2 = Math.pow(s2Val, 2);
        const pn1 = Math.pow(n1Val, 2);
        const pn2 = Math.pow(n2Val, 2);
        const ps14 = Math.pow(s1Val, 4);
        const ps24 = Math.pow(s2Val, 4);
        const devn1 = n1Val - 1;
        const devn2 = n2Val - 1;
        const devs1n1 = ps1 / n1Val;
        const devs2n2 = ps2 / n2Val;
        const devpspn = ps14 / pn1;
        const mpndev = pn2 * devn2;
        const psmpn = ps24 / mpndev;
        const devpsmp = devpspn + psmpn;
        const se = devs1n1 + devs2n2;
        const devs1s2 = devs1n1 + devs2n2;
        const powdevs1s2 = Math.pow(devs1s2, 2);
        const devs1sm = round(powdevs1s2 / devpsmp, ronding);
        const sqrse = Math.sqrt(se);
        const seround = round(sqrse, ronding);

        Object.assign(result, {
          n1: n1Val, pn1, pn2, s1: s1Val, n2: n2Val, s2: s2Val,
          ps1, ps14, ps2, ps24, devs1n1, devs2n2, se, sqrse, seround,
          devn1, devn2, devpspn, mpndev, psmpn, devpsmp,
          devs1s2, devs1sm, powdevs1s2,
          RESULT: 1
        });
      }
      
      // UNEQUAL VARIANCE - RAW DATA
      else if (type === 'unequal' && option === 'raw') {
        if (!g1 || !g2) {
          return { error: "Please! Check Your Input" };
        }

        // Process Group 1 with unequal variance calculations
        const group1Data = processRawDataUnequal(g1, ronding);
        if (group1Data.error) return group1Data;

        // Process Group 2 with unequal variance calculations
        const group2Data = processRawDataUnequal(g2, ronding);
        if (group2Data.error) return group2Data;

        // Pooled calculations for unequal variance
        const pv = group1Data.ress12 + group2Data.ress22;
        const pvr = group1Data.i + group2Data.i1 - 2;
        const powpv = Math.pow(pv, 2);
        const pvres = round(pv / pvr, ronding);
        const sqrpvres = round(Math.sqrt(pvres), ronding);
        const resdev = group1Data.vsqi + group2Data.vsqi1;
        const sqrresdev = round(Math.sqrt(resdev), ronding);
        const seres = round(sqrpvres * sqrresdev, ronding);
        const dft = group1Data.vsqi + group2Data.vsqi1;
        const powdft = Math.pow(dft, 2);
        const dft1 = group1Data.devn1 + group2Data.devn12;
        const dftres = round(powdft / dft1, ronding);

        Object.assign(result, {
          powpv, pvr, vsqi1: group2Data.vsqi1, vsqi: group1Data.vsqi,
          pi1: group2Data.pi1, s224: group2Data.s224,
          pi: group1Data.pi, s124: group1Data.s124,
          sqrresdev, resdev,
          devn12: group2Data.devn12, devn1: group1Data.devn1,
          sqrpvres, pv,
          ress22: group2Data.ress22, ress12: group1Data.ress12,
          s22: group2Data.s22, vrres1: group2Data.vrres1,
          s12: group1Data.s12, vrres: group1Data.vrres,
          vsqrt1: group2Data.vsqrt1, v1: group2Data.v1,
          i1: group2Data.i1, ar_sum1: group2Data.ar_sum1,
          table1: group2Data.table1, sum1: group2Data.sum1,
          countn1: group2Data.countn1,
          vsqrt: group1Data.vsqrt, v: group1Data.v,
          i: group1Data.i, ar_sum: group1Data.ar_sum,
          table: group1Data.table, sum: group1Data.sum,
          countn: group1Data.countn,
          seres, pvres, pivr: group1Data.pivr, pivr1: group2Data.pivr1,
          dft, dft1, powdft, dftres,
          RESULT: 1
        });
      }
      
      else {
        return { error: "Please! Check Your Input" };
      }

      return result;
      
          // Helper function to round numbers
          function round(value, decimals) {
            return Number(Math.round(value + 'e' + decimals) + 'e-' + decimals);
          }
                    // Helper function to check if value is numeric
          function isNumeric(value) {
            return !isNaN(parseFloat(value)) && isFinite(value);
          }
      
          // Process raw data for equal variance
          function processRawData(dataString, option, ronding) {
            const stdv_txt = dataString.split(',').map(v => v.trim()).filter(v => v);
            const countn = stdv_txt.length;
            
            // Validate data
            for (let value of stdv_txt) {
              if (!isNumeric(value)) {
                return { error: "Please! Check Your Input" };
              }
            }
            
            if (stdv_txt.length < 2) {
              return { error: "Please! Check Your Input" };
            }
      
            const i = stdv_txt.length;
            const numericData = stdv_txt.map(v => parseFloat(v));
            const sum = numericData.reduce((a, b) => a + b, 0);
            const m = round(sum / i, 3);
            
            let d = 0;
            for (let value of numericData) {
              d += Math.pow(value - m, 2);
            }
            
            const s_d = (1 / i) * d;
            const mSym = 'x̄';
            
            // Build table
            let table = `<table class='w-100 font-s-18' style='border-collapse: collapse'><thead><tr class='bg-gray'><th class='border p-2 text-center text-blue'>xᵢ</th><th class='border p-2 text-center text-blue'>(xᵢ - ${mSym})</th><th class='border p-2 text-center text-blue'>(xᵢ - ${mSym})²</th></tr></thead><tbody>`;
            
            let ar_sum = 0;
            for (let value of numericData) {
              const diff = value - m;
              const diffSq = Math.pow(diff, 2);
              ar_sum += diffSq;
              table += `<tr class="bg-white"><td class="border p-2 text-center">${value}</td><td class="border p-2 text-center">${diff}</td><td class="border p-2 text-center">${diffSq}</td></tr>`;
            }
            
            table += `<tr class='bg-gray'><th class='border p-2 text-center text-blue'>Σxᵢ = ${sum}</th><th class='border p-2 text-center text-blue'> </th><th class='border p-2 text-center text-blue'>Σ(xᵢ - ${mSym})² = ${ar_sum}</th></tr></tbody></table>`;
            
            const vrres = i - 1;
            const v = ar_sum / vrres;
            const vsqrt = round(Math.sqrt(v), ronding);
            const s12 = Math.pow(vsqrt, 2);
            const ress12 = vrres * s12;
            const devn1 = 1 / i;
            
            return {
              i, v, sum, table, ar_sum, vsqrt, vrres, s12, ress12, devn1, countn,
              i1: i, v1: v, sum1: sum, table1: table, ar_sum1: ar_sum,
              vsqrt1: vsqrt, vrres1: vrres, s22: s12, ress22: ress12,
              devn12: devn1, countn1: countn
            };
          }
      
          // Process raw data for unequal variance
          function processRawDataUnequal(dataString, ronding) {
            const stdv_txt = dataString.split(',').map(v => v.trim()).filter(v => v);
            const countn = stdv_txt.length;
            
            // Validate data
            for (let value of stdv_txt) {
              if (!isNumeric(value)) {
                return { error: "Please! Check Your Input" };
              }
            }
            
            if (stdv_txt.length < 2) {
              return { error: "Please! Check Your Input" };
            }
      
            const i = stdv_txt.length;
            const numericData = stdv_txt.map(v => parseFloat(v));
            const sum = numericData.reduce((a, b) => a + b, 0);
            const m = round(sum / i, 3);
            
            let d = 0;
            for (let value of numericData) {
              d += Math.pow(value - m, 2);
            }
            
            const s_d = (1 / i) * d;
            const mSym = 'x̄';
            
            // Build table
            let table = `<table class='w-100 font-s-18' style='border-collapse: collapse'><thead><tr class='bg-gray'><th class='border p-2 text-center text-blue'>xᵢ</th><th class='border p-2 text-center text-blue'>(xᵢ - ${mSym})</th><th class='border p-2 text-center text-blue'>(xᵢ - ${mSym})²</th></tr></thead><tbody>`;
            
            let ar_sum = 0;
            for (let value of numericData) {
              const diff = value - m;
              const diffSq = Math.pow(diff, 2);
              ar_sum += diffSq;
              table += `<tr class="bg-white"><td class="border p-2 text-center">${value}</td><td class="border p-2 text-center">${diff}</td><td class="border p-2 text-center">${diffSq}</td></tr>`;
            }
            
            table += `<tr class='bg-gray'><th class='border p-2 text-center text-blue'>Σxᵢ = ${sum}</th><th class='border p-2 text-center text-blue'> </th><th class='border p-2 text-center text-blue'>Σ(xᵢ - ${mSym})² = ${ar_sum}</th></tr></tbody></table>`;
            
            const vrres = i - 1;
            const pi = Math.pow(i, 2);
            const v = ar_sum / vrres;
            const vsqrt = round(Math.sqrt(v), ronding);
            const s12 = Math.pow(vsqrt, 2);
            const s124 = Math.pow(vsqrt, 4);
            const vsqi = s12 / i;
            const ress12 = vrres * s12;
            const pivr = pi * vrres;
            const devn1 = s124 / pivr;
            
            return {
              i, v, sum, table, ar_sum, vsqrt, vrres, s12, s124, vsqi, ress12, devn1, countn, pi, pivr,
              i1: i, v1: v, sum1: sum, table1: table, ar_sum1: ar_sum,
              vsqrt1: vsqrt, vrres1: vrres, s22: s12, s224: s124, vsqi1: vsqi,
              ress22: ress12, devn12: devn1, countn1: countn, pi1: pi, pivr1: pivr
            };
      
      
          }
    }

       /**
   * getCalculationSampleDistributionCalculator: Service Method
   * POST: /api/calculators-lol/sample-distribution-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async getCalculationSampleDistributionCalculator(body) {
        let mean = body.tech_mean;
        let deviation = body.tech_deviation;
        let size = body.tech_size;
        let probability = body.tech_probability;
        let x1 = body.tech_x1;
        let x2 = body.tech_x2;
        // Convert string values to numbers
        mean = parseFloat(mean);
        deviation = parseFloat(deviation);
        size = parseFloat(size);
        x1 = parseFloat(x1);
        x2 = x2 ? parseFloat(x2) : x2;

        // Helper function: Check if numeric
        function isNumeric(value) {
            return value !== null && value !== undefined && value !== '' && !isNaN(parseFloat(value)) && isFinite(value);
        }

        // Helper function: Significant figures
        function sigFig(value, digits) {
            if (value === '' || value === null || value === undefined) {
                return value;
            }
            
            let decimalPlaces;
            if (value === 0) {
                decimalPlaces = digits - 1;
            } else if (value < 0) {
                decimalPlaces = digits - Math.floor(Math.log10(Math.abs(value))) - 1;
            } else {
                decimalPlaces = digits - Math.floor(Math.log10(value)) - 1;
            }
            
            return parseFloat(value.toFixed(decimalPlaces));
        }

        // Helper function: Error function (erf)
        function erf(x) {
            const a1 = 0.254829592;
            const a2 = -0.284496736;
            const a3 = 1.421413741;
            const a4 = -1.453152027;
            const a5 = 1.061405429;
            const p = 0.3275911;

            const sign = x >= 0 ? 1 : -1;
            x = Math.abs(x);

            const t = 1.0 / (1.0 + p * x);
            let y = ((((a5 * t + a4) * t) + a3) * t + a2) * t + a1;
            y = y * t;
            y = 1.0 - (y * Math.exp(-x * x));

            return sign * y;
        }

        // Helper function: Standard Normal CDF
        function standardNormalCDF(z) {
            return 0.5 * (1 + erf(z / Math.sqrt(2)));
        }

        // Helper function: Normal PDF
        function normalPDF(x, mu, sigma) {
            return Math.exp(-0.5 * Math.pow((x - mu) / sigma, 2)) / (sigma * Math.sqrt(2 * Math.PI));
        }

        // Validation
        if (!isNumeric(mean) || !isNumeric(deviation) || 
            !isNumeric(size) || !probability || !isNumeric(x1)) {
            return { error: "Please! Check Your Input" };
        }

        const result = {};
        const sd = deviation / Math.sqrt(size);
        const standard_error = parseFloat(sd.toFixed(4));
        const zl = (x1 - mean) / sd;
        const pr2 = standardNormalCDF(zl);

        const a = mean - 6 * sd;
        const b = mean + 6 * sd;
        const step = 0.058;

        let chartData = [];
        let chartData2 = [];

        if (probability === 'two_tailed') {
            if (!isNumeric(x2)) {
                return { error: "Please! Check Your Input" };
            }
              // console.log(x2,mean,deviation,size);
            const zu = (x2 - mean) / sd;
            const pr1 = standardNormalCDF(zu);
            const pr = pr1 - pr2;

            if (x1 > x2) {
                return { error: "X₂ must be greater than X₁" };
            }

            // Clamp x1 and x2 to bounds
            let x1Clamped = x1;
            let x2Clamped = x2;
            
            if (x1Clamped > b) x1Clamped = b;
            if (x1Clamped < a) x1Clamped = a;
            if (x2Clamped > b) x2Clamped = b;
            if (x2Clamped < a) x2Clamped = a;

            // Generate chart data for left tail
            for (let i = a; i <= x1Clamped; i += step) {
                const xVal = sigFig(i, 5);
                const yVal = normalPDF(i, mean, sd);
                chartData.push([xVal, yVal, '', '', '', '', '', '', '', '', '']);
            }

            // Generate chart data for middle (shaded area)
            for (let i = x1Clamped; i <= x2Clamped; i += step) {
                const xVal = sigFig(i, 5);
                const yVal = normalPDF(i, mean, sd);
                chartData.push([xVal, '', '', '', '', '', '', '', '', '', yVal]);
            }

            // Generate chart data for right tail
            for (let i = x2Clamped; i <= b; i += step) {
                const xVal = sigFig(i, 5);
                const yVal = normalPDF(i, mean, sd);
                chartData.push([xVal, yVal, '', '', '', '', '', '', '', '', '']);
            }

            // Generate chartData2 (shaded area only)
            for (let i = x1Clamped; i <= x2Clamped; i += step) {
                const xVal = sigFig(i, 5);
                const yVal = normalPDF(i, mean, sd);
                chartData2.push([xVal, yVal, '', '', '', '', '', '', '', '', '']);
            }

            result.tech_zu = zu;
            result.tech_pr = pr;
            result.tech_pr1 = pr1;

        } else if (probability === 'left_tailed') {
            let x1Clamped = x1;
            if (x1Clamped > b) x1Clamped = b;
            if (x1Clamped < a) x1Clamped = a;

            // Generate chart data for left tail (shaded)
            for (let i = a; i <= x1Clamped; i += step) {
                const xVal = parseFloat(sigFig(i, 5));
                const yVal = parseFloat(normalPDF(i, mean, sd));
                chartData.push([xVal, yVal]);
            }

            // Generate chart data for right tail (unshaded)
            for (let i = x1Clamped; i <= b; i += step) {
                const xVal = parseFloat(sigFig(i, 5));
                const yVal = parseFloat(normalPDF(i, mean, sd));
                chartData.push([xVal, yVal]);
            }

            // Generate chartData2 (shaded area only)
            for (let i = a; i <= x1Clamped; i += step) {
                const xVal = sigFig(i, 5);
                const yVal = normalPDF(i, mean, sd);
                chartData2.push([xVal, yVal]);
            }

        } else { // right_tailed
            let x1Clamped = x1;
            if (x1Clamped > b) x1Clamped = b;
            if (x1Clamped < a) x1Clamped = a;

            // Generate chart data for left tail (unshaded)
            for (let i = a; i <= x1Clamped; i += step) {
                const xVal = sigFig(i, 5);
                const yVal = normalPDF(i, mean, sd);
                chartData.push([xVal, yVal]);
            }

            // Generate chart data for right tail (shaded)
            for (let i = x1Clamped; i <= b; i += step) {
                const xVal = sigFig(i, 5);
                const yVal = normalPDF(i, mean, sd);
                chartData.push([xVal, yVal]);
            }

            // Generate chartData2 (shaded area only)
            for (let i = a; i <= x1Clamped; i += step) {
                const xVal = sigFig(i, 5);
                const yVal = normalPDF(i, mean, sd);
                chartData2.push([xVal, yVal]);
            }
        }

        // Build result object - return original string values like Laravel
        result.tech_standard_error = standard_error;
        result.tech_mean = body.mean;  // Original string value
        result.tech_deviation = body.deviation;  // Original string value
        result.tech_probability = probability;
        result.tech_size = body.size;  // Original string value
        result.tech_x1 = body.x1;  // Original string value
        result.tech_x2 = body.x2;  // Original string value
        result.tech_sd = sd;
        result.tech_zl = zl;
        result.tech_pr2 = pr2;
        result.tech_chartData = chartData;
        result.tech_chartData2 = chartData2;

        return result;
}



    /**
   * getCalculationNormalCriticalValueCalculator: Service Method
   * POST: /api/calculators-lol/critical-value-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
async getCalculationNormalCriticalValueCalculator(body) {
  const submit = body.tech_calculator_name;
  const first = body.tech_first;
  const second = body.tech_second;
  const third = body.tech_third;
  const Pi = 3.1415926535898;
  const PiD2 = Pi / 2;
  const PiD4 = Pi / 4;
  const Pi2 = 2 * Pi;
  const pi2 = Pi / 2;
  const e = 2.718281828459045235;
  const e10 = 1.105170918075647625;
  const Deg = 180 / Pi;
  
  const param = {};

  function resConvert(a) {
    return a >= 0 ? a + 0.0000 : a - 0.0000;
  }

  function stuT(a, b) {
    a = Math.abs(a);
    const c = a / Math.sqrt(b);
    const d = Math.atan(c);
    const pi2 = 3.1415926535898 / 2;
    
    if (1 === b) {
      return d / pi2;
    }
    
    const e = Math.sin(d);
    const f = Math.cos(d);
    const alpha = b % 2 === 1 
      ? 1 - (d + e * f * stuComp(f * f, 2, b - 3, -1)) / pi2 
      : 1 - e * stuComp(f * f, 1, b - 3, -1);
    const alpha2 = 1 - alpha;
    return alpha2;
  }

  function pStuT(a, b) {
    let c = 0.5;
    let d = 0.5;
    let e = 0;
    
    while (d > 0.000001) {
      e = 1 / c - 1;
      d /= 2;
      const qt = 1 - stuT(e, b);
      qt > a ? (c -= d) : (c += d);
    }
    
    return e;
  }

  function stuComp(a, b, c, d) {
    let e = 1;
    let f = e;
    let g = b;
    
    while (g <= c) {
      e = (e * a * g) / (g - d);
      f += e;
      g += 2;
    }
    return f;
  }

  function parseConv(a) {
    return parseFloat(a);
  }

  function easyRoundOf(a, b) {
    if (isNaN(a)) return 0;
    b = Math.pow(10, parseConv(b));
    const c = Math.round(parseConv(a) * b) / b;
    return isNaN(c) ? 0 : c;
  }

  function tcritical(first, third) {
    const a2b = first * 2;
    const a1result = resConvert(pStuT(a2b, third));
    const a2result = resConvert(pStuT(first, third));
    let rloop = 15;
    
    if (third < 15) {
      rloop = third;
    }
    
    const nloop = Math.ceil(third / rloop);
    let dat1 = " ";
    let dat2 = "";
    let dat3 = "";
    let dat2Cus = "";
    
    // Calculate the final values first
    const finalDf = third;
    const finalA1 = easyRoundOf(resConvert(pStuT(a2b, finalDf)), 4);
    const finalA2 = easyRoundOf(resConvert(pStuT(first, finalDf)), 4);
    
    dat1 = " " + finalA1;
    dat3 = " - " + finalA1;
    dat2 = " ± " + finalA2;
    dat2Cus = finalA2;
    
    // One Tailed Table
    let a1tbl = `<p class="col-12 mt-2 font-s-18 text-blue"> One Tailed Probability of ${first}</p> <div class="col-12 overflow-auto"><table class="w-100" style="border-collapse: collapse">`;
    
    for (let i = 1; i <= rloop; i++) {
      if (i === 1) {
        a1tbl += "<tr class='bg-gray'>";
        for (let j = 1; j <= nloop; j++) {
          a1tbl += "<td class='p-2 border text-center text-blue'> df </td> <th class='p-2 border text-center text-blue'> &alpha; </th>";
        }
        a1tbl += "</tr>";
      }
      
      a1tbl += '<tr class="bg-white">';
      for (let j = 1; j <= nloop; j++) {
        const df1 = (j - 1) * 15 + i;
        if (df1 > third) {
          a1tbl += "<td colspan='2' class='p-2 border text-center'> </td>";
        } else {
          const a1 = easyRoundOf(resConvert(pStuT(a2b, df1)), 4);
          if (df1 === third) {
            a1tbl += `<th class='p-2 border text-center' style='background-color: #0072b7;color: white;'>${df1}</th> <td class='p-2 border text-center' style='background-color: #0072b7;color: white;'>${a1}</td>`;
          } else {
            a1tbl += `<th class='p-2 border text-center'>${df1}</th> <td class='p-2 border text-center'>${a1}</td>`;
          }
        }
      }
      a1tbl += "</tr>";
    }
    a1tbl += "</table></div>";
    
    // Two Tailed Table
    let a2tbl = `<p class="col-12 mt-2 font-s-18 text-blue"> Two Tailed Probability of ${first}</p> <div class="col-12 overflow-auto"><table class="w-100" style="border-collapse: collapse">`;
    
    for (let i = 1; i <= rloop; i++) {
      if (i === 1) {
        a2tbl += "<tr class='bg-gray'>";
        for (let j = 1; j <= nloop; j++) {
          a2tbl += "<td class='p-2 border text-center text-blue'> df </td> <td class='p-2 border text-center text-blue'> &alpha; </td>";
        }
        a2tbl += "</tr>";
      }
      
      a2tbl += '<tr class="bg-white">';
      for (let j = 1; j <= nloop; j++) {
        const df2 = (j - 1) * 15 + i;
        if (df2 > third) {
          a2tbl += "<td colspan='2' class='p-2 border text-center'> </td>";
        } else {
          const a1 = easyRoundOf(resConvert(pStuT(first, df2)), 4);
          if (df2 === third) {
            a2tbl += `<td class='p-2 border text-center' style='background-color: #0072b7;color: white;'>${df2}</td> <td class='p-2 border text-center' style='background-color: #0072b7;color: white;'>${a1}</td>`;
          } else {
            a2tbl += `<td class='p-2 border text-center'>${df2}</td> <td class='p-2 border text-center'>${a1}</td>`;
          }
        }
      }
      a2tbl += "</tr>";
    }
    a2tbl += "</table></div>";
    
    return [dat1, dat3, dat2, a1tbl, a2tbl];
  }

  // Z Critical Value Functions
  function log_10(n) {
    return Math.log(n) / Math.log(10);
  }

  function round_to_precision(x, p) {
    x = x * Math.pow(10, p);
    x = Math.round(x);
    return x / Math.pow(10, p);
  }

  function integer(i) {
    if (i > 0) return Math.floor(i);
    else return Math.ceil(i);
  }

  function precision(x) {
    const SIGNIFICANT = 8;
    return Math.abs(integer(log_10(Math.abs(x)) - SIGNIFICANT));
  }

  function poz(z) {
    const Z_MAX = 6;
    let x;
    
    if (z === 0.0) {
      x = 0.0;
    } else {
      const y = 0.5 * Math.abs(z);
      if (y > Z_MAX * 0.5) {
        x = 1.0;
      } else if (y < 1.0) {
        const w = y * y;
        x = ((((((((0.000124818987 * w - 0.001075204047) * w +
          0.005198775019) * w - 0.019198292004) * w +
          0.059054035642) * w - 0.151968751364) * w +
          0.319152932694) * w - 0.5319230073) * w +
          0.797884560593) * y * 2.0;
      } else {
        const y2 = y - 2.0;
        x = (((((((((((((-0.000045255659 * y2 + 0.00015252929) * y2 -
          0.000019538132) * y2 - 0.000676904986) * y2 +
          0.001390604284) * y2 - 0.00079462082) * y2 -
          0.002034254874) * y2 + 0.006549791214) * y2 -
          0.010557625006) * y2 + 0.011630447319) * y2 -
          0.009279453341) * y2 + 0.005353579108) * y2 -
          0.002141268741) * y2 + 0.000535310849) * y2 +
          0.999936657524;
      }
    }
    return z > 0.0 ? (x + 1.0) * 0.5 : (1.0 - x) * 0.5;
  }

  function criva(p) {
    const Z_MAX = 6;
    const Z_EPSILON = 0.000001;
    let minz = -Z_MAX;
    let maxz = Z_MAX;
    let zval = 0.0;
    let pval = '';
    
    if (p < 0.0 || p > 1.0) {
      return -1;
    }
    
    while (maxz - minz > Z_EPSILON) {
      pval = poz(zval);
      if (pval > p) {
        maxz = zval;
      } else {
        minz = zval;
      }
      zval = (maxz + minz) * 0.5;
    }
    return zval;
  }

  function erf(x) {
    const cof = [
      -1.3026537197817094, 0.6419697923564902, 0.019476473204185836,
      -0.00956151478680863, -0.000946595344482036, 0.000366839497852761,
      42523324806907e-18, -20278578112534e-18, -1624290004647e-18,
      130365583558e-17, 1.5626441722e-8, -8.5238095915e-8,
      6.529054439e-9, 5.059343495e-9, -9.91364156e-10,
      -2.27365122e-10, 96467911e-18, 2394038e-18,
      -6886027e-18, 894487e-18, 313092e-18,
      -112708e-18, 381e-18, 7106e-18,
      -1523e-18, -94e-18, 121e-18, -28e-18
    ];
    
    let j = cof.length - 1;
    let isneg = false;
    let d = 0;
    let dd = 0;
    
    if (x < 0) {
      x = -x;
      isneg = true;
    }
    
    const t = 2 / (2 + x);
    const ty = 4 * t - 2;
    
    for (; j > 0; j--) {
      const tmp = d;
      d = ty * d - dd + cof[j];
      dd = tmp;
    }
    
    const res = t * Math.exp(-x * x + 0.5 * (cof[0] + ty * d) - dd);
    return isneg ? res - 1 : 1 - res;
  }

  function erfc(x) {
    return 1 - erf(x);
  }

  function erfcinv(p) {
    let j = 0;
    
    if (p >= 2) return -100;
    if (p <= 0) return 100;
    
    const pp = p < 1 ? p : 2 - p;
    const t = Math.sqrt(-2 * Math.log(pp / 2));
    let x = -0.70711 *
      ((2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t);
    
    for (; j < 2; j++) {
      const err = erfc(x) - pp;
      x += err / (1.1283791670955126 * Math.exp(-x * x) - x * err);
    }
    
    return p < 1 ? x : -x;
  }

  function normal__inv(p, mean, std) {
    return -1.4142135623730951 * std * erfcinv(2 * p) + mean;
  }

  function zcritical(first) {
    const left__z__val = normal__inv(1 - first, 0, 1);
    const right__z__val = normal__inv(first, 0, 1);
    const z_two_tailed_value = normal__inv(first / 2, 0, 1);
    const z_two_tailed_neg_value = normal__inv(1 - first / 2, 0, 1);
    let z_val = Math.abs(criva(first));
    const answer = round_to_precision(z_two_tailed_value, precision(z_two_tailed_value)) + 
      " & " + round_to_precision(z_two_tailed_neg_value, precision(z_two_tailed_neg_value));
    
    if (first === 0) {
      z_val = "-Inf";
    }
    if (first === 1) {
      z_val = "Inf";
    }
    
    return [left__z__val, right__z__val, z_val, answer];
  }

  // Main Logic
  if (submit === "t_val") {
    if (!isNaN(first) && !isNaN(third)) {
      if (first >= 0 && first <= 0.5) {
        const t_jawab = tcritical(first, third);
        param.tech_t_jawab = t_jawab;
      } else {  
        param.error = "Enter Significant Level between 0 to 0.5";
        return param;
      }
    } else {
      param.error = "Please! Check Your Input";
      return param;
    }
  } else if (submit === "z_val") {
    if (!isNaN(first)) {
      if (first >= 0 && first <= 1) {
        const z_jawab = zcritical(first);
        param.tech_z_jawab = z_jawab;
      } else {
        param.error = "Enter Significant Level between 0 to 1";
        return param;
      }
    } else {
      param.error = "Please! Check Your Input";
      return param;
    }
  } else if (submit === "chi_val") {
    if (!isNaN(first) && !isNaN(third)) {
      if (first >= 0 && first <= 0.5) {
        param.tech_value = first;
        param.tech_degree = third;
      } else {
        param.error = "Enter Significant Level between 0 to 0.5";
        return param;
      }
    } else {
      param.error = "Please! Check Your Input";
      return param;
    }
  } else if (submit === "f_val") {
    if (!isNaN(first) && !isNaN(second) && !isNaN(third)) {
      if (first >= 0 && first <= 0.5) {
        if (second > 0) {
          if (third > 0) {
            param.tech_first = first;
            param.tech_second = second;
            param.tech_third = third;
          } else {
            param.error = "Degrees of Freedom Denominator greater than zero";
            return param;
          }
        } else {
          param.error = "Degrees of Freedom Numerator greater than zero";
          return param;
        }
      } else {
        param.error = "Enter Significant Level between 0 to 0.5";
        return param;
      }
    } else {
      param.error = "Please! Check Your Input";
      return param;
    }
  } else if (submit === "r_val") {
    if (!isNaN(first) && !isNaN(third)) {
      if (first >= 0 && first <= 0.5) {
        param.tech_value = first;
        param.tech_degree = third;
      } else {
        param.error = "Enter Significant Level between 0 to 0.5";
        return param;
      }
    } else {
      param.error = "Please! Check Your Input";
      return param;
    }
  }
  
  param.tech_submit = submit;
  
  return param;
}
 

     /**
   * getCalculationNormalDistributionCalculator: Service Method
   * POST: /api/calculators-lol/normal-distribution-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async getCalculationNormalDistributionCalculator(body) {
           let operations = body.tech_operations;
          let find_compare = body.tech_find_compare;
          let f_first = body.tech_f_first;
          let f_second = body.tech_f_second;
          let f_third = body.tech_f_third;
          let mean = body.tech_mean;
          let deviation = body.tech_deviation;
          let a = body.tech_a;
          let b = body.tech_b;
          let c = body.tech_c;
          let d = body.tech_d;
          let e1 = body.tech_e1;
          let e2 = body.tech_e2;
          let f = body.tech_f;

        const param = {};
      if (parseFloat(c) <= 0 || parseFloat(c) >= 1 || parseFloat(d) <= 0 || parseFloat(d) >= 1 || parseFloat(f) <= 0 || parseFloat(f) >= 1) {
        param.error = "Probability must be between 0 and 1";
        return param;
      }
    

    // Z-table data (same as before)
      const z_table = {
         '-4.0': { 9: 0.00002, 8: 0.00002, 7: 0.00002, 6: 0.00002, 5: 0.00003, 4: 0.00003, 3: 0.00003, 2: 0.00003, 1: 0.00003, 0: 0.00003 },
         '-3.9': { 9: 0.00003, 8: 0.00003, 7: 0.00004, 6: 0.00004, 5: 0.00004, 4: 0.00004, 3: 0.00004, 2: 0.00004, 1: 0.00005, 0: 0.00005 },
         '-3.8': { 9: 0.00005, 8: 0.00005, 7: 0.00005, 6: 0.00006, 5: 0.00006, 4: 0.00006, 3: 0.00006, 2: 0.00007, 1: 0.00007, 0: 0.00007 },
         '-3.7': { 9: 0.00008, 8: 0.00008, 7: 0.00008, 6: 0.00008, 5: 0.00009, 4: 0.00009, 3: 0.00010, 2: 0.00010, 1: 0.00010, 0: 0.00011 },
         '-3.6': { 9: 0.00011, 8: 0.00012, 7: 0.00012, 6: 0.00013, 5: 0.00013, 4: 0.00014, 3: 0.00014, 2: 0.00015, 1: 0.00015, 0: 0.00016 },
         '-3.5': { 9: 0.00017, 8: 0.00017, 7: 0.00018, 6: 0.00019, 5: 0.00019, 4: 0.00020, 3: 0.00021, 2: 0.00022, 1: 0.00022, 0: 0.00023 },
         '-3.4': { 9: 0.00024, 8: 0.00025, 7: 0.00026, 6: 0.00027, 5: 0.00028, 4: 0.00029, 3: 0.00030, 2: 0.00031, 1: 0.00032, 0: 0.00034 },
         '-3.3': { 9: 0.00035, 8: 0.00036, 7: 0.00038, 6: 0.00039, 5: 0.00040, 4: 0.00042, 3: 0.00043, 2: 0.00045, 1: 0.00047, 0: 0.00048 },
         '-3.2': { 9: 0.00050, 8: 0.00052, 7: 0.00054, 6: 0.00056, 5: 0.00058, 4: 0.00060, 3: 0.00062, 2: 0.00064, 1: 0.00066, 0: 0.00069 },
         '-3.1': { 9: 0.00071, 8: 0.00074, 7: 0.00076, 6: 0.00079, 5: 0.00082, 4: 0.00084, 3: 0.00087, 2: 0.00090, 1: 0.00094, 0: 0.00097 },
         '-3.0': { 9: 0.00100, 8: 0.00104, 7: 0.00107, 6: 0.00111, 5: 0.00114, 4: 0.00118, 3: 0.00122, 2: 0.00126, 1: 0.00131, 0: 0.00135 },
         '-2.9': { 9: 0.00139, 8: 0.00144, 7: 0.00149, 6: 0.00154, 5: 0.00159, 4: 0.00164, 3: 0.00169, 2: 0.00175, 1: 0.00181, 0: 0.00187 },
         '-2.8': { 9: 0.00193, 8: 0.00199, 7: 0.00205, 6: 0.00212, 5: 0.00219, 4: 0.00226, 3: 0.00233, 2: 0.00240, 1: 0.00248, 0: 0.00256 },
         '-2.7': { 9: 0.00264, 8: 0.00272, 7: 0.00280, 6: 0.00289, 5: 0.00298, 4: 0.00307, 3: 0.00317, 2: 0.00326, 1: 0.00336, 0: 0.00347 },
         '-2.6': { 9: 0.00357, 8: 0.00368, 7: 0.00379, 6: 0.00391, 5: 0.00402, 4: 0.00415, 3: 0.00427, 2: 0.00440, 1: 0.00453, 0: 0.00466 },
         '-2.5': { 9: 0.00480, 8: 0.00494, 7: 0.00508, 6: 0.00523, 5: 0.00539, 4: 0.00554, 3: 0.00570, 2: 0.00587, 1: 0.00604, 0: 0.00621 },
         '-2.4': { 9: 0.00639, 8: 0.00657, 7: 0.00676, 6: 0.00695, 5: 0.00714, 4: 0.00734, 3: 0.00755, 2: 0.00776, 1: 0.00798, 0: 0.00820 },
         '-2.3': { 9: 0.00842, 8: 0.00866, 7: 0.00889, 6: 0.00914, 5: 0.00939, 4: 0.00964, 3: 0.00990, 2: 0.01017, 1: 0.01044, 0: 0.01072 },
         '-2.2': { 9: 0.01101, 8: 0.01130, 7: 0.01160, 6: 0.01191, 5: 0.01222, 4: 0.01255, 3: 0.01287, 2: 0.01321, 1: 0.01355, 0: 0.01390 },
         '-2.1': { 9: 0.01426, 8: 0.01463, 7: 0.01500, 6: 0.01539, 5: 0.01578, 4: 0.01618, 3: 0.01659, 2: 0.01700, 1: 0.01743, 0: 0.01786 },
         '-2.0': { 9: 0.01831, 8: 0.01876, 7: 0.01923, 6: 0.01970, 5: 0.02018, 4: 0.02068, 3: 0.02118, 2: 0.02169, 1: 0.02222, 0: 0.02275 },
         '-1.9': { 9: 0.02330, 8: 0.02385, 7: 0.02442, 6: 0.02500, 5: 0.02559, 4: 0.02619, 3: 0.02680, 2: 0.02743, 1: 0.02807, 0: 0.02872 },
         '-1.8': { 9: 0.02938, 8: 0.03005, 7: 0.03074, 6: 0.03144, 5: 0.03216, 4: 0.03288, 3: 0.03362, 2: 0.03438, 1: 0.03515, 0: 0.03593 },
         '-1.7': { 9: 0.03673, 8: 0.03754, 7: 0.03836, 6: 0.03920, 5: 0.04006, 4: 0.04093, 3: 0.04182, 2: 0.04272, 1: 0.04363, 0: 0.04457 },
         '-1.6': { 9: 0.04551, 8: 0.04648, 7: 0.04746, 6: 0.04846, 5: 0.04947, 4: 0.05050, 3: 0.05155, 2: 0.05262, 1: 0.05370, 0: 0.05480 },
         '-1.5': { 9: 0.0559, 8: 0.0571, 7: 0.0582, 6: 0.0594, 5: 0.0606, 4: 0.0618, 3: 0.0630, 2: 0.0643, 1: 0.0655, 0: 0.0668 },
         '-1.4': { 9: 0.0681, 8: 0.0694, 7: 0.0708, 6: 0.0721, 5: 0.0735, 4: 0.0749, 3: 0.0764, 2: 0.0778, 1: 0.0793, 0: 0.0808 },
         '-1.3': { 9: 0.0823, 8: 0.0838, 7: 0.0853, 6: 0.0869, 5: 0.0885, 4: 0.0901, 3: 0.0918, 2: 0.0934, 1: 0.0951, 0: 0.0968 },
         '-1.2': { 9: 0.0985, 8: 0.1003, 7: 0.1020, 6: 0.1038, 5: 0.1056, 4: 0.1075, 3: 0.1093, 2: 0.1112, 1: 0.1131, 0: 0.1151 },
         '-1.1': { 9: 0.1170, 8: 0.1190, 7: 0.1210, 6: 0.1230, 5: 0.1251, 4: 0.1271, 3: 0.1292, 2: 0.1314, 1: 0.1335, 0: 0.1357 },
         '-1.0': { 9: 0.1379, 8: 0.1401, 7: 0.1423, 6: 0.1446, 5: 0.1469, 4: 0.1492, 3: 0.1515, 2: 0.1539, 1: 0.1562, 0: 0.1587 },
         '-0.9': { 9: 0.1611, 8: 0.1635, 7: 0.1660, 6: 0.1685, 5: 0.1711, 4: 0.1736, 3: 0.1762, 2: 0.1788, 1: 0.1814, 0: 0.1841 },
         '-0.8': { 9: 0.1867, 8: 0.1894, 7: 0.1922, 6: 0.1949, 5: 0.1977, 4: 0.2005, 3: 0.2033, 2: 0.2061, 1: 0.2090, 0: 0.2119 },
         '-0.7': { 9: 0.2148, 8: 0.2177, 7: 0.2206, 6: 0.2236, 5: 0.2266, 4: 0.2296, 3: 0.2327, 2: 0.2358, 1: 0.2389, 0: 0.2420 },
         '-0.6': { 9: 0.2451, 8: 0.2483, 7: 0.2514, 6: 0.2546, 5: 0.2578, 4: 0.2611, 3: 0.2643, 2: 0.2676, 1: 0.2709, 0: 0.2743 },
         '-0.5': { 9: 0.2776, 8: 0.2810, 7: 0.2843, 6: 0.2877, 5: 0.2912, 4: 0.2946, 3: 0.2981, 2: 0.3015, 1: 0.3050, 0: 0.3085 },
         '-0.4': { 9: 0.3121, 8: 0.3156, 7: 0.3192, 6: 0.3228, 5: 0.3264, 4: 0.3300, 3: 0.3336, 2: 0.3372, 1: 0.3409, 0: 0.3446 },
         '-0.3': { 9: 0.3483, 8: 0.3520, 7: 0.3557, 6: 0.3594, 5: 0.3632, 4: 0.3669, 3: 0.3707, 2: 0.3745, 1: 0.3783, 0: 0.3821 },
         '-0.2': { 9: 0.3829, 8: 0.3897, 7: 0.3936, 6: 0.3974, 5: 0.4013, 4: 0.4052, 3: 0.4090, 2: 0.4129, 1: 0.4168, 0: 0.4207 },
         '-0.1': { 9: 0.4247, 8: 0.4286, 7: 0.4325, 6: 0.4364, 5: 0.4404, 4: 0.4443, 3: 0.4483, 2: 0.4522, 1: 0.4562, 0: 0.4602 },
         '-0.0': { 9: 0.4641, 8: 0.4681, 7: 0.4721, 6: 0.4761, 5: 0.4801, 4: 0.4840, 3: 0.4880, 2: 0.4920, 1: 0.4960, 0: 0.5000 },
         '0.0': { 0: 0.50000, 1: 0.50399, 2: 0.50798, 3: 0.51197, 4: 0.51595, 5: 0.51994, 6: 0.52392, 7: 0.52790, 8: 0.53188, 9: 0.53586 },
         '0.1': { 0: 0.53980, 1: 0.54380, 2: 0.54776, 3: 0.55172, 4: 0.55567, 5: 0.55966, 6: 0.56360, 7: 0.56749, 8: 0.57142, 9: 0.57535 },
         '0.2': { 0: 0.57930, 1: 0.58317, 2: 0.58706, 3: 0.59095, 4: 0.59483, 5: 0.59871, 6: 0.60257, 7: 0.60642, 8: 0.61026, 9: 0.61409 },
         '0.3': { 0: 0.61791, 1: 0.62172, 2: 0.62552, 3: 0.62930, 4: 0.63307, 5: 0.63683, 6: 0.64058, 7: 0.64431, 8: 0.64803, 9: 0.65173 },
         '0.4': { 0: 0.65542, 1: 0.65910, 2: 0.66276, 3: 0.66640, 4: 0.67003, 5: 0.67364, 6: 0.67724, 7: 0.68082, 8: 0.68439, 9: 0.68793 },
         '0.5': { 0: 0.69146, 1: 0.69497, 2: 0.69847, 3: 0.70194, 4: 0.70540, 5: 0.70884, 6: 0.71226, 7: 0.71566, 8: 0.71904, 9: 0.72240 },
         '0.6': { 0: 0.72575, 1: 0.72907, 2: 0.73237, 3: 0.73565, 4: 0.73891, 5: 0.74215, 6: 0.74537, 7: 0.74857, 8: 0.75175, 9: 0.75490 },
         '0.7': { 0: 0.75804, 1: 0.76115, 2: 0.76424, 3: 0.76730, 4: 0.77035, 5: 0.77337, 6: 0.77637, 7: 0.77935, 8: 0.78230, 9: 0.78524 },
         '0.8': { 0: 0.78814, 1: 0.79103, 2: 0.79389, 3: 0.79673, 4: 0.79955, 5: 0.80234, 6: 0.80511, 7: 0.80785, 8: 0.81057, 9: 0.81327 },
         '0.9': { 0: 0.81594, 1: 0.81859, 2: 0.82121, 3: 0.82381, 4: 0.82639, 5: 0.82894, 6: 0.83147, 7: 0.83398, 8: 0.83646, 9: 0.83891 },
         '1.0': { 0: 0.84134, 1: 0.84375, 2: 0.84614, 3: 0.84849, 4: 0.85083, 5: 0.85314, 6: 0.85543, 7: 0.85769, 8: 0.85993, 9: 0.86214 },
         '1.1': { 0: 0.86433, 1: 0.86650, 2: 0.86864, 3: 0.87076, 4: 0.87286, 5: 0.87493, 6: 0.87698, 7: 0.87900, 8: 0.88100, 9: 0.88298 },
         '1.2': { 0: 0.88493, 1: 0.88686, 2: 0.88877, 3: 0.89065, 4: 0.89251, 5: 0.89435, 6: 0.89617, 7: 0.89796, 8: 0.89973, 9: 0.90147 },
         '1.3': { 0: 0.90320, 1: 0.90490, 2: 0.90658, 3: 0.90824, 4: 0.90988, 5: 0.91149, 6: 0.91308, 7: 0.91466, 8: 0.91621, 9: 0.91774 },
         '1.4': { 0: 0.91924, 1: 0.92073, 2: 0.92220, 3: 0.92364, 4: 0.92507, 5: 0.92647, 6: 0.92785, 7: 0.92922, 8: 0.93056, 9: 0.93189 },
         '1.5': { 0: 0.93319, 1: 0.93448, 2: 0.93574, 3: 0.93699, 4: 0.93822, 5: 0.93943, 6: 0.94062, 7: 0.94179, 8: 0.94295, 9: 0.94408 },
         '1.6': { 0: 0.94520, 1: 0.94630, 2: 0.94738, 3: 0.94845, 4: 0.94950, 5: 0.95053, 6: 0.95154, 7: 0.95254, 8: 0.95352, 9: 0.95449 },
         '1.7': { 0: 0.95543, 1: 0.95637, 2: 0.95728, 3: 0.95818, 4: 0.95907, 5: 0.95994, 6: 0.96080, 7: 0.96164, 8: 0.96246, 9: 0.96327 },
         '1.8': { 0: 0.96407, 1: 0.96485, 2: 0.96562, 3: 0.96638, 4: 0.96712, 5: 0.96784, 6: 0.96856, 7: 0.96926, 8: 0.96995, 9: 0.97062 },
         '1.9': { 0: 0.97128, 1: 0.97193, 2: 0.97257, 3: 0.97320, 4: 0.97381, 5: 0.97441, 6: 0.97500, 7: 0.97558, 8: 0.97615, 9: 0.97670 },
         '2.0': { 0: 0.97725, 1: 0.97778, 2: 0.97831, 3: 0.97882, 4: 0.97932, 5: 0.97982, 6: 0.98030, 7: 0.98077, 8: 0.98124, 9: 0.98169 },
         '2.1': { 0: 0.98214, 1: 0.98257, 2: 0.98300, 3: 0.98341, 4: 0.98382, 5: 0.98422, 6: 0.98461, 7: 0.98500, 8: 0.98537, 9: 0.98574 },
         '2.2': { 0: 0.98610, 1: 0.98645, 2: 0.98679, 3: 0.98713, 4: 0.98745, 5: 0.98778, 6: 0.98809, 7: 0.98840, 8: 0.98870, 9: 0.98899 },
         '2.3': { 0: 0.98928, 1: 0.98956, 2: 0.98983, 3: 0.99010, 4: 0.99036, 5: 0.99061, 6: 0.99086, 7: 0.99111, 8: 0.99134, 9: 0.99158 },
         '2.4': { 0: 0.99180, 1: 0.99202, 2: 0.99224, 3: 0.99245, 4: 0.99266, 5: 0.99286, 6: 0.99305, 7: 0.99324, 8: 0.99343, 9: 0.99361 },
         '2.5': { 0: 0.99379, 1: 0.99396, 2: 0.99413, 3: 0.99430, 4: 0.99446, 5: 0.99461, 6: 0.99477, 7: 0.99492, 8: 0.99506, 9: 0.99520 },
         '2.6': { 0: 0.99534, 1: 0.99547, 2: 0.99560, 3: 0.99573, 4: 0.99585, 5: 0.99598, 6: 0.99609, 7: 0.99621, 8: 0.99632, 9: 0.99643 },
         '2.7': { 0: 0.99653, 1: 0.99664, 2: 0.99674, 3: 0.99683, 4: 0.99693, 5: 0.99702, 6: 0.99711, 7: 0.99720, 8: 0.99728, 9: 0.99736 },
         '2.8': { 0: 0.99744, 1: 0.99752, 2: 0.99760, 3: 0.99767, 4: 0.99774, 5: 0.99781, 6: 0.99788, 7: 0.99795, 8: 0.99801, 9: 0.99807 },
         '2.9': { 0: 0.99813, 1: 0.99819, 2: 0.99825, 3: 0.99831, 4: 0.99836, 5: 0.99841, 6: 0.99846, 7: 0.99851, 8: 0.99856, 9: 0.99861 },
         '3.0': { 0: 0.99865, 1: 0.99869, 2: 0.99874, 3: 0.99878, 4: 0.99882, 5: 0.99886, 6: 0.99889, 7: 0.99893, 8: 0.99896, 9: 0.99900 },
         '3.1': { 0: 0.99903, 1: 0.99906, 2: 0.99910, 3: 0.99913, 4: 0.99916, 5: 0.99918, 6: 0.99921, 7: 0.99924, 8: 0.99926, 9: 0.99929 },
         '3.2': { 0: 0.99931, 1: 0.99934, 2: 0.99936, 3: 0.99938, 4: 0.99940, 5: 0.99942, 6: 0.99944, 7: 0.99946, 8: 0.99948, 9: 0.99950 },
         '3.3': { 0: 0.99952, 1: 0.99953, 2: 0.99955, 3: 0.99957, 4: 0.99958, 5: 0.99960, 6: 0.99961, 7: 0.99962, 8: 0.99964, 9: 0.99965 },
         '3.4': { 0: 0.99966, 1: 0.99968, 2: 0.99969, 3: 0.99970, 4: 0.99971, 5: 0.99972, 6: 0.99973, 7: 0.99974, 8: 0.99975, 9: 0.99976 },
         '3.5': { 0: 0.99977, 1: 0.99978, 2: 0.99978, 3: 0.99979, 4: 0.99980, 5: 0.99981, 6: 0.99981, 7: 0.99982, 8: 0.99983, 9: 0.99983 },
         '3.6': { 0: 0.99984, 1: 0.99985, 2: 0.99985, 3: 0.99986, 4: 0.99986, 5: 0.99987, 6: 0.99987, 7: 0.99988, 8: 0.99988, 9: 0.99989 },
         '3.7': { 0: 0.99989, 1: 0.99990, 2: 0.99990, 3: 0.99990, 4: 0.99991, 5: 0.99991, 6: 0.99992, 7: 0.99992, 8: 0.99992, 9: 0.99992 },
         '3.8': { 0: 0.99993, 1: 0.99993, 2: 0.99993, 3: 0.99994, 4: 0.99994, 5: 0.99994, 6: 0.99994, 7: 0.99995, 8: 0.99995, 9: 0.99995 },
         '3.9': { 0: 0.99995, 1: 0.99995, 2: 0.99996, 3: 0.99996, 4: 0.99996, 5: 0.99996, 6: 0.99996, 7: 0.99996, 8: 0.99997, 9: 0.99997 },
         '4.0': { 0: 0.99997, 1: 0.99997, 2: 0.99997, 3: 0.99997, 4: 0.99997, 5: 0.99997, 6: 0.99998, 7: 0.99998, 8: 0.99998, 9: 0.99998 }
     };

    // Helper function: zain
    const zain = (rz) => {
      const rzStr = String(rz);
      const rz_check = rzStr.split('');
      let rz_val1, rz_val2;

      if (rz_check.length > 1) {
        if (rz < 0) {
          if (rz_check.length === 2) {
            rz_val1 = `${rz_check[0]}${rz_check[1]}.0`;
            rz_val2 = 0;
          } else {
            rz_val1 = rzStr.substring(0, 4);
            rz_val2 = rzStr.length > 4 ? parseInt(rz_check[4]) : 0;
          }
        } else {
          rz_val1 = rzStr.substring(0, 3);
          rz_val2 = rzStr.length > 3 ? parseInt(rz_check[3]) : 0;
        }
      } else {
        rz_val1 = `${rz_check[0]}.0`;
        rz_val2 = 0;
      }

      let ltpv, rtpv;
      if (rz >= 4.1) {
        ltpv = 1;
        rtpv = 0;
      } else if (rz <= -4.1) {
        ltpv = 0;
        rtpv = 1;
      } else {
        ltpv = parseFloat(z_table[rz_val1]?.[rz_val2]?.toFixed(5) || 0);
        rtpv = parseFloat((1 - ltpv).toFixed(5));
      }

      const ttcl = ltpv - rtpv;
      const ttpv = 1 - Math.abs(ttcl);
      
      let z_url = getZUrl(rz);
      rz = parseFloat(rz.toFixed(4));
      return [z_url, ltpv, rtpv, ttpv, ttcl, rz];
    };

    // Helper function: getZUrl
    const getZUrl = (rz) => {
      rz = parseFloat(rz);
      if (rz < -0.126 && rz > -0.376) return 'z_score_-0.25';
      if (rz < -0.375 && rz > -0.626) return 'z_score_-0.5';
      if (rz < -0.625 && rz > -0.876) return 'z_score_-0.75';
      if (rz < -0.875 && rz > -1.126) return 'z_score_-1';
      if (rz < -1.125 && rz > -1.376) return 'z_score_-1.25';
      if (rz < -1.375 && rz > -1.626) return 'z_score_-1.5';
      if (rz < -1.625 && rz > -1.876) return 'z_score_-1.75';
      if (rz < -1.875 && rz > -2.126) return 'z_score_-2';
      if (rz < -2.125 && rz > -2.376) return 'z_score_-2.25';
      if (rz < -2.375 && rz > -2.626) return 'z_score_-2.5';
      if (rz < -2.625 && rz > -2.876) return 'z_score_-2.75';
      if (rz < -2.875 && rz > -3.126) return 'z_score_-3';
      if (rz < -3.125 && rz > -3.376) return 'z_score_-3.25';
      if (rz < -3.375 && rz > -3.626) return 'z_score_-3.5';
      if (rz < -3.625 && rz > -3.876) return 'z_score_-3.75';
      if (rz < -3.875 && rz > -4.126) return 'z_score_-4';
      if (rz < -4.125) return 'z_score_-4.25';
      if (rz > -0.126 && rz < 0.125) return 'z_score_0';
      if (rz > 0.124 && rz < 0.375) return 'z_score_0.25';
      if (rz > 0.374 && rz < 0.625) return 'z_score_0.5';
      if (rz > 0.624 && rz < 0.875) return 'z_score_0.75';
      if (rz > 0.874 && rz < 1.125) return 'z_score_1';
      if (rz > 1.124 && rz < 1.375) return 'z_score_1.25';
      if (rz > 1.374 && rz < 1.625) return 'z_score_1.5';
      if (rz > 1.624 && rz < 1.875) return 'z_score_1.75';
      if (rz > 1.874 && rz < 2.125) return 'z_score_2';
      if (rz > 2.124 && rz < 2.375) return 'z_score_2.25';
      if (rz > 2.374 && rz < 2.625) return 'z_score_2.5';
      if (rz > 2.624 && rz < 2.875) return 'z_score_2.75';
      if (rz > 2.874 && rz < 3.125) return 'z_score_3';
      if (rz > 3.124 && rz < 3.375) return 'z_score_3.25';
      if (rz > 3.374 && rz < 3.625) return 'z_score_3.5';
      if (rz > 3.624 && rz < 3.875) return 'z_score_3.75';
      if (rz > 3.874 && rz < 4.125) return 'z_score_4';
      if (rz > 4.124) return 'z_score_4.25';
      return 'z_score_';
    };

    // Helper function: zinv (inverse normal distribution)
    const zinv = (p) => {
      const a1 = -39.6968302866538;
      const a2 = 220.946098424521;
      const a3 = -275.928510446969;
      const a4 = 138.357751867269;
      const a5 = -30.6647980661472;
      const a6 = 2.50662827745924;
      const b1 = -54.4760987982241;
      const b2 = 161.585836858041;
      const b3 = -155.698979859887;
      const b4 = 66.8013118877197;
      const b5 = -13.2806815528857;
      const c1 = -7.78489400243029e-3;
      const c2 = -0.322396458041136;
      const c3 = -2.40075827716184;
      const c4 = -2.54973253934373;
      const c5 = 4.37466414146497;
      const c6 = 2.93816398269878;
      const d1 = 7.78469570904146e-3;
      const d2 = 0.32246712907004;
      const d3 = 2.445134137143;
      const d4 = 3.75440866190742;
      const p_low = 0.02425;
      const p_high = 1 - p_low;

      if (p < 0 || p > 1) {
        return 0;
      } else if (p < p_low) {
        const q = Math.sqrt(-2 * Math.log(p));
        return (((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6) / ((((d1 * q + d2) * q + d3) * q + d4) * q + 1);
      } else if (p <= p_high) {
        const q = p - 0.5;
        const r = q * q;
        return (((((a1 * r + a2) * r + a3) * r + a4) * r + a5) * r + a6) * q / (((((b1 * r + b2) * r + b3) * r + b4) * r + b5) * r + 1);
      } else {
        const q = Math.sqrt(-2 * Math.log(1 - p));
        return -(((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6) / ((((d1 * q + d2) * q + d3) * q + d4) * q + 1);
      }
    };

    // Check if value is numeric
    const isNumeric = (val) => !isNaN(parseFloat(val)) && isFinite(val);

    // Main logic
    if (operations === "3") {
      if (find_compare === "1") {
        if (isNumeric(f_first) && isNumeric(f_second) && isNumeric(f_third)) {
          if (Number(f_first) > 0 && Number(f_first) < 1) {
            if (parseFloat(f_third) > 0) {
              let x1 = zinv(parseFloat(f_first));
              x1 = (-1 * parseFloat(f_second)) + parseFloat(f_third) * x1;
              const ul = parseFloat(f_second) + 3.1 * parseFloat(f_third);
              const ll = -1 * x1;
              const above = Math.round(10000000 * ll) / 10000000;

              x1 = zinv(parseFloat(f_first));
              x1 = parseFloat(f_second) + parseFloat(f_third) * x1;
              const blow = Math.round(10000000 * x1) / 10000000;

              const f_first2 = parseFloat(f_first) / 2;
              x1 = zinv(0.5 - f_first2);
              const ll_val = Math.round((parseFloat(f_second) + parseFloat(f_third) * x1) * 100000000) / 100000000;
              const ul_val = Math.round((parseFloat(f_second) + parseFloat(f_third) * (-1 * x1)) * 100000000) / 100000000;

              const f_first3 = parseFloat(f_first) / 2;
              x1 = zinv(f_first3);
              const ll1_val = Math.round((parseFloat(f_second) + parseFloat(f_third) * x1) * 100000000) / 100000000;
              const ul1_val = Math.round((parseFloat(f_second) + parseFloat(f_third) * (-1 * x1)) * 100000000) / 100000000;

              param.tech_z_url = getZUrl(parseFloat(f_first));
              param.tech_above_first = above;
              param.tech_blow_first = blow;
              param.tech_ll_first = ll_val;
              param.tech_ul_first = ul_val;
              param.tech_ll1_first = ll1_val;
              param.tech_ul1_first = ul1_val;
              param.tech_option1 = 1;
            } else {
              param.error = "The standard deviation must be greater than zero.";
              return param;
            }
          } else {
            param.error = "Probability must be between 0 and 1.";
            return param;
          }
        } else {
          param.error = "Please! Check Your Input";
          return param;
        }
      } else if (find_compare === "2") {
        if (isNumeric(f_first) && isNumeric(f_second) && isNumeric(f_third)) {
          if (parseFloat(f_third) > 0) {
            const ms_first = parseFloat(f_first) - parseFloat(f_second);
            const rz_first = (parseFloat(f_first) - parseFloat(f_second)) / parseFloat(f_third);
            const zaini_first = zain(rz_first);

            param.tech_z_url = getZUrl(Math.abs(zaini_first[1]));
            param.tech_z_url_first = zaini_first[0];
            param.tech_ltpv_first = Math.abs(zaini_first[1]);
            param.tech_rtpv_first = Math.abs(zaini_first[2]);
            param.tech_ttpv_first = Math.abs(zaini_first[3]);
            param.tech_ttcl_first = Math.abs(zaini_first[4]);
            param.tech_ms_first = ms_first;
            param.tech_rz_first = parseFloat(rz_first.toFixed(4));
            param.tech_option2 = 2;
          } else {
            param.error = "The standard deviation must be greater than zero.";
            return param;
          }
        } else {
          param.error = "Please! Check Your Input";
          return param;
        }
      }
    } else if (operations === "4") {
      // Collect errors instead of returning immediately
      const errors = [];
      // Handle operation 4 - value 'a'
      if (isNumeric(a)) {
        if (isNumeric(mean) && isNumeric(deviation)) {
          if (parseFloat(deviation) > 0) {
            const ms = parseFloat(a) - parseFloat(mean);
            const rzss = (parseFloat(a) - parseFloat(mean)) / parseFloat(deviation);
            const zaini = zain(rzss);
            const rz = Math.abs(zaini[1]);
            param.tech_z_url = getZUrl(Math.abs(zaini[1]));
            param.tech_ltpv = Math.abs(zaini[1]);
            param.tech_rtpv = Math.abs(zaini[2]);
            param.tech_ttpv = Math.abs(zaini[3]);
            param.tech_ttcl = Math.abs(zaini[4]);
            param.tech_ms = ms;
            param.tech_rz = parseFloat(rz.toFixed(4));
            param.tech_a = parseFloat(a);
          } else {
            errors.push("The standard deviation must be greater than zero.");
          }
        } else {
          errors.push("Please! Check Your Input for field 'a'");
        }
      }

      // Handle operation 4 - value 'b'
      if (isNumeric(b)) {
        if (isNumeric(mean) && isNumeric(deviation)) {
          if (parseFloat(deviation) > 0) {
            const ms2 = parseFloat(b) - parseFloat(mean);
            const rz2 = (parseFloat(b) - parseFloat(mean)) / parseFloat(deviation);
            const zaini2 = zain(rz2);

            param.tech_z_url2 = getZUrl(Math.abs(zaini2[2]));
            param.tech_ltpv2 = Math.abs(zaini2[1]);
            param.tech_rtpv2 = Math.abs(zaini2[2]);
            param.tech_ttpv2 = Math.abs(zaini2[3]);
            param.tech_ttcl2 = Math.abs(zaini2[4]);
            param.tech_ms2 = ms2;
            param.tech_rz2 = parseFloat(rz2.toFixed(4));
            param.tech_b = parseFloat(b);
          } else {
            // Don't add duplicate error
            if (!errors.includes("The standard deviation must be greater than zero.")) {
              errors.push("The standard deviation must be greater than zero.");
            }
          }
        } else {
          errors.push("Please! Check Your Input for field 'b'");
        }
      }

      // Handle operation 4 - value 'c'
      if (isNumeric(c)) {
        if (isNumeric(mean) && isNumeric(deviation)) {
          if (parseFloat(deviation) > 0) {
            if (parseFloat(c) > 0 && parseFloat(c) < 1) {
              let x1 = zinv(parseFloat(c));
              x1 = (-1 * parseFloat(mean)) + parseFloat(deviation) * x1;
              const ul = parseFloat(mean) + 3.1 * parseFloat(deviation);
              const ll = -1 * x1;
              const above = Math.round(10000000 * ll) / 10000000;

              x1 = zinv(parseFloat(c));
              x1 = parseFloat(mean) + parseFloat(deviation) * x1;
              const blow = Math.round(10000000 * x1) / 10000000;

              const c2 = parseFloat(c) / 2;
              x1 = zinv(0.5 - c2);
              const ll_val = Math.round((parseFloat(mean) + parseFloat(deviation) * x1) * 100000000) / 100000000;
              const ul_val = Math.round((parseFloat(mean) + parseFloat(deviation) * (-1 * x1)) * 100000000) / 100000000;

              const c3 = parseFloat(c) / 2;
              x1 = zinv(c3);
              const ll1_val = Math.round((parseFloat(mean) + parseFloat(deviation) * x1) * 100000000) / 100000000;
              const ul1_val = Math.round((parseFloat(mean) + parseFloat(deviation) * (-1 * x1)) * 100000000) / 100000000;

              param.tech_z_urlc = getZUrl(parseFloat(c));
              param.tech_above = above;
              param.tech_blow = blow;
              param.tech_ll = ll_val;
              param.tech_ul = ul_val;
              param.tech_ll1 = ll1_val;
              param.tech_ul1 = ul1_val;
              param.tech_c = parseFloat(c);
            } else {
              errors.push("Probability must be between 0 and 1 for field 'c'");
            }
          } else {
            // Don't add duplicate error
            if (!errors.includes("The standard deviation must be greater than zero.")) {
              errors.push("The standard deviation must be greater than zero.");
            }
          }
        } else {
          errors.push("Please! Check Your Input for field 'c'");
        }
      }

      // Handle operation 4 - value 'd'
      if (isNumeric(d)) {
        if (isNumeric(mean) && isNumeric(deviation)) {
          if (parseFloat(deviation) > 0) {
            if (parseFloat(d) > 0 && parseFloat(d) < 1) {
              let x1 = zinv(parseFloat(d));
              x1 = (-1 * parseFloat(mean)) + parseFloat(deviation) * x1;
              const ul = parseFloat(mean) + 3.1 * parseFloat(deviation);
              const ll = -1 * x1;
              const above = Math.round(10000000 * ll) / 10000000;

              x1 = zinv(parseFloat(d));
              x1 = parseFloat(mean) + parseFloat(deviation) * x1;
              const blow = Math.round(10000000 * x1) / 10000000;

              const d2 = parseFloat(d) / 2;
              x1 = zinv(0.5 - d2);
              const ll_val = Math.round((parseFloat(mean) + parseFloat(deviation) * x1) * 100000000) / 100000000;
              const ul_val = Math.round((parseFloat(mean) + parseFloat(deviation) * (-1 * x1)) * 100000000) / 100000000;

              const d3 = parseFloat(d) / 2;
              x1 = zinv(d3);
              const ll1_val = Math.round((parseFloat(mean) + parseFloat(deviation) * x1) * 100000000) / 100000000;
              const ul1_val = Math.round((parseFloat(mean) + parseFloat(deviation) * (-1 * x1)) * 100000000) / 100000000;

              param.tech_z_urld = getZUrl(parseFloat(d));
              param.tech_above2 = above;
              param.tech_blow2 = blow;
              param.tech_ll2 = ll_val;
              param.tech_ul2 = ul_val;
              param.tech_ll12 = ll1_val;
              param.tech_ul12 = ul1_val;
              param.tech_d = parseFloat(d);
            } else {
              errors.push("Probability must be between 0 and 1 for field 'd'");
            }
          } else {
            // Don't add duplicate error
            if (!errors.includes("The standard deviation must be greater than zero.")) {
              errors.push("The standard deviation must be greater than zero.");
            }
          }
        } else {
          errors.push("Please! Check Your Input for field 'd'");
        }
      }

      // Handle operation 4 - interval e1 and e2
      if (isNumeric(e1) && isNumeric(e2)) {
        if (isNumeric(mean) && isNumeric(deviation)) {
          if (parseFloat(deviation) > 0) {
            if (parseFloat(e1) < parseFloat(e2)) {
              const ms_e1 = parseFloat(e1) - parseFloat(mean);
              const rz_e1 = (parseFloat(e1) - parseFloat(mean)) / parseFloat(deviation);
              const zaini_e1 = zain(rz_e1);

              param.tech_z_url_e1 = zaini_e1[0];
              param.tech_ltpv_e1 = Math.abs(zaini_e1[1]);
              param.tech_rtpv_e1 = Math.abs(zaini_e1[2]);
              param.tech_ttpv_e1 = Math.abs(zaini_e1[3]);
              param.tech_ttcl_e1 = Math.abs(zaini_e1[4]);
              param.tech_ms_e1 = ms_e1;
              param.tech_rz_e1 = parseFloat(rz_e1.toFixed(4));

              const ms_e2 = parseFloat(e2) - parseFloat(mean);
              const rz_e2 = (parseFloat(e2) - parseFloat(mean)) / parseFloat(deviation);
              const zaini_e2 = zain(rz_e2);

              param.tech_z_url_e2 = zaini_e2[0];
              param.tech_ltpv_e2 = Math.abs(zaini_e2[1]);
              param.tech_rtpv_e2 = Math.abs(zaini_e2[2]);
              param.tech_ttpv_e2 = Math.abs(zaini_e2[3]);
              param.tech_ttcl_e2 = Math.abs(zaini_e2[4]);
              param.tech_ms_e2 = ms_e2;
              param.tech_rz_e2 = parseFloat(rz_e2.toFixed(4));
              param.tech_e1 = parseFloat(e1);
              param.tech_e2 = parseFloat(e2);

              const main_ans = Math.abs(zaini_e2[1]) - Math.abs(zaini_e1[1]);
              param.tech_z_urle = getZUrl(main_ans);
            } else {
              errors.push("The left side of the interval has to be lesser than the right side.");
            }
          } else {
            // Don't add duplicate error
            if (!errors.includes("The standard deviation must be greater than zero.")) {
              errors.push("The standard deviation must be greater than zero.");
            }
          }
        } else {
          errors.push("Please! Check Your Input for fields 'e1' and 'e2'");
        }
      }

      // Handle operation 4 - value 'f'
      if (isNumeric(f)) {
        if (isNumeric(mean) && isNumeric(deviation)) {
          if (parseFloat(deviation) > 0) {
            if (parseFloat(f) > 0 && parseFloat(f) < 1) {
              let x1 = zinv(parseFloat(f));
              x1 = (-1 * parseFloat(mean)) + parseFloat(deviation) * x1;
              const ul = parseFloat(mean) + 3.1 * parseFloat(deviation);
              const ll = -1 * x1;
              const above = Math.round(10000000 * ll) / 10000000;

              x1 = zinv(parseFloat(f));
              x1 = parseFloat(mean) + parseFloat(deviation) * x1;
              const blow = Math.round(10000000 * x1) / 10000000;

              const f2 = parseFloat(f) / 2;
              x1 = zinv(0.5 - f2);
              const ll_val = Math.round((parseFloat(mean) + parseFloat(deviation) * x1) * 100000000) / 100000000;
              const ul_val = Math.round((parseFloat(mean) + parseFloat(deviation) * (-1 * x1)) * 100000000) / 100000000;

              const f3 = parseFloat(f) / 2;
              x1 = zinv(f3);
              const ll1_val = Math.round((parseFloat(mean) + parseFloat(deviation) * x1) * 100000000) / 100000000;
              const ul1_val = Math.round((parseFloat(mean) + parseFloat(deviation) * (-1 * x1)) * 100000000) / 100000000;

              param.tech_z_urlf = getZUrl(parseFloat(f));
              param.tech_abovef = above;
              param.tech_blowf = blow;
              param.tech_llf = ll_val;
              param.tech_ulf = ul_val;
              param.tech_ll1f = ll1_val;
              param.tech_ul1f = ul1_val;
              param.tech_f = parseFloat(f);
            } else {
              errors.push("Probability must be between 0 and 1 for field 'f'");
            }
          } else {
            // Don't add duplicate error
            if (!errors.includes("The standard deviation must be greater than zero.")) {
              errors.push("The standard deviation must be greater than zero.");
            }
          }
        } else {
          errors.push("Please! Check Your Input for field 'f'");
        }
      }
      // Add all errors to param if any exist
      // if (errors.length > 0) {
      //   param.errors = errors;
      // }
    }
    return param;
  }

       /**
   * getCalculationNormalIdealGasLawCalculator: Service Method
   * POST: /api/calculators-lol/ideal-gas-law-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

   async getCalculationNormalIdealGasLawCalculator(body) {
    const request = body;
    
      if (isNumeric(request.tech_x) && isNumeric(request.tech_y) && isNumeric(request.tech_z)) {
          let ans, ans1;
          
          if (request.tech_method == 'press') {
              let volum = parseFloat(request.tech_x);
              
              // Volume unit conversions
              if (request.tech_x_v_unit == 'cm³') {
                  volum = volum / 1e+6;
              }
              if (request.tech_x_v_unit == 'mm³') {
                  volum = volum / 1e+9;
              }
              if (request.tech_x_v_unit == 'dm³') {
                  volum = volum / 1000;
              }
              if (request.tech_x_v_unit == 'ft³') {
                  volum = volum / 35.315;
              }
              if (request.tech_x_v_unit == 'in³') {
                  volum = volum / 61024;
              }
              
              let temp = parseFloat(request.tech_z);
              // Temperature unit conversions
              if (request.tech_z_t_unit == '°C') {
                  temp = temp + 273.15;
              }
              if (request.tech_z_t_unit == '°F') {
                  temp = (temp - 32) * 5/9 + 273.15;
              }
              
              let amount = parseFloat(request.tech_y);
              // Amount unit conversions
              // console.log(request.tech_y_s_unit,amount); 
              if (request.tech_y_s_unit == "abc") {
                  amount = amount / 1e+6;
              }
              if (request.tech_y_s_unit == "mmol") {
                  amount = amount / 1000;
              }
              // console.log(volum,temp,amount);
              // ans = round((amount * request.R * temp) / volum, 3) + " Pascal";
              // ans1 = round((amount * request.R * temp) / volum, 3);
                 ans1 = ((amount * request.tech_R * temp) / volum).toFixed(3);
            if (ans1 == "0.000") {
              ans1 = parseFloat(ans1).toFixed(1);
            }
            ans = ans1 + " Pascal";
            
          }
          
          if (request.tech_method == 'volume') {
              let temp = parseFloat(request.tech_x);
              // Temperature unit conversions
              if (request.tech_x_t_unit == '°C') {
                  temp = temp + 273.15;
              }
              if (request.tech_x_t_unit == '°F') {
                  temp = (temp - 32) * 5/9 + 273.15;
              }
              
              let amount = parseFloat(request.tech_y);
              // Amount unit conversions
              if (request.tech_y_s_unit == 'abc') {
                  amount = amount / 1e+6;
              }
              if (request.tech_y_s_unit == 'mmol') {
                  amount = amount / 1000;
              }
              
              let press = parseFloat(request.tech_z);
              // Pressure unit conversions
              if (request.tech_z_p_unit == 'psi') {
                  press = press * 6894.757;
              }
              if (request.tech_z_p_unit == 'bar') {
                  press = press * 100000;
              }
              if (request.tech_z_p_unit == 'atm') {
                  press = press * 101325;
              }
              if (request.tech_z_p_unit == 'at') {
                  press = press * 98067;
              }
              if (request.tech_z_p_unit == 'Torr' || request.tech_z_p_unit == 'mmHg') {
                  press = press * 133.322;
              }
              if (request.tech_z_p_unit == 'kPa') {
                  press = press * 1000;
              }
              
              // ans = round((amount * request.tech_R * temp) / press, 5) + " m³";
              // ans1 = round((amount * request.tech_R * temp) / press, 5);
            ans1 = ((amount * request.tech_R * temp) / press).toFixed(5);
            if (ans1 == "0.00000") {
              ans1 = parseFloat(ans1).toFixed(1);
            }
            ans = ans1 + " m³";


          }
          
          if (request.tech_method == 'temp') {
              let volum = parseFloat(request.tech_x);
              // Volume unit conversions
              if (request.tech_x_v_unit == 'cm³') {
                  volum = volum / 1e+6;
              }
              if (request.tech_x_v_unit == 'ft³') {
                  volum = volum / 35.315;
              }
              if (request.tech_x_v_unit == 'dm³') {
                  volum = volum / 1000;
              }
              if (request.tech_x_v_unit == 'in³') {
                  volum = volum / 61024;
              }
              
              let amount = parseFloat(request.tech_y);
              // Amount unit conversions
              if (request.tech_y_s_unit == "abc") {
                  amount = amount / 1e+6;
              }
              if (request.tech_y_s_unit == "mmol") {
                  amount = amount / 1000;
              }
              
              let press = parseFloat(request.tech_z);
              // Pressure unit conversions
              if (request.tech_z_p_unit == 'psi') {
                  press = press * 6894.757;
              }
              if (request.tech_z_p_unit == 'bar') {
                  press = press * 100000;
              }
              if (request.tech_z_p_unit == 'atm') {
                  press = press * 101325;
              }
              if (request.tech_z_p_unit == 'at') {
                  press = press * 98067;
              }
              if (request.tech_z_p_unit == 'Torr' || request.tech_z_p_unit == 'mmHg') {
                  press = press * 133.322;
              }
              if (request.tech_z_p_unit == 'kPa') {
                  press = press * 1000;
              }
              //  console.log(volum,amount,press);
              // ans = round((press * volum) / (request.tech_R * amount), 5) + " Kelvin";
              // ans1 = round((press * volum) / (request.tech_R * amount), 5);
               ans1 = ((press * volum) / (request.tech_R * amount)).toFixed(5);
              if (ans1 == "0.00000") {
                  ans1 = ((press * volum) / (request.tech_R * amount)).toFixed(1);
              }
               ans = ans1 + " Kelvin";
          }
          
          if (request.tech_method === 'sub') {
              let volum = parseFloat(request.tech_x);
              // Volume unit conversions
              if (request.tech_x_v_unit == 'cm³') {
                  volum = volum / 1e+6;
              }
              if (request.tech_x_v_unit == 'ft³') {
                  volum = volum / 35.315;
              }
              if (request.tech_x_v_unit == 'dm³') {
                  volum = volum / 1000;
              }
              if (request.tech_x_v_unit == 'in³') {
                  volum = volum / 61024;
              }
              
              let press = parseFloat(request.tech_y);
              // Pressure unit conversions
              if (request.tech_y_p_unit == 'psi') {
                  press = press * 6894.757;
              }
              if (request.tech_y_p_unit == 'bar') {
                  press = press * 100000;
              }
              if (request.tech_y_p_unit == 'atm') {
                  press = press * 101325;
              }
              if (request.tech_y_p_unit == 'at') {
                  press = press * 98067;
              }
              if (request.tech_y_p_unit == 'Torr' || request.tech_y_p_unit == 'mmHg') {
                  press = press * 133.322;
              }
              if (request.tech_y_p_unit == 'kPa') {
                  press = press * 1000;
              }
              
              let temp = parseFloat(request.tech_z);
              // Temperature unit conversions
              if (request.tech_z_t_unit == '°C') {
                  temp = temp + 273.15;
              }
              if (request.tech_z_t_unit == '°F') {
                  temp = (temp - 32) * 5/9 + 273.15;
              }
                const presssub = parseFloat(press);
                const volumsub = parseFloat(volum);
                const tempsub  = parseFloat(temp);
                const Rsub     = parseFloat(request.tech_R);

              ans1 = ((presssub * volumsub) / (Rsub * tempsub)).toFixed(5);
              if (ans1 == "0.00000") {
                  ans1 = ((presssub * volumsub) / (Rsub * tempsub)).toFixed(1);
              }
              ans = ans1 + " mol";
          }
          
          return {
              tech_ans: ans,
              tech_ans1: ans1,
          };
      } else {
          return {
              error: 'Please! Check Your Input.'
          };
      }
      // Helper functions
      function isNumeric(value) {
          return !isNaN(parseFloat(value)) && isFinite(value);
      }
      
      function round(value, decimals) {
          return Number(Math.round(value + 'e' + decimals) + 'e-' + decimals);
      }
      
  }

  /**
   * getCalculationMoleFractionCalculator: Service Method
   * POST: /api/calculators-lol/mole-fraction-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMoleFractionCalculator(body) {
    let x = body.tech_x;
      let y = body.tech_y;
      let z = body.tech_z;
      let a = body.tech_a;

      let unit_x = body.tech_unit_x;
      let unit_y = body.tech_unit_y;
      let unit_z = body.tech_unit_z;
      let unit_a = body.tech_unit_a;

      let divide_x = body.tech_divide_x;
      let divide_y = body.tech_divide_y;
      let divide_z = body.tech_divide_z;
      let divide_a = body.tech_divide_a;

    const param = {};

    // Helper function to check if value is numeric
    const isNumeric = (val) => val !== undefined && val !== null && val !== '' && !isNaN(val);

    // Helper function to convert units to moles
    const convertToMoles = (value, unit, divideBy) => {
        let result = parseFloat(value);
        if (unit == 'Gram') {
            result = result / parseFloat(divideBy);
        }
        if (unit == 'Millimole') {
            result = result / 1000;
        }
        if (unit == 'Kilomole') {
            result = result * 1000;
        }
        if (unit == 'PoundMole') {
            result = result * 9.223e+18;
        }
        
        return result;
    };

    // Case 1: x and y provided
    if (isNumeric(x) && isNumeric(y) && !isNumeric(z) && !isNumeric(a)) {
        if (unit_x == 'Gram' && !isNumeric(divide_x)) {
            param.error = 'Please enter gram value too.';
            return param;
        }
        if (unit_y == 'Gram' && !isNumeric(divide_y)) {
            param.error = 'Please enter gram value too.';
            return param;
        }

        const Solute = convertToMoles(x, unit_x, divide_x);
        const Solvent = convertToMoles(y, unit_y, divide_y);
        const sol = parseFloat((Solute + Solvent).toFixed(5));
        const mol = parseFloat((Solute / (Solute + Solvent)).toFixed(5));
        // console.log(Solute,Solvent);
       param.tech_Solute = Solute;
        param.tech_Solvent = Solvent;
        param.tech_sol = sol;
        param.tech_mol = mol;

        return param;
    }
    
    // Case 2: x and z provided
    else if (isNumeric(x) && isNumeric(z) && !isNumeric(y) && !isNumeric(a)) {
        if (unit_z == 'Gram' && !isNumeric(divide_z)) {
            param.error = 'Please enter gram value too.';
            return param;
        }
        if (unit_x == 'Gram' && !isNumeric(divide_x)) {
            param.error = 'Please enter gram value too.';
            return param;
        }

        const Solute = convertToMoles(x, unit_x, divide_x);
        const sol = convertToMoles(z, unit_z, divide_z);
        const Solvent = sol - Solute;
        const mol = parseFloat((Solute / (Solute + Solvent)).toFixed(5));

       param.tech_Solute = Solute;
        param.tech_Solvent = Solvent;
        param.tech_sol = sol;
        param.tech_mol = mol;

        return param;
    }
    
    // Case 3: x and a provided
    else if (isNumeric(x) && isNumeric(a) && !isNumeric(y) && !isNumeric(z)) {
        if (unit_x == 'Gram' && !isNumeric(divide_x)) {
            param.error = 'Please enter gram value too.';
            return param;
        }
        if (unit_a == 'Gram' && !isNumeric(divide_a)) {
            param.error = 'Please enter gram value too.';
            return param;
        }
        console.log(x,unit_x,divide_x);
        const Solute = convertToMoles(x, unit_x, divide_x);
        const mol = convertToMoles(a, unit_a, divide_a);
        const Solvent = parseFloat(((Solute / mol) - Solute).toFixed(2));
        const sol = parseFloat((Solute + Solvent).toFixed(2));
        // console.log(Solute,mol);
          param.tech_Solute = Solute;
        param.tech_Solvent = Solvent;
        param.tech_sol = sol;
        param.tech_mol = mol;

        return param;
    }
    
    // Case 4: y and z provided
    else if (isNumeric(y) && isNumeric(z) && !isNumeric(x) && !isNumeric(a)) {
        if (unit_z == 'Gram' && !isNumeric(divide_z)) {
            param.error = 'Please enter gram value too.';
            return param;
        }
        if (unit_y == 'Gram' && !isNumeric(divide_y)) {
            param.error = 'Please enter gram value too.';
            return param;
        }

        const sol = convertToMoles(z, unit_z, divide_z);
        const Solvent = convertToMoles(y, unit_y, divide_y);
        const Solute = sol - Solvent;
        const mol = parseFloat((Solute / (Solute + Solvent)).toFixed(5));

         param.tech_Solute = Solute;
        param.tech_Solvent = Solvent;
        param.tech_sol = sol;
        param.tech_mol = mol;

        return param;
    }
    
    // Case 5: y and a provided
    else if (isNumeric(y) && isNumeric(a) && !isNumeric(x) && !isNumeric(z)) {
        if (unit_a == 'Gram' && !isNumeric(divide_a)) {
            param.error = 'Please enter gram value too.';
            return param;
        }
        if (unit_y == 'Gram' && !isNumeric(divide_y)) {
            param.error = 'Please enter gram value too.';
            return param;
        }

        const Solvent = convertToMoles(y, unit_y, divide_y);
        const mol = convertToMoles(a, unit_a, divide_a);
        const Solute = parseFloat((((mol * Solvent) * (-1)) / (mol - 1)).toFixed(3));
        const sol = Solute + Solvent;

        param.tech_Solute = Solute;
        param.tech_Solvent = Solvent;
        param.tech_sol = sol;
        param.tech_mol = mol;

        return param;
    }
    
    // Case 6: z and a provided
    else if (isNumeric(z) && isNumeric(a) && !isNumeric(x) && !isNumeric(y)) {
        if (unit_a == 'Gram' && !isNumeric(divide_a)) {
            param.error = 'Please enter gram value too.';
            return param;
        }
        if (unit_z == 'Gram' && !isNumeric(divide_z)) {
            param.error = 'Please enter gram value too.';
            return param;
        }

        const mol = convertToMoles(a, unit_a, divide_a);
        const sol = convertToMoles(z, unit_z, divide_z);
        const Solute = parseFloat((sol * mol).toFixed(3));
        const Solvent = sol - Solute;

        param.tech_Solute = Solute;
        param.tech_Solvent = Solvent;
        param.tech_sol = sol;
        param.tech_mol = mol;

        return param;
    }
    
    // Default case: error
    else {
        param.error = 'Please fill any two fields.';
        return param;
    }
}


  /**
   * getCalculationCharlesLawCalculator: Service Method
   * POST: /api/calculators-lol/charles-law-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCharlesLawCalculator(body) {
        let find = body.tech_find;
        let v1 = body.tech_v1;
        let v1_unit = body.tech_v1_unit;
        let t1 = body.tech_t1;
        let t1_unit = body.tech_t1_unit;
        let v2 = body.tech_v2;
        let v2_unit = body.tech_v2_unit;
        let t2 = body.tech_t2;
        let t2_unit = body.tech_t2_unit;
        let p = body.tech_p;
        let n = body.tech_n;
        let R = body.tech_R;
        let p_unit = body.tech_p_unit;

      const result = {};  
      
      // Check if all required values are numeric
      if (
        isNaN(parseFloat(v1)) || 
        isNaN(parseFloat(t1)) || 
        isNaN(parseFloat(v2)) || 
        isNaN(parseFloat(t2)) || 
        isNaN(parseFloat(p)) || 
        isNaN(parseFloat(n)) || 
        isNaN(parseFloat(R))
      ) {
        result.error = 'Please! Check Your Input.';
        return result;
      }
      
      // Convert to numbers
      let v1_converted = parseFloat(v1);
      let t1_converted = parseFloat(t1);
      let v2_converted = parseFloat(v2);
      let t2_converted = parseFloat(t2);
      let p_converted = parseFloat(p);
      let n_converted = parseFloat(n);
      let R_converted = parseFloat(R);
      
      // Unit Conversion for V1
      if (!isNaN(v1_converted)) {
        if (v1_unit === 'mm³') {
          v1_converted = v1_converted / 1000000000;
        } else if (v1_unit === 'cm³' || v1_unit === 'ml') {
          v1_converted = v1_converted / 1000000;
        } else if (v1_unit === 'dm³' || v1_unit === 'liters') {
          v1_converted = v1_converted / 1000;
        } else if (v1_unit === 'cu in') {
          v1_converted = v1_converted / 61024;
        } else if (v1_unit === 'cu ft') {
          v1_converted = v1_converted / 35.315;
        } else if (v1_unit === 'cu yd') {
          v1_converted = v1_converted / 1.308;
        }
      }
      
      // Unit Conversion for T1
      if (!isNaN(t1_converted)) {
        if (t1_unit === 'c' || t1_unit === '°C') {
          t1_converted = t1_converted + 273.15;
        } else if (t1_unit === 'f' || t1_unit === '°F') {
          t1_converted = (t1_converted - 32) * (5 / 9) + 273.15;
        }
      }
      
      // Unit Conversion for V2
      if (!isNaN(v2_converted)) {
        if (v2_unit === 'mm³') {
          v2_converted = v2_converted / 1000000000;
        } else if (v2_unit === 'cm³' || v2_unit === 'ml') {
          v2_converted = v2_converted / 1000000;
        } else if (v2_unit === 'dm³' || v2_unit === 'liters') {
          v2_converted = v2_converted / 1000;
        } else if (v2_unit === 'cu in') {
          v2_converted = v2_converted / 61024;
        } else if (v2_unit === 'cu ft') {
          v2_converted = v2_converted / 35.315;
        } else if (v2_unit === 'cu yd') {
          v2_converted = v2_converted / 1.308;
        }
      }
      
      // Unit Conversion for T2
      if (!isNaN(t2_converted)) {
        if (t2_unit === 'c' || t2_unit === '°C') {
          t2_converted = t2_converted + 273.15;
        } else if (t2_unit === 'f' || t2_unit === '°F') {
          t2_converted = (t2_converted - 32) * (5 / 9) + 273.15;
        }
      }
      
      // Unit Conversion for P (pressure)
      if (!isNaN(p_converted)) {
        if (p_unit === 'bar') {
          p_converted = p_converted / 0.00001;
        } else if (p_unit === 'psi') {
          p_converted = p_converted / 0.00014504;
        } else if (p_unit === 'at') {
          p_converted = p_converted / 0.000010197;
        } else if (p_unit === 'atm') {
          p_converted = p_converted / 0.00000987;
        } else if (p_unit === 'Torr') {
          p_converted = p_converted / 0.0075;
        } else if (p_unit === 'hPa') {
          p_converted = p_converted / 0.01;
        } else if (p_unit === 'kPa') {
          p_converted = p_converted / 0.001;
        } else if (p_unit === 'MPa') {
          p_converted = p_converted / 0.000001;
        } else if (p_unit === 'GPa') {
          p_converted = p_converted / 0.000000001;
        } else if (p_unit === 'in Hg') {
          p_converted = p_converted / 0.0002953;
        } else if (p_unit === 'mmHg') {
          p_converted = p_converted / 0.0075;
        }
      }
      
      // Calculations based on 'find' parameter
      if (find === 'v1' && !isNaN(t1_converted) && !isNaN(v2_converted) && !isNaN(t2_converted)) {
        const v1_result = (v2_converted / t2_converted) * t1_converted;
        console.log(v2_converted,t2_converted,t1_converted);
        const mm3 = v1_result * 1000000000;
        const cm3 = v1_result * 1000000;
        const dm3 = v1_result * 1000;
        const cu_in = v1_result * 61024;
        const cu_ft = v1_result * 35.315;
        const cu_yd = v1_result * 1.308;
        const p_val = 101325;
        const n_val = (p_val * v1_result) / (R_converted * t1_converted);
        
        result.tech_v1 = Math.round(v1_result * 100000) / 100000;
        result.tech_p = p_val;
        result.tech_n = Math.round(n_val * 100000) / 100000;
        result.tech_mm3 = mm3;
        result.tech_cm3 = cm3;
        result.tech_dm3 = dm3;
        result.tech_cu_in = cu_in;
        result.tech_cu_ft = cu_ft;
        result.tech_cu_yd = cu_yd;
        
      } else if (find === 't1' && !isNaN(v1_converted) && !isNaN(v2_converted) && !isNaN(t2_converted)) {
        const t1_result = (t2_converted / v2_converted) * v1_converted;
        const c = t1_result - 273.15;
        const f = (t1_result - 273.15) * (9 / 5) + 32;
        const p_val = 101325;
        const n_val = (p_val * v1_converted) / (R_converted * t1_result);
        
        result.tech_t1 = Math.round(t1_result * 100000) / 100000;
        result.tech_p = p_val;
        result.tech_n = Math.round(n_val * 100000) / 100000;
        result.tech_c = c;
        result.tech_f = f;
        
      } else if (find === 'v2' && !isNaN(v1_converted) && !isNaN(t1_converted) && !isNaN(t2_converted)) {
        const v2_result = (v1_converted / t1_converted) * t2_converted;
        const mm3 = v2_result * 1000000000;
        const cm3 = v2_result * 1000000;
        const dm3 = v2_result * 1000;
        const cu_in = v2_result * 61024;
        const cu_ft = v2_result * 35.315;
        const cu_yd = v2_result * 1.308;
        const p_val = 101325;
        const n_val = (p_val * v1_converted) / (R_converted * t1_converted);
        
        result.tech_v2 = Math.round(v2_result * 100000) / 100000;
        result.tech_p = p_val;
        result.tech_n = Math.round(n_val * 100000) / 100000;
        result.tech_mm3 = mm3;
        result.tech_cm3 = cm3;
        result.tech_dm3 = dm3;
        result.tech_cu_in = cu_in;
        result.tech_cu_ft = cu_ft;
        result.tech_cu_yd = cu_yd;
        
      } else if (find === 't2' && !isNaN(v1_converted) && !isNaN(t1_converted) && !isNaN(v2_converted)) {
        const t2_result = (t1_converted / v1_converted) * v2_converted;
        const c = t2_result - 273.15;
        const f = (t2_result - 273.15) * (9 / 5) + 32;
        const p_val = 101325;
        const n_val = (p_val * v1_converted) / (R_converted * t1_converted);
        
        result.tech_t2 = Math.round(t2_result * 100000) / 100000;
        result.tech_p = p_val;
        result.tech_n = Math.round(n_val * 100000) / 100000;
        result.tech_c = c;
        result.tech_f = f;
        
      } else if (find === 'p' && !isNaN(v1_converted) && !isNaN(t1_converted) && !isNaN(v2_converted) && !isNaN(t2_converted) && !isNaN(n_converted) && !isNaN(R_converted)) {
        const p_result = (n_converted * R_converted * t1_converted) / v1_converted;
        const bar = p_result * 0.00001;
        const psi = p_result * 0.00014504;
        const at = p_result * 0.000010197;
        const atm = p_result * 0.00000987;
        const torr = p_result * 0.0075;
        const hpa = p_result * 0.01;
        const kpa = p_result * 0.001;
        const mpa = p_result * 0.000001;
        const gpa = p_result * 0.000000001;
        const in_hg = p_result * 0.0002953;
        const mmhg = p_result * 0.0075;
        
        result.tech_p_val = Math.round(p_result * 100000) / 100000;
        result.tech_bar = bar;
        result.tech_psi = psi;
        result.tech_at = at;
        result.tech_atm = atm;
        result.tech_torr = torr;
        result.tech_hpa = hpa;
        result.tech_kpa = kpa;
        result.tech_mpa = mpa;
        result.tech_gpa = gpa;
        result.tech_in_hg = in_hg;
        result.tech_mmhg = mmhg;
        
      } else if (find === 'n' && !isNaN(v1_converted) && !isNaN(t1_converted) && !isNaN(v2_converted) && !isNaN(t2_converted) && !isNaN(p_converted) && !isNaN(R_converted)) {
        const n_result = (p_converted * v1_converted) / (R_converted * t1_converted);
        result.n_val = Math.round(n_result * 100000) / 100000;
        
      } else {
        result.error = 'Please! Fill All The Fields.';
        return result;
      }
      
      result.RESULT = 1;
      return result;
    }

     /**
   * getCalculationPartialPressureCalculator: Service Method
   * POST: /api/calculators-lol/partial-pressure-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async getCalculationPartialPressureCalculator(body) {
          let formula = body.tech_formula;
        let to_cal1 = body.tech_to_cal1;
        let total = body.tech_total;
        let total_unit = body.tech_total_unit;
        let mole = body.tech_mole;
        let partial = body.tech_partial;
        let part_unit = body.tech_part_unit;
        let to_cal2 = body.tech_to_cal2;
        let amole = body.tech_amole;
        let temp = body.tech_temp;
        let temp_unit = body.tech_temp_unit;
        let volume = body.tech_volume;
        let vol_unit = body.tech_vol_unit;
        let partial1 = body.tech_partial1;
        let part_unit1 = body.tech_part_unit1;
        let to_cal3 = body.tech_to_cal3;
        let gas = body.tech_gas;
        let cons = body.tech_cons;
        let conc = body.tech_conc;
        let conc_unit = body.tech_conc_unit;
        let partial2 = body.tech_partial2;
        let part_unit2 = body.tech_part_unit2;
        let to_cal4 = body.tech_to_cal4;
        let gas1 = body.tech_gas1;
        let mole1 = body.tech_mole1;
        let partial3 = body.tech_partial3;
        let cons1 = body.tech_cons1;
        let cons1_unit2 = body.tech_cons1_unit2;
        let part_unit3 = body.tech_part_unit3;


    const param = {};

    try {
      if (formula == '1') {
        if (to_cal1 == '1') {
          if (isNumeric(total) && isNumeric(mole)) {
            if (mole > 1) {
              param.error = "Mole fraction value can't be greater than 1.";
              return param;
            } else {
              const ans = total * mole;
              param.tech_mode = 1;
              param.tech_ans = ans;
              param.tech_unit = total_unit;
              return param;
            }
          } else {
            param.error = 'Please! Check Your Input.';
            return param;
          }
        } else if (to_cal1 == '2') {
          if (isNumeric(total) && isNumeric(partial)) {
            let convertedPartial = parseFloat(partial);
            let convertedTotal = parseFloat(total);

            if (part_unit !== total_unit) {
              convertedPartial = convertPressure(convertedPartial, part_unit, 'Pa');
              convertedTotal = convertPressure(convertedTotal, total_unit, 'Pa');
            }

            const ans = convertedPartial / convertedTotal;
            param.tech_mode = 2;
            param.tech_ans = ans;
            return param;
          } else {
            param.error = 'Please! Check Your Input.';
            return param;
          }
        } else if (to_cal1 == '3') {
          if (isNumeric(partial) && isNumeric(mole)) {
            if (mole > 1) {
              param.error = "Mole fraction value can't be greater than 1.";
              return param;
            } else {
              const ans = partial / mole;
              param.tech_mode = 3;
              param.tech_ans = ans;
              param.tech_unit = part_unit;
              return param;
            }
          } else {
            param.error = 'Please! Check Your Input.';
            return param;
          }
        }
      } else if (formula == '2') {
        if (to_cal2 == '1') {
          if (isNumeric(amole) && isNumeric(temp) && isNumeric(volume)) {
            let convertedVolume = parseFloat(volume);
            let convertedTemp = parseFloat(temp);

            convertedVolume = convertVolume(convertedVolume, vol_unit, 'm³');
            convertedTemp = convertTemperature(convertedTemp, temp_unit, 'K');

            const ans = (amole * 8.3145 * convertedTemp) / convertedVolume;
            param.tech_mode = 4;
            param.tech_ans = ans;
            return param;
          } else {
            param.error = 'Please! Check Your Input.';
            return param;
          }
        } else if (to_cal2 == '2') {
          if (isNumeric(amole) && isNumeric(temp) && isNumeric(partial1)) {
            let convertedPartial1 = convertPressure(parseFloat(partial1), part_unit1, 'Pa');
            let convertedTemp = convertTemperature(parseFloat(temp), temp_unit, 'K');

            const ans = (amole * 8.3145 * convertedTemp) / convertedPartial1;
            param.tech_mode = 5;
            param.tech_ans = ans;
            return param;
          } else {
            param.error = 'Please! Check Your Input.';
            return param;
          }
        } else if (to_cal2 == '3') {
          if (isNumeric(amole) && isNumeric(volume) && isNumeric(partial1)) {
            let convertedVolume = convertVolume(parseFloat(volume), vol_unit, 'm³');
            let convertedPartial1 = convertPressure(parseFloat(partial1), part_unit1, 'Pa');

            const ans = (convertedVolume * convertedPartial1) / (amole * 8.3145);
            param.tech_mode = 6;
            param.tech_ans = ans;
            return param;
          } else {
            param.error = 'Please! Check Your Input.';
            return param;
          }
        } else if (to_cal2 == '4') {
          if (isNumeric(temp) && isNumeric(volume) && isNumeric(partial1)) {
            let convertedVolume = convertVolume(parseFloat(volume), vol_unit, 'm³');
            let convertedPartial1 = convertPressure(parseFloat(partial1), part_unit1, 'Pa');
            let convertedTemp = convertTemperature(parseFloat(temp), temp_unit, 'K');

            const ans = (convertedVolume * convertedPartial1) / (convertedTemp * 8.3145);
            param.tech_mode = 7;
            param.tech_ans = ans;
            return param;
          } else {
            param.error = 'Please! Check Your Input.';
            return param;
          }
        }
      } else if (formula == '3') {
        let gasConstant;
        
        switch (gas) {
          case '1': gasConstant = 77942230; break;
          case '2': gasConstant = 129903716; break;
          case '3': gasConstant = 2979968; break;
          case '4': gasConstant = 166106126; break;
          case '5': gasConstant = 273851078; break;
          case '6': gasConstant = 225166442; break;
          case '7': gasConstant = 72374421; break;
          case '8': gasConstant = 106657735; break;
          case '9':
            if (!isNumeric(cons)) {
              param.error = 'Please! Check Your Input.';
              return param;
            } else {
              gasConstant = 101325 * cons;
            }
            break;
          default:
            param.error = 'Invalid gas selection';
            return param;
        }

        if (to_cal3 == '1') {
          if (isNumeric(gasConstant) && isNumeric(conc)) {
            let convertedConc = convertConcentration(parseFloat(conc), conc_unit, 'M');
            const ans = gasConstant * convertedConc;
            param.tech_mode = 4;
            param.tech_ans = ans;
            return param;
          } else {
            param.error = 'Please! Check Your Input.';
            return param;
          }
        } else if (to_cal3 == '2') {
          if (isNumeric(gasConstant) && isNumeric(partial2)) {
            let convertedPartial2 = convertPressure(parseFloat(partial2), part_unit2, 'Pa');
            const ans = convertedPartial2 / gasConstant;
            param.tech_mode = 8;
            param.tech_ans = ans;
            return param;
          } else {
            param.error = 'Please! Check Your Input.';
            return param;
          }
        }
      } else if (formula == '4') {
        let gasConstant1;
        
        switch (gas1) {
          case '1': gasConstant1 = 4315431750; break;
          case '2': gasConstant1 = 7193061750; break;
          case '3': gasConstant1 = 165159750; break;
          case '4': gasConstant1 = 9197270250; break;
          case '5': gasConstant1 = 15168352500; break;
          case '6': gasConstant1 = 12462975000; break;
          case '7': gasConstant1 = 4007403750; break;
          case '8': gasConstant1 = 5905221000; break;
          case '9':
            if (!isNumeric(cons1)) {
              param.error = 'Please! Check Your Input.';
              return param;
            } else {
              gasConstant1 = convertPressure(parseFloat(cons1), cons1_unit2, 'Pa');
            }
            break;
          default:
            param.error = 'Invalid gas selection';
            return param;
        }

        if (to_cal4 == '1') {
          if (isNumeric(mole1) && isNumeric(gasConstant1)) {
            if (mole1 > 1) {
              param.error = "Mole fraction value can't be greater than 1.";
              return param;
            } else {
              const ans = mole1 * gasConstant1;
              param.tech_mode = 4;
              param.tech_ans = ans;
              return param;
            }
          } else {
            param.error = 'Please! Check Your Input.';
            return param;
          }
        } else if (to_cal4 == '2') {
          if (isNumeric(partial3) && isNumeric(gasConstant1)) {
            let convertedPartial3 = convertPressure(parseFloat(partial3), part_unit3, 'Pa');
            const ans = convertedPartial3 / gasConstant1;
            param.tech_mode = 2;
            param.tech_ans = ans;
            return param;
          } else {
            param.error = 'Please! Check Your Input.';
            return param;
          }
        }
      }

      param.error = 'Invalid formula or calculation type';
      return param;
    } catch (error) {
      param.error = 'Calculation error: ' + error.message;
      return param;
    }
    
    // Helper functions
    function isNumeric(value) {
      return !isNaN(parseFloat(value)) && isFinite(value);
    }
    
    function convertPressure(value, fromUnit, toUnit = 'Pa') {
      const conversionFactors = {
        'Bar': 100000,
        'Torr': 133.32,
        'psi': 6895,
        'atm': 101325,
        'hPa': 100,
        'MPa': 1000000,
        'kPa': 1000,
        'GPa': 1000000000,
        'mmHg': 133.32,
        'in Hg': 3386.4,
        'Pa': 1
      };
    
      if (conversionFactors[fromUnit]) {
        return value * conversionFactors[fromUnit];
      }
      return value;
    }
    
    function convertVolume(value, fromUnit, toUnit = 'm³') {
      const conversionFactors = {
        'cm³': 1e-6,
        'mm³': 1e-9,
        'dm³': 0.001,
        'ft³': 0.0283168,
        'yd³': 0.764555,
        'in³': 1.63871e-5,
        'litre': 0.001,
        'm³': 1
      };
    
      if (conversionFactors[fromUnit]) {
        return value * conversionFactors[fromUnit];
      }
      return value;
    }
    
    function convertTemperature(value, fromUnit, toUnit = 'K') {
      if (fromUnit === '°C') {
        return value + 273.15;
      } else if (fromUnit === '°F') {
        return (value - 32) * 5/9 + 273.15;
      }
      return value; // Assuming it's already in Kelvin
    }
    
    function convertConcentration(value, fromUnit, toUnit = 'M') {
      const conversionFactors = {
        'mM': 0.001,
        'μM': 1e-6,
        'nM': 1e-9,
        'pM': 1e-12,
        'fM': 1e-15,
        'aM': 1e-18,
        'zM': 1e-21,
        'yM': 1e-24,
        'M': 1
      };
    
      if (conversionFactors[fromUnit]) {
        return value * conversionFactors[fromUnit];
      }
      return value;
    }
  }

    /**
   * getCalculationPhCalculator: Service Method
   * POST: /api/calculators-lol/ph-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async getCalculationPhCalculator(body) {
        let concentration = body.tech_concentration;
      let con_units = body.tech_con_units;
      let chemical_name = body.tech_chemical_name;
      let chemical_selection = body.tech_chemical_selection;
      let post_space = body.tech_post_space;
      let po_units = body.tech_po_units;
      let f_length = body.tech_f_length;
      let fl_units = body.tech_fl_units;
      let operation = body.tech_operation;
      let second = body.tech_second;

    const result = {};

    // Helper function to convert concentration units to M (Molar)
    function convertUnits(a, b) {
      const conversions = {
        'M': 1,
        'mM': 0.001,
        'µM': 0.000001,
        'nM': 0.000000001,
        'pM': 0.000000000001,
        'fM': 0.000000000000001,
        'aM': 0.000000000000000001,
        'zM': 0.000000000000000000001
      };
      return a * (conversions[b] || 1);
    }

    // Helper function to convert weight units to grams
    function convertWeight(c, d) {
      const conversions = {
        'ng': c / 1000000000,
        'µg': c / 1000000,
        'mg': c / 1000,
        'g': c * 1,
        'dag': c * 10,
        'kg': c * 1000,
        'gr': c / 15.432,
        'dr': c * 3.41,
        'lbs': c * 454,
        'stones': c * 6350,
        'oz t': c * 31.103,
        'oz': c * 28.35,
        't': c * 1000000
      };
      return conversions[d] || c;
    }

    // Helper function to convert volume units to liters
    function convertVolume(x, y) {
      const conversions = {
        'mm³': x / 1000000,
        'cm³': x / 1000,
        'dm³': x * 1,
        'm³': x * 1000,
        'in³': x * 61.024,
        'ft³': x * 28.317,
        'ml': x / 1000,
        'cl': x / 100,
        'liters': x * 1,
        'US gal': x * 3.785,
        'UK gal': x * 4.546,
        'US fl oz': x / 33.814,
        'UK fl oz': x / 35.195
      };
      return conversions[y] || x;
    }

    try {
      let pH, pho, OH, H, pka;
      let chemicalValue;

      if (chemical_selection === "1") {
        if (concentration > 0) {
          // Convert chemical_name to number
          chemicalValue = parseFloat(chemical_name);
          
          const conc = convertUnits(parseFloat(concentration), con_units);
          const res1 = chemicalValue * conc;
          const res2 = Math.sqrt(res1);
          const res3 = Math.log10(res2);
          pH = res3 * -1;
          H = Math.pow(10, -pH);
          pho = 14 - pH;
          OH = Math.pow(10, -pho);
          const pk_a = Math.log10(chemicalValue);
          pka = pk_a * -1;
          
          pH = pH.toFixed(4);
          pho = pho.toFixed(2);
          pka = pka.toFixed(3);
        } else {
          result.error = 'Please! Concentration greater than 0.';
          return result;
        }
      } 
      else if (chemical_selection === "2") {
        if (concentration > 0) {
          // Convert chemical_name to number
          chemicalValue = parseFloat(chemical_name);
          
          const conc = convertUnits(parseFloat(concentration), con_units);
          const res1 = chemicalValue * conc * 4;
          const res2 = Math.sqrt(res1);
          const re = (res2 - chemicalValue) / 2;
          const ans1 = 0.00000000000001 / re;
          const res3 = Math.log10(ans1);
          pH = res3 * -1;
          H = Math.pow(10, -pH);
          pho = 14 - pH;
          OH = Math.pow(10, -pho);
          const pk_a = Math.log10(chemicalValue);
          pka = pk_a * -1;
          
          pH = pH.toFixed(4);
          pho = pho.toFixed(2);
          pka = pka.toFixed(3);
        } else {
          result.error = 'Please! Concentration greater than 0.';
          return result;
        }
      } 
      else if (chemical_selection === "3") {
        if (parseFloat(f_length) > 0 && parseFloat(post_space) > 0) {
          const length = convertWeight(parseFloat(f_length), fl_units);
          const volume = convertVolume(parseFloat(post_space), po_units);
          
          // Check if chemical_name contains '&'
          let v, m;
          if (chemical_name.includes('&')) {
            [v, m] = chemical_name.split('&').map(parseFloat);
          } else {
            // If no '&', treat chemical_name as Ka value (v) with default molecular weight
            v = parseFloat(chemical_name);
            m = 1; // Default molecular weight
          }
          
          const moles = m !== 0 ? length / m : 0;
          const conc = volume !== 0 ? moles / volume : 0;
          
          // Check if calculation will result in valid numbers
          if (conc <= 0 || v <= 0) {
            result.error = 'Invalid calculation parameters';
            return result;
          }
          
          const res1 = v * conc;
          const res2 = Math.sqrt(res1);
          const res3 = Math.log10(res2);
          pH = res3 * -1;
          H = Math.pow(10, -pH);
          pho = 14 - pH;
          OH = Math.pow(10, -pho);
          const pk_a = Math.log10(v);
          pka = pk_a * -1;
          
          // Check for Infinity or NaN
          if (!isFinite(pH) || !isFinite(pho)) {
            pH = 'inf';
            pho = 'inf';
            OH = Infinity;
          } else {
            pH = pH.toFixed(4);
            pho = pho.toFixed(2);
          }
          pka = pka.toFixed(3);
        } else {
          result.error = 'Please! Input greater than 0.';
          return result;
        }
      } 
      else if (chemical_selection === "4") {
        if (parseFloat(f_length) > 0 && parseFloat(post_space) > 0) {
          const length = convertWeight(parseFloat(f_length), fl_units);
          const volume = convertVolume(parseFloat(post_space), po_units);
          
          // Check if chemical_name contains '&'
          let v, m;
          if (chemical_name.includes('&')) {
            [v, m] = chemical_name.split('&').map(parseFloat);
          } else {
            // If no '&', treat chemical_name as Kb value (v) with default molecular weight
            v = parseFloat(chemical_name);
            m = 1; // Default molecular weight
          }
          
          const moles = m !== 0 ? length / m : 0;
          const conc = volume !== 0 ? moles / volume : 0;
          
          // Check if calculation will result in valid numbers
          if (conc <= 0 || v <= 0) {
            result.error = 'Invalid calculation parameters';
            return result;
          }
          
          const res3 = Math.log10(conc);
          pho = res3 * -1;
          pH = 14 - pho;
          H = Math.pow(10, -pH);
          OH = Math.pow(10, -pho);
          const pk_a = Math.log10(v);
          pka = pk_a * -1;
          
          // Check for Infinity or NaN
          if (!isFinite(pH) || !isFinite(pho)) {
            pH = 'inf';
            pho = 'inf';
          } else {
            pH = pH.toFixed(4);
            pho = pho.toFixed(2);
          }
          pka = pka.toFixed(3);
        } else {
          result.error = 'Please! Input greater than 0.';
          return result;
        }
      } 
      else if (chemical_selection === "5") {
        if (operation === "1") {
          if (parseFloat(concentration) > 0) {
            const conc = convertUnits(parseFloat(concentration), con_units);
            const res3 = Math.log10(conc);
            pH = res3 * -1;
            pho = 14 - pH;
            OH = Math.pow(10, -pho);
            
            pH = pH.toFixed(4);
            pho = pho.toFixed(4);
          } else {
            result.error = 'Please! Input greater than 0.';
            return result;
          }
        } 
        else if (operation === "2") {
          if (!isNaN(second)) {
            pH = 14 - parseFloat(second);
            H = Math.pow(10, -pH);
            OH = Math.pow(10, -parseFloat(second));
          } else {
            result.error = 'Please! Input greater than 0.';
            return result;
          }
        } 
        else if (operation === "3") {
          if (parseFloat(concentration) > 0) {
            const conc = convertUnits(parseFloat(concentration), con_units);
            const res3 = Math.log10(conc);
            pho = res3 * -1;
            pH = 14 - pho;
            H = Math.pow(10, -pH);
          } else {
            result.error = 'Please! Input greater than 0.';
            return result;
          }
        }
      }

      // Add non-empty values to result
      if (pH !== undefined) result.tech_pH = pH;
      if (pho !== undefined) result.tech_pho = pho;
      if (OH !== undefined) result.tech_OH = OH;
      if (H !== undefined) result.tech_H = H;
      if (pka !== undefined) result.tech_pka = pka;
      
      return result;
    } catch (error) {
      result.error = 'Calculation error: ' + error.message;
      return result;
    }
  }

  /**
    * getCalculationBoylesLawCalculator: Service Method
    * POST: /api/calculators-lol/boyles-law-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

   async getCalculationBoylesLawCalculator(body) {
      let find = body.tech_find;
      let v1 = body.tech_v1;
      let v1_unit = body.tech_v1_unit;
      let p1 = body.tech_p1;
      let p1_unit = body.tech_p1_unit;
      let v2 = body.tech_v2;
      let v2_unit = body.tech_v2_unit;
      let p2 = body.tech_p2;
      let p2_unit = body.tech_p2_unit;
      let R = body.tech_R;
      let temp = body.tech_temp;
      let temp_unit = body.tech_temp_unit;
      let amount = body.tech_amount;

    const result = {};

    // Pressure conversion function
    function convertPressure(unit, value) {
        const conversions = {
            'Pa': 1,
            'Bar': 100000,
            'psi': 6895,
            'at': 98068,
            'atm': 101325,
            'Torr': 133.32,
            'hPa': 100,
            'kPa': 1000,
            'MPa': 1000,
            'GPa': 1000000000,
            'in Hg': 3386.4,
            'mmHg': 133.32
        };
        return value * (conversions[unit] || 1);
    }

    // Volume conversion function
    function convertVolume(unit, value) {
        const conversions = {
            'mm³': 0.000000001,
            'cm³': 0.000001,
            'dm³': 0.001,
            'm³': 1,
            'in³': 0.000016387,
            'ft³': 0.028317,
            'yd³': 0.7646,
            'ml': 0.000001,
            'liters': 0.001
        };
        return value * (conversions[unit] || 1);
    }

    // Temperature conversion function
    function convertTemp(unit, value) {
        if (unit === '°C') {
            return value + 273.15;
        } else if (unit === '°F') {
            return (value - 32) * (5/9) + 273.15;
        } else if (unit === 'K') {
            return value;
        }
        return value;
    }

    let method, formula, content;

    if (find === "1") { // Find Volume V2
        if (isNumeric(p1) && isNumeric(v1) && isNumeric(p2)) {
            method = 1;
            const pressure_one = convertPressure(p1_unit, p1);
            const volume_one = convertVolume(v1_unit, v1);
            const pressure_two = convertPressure(p2_unit, p2);
            formula = (pressure_one * volume_one) / pressure_two;
            content = "Final Volume (V₂)";
        } else {
            result.error = 'Please! Check Your Input.';
            return result;
        }
    } else if (find === "2") { // Find Pressure P2
        if (isNumeric(p1) && isNumeric(v1) && isNumeric(v2)) {
            method = 2;
            const pressure_one = convertPressure(p1_unit, p1);
            const volume_one = convertVolume(v1_unit, v1);
            const volume_two = convertVolume(v2_unit, v2);
            formula = pressure_one * (volume_one / volume_two);
            content = "Final Pressure (P₂)";
        } else {
            result.error = 'Please! Check Your Input.';
            return result;
        }
    } else if (find === "3") { // Find Volume V1
        if (isNumeric(p1) && isNumeric(p2) && isNumeric(v2)) {
            method = 3;
            const pressure_one = convertPressure(p1_unit, p1);
            const pressure_two = convertPressure(p2_unit, p2);
            const volume_two = convertVolume(v2_unit, v2);
            formula = pressure_two * (volume_two / pressure_one);
            content = "Initial Volume (V₁)";
        } else {
            result.error = 'Please! Check Your Input.';
            return result;
        }
    } else if (find === "4") { // Find Pressure P1
        if (isNumeric(v1) && isNumeric(v2) && isNumeric(p2)) {
            method = 4;
            const pressure_two = convertPressure(p2_unit, p2);
            const volume_one = convertVolume(v1_unit, v1);
            const volume_two = convertVolume(v2_unit, v2);
            formula = pressure_two * (volume_two / volume_one);
            content = "Initial Pressure (P₁)";
        } else {
            result.error = 'Please! Check Your Input.';
            return result;
        }
    } else if (find === "5") { // Find Temperature
        if (isNumeric(p1) && isNumeric(v1) && isNumeric(R) && isNumeric(amount)) {
            method = 5;
            const final = (p1 * v1) / (R * amount);
            content = "Temperature";
            result.tech_method = method;
            result.tech_content = content;
            result.tech_pooran = final;
            return result;
        }
    } else if (find === "6") { // Find Amount of Gas
        if (isNumeric(p1) && isNumeric(v1) && isNumeric(R) && isNumeric(temp)) {
            method = 6;
            const temp_value = convertTemp(temp_unit, temp);
            const f = p1 * v1;
            const s = R * temp_value;
            const final = f / s;
            content = "Amount of gas (n)";
            result.tech_content = content;
            result.tech_final = final;
        } else {
            result.error = 'Please! Check Your Input.';
            return result;
        }
    }

    const tempValue = 295;
    const first = p1 * v1;
    const second = R * tempValue;
    const final = first / second;

    result.tech_ans = formula;
    result.tech_method = method;
    result.tech_temp = tempValue;
    result.tech_n = parseFloat(final.toFixed(3));
    result.tech_content = content;

    return result;
    
    // Helper function to check if value is numeric
    function isNumeric(value) {
        return !isNaN(parseFloat(value)) && isFinite(value);
    }
}


    /**
    * getCalculationCombinedGasLawCalculator: Service Method
    * POST: /api/calculators-lol/combined-gas-law-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

      async getCalculationCombinedGasLawCalculator(body) {
            let calculation = body.tech_calculation;
          let pressure_one = body.tech_pressure_one;
          let pressure_one_unit = body.tech_pressure_one_unit;
          let pressure_two = body.tech_pressure_two;
          let pressure_two_unit = body.tech_pressure_two_unit;
          let volume_one = body.tech_volume_one;
          let volume_one_unit = body.tech_volume_one_unit;
          let volume_two = body.tech_volume_two;
          let volume_two_unit = body.tech_volume_two_unit;
          let temp_one = body.tech_temp_one;
          let temp_one_unit = body.tech_temp_one_unit;
          let temp_two = body.tech_temp_two;
          let temp_two_unit = body.tech_temp_two_unit;

        let val3;
        // Helper function for pressure conversion to Pascal
        const pre = (unit, value) => {
            const conversions = {
                'Pa': 1,
                'kPa': 1000,
                'Bar': 100000,
                'atm': 101325,
                'hPa': 100,
                'mbar': 100,
                'mmHg': 133.32
            };
            return value * (conversions[unit] || 1);
        };

        // Helper function for volume conversion to m³
        const vol = (unit, value) => {
            const conversions = {
                'm³': 1,
                'l': 0.001,
                'ml': 0.000001,
                'ft³': 0.0283168,
                'in³': 1.63871e-5
            };
            return value * (conversions[unit] || 1);
        };

        // Helper function for temperature conversion to Kelvin

        function temp(unit3,value3){
          if(unit3=="°C"){
            val3= Number(value3)+273.15;
          }else if(unit3=="°F"){
            val3=(Number(value3)-32)*(5/9)+273.15;
          }else if(unit3=="K"){
            val3=Number(value3)*1;
          }
          return val3; 
        }


        const result = {};
        let method;

        try {
            switch(calculation) {
                case "1": // Temperature Two
                    if (isNumeric(pressure_one) && isNumeric(pressure_two) && 
                        isNumeric(volume_one) && isNumeric(volume_two) && isNumeric(temp_one)) {
                        method = 1;
                        const pressure_two_value = pre(pressure_two_unit, pressure_two);
                        const pressure_one_value = pre(pressure_one_unit, pressure_one);
                        const volume_two_value = vol(volume_two_unit, volume_two);
                        const volume_one_value = vol(volume_one_unit, volume_one);
                        const temp_one_value = temp(temp_one_unit, temp_one);
                          const tf = (pressure_two_value * volume_two_value * temp_one_value) /
                          (pressure_one_value * volume_one_value);
                        result.tech_temperature = tf;

                    } else {
                        result.error = 'Please! Check Your Input.';
                        return result;
                    }
                    break;

                case "2": // Volume One
                    method = 2;
                    if (isNumeric(pressure_one) && isNumeric(pressure_two) && 
                        isNumeric(temp_two) && isNumeric(volume_two) && isNumeric(temp_one)) {
                        const pressure_two_value = pre(pressure_two_unit, pressure_two);
                        const pressure_one_value = pre(pressure_one_unit, pressure_one);
                        const volume_two_value = vol(volume_two_unit, volume_two);
                        const temp_two_value = temp(temp_two_unit, temp_two);
                        const temp_one_value = temp(temp_one_unit, temp_one);
                        const vi = Math.round(((pressure_two_value * volume_two_value * temp_one_value) / 
                                  (temp_two_value * pressure_one_value)) * 100) / 100;
                        result.tech_volume = vi;


                    } else {
                        result.error = 'Please! Check Your Input.';
                        return result;
                    }
                    break;

                case "3": // Pressure One
                    method = 3;
                    if (isNumeric(volume_one) && isNumeric(pressure_two) && 
                        isNumeric(temp_two) && isNumeric(volume_two) && isNumeric(temp_one)) {
                        const pressure_two_value = pre(pressure_two_unit, pressure_two);
                        const volume_one_value = vol(volume_one_unit, volume_one);
                        const volume_two_value = vol(volume_two_unit, volume_two);
                        const temp_two_value = temp(temp_two_unit, temp_two);
                        const temp_one_value = temp(temp_one_unit, temp_one);
                        const pi = Math.round(((pressure_two_value * volume_two_value * temp_one_value) / 
                                  (temp_two_value * volume_one_value)) * 100) / 100;
                        result.tech_pressure = pi;


                    } else {
                        result.error = 'Please! Check Your Input.';
                        return result;
                    }
                    break;

                case "4": // Temperature One
                    method = 4;
                    if (isNumeric(volume_one) && isNumeric(pressure_two) && 
                        isNumeric(temp_two) && isNumeric(volume_two) && isNumeric(pressure_one)) {
                        const pressure_two_value = pre(pressure_two_unit, pressure_two);
                        const volume_one_value = vol(volume_one_unit, volume_one);
                        const volume_two_value = vol(volume_two_unit, volume_two);
                        const temp_two_value = temp(temp_two_unit, temp_two);
                        const pressure_one_value = pre(pressure_one_unit, pressure_one);
                        const ti = Math.round(((pressure_one_value * volume_one_value * temp_two_value) / 
                                  (pressure_two_value * volume_two_value)) * 100) / 100;
                        result.tech_temperature = ti;

                    } else {
                        result.error = 'Please! Check Your Input.';
                        return result;
                    }
                    break;

                case "5": // Volume Two
                    method = 5;
                    if (isNumeric(volume_one) && isNumeric(pressure_two) && 
                        isNumeric(temp_two) && isNumeric(temp_one) && isNumeric(pressure_one)) {
                        const pressure_two_value = pre(pressure_two_unit, pressure_two);
                        const volume_one_value = vol(volume_one_unit, volume_one);
                        const temp_one_value = temp(temp_one_unit, temp_two);
                        const temp_two_value = temp(temp_two_unit, temp_two);
                        const pressure_one_value = pre(pressure_one_unit, pressure_one);
                        const vf = Math.round(((temp_two_value * pressure_one_value * volume_one_value) / 
                                  (temp_one_value * pressure_two_value)) * 100) / 100;
                        result.tech_volume = vf;
                        // console.log(pressure_two_value,volume_one_value,temp_one_value,temp_two_value,pressure_one_value)

                    } else {
                        result.error = 'Please! Check Your Input.';
                        return result;
                    }
                    break;

                case "6": // Pressure Two
                    method = 6;
                    if (isNumeric(volume_one) && isNumeric(pressure_one) && 
                        isNumeric(temp_two) && isNumeric(volume_two) && isNumeric(temp_one)) {
                        const pressure_one_value = pre(pressure_one_unit, pressure_one);
                        const volume_one_value = vol(volume_one_unit, volume_one);
                        const volume_two_value = vol(volume_two_unit, volume_two);
                        const temp_two_value = temp(temp_two_unit, temp_two);
                        const temp_one_value = temp(temp_one_unit, temp_one);
                        // const pf = Math.round(((temp_two_value * pressure_one_value * volume_one_value) / 
                        //            (temp_one_value * volume_two_value)) * 100) / 100;
                        // result.pressure = pf;
                        const pf = ((temp_two_value * pressure_one_value * volume_one_value) /
                (temp_one_value * volume_two_value));
                    if (Math.abs(pf) < 1e-4) {
                        result.pressure = pf.toExponential();
                    } else {
                        result.pressure = Math.round(pf * 100) / 100;
                    }


                    } else {
                        result.error = 'Please! Check Your Input.';
                        return result;
                    }
                    break;

                default:
                    result.error = 'Invalid calculation type.';
                    return result;
            }

            result.tech_method = method;
            return result;

        } catch (error) {
            return {
                error: 'Calculation error occurred.',
                details: error.message
            };
        }

        // Helper function to check if value is numeric
        function isNumeric(value) {
            return value !== null && value !== undefined && value !== '' && !isNaN(Number(value));
        }
    }


    /**
    * getCalculationGayLussacsLawCalculator: Service Method
    * POST: /api/calculators-lol/gay-lussacs-law-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

  async getCalculationGayLussacsLawCalculator(body) {
    const result = {};

    const selection = body.tech_selection;
    const p1 = body.tech_p1;
    const p1_unit = body.tech_p1_unit;
    const t1 = body.tech_t1;
    const t1_unit = body.tech_t1_unit;
    const p2 = body.tech_p2;
    const p2_unit = body.tech_p2_unit;
    const t2 = body.tech_t2;
    const t2_unit = body.tech_t2_unit;
    const R = body.tech_R;
    const amount = body.tech_amount;
    const v1 = body.tech_v1;

    // Pressure conversion
    function pre(unit, value) {
        switch (unit) {
            case "Pa": return value * 1;
            case "Bar": return value * 100000;
            case "psi": return value * 6895;
            case "at": return value * 98068;
            case "atm": return value * 101325;
            case "Torr": return value * 133.32;
            case "hPa": return value * 100;
            case "kPa": return value * 1000;
            case "MPa": return value * 1000000;
            case "GPa": return value * 1000000000;
            case "inHg": return value * 3386.4;
            case "mmHg": return value * 133.32;
            default: return NaN;
        }
    }

    // Volume conversion
    function vol(unit2, value2) {
        switch (unit2) {
            case "mm³": return value2 * 0.000000001;
            case "cm³": return value2 * 0.000001;
            case "dm³": return value2 * 0.001;
            case "m³": return value2 * 1;
            case "in³": return value2 * 0.000016387;
            case "ft³": return value2 * 0.028317;
            case "yd³": return value2 * 0.7646;
            case "ml": return value2 * 0.000001;
            case "liters": return value2 * 0.001;
            default: return NaN;
        }
    }

    // Temperature conversion
    function temp(unit3, value3) {
          value3 =   Number(value3);
        switch (unit3) {
            case "°C": return value3 + 273.15;
            case "°F": return (value3 - 32) * (5 / 9) + 273.15;
            case "K": return value3 * 1;
            default: return NaN;
        }
    }

    let method, temp2;

    // Selection logic
    if (selection === "1") { // Final Temperature (T2)
        method = 1;
        if (!isNaN(p1) && !isNaN(p2) && !isNaN(t1)) {
            const p1_value = pre(p1_unit, p1);
            const p2_value = pre(p2_unit, p2);
            const t1_value = temp(t1_unit, t1);
            temp2 = (t1_value * p2_value) / p1_value;
        } else {
            result.error = "Please! Check Your Input.";
            return result;
        }
    } 
    else if (selection === "2") { // Final Pressure (P2)
        method = 2;
        if (!isNaN(t1) && !isNaN(t2) && !isNaN(p1)) {
            const p1_value = pre(p1_unit, p1);
            const t1_value = temp(t1_unit, t1);
            const t2_value = temp(t2_unit, t2);
            temp2 = (p1_value * t2_value) / t1_value;
        } else {
            result.error = "Please! Check Your Input.";
            return result;
        }
    } 
    else if (selection === "3") { // Initial Pressure (P1)
        method = 3;
        if (!isNaN(t1) && !isNaN(t2) && !isNaN(p2)) {
            const p2_value = pre(p2_unit, p2);
            const t1_value = temp(t1_unit, t1);
            const t2_value = temp(t2_unit, t2);
            temp2 = (t1_value * p2_value) / t2_value;
        } else {
            result.error = "Please! Check Your Input.";
            return result;
        }
    } 
    else if (selection === "4") { // Initial Temperature (T1)
        method = 4;
        if (!isNaN(p1) && !isNaN(p2) && !isNaN(t2)) {
            const p1_value = pre(p1_unit, p1);
            const p2_value = pre(p2_unit, p2);
            const t2_value = temp(t2_unit, t2);
            temp2 = (t2_value / p2_value) * p1_value;
        } else {
            result.error = "Please! Check Your Input.";
            return result;
        }
    } 
    else if (selection === "5") { // Volume Calculation
        method = 5;
        if (!isNaN(p1) && !isNaN(t1) && !isNaN(amount) && !isNaN(R)) {
            const calculate_volume = (amount * R * t1) / p1;
            result.tech_calculate_volume = calculate_volume;
            result.tech_method = method;
            return result;
        } else {
            result.error = "Please! Check Your Input.";
            return result;
        }
    } 
    else if (selection === "6") { // Amount of Gas (n)
        method = 6;
        if (!isNaN(p1) && !isNaN(t1) && !isNaN(v1) && !isNaN(R)) {
            const n = (p1 * v1) / (R * t1);
            result.tech_n = n;
            result.tech_method = method;
            return result;
        } else {
            result.error = "Please! Check Your Input.";
            return result;
        }
    }

    const amount_of_gas = 1;
    const calculate_volume = (amount_of_gas * R * t1) / p1;

    result.tech_volume = calculate_volume;
    result.tech_amount_of_gas = amount_of_gas;
    result.tech_method = method;
    result.tech_temp = temp2;

    return result;
}

      /**
    * getCalculationMassPercentCalculator: Service Method
    * POST: /api/calculators-lol/mass-percent-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationMassPercentCalculator(body) {
        let find = body.tech_find;
        let mass_solute = body.tech_mass_solute;
        let mass_solute_unit = body.tech_mass_solute_unit;
        let mass_solvent = body.tech_mass_solvent;
        let mass_solvent_unit = body.tech_mass_solvent_unit;
        let mass_percentage = body.tech_mass_percentage;
        let mass_chemical = body.tech_mass_chemical;
        let mass_chemical_unit = body.tech_mass_chemical_unit;
        let total_mass_compound = body.tech_total_mass_compound;
        let total_mass_compound_unit = body.tech_total_mass_compound_unit;
        let first_value = body.tech_first_value;
        let first_value_unit = body.tech_first_value_unit;
        let second_value = body.tech_second_value;
        let second_value_unit = body.tech_second_value_unit;
        let third_value = body.tech_third_value;
        let third_value_unit = body.tech_third_value_unit;
        let four_value = body.tech_four_value;
        let four_value_unit = body.tech_four_value_unit;
        let five_value = body.tech_five_value;
        let five_value_unit = body.tech_five_value_unit;
        let six_value = body.tech_six_value;
        let six_value_unit = body.tech_six_value_unit;


      const result = {};

      // Mass conversion function
      function massConvert(unit, value) {
        const conversions = {
          'µg': 0.000000001,
          'mg': 0.000001,
          'g': 0.001,
          'dag': 0.01,
          'kg': 1,
          't': 1000,
          'oz': 0.02835,
          'lbs': 0.4536
        };
        return conversions[unit] ? value * conversions[unit] : value;
      }

      // Find atomic mass function
      function findAtomicMass(valueUnit, value) {
        console.log(valueUnit,value);
        const atomicMasses = {
          'Atomic mass amu': 12,
          'H (Hydrogen)': 1.00784,
          'He (Helium)': 4.002602,
          'Li (Lithium)': 6.941,
          'Be (Beryllium)': 9.0122,
          'B (Boron)': 10.811,
          'C (Carbon)': 12.011,
          'N (Nitrogen)': 14.0067,
          'O (Oxygen)': 15.9994,
          'F (Fluorine)': 18.998403,
          'Ne (Neon)': 20.179,
          'Na (Sodium)': 22.98977,
          'Mg (Magnesium)': 24.305,
          'Al (Aluminium)': 26.98154,
          'Si (Silicon)': 28.0855,
          'P (Phosphorus)': 30.97376,
          'S (Sulfur)': 32.06,
          'Cl (Chlorine)': 35.453,
          'Ar (Argon)': 39.0983,
          'K (Potassium)': 39.948,
          'Ca (Calcium)': 40.08,
          'Sc (Scandium)': 44.9559,
          'Ti (Titanium)': 47.90,
          'V (Vanadium)': 50.9415,
          'Cr (Chromium)': 51.996,
          'Mn (Manganese)': 54.9380,
          'Fe (Iron)': 55.847,
          'Co ( Cobalt)': 58.9332,
          'Ni (Nickel)': 58.70,
          'Cu (Copper)': 63.546,
          'Zn (Zinc)': 65.38
        };

        const atomicMass = atomicMasses[valueUnit];
        if (valueUnit === 'Atomic mass amu') {
          return [atomicMass, atomicMass];
        }
        return [atomicMass * value, atomicMass];
      }

      // Helper function to check if value is numeric
      function isNumeric(value) {
        return !isNaN(parseFloat(value)) && isFinite(value);
      }

      let method;

      try {
        if (find === "1") { // Mass Percentage
          method = 1;
          if (isNumeric(mass_solute) && isNumeric(mass_solvent)) {
            const massSoluteValue = massConvert(mass_solute_unit, parseFloat(mass_solute));
            const massSolventValue = massConvert(mass_solvent_unit, parseFloat(mass_solvent));
            const massSolution = massSoluteValue + massSolventValue;
            
            const massPercent = massSolution !== 0 
              ? (massSoluteValue / massSolution) * 100 
              : 0;
            
            result.tech_mass_solution = massSolution;
            result.tech_mass_percent = massPercent;
            result.tech_method = method;
          } else {
            result.error = 'Please! Check Your Input.';
            return result;
          }
        } 
        else if (find === "2") { // Mass Solute
          method = 2;
          if (isNumeric(mass_solvent) && isNumeric(mass_percentage)) {
            const massSolventVal = parseFloat(mass_solvent);
            const massPercentVal = parseFloat(mass_percentage);
            const massSoluteCalc = massSolventVal * massPercentVal / 100 + (massSolventVal / massPercentVal);
            const massSolution = massSolventVal + massSoluteCalc;
            
            result.tech_mass_solution = massSolution;
            result.tech_mass_solute = massSoluteCalc;
            result.tech_method = method;
          } else {
            result.error = 'Please! Check Your Input.';
            return result;
          }
        } 
        else if (find === "3") { // Mass Solvent
          method = 3;
          if (isNumeric(mass_solute) && isNumeric(mass_percentage)) {
            const massSoluteVal = parseFloat(mass_solute);
            const massPercentVal = parseFloat(mass_percentage);
            const massSolventCalc = massSoluteVal * 100 / massPercentVal - massSoluteVal;
            const massSolution = massSoluteVal + massSolventCalc;
            
            result.tech_mass_solution = massSolution;
            result.tech_mass_solvent = massSolventCalc;
            result.tech_method = method;
          } else {
            result.error = 'Please! Check Your Input.';
            return result;
          }
        } 
        else if (find === "4") { // Mass Percentage for a Chemical
          method = 4;
          if (isNumeric(mass_chemical) && isNumeric(total_mass_compound)) {
            const massChemicalValue = massConvert(mass_chemical_unit, parseFloat(mass_chemical));
            const massCompoundValue = massConvert(total_mass_compound_unit, parseFloat(total_mass_compound));
            const massPercent = (massChemicalValue * 100) / massCompoundValue;
            
            result.tech_mass_percent = massPercent;
            result.tech_method = method;
          } else {
            result.error = 'Please! Check Your Input.';
            return result;
          }
        } 
        else if (find === "5") { // Mass of chemical
          method = 5;
          if (isNumeric(total_mass_compound) && isNumeric(mass_percentage)) {
            const massCompoundValue = massConvert(total_mass_compound_unit, parseFloat(total_mass_compound));
            const massOfChemical = (parseFloat(mass_percentage) / 100) * massCompoundValue;
            
            result.tech_mass_of_chemical = massOfChemical;
            result.tech_method = method;
          } else {
            result.error = 'Please! Check Your Input.';
            return result;
          }
        } 
        else if (find === "6") { // Total Mass of Compound
          method = 6;
          if (isNumeric(mass_chemical) && isNumeric(mass_percentage)) {
            const massChemicalValue = massConvert(mass_chemical_unit, parseFloat(mass_chemical));
            const totalMassCompound = (parseFloat(mass_percentage) / 100) * massChemicalValue;
            
            result.tech_total_mass_compound = totalMassCompound;
            result.tech_method = method;
          } else {
            result.error = 'Please! Check Your Input.';
            return result;
          }
        } 
        else if (find === "7") { // Atomic Mass Calculation
          method = 7;
          if (first_value && isNumeric(first_value)) {
            const call = [];
            let value = 1;
            
            const root = findAtomicMass(first_value_unit, parseFloat(first_value));
            console.log(root);
            call.push(root[0]);
            result.tech_punk = parseFloat(first_value);
            result.tech_punk1 = root[1];
            result.tech_value1 = value;
            result.tech_name1 = first_value_unit;
            result.tech_atomic1 = root;

            if (isNumeric(second_value) && second_value) {
              value = 2;
              const root2 = findAtomicMass(second_value_unit, parseFloat(second_value));
              call.push(root2[0]);
              result.tech_punk2 = parseFloat(second_value);
              result.tech_punk3 = root2[1];
              result.tech_value2 = value;
              result.tech_name2 = second_value_unit;
              result.tech_atomic2 = root2;
            }

            if (isNumeric(third_value) && third_value) {
              value = 3;
              const root3 = findAtomicMass(third_value_unit, parseFloat(third_value));
              call.push(root3[0]);
              result.tech_punk4 = parseFloat(third_value);
              result.tech_punk5 = root3[1];
              result.tech_value3 = value;
              result.tech_name3 = third_value_unit;
              result.tech_atomic3 = root3;
            }

            if (isNumeric(four_value) && four_value) {
              value = 4;
              const root4 = findAtomicMass(four_value_unit, parseFloat(four_value));
              call.push(root4[0]);
              result.tech_punk6 = parseFloat(four_value);
              result.tech_punk7 = root4[1];
              result.tech_value4 = value;
              result.tech_name4 = four_value_unit;
              result.tech_atomic4 = root4;
            }

            if (isNumeric(five_value) && five_value) {
              value = 5;
              const root5 = findAtomicMass(five_value_unit, parseFloat(five_value));
              call.push(root5[0]);
              result.tech_punk8 = parseFloat(five_value);
              result.tech_punk9 = root5[1];
              result.tech_value5 = value;
              result.tech_name5 = five_value_unit;
              result.tech_atomic5 = root5;
            }

            if (isNumeric(six_value) && six_value) {
              value = 6;
              const root6 = findAtomicMass(six_value_unit, parseFloat(six_value));
              call.push(root6[0]);
              result.tech_punk10 = parseFloat(six_value);
              result.tech_punk11 = root6[1];
              result.tech_value6 = value;
              result.tech_name6 = six_value_unit;
              result.tech_atomic6 = root6;
            }

            const totalMass = call.reduce((sum, val) => sum + val, 0);
            result.tech_call = totalMass;
            result.tech_method = method;
          } else {
            result.error = 'Please! Check Your Input.';
            return result;
          }
        }
        return result;

      } catch (error) {
        return {
          error: 'An error occurred during calculation.',
          details: error.message
        };
      }
    }

       /**
    * getCalculationRateConstantCalculator: Service Method
    * POST: /api/calculators-lol/rate-constant-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */
    async getCalculationRateConstantCalculator(body) {
      const unit_x = body.tech_unit_x?.trim();
      const module_x = body.tech_module_x?.trim();
      const module_y = body.tech_module_y?.trim();
      const module_z = body.tech_module_z?.trim();
      let unit_a = body.tech_unit_a?.trim();
      let unit_b = body.tech_unit_b?.trim();
      let unit_c = body.tech_unit_c?.trim();
      let time_a = body.tech_time_a?.trim();
      let time_b = body.tech_time_b?.trim();
      let time_c = body.tech_time_c?.trim();
      const half_a = body.tech_half_a?.trim();
      const half_b = body.tech_half_b?.trim();
      const half_c = body.tech_half_c?.trim();
      const con_a = body.tech_con_a?.trim();
      const con_b = body.tech_con_b?.trim();
      const con_c = body.tech_con_c?.trim();

      // Unit A conversion
      if (unit_a == 'M') {
          unit_a = '0';
      } else if (unit_a == 'mM') {
          unit_a = '1';
      } else if (unit_a == 'μM') {
          unit_a = '2';
      } else if (unit_a == 'nM') {
          unit_a = '3';
      }

      // Time A conversion
      if (time_a == 'μs') {
          time_a = '0';
      } else if (time_a == 'ms') {
          time_a = '1';
      } else if (time_a == 'sec') {
          time_a = '2';
      } else if (time_a == 'min') {
          time_a = '3';
      } else if (time_a == 'min/sec') {
          time_a = '4';
      } else if (time_a == 'hrs') {
          time_a = '6';
      }

      // Unit B conversion
      if (unit_b == 'M') {
          unit_b = '0';
      } else if (unit_b == 'mM') {
          unit_b = '1';
      } else if (unit_b == 'μM') {
          unit_b = '2';
      } else if (unit_b == 'nM') {
          unit_b = '3';
      }

      // Time B conversion
      if (time_b == 'μs') {
          time_b = '0';
      } else if (time_b == 'ms') {
          time_b = '1';
      } else if (time_b == 'sec') {
          time_b = '2';
      } else if (time_b == 'min') {
          time_b = '3';
      } else if (time_b == 'min/sec') {
          time_b = '4';
      } else if (time_b == 'hrs') {
          time_b = '6';
      }

      // Unit C conversion
      if (unit_c == 'M') {
          unit_c = '0';
      } else if (unit_c == 'mM') {
          unit_c = '1';
      } else if (unit_c == 'μM') {
          unit_c = '2';
      } else if (unit_c == 'nM') {
          unit_c = '3';
      }

      // Time C conversion
      if (time_c == 'μs') {
          time_c = '0';
      } else if (time_c == 'ms') {
          time_c = '1';
      } else if (time_c == 'sec') {
          time_c = '2';
      } else if (time_c == 'min') {
          time_c = '3';
      } else if (time_c == 'min/sec') {
          time_c = '4';
      } else if (time_c == 'hrs') {
          time_c = '6';
      }

      // Helper function for concentration calculation
      function calculate(a, b) {
          let convert;
          if (b == '0') {
              convert = a * 1;
          } else if (b == '1') {
              convert = a * 0.001;
          } else if (b == '2') {
              convert = a * 0.000001;
          } else if (b == '3') {
              convert = a * 0.000000001;
          }
          return convert;
      }

      // Helper function for time calculation
      function calculatet(a, b) {
          let convert;
          if (b == '0') {
              convert = a * 0.000001;
          } else if (b == '1') {
              convert = a * 0.001;
          } else if (b == '2') {
              convert = a * 1;
          } else if (b == '3') {
              convert = a * 60;
          } else if (b == '4') {
              convert = a * 3600;
          }
          return convert;
      }

      let check = true;
      let rate_res, k_res, b_res, c_res, a_res;
      k_res = 0;
      rate_res = 0;
      if (unit_x == 'uni') {
          if (module_x === '0') {
              if (!isNaN(con_a) && !isNaN(half_a)) {
                  const conca = calculate(parseFloat(con_a), unit_a);
                  const htime = calculatet(parseFloat(half_a), time_a);
                  k_res = conca / (2 * htime);
                  rate_res = k_res;
              } else {
                  check = false;
              }
          } else if (module_x == '1') {
              if (!isNaN(con_a) && !isNaN(half_a)) {
                  const conca = calculate(parseFloat(con_a), unit_a);
                  const htime = calculatet(parseFloat(half_a), time_a);
                  k_res = 0.693 / htime;
                  rate_res = k_res * conca;
              } else {
                  check = false;
              }
          } else {
              if (!isNaN(con_a) && !isNaN(half_a)) {
                  const conca = calculate(parseFloat(con_a), unit_a);
                  const htime = calculatet(parseFloat(half_a), time_a);
                  k_res = 1 / (htime * conca);
                  rate_res = k_res * (conca * conca);
              } else {
                  check = false;
              }
          }
      } else if (unit_x == 'bi') {
          if (module_x == '1' && module_y == '1') {
              if (!isNaN(con_a) && !isNaN(half_a)) {
                  const conca = calculate(parseFloat(con_a), unit_a);
                  const concb = calculate(parseFloat(con_b), unit_b);
                  const htime = calculatet(parseFloat(half_a), time_b);
                  k_res = 0.693 / htime;
                  rate_res = k_res * conca * concb;
                  rate_res = parseFloat(rate_res.toFixed(15));
              } else {
                  check = false;
              }
          } else if (module_x == '1' && module_y == '2') {
              if (!isNaN(con_a) && !isNaN(half_a)) {
                  const conca = calculate(parseFloat(con_a), unit_a);
                  const concb = calculate(parseFloat(con_b), unit_b);
                  const htime = calculatet(parseFloat(half_a), time_b);
                  k_res = 0.693 / htime;
                  b_res = 1 / (k_res * concb);
                  b_res = Math.round(b_res);
                  rate_res = k_res * conca * (concb * concb);
                  rate_res = parseFloat(rate_res.toFixed(15));
              } else {
                  check = false;
              }
          } else if (module_x == '2' && module_y == '1') {
              if (!isNaN(con_a) && !isNaN(half_a)) {
                  const conca = calculate(parseFloat(con_a), unit_a);
                  const concb = calculate(parseFloat(con_b), unit_b);
                  const htime = calculatet(parseFloat(half_a), time_b);
                  k_res = 1 / (conca * htime);
                  b_res = 0.693 / k_res;
                  b_res = parseFloat(b_res.toFixed(8));
                  rate_res = k_res * concb * (conca * conca);
                  rate_res = parseFloat(rate_res.toFixed(12));
              } else {
                  check = false;
              }
          }
      } else {
          if (module_x == '1' && module_y == '1' && module_z == '1') {
              if ((!isNaN(con_a) && !isNaN(con_b)) || !isNaN(con_c) || (!isNaN(half_a) && !isNaN(half_b)) || !isNaN(half_c)) {
                  const conca = calculate(parseFloat(con_a), unit_a);
                  const concb = calculate(parseFloat(con_b), unit_b);
                  const concd = calculate(parseFloat(con_c), unit_c);
                  const htime = calculatet(parseFloat(half_a), time_a);
                  k_res = 0.693 / htime;
                  rate_res = k_res * conca * concb * concd;
                  rate_res = parseFloat(rate_res.toFixed(15));
              } else {
                  check = false;
              }
          } else if (module_x == '1' && module_y == '2' && module_z == '1') {
              if ((!isNaN(con_a) && !isNaN(con_b)) || !isNaN(con_c) || (!isNaN(half_a) && !isNaN(half_b)) || !isNaN(half_c)) {
                  const conca = calculate(parseFloat(con_a), unit_a);
                  const concb = calculate(parseFloat(con_b), unit_b);
                  const concc = calculate(parseFloat(con_c), unit_c);
                  const htime = calculatet(parseFloat(half_a), time_a);
                  k_res = 0.693 / htime;
                  b_res = 1 / (k_res * concb);
                  b_res = parseFloat(b_res.toFixed(5));
                  rate_res = k_res * conca * concb * concb * concc;
                  rate_res = parseFloat(rate_res.toFixed(15));
              } else {
                  check = false;
              }
          } else if (module_x == '1' && module_y == '1' && module_z == '2') {
              if ((!isNaN(con_a) && !isNaN(con_b)) || !isNaN(con_c) || (!isNaN(half_a) && !isNaN(half_b)) || !isNaN(half_c)) {
                  const conca = calculate(parseFloat(con_a), unit_a);
                  const concb = calculate(parseFloat(con_b), unit_b);
                  const concc = calculate(parseFloat(con_c), unit_c);
                  const htime = calculatet(parseFloat(half_a), time_a);
                  k_res = 0.693 / htime;
                  c_res = 1 / (k_res * concc);
                  c_res = parseFloat(c_res.toFixed(5));
                  rate_res = k_res * conca * concb * concc * concc;
                  rate_res = parseFloat(rate_res.toFixed(15));
              } else {
                  check = false;
              }
          } else if (module_x == '2' && module_y == '1' && module_z == '1') {
              if ((!isNaN(con_a) && !isNaN(con_b)) || !isNaN(con_c) || (!isNaN(half_a) && !isNaN(half_b)) || !isNaN(half_c)) {
                  const conca = calculate(parseFloat(con_a), unit_a);
                  const concb = calculate(parseFloat(con_b), unit_b);
                  const concc = calculate(parseFloat(con_c), unit_c);
                  const htime = calculatet(parseFloat(half_b), time_b);
                  k_res = 0.693 / htime;
                  c_res = 1 / (k_res * conca);
                  c_res = parseFloat(c_res.toFixed(5));
                  rate_res = k_res * conca * conca * concb * concc;
                  rate_res = parseFloat(rate_res.toFixed(15));
              } else {
                  check = false;
              }
          } else if (module_x == '2' && module_y == '2' && module_z == '1') {
              if ((!isNaN(con_a) && !isNaN(con_b)) || !isNaN(con_c) || (!isNaN(half_a) && !isNaN(half_b)) || !isNaN(half_c)) {
                  const conca = calculate(parseFloat(con_a), unit_a);
                  const concb = calculate(parseFloat(con_b), unit_b);
                  const concc = calculate(parseFloat(con_c), unit_c);
                  const htime = calculatet(parseFloat(half_c), time_c);
                  k_res = 0.693 / htime;
                  a_res = 1 / (k_res * conca);
                  a_res = parseFloat(a_res.toFixed(5));
                  b_res = 1 / (k_res * concb);
                  b_res = parseFloat(b_res.toFixed(5));
                  rate_res = k_res * conca * conca * concb * concb * concc;
                  rate_res = parseFloat(rate_res.toFixed(15));
              } else {
                  check = false;
              }
          } else if (module_x == '1' && module_y == '2' && module_z == '2') {
              if ((!isNaN(con_a) && !isNaN(con_b)) || !isNaN(con_c) || (!isNaN(half_a) && !isNaN(half_b)) || !isNaN(half_c)) {
                  const conca = calculate(parseFloat(con_a), unit_a);
                  const concb = calculate(parseFloat(con_b), unit_b);
                  const concc = calculate(parseFloat(con_c), unit_c);
                  const htime = calculatet(parseFloat(half_a), time_a);
                  k_res = 0.693 / htime;
                  c_res = 1 / (k_res * concc);
                  c_res = parseFloat(c_res.toFixed(5));
                  b_res = 1 / (k_res * concb);
                  b_res = parseFloat(b_res.toFixed(5));
                  rate_res = k_res * concc * concc * concb * concb * conca;
                  rate_res = parseFloat(rate_res.toFixed(15));
              } else {
                  check = false;
              }
          } else if (module_x == '2' && module_y == '2' && module_z == '2') {
              if ((!isNaN(con_a) && !isNaN(con_b)) || !isNaN(con_c) || (!isNaN(half_a) && !isNaN(half_b)) || !isNaN(half_c)) {
                  const conca = calculate(parseFloat(con_a), unit_a);
                  const concb = calculate(parseFloat(con_b), unit_b);
                  const concc = calculate(parseFloat(con_c), unit_c);
                  const htime = calculatet(parseFloat(half_a), time_a);
                  k_res = 1 / (htime * conca);
                  k_res = parseFloat(k_res.toFixed(5));
                  b_res = 1 / (k_res * concb);
                  b_res = parseFloat(b_res.toFixed(5));
                  c_res = 1 / (k_res * concc);
                  c_res = parseFloat(c_res.toFixed(5));
                  rate_res = k_res * conca * conca * concb * concb * concc * concc;
                  rate_res = parseFloat(rate_res.toFixed(15));
              } else {
                  check = false;
              }
          }
      }
      if (check === true) {
          return {
              tech_rate_res: rate_res,
              tech_k_res: k_res
          };
      } else {
          return {
              error: 'Please! Check Your Input.'
          };
      }
  }


      /**
    * getCalculationSalaryCalculator: Service Method
    * POST: /api/calculators-lol/salary-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */
      async getCalculationSalaryCalculator(body) {
      let salary = body.tech_salary;
      let hours = body.tech_hours;
      let days = body.tech_days;
      let per = body.tech_per;
      let holidays = body.tech_holidays ?? 0;
      let vacation = body.tech_vacation ?? 0;
      let tax = body.tech_tax;
      let are = body.tech_are;


      // Validation
      if (!isNumeric(salary) || !isNumeric(hours)) {
        return { error: 'Please fill all fields.' };
      }

      const salaryNum = parseFloat(salary);
      const weekHours = parseFloat(hours);
      const weekDay = parseFloat(days);
      const yearlyHours = weekHours * 52;
      const dailyHours = weekHours / weekDay;
      // console.log(salaryNum,weekHours,weekDay,dailyHours);
      let hourly, daily, week, biWeek, yearly, monthly, semiMonth, quarterly;
      let aHourly, aDaily, aWeek, aBiWeek, aYearly, aMonthly, aSemiMonth, aQuarterly;

      // Calculate based on payment period
      switch (per) {
        case 'Hourly':
          hourly = salaryNum;
          daily = round(salaryNum * dailyHours, 2);
          week = round(weekHours * salaryNum);
          biWeek = round(week * 2);
          yearly = round(yearlyHours * salaryNum);
          monthly = round(yearly / 12);
          semiMonth = round(monthly / 2);
          quarterly = round(yearly / 4);
          break;

        case 'Daily':
          daily = salaryNum;
          hourly = round(salaryNum / dailyHours, 2);
          week = round(weekHours * hourly);
          biWeek = round(week * 2);
          yearly = round(yearlyHours * hourly);
          monthly = round(yearly / 12);
          semiMonth = round(monthly / 2);
          quarterly = round(yearly / 4);
          break;

        case 'Weekly':
          aWeek = salaryNum;
          aHourly = round(aWeek / weekHours, 2);
          aDaily = round(aHourly * dailyHours, 2);
          aBiWeek = round(aWeek * 2);
          aYearly = round(yearlyHours * aHourly);
          aMonthly = round(aYearly / 12);
          aSemiMonth = round(aMonthly / 2);
          aQuarterly = round(aYearly / 4);
          break;

        case 'Bi-Weekly':
          aBiWeek = salaryNum;
          aWeek = round(aBiWeek * 2);
          aHourly = round(aWeek / weekHours, 2);
          aDaily = round(aHourly * dailyHours, 2);
          aYearly = round(yearlyHours * aHourly);
          aMonthly = round(aYearly / 12);
          aSemiMonth = round(aMonthly / 2);
          aQuarterly = round(aYearly / 4);
          console.log(aBiWeek,aWeek);
          break;

        case 'Semi-Monthly':
          aSemiMonth = salaryNum;
          aMonthly = round(aSemiMonth * 2);
          aYearly = round(aMonthly * 12);
          aQuarterly = round(aYearly / 4);
          aHourly = round(aYearly / yearlyHours, 2);
          aDaily = round(aHourly * dailyHours, 2);
          aWeek = round(weekHours * aDaily);
          aBiWeek = round(aWeek * 2);
          break;

        case 'Monthly':
          aYearly = round(salaryNum * 12);
          aQuarterly = round(aYearly / 4);
          aSemiMonth = round(salaryNum / 2);
          aHourly = round(aYearly / yearlyHours, 2);
          aWeek = round(weekHours * aHourly);
          aBiWeek = round(aWeek * 2);
          aDaily = round(aHourly * dailyHours, 2);
          aMonthly = salaryNum;
          break;

        case 'Quarterly':
          aQuarterly = salaryNum;
          aYearly = round(aQuarterly * 4);
          aHourly = round(aYearly / yearlyHours, 2);
          aDaily = round(aHourly * dailyHours, 2);
          aWeek = round(weekHours * aDaily);
          aBiWeek = round(aWeek * 2);
          aMonthly = round(aYearly / 12);
          aSemiMonth = round(aMonthly / 2);
          break;

        case 'Annual':
          aYearly = salaryNum;
          aHourly = round(aYearly / yearlyHours, 2);
          aDaily = round(aHourly * dailyHours, 2);
          aWeek = round(weekHours * aHourly);
          aBiWeek = round(aWeek * 2);
          aMonthly = round(aYearly / 12);
          aSemiMonth = round(aMonthly / 2);
          aQuarterly = round(aYearly / 4);
          // console.log(aYearly,aHourly,aDaily,aWeek,aBiWeek,aMonthly,aSemiMonth,aQuarterly);
          break;

        default:
          return { error: 'Invalid payment period.' };
      }

      // Handle holidays and vacation
      const totalLeaves = (isNumeric(holidays) ? parseFloat(holidays) : 0) + 
                          (isNumeric(vacation) ? parseFloat(vacation) : 0);
      if (totalLeaves != 0) {
    
        if (per === 'Hourly' || per === 'Daily') {
          const subSalary = daily * totalLeaves;
          aYearly = round(yearly - subSalary);
          aHourly = round(aYearly / yearlyHours, 2);
          aQuarterly = round(aYearly / 4);
          aMonthly = round(aYearly / 12);
          aSemiMonth = round(aMonthly / 2);
          aDaily = round(aHourly * dailyHours, 2);
          aWeek = round(weekHours * aHourly);
          aBiWeek = round(aWeek * 2);
        } else {
          const hh = (260 - totalLeaves) / 5;
          hourly = aMonthly / ((hh / 12) * weekHours);
          // console.log(hourly,hh,aMonthly,weekHours);
          yearly = round(hourly * yearlyHours);
          quarterly = round(yearly / 4);
          monthly = round(yearly / 12);
          semiMonth = round(monthly / 2);
          daily = round(hourly * dailyHours, 2);
          week = round(weekHours * hourly);
          biWeek = round(week * 2);
          // console.log(hh,hourly,yearly,quarterly,monthly,semiMonth,daily,week,biWeek);
        }
      } else {
        if (per === 'Hourly' || per === 'Daily') {
          aYearly = yearly;
          aQuarterly = quarterly;
          aMonthly = monthly;
          aSemiMonth = semiMonth;
          aBiWeek = biWeek;
          aWeek = week;
          aDaily = daily;
          aHourly = hourly;
        } else {
          yearly = aYearly;
          quarterly = aQuarterly;
          monthly = aMonthly;
          semiMonth = aSemiMonth;
          biWeek = aBiWeek;
          week = aWeek;
          daily = aDaily;
          hourly = aHourly;
        }
      }

      // Prepare result
      const result = {
        tech_Hourly: round(hourly, 2),
        tech_Daily: daily,
        tech_Week: week,
        tech_Bi_week: biWeek,
        tech_Monthly: monthly,
        tech_Sami_month: semiMonth,
        tech_Quarterly: quarterly,
        tech_Yearly: yearly,
        tech_a_Hourly: round(aHourly, 2),
        tech_a_Daily: aDaily,
        tech_a_Week: aWeek,
        tech_a_Bi_week: aBiWeek,
        tech_a_Monthly: aMonthly,
        tech_a_Sami_month: aSemiMonth,
        tech_a_Quarterly: aQuarterly,
        tech_a_Yearly: aYearly,
      };

      // Handle tax calculation
      if (isNumeric(tax)) {
        const taxNum = parseFloat(tax);
        if (are == "1") {
          result.tax = taxNum / 100;
        } else {
          result.tax = 1 - (taxNum / 100);
        }
      }

      return result;
      
      // Helper functions
      function isNumeric(value) {
        return value !== null && value !== undefined && value !== '' && !isNaN(parseFloat(value)) && isFinite(value);
      }
      
      function round(value, decimals = 0) {
        return Math.round(value * Math.pow(10, decimals)) / Math.pow(10, decimals);
      }
    }

      /**
    * getCalculationTaxCalculator: Service Method
    * POST: /api/calculators-lol/salary-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */
   async getCalculationTaxCalculator(body) {
    const result = {};
    
        // Validate input
        if (!this.isNumeric(body.tech_income) || !body.tech_f_state) {
            result.error = 'Please! Check Your Input.';
            return result;
        }

        let income = parseFloat(body.tech_income);
        let s = 0;
        let tax = 0;
        let m_tax = 0;

        // Deduct k_con if provided
        if (this.isNumeric(body.tech_k_con)) {
            income = income - parseFloat(body.tech_k_con);
        }

        // Deduct IRA if provided
        if (this.isNumeric(body.tech_ira)) {
            income = income - parseFloat(body.tech_ira);
        }

        // Handle itemized deductions
        if (body.tech_ded == 'i') {
            if (body.tech_item) {
                income = income - parseFloat(body.tech_item);
                s = parseFloat(body.tech_item);
            } else {
                result.error = 'Please Itemized Deductions.';
                return result;
            }
        }

        // Tax Year 2019
        if (body.tech_tax_year == '2019') {
            if (body.tech_ded == 's') {
                if (body.tech_f_state == 's' || body.tech_f_state == 'm_s') {
                    if (body.tech_age < 65) {
                        income = income - 12200;
                        s = 12200;
                    } else {
                        income = income - 13800;
                        s = 13800;
                    }
                } else if (body.tech_f_state === 'm_j') {
                    if (body.tech_age < 65) {
                        income = income - 24400;
                        s = 24400;
                    } else {
                        income = income - 25700;
                        s = 25700;
                    }
                } else {
                    if (body.tech_age < 65) {
                        income = income - 18350;
                        s = 18350;
                    } else {
                        income = income - 19950;
                        s = 19950;
                    }
                }
            }

            // Handle negative income
            if (income < 0) {
                return this.handleNegativeIncome(body);
            }

            // Calculate tax based on filing status
            if (body.tech_f_state == 's') {
                tax = this.calculateTax2019Single(income);
                m_tax = this.getMarginalTaxRate2019Single(income);
            } else if (body.tech_f_state == 'm_j' || body.tech_f_state == 'w') {
                tax = this.calculateTax2019MarriedJoint(income);
                m_tax = this.getMarginalTaxRate2019MarriedJoint(income);
            } else if (body.tech_f_state == 'm_s') {
                tax = this.calculateTax2019MarriedSeparate(income);
                m_tax = this.getMarginalTaxRate2019MarriedSeparate(income);
            } else if (body.tech_f_state == 'h') {
                tax = this.calculateTax2019HeadOfHousehold(income);
                m_tax = this.getMarginalTaxRate2019HeadOfHousehold(income);
            }
        }
        // Tax Year 2020
        else if (body.tech_tax_year == '2020') {
            if (body.tech_ded == 's') {
                if (body.tech_f_state == 's' || body.tech_f_state == 'm_s') {
                    income = income - 12400;
                    s = 12400;
                } else if (body.tech_f_state == 'm_j') {
                    income = income - 24800;
                    s = 24800;
                } else {
                    income = income - 18650;
                    s = 18650;
                }
            }

            // Handle negative income
            if (income < 0) {
                return this.handleNegativeIncome(body);
            }

            // Calculate tax based on filing status
            if (body.tech_f_state == 's') {
                tax = this.calculateTax2020Single(income);
                m_tax = this.getMarginalTaxRate2020Single(income);
            } else if (body.tech_f_state == 'm_j' || body.tech_f_state == 'w') {
                tax = this.calculateTax2020MarriedJoint(income);
                m_tax = this.getMarginalTaxRate2020MarriedJoint(income);
            } else if (body.tech_f_state == 'm_s') {
                tax = this.calculateTax2020MarriedSeparate(income);
                m_tax = this.getMarginalTaxRate2020MarriedSeparate(income);
            } else if (body.tech_f_state == 'h') {
                tax = this.calculateTax2020HeadOfHousehold(income);
                m_tax = this.getMarginalTaxRate2020HeadOfHousehold(income);
            }
        }

        // Calculate final results
        const a = income;
        const b = Math.round((tax / body.tech_income) * 100 * 100) / 100;
        const c = tax;
        let d = 0;

        if (this.isNumeric(body.tech_tax_with)) {
            d = parseFloat(body.tech_tax_with);
            tax = tax - d;
        }

        result.a = this.formatNumber(a);
        result.b = b;
        result.s = s;
        result.m_tax = m_tax;
        result.c = this.formatNumber(c);
        result.d = this.formatNumber(d);

        if (tax > 0) {
            result.e = this.formatNumber(tax);
        }
        if (tax < 0) {
            result.f = this.formatNumber(Math.abs(tax));
        }

        result.RESULT = 1;
        return result;
    }

    // Helper method for numeric check
    isNumeric(value) {
        return value !== null && value !== undefined && value !== '' && !isNaN(parseFloat(value));
    }

    // Helper method to format numbers
    formatNumber(num) {
        return parseFloat(num).toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
    }

    // Handle negative income
    handleNegativeIncome(body) {
        const result = {
            a: 0,
            b: 0,
            c: 0,
            d: 0,
            f: 0,
        };

        if (this.isNumeric(body.tech_tax_with)) {
            result.d = parseFloat(body.tech_tax_with);
            result.f = result.f + parseFloat(body.tech_tax_with);
        }

        return result;
    }

    // 2019 Single Tax Calculation
    calculateTax2019Single(income) {
        let tax = 0;

        if (income <= 9700) {
            tax = income * 0.10;
        } else if (income <= 39475) {
            tax = 970 + (income - 9700) * 0.12;
        } else if (income <= 84200) {
            tax = 970 + 3573 + (income - 39475) * 0.22;
        } else if (income <= 160725) {
            tax = 970 + 3573 + 9839.5 + (income - 84200) * 0.24;
        } else if (income <= 204100) {
            tax = 970 + 3573 + 9839.5 + 18366 + (income - 160725) * 0.32;
        } else if (income <= 510300) {
            tax = 970 + 3573 + 9839.5 + 18366 + 13880 + (income - 204100) * 0.35;
        } else {
            tax = 970 + 3573 + 9839.5 + 18366 + 13880 + 107170 + (income - 510300) * 0.37;
        }

        return tax;
    }

    getMarginalTaxRate2019Single(income) {
        if (income <= 9700) return 10;
        if (income <= 39475) return 12;
        if (income <= 84200) return 22;
        if (income <= 160725) return 24;
        if (income <= 204100) return 32;
        if (income <= 510300) return 35;
        return 37;
    }

    // 2019 Married Joint/Widow Tax Calculation
    calculateTax2019MarriedJoint(income) {
        let tax = 0;

        if (income <= 19400) {
            tax = income * 0.10;
        } else if (income <= 78950) {
            tax = 1940 + (income - 19400) * 0.12;
        } else if (income <= 168400) {
            tax = 9086 + (income - 78950) * 0.22;
        } else if (income <= 321450) {
            tax = 28765 + (income - 168400) * 0.24;
        } else if (income <= 408200) {
            tax = 65497 + (income - 321450) * 0.32;
        } else if (income <= 612350) {
            tax = 93257 + (income - 408200) * 0.35;
        } else {
            tax = 164709.50 + (income - 612350) * 0.37;
        }

        return tax;
    }

    getMarginalTaxRate2019MarriedJoint(income) {
        if (income <= 19400) return 10;
        if (income <= 78950) return 12;
        if (income <= 168400) return 22;
        if (income <= 321450) return 24;
        if (income <= 408200) return 32;
        if (income <= 612350) return 35;
        return 37;
    }

    // 2019 Married Separate Tax Calculation
    calculateTax2019MarriedSeparate(income) {
        let tax = 0;

        if (income <= 9700) {
            tax = income * 0.10;
        } else if (income <= 39475) {
            tax = 970 + (income - 9700) * 0.12;
        } else if (income <= 84200) {
            tax = 4543 + (income - 39475) * 0.22;
        } else if (income <= 160725) {
            tax = 14382.50 + (income - 84200) * 0.24;
        } else if (income <= 204100) {
            tax = 32748.50 + (income - 160725) * 0.32;
        } else if (income <= 306175) {
            tax = 46628.50 + (income - 204100) * 0.35;
        } else {
            tax = 82354.75 + (income - 306175) * 0.37;
        }

        return tax;
    }

    getMarginalTaxRate2019MarriedSeparate(income) {
        if (income <= 9700) return 10;
        if (income <= 39475) return 12;
        if (income <= 84200) return 22;
        if (income <= 160725) return 24;
        if (income <= 204100) return 32;
        if (income <= 306175) return 35;
        return 37;
    }

    // 2019 Head of Household Tax Calculation
    calculateTax2019HeadOfHousehold(income) {
        let tax = 0;

        if (income <= 13850) {
            tax = income * 0.10;
        } else if (income <= 52850) {
            tax = 1385 + (income - 13850) * 0.12;
        } else if (income <= 84200) {
            tax = 6065 + (income - 52850) * 0.22;
        } else if (income <= 160700) {
            tax = 12962 + (income - 84200) * 0.24;
        } else if (income <= 204100) {
            tax = 31322 + (income - 160700) * 0.32;
        } else if (income <= 510300) {
            tax = 45210 + (income - 204100) * 0.35;
        } else {
            tax = 152380 + (income - 510300) * 0.37;
        }

        return tax;
    }

    getMarginalTaxRate2019HeadOfHousehold(income) {
        if (income <= 13850) return 10;
        if (income <= 52850) return 12;
        if (income <= 84200) return 22;
        if (income <= 160700) return 24;
        if (income <= 204100) return 32;
        if (income <= 510300) return 35;
        return 37;
    }

    // 2020 Single Tax Calculation
    calculateTax2020Single(income) {
        let tax = 0;

        if (income <= 9875) {
            tax = income * 0.10;
        } else if (income <= 40125) {
            tax = 987.5 + (income - 9875) * 0.12;
        } else if (income <= 85525) {
            tax = 987.5 + 3630 + (income - 40125) * 0.22;
        } else if (income <= 163300) {
            tax = 987.5 + 3630 + 9988 + (income - 85525) * 0.24;
        } else if (income <= 207350) {
            tax = 987.5 + 3630 + 9988 + 18666 + (income - 163300) * 0.32;
        } else if (income <= 518400) {
            tax = 987.5 + 3630 + 9988 + 18666 + 14096 + (income - 207350) * 0.35;
        } else {
            tax = 987.5 + 3630 + 9988 + 18666 + 14096 + 108567.5 + (income - 518400) * 0.37;
        }

        return tax;
    }

    getMarginalTaxRate2020Single(income) {
        if (income <= 9875) return 10;
        if (income <= 40125) return 12;
        if (income <= 85525) return 22;
        if (income <= 163300) return 24;
        if (income <= 207350) return 32;
        if (income <= 518400) return 35;
        return 37;
    }

    // 2020 Married Joint/Widow Tax Calculation
    calculateTax2020MarriedJoint(income) {
        let tax = 0;

        if (income <= 19750) {
            tax = income * 0.10;
        } else if (income <= 80250) {
            tax = 1975 + (income - 19750) * 0.12;
        } else if (income <= 171050) {
            tax = 1975 + 7260 + (income - 80250) * 0.22;
        } else if (income <= 326600) {
            tax = 1975 + 7260 + 19976 + (income - 171050) * 0.24;
        } else if (income <= 414700) {
            tax = 1975 + 7260 + 19976 + 37332 + (income - 326600) * 0.32;
        } else if (income <= 622050) {
            tax = 1975 + 7260 + 19976 + 37332 + 28192 + (income - 414700) * 0.35;
        } else {
            tax = 1975 + 7260 + 19976 + 37332 + 28192 + 72872.5 + (income - 622050) * 0.37;
        }

        return tax;
    }

    getMarginalTaxRate2020MarriedJoint(income) {
        if (income <= 19750) return 10;
        if (income <= 80250) return 12;
        if (income <= 171050) return 22;
        if (income <= 326600) return 24;
        if (income <= 414700) return 32;
        if (income <= 622050) return 35;
        return 37;
    }

    // 2020 Married Separate Tax Calculation
    calculateTax2020MarriedSeparate(income) {
        let tax = 0;

        if (income <= 9875) {
            tax = income * 0.10;
        } else if (income <= 40125) {
            tax = 987.5 + (income - 9875) * 0.12;
        } else if (income <= 85525) {
            tax = 987.5 + 3630 + (income - 40125) * 0.22;
        } else if (income <= 163300) {
            tax = 987.5 + 3630 + 9988 + (income - 85525) * 0.24;
        } else if (income <= 207350) {
            tax = 987.5 + 3630 + 9988 + 18666 + (income - 163300) * 0.32;
        } else if (income <= 311025) {
            tax = 987.5 + 3630 + 9988 + 18666 + 14096 + (income - 207350) * 0.35;
        } else {
            tax = 987.5 + 3630 + 9988 + 18666 + 14096 + 36286.25 + (income - 311025) * 0.37;
        }

        return tax;
    }

    getMarginalTaxRate2020MarriedSeparate(income) {
        if (income <= 9875) return 10;
        if (income <= 40125) return 12;
        if (income <= 85525) return 22;
        if (income <= 163300) return 24;
        if (income <= 207350) return 32;
        if (income <= 311025) return 35;
        return 37;
    }

    // 2020 Head of Household Tax Calculation
    calculateTax2020HeadOfHousehold(income) {
        let tax = 0;

        if (income <= 14100) {
            tax = income * 0.10;
        } else if (income <= 53700) {
            tax = 1410 + (income - 14100) * 0.12;
        } else if (income <= 85500) {
            tax = 1410 + 4752 + (income - 53700) * 0.22;
        } else if (income <= 163300) {
            tax = 1410 + 4752 + 6996 + (income - 85500) * 0.24;
        } else if (income <= 207350) {
            tax = 1410 + 4752 + 6996 + 18672 + (income - 163300) * 0.32;
        } else if (income <= 518400) {
            tax = 1410 + 4752 + 6996 + 18672 + 14096 + (income - 207350) * 0.35;
        } else {
            tax = 1410 + 4752 + 6996 + 18672 + 14096 + 108867.5 + (income - 518400) * 0.37;
        }

        return tax;
    }

    getMarginalTaxRate2020HeadOfHousehold(income) {
        if (income <= 14100) return 10;
        if (income <= 53700) return 12;
        if (income <= 85500) return 22;
        if (income <= 163300) return 24;
        if (income <= 207350) return 32;
        if (income <= 518400) return 35;
        return 37;
    }



    /**
    * getCalculationDiscountCalculator: Service Method
    * POST: /api/calculators-lol/discount-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

  async getCalculationDiscountCalculator(request) {
    const param = {};
    // console.log(request);
    var amount = parseFloat(request.amount) || 0;
    const off = parseFloat(request.off) || 0;
    const pay = parseFloat(request.pay) || 0;
    const saving = parseFloat(request.saving) || 0;
    const myLang = request.lang; 
  
      if (myLang == 'ar') {    
        if (request.form_a) {
          if (request.form_a == 'first1') {
            if (!isNaN(request.first1) && !isNaN(request.thir)) {
              const first = parseFloat(request.first1);
              const sec = parseFloat(request.thir);
              const third = Math.round((sec / 100) * first * 100) / 100;
              const dis = first - third;

              param.third = third;
              param.arabic = third;
              param.dis = dis;
              param.RESULT = 1;
              return param;
            } else {
              param.error = 'Please! Check Your Input.';
              return param;
            }
          } else if (request.form_a == 'sec') {
            if (!isNaN(request.sec) && !isNaN(request.thir)) {
              const sec = parseFloat(request.sec);
              const thir = parseFloat(request.thir);
              const first = Math.round((sec / (1 - thir / 100)) * 100) / 100;
              const dis = first - sec;

              param.first = first;
              param.arabic = first;
              param.dis = dis;
              param.RESULT = 1;
              return param;
            } else {
              param.error = 'Please! Check Your Input.';
              return param;
            }
          } else if (request.form_a == 'thir') {
            if (!isNaN(request.sec) && !isNaN(request.first1)) {
              const first = parseFloat(request.first1);
              const sec = parseFloat(request.sec);
              const dis = first - sec;
              const thirl = Math.round(((dis / first) * 100) * 100) / 100;

              param.thirl = thirl;
              param.arabic = thirl;
              param.dis = dis;
              param.RESULT = 1;
              return param;
            } else {
              param.error = 'Please! Check Your Input.';
              return param;
            }
          }
        }

      } else if (myLang == 'id') {
            if (!isNaN(request.id_rp) && !isNaN(request.id_p)) {
              const id_rp = parseFloat(request.id_rp);
              const id_p = parseFloat(request.id_p);
              const discount_id = Math.round(id_rp * (id_p / 100) * 100) / 100;

              param.discount_id = discount_id;
              param.RESULT = 1;
              return param;
            } else {
              param.error = 'Harga Awal & Diskon tidak boleh kosong.';
              return param;
            }

        } else if (myLang == 'tr') {
            const type = request.typet;

            if (!isNaN(request.tx) && !isNaN(request.ty)) {
              let nor, ora, mik, ind;

              const tx = parseFloat(request.tx);
              const ty = parseFloat(request.ty);

              if (type == "1") {
                nor = tx;
                ora = ty;
                mik = Math.round((ora / 100) * nor * 100) / 100;
                ind = nor - mik;
              } else if (type == "2") {
                nor = tx;
                ind = ty;
                mik = nor - ind;
                ora = Math.round((mik / nor) * 100 * 100) / 100;
              } else if (type == "3") {
                nor = tx;
                mik = ty;
                ind = nor - mik;
                ora = Math.round((mik / nor) * 100 * 100) / 100;
              } else if (type == "4") {
                ind = tx;
                ora = ty;
                nor = Math.round((ind / (1 - ora / 100)) * 100) / 100;
                mik = nor - ind;
              } else if (type == "5") {
                ind = tx;
                mik = ty;
                nor = ind + mik;
                ora = Math.round((mik / nor) * 100 * 100) / 100;
              }

              param.nor = nor;
              param.ind = ind;
              param.mik = mik;
              param.ora = ora;
              return param;
            } else {
              param.error = 'Lütfen tüm alanları doldurun.';
              return param;
            }

        } else {
      if (request.type === '1') {
          if (isNaN(amount) && isNaN(off) && isNaN(pay) && isNaN(saving)) {
              param.error = 'Please fill the fields.';
              return param;
          }

          let ans, payt, tax, taxt;

          if (request.tax === 'no') {
              if (!request.sale || isNaN(parseFloat(request.sale))) {
                  param.error = 'Please fill Tax field.';
                  return param;
              }

              if (!pay && !saving) {
                  ans = (amount / 100) * off;
                  // console.log(ans,amount,off);
                  payt = amount - ans;
                  tax = Math.round((parseFloat(request.sale) / 100) * amount);
                  taxt = tax - ((tax / 100) * off);
                  param.tax = tax;
                  param.taxt = taxt;
                  var amount = amount + tax;
                  ans = (amount / 100) * off;
                  param.pay = amount - ans;
              } else if (!pay && !off) {
                  tax = parseFloat(request.sale) / 100;
                  tax = 100 * (1 + tax);
                  ans = (saving / tax) * 100;
                  ans = ans.toFixed(3) + "%";
                  param.pay = amount - saving;
              } else if (!off && !saving) {
                  tax = parseFloat(request.sale) / 100;
                  tax = amount * (1 + tax);
                  ans = (parseFloat(request.sale) / tax) * 100;
                  ans = ans.toFixed(4) + " %";
                  param.pay = amount - pay;
              } else if (!amount && !saving) {
                  tax = parseFloat(request.sale) / 100;
                  tax = 100 * (1 + tax);
                  const percent = off / 100;
                  const original_pr = tax / (1 - percent);
                  param.pay = original_pr - tax;
                  ans = original_pr;
              } else if (!amount && !off) {
                  tax = parseFloat(request.sale) / 100;
                  tax = 100 * (1 + tax);
                  param.pay = tax + saving;
                  ans = (saving / param.pay) * 100;
                  ans = ans.toFixed(3);
              }
          } else {
              if (!pay && !saving) {
                  ans = (amount / 100) * off;
                  param.pay = amount - ans;
                  payt = amount - ans;
              } else if (!pay && !off) {
                  ans = (saving / amount) * 100 + "%";
                  param.pay = amount - saving;
                  payt = amount - ans;
              } else if (!amount && !pay) {
                  ans = (saving / 100) * off;
                  param.pay = saving - ans;
                  payt = saving - ans;
              } else if (!amount && !saving) {
                  const percent = off / 100;
                  const original_pr = pay / (1 - percent);
                  ans = (original_pr - pay).toFixed(4);
                  param.pay = original_pr.toFixed(4);
              } else if (!off && !saving) {
                  ans = amount - pay;
                  param.pay = ans;
                  payt = ans;
              } else if (!amount && !off) {
                  param.pay = saving + pay;
                  ans = (saving / param.pay) * 100;
                  ans = ans.toFixed(3);
                  payt = saving - ans;
              }
          }
          // console.log(amount);
          param.amount = amount;
          param.Ans = ans;
          param.off = off;
          if (!param.pay) param.pay = pay;
          param.payt = payt;
          param.RESULT = 1;
          // console.log(param);
          return param;
      } else if (request.type === '2') {
          const p1 = parseFloat(request.p1);
          const p2 = parseFloat(request.p2);
          const off = parseFloat(request.off);

          if (isNaN(p1) || isNaN(p2) || isNaN(off)) {
              param.error = 'Please fill All fields.';
              return param;
          }

          let ans, pay, payt, tax, taxt, total;

          if (request.tax === 'no') {
              if (isNaN(parseFloat(request.sale))) {
                  param.error = 'Please fill All fields.';
                  return param;
              }

              if (p1 <= p2) {
                  ans = (p1 / 100) * off;
                  payt = (p1 - ans) + p2;
                  tax = (p1 / 100) * parseFloat(request.sale);
                  let newP1 = p1 + tax;
                  ans = (newP1 / 100) * off;
                  const tax2 = (p2 / 100) * parseFloat(request.sale);
                  const newP2 = tax2 + p2;
                  pay = newP1 - ans + newP2;
                  tax = tax + tax2;
                  taxt = pay - payt;
              } else {
                  ans = (p2 / 100) * off;
                  payt = (p2 - ans) + p1;
                  tax = (p2 / 100) * parseFloat(request.sale);
                  let newP2 = p2 + tax;
                  ans = (newP2 / 100) * off;
                  const tax2 = (p1 / 100) * parseFloat(request.sale);
                  const newP1 = tax2 + p1;
                  pay = newP2 - ans + newP1;
                  tax = tax + tax2;
                  taxt = pay - payt;
              }
              total = parseFloat(request.p1) + parseFloat(request.p2) + parseFloat(tax);
              param.tax = tax;
              param.taxt = taxt;
          } else {
              if (p1 <= p2) {
                  ans = (p1 / 100) * off;
                  pay = (p1 - ans) + p2;
                  payt = (p1 - ans) + p2;
              } else {
                  ans = (p2 / 100) * off;
                  pay = (p2 - ans) + p1;
                  payt = (p2 - ans) + p1;
              }
              total = parseFloat(p1) +parseFloat(p2);
          }

          const ave = parseFloat((pay / 2).toFixed(2));
          const stand = 2;

          param.amount = parseFloat(request.p1) + parseFloat(request.p2);
          param.Ans = ans;
          param.ave = ave;
          param.per = parseFloat(((ans / total) * 100).toFixed(1));
          param.stand = stand;
          param.pay = pay;
          param.payt = payt;
          param.RESULT = 1;
          // console.log(ans,total);
          return param;

      } else if (request.type === '3') {
          const p1 = parseFloat(request.p1);
          const p2 = parseFloat(request.p2);
          const p3 = parseFloat(request.p3);
          const off = parseFloat(request.off);

          if (isNaN(p1) || isNaN(p2) || isNaN(p3) || isNaN(off)) {
              param.error = 'Please fill All fields.';
              return param;
          }

          let ans, pay, payt, tax, taxt, total;

          if (request.tax === 'no') {
              if (isNaN(parseFloat(request.sale))) {
                  param.error = 'Please fill All fields.';
                  return false;
              }

              let minPrice = Math.min(p1, p2, p3);
              ans = (minPrice / 100) * off;
              payt = minPrice - ans + (p1 === minPrice ? p2 + p3 : p2 === minPrice ? p1 + p3 : p1 + p2);
              
              const tax1 = (p1 / 100) * parseFloat(request.sale);
              const tax2 = (p2 / 100) * parseFloat(request.sale);
              const tax3 = (p3 / 100) * parseFloat(request.sale);
              
              const newP1 = p1 + tax1;
              const newP2 = p2 + tax2;
              const newP3 = p3 + tax3;
              
              minPrice = Math.min(newP1, newP2, newP3);
              ans = (minPrice / 100) * off;
              pay = minPrice - ans + (newP1 === minPrice ? newP2 + newP3 : newP2 === minPrice ? newP1 + newP3 : newP1 + newP2);
              
              tax = tax1 + tax2 + tax3;
              taxt = pay - payt;
              total = parseFloat(request.p1) + parseFloat(request.p2) + parseFloat(request.p3) + parseFloat(tax);
              param.tax = tax;
              param.taxt = taxt;
          } else {
              const minPrice = Math.min(p1, p2, p3);
              ans = (minPrice / 100) * off;
              pay = minPrice - ans + (p1 === minPrice ? p2 + p3 : p2 === minPrice ? p1 + p3 : p1 + p2);
              payt = pay;
              total = p1 + p2 + p3;
          }

          const ave = parseFloat((pay / 3).toFixed(2));
          const stand = 3;

          param.amount = parseFloat(request.p1) + parseFloat(request.p2) + parseFloat(request.p3);
          param.Ans = ans;
          param.ave = ave;
          param.per = parseFloat(((ans / total) * 100).toFixed(1));
          param.stand = stand;
          param.pay = pay;
          param.payt = payt;
          param.RESULT = 1;
          console.log(param);
          return param;

      } else if (request.type === '4') {
          // Type 4 is identical to Type 1
          return this.getCalculationDiscountCalculator({...request, type: '1'});

      } else if (request.type === '5') {
          const p1 = parseFloat(request.p1);
          const p2 = parseFloat(request.p2);

          if (isNaN(p1) || isNaN(p2)) {
              param.error = 'Please fill All fields.';
              return param;
          }

          let ans, pay, payt, tax, taxt, total;

          if (request.tax === 'no') {
              if (isNaN(parseFloat(request.sale))) {
                  param.error = 'Please fill All fields.';
                  return param;
              }

              if (p1 <= p2) {
                  ans = p1;
                  payt = (p1 - ans) + p2;
                  tax = (p1 / 100) * parseFloat(request.sale);
                  const newP1 = p1 + tax;
                  ans = newP1;
                  const tax2 = (p2 / 100) * parseFloat(request.sale);
                  const newP2 = tax2 + p2;
                  pay = newP1 - ans + newP2;
                  tax = tax + tax2;
                  taxt = pay - payt;
              } else {
                  ans = p2;
                  payt = (p2 - ans) + p1;
                  tax = (p2 / 100) * parseFloat(request.sale);
                  const newP2 = p2 + tax;
                  ans = newP2;
                  const tax2 = (p1 / 100) * parseFloat(request.sale);
                  const newP1 = tax2 + p1;
                  pay = newP2 - ans + newP1;
                  tax = tax + tax2;
                  taxt = pay - payt;
              }
              total = parseFloat(request.p1) + parseFloat(request.p2) + parseFloat(tax);
              param.tax = tax;
              param.taxt = taxt;
          } else {
              if (p1 <= p2) {
                  ans = p1;
                  pay = (p1 - ans) + p2;
                  payt = (p1 - ans) + p2;
              } else {
                  ans = p2;
                  pay = (p2 - ans) + p1;
                  payt = (p2 - ans) + p1;
              }
              total = p1 + p2;
          }

          const ave = parseFloat((pay / 2).toFixed(2));
          const stand = 2;

          param.amount = parseFloat(request.p1) + parseFloat(request.p2);
          param.Ans = ans;
          param.ave = ave;
          param.per = parseFloat(((ans / total) * 100).toFixed(1));
          param.stand = stand;
          param.pay = pay;
          param.payt = payt;
          param.RESULT = 1;
          // console.log(param);
          return param;

      } else if (request.type === '6') {
          const p1 = parseFloat(request.p1);
          const p2 = parseFloat(request.p2);
          const p3 = parseFloat(request.p3);

          if (isNaN(p1) || isNaN(p2) || isNaN(p3)) {
              param.error = 'Please fill All fields.';
              return param;
          }

          let ans, pay, payt, tax, taxt, total;
          const minPrice = Math.min(p1, p2, p3);

          if (request.tax === 'no') {
              if (isNaN(parseFloat(request.sale))) {
                  param.error = 'Please fill All fields.';
                  return param;
              }

              ans = minPrice;
              payt = minPrice - ans + (p1 === minPrice ? p2 + p3 : p2 === minPrice ? p1 + p3 : p1 + p2);
              
              const tax1 = (p1 / 100) * parseFloat(request.sale);
              const tax2 = (p2 / 100) * parseFloat(request.sale);
              const tax3 = (p3 / 100) * parseFloat(request.sale);
              
              const newP1 = p1 + tax1;
              const newP2 = p2 + tax2;
              const newP3 = p3 + tax3;
              
              const newMinPrice = Math.min(newP1, newP2, newP3);
              ans = newMinPrice;
              pay = newMinPrice - ans + (newP1 === newMinPrice ? newP2 + newP3 : newP2 === newMinPrice ? newP1 + newP3 : newP1 + newP2);
              
              tax = tax1 + tax2 + tax3;
              taxt = pay - payt;
              total = parseFloat(request.p1) + parseFloat(request.p2) + parseFloat(request.p3) + parseFloat(tax);
              param.tax = tax;
              param.taxt = taxt;
          } else {
              ans = minPrice;
              pay = minPrice - ans + (p1 === minPrice ? p2 + p3 : p2 === minPrice ? p1 + p3 : p1 + p2);
              payt = pay;
              total = p1 + p2 + p3;
          }

          const ave = parseFloat((pay / 3).toFixed(2));
          const stand = 3;

          param.amount = parseFloat(request.p1) + parseFloat(request.p2) + parseFloat(request.p3);
          param.Ans = ans;
          param.ave = ave;
          param.per = parseFloat(((ans / total) * 100).toFixed(1));
          param.stand = stand;
          param.pay = pay;
          param.payt = payt;
          param.RESULT = 1;
          // console.log(param);
          return param;

      } else if (request.type === '7') {
          const p1 = parseFloat(request.p1);
          const p2 = parseFloat(request.p2);
          const p3 = parseFloat(request.p3);
          const p4 = parseFloat(request.p4);

          if (isNaN(p1) || isNaN(p2) || isNaN(p3) || isNaN(p4)) {
              param.error = 'Please fill All fields.';
              return param;
          }

          let ans, pay, payt, tax, taxt, total, per;
          const minPrice = Math.min(p1, p2, p3, p4);

          if (request.tax === 'no') {
              if (isNaN(parseFloat(request.sale))) {
                  param.error = 'Please fill All fields.';
                  return param;
              }

              ans = minPrice;
              const others = [p1, p2, p3, p4].filter(p => p !== minPrice).reduce((a, b) => a + b, 0);
              payt = minPrice - ans + others;
              
              const tax1 = (p1 / 100) * parseFloat(request.sale);
              const tax2 = (p2 / 100) * parseFloat(request.sale);
              const tax3 = (p3 / 100) * parseFloat(request.sale);
              const tax4 = (p4 / 100) * parseFloat(request.sale);
              
              const newP1 = p1 + tax1;
              const newP2 = p2 + tax2;
              const newP3 = p3 + tax3;
              const newP4 = p4 + tax4;
              
              const newMinPrice = Math.min(newP1, newP2, newP3, newP4);
              ans = newMinPrice;
              const newOthers = [newP1, newP2, newP3, newP4].filter(p => p !== newMinPrice).reduce((a, b) => a + b, 0);
              pay = newMinPrice - ans + newOthers;
              
              tax = tax1 + tax2 + tax3 + tax4;
              taxt = pay - payt;
              total = parseFloat(request.p1) + parseFloat(request.p2) + parseFloat(request.p3) + parseFloat(request.p4) + parseFloat(tax);
              per = parseFloat(((ans / total) * 100).toFixed(1));
              param.tax = tax;
              param.taxt = taxt;
          } else {
              ans = minPrice;
              const others = [p1, p2, p3, p4].filter(p => p !== minPrice).reduce((a, b) => a + b, 0);
              pay = minPrice - ans + others;
              payt = pay;
              total = p1 + p2 + p3 + p4;
              per = parseFloat(((ans / total) * 100).toFixed(1));
              
              if (per > 25) {
                  per = 25;
                  total = p1 + p2 + p3;
                  const save = parseFloat((total * 0.25).toFixed(2));
                  pay = parseFloat((total - save).toFixed(2));
                  payt = parseFloat((total - save).toFixed(2));
              }
          }

          const ave = parseFloat((pay / 4).toFixed(2));
          const stand = 4;

          param.amount = parseFloat(request.p1) + parseFloat(request.p2) + parseFloat(request.p3) + parseFloat(request.p4);
          param.Ans = ans;
          param.ave = ave;
          param.per = per;
          param.stand = stand;
          param.pay = pay;
          param.payt = payt;
          param.RESULT = 1;
          // console.log(param);
          return param;

      } else if (request.type === '8') {
          const amount = parseFloat(request.amount);
          const off = parseFloat(request.off);
          const off2 = parseFloat(request.off2);

          if (isNaN(amount) || isNaN(off) || isNaN(off2)) {
              param.error = 'Please fill All fields.';
              return param;
          }

          let ans, pay, payt, tax, taxt, effect;

          if (request.tax === 'no') {
              if (isNaN(parseFloat(request.sale))) {
                  param.error = 'Please fill All fields.';
                  return param;
              }

              const off1 = parseFloat(((amount / 100) * off).toFixed(2));
              const off_2 = parseFloat((((amount - off1) / 100) * off2).toFixed(2));
              ans = off1 + off_2;
              payt = amount - ans;
              tax = parseFloat(((parseFloat(request.sale) / 100) * amount).toFixed(2));
              const newAmount = amount + tax;
              const newOff1 = parseFloat(((newAmount / 100) * off).toFixed(2));
              const newOff2 = parseFloat((((newAmount - newOff1) / 100) * off2).toFixed(2));
              ans = newOff1 + newOff2;
              pay = newAmount - ans;
              taxt = pay - payt;
              effect = parseFloat(((ans / newAmount) * 100).toFixed(2));
              param.tax = tax;
              param.taxt = taxt;
          } else {
              const off1 = parseFloat(((amount / 100) * off).toFixed(2));
              const off_2 = parseFloat((((amount - off1) / 100) * off2).toFixed(2));
              ans = off1 + off_2;
              pay = amount - ans;
              payt = amount - ans;
              effect = parseFloat(((ans / parseFloat(request.amount)) * 100).toFixed(2));
          }

          param.amount = parseFloat(request.amount);
          param.Ans = ans;
          param.pay = pay;
          param.effect = effect;
          param.sum = `${parseFloat(request.off) + parseFloat(request.off2)}% (${parseFloat(request.off)}% + ${parseFloat(request.off2)}%)`;
          param.payt = payt;
          param.RESULT = 1;
          // console.log(param);
          return param;

      } else if (request.type === '9') {
          const amount = parseFloat(request.amount);
          const off = parseFloat(request.off);
          const off2 = parseFloat(request.off2);
          const off3 = parseFloat(request.off3);
          const sale = parseFloat(request.sale);
            // console.log(sale);
          if (isNaN(amount) || isNaN(off) || isNaN(off2) || isNaN(off3)) {
              param.error = 'Please fill All fields.';
              return param;
          }

          let ans, pay, payt, tax, taxt, effect;

          if (request.tax == 'no') {
              if (isNaN(parseFloat(request.sale))) {
                  param.error = 'Please fill All fields.';
                  return param;
              }

              const off1 = parseFloat(((amount / 100) * off).toFixed(2));
              const off_2 = parseFloat((((amount - off1) / 100) * off2).toFixed(2));
              const off_3 = parseFloat((((amount - off1 - off_2) / 100) * off3).toFixed(2));
              ans = off1 + off_2 + off_3;
              payt = amount - ans;
            
               tax = Math.round((sale / 100) * amount);
              // console.log(sale,amount,tax);
              const newAmount = amount + tax;
              const newOff1 = Math.round(((newAmount / 100) * off) * 100) / 100;
                const newOff2 = Math.round((((newAmount - newOff1) / 100) * off2) * 100) / 100;
                const newOff3 = Math.round((((newAmount - newOff1 - newOff2) / 100) * off3) * 100) / 100;

              ans = newOff1 + newOff2 + newOff3;
              pay = newAmount - ans;
              taxt = pay - payt;
              effect = parseFloat(((ans / newAmount) * 100).toFixed(2));
              param.tax = tax;  // no
              param.taxt = taxt;  // no
          } else {
              const off1 = parseFloat(((amount / 100) * off).toFixed(2));
              const off_2 = parseFloat((((amount - off1) / 100) * off2).toFixed(2));
              const off_3 = parseFloat((((amount - off1 - off_2) / 100) * off3).toFixed(2));
              ans = off1 + off_2 + off_3;
              pay = amount - ans;
              payt = amount - ans;
              effect = parseFloat(((ans / parseFloat(request.amount)) * 100).toFixed(2));
          }

          param.amount = parseFloat(request.amount);
          param.Ans = ans;  // no
          param.pay = pay;  ///no
          param.effect = effect;
          param.sum = `${parseFloat(request.off) + parseFloat(request.off2) + parseFloat(request.off3)}% (${parseFloat(request.off)}% + ${parseFloat(request.off2)}% + ${parseFloat(request.off3)}%)`;
          param.payt = payt;
          param.RESULT = 1;
          // console.log(param);
          return param;

      } else if (request.type === '10') {
          const nbr = parseFloat(request.nbr);
          const up = parseFloat(request.up);
          const fix = parseFloat(request.fix);

          if (isNaN(nbr) || isNaN(up) || isNaN(fix)) {
              param.error = 'Please fill All fields.';
              return param;
          }

          let amount, ans, pay, payt, tax, taxt;

          if (request.tax === 'no') {
              if (isNaN(parseFloat(request.sale))) {
                  param.error = 'Please fill All fields.';
                  return param;
              }

              amount = nbr * up;
              tax = parseFloat(((parseFloat(request.sale) / 100) * amount).toFixed(2));
              taxt = parseFloat(((parseFloat(request.sale) / 100) * fix).toFixed(2));
              payt = fix;
              pay = fix + taxt;
              const total = amount + tax;
              ans = total - pay;
              param.tax = tax;
              param.taxt = taxt;
          } else {
              pay = fix;
              payt = fix;
              amount = nbr * up;
              ans = amount - pay;
          }

          param.amount = amount;
          param.Ans = ans;
          param.pay = pay;
          param.payt = payt;
          param.RESULT = 1;
          // console.log(param);
          return param;
      }

    param.error = 'Invalid type';
    return param;
    }
  }


     /**
    * getCalculationGrossIncomeCalculator: Service Method
    * POST: /api/calculators-lol/gross-income-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationGrossIncomeCalculator(body) {
      const pay_frequency = body.tech_pay_frequency;
      const type = body.tech_type;
      const pay_method = body.tech_pay_method;
      const amount = parseFloat(body.tech_amount);
      const filer_status = body.tech_filer_status;

      const param = {};

      if (
        pay_frequency &&
        type &&
        filer_status &&
        pay_method &&
        !isNaN(amount)
      ) {
        let total_amount;

        // ====== STEP 1: Calculate total yearly amount ======
        if (type === "Bonus") {
          total_amount = amount;
        } else {
          if (pay_method === "Per-Year") {
            total_amount = amount;
          } else {
            if (pay_frequency === "Daily") {
              total_amount = amount * (365 - 104);
            } else if (pay_frequency === "Weekly") {
              total_amount = amount * 52;
            } else if (pay_frequency === "Bi-Weekly") {
              total_amount = amount * 26;
            } else if (pay_frequency === "Semi-Monthly") {
              total_amount = amount * 24;
            } else if (pay_frequency === "Monthly") {
              total_amount = amount * 12;
            } else if (pay_frequency === "Quarterly") {
              total_amount = amount * 4;
            } else {
              total_amount = amount;
            }
          }
        }

        // ====== STEP 2: Per-frequency amount ======
        let per_frequency;
        if (pay_frequency === "Daily") {
          per_frequency = Math.round((total_amount / (365 - 104)) * 100) / 100;
        } else if (pay_frequency === "Weekly") {
          per_frequency = Math.round((total_amount / 52) * 100) / 100;
        } else if (pay_frequency === "Bi-Weekly") {
          per_frequency = Math.round((total_amount / 26) * 100) / 100;
        } else if (pay_frequency === "Semi-Monthly") {
          per_frequency = Math.round((total_amount / 24) * 100) / 100;
        } else if (pay_frequency === "Monthly") {
          per_frequency = Math.round((total_amount / 12) * 100) / 100;
        } else if (pay_frequency === "Quarterly") {
          per_frequency = Math.round((total_amount / 4) * 100) / 100;
        } else {
          per_frequency = total_amount;
        }

        // ====== STEP 3: Security & Medicare deductions ======
        const secrity_per = 6.2;
        const medicare_per = 1.45;
        const secrity_amount_frequency = per_frequency * 0.062;
        const secrity_amount_yearly = total_amount * 0.062;
        const medicare_amount_frequency = per_frequency * 0.0145;
        const medicare_amount_yearly = total_amount * 0.0145;

        // ====== STEP 4: Tax brackets ======
        let tax_per = 0;
        let tax_amount_frequency = 0;
        let net_frequency_amount = 0;
        let tax_amount_yearly = 0;
        let yearly_net_income = 0;

        function setTax(percent) {
          tax_per = percent;
          tax_amount_frequency = per_frequency * (percent / 100);
          net_frequency_amount = Math.round(
            (per_frequency -
              tax_amount_frequency -
              secrity_amount_frequency -
              medicare_amount_frequency) * 100
          ) / 100;
          tax_amount_yearly = total_amount * (percent / 100);
          yearly_net_income = Math.round(
            (total_amount -
              tax_amount_yearly -
              secrity_amount_yearly -
              medicare_amount_yearly) * 100
          ) / 100;
        }

        // ====== STEP 5: Apply tax based on filer status ======
        if (filer_status === "single") {
          if (total_amount <= 10275) setTax(10);
          else if (total_amount <= 41775) setTax(12);
          else if (total_amount <= 89075) setTax(22);
          else if (total_amount <= 170050) setTax(24);
          else if (total_amount <= 215950) setTax(32);
          else if (total_amount <= 539900) setTax(35);
          else setTax(37);
        } else if (filer_status === "married-jointly") {
          if (total_amount <= 20550) setTax(10);
          else if (total_amount <= 83550) setTax(12);
          else if (total_amount <= 178150) setTax(22);
          else if (total_amount <= 340100) setTax(24);
          else if (total_amount <= 431900) setTax(32);
          else if (total_amount <= 647850) setTax(35);
          else setTax(37);
        } else if (filer_status === "married-separately") {
          if (total_amount <= 10275) setTax(10);
          else if (total_amount <= 41775) setTax(12);
          else if (total_amount <= 89075) setTax(22);
          else if (total_amount <= 170050) setTax(24);
          else if (total_amount <= 215950) setTax(32);
          else if (total_amount <= 323925) setTax(35);
          else setTax(37);
        } else if (filer_status === "head") {
          if (total_amount <= 14650) setTax(10);
          else if (total_amount <= 55900) setTax(12);
          else if (total_amount <= 89050) setTax(22);
          else if (total_amount <= 170050) setTax(24);
          else if (total_amount <= 215950) setTax(32);
          else if (total_amount <= 539900) setTax(35);
          else setTax(37);
        }

        // ====== STEP 6: Percent summaries ======
        const net_income_per = (yearly_net_income * 100) / total_amount;
        const net_tax_per =
          ((secrity_amount_yearly + medicare_amount_yearly + tax_amount_yearly) *
            100) /
          total_amount;

        // ====== STEP 7: Prepare result ======
        param.tech_total_amount = Math.round(total_amount).toLocaleString('en-US');
        param.tech_yearly_net_income = Math.round(yearly_net_income).toLocaleString('en-US');
        param.tech_secrity_amount_yearly = Math.round(secrity_amount_yearly).toLocaleString('en-US');
        param.tech_medicare_amount_yearly = Math.round(medicare_amount_yearly).toLocaleString('en-US');
        param.tech_tax_amount_yearly = Math.round(tax_amount_yearly).toLocaleString('en-US');
        param.tech_secrity_per = secrity_per;
        param.tech_medicare_per = medicare_per;
        param.tech_tax_per = tax_per;
        param.tech_per_frequency = Math.round(per_frequency).toLocaleString('en-US');
        param.tech_net_frequency_amount = Math.round(net_frequency_amount).toLocaleString('en-US');
        param.tech_tax_amount_frequency = Math.round(tax_amount_frequency).toLocaleString('en-US');
        param.tech_secrity_amount_frequency = Math.round(secrity_amount_frequency).toLocaleString('en-US');
        param.tech_medicare_amount_frequency = Math.round(medicare_amount_frequency).toLocaleString('en-US');
        param.tech_net_income_per = net_income_per;
        param.tech_net_tax_per = net_tax_per;
        param.tech_pay_frequency = pay_frequency;
        param.tech_filer_status = filer_status;
        param.tech_type = type;
        return param;
      } else {
        return { error: "Please fill all fields." };
      }
    }


     /**
    * getCalculationMonthlyIncomeCalculator: Service Method
    * POST: /api/calculators-lol/monthly-income-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationMonthlyIncomeCalculator(body) {
        const param = {};
        const pay = body.tech_pay;
        const first = parseFloat(body.tech_first);
        const second = parseFloat(body.tech_second);

        let hourly_income, daily_income, weekly_income, bi_weekly_income,
            sami_monthly_income, monthly_income, quarterly_income, annual_income;

        if (pay == "1") {
          if (!isNaN(first) && !isNaN(second)) {
            annual_income = first * second * 52;
            monthly_income = Math.round(annual_income / 12);
            sami_monthly_income = Math.round((monthly_income / 2) * 100) / 100;
            daily_income = first * 8;
            weekly_income = first * second;
            bi_weekly_income = Math.round(weekly_income * 2);
            hourly_income = first;
            quarterly_income = Math.round((annual_income / 4) * 100) / 100;
          } else {
            param.error = "Please! Check Your Input.";
            return param;
          }
        } else if (pay == "2") {
          if (!isNaN(first) && !isNaN(second)) {
            daily_income = first;
            weekly_income = first * second;
            hourly_income = Math.round((first / 8) * 100) / 100;
            annual_income = hourly_income * 40 * 52;
            monthly_income = Math.round(annual_income / 12);
            sami_monthly_income = Math.round((monthly_income / 2) * 100) / 100;
            bi_weekly_income = Math.round(weekly_income * 2);
            quarterly_income = Math.round((annual_income / 4) * 100) / 100;
          } else {
            param.error = "Please! Check Your Input.";
            return param;
          }
        } else if (pay == "3") {
          if (!isNaN(first)) {
            daily_income = Math.round((first / 5) * 100) / 100;
            weekly_income = first;
            hourly_income = Math.round((first / 40) * 100) / 100;
            annual_income = hourly_income * 40 * 52;
            monthly_income = Math.round((annual_income / 12) * 100) / 100;
            sami_monthly_income = Math.round((monthly_income / 2) * 100) / 100;
            bi_weekly_income = Math.round(weekly_income * 2);
            quarterly_income = Math.round((annual_income / 4) * 100) / 100;
          } else {
            param.error = "Please! Check Your Input.";
            return param;
          }
        } else if (pay == "4") {
          if (!isNaN(first)) {
            weekly_income = Math.round((first / 2) * 100) / 100;
            daily_income = Math.round((weekly_income / 5) * 100) / 100;
            hourly_income = Math.round((daily_income / 8) * 100) / 100;
            annual_income = hourly_income * 40 * 52;
            monthly_income = Math.round((annual_income / 12) * 100) / 100;
            sami_monthly_income = Math.round((monthly_income / 2) * 100) / 100;
            bi_weekly_income = first;
            quarterly_income = Math.round((annual_income / 4) * 100) / 100;
          } else {
            param.error = "Please! Check Your Input.";
            return param;
          }
        } else if (pay == "5") {
          if (!isNaN(first)) {
            sami_monthly_income = first;
            monthly_income = Math.round(sami_monthly_income * 2);
            annual_income = monthly_income * 12;
            weekly_income = Math.round((annual_income / 52) * 100) / 100;
            daily_income = Math.round((weekly_income / 5) * 100) / 100;
            hourly_income = Math.round((daily_income / 8) * 100) / 100;
            bi_weekly_income = weekly_income * 2;
            quarterly_income = Math.round((annual_income / 4) * 100) / 100;
          } else {
            param.error = "Please! Check Your Input.";
            return param;
          }
        } else if (pay == "6") {
          if (!isNaN(first)) {
            quarterly_income = first;
            annual_income = first * 4;
            weekly_income = Math.round((annual_income / 52) * 100) / 100;
            monthly_income = Math.round((annual_income / 12) * 100) / 100;
            sami_monthly_income = Math.round((monthly_income / 2) * 100) / 100;
            daily_income = Math.round((weekly_income / 5) * 100) / 100;
            hourly_income = Math.round((daily_income / 8) * 100) / 100;
            bi_weekly_income = weekly_income * 2;
          } else {
            param.error = "Please! Check Your Input.";
            return param;
          }
        } else {
          if (!isNaN(first)) {
            weekly_income = Math.round((first / 52) * 100) / 100;
            daily_income = Math.round((weekly_income / 5) * 100) / 100;
            hourly_income = Math.round((daily_income / 8) * 100) / 100;
            annual_income = first;
            monthly_income = Math.round((annual_income / 12) * 100) / 100;
            bi_weekly_income = weekly_income * 2;
            sami_monthly_income = Math.round((monthly_income / 2) * 100) / 100;
            quarterly_income = Math.round((annual_income / 4) * 100) / 100;
          } else {
            param.error = "Please! Check Your Input.";
            return param;
          }
        }

        param.tech_hourly_income = hourly_income;
        param.tech_daily_income = daily_income;
        param.tech_weekly_income = weekly_income;
        param.tech_bi_weekly_income = bi_weekly_income;
        param.tech_sami_monthly_income = sami_monthly_income;
        param.tech_monthly_income = monthly_income;
        param.tech_quarterly_income = quarterly_income;
        param.tech_annual_income = annual_income;

        return param;
      }


     /**
    * getCalculationMoneyCounterCalculator: Service Method
    * POST: /api/calculators-lol/money-counter-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */
    

      async  getCalculationMoneyCounterCalculator(body) {
    const param = {};
        
        // Extract parameters from body
        const currency = body.tech_currency;
        const checkbox1 = body.tech_checkbox1 || false;
        const checkbox2 = body.tech_checkbox2 || false;
        const checkbox3 = body.tech_checkbox3 || false;
        const bank_notes = body.tech_bank_notes || false;
        const coins = body.tech_coins || false;
        const rolls = body.tech_rolls || false;

        // Initialize arrays
        let note_total = [];
        let note_quantity = [];
        let note_input = [];
        let coins_total = [];
        let coins_quantity = [];
        let coins_input = [];
        let rolls_total = [];
        let rolls_quantity = [];
        let rolls_input = [];
        let rolls_count_ans = [];

        // Define currency configurations
        let note_values, coins_values, rolls_values, rolls_count, ans_currency;

        switch (currency) {
            case "USD":
                note_values = ["1", "2", "5", "10", "20", "50", "100"];
                coins_values = ["0.01", "0.05", "0.10", "0.25", "0.50", "1.00"];
                rolls_values = ["0.01", "0.05", "0.10", "0.25", "0.50", "1.00"];
                rolls_count = ["50", "40", "50", "40", "20", "25"];
                ans_currency = "$";
                break;
            case "EUR":
                note_values = ["5", "10", "20", "50", "100", "200", "500"];
                coins_values = ["0.01", "0.02", "0.05", "0.10", "0.20", "0.50", "1.00", "2.00"];
                rolls_values = ["0.01", "0.02", "0.05", "0.10", "0.20", "0.50", "1.00", "2.00"];
                rolls_count = ["50", "50", "50", "40", "40", "40", "25", "25"];
                ans_currency = "€";
                break;
            case "JPY":
                note_values = ["1000", "2000", "5000", "10000"];
                coins_values = ["1.00", "5.00", "10.00", "50.00", "100.00", "500.00"];
                rolls_values = ["1.00", "5.00", "10.00", "50.00", "100.00", "500.00"];
                rolls_count = ["50", "50", "50", "50", "50", "50"];
                ans_currency = "¥";
                break;
            case "GBP":
                note_values = ["5", "10", "20", "50"];
                coins_values = ["0.01", "0.02", "0.05", "0.10", "0.20", "0.50", "1.00", "2.00"];
                rolls_values = ["0.01", "0.02", "0.05", "0.10", "0.20", "0.50", "1.00", "2.00"];
                rolls_count = ["100", "50", "100", "50", "50", "20", "20", "10"];
                ans_currency = "£";
                break;
            case "AUD":
                note_values = ["5", "10", "20", "50", "100"];
                coins_values = ["0.05", "0.10", "0.20", "0.50", "2.00"];
                rolls_values = ["0.05", "0.10", "0.20", "0.50", "1.00", "2.00"];
                rolls_count = ["40", "40", "20", "20", "20", "25"];
                ans_currency = "$";
                break;
            case "CAD":
                note_values = ["1", "5", "10", "20", "50", "100"];
                coins_values = ["0.01", "0.05", "0.10", "0.25", "0.50", "1.00", "2.00"];
                rolls_values = ["0.01", "0.05", "0.10", "0.25", "0.50", "1.00", "2.00"];
                rolls_count = ["50", "40", "50", "40", "25", "25", "25"];
                ans_currency = "$";
                break;
            case "CHF":
                note_values = ["10", "20", "50", "100", "200", "1000"];
                coins_values = ["0.05", "0.10", "0.20", "0.50", "1.00", "2.00", "5.00"];
                rolls_values = ["0.05", "0.10", "0.20", "0.50", "1.00", "2.00", "5.00"];
                rolls_count = ["50", "50", "50", "50", "50", "50", "50"];
                ans_currency = "fr";
                break;
            case "SEK":
                note_values = ["20", "50", "100", "200", "500", "1000"];
                coins_values = ["1.00", "2.00", "5.00", "10.00"];
                rolls_values = ["1.00", "2.00", "5.00", "10.00"];
                rolls_count = ["50", "50", "40", "25"];
                ans_currency = "kr";
                break;
            case "MXN":
                note_values = ["20", "50", "100", "200", "500", "1000"];
                coins_values = ["0.05", "0.10", "0.20", "0.50", "1.00", "2.00", "5.00", "10.00", "20.00"];
                ans_currency = "$";
                break;
            case "NZD":
                note_values = ["10", "20", "50", "100"];
                coins_values = ["0.10", "0.20", "0.50", "1.00", "2.00"];
                rolls_values = ["0.10", "0.20", "0.50", "1.00", "2.00"];
                rolls_count = ["50", "25", "20", "25", "25"];
                ans_currency = "$";
                break;
            case "INR":
                note_values = ["2", "5", "10", "20", "50", "100", "200", "500", "2000"];
                coins_values = ["0.50", "1.00", "2.00", "5.00", "10.00", "20.00"];
                rolls_values = ["0.50", "1.00", "2.00", "5.00", "10.00", "20.00"];
                rolls_count = ["100", "100", "100", "100", "100", "100"];
                ans_currency = "₹";
                break;
            default:
                note_values = ["20", "50", "100", "200", "500", "1000"];
                coins_values = ["0.01", "0.05", "0.10", "0.25", "1.00", "5.00", "10.00", "20.00"];
                ans_currency = "₱";
        }

        // Process bank notes - ONLY if checkbox1 is true
        if (checkbox1 != false && checkbox1 != 'false') {
            const noteOneNotEmpty = bank_notes && bank_notes.some(element => element !== '' && element != null);
            if (!noteOneNotEmpty) {
                param.error = 'Please fill all fields.';
                return param;
            }

            // Calculate bank notes totals
            note_values.forEach((value, key) => {
                if (bank_notes && bank_notes[key] && !isNaN(bank_notes[key])) {
                    note_total.push(parseFloat(value) * parseFloat(bank_notes[key]));
                    note_quantity.push(value);
                    note_input.push(bank_notes[key]);
                }
            });
        } else {
            // If checkbox1 is false, skip bank notes calculations
            note_total = [];
            note_quantity = [];
            note_input = [];
        }

        // Process coins - ONLY if checkbox2 is true
        if (checkbox2 != false && checkbox2 != 'false') {
            const coinsOneNotEmpty = coins && coins.some(element => element !== '' && element != null);
            if (!coinsOneNotEmpty) {
                param.error = 'Please fill all fields.';
                return param;
            }

            // Calculate coins totals
            coins_values.forEach((value, key) => {
                if (coins && coins[key] && !isNaN(coins[key])) {
                    coins_total.push(parseFloat(value) * parseFloat(coins[key]));
                    coins_quantity.push(value);
                    coins_input.push(coins[key]);
                }
            });
        } else {
            // If checkbox2 is false, skip coins calculations
            coins_total = [];
            coins_quantity = [];
            coins_input = [];
        }

        // Process rolls for supported currencies ONLY if checkbox3 is true
        const supportedCurrencies = ["USD", "EUR", "JPY", "GBP", "AUD", "CAD", "CHF", "SEK", "NZD", "INR"];
        
        if (supportedCurrencies.includes(currency) && (checkbox3 !== false && checkbox3 !== 'false')) {
            const rollsOneNotEmpty = rolls && rolls.some(element => element !== '' && element != null);
            if (!rollsOneNotEmpty) {
                param.error = 'Please fill all fields.';
                return param;
            }

            if (rolls_values) {
                rolls_values.forEach((value, key) => {
                    if (rolls && rolls[key] && !isNaN(rolls[key])) {
                        rolls_total.push(parseFloat(value) * parseFloat(rolls[key]) * parseFloat(rolls_count[key]));
                        rolls_quantity.push(value);
                        rolls_input.push(rolls[key]);
                        rolls_count_ans.push(rolls_count[key]);
                    }
                });
            }

            param.tech_rolls_total = rolls_total;
            param.tech_rolls_quantity = rolls_quantity;
            param.tech_rolls_input = rolls_input;
            if (rolls_count_ans.length > 0) {
                param.rolls_count_ans = rolls_count_ans;
            }
        } else {
            // If checkbox3 is false or currency not supported, set empty arrays
            param.tech_rolls_total = [];
            param.tech_rolls_quantity = [];
            param.tech_rolls_input = [];
        }

        // Calculate total money
        const total_money = coins_total.reduce((a, b) => a + b, 0) + 
                          note_total.reduce((a, b) => a + b, 0) + 
                          rolls_total.reduce((a, b) => a + b, 0);

        // Set response parameterstech_
        param.tech_total_money = Math.round(total_money * 100) / 100;
        param.tech_note_total = note_total;
        param.tech_note_quantity = note_quantity;
        param.tech_note_input = note_input;
        param.tech_coins_total = coins_total;
        param.tech_coins_quantity = coins_quantity;
        param.tech_coins_input = coins_input;
        param.tech_ans_currency = ans_currency;
        
        // Convert checkbox values to match Laravel format
        param.tech_checkbox1 = checkbox1 == true || checkbox1 == 'true' || checkbox1 == '1' ? '1' : false;
        param.tech_checkbox2 = checkbox2 == true || checkbox2 == 'true' || checkbox2 == '1' ? '1' : false;
        param.tech_checkbox3 = checkbox3 == true || checkbox3 == 'true' || checkbox3 == '1' ? '1' : false;
        
        param.tech_currency = currency;

        return param;
    }

      /**
    * getCalculationdisCountedCashFlowCalculator: Service Method
    * POST: /api/calculators-lol/discounted-cash-flow-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */
    

     async  getCalculationdisCountedCashFlowCalculator(body) {
        const param = {};
        
        // Extract parameters from body
        const main_unit = body.tech_main_unit?.trim();
        const input = body.tech_input || [];
        const cash = parseFloat(body.tech_cash?.trim()) || 0;
        const outstanding = parseFloat(body.tech_outstanding?.trim()) || 0;
        const perpetual = parseFloat(body.tech_perpetual?.trim()) || 0;
        const wacc = parseFloat(body.tech_wacc?.trim()) || 0;
        const shares = parseFloat(body.tech_shares?.trim()) || 0;
        const price = parseFloat(body.tech_price?.trim()) || 0;
        const earnings = parseFloat(body.tech_earnings?.trim()) || 0;
        const discount = parseFloat(body.tech_discount?.trim()) || 0;
        const growth = parseFloat(body.tech_growth?.trim()) || 0;
        const growth_time = parseFloat(body.tech_growth_time?.trim()) || 0;
        const growth_time_one = parseFloat(body.tech_growth_time_one?.trim()) || 0;
        const growth_time_sec = parseFloat(body.tech_growth_time_sec?.trim()) || 0;
        const growth_unit = body.tech_growth_unit?.trim();
        const terminal = parseFloat(body.tech_terminal?.trim()) || 0;
        const terminal_time = parseFloat(body.tech_terminal_time?.trim()) || 0;
        const terminal_one = parseFloat(body.tech_terminal_one?.trim()) || 0;
        const terminal_sec = parseFloat(body.tech_terminal_sec?.trim()) || 0;
        const terminal_unit = body.tech_terminal_unit?.trim();

        if (main_unit == "Earnings per share (EPS)") {
            // Validation for EPS calculations
            if ((!growth_time_one && !growth_time_sec) || (!terminal_one && !terminal_sec)) {
                param.error = 'Please! Enter Input.';
                return param;
            }

            let growth_time_final = growth_time_one || 0;
            let terminal_time_final = terminal_one || 0;

            // Handle growth time conversion
            if (growth_unit == "yrs/mos") {
                growth_time_final = (growth_time_one || 0) + ((growth_time_sec || 0) / 12);
            } else if (growth_unit == "mos") {
                growth_time_final = (growth_time || 0) / 12;
            } else {
                growth_time_final = growth_time || 0;
            }

            // Handle terminal time conversion
            if (terminal_unit == "yrs/mos") {
                terminal_time_final = (terminal_one || 0) + ((terminal_sec || 0) / 12);
            } else if (terminal_unit == "mos") {
                terminal_time_final = (terminal_time || 0) / 12;
            } else {
                terminal_time_final = terminal_time || 0;
            }

            // Validate numeric inputs
            if (!isNaN(earnings) && !isNaN(discount) && !isNaN(growth) && !isNaN(growth_time_final) && 
                !isNaN(terminal) && !isNaN(terminal_time_final)) {
                
                if (discount == 0) {
                    param.error = 'discount rate Value is greater than or not equal to.';
                    return param;
                }

                // Calculate coefficient
                const coefficient = (1 + (growth / 100)) / (1 + (discount / 100));

                // Growth value calculation
                const groeth_answer = earnings * coefficient * (1 - Math.pow(coefficient, growth_time_final)) / (1 - coefficient);

                // Terminal value calculation
                const coefficient_b = (1 + (terminal / 100)) / (1 + (discount / 100));
                const terminal_answer = (earnings * Math.pow(coefficient, growth_time_final) * coefficient_b * 
                    (1 - Math.pow(coefficient_b, terminal_time_final))) / (1 - coefficient_b);

                // Total intrinsic value
                const Total_intrinsic_answer = groeth_answer + terminal_answer;

                // Set response parameters
                param.tech_groeth_answer = groeth_answer;
                param.tech_terminal_answer = terminal_answer;
                param.tech_Total_intrinsic_answer = Total_intrinsic_answer;
                param.tech_main_unit = main_unit;
                param.tech_growth_unit = growth_unit;
                param.tech_terminal_unit = terminal_unit;
                param.tech_input = input;
                param.tech_length = input.length + 1;

                return param;
            } else {
                param.error = 'Please! Check Your Input.';
                return param;
            }
        } else {
            // FCFF (Free Cash Flow to Firm) calculations
            if (!isNaN(cash) && !isNaN(outstanding) && !isNaN(perpetual) && !isNaN(wacc) && 
                !isNaN(shares) && !isNaN(price) && !isNaN(growth_time_one) && !isNaN(growth_time_sec) && 
                !isNaN(terminal_one) && !isNaN(terminal_sec) && terminal_unit && growth_unit) {
                
                // Process input array
                const nawi_array = [];
                for (let i = 0; i < input.length; i++) {
                    if (!isNaN(parseFloat(input[i]))) {
                        nawi_array[i + 1] = parseFloat(input[i]);
                    }
                }

                if (nawi_array.length < 1) {
                    param.error = 'Please! Check Your Input.';
                    return param;
                }

                const fcff_last = nawi_array[nawi_array.length - 1];

                // Validate WACC
                if (wacc == 0) {
                    param.error = 'wacc value is greater than or not equal to.';
                    return param;
                }

                // Calculate terminal value
                const terminal_value = fcff_last * (1 + (perpetual / 100)) / ((wacc / 100) - (perpetual / 100));

                // Calculate firm value function
                const calculateFirmValue = (fcffArray, wacc) => {
                    let firmValue = 0;
                    for (const [t, fcff] of Object.entries(fcffArray)) {
                        const discountFactor = Math.pow(1 + (wacc / 100), parseInt(t));
                        firmValue += fcff / discountFactor;
                    }
                    return firmValue;
                };

                const result = calculateFirmValue(nawi_array, wacc);
                const nz = Object.keys(nawi_array).length;
                const value_firm = Math.pow((1 + (wacc / 100)), nz);
                const ans_sec = terminal_value / value_firm;
                
                // Final calculations
                const answer_sec = result + ans_sec;
                const net_debt = outstanding - cash;
                const equdiry = answer_sec - net_debt;

                // Validate shares
                if (shares == 0) {
                    param.error = 'Outstanding Shares value is greater than or not equal to.';
                    return param;
                }

                const fair_val = equdiry / shares;

                if (fair_val == 0) {
                    param.error = 'fair value is greater than or not equal to.';
                    return param;
                }

                const percentage = ((price - fair_val) * 100) / fair_val;

                // Set response parameters
                param.tech_terminal_value = terminal_value;
                param.tech_answer_sec = answer_sec;
                param.tech_equdiry = equdiry;
                param.tech_fair_val = fair_val;
                param.tech_percentage = percentage;
                param.tech_main_unit = main_unit;
                param.tech_input = input;
                param.tech_growth_unit = growth_unit;
                param.tech_terminal_unit = terminal_unit;
                param.tech_length = input.length + 1;

                return param;
            } else {
                param.error = 'Please! Check Your Input.';
                return param;
            }
        }
    }


      /**
    * getCalculationVaDisdisabilityCalculator: Service Method
    * POST: /api/calculators-lol/va-disability-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */
    
      async  getCalculationVaDisdisabilityCalculator(body) {
        const param = {};
        
        // Extract parameters from body
        const right_arm = parseFloat(body.tech_right_arm?.trim()) || 0;
        const left_arm = parseFloat(body.tech_left_arm?.trim()) || 0;
        const right_leg = parseFloat(body.tech_right_leg?.trim()) || 0;
        const left_leg = parseFloat(body.tech_left_leg?.trim()) || 0;
        const right_foot = parseFloat(body.tech_right_foot?.trim()) || 0;
        const left_foot = parseFloat(body.tech_left_foot?.trim()) || 0;
        const back = parseFloat(body.tech_back?.trim()) || 0;
        const ssd = parseFloat(body.tech_ssd?.trim()) || 0;
        const ptsd = parseFloat(body.tech_ptsd?.trim()) || 0;
        const tinnitus = parseFloat(body.tech_tinnitus?.trim()) || 0;
        const migraines = parseFloat(body.tech_migraines?.trim()) || 0;
        const sleep_apnea = parseFloat(body.tech_sleep_apnea?.trim()) || 0;
        const bilateral_upper = parseFloat(body.tech_bilateral_upper?.trim()) || 0;
        const bilateral_lower = parseFloat(body.tech_bilateral_lower?.trim()) || 0;
        const others = parseFloat(body.tech_others?.trim()) || 0;
        const status = body.tech_status?.trim();
        const attendance = body.tech_attendance?.trim();
        const under_age = body.tech_under_age?.trim();
        const over_age = body.tech_over_age?.trim();
        const parent = body.tech_parent?.trim();

        // Create disabilities array and filter out zeros
        const disabilities = [
            right_arm, left_arm, right_leg, left_leg, right_foot, left_foot, 
            back, ssd, ptsd, tinnitus, migraines, sleep_apnea, 
            bilateral_upper, bilateral_lower, others
        ];

        const filteredDisabilities = disabilities.filter(value => value !== 0);
        const newDisabilitiesArray = filteredDisabilities;
        const arraytotal = newDisabilitiesArray.length;

        // Sort in descending order
        newDisabilitiesArray.sort((a, b) => b - a);

        let total_cumulative = 0;

        // Calculate cumulative disability
        if (arraytotal == 0) {
            param.error = 'Please! select disability';
            return param;
        } else if (arraytotal === 1) {
            total_cumulative = newDisabilitiesArray[0];
        } else if (arraytotal === 2) {
            const val_first = newDisabilitiesArray[0];
            const val_sec = newDisabilitiesArray[1];

            const a = ((100 - val_first) * val_sec) / 100;
            const cdis = Math.round(val_first + a);
            total_cumulative = cdis;
        } else {
            const answers = [];
            let cdis = 0;

            for (let i = 0; i < (arraytotal - 1); i++) {
                if (i == 0) {
                    const a = ((100 - newDisabilitiesArray[i]) * newDisabilitiesArray[i + 1]) / 100;
                    cdis = Math.round(newDisabilitiesArray[i] + a);
                }
                if (i != 0) {
                    const jawab = ((100 - cdis) * newDisabilitiesArray[i + 1]) / 100;
                    cdis = cdis + jawab;
                    answers.push(Math.round(cdis));
                }
            }
            total_cumulative = answers.length > 0 ? answers[answers.length - 1] : cdis;
        }

        // Determine total combined rating and index
        let total_combined = 0;
        let total_combined_index = 0;

        if (total_cumulative < 15) {
            total_combined = 10;
            total_combined_index = 0;
        } else if (total_cumulative < 25) {
            total_combined = 20;
            total_combined_index = 1;
        } else if (total_cumulative < 35) {
            total_combined = 30;
            total_combined_index = 2;
        } else if (total_cumulative < 45) {
            total_combined = 40;
            total_combined_index = 3;
        } else if (total_cumulative < 55) {
            total_combined = 50;
            total_combined_index = 4;
        } else if (total_cumulative < 65) {
            total_combined = 60;
            total_combined_index = 5;
        } else if (total_cumulative < 75) {
            total_combined = 70;
            total_combined_index = 6;
        } else if (total_cumulative < 85) {
            total_combined = 80;
            total_combined_index = 7;
        } else if (total_cumulative < 95) {
            total_combined = 90;
            total_combined_index = 8;
        } else {
            total_combined = 100;
            total_combined_index = 9;
        }

        // VA compensation model
        const model = {
            'alone': [171.23, 338.49, 524.31, 755.28, 1075.16, 1361.88, 1716.28, 1995.01, 2241.91, 3737.85],
            'VeteranChild': [171.23, 338.49, 565.31, 810.28, 1144.16, 1444.88, 1813.29, 2106.01, 2366.91, 3877.22],
            'veteranparent': [171.23, 338.49, 574.31, 821.28, 1158.16, 1461.88, 1833.28, 2128.01, 2391.91, 3905.11],
            'VeteranSpouse': [171.23, 338.49, 586.31, 838.28, 1179.16, 1486.88, 1861.28, 2161.01, 2428.91, 3946.25],
            'VeteranParentChild': [171.23, 338.49, 615.31, 876.28, 1227.16, 1544.88, 1930.28, 2239.01, 2516.91, 4044.48],
            'VeterantwoParents': [171.23, 338.49, 624.31, 887.28, 1241.16, 1561.88, 1950.28, 2261.01, 2541.91, 4072.37],
            'VeteranSpouseChild': [171.23, 338.49, 632.31, 899.28, 1255.16, 1577.88, 1968.28, 2283.01, 2565.91, 4098.87],
            'VeteranspouseoneParent': [171.23, 338.49, 636.31, 904.28, 1262.16, 1586.88, 1978.28, 2294.01, 2578.91, 4113.51],
            'VeterantwoParentsChild': [171.23, 338.49, 665.31, 942.28, 1310.16, 1644.88, 2047.28, 2372.01, 2666.91, 4211.74],
            'VeteranspouseoneParentoneChild': [171.23, 338.49, 682.31, 965.28, 1338.16, 1677.88, 2085.28, 2416.01, 2715.91, 4266.13],
            'VeteranSpousetwoParents': [171.23, 338.49, 688.31, 970.28, 1345.16, 1686.88, 2095.28, 2427.01, 2727.91, 4280.77],
            'VeteranSpousetwoParentsoneChild': [171.23, 338.49, 732.31, 1031.28, 1421.16, 1777.88, 2202.28, 2549.01, 2865.91, 4433.39],
            'additionalchildrenunderage': [0.00, 0.00, 31.00, 41.00, 51.00, 62.00, 72.00, 82.00, 93.00, 103.55],
            'overagechildren': [0.00, 0.00, 100.00, 133.00, 167.00, 200.00, 234.00, 267.00, 301.00, 334.49],
            'aidandattendance': [0.00, 0.00, 57.00, 76.00, 95.00, 114.00, 134.00, 153.00, 172.00, 191.14],
        };

        let rate = 0;

        // Determine base rate based on status and dependencies
        if (status == "Single") {
            rate = model['alone'][total_combined_index];
        }
        
        if (status == "Single" && (under_age == '1' || over_age == '1')) {
            rate = model['VeteranChild'][total_combined_index];
        }
        
        if (status == "Single" && parent == '1') {
            rate = model['veteranparent'][total_combined_index];
        }
        
        if (status == "Single" && parent == '2') {
            rate = model['VeterantwoParents'][total_combined_index];
        }
        
        if (status == "Single" && parent == '1' && (under_age == '1' || over_age == '1')) {
            rate = model['VeteranParentChild'][total_combined_index];
        }
        
        if (status == "Single" && parent == '2' && (under_age == '1' || over_age == '1')) {
            rate = model['VeterantwoParentsChild'][total_combined_index];
        }
        
        if (status == "Married") {
            rate = model['VeteranSpouse'][total_combined_index];
        }
        
        if (status == "Married" && (under_age == '1' || over_age == '1')) {
            rate = model['VeteranSpouseChild'][total_combined_index];
        }
        
        if (status == "Married" && parent == '1') {
            rate = model['VeteranspouseoneParent'][total_combined_index];
        }
        
        if (status == "Married" && parent == '1' && (under_age == '1' || over_age == '1')) {
            rate = model['VeteranspouseoneParentoneChild'][total_combined_index];
        }
        
        if (status == "Married" && parent == '2') {
            rate = model['VeteranSpousetwoParents'][total_combined_index];
        }
        
        if (status == "Married" && parent == '2' && (under_age == '1' || over_age == '1')) {
            rate = model['VeteranSpousetwoParentsoneChild'][total_combined_index];
        }

        // Add aid and attendance if applicable
        if (attendance == 'Yes') {
            rate += model['aidandattendance'][total_combined_index];
        }

        // Add additional children under age
        if (under_age != '1' && under_age) {
            const underAgeCount = parseInt(under_age) || 0;
            rate += (underAgeCount * model['additionalchildrenunderage'][total_combined_index]);
        }

        // Add additional children over age
        if (over_age != '1' && over_age) {
            const overAgeCount = parseInt(over_age) || 0;
            rate += (overAgeCount * model['overagechildren'][total_combined_index]);
        }

        // Set response parameters
        param.tech_total_cumulative = total_cumulative;
        param.tech_total_combined = total_combined;
        param.tech_rate = rate;
        param.tech_status = status;

        return param;
    }

    
      /**
    * getCalculationCagrCalculator: Service Method
    * POST: /api/calculators-lol/cagr-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

     async  getCalculationCagrCalculator(body) {
        const param = {};
    
          // Extract parameters from body
          const units = body.tech_unit_type?.trim();
          const starting_first = parseFloat(body.tech_starting_first?.trim()) || 0;
          const ending_first = parseFloat(body.tech_ending_first?.trim()) || 0;
          const years_first = parseFloat(body.tech_years_first?.trim()) || 0;
          const months_first = parseFloat(body.tech_months_first?.trim()) || 0;
          const days_first = parseFloat(body.tech_days_first?.trim()) || 0;
          const starting_sec = parseFloat(body.tech_starting_sec?.trim()) || 0;
          const ending_sec = parseFloat(body.tech_ending_sec?.trim()) || 0;
          const start_date = body.tech_start_date?.trim();
          const ending_date = body.tech_ending_date?.trim();
          const starting_third = parseFloat(body.tech_starting_third?.trim()) || 0;
          const cagr = parseFloat(body.tech_cagr?.trim()) || 0;
          const years_third = parseFloat(body.tech_years_third?.trim()) || 0;
          const months_third = parseFloat(body.tech_months_third?.trim()) || 0;
          const days_third = parseFloat(body.tech_days_third?.trim()) || 0;

          // Helper function to calculate total days
        
          	function calculateTotalDays(years, months, days)
            {
             let total_dayse = years * 365 + months * 30 + days;
              return total_dayse;
            }


          // Helper function to calculate date difference in days
          const calculateDateDifference = (startDate, endDate) => {
              const start = new Date(startDate);
              const end = new Date(endDate);
              const timeDiff = end.getTime() - start.getTime();
              return Math.floor(timeDiff / (1000 * 3600 * 24));
          };

          // Validation checks
          if (units == 'one' && starting_first >= ending_first) {
              param.error = 'ending value is greater than or not equal to starting value.';
              return param;
          }

          if (units == 'two' && starting_sec >= ending_sec) {
              param.error = 'ending value is greater than or not equal to starting value.';
              return param;
          }

          if (units == 'one' && !years_first && !months_first && !days_first) {
              param.error = 'Please! Check Enter Input.';
              return param;
          }

          if (units === 'three' && !years_third && !months_third && !days_third) {
              param.error = 'Please! Check Enter Input.';
              return param;
          }

          if (units == 'two') {
              if (!start_date) {
                  param.error = 'Please! Check Start Date Input.';
                  return param;
              }
              if (!ending_date) {
                  param.error = 'Please! Check Ending Date Input.';
                  return param;
              }
          }

          // Process based on unit type
          if (units == 'one') {
              if (!isNaN(starting_first) && !isNaN(ending_first)) {
                  const total_days = calculateTotalDays(years_first, months_first, days_first);
                  
                  if (total_days <= 0) {
                      param.error = 'Please! add at least one day';
                      return param;
                  }

                  // Calculate CAGR
                  const cagr_value = Math.pow(ending_first / starting_first, 365 / total_days) - 1;
                  
                  // Calculate doubling time
                  const double = Math.log(2) / Math.log(1 + cagr_value);
                  const yearx = Math.floor(double);
                  const fractional_part = double - yearx;
                  const total_dayz = fractional_part * 365;
                  const monthz = Math.floor(total_dayz / 30);
                  // const dayz = Math.round(total_dayz % 30);
                  const dayz = Math.floor(total_dayz % 30);

                  const table_year = total_days / 365;
                  const cagr_percentage = cagr_value * 100;

                  // Format time strings
                  const year = years_first <= 1 ? `${years_first} year` : `${years_first} years`;
                  const months = months_first <= 1 ? `${months_first} month` : `${months_first} months`;
                  const days = days_first <= 1 ? `${days_first} day` : `${days_first} days`;

                  // Set response parameters
                  param.tech_total_days = total_days;
                  param.tech_cagr_percentage = cagr_percentage;
                  param.tech_year = year;
                  param.tech_months = months;
                  param.tech_days = days;
                  param.tech_dayz = dayz;
                  param.tech_monthz = monthz;
                  param.tech_yearx = yearx;
                  param.tech_table_year = table_year;
              } else {
                  param.error = 'Please! Check Your Input';
                  return param;
              }
          } else if (units == 'two') {
              if (!isNaN(starting_sec) && !isNaN(ending_sec)) {
                  const total_days = calculateDateDifference(start_date, ending_date);
                  
                  if (total_days <= 0) {
                      param.error = 'Please! add at least one day.';
                      return param;
                  }

                  // Calculate CAGR
                  const cagr_value = Math.pow(ending_sec / starting_sec, 365 / total_days) - 1;
                  
                  // Calculate doubling time
                  const double = Math.log(2) / Math.log(1 + cagr_value);
                  const yearx = Math.floor(double);
                  const fractional_part = double - yearx;
                  const total_dayz = fractional_part * 365;
                  const monthz = Math.floor(total_dayz / 30);
                  // const dayz = Math.round(total_dayz % 30);
                  const dayz = Math.floor(total_dayz % 30);
                  const table_year = Math.round(total_days / 365);
                  const cagr_percentage = cagr_value * 100;

                  // Set response parameters
                  param.tech_total_days = total_days;
                  param.tech_cagr_percentage = cagr_percentage;
                  param.tech_dayz = dayz;
                  param.tech_monthz = monthz;
                  param.tech_yearx = yearx;
                  param.tech_table_year = table_year;
              } else {
                  param.error = 'Please fill all fields.';
                  return param;
              }
          } else if (units == 'three') {
              if (!isNaN(starting_third) && !isNaN(cagr)) {
                  const total_days_years = calculateTotalDays(years_third, months_third, days_third) / 365;
                    // console.log(total_days_years);
                  if (total_days_years <= 0) {
                      param.error = 'Please! add at least one day.';
                      return param;
                  }

                  if (cagr <= 0) {
                      param.error = 'Please! Check Your CAGR Input.';
                      return param;
                  }

                  // Calculate future value
                  const cagr_percentage = starting_third * Math.pow((1 + cagr / 100), total_days_years);
                  
                  // Calculate doubling time
                  // const cagr_decimal = cagr / 100;
                  const double = Math.log(2) / Math.log(1 + cagr);
                  const yearx = Math.floor(double);
                  const fractional_part = double - yearx;
                  const total_dayz = fractional_part * 365;
                  const monthz = Math.floor(total_dayz / 30);
                  // const dayz = Math.round(total_dayz % 30);
                    const dayz = Math.floor(total_dayz % 30);
                  // Format time strings
                  const year = years_third <= 1 ? `${years_third} year` : `${years_third} years`;
                  const months = months_third <= 1 ? `${months_third} month` : `${months_third} months`;
                  const days = days_third <= 1 ? `${days_third} day` : `${days_third} days`;

                  // Set response parameters
                  param.tech_cagr_percentage = cagr_percentage;
                  param.tech_dayz = dayz; // no
                  param.tech_monthz = monthz;
                  param.tech_yearx = yearx; // no
                  param.tech_total_days = total_days_years;
                  param.tech_year = year;
                  param.tech_months = months;
                  param.tech_days = days;
              } else {
                  param.error = 'Please fill all fields.';
                  return param;
              }
          } else {
              param.error = 'Please fill all fields.';
              return param;
          }

          return param;
      }

    /**
    * getCalculationDepreciationCalculator: Service Method
    * POST: /api/calculators-lol/depreciation-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

     async getCalculationDepreciationCalculator(request) {
        try {
          // Reset param
          this.param = {};

          // Set currency
          const hiddenCurrency = request.hiddent_currency || '$';

          // Validate method
          if (!request.method) {
            this.param.error = 'Please! Check Your Input';
            return this.param;
          }

          // Route to appropriate method
          switch (request.method) {
            case 'Straight':
              return this.calculateStraightLine(request, hiddenCurrency);
            
            case 'Declining':
              return this.calculateDeclining(request, hiddenCurrency);
            
            case 'sum':
              return this.calculateSumOfYears(request, hiddenCurrency);
            
            case 'Reducing':
              return this.calculateReducing(request, hiddenCurrency);
            
            case 'unit_of_pro':
              return this.calculateUnitOfProduction(request, hiddenCurrency);
            
            default:
              this.param.error = 'Invalid depreciation method';
              return this.param;
          }
        } catch (error) {
          this.param.error = error.message || 'An error occurred';
          return this.param;
        }
      }
      // Straight Line Method
      calculateStraightLine(request, hiddenCurrency) {
        if (!this.validateInput(request, ['asset', 'salvage', 'year', 'date'])) {
          this.param.error = 'Please! Check Your Input';
          return this.param;
        }

        const { year, salvage, asset, date, conver, round } = request;
        let asset1 = asset;
        let depreciation = 0;
        let cDepreciation = 0;
        let table = '';
        let des = '';
        let bookDes = '';
        let totalYears = '';
        let totalBookValue = '';

        const dateArray = date.split('-');
        const startMonth = parseInt(dateArray[2]);
        let startYear = parseInt(dateArray[1]);
        
        const rate = this.roundValue(100 / year, 2);

        if (conver == '0') {
          // Full year convention
          for (let i = 0; i < Number(year); i++) {
            startYear = parseInt(dateArray[2]) + i;
            totalYears += startYear + ',';

            depreciation = this.calculateDepreciation((asset - salvage) * (rate / 100), round);
            cDepreciation = this.roundValue(cDepreciation + depreciation, round === 'yes' ? 0 : 2);
            let endBookValue = this.roundValue(asset - cDepreciation, round === 'yes' ? 0 : 2);

            // Check if end book value is less than salvage
            if (endBookValue < salvage) {
              endBookValue = salvage;
              cDepreciation = cDepreciation - depreciation;
              depreciation = asset1 - salvage;
              cDepreciation = cDepreciation + depreciation;
            }

            totalBookValue += endBookValue + ',';
            table += this.generateTableRow(startYear, asset1, rate, depreciation, cDepreciation, endBookValue, hiddenCurrency);
            des += depreciation + ',';
            bookDes += asset1 + ',';
            asset1 = asset - cDepreciation;
          }
        } else {
          // Partial year convention
          const months = this.calculateMonths(conver, startMonth);

          for (let i = 0; i <= Number(year) - 1; i++) {
            startYear = parseInt(dateArray[2]) + i;
            totalYears += startYear + ',';

            depreciation = this.calculateDepreciation((asset - salvage) * (rate / 100), round);
            cDepreciation = this.roundValue(cDepreciation + depreciation, round == 'yes' ? 0 : 2);
            let endBookValue = this.roundValue(asset - cDepreciation, round == 'yes' ? 0 : 2);

            if (endBookValue < salvage) {
              endBookValue = salvage;
              depreciation = asset1 - salvage;
              cDepreciation = cDepreciation + depreciation;
            }

            if (i == 0) {
              // First year partial depreciation
              const firstYearDep = 12 / months;
              cDepreciation = cDepreciation - depreciation;
              depreciation = this.calculateDepreciation(depreciation / firstYearDep, round);
              cDepreciation = this.roundValue(cDepreciation + depreciation, round == 'yes' ? 0 : 2);
              endBookValue = this.roundValue(asset - cDepreciation, round == 'yes' ? 0 : 2);
              
              const rate1 = this.roundValue((depreciation / (asset - salvage)) * 100, 2);
              table += this.generateTableRow(startYear, asset1, rate1, depreciation, cDepreciation, endBookValue, hiddenCurrency);
              des += depreciation + ',';
              bookDes += asset1 + ',';
            } else {
              table += this.generateTableRow(startYear, asset1, rate, depreciation, cDepreciation, endBookValue, hiddenCurrency);
              des += depreciation + ',';
              bookDes += asset1 + ',';
            }

            totalBookValue += endBookValue + ',';
            asset1 = asset - cDepreciation;
          }
        }

        this.param.table = table;
        this.param.des = des;
        this.param.book_des = bookDes;
        this.param.total_years = totalYears;
        this.param.total_book_value = totalBookValue;
        this.param.RESULT = 1;
        return this.param;
      }
      // Declining Balance Method
      calculateDeclining(request, hiddenCurrency) {
        if (!this.validateInput(request, ['asset', 'salvage', 'year', 'Factor', 'date'])) {
          this.param.error = 'Please! Check Your Input';
          return this.param;
        }

        const { year, salvage, asset, Factor, date, conver, round } = request;
        let asset1 = asset;
        let depreciation = 0;
        let cDepreciation = 0;
        let table = '';
        let des = '';
        let bookDes = '';
        let totalYears = '';
        let totalBookValue = '';

        const dateArray = date.split('-');
        const startMonth = parseInt(dateArray[2]);
        let startYear = parseInt(dateArray[1]);
        
        let rate = this.roundValue((1 / year * Factor) * 100, 2);
          
        if (conver == '0') {
          for (let i = 0; i < Number(year); i++) {
            startYear = parseInt(dateArray[2]) + i;
            totalYears += startYear + ',';

            depreciation = this.calculateDepreciation(asset1 * (rate / 100), round);
            cDepreciation = this.roundValue(cDepreciation + depreciation, round == 'yes' ? 0 : 2);
            let endBookValue = this.roundValue(asset - cDepreciation, round == 'yes' ? 0 : 2);

            if (endBookValue < salvage) {
              endBookValue = salvage;
              cDepreciation = cDepreciation - depreciation;
              depreciation = asset1 - salvage;
              cDepreciation = cDepreciation + depreciation;
              rate = this.roundValue((depreciation / asset1) * 100, 2);
            }

            if (i == Number(year) - 1 && endBookValue > salvage) {
              endBookValue = salvage;
              cDepreciation = cDepreciation - depreciation;
              depreciation = asset1 - salvage;
              cDepreciation = cDepreciation + depreciation;
              rate = this.roundValue((depreciation / asset1) * 100, 2);
            }

            totalBookValue += endBookValue + ',';
            table += this.generateTableRow(startYear, asset1, rate, depreciation, cDepreciation, endBookValue, hiddenCurrency);
            des += depreciation + ',';
            bookDes += asset1 + ',';
            asset1 = asset - cDepreciation;
          }
        } else {
          const months = this.calculateMonths(conver, startMonth);

          for (let i = 0; i < Number(year); i++) {
            startYear = parseInt(dateArray[2]) + i;
            totalYears += startYear + ',';

            depreciation = this.calculateDepreciation(asset1 * (rate / 100), round);
            cDepreciation = this.roundValue(cDepreciation + depreciation, round === 'yes' ? 0 : 2);
            let endBookValue = this.roundValue(asset - cDepreciation, round === 'yes' ? 0 : 2);

            if (endBookValue < salvage) {
              endBookValue = salvage;
              depreciation = asset1 - salvage;
              cDepreciation = cDepreciation + depreciation;
              rate = this.roundValue((depreciation / asset1) * 100, 2);
            }

            if (i == Number(year) - 1 && endBookValue > salvage) {
              endBookValue = salvage;
              cDepreciation = cDepreciation - depreciation;
              depreciation = asset1 - salvage;
              cDepreciation = cDepreciation + depreciation;
              rate = this.roundValue((depreciation / asset1) * 100, 2);
            }

            if (i == 0) {
              cDepreciation = 0;
              const rate1 = this.roundValue((rate / 12) * months, 2);
              depreciation = this.calculateDepreciation(asset1 * (rate1 / 100), round);
              cDepreciation = this.roundValue(cDepreciation + depreciation, round === 'yes' ? 0 : 2);
              endBookValue = this.roundValue(asset - cDepreciation, round === 'yes' ? 0 : 2);
              table += this.generateTableRow(startYear, asset1, rate1, depreciation, cDepreciation, endBookValue, hiddenCurrency);
            } else {
              table += this.generateTableRow(startYear, asset1, rate, depreciation, cDepreciation, endBookValue, hiddenCurrency);
            }

            des += depreciation + ',';
            bookDes += asset1 + ',';
            totalBookValue += endBookValue + ',';
            asset1 = asset - cDepreciation;
          }
        }

        this.param.table = table;
        this.param.des = des;
        this.param.book_des = bookDes;
        this.param.total_years = totalYears;
        this.param.total_book_value = totalBookValue;
        this.param.RESULT = 1;
        return this.param;
      }
      // Sum of Years Digits Method
      calculateSumOfYears(request, hiddenCurrency) {
      if (!this.validateInput(request, ['asset', 'salvage', 'year', 'date'])) {
        this.param.error = 'Please! Check Your Input';
        return this.param;
      }

      const { year, salvage, asset, date, conver, round } = request;
      let asset1 = asset;
      let depreciation = 0;
      let cDepreciation = 0;
      let table = '';
      let des = '';
      let bookDes = '';
      let totalYears = '';
      let totalBookValue = '';

      // Parse date - PHP format: MM-YYYY-DD or similar
      // So index[1] = YYYY, index[2] = MM/DD depending on format
      const dateArray = date.split('-');
      let startYear = parseInt(dateArray[1]); // Year from index 1 (like PHP)
      const startMonth = parseInt(dateArray[2]); // Month from index 2 (like PHP)
      
      // Calculate sum of years
      let sum = 0;
      for (let j = Number(year); j > 0; j--) {
        sum += j;
      }

      if (conver == '0') {
        for (let i = 0; i < year; i++) {
          const rate = this.roundValue(((year - i) / sum) * 100, 2);
          startYear = parseInt(dateArray[2]) + i; // Year calculation from dateArray[2]
          totalYears += startYear + ',';

          depreciation = this.calculateDepreciation((asset - salvage) * (rate / 100), round);
          cDepreciation = this.roundValue(cDepreciation + depreciation, round == 'yes' ? 0 : 2);
          let endBookValue = this.roundValue(asset - cDepreciation, round == 'yes' ? 0 : 2);

          if (endBookValue < salvage) {
            endBookValue = salvage;
            cDepreciation = cDepreciation - depreciation;
            depreciation = asset1 - salvage;
            cDepreciation = cDepreciation + depreciation;
            rate = this.roundValue((depreciation / (asset - salvage)) * 100, 2);
          }

          if (i == year - 1 && endBookValue > salvage) {
            endBookValue = salvage;
            cDepreciation = cDepreciation - depreciation;
            depreciation = asset1 - salvage;
            cDepreciation = cDepreciation + depreciation;
            rate = this.roundValue((depreciation / (asset - salvage)) * 100, 2);
          }

          totalBookValue += endBookValue + ',';
          table += this.generateTableRow(startYear, asset1, rate, depreciation, cDepreciation, endBookValue, hiddenCurrency);
          des += depreciation + ',';
          bookDes += asset1 + ',';
          asset1 = asset - cDepreciation;
        }
      } else {
        const months = this.calculateMonths(conver, startMonth);
        for (let i = 0; i <= year; i++) {
          let rateCalc = ((year - i) / sum) * 100;
          console.log(rateCalc);
          let rate = this.roundValue(rateCalc, 2);
          startYear = parseInt(dateArray[2]) + i; // Year calculation from dateArray[2]
          totalYears += startYear + ',';

          if (i == 0) {
            // First year with partial depreciation
            cDepreciation = 0;
            rateCalc = ((year - i) / sum) * 100; // Recalculate without rounding
            const rate1 = this.roundValue((rateCalc / 12) * months, 2);
            depreciation = this.calculateDepreciation((asset - salvage) * (rate1 / 100), round);
            cDepreciation = this.roundValue(cDepreciation + depreciation, round == 'yes' ? 0 : 2);
            let endBookValue = this.roundValue(asset - cDepreciation, round == 'yes' ? 0 : 2);
            
            table += this.generateTableRow(startYear, asset1, rate1, depreciation, cDepreciation, endBookValue, hiddenCurrency);
            des += depreciation + ',';
            bookDes += asset1 + ',';
            totalBookValue += endBookValue + ',';
            asset1 = asset - cDepreciation;
          } else {
            // Subsequent years - calculate fresh
            depreciation = this.calculateDepreciation((asset - salvage) * (rate / 100), round);
            cDepreciation = this.roundValue(cDepreciation + depreciation, round == 'yes' ? 0 : 2);
            let endBookValue = this.roundValue(asset - cDepreciation, round == 'yes' ? 0 : 2);

            if (endBookValue < salvage) {
              endBookValue = salvage;
              depreciation = asset1 - salvage;
              cDepreciation = cDepreciation + depreciation;
              rate = this.roundValue((depreciation / (asset - salvage)) * 100, 2);
            }

            if (i == year) {
              if (endBookValue > salvage) {
                endBookValue = salvage;
                cDepreciation = cDepreciation - depreciation;
                depreciation = asset1 - salvage;
                cDepreciation = cDepreciation + depreciation;
                rate = this.roundValue((depreciation / (asset - salvage)) * 100, 2);
              }
            }

            table += this.generateTableRow(startYear, asset1, rate, depreciation, cDepreciation, endBookValue, hiddenCurrency);
            des += depreciation + ',';
            bookDes += asset1 + ',';
            totalBookValue += endBookValue + ',';
            asset1 = asset - cDepreciation;
          }
        }
      }

      this.param.table = table;
      this.param.des = des;
      this.param.book_des = bookDes;
      this.param.total_years = totalYears;
      this.param.total_book_value = totalBookValue;
      this.param.RESULT = 1;
      return this.param;
      }
      // Reducing Balance Method
      calculateReducing(request, hiddenCurrency) {
        if (!this.validateInput(request, ['asset', 'salvage', 'year', 'date'])) {
          this.param.error = 'Please! Check Your Input';
          return this.param;
        }

        const { year, salvage: rate, asset, date, conver, round } = request;
        let asset1 = asset;
        let depreciation = 0;
        let cDepreciation = 0;
        let table = '';
        let des = '';
        let bookDes = '';
        let totalYears = '';
        let totalBookValue = '';

        const dateArray = date.split('-');
        const startMonth = parseInt(dateArray[2]);
        let startYear = parseInt(dateArray[1]);

        if (conver == '0') {
          for (let i = 0; i < Number(year); i++) {
            startYear = parseInt(dateArray[2]) + i;
            totalYears += startYear + ',';

            depreciation = this.calculateDepreciation(asset1 * (rate / 100), round);
            cDepreciation = this.roundValue(cDepreciation + depreciation, round == 'yes' ? 0 : 2);
            const endBookValue = this.roundValue(asset - cDepreciation, round == 'yes' ? 0 : 2);

            totalBookValue += endBookValue + ',';
            table += this.generateTableRow(startYear, asset1, rate, depreciation, cDepreciation, endBookValue, hiddenCurrency);
            des += depreciation + ',';
            bookDes += asset1 + ',';
            asset1 = asset - cDepreciation;
          }
        } else {
          const months = this.calculateMonths(conver, startMonth);

          for (let i = 0; i < Number(year); i++) {
            startYear = parseInt(dateArray[2]) + i;
            totalYears += startYear + ',';

            depreciation = this.calculateDepreciation(asset1 * (rate / 100), round);
            cDepreciation = this.roundValue(cDepreciation + depreciation, round == 'yes' ? 0 : 2);
            let endBookValue = this.roundValue(asset - cDepreciation, round == 'yes' ? 0 : 2);

            if (i == 0) {
              cDepreciation = 0;
              const rate1 = this.roundValue((rate / 12) * months, 2);
              depreciation = this.calculateDepreciation(asset1 * (rate1 / 100), round);
              cDepreciation = this.roundValue(cDepreciation + depreciation, round == 'yes' ? 0 : 2);
              endBookValue = this.roundValue(asset - cDepreciation, round == 'yes' ? 0 : 2);
              table += this.generateTableRow(startYear, asset1, rate1, depreciation, cDepreciation, endBookValue, hiddenCurrency);
            } else {
              table += this.generateTableRow(startYear, asset1, rate, depreciation, cDepreciation, endBookValue, hiddenCurrency);
            }

            des += depreciation + ',';
            bookDes += asset1 + ',';
            totalBookValue += endBookValue + ',';
            asset1 = asset - cDepreciation;
          }
        }

        this.param.table = table;
        this.param.des = des;
        this.param.book_des = bookDes;
        this.param.total_years = totalYears;
        this.param.total_book_value = totalBookValue;
        this.param.RESULT = 1;
        return this.param;
      }
      // Unit of Production Method
      calculateUnitOfProduction(request, hiddenCurrency) {
        if (!this.validateInput(request, ['asset', 'salvage', 'u_of_p'])) {
          this.param.error = 'Please! Check Your Input';
          return this.param;
        }

        const { asset, salvage, year, u_of_p } = request;

        const depreciableBase = asset - salvage;
        const depreciationPerUnit = depreciableBase / Number(year);
        const depreciationForPeriod = depreciationPerUnit * u_of_p;

        this.param.Depreciable_Base = this.formatNumber(depreciableBase);
        this.param.Depreciation_Per_Unit = this.formatNumber(depreciationPerUnit);
        this.param.Depreciation_for_Period = this.formatNumber(depreciationForPeriod);
        return this.param;
      }
      // Helper Methods
      validateInput(request, requiredFields) {
        for (const field of requiredFields) {
          if (request[field] === undefined || request[field] === null || request[field] === '') {
            return false;
          }
          // Check if numeric fields are actually numeric
          if (['asset', 'salvage', 'year', 'Factor', 'u_of_p'].includes(field)) {
            if (isNaN(parseFloat(request[field]))) {
              return false;
            }
          }
        }
        return true;
      }
      calculateMonths(conver, startMonth) {
        if (conver === '3') {
          return 12.5 - startMonth;
        }
        if (conver === '4') {
          return 13 - startMonth;
        }
        if (conver === '1') {
          if (startMonth <= 3) return 13 - 2.5;
          if (startMonth > 3 && startMonth <= 6) return 13 - 5.5;
          if (startMonth > 6 && startMonth <= 9) return 13 - 8.5;
          if (startMonth > 9 && startMonth <= 12) return 13 - 10.5;
        }
        if (conver === '2') {
          return 6;
        }
        return 12;
      }
      calculateDepreciation(value, round) {
        return round === 'yes' ? Math.round(value) : this.roundValue(value, 2);
      }
      roundValue(value, decimals = 2) {
        return Math.round(value * Math.pow(10, decimals)) / Math.pow(10, decimals);
      }
      formatNumber(value) {
        return value.toLocaleString('en-US', {
          minimumFractionDigits: 0,
          maximumFractionDigits: 2
        });
      }
      generateTableRow(year, beginningValue, rate, depreciation, cumDepreciation, endingValue, currency) {
        return `<tr>
          <td class="py-2 border-b">${year}</td>
          <td class="py-2 border-b">${currency} ${beginningValue}</td>
          <td class="py-2 border-b">${rate}%</td>
          <td class="py-2 border-b">${currency} ${depreciation}</td>
          <td class="py-2 border-b">${currency} ${cumDepreciation}</td>
          <td class="py-2 border-b">${currency} ${endingValue}</td>
        </tr>`;
      }

    /**
    * getCalculationAgeCalculator: Service Method
    * POST: /api/calculators-lol/age-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

   async getCalculationAgeCalculator(body) {
      try {
        let day = body.tech_day;
        let month = body.tech_month;
        let year = body.tech_year;
        let day_sec = body.tech_day_sec;
        let month_sec = body.tech_month_sec;
        let year_sec = body.tech_year_sec;
        let submit = body.tech_submit;


        // Format dates
        const dob = `${String(year).padStart(4, '0')}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
        const e_date = `${String(year_sec).padStart(4, '0')}-${String(month_sec).padStart(2, '0')}-${String(day_sec).padStart(2, '0')}`;

        // Parse dates
        const orderdob = dob.split('-');
        const orderdate = e_date.split('-');
        
        const e_year = parseInt(orderdate[0]);
        const e_month = parseInt(orderdate[1]);
        const e_day = parseInt(orderdate[2]);
        const dob_year = parseInt(orderdob[0]);
        const dob_month = parseInt(orderdob[1]);
        const dob_day = parseInt(orderdob[2]);

        // Validate inputs
        if (!Number.isInteger(dob_day) || !Number.isInteger(dob_month) || !Number.isInteger(dob_year) ||
            !Number.isInteger(e_day) || !Number.isInteger(e_month) || !Number.isInteger(e_year)) {
          return { error: 'Please check your input.' };
        }

        const result = {};
        const dob_array = [`${String(dob_year).padStart(2, '0')}-${String(dob_month).padStart(2, '0')}-${String(dob_day).padStart(2, '0')}`];
        const dates_array = [`${String(e_year).padStart(2, '0')}-${String(e_month).padStart(2, '0')}-${String(e_day).padStart(2, '0')}`];

        // Initialize arrays
        const all_dob = [];
        const age_years = [];
        const age_months = [];
        const age_days = [];
        const all_users_days = [];
        const Total_years = [];
        const Total_months = [];
        const Total_weeks = [];
        const Total_days = [];
        const Total_hours = [];
        const Total_minuts = [];
        const Total_seconds = [];
        const N_r_days = [];
        const N_r_days_per = [];
        const breath = [];
        const heartBeats = [];
        const sleeping = [];
        const laughed = [];
        const half_brdy = [];
        const n_half_brdy_days = [];
        const blinking_times = [];
        const hair_length_mm = [];
        const hair_length_m = [];
        const nail_length_mm = [];
        const nail_length_m = [];
        const dog_age = [];
        const cat_age = [];
        const turtle_age = [];
        const horse_age = [];
        const cow_age = [];
        const elephant_age = [];
        const mercury_age = [];
        const venus_age = [];
        const mars_age = [];
        const jupiter_age = [];
        const saturn_age = [];

        for (let i = 0; i < dob_array.length; i++) {
          const dob_str = dob_array[i];
          const dobDate = new Date(dob_str);
          
          // Format date of birth
          all_dob.push(dobDate.toLocaleDateString('en-US', { 
            weekday: 'long', 
            year: 'numeric', 
            month: 'long', 
            day: 'numeric' 
          }));

          const date_str = dates_array[i];
          const endDate = new Date(date_str);
          
          // Calculate age difference
          const diff = this.calculateDateDifferenceage(dobDate, endDate);
          console.log(diff);
          age_years.push(diff.years);
          age_months.push(diff.months);
          age_days.push(diff.days);
          all_users_days.push(diff.totalDays);

          // Current date calculations
          const now = new Date();
          const dob_timestamp = dobDate.getTime();
          const end_timestamp = endDate.getTime();

          // Validate date
          if (end_timestamp - dob_timestamp <= 0) {
            return { error: 'Invalid Date of Birth.' };
          }

          // Calculate totals
          const diff_seconds = Math.floor((end_timestamp - dob_timestamp) / 1000);
          const totalyears = Math.floor(diff_seconds / 31536000);
          
          Total_years.push(totalyears);
          Total_months.push(Math.floor(diff_seconds / 2628000));
          Total_weeks.push(Math.floor(diff_seconds / 604800));
          
          const total_days = Math.floor(diff_seconds / 86400);
          Total_days.push(total_days);
          Total_hours.push(Math.floor(diff_seconds / 3600));
          
          const total_minuts = Math.floor(diff_seconds / 60);
          Total_minuts.push(total_minuts);
          Total_seconds.push(diff_seconds);

          // Next Birthday calculation
          const current_year = now.getFullYear();
          const current_month = now.getMonth() + 1;
          const current_day = now.getDate();
          
          let next_birthday_year = current_year;
          if (current_month > dob_month || (current_month === dob_month && current_day >= dob_day)) {
            next_birthday_year = current_year + 1;
          }

          const next_birthday = new Date(next_birthday_year, dob_month - 1, dob_day);
          const days_to_birthday = Math.floor((next_birthday - now) / (1000 * 60 * 60 * 24));
          
          N_r_days.push(days_to_birthday);
          N_r_days_per.push(Math.round((days_to_birthday / 365) * 100));

          // Health and life statistics
          breath.push(Math.round(0.5 * 15 * total_minuts));
          heartBeats.push(Math.round(72 * total_minuts));
          sleeping.push(Math.round(totalyears * 365.25 * 8 / (365.25 * 24) * 10) / 10);
          laughed.push(total_days * 10);

          // Half Birthday calculation
          const half_birthday_date = new Date(dobDate);
          half_birthday_date.setMonth(half_birthday_date.getMonth() + 6);
          
          let half_bd_year = current_year;
          const half_bd_month = half_birthday_date.getMonth() + 1;
          const half_bd_day = half_birthday_date.getDate();
          
          if (current_month > half_bd_month || (current_month === half_bd_month && current_day > half_bd_day)) {
            half_bd_year = current_year + 1;
          }

          const next_half_birthday = new Date(half_bd_year, half_bd_month - 1, half_bd_day);
          half_brdy.push(next_half_birthday.toLocaleDateString('en-US', { 
            weekday: 'long', 
            year: 'numeric', 
            month: 'long', 
            day: 'numeric' 
          }));

          const days_to_half_birthday = Math.floor((next_half_birthday - now) / (1000 * 60 * 60 * 24));
          n_half_brdy_days.push(days_to_half_birthday * 100 / 365);

          // Physical calculations
          blinking_times.push(diff.totalDays * 16800);
          hair_length_mm.push(diff.totalDays * 0.42);
          hair_length_m.push((diff.totalDays * 0.42) / 1000);
          nail_length_mm.push(diff.totalDays * 0.12);
          nail_length_m.push((diff.totalDays * 0.12) / 1000);

          // Animal age calculations
          dog_age.push(parseFloat((diff.totalDays * 0.0004657534246575342).toFixed(2)));
          cat_age.push(parseFloat((diff.totalDays * 0.0005753424657534247).toFixed(2)));
          turtle_age.push(parseFloat((diff.totalDays * 0.0068219178082192).toFixed(2)));
          horse_age.push(parseFloat((diff.totalDays * 0.001041095890411).toFixed(2)));
          cow_age.push(parseFloat((diff.totalDays * 0.0007671232876712329).toFixed(2)));
          elephant_age.push(parseFloat((diff.totalDays * 0.0018630136986301).toFixed(2)));

          // Planet age calculations
          mercury_age.push(parseFloat((diff.totalDays * 0.0113698630136986).toFixed(2)));
          venus_age.push(parseFloat((diff.totalDays * 0.0044383561643836).toFixed(2)));
          mars_age.push(parseFloat((diff.totalDays * 0.0014520547945205).toFixed(2)));
          jupiter_age.push(parseFloat((diff.totalDays * 0.0002191780821917808).toFixed(2)));
          saturn_age.push(parseFloat((diff.totalDays * 0.00008219178082191781).toFixed(2)));
        }

        // Combine years and days
        const sum_users_days = all_users_days.reduce((a, b) => a + b, 0);
        const combine_years = sum_users_days / 365.2425;
        const combine_years_ans = Math.floor(combine_years);
        const combine_days_ans = Math.floor(sum_users_days % 365.2425);

        // Combine remaining days
        const combine_r_days = Math.round((365 - combine_days_ans) / dob_array.length);
        const today = new Date();
        const next_combine_date = new Date(today);
        next_combine_date.setDate(today.getDate() + combine_r_days);
        const next_combine_brdy = next_combine_date.toLocaleDateString('en-US', { 
          year: 'numeric', 
          month: 'long', 
          day: 'numeric' 
        });
        const combine_r_days_per = Math.round((combine_r_days / 365) * 100);

        // Build result object
        result.tech_dob_array = dob_array;
        result.tech_dates_array = dates_array;
        result.tech_all_dob = all_dob;
        result.tech_N_r_days = N_r_days;
        result.tech_N_r_days_per = N_r_days_per;
        result.tech_combine_years_ans = combine_years_ans;
        result.tech_combine_days_ans = combine_days_ans;
        result.tech_combine_r_days = combine_r_days;
        result.tech_combine_r_days_per = combine_r_days_per;
        result.tech_next_combine_brdy = next_combine_brdy;
        result.tech_age_years = age_years;
        result.tech_age_months = age_months;
        result.tech_age_days = age_days;
        result.tech_half_brdy = half_brdy;
        result.tech_Total_years = Total_years;
        result.tech_Total_months = Total_months;
        result.tech_Total_weeks = Total_weeks;
        result.tech_Total_days = Total_days;
        result.tech_Total_hours = Total_hours;
        result.tech_Total_minuts = Total_minuts;
        result.tech_Total_seconds = Total_seconds;
        result.tech_breath = breath;
        result.tech_heartBeats = heartBeats;
        result.tech_sleeping = sleeping;
        result.tech_laughed = laughed;
        result.tech_blinking_times = blinking_times;
        result.tech_hair_length_mm = hair_length_mm;
        result.tech_hair_length_m = hair_length_m;
        result.tech_nail_length_mm = nail_length_mm;
        result.tech_nail_length_m = nail_length_m;
        result.tech_dog_age = dog_age;
        result.tech_cat_age = cat_age;
        result.tech_turtle_age = turtle_age;
        result.tech_horse_age = horse_age;
        result.tech_cow_age = cow_age;
        result.tech_elephant_age = elephant_age;
        result.tech_mercury_age = mercury_age;
        result.tech_venus_age = venus_age;
        result.tech_mars_age = mars_age;
        result.tech_jupiter_age = jupiter_age;
        result.tech_saturn_age = saturn_age;
        result.tech_submit = submit;

        return result;
      } catch (error) {
        console.error('Error in age calculation:', error);
        return { error: 'An error occurred during calculation.' };
      }
      // Helper function to calculate date difference
    }
     calculateDateDifferenceage(startDate, endDate) {
       let years = endDate.getFullYear() - startDate.getFullYear();
       let months = endDate.getMonth() - startDate.getMonth();
       let days = endDate.getDate() - startDate.getDate();
       
      if (days < 0) {
        months--;
        const prevMonth = new Date(endDate.getFullYear(), endDate.getMonth(), 0);
        days += prevMonth.getDate();
      }

      if (months < 0) {
        years--;
        months += 12;
      }

      // Calculate total days
      const totalDays = Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24));

      return { years, months, days, totalDays };
    }



     /**
    * getCalculationPPICalculator: Service Method
    * POST: /api/calculators-lol/ppl-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationPPICalculator(body) {
      const vertical = body.tech_v;
      const diagonal = body.tech_d;
      const horizontal = body.tech_h;
      const unit = body.tech_unit;

      let fieldsDone = 0;
      let numeric = 0;

      // Check if all fields are filled
      if (vertical && horizontal && diagonal) {
          fieldsDone = 1;
      }

      // Check if all values are numeric
      if (!isNaN(diagonal) && !isNaN(horizontal) && !isNaN(vertical)) {
          numeric = 1;
      }

      // Validation
      if (!fieldsDone) {
          return {
              error: 'Please! Fill all the Input Fields'
          };
      }

      if (!numeric) {
          return {
              error: 'Please! Fill all the Input Fields'
          };
      }

      // Convert diagonal based on unit
      let diagonalValue = parseFloat(diagonal);
      
      if (unit == 'm') {
          diagonalValue = diagonalValue * 39.37;
      }
      if (unit == 'cm') {
          diagonalValue = diagonalValue / 2.54;
      }
      if (unit == 'ft') {
          diagonalValue = diagonalValue * 12;
      }
      if (unit == 'yd') {
          diagonalValue = diagonalValue * 36;
      }

      const verticalNum = parseFloat(vertical);
      const horizontalNum = parseFloat(horizontal);

      // Calculate diagonal from resolution
      const dia = Math.round(Math.sqrt(Math.pow(verticalNum, 2) + Math.pow(horizontalNum, 2)) * 100) / 100;

      // Calculate PPI
      const ppi = Math.sqrt((horizontalNum * horizontalNum) + (verticalNum * verticalNum)) / diagonalValue;
      const ppiRounded = Math.round(ppi * 100) / 100;

      // Calculate PPI squared
      const ppis = Math.round(ppi * ppi * 100) / 100;

      // Calculate pixel size
      const pixls = horizontalNum / ((Math.sqrt((horizontalNum * horizontalNum) + (verticalNum * verticalNum)) / (diagonalValue * 25.4))) / horizontalNum;
      const pixlsRounded = Math.round(pixls * 10000) / 10000;

      // Calculate megapixels
      const mpx = verticalNum * horizontalNum / 1000000;

      // GCD function
      function gcd(a, b) {
          if (a === 0 || b === 0) {
              return Math.abs(Math.max(Math.abs(a), Math.abs(b)));
          }
          const r = a % b;
          return (r !== 0) ? gcd(b, r) : Math.abs(b);
      }

      const gcdValue = gcd(horizontalNum, verticalNum);
      const ratio = (horizontalNum / gcdValue) + ':' + (verticalNum / gcdValue);

      // Calculate screen dimensions
      const over = verticalNum / horizontalNum;
      const xd = Math.round(Math.sqrt((Math.pow(diagonalValue, 2) / (1 + Math.pow(over, 2)))) * 100) / 100;
      const yd = Math.round(xd * over * 100) / 100;
      const xdcm = Math.round(xd * 2.54 * 100) / 100;
      const ydcm = Math.round(yd * 2.54 * 100) / 100;
      const screen_size = Math.round(xd * yd * 100) / 100;
      const s_cm = Math.round(screen_size * 6.452 * 100) / 100;

      const screen_in = xd + "'' x " + yd + "'' = " + screen_size + ' in²';
      const screen_cm = Math.round(xd * 2.54 * 100) / 100 + " cm x " + Math.round(yd * 2.54 * 100) / 100 + " cm = " + s_cm + ' cm²';

      // Return values
      return {
          tech_PPI: ppiRounded,
          tech_dia: dia,
          tech_screen_in: screen_in,
          tech_screen_cm: screen_cm,
          tech_screen_size: screen_size + ' in² ( ' + s_cm + ' cm² )',
          tech_xd: xd + '" ( ' + xdcm + ' cm)',
          tech_yd: yd + '" ( ' + ydcm + ' cm)',
          tech_ratio: ratio,
          tech_PPIS: ppis,
          tech_Pixls: pixlsRounded,
          tech_mpx: mpx,
      };
  }

     /**
    * getCalculationAgeDifferenceCalculator: Service Method
    * POST: /api/calculators-lol/age-difference-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationAgeDifferenceCalculator(body) {
      
      const submit = body.tech_selection;
      const dob_f = body.tech_dob_f;
      const dob_s = body.tech_dob_s;
      const year_1 = body.tech_year_1;
      const year_2 = body.tech_year_2;
      const age_1 = body.tech_age_1;
      const age_2 = body.tech_age_2;
      const current_date = body.tech_current_date || moment().format('YYYY-MM-DD'); // Request se current date lo

      let result = {};

    
          function calculateAgeDifference(date1Str, date2Str) {
          const start = moment(date1Str, 'YYYY-MM-DD');
          const end = moment(date2Str, 'YYYY-MM-DD');

          let from, to;
          if (start.isAfter(end)) {
              from = end.clone();
              to = start.clone();
          } else {
              from = start.clone();
              to = end.clone();
          }

          let years = to.year() - from.year();
          let months = to.month() - from.month();
          let days = to.date() - from.date();

          if (days < 0) {
              // borrow days from previous month
              const prevMonth = to.clone().subtract(1, 'month');
              days += prevMonth.daysInMonth();
              months--;
          }

          if (months < 0) {
              months += 12;
              years--;
          }

          return { years, months, days };
      }



      if (submit == "1") {
          if (dob_f && dob_s) {
              const dobFirst = dob_f;
              const dobSecond = dob_s;
              const currentDate = current_date;

              const ageDiff = calculateAgeDifference(dobFirst, dobSecond);
              const age_diff_Year = ageDiff.years;
              const age_diff_Month = ageDiff.months;
              const age_diff_Day = ageDiff.days;
              
              const age_diff_in_days = Math.abs(
                  moment(dobFirst, 'YYYY-MM-DD').diff(moment(dobSecond, 'YYYY-MM-DD'), 'days')
              );
              const age_diff_weeks = Math.floor(age_diff_in_days / 7);
              const age_diff_remaining_days = age_diff_in_days % 7;

              const ageFirst = calculateAgeDifference(currentDate, dobFirst);
              const ageFYear = ageFirst.years;
              const ageFMonth = ageFirst.months;
              const ageFDay = ageFirst.days;

              const ageSecond = calculateAgeDifference(currentDate, dobSecond);

              const ageSYear = ageSecond.years;
              const ageSMonth = ageSecond.months;
              const ageSDay = ageSecond.days;

              result = {
                  tech_submit: submit,
                  tech_age_diff_Day: age_diff_Day,
                  tech_age_diff_Month: age_diff_Month,
                  tech_age_diff_Year: age_diff_Year,
                  tech_age_diff_in_days: age_diff_in_days,
                  tech_age_diff_weeks: age_diff_weeks,
                  tech_age_diff_remaining_days: age_diff_remaining_days,
                  tech_ageFYear: ageFYear,
                  tech_ageFMonth: ageFMonth,
                  tech_ageFDay: ageFDay,
                  tech_ageSYear: ageSYear,
                  tech_ageSMonth: ageSMonth,
                  tech_ageSDay: ageSDay,
              };
          } else {
              return {
                  error: 'Please! Select Correct Date'
              };
          }
      } else if (submit == "2") {
          if (year_1 && year_2) {
              const dobFirst = `${year_1}-01-01`;
              const dobSecond = `${year_2}-01-01`;

              const ageDiff = calculateAgeDifference(dobFirst, dobSecond);
              const age_diff_Year = ageDiff.years;
              const age_diff_Month = ageDiff.months;
              const age_diff_Day = ageDiff.days;
              
              const age_diff_in_days = Math.abs(
                  moment(dobFirst, 'YYYY-MM-DD').diff(moment(dobSecond, 'YYYY-MM-DD'), 'days')
              );
              const age_diff_weeks = Math.floor(age_diff_in_days / 7);
              const age_diff_remaining_days = age_diff_in_days % 7;

              result = {
                  tech_submit: submit,
                  tech_age_diff_Day: age_diff_Day,
                  tech_age_diff_Month: age_diff_Month,
                  tech_age_diff_Year: age_diff_Year,
                  tech_age_diff_in_days: age_diff_in_days,
                  tech_age_diff_weeks: age_diff_weeks,
                  tech_age_diff_remaining_days: age_diff_remaining_days,
              };
          } else {
              return {
                  error: 'Please! Select Correct Year'
              };
          }
      } else {
          if (!isNaN(age_1) && !isNaN(age_2)) {
              const age_diff_Year = Math.abs(parseFloat(age_2) - parseFloat(age_1));
              const age_diff_in_days = age_diff_Year * 365;

              result = {
                  tech_submit: submit,
                  tech_age_diff_Year: age_diff_Year,
                  tech_age_diff_in_days: age_diff_in_days,
              };
          } else {
              return {
                  error: 'Please! Check Your Input'
              };
          }
      }

      return result;
  }
   

     /**
    * getCalculationFreightClassCalculator: Service Method
    * POST: /api/calculators-lol/freight-class-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

      async getCalculationFreightClassCalculator(body) {
        let submit = body.tech_submit;
          let length = body.tech_length;
          let length_unit = body.tech_length_unit;
          let width = body.tech_width;
          let width_unit = body.tech_width_unit;
          let height = body.tech_height;
          let height_unit = body.tech_height_unit;
          let weight = body.tech_weight;
          let weight_unit = body.tech_weight_unit;
          let pq = body.tech_pq;
          let fr = body.tech_fr;
          let fr_unit = body.tech_fr_unit;
          let currancy = body.tech_currancy;


    const result = {};
    
    // Check for empty required fields
    if (!length || !width || !height || !weight || !pq) {
      result.error = 'Please! Fill all the Input Fields';
      return result;
    }

    if (!submit) {
      result.error = 'Please! Fill all the Input Fields';
      return result;
    }

    // Check pallet quantity
    if (pq < 1) {
      result.error = 'Pallet Quantity cannot be zero or less.';
      return result;
    }

    // Significant figures function
    function sigFig(value, digits) {
      if (isNaN(value) || !isFinite(value)) return 0;

      let decimalPlaces;
      if (value === 0) {
        decimalPlaces = digits - 1;
      } else if (value < 0) {
        decimalPlaces = digits - Math.floor(Math.log10(-value)) - 1;
      } else {
        decimalPlaces = digits - Math.floor(Math.log10(value)) - 1;
      }

      // ✅ Clamp between 0 and 100
      decimalPlaces = Math.min(Math.max(decimalPlaces, 0), 100);

      return Number(value.toFixed(decimalPlaces));
    }

    let lengthValue = parseFloat(length);
    let widthValue = parseFloat(width);
    let heightValue = parseFloat(height);
    let weightValue = parseFloat(weight);
    let frValue = fr ? parseFloat(fr) : null;
    
    // ✅ FIX: fr_unit ko properly handle karo
    let frUnitValue = null;
    if (fr_unit) {
      // Agar fr_unit mein '/' hai toh uske baad ka part lo
      if (fr_unit.includes('/')) {
        frUnitValue = fr_unit.split('/').pop(); // Last part after '/'
      } else {
        frUnitValue = fr_unit;
      }
      
      // Agar currancy bhi provide hai toh use remove karo
      if (currancy && frUnitValue.startsWith(currancy)) {
        frUnitValue = frUnitValue.replace(currancy, '');
      }
    }

    // Convert length to inches
    if (!isNaN(lengthValue)) {
      const lengthConversions = {
        'mm': 25.4,
        'cm': 2.54,
        'm': 0.0254,
        'km': 0.0000254,
        'ft': 0.08333,
        'yd': 0.02778,
        'mi': 0.000015783,
        'nmi': 0.000013715
      };
      if (lengthConversions[length_unit]) {
        lengthValue = lengthValue / lengthConversions[length_unit];
      }
    }

    // Convert width to inches
    if (!isNaN(widthValue)) {
      const widthConversions = {
        'mm': 25.4,
        'cm': 2.54,
        'm': 0.0254,
        'km': 0.0000254,
        'ft': 0.08333,
        'yd': 0.02778,
        'mi': 0.000015783,
        'nmi': 0.000013715
      };
      if (widthConversions[width_unit]) {
        widthValue = widthValue / widthConversions[width_unit];
      }
    }

    // Convert height to inches
    if (!isNaN(heightValue)) {
      const heightConversions = {
        'mm': 25.4,
        'cm': 2.54,
        'm': 0.0254,
        'km': 0.0000254,
        'ft': 0.08333,
        'yd': 0.02778,
        'mi': 0.000015783,
        'nmi': 0.000013715
      };
      if (heightConversions[height_unit]) {
        heightValue = heightValue / heightConversions[height_unit];
      }
    }

    // Convert weight to pounds
    if (!isNaN(weightValue)) {
      const weightConversions = {
        'ug': 453592370,
        'mg': 453592,
        'g': 453.6,
        'dag': 45.36,
        'kg': 0.4536,
        't': 0.0004536,
        'gr': 7000,
        'dr': 256,
        'oz': 16,
        'stone': 0.07143,
        'us_ton': 0.0005,
        'long_ton': 0.0004464,
        'oz t': 14.583
      };
      
      if (weightConversions[weight_unit]) {
        weightValue = weightValue / weightConversions[weight_unit];
      } else if (weight_unit === 'earths') {
        weightValue = weightValue * 13166006297680889120775995;
      } else if (weight_unit === 'me') {
        weightValue = weightValue / 497939698128157422761985444381;
      } else if (weight_unit === 'u') {
        weightValue = weightValue / 273159675507180000000000000;
      }
    }

    // Convert freight rate to pounds
    // console.log('frUnitValue:', frUnitValue);
    
    if (frValue && !isNaN(frValue) && frUnitValue) {
      const frConversions = {
        'ug': 453592370,
        'mg': 453592,
        'g': 453.6,
        'dag': 45.36,
        'kg': 0.4536,
        't': 0.0004536,
        'gr': 7000,
        'dr': 256,
        'oz': 16,
        'stone': 0.07143,
        'us_ton': 0.0005,
        'long_ton': 0.0004464,
        'oz t': 14.583
      };
    
      if (frConversions[frUnitValue]) {
        frValue = frValue / frConversions[frUnitValue];
      } else if (frUnitValue === 'earths') {
        frValue = frValue * 13166006297680889120775995;
      } else if (frUnitValue === 'me') {
        frValue = frValue / 497939698128157422761985444381;
      } else if (frUnitValue === 'u') {
        frValue = frValue / 273159675507180000000000000;
      }
    }

    // Calculate volume and density
    const total = lengthValue * widthValue * heightValue;
    const volume = (total / 1728) * pq;
    const density = weightValue / volume;
    const weightPerPallet = weightValue / pq;

    // Determine freight class
    let f_cls;
    if (density < 1) f_cls = 500;
    else if (density < 2) f_cls = 400;
    else if (density < 3) f_cls = 300;
    else if (density < 4) f_cls = 250;
    else if (density < 5) f_cls = 200;
    else if (density < 6) f_cls = 175;
    else if (density < 7) f_cls = 150;
    else if (density < 8) f_cls = 125;
    else if (density < 9) f_cls = 110;
    else if (density < 10) f_cls = 100;
    else if (density < 12) f_cls = 92.5;
    else if (density < 13) f_cls = 85;
    else if (density < 15) f_cls = 77.5;
    else if (density < 22) f_cls = 70;
    else if (density < 30) f_cls = 65;
    else if (density < 35) f_cls = 60;
    else if (density < 50) f_cls = 55;
    else f_cls = 50;

    // Calculate freight cost if freight rate provided
    if (frValue && !isNaN(frValue)) {
      const fc = frValue * 936.96;
      result.tech_fc = fc;
    }

    result.tech_weight = sigFig(weightPerPallet, 4);
    result.tech_volume = sigFig(volume, 4);
    result.tech_density = sigFig(density, 4);
    result.tech_f_cls = sigFig(f_cls, 4);

    return result;
  }

    /**
    * getCalculationSobrietyCalculator: Service Method
    * POST: /api/calculators-lol/sobriety-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */
    async getCalculationSobrietyCalculator(body) {
      let input = body.tech_input;
      let input2 = body.tech_input2;
      let submit = body.tech_submit;
      const result = {};

      if (!submit) {
        result.error = 'Please! Check Your Input';
        return result;
      }

      try {
        // Detect date format and parse accordingly
        let s_date, e_date;
        
        // Check if format is YYYY-MM-DD or DD-MM-YYYY
        if (input.match(/^\d{4}-\d{2}-\d{2}$/)) {
          // Format: YYYY-MM-DD
          s_date = input.split("-");
          s_date = [s_date[2], s_date[1], s_date[0]]; // Convert to [DD, MM, YYYY]
        } else {
          // Format: DD-MM-YYYY
          s_date = input.split("-");
        }
        
        if (input2.match(/^\d{4}-\d{2}-\d{2}$/)) {
          // Format: YYYY-MM-DD
          e_date = input2.split("-");
          e_date = [e_date[2], e_date[1], e_date[0]]; // Convert to [DD, MM, YYYY]
        } else {
          // Format: DD-MM-YYYY
          e_date = input2.split("-");
        }

        const s_hour = 0;
        const s_min = 0;
        const s_sec = 0;
        const e_hour = 0;
        const e_min = 0;
        const e_sec = 0;

        // Create Date objects
        // s_date[0] = day, s_date[1] = month, s_date[2] = year
        const fromDate = new Date(s_date[2], s_date[1] - 1, s_date[0]);
        const toDate = new Date(e_date[2], e_date[1] - 1, e_date[0]);

        // Determine which date is earlier
        let startDate = fromDate <= toDate ? fromDate : toDate;
        let endDate = fromDate <= toDate ? toDate : fromDate;

        // Calculate difference in years, months, days
        let years = endDate.getFullYear() - startDate.getFullYear();
        let months = endDate.getMonth() - startDate.getMonth();
        let days = endDate.getDate() - startDate.getDate();

        // Adjust for negative days
        if (days < 0) {
          months--;
          const prevMonth = new Date(endDate.getFullYear(), endDate.getMonth(), 0);
          days += prevMonth.getDate();
        }

        // Adjust for negative months
        if (months < 0) {
          years--;
          months += 12;
        }

        // Format dates
        const formatDate = (dateStr) => {
          let parts;
          if (dateStr.match(/^\d{4}-\d{2}-\d{2}$/)) {
            parts = dateStr.split("-");
            parts = [parts[2], parts[1], parts[0]]; // Convert to [DD, MM, YYYY]
          } else {
            parts = dateStr.split('-');
          }
          const date = new Date(parts[2], parts[1] - 1, parts[0]);
          const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                            'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
          return `${monthNames[date.getMonth()]} ${String(date.getDate()).padStart(2, '0')}, ${date.getFullYear()}`;
        };

        let from = formatDate(input);
        let to = formatDate(input2);

        // Swap if needed to match original dates
        if (fromDate > toDate) {
          const temp = from;
          from = to;
          to = temp;
        }

        // Calculate timestamps
        const d1 = Math.floor(new Date(s_date[2], s_date[1] - 1, s_date[0], s_hour, s_min, s_sec).getTime() / 1000);
        const d2 = Math.floor(new Date(e_date[2], e_date[1] - 1, e_date[0], e_hour, e_min, e_sec).getTime() / 1000);
        const diff = Math.abs(d2 - d1);

        // Calculate hours, minutes, seconds (remaining after years, months, days)
        const hours = Math.floor((diff - years * 365 * 60 * 60 * 24 - months * 30 * 60 * 60 * 24 - days * 60 * 60 * 24) / (60 * 60));
        const minutes = Math.floor((diff - years * 365 * 60 * 60 * 24 - months * 30 * 60 * 60 * 24 - days * 60 * 60 * 24 - hours * 60 * 60) / 60);
        const seconds = Math.floor((diff - years * 365 * 60 * 60 * 24 - months * 30 * 60 * 60 * 24 - days * 60 * 60 * 24 - hours * 60 * 60 - minutes * 60));

        // Calculate days from months
        const day1 = months * 30.417;
        const d1_ans = parseFloat((day1 + days).toFixed(3));

        // Calculate total months
        const months1 = years * 12;
        const mon_ans = months1 + months;

        // Calculate total days between dates
        const days_ans = Math.floor(diff / (60 * 60 * 24));

        // Calculate total hours
        const hours_ans = days_ans * 24;

        // Calculate weeks
        const weeks = Math.floor(days_ans / 7);
        const w_days = weeks * 7;
        const wd_ans = days_ans - w_days;

        // Prepare result
        result.tech_from = from;
        result.tech_diff = diff;
        result.tech_to = to;
        result.tech_years = years;
        result.tech_months = months;
        result.tech_hours = parseFloat(hours.toFixed(1));
        result.tech_days = days;
        result.tech_d1_ans = d1_ans;
        result.tech_mon_ans = mon_ans;
        result.tech_days_ans = days_ans.toString();
        result.tech_hours_ans = hours_ans;
        result.tech_weeks = parseFloat(weeks.toFixed(1));
        result.tech_wd_ans = parseFloat(wd_ans.toFixed(1));

        return result;

      } catch (error) {
        console.error('Error in sobriety calculator:', error);
        result.error = 'Please! Check Your Input';
        return result;
      }
  }


      /**
    * getCalculationHouseAgeCalculator: Service Method
    * POST: /api/calculators-lol/house-age-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */
   async getCalculationHouseAgeCalculator(body) {
      let build_date = body.tech_build_date;
      let structure_type = body.tech_structure_type;

      const result = {};

      // Validate inputs
      if (!structure_type || !build_date) {
        result.error = 'Please! Check Your Input';
        return result;
      }

      try {
        // Parse build date
        const date1 = new Date(build_date);
        const date2 = new Date();

        // Check if build date is in the past
        if (date1 >= date2) {
          result.error = 'Please! Check Your Input';
          return result;
        }

        // Calculate age difference
        let years = date2.getFullYear() - date1.getFullYear();
        let months = date2.getMonth() - date1.getMonth();
        let days = date2.getDate() - date1.getDate();

        // Adjust for negative days
        if (days < 0) {
          months--;
          const prevMonth = new Date(date2.getFullYear(), date2.getMonth(), 0);
          days += prevMonth.getDate();
        }

        // Adjust for negative months
        if (months < 0) {
          years--;
          months += 12;
        }

        // Determine predicted age based on structure type
        let predicted_age;
        
        switch (structure_type) {
          case 'concrete':
            predicted_age = '50-60';
            break;
          case 'cement-bricks':
            predicted_age = '75-100';
            break;
          case 'wooden':
            predicted_age = '100-150';
            break;
          case 'stone':
            predicted_age = '150-200';
            break;
          default:
            result.error = 'Invalid structure type';
            return result;
        }

        // Prepare result
        result.tech_predicted_age = predicted_age;
        result.tech_years = years;
        result.tech_months = months;
        result.tech_days = days;

        return result;

      } catch (error) {
        console.error('Error in house age calculator:', error);
        result.error = 'Please! Check Your Input';
        return result;
      }
    }


     /**
    * getCalculationBirthdayCalculator: Service Method
    * POST: /api/calculators-lol/birthday-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */
  async getCalculationBirthdayCalculator(body) {
      let next_birth = body.tech_next_birth;

      const result = {};

      if (!next_birth) {
        result.error = 'Please Select Your Date of Birth.';
        return result;
      }

      try {
        const dob = next_birth; // yyyy-mm-dd format expected
        const currentDate = new Date();
        
        // Parse DOB
        const dob2 = dob.split("-");
        const birth_month = dob2[1];
        
        // Create date objects for age calculation
        const bdayDate = new Date(dob2[0], dob2[1] - 1, dob2[2]);
        const today = new Date();
        
        // Check if DOB is valid (not in future)
        if (bdayDate >= today) {
          result.error = 'Invalid Date of Birth.';
          return result;
        }
        
        // Calculate age (years, months, days)
        let age_years = today.getFullYear() - bdayDate.getFullYear();
        let age_months = today.getMonth() - bdayDate.getMonth();
        let age_days = today.getDate() - bdayDate.getDate();
        
        if (age_days < 0) {
          age_months--;
          const prevMonth = new Date(today.getFullYear(), today.getMonth(), 0);
          age_days += prevMonth.getDate();
        }
        
        if (age_months < 0) {
          age_years--;
          age_months += 12;
        }
        
        // Current date details
        const year = currentDate.getFullYear();
        const mon = currentDate.getMonth() + 1;
        const mday = currentDate.getDate();
        const hour = currentDate.getHours();
        const min = currentDate.getMinutes();
        const sec = currentDate.getSeconds();
        
        // Calculate timestamps
        const d1 = new Date(dob2[0], dob2[1] - 1, dob2[2], hour, min, sec).getTime() / 1000;
        const d2 = new Date(year, mon - 1, mday, hour, min, sec).getTime() / 1000;
        const diffSeconds = d2 - d1;
        
        if (diffSeconds <= 0) {
          result.error = 'Invalid Date of Birth.';
          return result;
        }
        
        // Calculate totals
        const Totalyears = Math.floor(diffSeconds / 31536000);
        const Total_months = Math.floor(diffSeconds / 2628000);
        const Total_weeks = Math.floor(diffSeconds / 604800);
        const Total_days = Math.floor(diffSeconds / 86400);
        const Total_hours = Math.floor(diffSeconds / 3600);
        const Total_minuts = Math.floor(diffSeconds / 60);
        const Total_seconds = diffSeconds;
        
        // Calculate which day of week birthdays fell on
        const totalDays = [0, 0, 0, 0, 0, 0, 0];
        const daysName = [];
        
        for (let i = 0; i < age_years; i++) {
          const birthdayThisYear = new Date(bdayDate);
          birthdayThisYear.setFullYear(bdayDate.getFullYear() + i);
          const dayOfWeek = birthdayThisYear.getDay();
          const dayName = birthdayThisYear.toLocaleDateString('en-US', { weekday: 'long' });
          totalDays[dayOfWeek]++;
          daysName.push(dayName);
        }
        
        // Calculate next birthday
        let nextBirthdayYear = year;
        if (mon > parseInt(dob2[1]) || (mon === parseInt(dob2[1]) && mday >= parseInt(dob2[2]))) {
          nextBirthdayYear = year + 1;
        }
        
        const nextBirthdayDate = new Date(nextBirthdayYear, dob2[1] - 1, dob2[2]);
        const todayDate = new Date(year, mon - 1, mday);
        
        // Calculate days until next birthday
        const timeDiff = nextBirthdayDate - todayDate;
        const remDays = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
        
        // Calculate months and days until next birthday
        let next_r_mon = nextBirthdayDate.getMonth() - todayDate.getMonth();
        let next_r_day = nextBirthdayDate.getDate() - todayDate.getDate();
        
        if (next_r_day < 0) {
          next_r_mon--;
          const prevMonth = new Date(nextBirthdayDate.getFullYear(), nextBirthdayDate.getMonth(), 0);
          next_r_day += prevMonth.getDate();
        }
        
        if (next_r_mon < 0) {
          next_r_mon += 12;
        }
        
        // Format next birthday
        const nextBirth = nextBirthdayDate.toLocaleDateString('en-US', { 
          weekday: 'long', 
          year: 'numeric', 
          month: 'long', 
          day: 'numeric' 
        });
        
        const n_brdy_days_per = (remDays / 365) * 100;
        
        // Calculate half birthday (6 months after DOB)
        const halfBirthdayDate = new Date(bdayDate);
        halfBirthdayDate.setMonth(halfBirthdayDate.getMonth() + 6);
        
        let halfBirthdayYear = year;
        const halfMonth = halfBirthdayDate.getMonth() + 1;
        const halfDay = halfBirthdayDate.getDate();
        
        if (mon > halfMonth || (mon === halfMonth && mday >= halfDay)) {
          halfBirthdayYear = year + 1;
        }
        
        const nextHalfBirthdayDate = new Date(halfBirthdayYear, halfMonth - 1, halfDay);
        const half_brdy = nextHalfBirthdayDate.toLocaleDateString('en-US', { 
          weekday: 'long', 
          year: 'numeric', 
          month: 'long', 
          day: 'numeric' 
        });
        
        const halfTimeDiff = nextHalfBirthdayDate - todayDate;
        const next_half_r_days = Math.floor(halfTimeDiff / (1000 * 60 * 60 * 24));
        const n_half_brdy_days = Math.round((next_half_r_days / 365) * 100);
        
        // Prepare result
        result.tech_Age = age_years;
        result.tech_Age_months = age_months;
        result.tech_Age_days = age_days;
        result.tech_birth_month = birth_month;
        result.tech_N_r_months = next_r_mon;
        result.tech_N_r_days = next_r_day;
        result.tech_Years = Totalyears;
        result.tech_Months = Total_months;
        result.tech_Weeks = Total_weeks;
        result.tech_Days = Total_days;
        result.tech_Hours = Total_hours;
        result.tech_Min = Total_minuts;
        result.tech_nextBirth = nextBirth;
        result.tech_remDays = remDays;
        result.tech_totalDays = totalDays;
        result.tech_daysName = daysName;
        result.tech_n_brdy_days_per = parseFloat(n_brdy_days_per.toFixed(2));
        result.tech_half_brdy = half_brdy;
        result.tech_next_half_r_days = next_half_r_days;
        result.tech_n_half_brdy_days = n_half_brdy_days;
        
        return result;
        
      } catch (error) {
        console.error('Error in birthday calculator:', error);
        result.error = 'Please Select Your Date of Birth.';
        return result;
      }
    }

     /**
    * getCalculationHalfBirthdayCalculator: Service Method
    * POST: /api/calculators-lol/half-birthday-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */
  async getCalculationHalfBirthdayCalculator(body) {
      let day = body.tech_day;
      let month = body.tech_month;
      let year = body.tech_year;

    const result = {};

    // Validate and format DOB
    if (!day || !month || !year) {
      result.error = 'Please! Check Your Input';
      return result;
    }

    try {
      // Format DOB as YYYY-MM-DD
      const dob = `${String(year).padStart(4, '0')}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
      const dobDate = new Date(year, month - 1, day);
      const currentDate = new Date();
      
      // Check if DOB is valid (not in future)
      if (dobDate > currentDate) {
        result.error = 'Please! Check Your Input';
        return result;
      }

      // Current date details
      const current = {
        year: currentDate.getFullYear(),
        mon: currentDate.getMonth() + 1,
        mday: currentDate.getDate()
      };

      // Calculate quarter and half birthdays
      const dobDateObj = new Date(dob);
      
      // First quarter (3 months)
      const first_q_date = new Date(dobDateObj);
      first_q_date.setMonth(first_q_date.getMonth() + 3);
      const Q1 = [
        first_q_date.getFullYear(),
        first_q_date.getMonth() + 1,
        first_q_date.getDate()
      ];

      // Half birthday (6 months)
      const half_date = new Date(dobDateObj);
      half_date.setMonth(half_date.getMonth() + 6);
      const Q2 = [
        half_date.getFullYear(),
        half_date.getMonth() + 1,
        half_date.getDate()
      ];

      // Third quarter (9 months)
      const third_q_date = new Date(dobDateObj);
      third_q_date.setMonth(third_q_date.getMonth() + 9);
      const Q3 = [
        third_q_date.getFullYear(),
        third_q_date.getMonth() + 1,
        third_q_date.getDate()
      ];

      // Birthday
      const bday = [year, month, day];

      // Determine next occurrence years for each date
      let year_q1, mon_q1, day_q1;
      if (Q1[1] > current.mon || (Q1[1] === current.mon && Q1[2] > current.mday)) {
        year_q1 = current.year;
        mon_q1 = Q1[1];
        day_q1 = Q1[2];
      } else {
        year_q1 = current.year + 1;
        mon_q1 = Q1[1];
        day_q1 = Q1[2];
      }

      let year_q2, mon_q2, day_q2;
      if (Q2[1] > current.mon || (Q2[1] === current.mon && Q2[2] > current.mday)) {
        year_q2 = current.year;
        mon_q2 = Q2[1];
        day_q2 = Q2[2];
      } else {
        year_q2 = current.year + 1;
        mon_q2 = Q2[1];
        day_q2 = Q2[2];
      }

      let year_q3, mon_q3, day_q3;
      if (Q3[1] > current.mon || (Q3[1] === current.mon && Q3[2] > current.mday)) {
        year_q3 = current.year;
        mon_q3 = Q3[1];
        day_q3 = Q3[2];
      } else {
        year_q3 = current.year + 1;
        mon_q3 = Q3[1];
        day_q3 = Q3[2];
      }

      let bd_year, bd_mon, bd_day;
      if (bday[1] > current.mon || (bday[1] === current.mon && bday[2] > current.mday)) {
        bd_year = current.year;
        bd_mon = bday[1];
        bd_day = bday[2];
      } else {
        bd_year = current.year + 1;
        bd_mon = bday[1];
        bd_day = bday[2];
      }

      // Format dates
      const formatDate = (year, month, day) => {
        const date = new Date(year, month - 1, day);
        return date.toLocaleDateString('en-US', { 
          weekday: 'long', 
          year: 'numeric', 
          month: 'long', 
          day: 'numeric' 
        });
      };

      const next_bday = formatDate(bd_year, bd_mon, bd_day);
      const next_half = formatDate(year_q2, mon_q2, day_q2);
      const first_Q = formatDate(year_q1, mon_q1, day_q1);
      const third_Q = formatDate(year_q3, mon_q3, day_q3);

      // Calculate days until each date
      const today = new Date(current.year, current.mon - 1, current.mday);
      
      const nextHalfDate = new Date(year_q2, mon_q2 - 1, day_q2);
      const q1Date = new Date(year_q1, mon_q1 - 1, day_q1);
      const q3Date = new Date(year_q3, mon_q3 - 1, day_q3);

      const next_half_days = Math.floor((nextHalfDate - today) / (1000 * 60 * 60 * 24));
      const first_Q_days = Math.floor((q1Date - today) / (1000 * 60 * 60 * 24));
      const third_Q_days = Math.floor((q3Date - today) / (1000 * 60 * 60 * 24));

      const day_per = (next_half_days * 100) / 365;

      // Prepare result
      result.tech_next_half = next_half;
      result.tech_day_per = parseFloat(day_per.toFixed(2));
      result.tech_next_half_days = next_half_days;
      result.tech_first_Q = first_Q;
      result.tech_first_Q_days = first_Q_days;
      result.tech_third_Q = third_Q;
      result.tech_third_Q_days = third_Q_days;
      result.tech_next_bday = next_bday;

      return result;

    } catch (error) {
      console.error('Error in half birthday calculator:', error);
      result.error = 'Please! Check Your Input';
      return result;
    }
  }

    /**
    * getCalculationTravelTimeCalculator: Service Method
    * POST: /api/calculators-lol/travel-time-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */
  async getCalculationTravelTimeCalculator(body) {
     let distance = body.tech_distance;
    let distance_unit = body.tech_distance_unit;
    let speed = body.tech_speed;
    let speed_unit = body.tech_speed_unit;
    let break_hrs = body.tech_break_hrs;
    let break_min = body.tech_break_min;
    let dep_time = body.tech_dep_time;
    let fule_effi = body.tech_fule_effi;
    let fule_effi_unit = body.tech_fule_effi_unit;
    let price = body.tech_price;
    let price_unit = body.tech_price_unit;
    let currancy = body.tech_currancy;
    let passenger = body.tech_passenger;


      const result = {};

      // Helper function: Convert distance to km
      function convert_to_km(unit, value) {
        if (unit == 'mi') {
          return value * 1.609;
        } else {
          console.log(value);
          return value;
        }
      }
      // Helper function: Convert fuel efficiency to km/l
      function convert_to_kmpl(unit, value) {
        if (unit == 'mpg') {
          return value / 2.352;
        } else {
          return value;
        }
      }

      // Validate inputs
      if (
        !distance || !speed || break_hrs === undefined || break_min === undefined ||
        !fule_effi || !price || !passenger || !dep_time
      ) {
        result.error = 'Please! Check Your Input';
        return result;
      }

      // Check if all numeric values are valid
      if (
        isNaN(parseFloat(distance)) ||
        isNaN(parseFloat(speed)) ||
        isNaN(parseFloat(break_hrs)) ||
        isNaN(parseFloat(break_min)) ||
        isNaN(parseFloat(fule_effi)) ||
        isNaN(parseFloat(price)) ||
        isNaN(parseFloat(passenger))
      ) {
        result.error = 'Please! Check Your Input';
        return result;
      }

      try {
        // Remove currency symbol from price_unit
        let price_unit_clean = price_unit ? price_unit.replace(currancy || '', '').trim() : 'liter';

        // Convert values
        const distance_f = convert_to_km(distance_unit, parseFloat(distance));
        const fule_effi_f = convert_to_kmpl(fule_effi_unit, parseFloat(fule_effi));
        const speed_f = convert_to_km(speed_unit, parseFloat(speed));
          // console.log(distance_f,fule_effi_f,speed_f);
        // Convert price to per liter if it's per gallon
        const price_f = (price_unit_clean.includes('liter') || price_unit_clean.includes('litre')) 
          ? parseFloat(price) 
          : parseFloat(price) / 3.785;

        // Calculate break time in hours
        const break_hr = ((parseFloat(break_hrs) * 60) + parseFloat(break_min)) / 60;

        // Calculate travel time
        const travel_time = (distance_f / speed_f) + break_hr;
        const hours = Math.floor(travel_time);
        const mins = Math.round((travel_time - hours) * 60);

        // Parse departure time
        const depTime = new Date(dep_time);
        
        // Add hours and minutes to departure time
        const arrivalTime = new Date(depTime);
        arrivalTime.setHours(arrivalTime.getHours() + hours);
        arrivalTime.setMinutes(arrivalTime.getMinutes() + mins);

        // Format dates
        const formatDate = (date) => {
          const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                            'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
          const month = monthNames[date.getMonth()];
          const day = String(date.getDate()).padStart(2, '0');
          const year = date.getFullYear();
          
          let hours = date.getHours();
          const minutes = String(date.getMinutes()).padStart(2, '0');
          const seconds = String(date.getSeconds()).padStart(2, '0');
          const ampm = hours >= 12 ? 'PM' : 'AM';
          hours = hours % 12;
          hours = hours ? hours : 12; // 0 should be 12
          const hoursStr = String(hours).padStart(2, '0');
          
          return `${month} ${day}, ${year} ${hoursStr}:${minutes}:${seconds} ${ampm}`;
        };

        const depature = formatDate(depTime);
        const arrival = formatDate(arrivalTime);

        // Calculate fuel requirements
        const fule_req = distance_f / fule_effi_f;
        const fule_price = fule_req * price_f;
        const per_person = fule_price / parseFloat(passenger);
        // console.log(fule_price,fule_req,price_f);
        // Format numbers
        const formatNumber = (num, decimals = 2) => {
          return num.toFixed(decimals).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        };

        // Prepare result
        result.tech_hours = hours;
        result.tech_mins = mins;
        result.tech_depature = depature;
        result.tech_arrival = arrival;
        result.tech_fule_price = formatNumber(fule_price, 2);
        result.tech_per_person = formatNumber(per_person, 2);
        return result;

      } catch (error) {
        console.error('Error in travel time calculator:', error);
        result.error = 'Please! Check Your Input';
        return result;
      }
    }

     /**
    * getCalculationSleepCalculator: Service Method
    * POST: /api/calculators-lol/sleep-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */


    async getCalculationSleepCalculator(body) {
      let h = body.tech_h;
      let stype = body.tech_stype;

        const result = {};

        if (stype == 'bedtime') {
            // Bedtime calculation
            // Current date ke sath time combine karo
            const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
            const dateTimeString = `${today} ${h}`;
            
            const baseDate = new Date(dateTimeString);
            const timestamp = Math.floor(baseDate.getTime() / 1000) + ((14 * 60) + 45) * 60;
            const timestamp2 = timestamp + 90 * 60;
            const timestamp3 = timestamp2 + 90 * 60;
            const timestamp4 = timestamp3 + 90 * 60;
            const timestamp5 = timestamp4 + 90 * 60;
            const timestamp6 = timestamp5 + 90 * 60;

            result.tech_time = this.formatTimesleep(timestamp);
            result.tech_time2 = this.formatTimesleep(timestamp2);
            result.tech_time3 = this.formatTimesleep(timestamp3);
            result.tech_time4 = this.formatTimesleep(timestamp4);
            result.tech_time5 = this.formatTimesleep(timestamp5);
            result.tech_time6 = this.formatTimesleep(timestamp6);

        } else if (stype == 'wkup') {
            // Wake up calculation - current time se calculate karo
            const now = new Date();
            const currentTimestamp = Math.floor(now.getTime() / 1000);
            const timestamp = currentTimestamp + (465 + 90) * 60;
            const timestamp2 = timestamp - 90 * 60;
            const timestamp3 = timestamp2 - 90 * 60;
            const timestamp4 = timestamp3 - 90 * 60;
            const timestamp5 = timestamp4 - 90 * 60;
            const timestamp6 = timestamp5 - 90 * 60;

            result.tech_time = this.formatTimesleep(timestamp);
            result.tech_time2 = this.formatTimesleep(timestamp2);
            result.tech_time3 = this.formatTimesleep(timestamp3);
            result.tech_time4 = this.formatTimesleep(timestamp4);
            result.tech_time5 = this.formatTimesleep(timestamp5);
            result.tech_time6 = this.formatTimesleep(timestamp6);

        } else {
            result.error = 'Please! Check Your Inputs';
            return result;
        }

        result.tech_stype = stype;
        return result;
    }

    formatTimesleep(timestamp) {
        const date = new Date(timestamp * 1000);
        
        let hours = date.getUTCHours() + 5; // Pakistan Standard Time (UTC+5)
        const minutes = date.getUTCMinutes();
        const seconds = date.getUTCSeconds();
        
        // Handle day overflow
        if (hours >= 24) {
            hours -= 24;
        }
        
        const period = hours >= 12 ? 'pm' : 'am';
        const displayHours = hours % 12 || 12; // Convert to 12-hour format
        
        const pad = (num) => String(num).padStart(2, '0');
        
        return `${pad(displayHours)}:${pad(minutes)}:${pad(seconds)}${period}`;
    }

     /**
    * getCalculationPantSizeCalculator: Service Method
    * POST: /api/calculators-lol/pant-size-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */


    async getCalculationPantSizeCalculator(body) {
      let submit = body.tech_submit;
      let weist = body.tech_weist;
      let length = body.tech_length;
      let gender = body.tech_gender;
      let measure = body.tech_measure;
      let measure_in_weiat = body.tech_measure_in_weiat;
      let measure_in_length = body.tech_measure_in_length;

      const result = {};

      // Measure conversion
      let measureInWeist = measure_in_weiat;
      let measureInLength = measure_in_length;

      if (measure_in_weiat == 'cm') {
          measureInWeist = 'centimeter_weist';
      } else if (measure_in_weiat == 'dm') {
          measureInWeist = 'decimeter_weist';
      } else if (measure_in_weiat == 'in') {
          measureInWeist = 'inches_weist';
      }

      if (measure_in_length == 'cm') {
          measureInLength = 'centimeter_length';
      } else if (measure_in_length == 'dm') {
          measureInLength = 'decimeter_length';
      } else if (measure_in_length == 'in') {
          measureInLength = 'inches_length';
      }

      if (!submit) {
          result.error = 'Please! Check Your Input';
          return result;
      }

      // Women's table values
      const waist_women = [25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39];
      const length_women = [32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32];
      const inda_women = [26, 26, 28, 28, 30, 30, 32, 32, 34, 34, 36, 36, 38, 38, 40];
      const usa_women = [
          '25/32, 0, or XXS',
          '26/32, 2, or XS',
          '27/32, 4, or XS',
          '28/32, 6, or S',
          '29/32, 8, or S',
          '30/32, 10, or M',
          '31/32, 12, or M',
          '32/32, 14, or L',
          '33/32, 16, or L',
          '34/32, 18, or XL',
          '35/32, 20, or XL',
          '36/32, 22, or XXL',
          '37/32, 24, or XXL',
          '38/32, 26, or XXXL',
          '39/32, 28, or XXXL'
      ];
      const uk_women = [4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32];
      const eu_women = [32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60];
      const it_women = [36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64];
      const ru_women = [38, '38/40', 40, '42/44', 46, 48, 50, 54, 58, '60/62', 64, '66/68', 70, 'Not Available', 'Not Available'];
      const ja_women = [7, '7/9', 9, '9/11', 11, '11/13', 13, '13/15', '13/15', 15, '15/17', 17, 'Not Available', 'Not Available', 'Not Available'];

      // Men's table values
      const waist_men = [28, 29, 30, 32, 33, 34, 36, 38, 40, 42, 44];
      const length_men = [30, 30, 32, 32, 32, 32, 34, 34, 34, 34, 34];
      const inda_men = [28, 30, 30, 32, 34, 34, 36, 38, 40, 42, 44];
      const usa_men = [
          '28/30, 30, or XS',
          '29/30, 32, or XS',
          '30/32, 34, or S',
          '32/32, 36, or S',
          '33/32, 38, or M',
          '34/32, 40, or M',
          '36/34, 42, or L',
          '38/34, 44, or L',
          '40/34, 46, or XL',
          '42/34, 48, or XL',
          '44/34, 50, or XXL'
      ];
      const uk_men = [30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50];
      const eu_men = [40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60];
      const it_men = [30, 32, 34, 46, 48, 50, 52, 54, 56, 58, 60];

      if (!weist || !length) {
          result.error = 'Please! Check Your Input';
          return result;
      }

      let waistValue = parseFloat(weist);
      let lengthValue = parseFloat(length);

      if (measure === 'pair') {
          waistValue = waistValue * 2;
      }

      let result_weist = "";
      let result_length = "";
      let result_india = "";
      let result_us = "";
      let result_uk = "";
      let result_eu = "";
      let result_it = "";
      let result_ru = "";
      let result_ja = "";
      let check_length = false;
      let check_weist = false;

      // Women Portion
      if (gender == 'female') {
          // Measure check waist
          if (measureInWeist == "centimeter_weist") {
              for (let i = 0; i < waist_women.length; i++) {
                  waist_women[i] = waist_women[i] * 2.54;
              }
              if (waistValue < 7.5) {
                  result.error = 'Waist should be greater then 7.5';
                  return result;
              } else {
                  check_weist = true;
              }
          } else if (measureInWeist == "decimeter_weist") {
              for (let i = 0; i < waist_women.length; i++) {
                  waist_women[i] = waist_women[i] * 0.254;
              }
              if (waistValue < 7.5) {
                  result.error = 'Waist should be greater then 7.5';
                  return result;
              } else {
                  check_weist = true;
              }
          } else if (measureInWeist == "inches_weist") {
              if (waistValue < 15) {
                  result.error = 'Waist should be greater then 15';
                  return result;
              } else {
                  check_weist = true;
              }
          }

          // Measure check length
          if (measureInLength == "centimeter_length") {
              for (let i = 0; i < length_women.length; i++) {
                  length_women[i] = length_women[i] * 2.54;
              }
              if (lengthValue < 7.5) {
                  result.error = 'Length should be greater then 7.5';
                  return result;
              } else {
                  check_length = true;
              }
          } else if (measureInLength === "decimeter_length") {
              for (let i = 0; i < length_women.length; i++) {
                  length_women[i] = length_women[i] * 0.254;
              }
              if (lengthValue < 7.5) {
                  result.error = 'Length should be greater then 7.5';
                  return result;
              } else {
                  check_length = true;
              }
          } else if (measureInLength == "inches_length") {
              if (lengthValue < 15) {
                  result.error = 'Length should be greater then 15';
                  return result;
              } else {
                  check_length = true;
              }
          }

          if (check_weist && check_length) {
              for (let i = 0; i < waist_women.length; i++) {
                  if (waistValue === waist_women[i] && lengthValue === length_women[i]) {
                      result_weist = i;
                      result_length = i;
                      break;
                  } else if (waistValue < waist_women[i] && lengthValue < length_women[i]) {
                      result_weist = i;
                      result_length = i;
                      break;
                  } else if (waistValue > waist_women[i]) {
                      if (lengthValue > length_women[i]) {
                          result_weist = "";
                          result_length = "";
                      } else if (lengthValue < length_women[i]) {
                          result_weist = "";
                          result_length = "";
                      }
                  } else {
                      if (lengthValue === length_women[i]) {
                          result_weist = i;
                          result_length = i;
                          break;
                      }
                      if (lengthValue < length_women[i]) {
                          result_weist = i;
                          result_length = i;
                          break;
                      } else {
                          result_weist = "";
                          result_length = "";
                          break;
                      }
                  }
              }

              if (typeof result_weist == 'number' && typeof result_length == 'number') {
                  result_india = inda_women[result_weist];
                  result_us = usa_women[result_weist];
                  result_uk = uk_women[result_weist];
                  result_eu = eu_women[result_weist];
                  result_it = it_women[result_weist];
                  result_ru = ru_women[result_weist];
                  result_ja = ja_women[result_weist];
              } else {
                  result.error = 'Please Enter Correct Values!';
                  return result;
              }
          } else {
              result.error = 'Please Enter Correct Values!';
              return result;
          }

          result.tech_result_india = result_india;
          result.tech_result_us = result_us;
          result.tech_result_uk = result_uk;
          result.tech_result_eu = result_eu;
          result.tech_result_it = result_it;
          result.tech_result_ru = result_ru;
          result.tech_result_ja = result_ja;
          return result;

      } else if (gender === 'male') {
          // Measure check waist
          if (measureInWeist == "centimeter_weist") {
              for (let i = 0; i < waist_men.length; i++) {
                  waist_men[i] = waist_men[i] * 2.54;
              }
              if (waistValue < 7.5) {
                  result.error = 'Waist should be greater then 7.5';
                  return result;
              } else {
                  check_weist = true;
              }
          } else if (measureInWeist == "decimeter_weist") {
              for (let i = 0; i < waist_men.length; i++) {
                  waist_men[i] = waist_men[i] * 0.254;
              }
              if (waistValue < 7.5) {
                  result.error = 'Waist should be greater then 7.5';
                  return result;
              } else {
                  check_weist = true;
              }
          } else if (measureInWeist == "inches_weist") {
              if (waistValue < 15) {
                  result.error = 'Waist should be greater then 15';
                  return result;
              } else {
                  check_weist = true;
              }
          }

          // Measure check length
          if (measureInLength == "centimeter_length") {
              for (let i = 0; i < length_men.length; i++) {
                  length_men[i] = length_men[i] * 2.54;
              }
              if (lengthValue < 7.5) {
                  result.error = 'Length should be greater then 7.5';
                  return result;
              } else {
                  check_length = true;
              }
          } else if (measureInLength == "decimeter_length") {
              for (let i = 0; i < length_men.length; i++) {
                  length_men[i] = length_men[i] * 0.254;
              }
              if (lengthValue < 7.5) {
                  result.error = 'Length should be greater then 7.5';
                  return result;
              } else {
                  check_length = true;
              }
          } else if (measureInLength == "inches_length") {
              if (lengthValue < 15) {
                  result.error = 'Length should be greater then 15';
                  return result;
              } else {
                  check_length = true;
              }
          }

          if (check_weist && check_length) {
              for (let i = 0; i < waist_men.length; i++) {
                  if (waistValue == waist_men[i] && lengthValue == length_men[i]) {
                      result_weist = i;
                      result_length = i;
                      break;
                  } else if (waistValue < waist_men[i] && lengthValue < length_men[i]) {
                      result_weist = i;
                      result_length = i;
                      break;
                  } else if (waistValue > waist_men[i]) {
                      if (lengthValue > length_men[i]) {
                          result_weist = "";
                          result_length = "";
                      } else if (lengthValue < length_men[i]) {
                          result_weist = "";
                          result_length = "";
                      }
                  } else {
                      if (lengthValue === length_men[i]) {
                          result_weist = i;
                          result_length = i;
                          break;
                      }
                      if (lengthValue < length_men[i]) {
                          result_weist = i;
                          result_length = i;
                          break;
                      } else {
                          result_weist = "";
                          result_length = "";
                          break;
                      }
                  }
              }

              if (typeof result_weist == 'number' && typeof result_length == 'number') {
                  result_india = inda_men[result_weist];
                  result_us = usa_men[result_weist];
                  result_uk = uk_men[result_weist];
                  result_eu = eu_men[result_weist];
                  result_it = it_men[result_weist];
              } else {
                  result.error = 'Please Enter Correct Values!';
                  return result;
              }
          } else {
              result.error = 'Please Enter Correct Values!';
              return result;
          }

          result.tech_result_india = result_india;
          result.tech_result_us = result_us;
          result.tech_result_uk = result_uk;
          result.tech_result_eu = result_eu;
          result.tech_result_it = result_it;
          result.tech_result_ru = result_ru;
          result.tech_result_ja = result_ja;
          return result;

      } else {
          result.error = 'Please! Check Your Input';
          return result;
      }
  }


    /**
    * getCalculationDriveTimeCalculator: Service Method
    * POST: /api/calculators-lol/drive-time-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationDriveTimeCalculator(body) {
      let distance = body.tech_distance;
      let distance_unit = body.tech_distance_unit;
      let average_speed = body.tech_average_speed;
      let average_speed_unit = body.tech_average_speed_unit;
      let breaks = body.tech_breaks;
      let breaks_unit = body.tech_breaks_unit;
      let departure_time = body.tech_departure_time;
      let fuel_e = body.tech_fuel_e;
      let fuel_e_unit = body.tech_fuel_e_unit;
      let fuel_p = body.tech_fuel_p;
      let currancy = body.tech_currancy;
      let fuel_p_unit = body.tech_fuel_p_unit;
      let passengers = body.tech_passengers;


        const result = {};

        // Remove currency symbol from fuel price
        let fuelPrice = fuel_p;
        if (currancy && typeof fuel_p == 'string') {
            fuelPrice = fuel_p.replace(currancy, '');
        }

        // Validate numeric inputs
        if (
            !this.isNumerictravel(distance) || 
            !this.isNumerictravel(average_speed) || 
            !this.isNumerictravel(passengers) || 
            !this.isNumerictravel(fuelPrice)
        ) {
            result.error = 'Please ! Fill all the Input';
            return result;
        }

        // Convert to numbers
        let distanceValue = parseFloat(distance);
        let averageSpeedValue = parseFloat(average_speed);
        let breaksValue = parseFloat(breaks) || 0;
        let fuelEfficiency = parseFloat(fuel_e) || 0;
        let fuelPriceValue = parseFloat(fuelPrice);
        const passengersValue = parseFloat(passengers);

        // Convert breaks to minutes
        if (breaks_unit) {
            if (breaks_unit == 'sec') {
                breaksValue = breaksValue / 60;
            } else if (breaks_unit == 'hrs') {
                breaksValue = breaksValue * 60;
            } else if (breaks_unit == 'days') {
                breaksValue = breaksValue * 24 * 60;
            } else if (breaks_unit == 'wks') {
                breaksValue = breaksValue * 10080;
            }
        }

        // Convert distance to km
        if (distance_unit) {
            if (distance_unit == 'km') {
                distanceValue = distanceValue;
            } else if (distance_unit == 'm') {
                distanceValue = distanceValue / 1000;
            } else if (distance_unit == 'mi') {
                distanceValue = Math.round(distanceValue * 1.609);
            } else if (distance_unit == 'nmi') {
                distanceValue = distanceValue * 1.852;
            }
        }

        // Convert average speed to km/h
        if (average_speed_unit) {
            if (average_speed_unit == 'km/h') {
                averageSpeedValue = averageSpeedValue;
            } else if (average_speed_unit == 'm/s') {
                averageSpeedValue = averageSpeedValue * 3.6;
            } else if (average_speed_unit == 'mph') {
                averageSpeedValue = averageSpeedValue * 1.609;
            }
        }

        // Convert fuel efficiency to L/100km
        if (fuel_e_unit) {
            if (fuel_e_unit == 'L/100km') {
                fuelEfficiency = fuelEfficiency;
            } else if (fuel_e_unit == 'us mpg') {
                fuelEfficiency = 235.215 / fuelEfficiency;
            } else if (fuel_e_unit == 'uk mpg') {
                fuelEfficiency = 282.5 / fuelEfficiency;
            } else if (fuel_e_unit == 'km/L') {
                fuelEfficiency = 100 / fuelEfficiency;
            }
        }

        // Convert fuel price to per liter
        if (fuel_p_unit) {
            if (fuel_p_unit == '/L') {
                fuelPriceValue = fuelPriceValue;
            } else if (fuel_p_unit == '/us gal') {
                fuelPriceValue = fuelPriceValue * 0.26;
            } else if (fuel_p_unit == '/uk gal') {
                fuelPriceValue = fuelPriceValue * 0.22;
            }
        }

        // Calculate total drive time
        const total_breaks_hours = breaksValue / 60;
        const total_drive_hours = (distanceValue / averageSpeedValue) + total_breaks_hours;

        // Calculate arrival time
        if (departure_time) {
            const departureDate = new Date(departure_time);
            const arrivalTimestamp = departureDate.getTime() + (total_drive_hours * 3600 * 1000);
            const arrivalDate = new Date(arrivalTimestamp);
            
            // Format: "05 November 2025, 02:30 PM"
            const arrival_time = this.formatDateTimeTravel(arrivalDate);
            result.tech_arrival_time = arrival_time;
        }

        // Calculate total drive cost
        const total_drive_cost = (distanceValue / 100) * fuelEfficiency * fuelPriceValue;

        // Calculate drive cost per person
        const drive_cost_per_person = total_drive_cost / passengersValue;

        result.tech_total_drive_hours = total_drive_hours;
        result.tech_total_drive_cost = total_drive_cost;
        result.tech_drive_cost_per_person = drive_cost_per_person;

        return result;
    }

      // Helper function to check if value is numeric
      isNumerictravel(value) {
          if (value == null || value == undefined || value == '') {
              return false;
          }
          return !isNaN(parseFloat(value)) && isFinite(value);
      }

      // Helper function to format date time
      formatDateTimeTravel(date) {
          const months = [
              'January', 'February', 'March', 'April', 'May', 'June',
              'July', 'August', 'September', 'October', 'November', 'December'
          ];
          
          const day = String(date.getDate()).padStart(2, '0');
          const month = months[date.getMonth()];
          const year = date.getFullYear();
          
          let hours = date.getHours();
          const minutes = String(date.getMinutes()).padStart(2, '0');
          const period = hours >= 12 ? 'PM' : 'AM';
          
          hours = hours % 12 || 12; // Convert to 12-hour format
          hours = String(hours).padStart(2, '0');
          
          return `${day} ${month} ${year}, ${hours}:${minutes} ${period}`;
      }

      /**
    * getCalculationAnniversaryCalculator: Service Method
    * POST: /api/calculators-lol/anniversary-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationAnniversaryCalculator(body) {
        let date = body.tech_date;
        let current_date = body.tech_current_date;
        let one = body.tech_one;

        const result = {};

        if (one == 'one' || one == 'two' || one == 'three') {
            if (!date) {
                result.error = 'Please! Enter the date';
                return result;
            }

            // Parse dates
            const marriageStartDate = new Date(date);
            const currentDate = new Date(current_date);
            const today = new Date();
            
            // Calculate next anniversary date
            const currentYear = today.getFullYear();
            const marriageYear = marriageStartDate.getFullYear();
            const yearsElapsed = currentYear - marriageYear;
            
            // Create next anniversary date
            let nextAnniversary = new Date(marriageStartDate);
            nextAnniversary.setFullYear(marriageStartDate.getFullYear() + yearsElapsed);
            
            // Add 365 days to get the actual next anniversary
            nextAnniversary.setDate(nextAnniversary.getDate() + 365);
            
            // Format anniversary date
            const anniversaryDate = this.formatDateMonthDayYearanniversary(nextAnniversary);
            
            // Calculate days until anniversary
            const todayOnly = new Date(today.getFullYear(), today.getMonth(), today.getDate());
            const anniversaryOnly = new Date(nextAnniversary.getFullYear(), nextAnniversary.getMonth(), nextAnniversary.getDate());
            const daysUntilAnniversary = Math.floor((anniversaryOnly - todayOnly) / (1000 * 60 * 60 * 24));
            
            // Calculate marriage age
            const marriageAge = this.calculateDateDifferenceanniversary(marriageStartDate, currentDate);
            
            const yearsMarried = marriageAge.years;
            const monthsMarried = (yearsMarried * 12) + marriageAge.months;
            const daysMarried = marriageAge.days;
            const totalDays = marriageAge.totalDays;
            
            result.tech_anniversaryDate = anniversaryDate;
            result.tech_daysUntilAnniversary = daysUntilAnniversary;
            result.tech_yearsMarried = yearsMarried;
            result.tech_monthsMarried = monthsMarried;
            result.tech_daysMarried = daysMarried;
            result.tech_marriage_age_weeks = Math.ceil(totalDays / 7);
            result.tech_marriage_age_days = totalDays;
            
            return result;
        } else {
            result.error = 'Please! Enter the date';
            return result;
        }
    }

    // Helper function to format date as "MMM DD, YYYY" (e.g., "Nov 05, 2025")
    formatDateMonthDayYearanniversary(date) {
        const months = [
            'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
            'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
        ];
        
        const month = months[date.getMonth()];
        const day = String(date.getDate()).padStart(2, '0');
        const year = date.getFullYear();
        
        return `${month} ${day}, ${year}`;
    }

    // Helper function to calculate difference between two dates (like Carbon diff)
    calculateDateDifferenceanniversary(startDate, endDate) {
        let years = endDate.getFullYear() - startDate.getFullYear();
        let months = endDate.getMonth() - startDate.getMonth();
        let days = endDate.getDate() - startDate.getDate();
        
        // Adjust for negative days
        if (days < 0) {
            months--;
            const previousMonth = new Date(endDate.getFullYear(), endDate.getMonth(), 0);
            days += previousMonth.getDate();
        }
        
        // Adjust for negative months
        if (months < 0) {
            years--;
            months += 12;
        }
        
        // Calculate total days
        const totalDays = Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24));
        
        return {
            years: years,
            months: months,
            days: days,
            totalDays: totalDays
        };
    }

     /**
    * getCalculationPointBuyCalculator: Service Method
    * POST: /api/calculators-lol/point-buy-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationPointBuyCalculator(body) {
      let racial_choice = body.tech_racial_choice;
      let strength = body.tech_strength;
      let dexerity = body.tech_dexerity;
      let intelligence = body.tech_intelligence;
      let wisdom = body.tech_wisdom;
      let charisma = body.tech_charisma;
      let constitution = body.tech_constitution;
      let choice = body.tech_choice;
      let strength1 = body.tech_strength1;
      let dexerity1 = body.tech_dexerity1;
      let intelligence1 = body.tech_intelligence1;
      let wisdom1 = body.tech_wisdom1;
      let charisma1 = body.tech_charisma1;
      let constitution1 = body.tech_constitution1;
      let points_budget = body.tech_points_budget;
      let smallest_score = body.tech_smallest_score;
      let largest_score = body.tech_largest_score;
      let s1 = body.tech_s1;
      let s2 = body.tech_s2;
      let s3 = body.tech_s3;
      let s4 = body.tech_s4;
      let s5 = body.tech_s5;
      let s6 = body.tech_s6;
      let s7 = body.tech_s7;
      let s8 = body.tech_s8;
      let s9 = body.tech_s9;
      let s10 = body.tech_s10;
      let s11 = body.tech_s11;
      let x1 = body.tech_s12;
      let x2 = body.tech_s13;
      let x3 = body.tech_s14;
      let x4 = body.tech_s15;
      let x5 = body.tech_s16;

    const result = {};

    // Helper function: calculate_sum (for choice 1)
    const calculateSum = (val1) => {
        const scoreMap = {
            '8': 0,
            '9': 1,
            '10': 2,
            '11': 3,
            '12': 4,
            '13': 5,
            '14': 7,
            '15': 9
        };
        return scoreMap[String(val1)] || 0;
    };

    // Helper function: calculate_sum2 (for choice 2)
    const calculateSum2 = (val2, val3, val4, val5, val6, val7, val8, val9, val10, val11, val12, val13, val14, val15, val16, val17) => {
        const scoreMap = {
            '3': val13,
            '4': val14,
            '5': val15,
            '6': val16,
            '7': val17,
            '8': val3,
            '9': val4,
            '10': val5,
            '11': val6,
            '12': val7,
            '13': val8,
            '14': val9,
            '15': val10,
            '16': val11,
            '17': val12,
            '18': val13
        };
        return scoreMap[String(val2)] || 0;
    };

    // Helper function: calculate_sum2 for 8 parameters (simplified version)
    const calculateSum2Simple = (val2, val3, val4, val5, val6, val7, val8, val9, val10) => {
        const scoreMap = {
            '8': val3,
            '9': val4,
            '10': val5,
            '11': val6,
            '12': val7,
            '13': val8,
            '14': val9,
            '15': val10
        };
        return scoreMap[String(val2)] || 0;
    };

    // Choice 1: Standard Point Buy
    if (choice == "1") {
        // Racial choice 39 (custom)
        if (racial_choice == "39") {
            if (
                !this.isNumericdnd(strength) || !this.isNumericdnd(dexerity) ||
                !this.isNumericdnd(intelligence) || !this.isNumericdnd(wisdom) ||
                !this.isNumericdnd(charisma) || !this.isNumericdnd(constitution) ||
                !this.isNumericdnd(strength1) || !this.isNumericdnd(dexerity1) ||
                !this.isNumericdnd(intelligence1) || !this.isNumericdnd(wisdom1) ||
                !this.isNumericdnd(charisma1) || !this.isNumericdnd(constitution1)
            ) {
                result.error = 'Please! Check Your Input';
                return result;
            }

            const str = parseFloat(strength);
            const dex = parseFloat(dexerity);
            const int = parseFloat(intelligence);
            const wis = parseFloat(wisdom);
            const cha = parseFloat(charisma);
            const con = parseFloat(constitution);

            if (
                (str >= 3 && str <= 15) && (dex >= 3 && dex <= 15) &&
                (int >= 3 && int <= 15) && (wis >= 3 && wis <= 15) &&
                (cha >= 3 && cha <= 15) && (con >= 3 && con <= 15)
            ) {
                const strength_value = calculateSum(str);
                const dexerity_value = calculateSum(dex);
                const intelligence_value = calculateSum(int);
                const wisdom_value = calculateSum(wis);
                const charisma_value = calculateSum(cha);
                const constitution_value = calculateSum(con);

                const sum = strength_value + dexerity_value + intelligence_value + 
                          wisdom_value + charisma_value + constitution_value;
                const total_sum = sum - 27;

                if (sum > 27) {
                    result.error = `You are ${total_sum} points over budget`;
                    return result;
                }

                result.tech_strength = str;
                result.tech_dexerity = dex;
                result.tech_constitution = con;
                result.tech_intelligence = int;
                result.tech_wisdom = wis;
                result.tech_charisma = cha;
                result.tech_strength_racial_bonus = parseFloat(strength1);
                result.tech_charisma_racial_bonus = parseFloat(charisma1);
                result.tech_dexerity_racial_bonus = parseFloat(dexerity1);
                result.tech_constitution_racial_bonus = parseFloat(constitution1);
                result.tech_intelligence_racial_bonus = parseFloat(intelligence1);
                result.tech_wisdom_racial_bonus = parseFloat(wisdom1);
                result.tech_strength_value = strength_value;
                result.tech_dexerity_value = dexerity_value;
                result.tech_intelligence_value = intelligence_value;
                result.tech_wisdom_value = wisdom_value;
                result.tech_charisma_value = charisma_value;
                result.tech_constitution_value = constitution_value;
                return result;
            }
        } else {
            // Other racial choices
            if (
                !this.isNumericdnd(strength) || !this.isNumericdnd(dexerity) ||
                !this.isNumericdnd(intelligence) || !this.isNumericdnd(wisdom) ||
                !this.isNumericdnd(charisma) || !this.isNumericdnd(constitution)
            ) {
                result.error = 'Please! Check Your Input';
                return result;
            }

            const str = parseFloat(strength);
            const dex = parseFloat(dexerity);
            const int = parseFloat(intelligence);
            const wis = parseFloat(wisdom);
            const cha = parseFloat(charisma);
            const con = parseFloat(constitution);

            if (
                (str >= 3 && str <= 15) && (dex >= 3 && dex <= 15) &&
                (int >= 3 && int <= 15) && (wis >= 3 && wis <= 15) &&
                (cha >= 3 && cha <= 15) && (con >= 3 && con <= 15)
            ) {
                const strength_value = calculateSum(str);
                const dexerity_value = calculateSum(dex);
                const intelligence_value = calculateSum(int);
                const wisdom_value = calculateSum(wis);
                const charisma_value = calculateSum(cha);
                const constitution_value = calculateSum(con);

                const devillers = racial_choice.split('.');
                const strength_racial_bonus = devillers[0];
                const dexerity_racial_bonus = devillers[1];
                const constitution_racial_bonus = devillers[2];
                const intelligence_racial_bonus = devillers[3];
                const wisdom_racial_bonus = devillers[4];
                const charisma_racial_bonus = devillers[5];

                const sum = strength_value + dexerity_value + intelligence_value + 
                          wisdom_value + charisma_value + constitution_value;
                const total_sum = sum - 27;

                if (sum > 27) {
                    result.error = `You are ${total_sum} points over budget`;
                    return result;
                }

                result.tech_strength = str;
                result.tech_dexerity = dex;
                result.tech_constitution = con;
                result.tech_intelligence = int;
                result.tech_wisdom = wis;
                result.tech_charisma = cha;
                result.tech_strength_racial_bonus = strength_racial_bonus;
                result.tech_charisma_racial_bonus = charisma_racial_bonus;
                result.tech_dexerity_racial_bonus = dexerity_racial_bonus;
                result.tech_constitution_racial_bonus = constitution_racial_bonus;
                result.tech_intelligence_racial_bonus = intelligence_racial_bonus;
                result.tech_wisdom_racial_bonus = wisdom_racial_bonus;
                result.tech_strength_value = strength_value;
                result.tech_dexerity_value = dexerity_value;
                result.tech_intelligence_value = intelligence_value;
                result.tech_wisdom_value = wisdom_value;
                result.tech_charisma_value = charisma_value;
                result.tech_constitution_value = constitution_value;
                return result;
            } else {
                result.error = 'The score cannot be smaller than 3 and cannot larger than 18';
                return result;
            }
        }
    }
    // Choice 2: Custom Point Buy
    else if (choice == "2") {
        // Racial choice 39 (custom)
        if (racial_choice == "39") {
            if (
                !this.isNumericdnd(strength) || !this.isNumericdnd(dexerity) ||
                !this.isNumericdnd(intelligence) || !this.isNumericdnd(wisdom) ||
                !this.isNumericdnd(charisma) || !this.isNumericdnd(constitution) ||
                !this.isNumericdnd(smallest_score) || !this.isNumericdnd(largest_score) ||
                !this.isNumericdnd(points_budget) || !this.isNumericdnd(s1) ||
                !this.isNumericdnd(s2) || !this.isNumericdnd(s3) || !this.isNumericdnd(s4) ||
                !this.isNumericdnd(s5) || !this.isNumericdnd(s6) || !this.isNumericdnd(strength1) ||
                !this.isNumericdnd(dexerity1) || !this.isNumericdnd(intelligence1) ||
                !this.isNumericdnd(wisdom1) || !this.isNumericdnd(charisma1) ||
                !this.isNumericdnd(constitution1) || !this.isNumericdnd(s7) ||
                !this.isNumericdnd(s8) || !this.isNumericdnd(s9) || !this.isNumericdnd(s10) ||
                !this.isNumericdnd(s11) || !this.isNumericdnd(x1) || !this.isNumericdnd(x2) ||
                !this.isNumericdnd(x3) || !this.isNumericdnd(x4) || !this.isNumericdnd(x5)
            ) {
                result.error = 'Please! Check Your Input';
                return result;
            }

            const smallScore = parseFloat(smallest_score);
            const largeScore = parseFloat(largest_score);

            if (!(smallScore >= 3 && smallScore <= 8 && largeScore >= 13 && largeScore <= 18)) {
                result.error = 'The score cannot be smaller than 3 and cannot larger than 18';
                return result;
            }

            const str = parseFloat(strength);
            const dex = parseFloat(dexerity);
            const int = parseFloat(intelligence);
            const wis = parseFloat(wisdom);
            const cha = parseFloat(charisma);
            const con = parseFloat(constitution);

            if (
                (str >= 3 && str <= 18) && (dex >= 3 && dex <= 18) &&
                (int >= 3 && int <= 18) && (wis >= 8 && wis <= 18) &&
                (cha >= 8 && cha <= 18) && (con >= 8 && con <= 18)
            ) {
                const strength_value = calculateSum2(str, parseFloat(x1), parseFloat(x2), parseFloat(x3), 
                    parseFloat(x4), parseFloat(x5), parseFloat(s1), parseFloat(s2), parseFloat(s3), 
                    parseFloat(s4), parseFloat(s5), parseFloat(s6), parseFloat(s7), parseFloat(s8), 
                    parseFloat(s9), parseFloat(s10), parseFloat(s11));
                
                const dexerity_value = calculateSum2(dex, parseFloat(x1), parseFloat(x2), parseFloat(x3), 
                    parseFloat(x4), parseFloat(x5), parseFloat(s1), parseFloat(s2), parseFloat(s3), 
                    parseFloat(s4), parseFloat(s5), parseFloat(s6), parseFloat(s7), parseFloat(s8), 
                    parseFloat(s9), parseFloat(s10), parseFloat(s11));
                
                const intelligence_value = calculateSum2(int, parseFloat(x1), parseFloat(x2), parseFloat(x3), 
                    parseFloat(x4), parseFloat(x5), parseFloat(s1), parseFloat(s2), parseFloat(s3), 
                    parseFloat(s4), parseFloat(s5), parseFloat(s6), parseFloat(s7), parseFloat(s8), 
                    parseFloat(s9), parseFloat(s10), parseFloat(s11));
                
                const wisdom_value = calculateSum2(wis, parseFloat(x1), parseFloat(x2), parseFloat(x3), 
                    parseFloat(x4), parseFloat(x5), parseFloat(s1), parseFloat(s2), parseFloat(s3), 
                    parseFloat(s4), parseFloat(s5), parseFloat(s6), parseFloat(s7), parseFloat(s8), 
                    parseFloat(s9), parseFloat(s10), parseFloat(s11));
                
                const charisma_value = calculateSum2(cha, parseFloat(x1), parseFloat(x2), parseFloat(x3), 
                    parseFloat(x4), parseFloat(x5), parseFloat(s1), parseFloat(s2), parseFloat(s3), 
                    parseFloat(s4), parseFloat(s5), parseFloat(s6), parseFloat(s7), parseFloat(s8), 
                    parseFloat(s9), parseFloat(s10), parseFloat(s11));
                
                const constitution_value = calculateSum2(con, parseFloat(x1), parseFloat(x2), parseFloat(x3), 
                    parseFloat(x4), parseFloat(x5), parseFloat(s1), parseFloat(s2), parseFloat(s3), 
                    parseFloat(s4), parseFloat(s5), parseFloat(s6), parseFloat(s7), parseFloat(s8), 
                    parseFloat(s9), parseFloat(s10), parseFloat(s11));

                const sum = strength_value + dexerity_value + intelligence_value + 
                          wisdom_value + charisma_value + constitution_value;
                const budget = parseFloat(points_budget);
                const total_minus = sum - budget;

                if (sum > budget) {
                    result.error = `You are ${total_minus} points over budget`;
                    return result;
                }

                result.tech_strength = str;
                result.tech_dexerity = dex;
                result.tech_constitution = con;
                result.tech_intelligence = int;
                result.tech_wisdom = wis;
                result.tech_charisma = cha;
                result.tech_strength_racial_bonus = parseFloat(strength1);
                result.tech_charisma_racial_bonus = parseFloat(charisma1);
                result.tech_dexerity_racial_bonus = parseFloat(dexerity1);
                result.tech_constitution_racial_bonus = parseFloat(constitution1);
                result.tech_intelligence_racial_bonus = parseFloat(intelligence1);
                result.tech_wisdom_racial_bonus = parseFloat(wisdom1);
                result.tech_strength_value = strength_value;
                result.tech_dexerity_value = dexerity_value;
                result.tech_intelligence_value = intelligence_value;
                result.tech_wisdom_value = wisdom_value;
                result.tech_charisma_value = charisma_value;
                result.tech_constitution_value = constitution_value;
                return result;
            } else {
                result.error = 'The base ability scores cannot be small than 8 and larger than 18';
                return result;
            }
        } else {
            // Other racial choices
            if (
                !this.isNumericdnd(strength) || !this.isNumericdnd(dexerity) ||
                !this.isNumericdnd(intelligence) || !this.isNumericdnd(wisdom) ||
                !this.isNumericdnd(charisma) || !this.isNumericdnd(constitution) ||
                !this.isNumericdnd(smallest_score) || !this.isNumericdnd(largest_score) ||
                !this.isNumericdnd(points_budget) || !this.isNumericdnd(s1) ||
                !this.isNumericdnd(s2) || !this.isNumericdnd(s3) || !this.isNumericdnd(s4) ||
                !this.isNumericdnd(s5) || !this.isNumericdnd(s6) || !this.isNumericdnd(s7) ||
                !this.isNumericdnd(s8)
            ) {
                result.error = 'Please! Check Your Input11';
                return result;
            }

            const smallScore = parseFloat(smallest_score);
            const largeScore = parseFloat(largest_score);
            const str = parseFloat(strength);
            const dex = parseFloat(dexerity);
            const int = parseFloat(intelligence);
            const wis = parseFloat(wisdom);
            const cha = parseFloat(charisma);
            const con = parseFloat(constitution);

            if (
                smallScore <= str && smallScore <= dex && smallScore <= int &&
                smallScore <= wis && smallScore <= con && smallScore <= cha &&
                smallScore >= 3 && smallScore <= 18 && largeScore >= 3 && largeScore <= 18 &&
                smallScore !== largeScore && largeScore > str && largeScore > dex &&
                largeScore > cha && largeScore > wis && largeScore > int && largeScore > con
            ) {
                if (
                    (str >= 8 && str <= 15) && (dex >= 8 && dex <= 15) &&
                    (int >= 8 && int <= 15) && (wis >= 8 && wis <= 15) &&
                    (cha >= 8 && cha <= 15) && (con >= 8 && con <= 15)
                ) {
                    const strength_value = calculateSum2Simple(str, parseFloat(s1), parseFloat(s2), 
                        parseFloat(s3), parseFloat(s4), parseFloat(s5), parseFloat(s6), 
                        parseFloat(s7), parseFloat(s8));
                    
                    const dexerity_value = calculateSum2Simple(dex, parseFloat(s1), parseFloat(s2), 
                        parseFloat(s3), parseFloat(s4), parseFloat(s5), parseFloat(s6), 
                        parseFloat(s7), parseFloat(s8));
                    
                    const intelligence_value = calculateSum2Simple(int, parseFloat(s1), parseFloat(s2), 
                        parseFloat(s3), parseFloat(s4), parseFloat(s5), parseFloat(s6), 
                        parseFloat(s7), parseFloat(s8));
                    
                    const wisdom_value = calculateSum2Simple(wis, parseFloat(s1), parseFloat(s2), 
                        parseFloat(s3), parseFloat(s4), parseFloat(s5), parseFloat(s6), 
                        parseFloat(s7), parseFloat(s8));
                    
                    const charisma_value = calculateSum2Simple(cha, parseFloat(s1), parseFloat(s2), 
                        parseFloat(s3), parseFloat(s4), parseFloat(s5), parseFloat(s6), 
                        parseFloat(s7), parseFloat(s8));
                    
                    const constitution_value = calculateSum2Simple(con, parseFloat(s1), parseFloat(s2), 
                        parseFloat(s3), parseFloat(s4), parseFloat(s5), parseFloat(s6), 
                        parseFloat(s7), parseFloat(s8));

                    const sum = strength_value + dexerity_value + intelligence_value + 
                              wisdom_value + charisma_value + constitution_value;

                    const devillers = racial_choice.split('.');
                    const strength_racial_bonus = devillers[0];
                    const dexerity_racial_bonus = devillers[1];
                    const constitution_racial_bonus = devillers[2];
                    const intelligence_racial_bonus = devillers[3];
                    const wisdom_racial_bonus = devillers[4];
                    const charisma_racial_bonus = devillers[5];

                    const budget = parseFloat(points_budget);
                    const total_minus = sum - budget;

                    if (sum > budget) {
                        result.error = `You are ${total_minus} points over budget`;
                        return result;
                    }

                    result.tech_strength = str;
                    result.tech_dexerity = dex;
                    result.tech_constitution = con;
                    result.tech_intelligence = int;
                    result.tech_wisdom = wis;
                    result.tech_charisma = cha;
                    result.tech_strength_racial_bonus = strength_racial_bonus;
                    result.tech_charisma_racial_bonus = charisma_racial_bonus;
                    result.tech_dexerity_racial_bonus = dexerity_racial_bonus;
                    result.tech_constitution_racial_bonus = constitution_racial_bonus;
                    result.tech_intelligence_racial_bonus = intelligence_racial_bonus;
                    result.tech_wisdom_racial_bonus = wisdom_racial_bonus;
                    result.tech_strength_value = strength_value;
                    result.tech_dexerity_value = dexerity_value;
                    result.tech_intelligence_value = intelligence_value;
                    result.tech_wisdom_value = wisdom_value;
                    result.tech_charisma_value = charisma_value;
                    result.tech_constitution_value = constitution_value;
                    return result;
                } else {
                    result.error = 'The base ability scores cannot be small than 8 and larger than 18';
                    return result;
                }
            } else {
                result.error = 'The score cannot be smaller than 3 and cannot larger than 18';
                return result;
            }
        }
    }

    result.error = 'Please! Check Your Input';
    return result;
    }

    // Helper function (reuse from previous code)
    isNumericdnd(value) {
        if (value === null || value === undefined || value === '') {
            return false;
        }
        return !isNaN(parseFloat(value)) && isFinite(value);
    }

     /**
    * getCalculationStairCalculator: Service Method
    * POST: /api/calculators-lol/stair-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

  async getCalculationStairCalculator(body) {
      const stairInches = (a, b) => {
          if (b == "ft") {
              return a * 12;
          } else if (b == "in") {
              return a * 1;
          } else if (b == "yd") {
              return a * 36;
          } else if (b == "cm") {
              return a / 2.54;
          } else if (b == "m") {
              return a * 39.37;
          }
          return a;
      };
      const type = body.tech_type;
      const f_input = parseFloat(body.tech_f_input) || 0;
      const f_units = body.tech_f_units;
      var s_input = parseFloat(body.tech_s_input) || 0;
      const s_units = body.tech_s_units;
      const rise = body.tech_rise;
      const t_input = parseFloat(body.tech_t_input) || 0;
      const t_units = body.tech_t_units;
      const tread = body.tech_tread;
      const tread_input = parseFloat(body.tech_tread_input) || 0;
      const tread_units = body.tech_tread_units;
      const headroom = body.tech_headroom;
      const f_opening = parseFloat(body.tech_f_opening) || 0;
      const fo_units = body.tech_fo_units;
      const f_thickness = parseFloat(body.tech_f_thickness) || 0;
      const ft_units = body.tech_ft_units;
      const h_req = parseFloat(body.tech_h_req) || 0;
      const hr_units = body.tech_hr_units;
      const mount = body.tech_mount;

      const result = {};

      let inch, total_run_ans, run_ans, stair_ans, placement, mount_ans, step_ans, s_ans, str, angle_ans, answ;

      if (type == "first") {
          const f_input_in = stairInches(f_input, f_units);
          var s_input = stairInches(s_input, s_units);
          const t_input_in = stairInches(t_input, t_units);
          const tread_input_in = stairInches(tread_input, tread_units);
          if (f_input_in > 0 && s_input > 0) {
              if (rise == "1") {
                  if (t_input_in > 0) {
                      inch = t_input_in;
                      inch = Number(inch.toFixed(2));
                      const no_stair = s_input / t_input_in;
                      stair_ans = Math.round(no_stair);
                      total_run_ans = f_input_in * (stair_ans - 1);
                      total_run_ans = Number(total_run_ans.toFixed(2));
                      run_ans = f_input_in;
                      run_ans = Number(run_ans.toFixed(2));
                      const first_step = s_input - t_input_in;
                      
                      if (first_step <= 0) {
                          step_ans = s_input;
                          step_ans = Number(step_ans.toFixed(2));
                      } else if (first_step > 0) {
                          step_ans = first_step;
                          step_ans = Number(step_ans.toFixed(2));
                      }
                  } else {
                      result.error = 'Please! Check Your Input';
                      return result;
                  }

                  if (tread == "2") {
                      if (tread_input_in > 0) {
                          const f_step = s_input - t_input_in;
                          if (f_step <= 0) {
                              s_ans = s_input;
                              s_ans = Number(s_ans.toFixed(2));
                          } else if (f_step > 0) {
                              s_ans = f_step;
                              s_ans = Number(s_ans.toFixed(2));
                          }
                          placement = t_input_in + tread_input_in;
                          placement = Number(placement.toFixed(2));
                      } else {
                          result.error = 'Please! Check Your Input';
                          return result;
                      }
                  }
              } else if (rise == "2") {
                  if (t_input_in > 0) {
                      inch = s_input / t_input_in;
                      inch = Number(inch.toFixed(2));
                      stair_ans = Math.round(t_input_in);
                      total_run_ans = f_input_in * t_input_in;
                      total_run_ans = Number(total_run_ans.toFixed(2));
                      run_ans = f_input_in;
                      run_ans = Number(run_ans.toFixed(2));
                  } else {
                      result.error = 'Please! Check Your Input';
                      return result;
                  }

                  if (tread == "2") {
                      if (tread_input_in > 0) {
                          const f_step = s_input - t_input_in;
                          if (f_step <= 0) {
                              s_ans = s_input;
                              s_ans = Number(s_ans.toFixed(2));
                          } else if (f_step > 0) {
                              s_ans = f_step;
                              s_ans = Number(s_ans.toFixed(2));
                          }
                          placement = tread_input_in;
                          placement = Number(placement.toFixed(2));
                      } else {
                          result.error = 'Please! Check Your Input';
                          return result;
                      }
                  }
              }
          } else {
              result.error = 'Please! Check Your Input';
              return result;
          }
      } else if (type == "second") {
          const f_input_in = stairInches(f_input, f_units);
          var s_input = stairInches(s_input, s_units);
          const t_input_in = stairInches(t_input, t_units);
          const tread_input_in = stairInches(tread_input, tread_units);

          if (f_input_in > 0 && s_input > 0) {
              if (rise == "1") {
                  if (t_input_in > 0) {
                      inch = t_input_in;
                      inch = Number(inch.toFixed(2));
                      const no_stair = s_input / t_input_in;
                      stair_ans = Math.round(no_stair);
                      total_run_ans = f_input_in;
                      total_run_ans = Number(total_run_ans.toFixed(2));
                      run_ans = f_input_in / stair_ans;
                      run_ans = Number(run_ans.toFixed(2));
                      const first_step = s_input - t_input_in;
                      
                      if (first_step <= 0) {
                          step_ans = s_input;
                          step_ans = Number(step_ans.toFixed(2));
                      } else if (first_step > 0) {
                          step_ans = first_step;
                          step_ans = Number(step_ans.toFixed(2));
                      }
                  } else {
                      result.error = 'Please! Check Your Input';
                      return result;
                  }

                  if (tread == "2") {
                      if (tread_input_in > 0) {
                          const f_step = s_input - t_input_in;
                          if (f_step <= 0) {
                              s_ans = s_input;
                              s_ans = Number(s_ans.toFixed(2));
                          } else if (f_step > 0) {
                              s_ans = f_step;
                              s_ans = Number(s_ans.toFixed(2));
                          }
                          placement = t_input_in + tread_input_in;
                          placement = Number(placement.toFixed(2));
                      } else {
                          result.error = 'Please! Check Your Input';
                          return result;
                      }
                  }
              } else if (rise == "2") {
                  if (t_input_in > 0) {
                      inch = s_input / t_input_in;
                      inch = Number(inch.toFixed(2));
                      stair_ans = Math.round(t_input_in);
                      total_run_ans = f_input_in;
                      total_run_ans = Number(total_run_ans.toFixed(2));
                      run_ans = f_input_in / stair_ans;
                      run_ans = Number(run_ans.toFixed(2));
                  } else {
                      result.error = 'Please! Check Your Input';
                      return result;
                  }

                  if (tread == "2") {
                      if (tread_input_in > 0) {
                          const f_step = s_input - t_input_in;
                          if (f_step <= 0) {
                              s_ans = s_input;
                              s_ans = Number(s_ans.toFixed(2));
                          } else if (f_step > 0) {
                              s_ans = f_step;
                              s_ans = Number(s_ans.toFixed(2));
                          }
                          placement = tread_input_in;
                          placement = Number(placement.toFixed(2));
                      } else {
                          result.error = 'Please! Check Your Input';
                          return result;
                      }
                  }
              }
          } else {
              result.error = 'Please! Check Your Input';
              return result;
          }
      }

      if (mount == "1") {
          mount_ans = s_input - t_input;
          mount_ans = Number(mount_ans.toFixed(2));
          
          if (headroom == "2") {
              if (f_opening && f_thickness && h_req) {
                  const f_opening_in = stairInches(f_opening, fo_units);
                  const f_thickness_in = stairInches(f_thickness, ft_units);
                  const h_req_in = stairInches(h_req, hr_units);

                  if (f_opening_in > 0) {
                      if (f_opening_in > 0 && f_opening_in < 5) {
                          answ = inch - f_thickness_in;
                      } else {
                          answ = inch - f_thickness_in;
                          for (let i = 0; i <= f_opening_in; i++) {
                              if (i % 5 === 0) {
                                  answ += inch;
                              }
                          }
                          if (f_opening_in < 5) {
                              // answ remains the same
                          } else if (f_opening_in > 5) {
                              answ -= inch;
                          }
                      }
                  } else if (f_opening_in < 0) {
                      if (f_opening_in < -1 && f_opening_in > -5) {
                          answ = f_thickness_in * -1;
                      } else {
                          answ = inch + f_thickness_in;
                          for (let i = -1; i >= f_opening_in; i--) {
                              if (i % 5 === 0) {
                                  answ += inch;
                              }
                          }
                          answ *= -1;
                      }
                      if (f_opening_in > -5) {
                          // answ remains the same
                      } else if (f_opening_in < -5) {
                          answ += inch;
                      }
                  }
              } else {
                  result.error = 'Please! Check Your Input';
                  return result;
              }
          }
      } else if (mount == "2") {
          mount_ans = s_input;
          
          if (headroom == "2") {
              if (f_opening && f_thickness && h_req) {
                  const f_opening_in = stairInches(f_opening, fo_units);
                  const f_thickness_in = stairInches(f_thickness, ft_units);
                  const h_req_in = stairInches(h_req, hr_units);

                  if (f_opening_in > 0) {
                      if (f_opening_in >= 0 && f_opening_in < 5) {
                          answ = f_thickness_in * -1;
                      } else {
                          answ = inch - f_thickness_in;
                          for (let i = 0; i < f_opening_in; i++) {
                              if (i % 5 === 0) {
                                  answ += inch;
                              }
                          }
                          answ -= inch;
                      }
                  } else if (f_opening_in < 0) {
                      if (f_opening_in < -1 && f_opening_in > -5) {
                          answ = f_thickness_in + inch;
                          answ *= -1;
                      } else {
                          answ = inch + f_thickness_in;
                          for (let i = -1; i > f_opening_in; i--) {
                              if (i % 5 === 0) {
                                  answ += inch;
                              }
                          }
                          answ *= -1;
                      }
                  }
              } else {
                  result.error = 'Please! Check Your Input';
                  return result;
              }
          }
      }
      // console.log(mount_ans);
      if (total_run_ans && mount_ans) {
          str = Math.pow(total_run_ans, 2) + Math.pow(mount_ans, 2);
          str = Math.sqrt(str);
          str = Number(str.toFixed(2));

          if (str && mount_ans) {
              const angle = mount_ans / str;
              angle_ans = Math.asin(angle);
              angle_ans = angle_ans * (180 / Math.PI); // Convert radians to degrees
              angle_ans = Number(angle_ans.toFixed(2));
          }
      }

      // Add calculated values to result object
      if (inch !== undefined) result.tech_inch = inch;
      if (total_run_ans !== undefined) result.tech_total_run_ans = total_run_ans;
      if (run_ans !== undefined) result.tech_run_ans = run_ans;
      if (stair_ans !== undefined) result.tech_stair_ans = stair_ans;
      if (placement !== undefined) result.tech_placement = placement;
      if (mount_ans !== undefined) result.tech_mount_ans = mount_ans;
      if (str !== undefined) result.tech_str = str;
      if (step_ans !== undefined) result.tech_step_ans = step_ans;
      if (s_ans !== undefined) result.tech_s_ans = s_ans;
      if (angle_ans !== undefined) result.tech_angle_ans = angle_ans;
      if (answ !== undefined) result.tech_answ = answ;

      return result;
  }


       /**
    * getCalculationBattingAverageCalculator: Service Method
    * POST: /api/calculators-lol/batting-average-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationBattingAverageCalculator(body) {
        const operations = body.tech_operations;
        const first = parseFloat(body.tech_first) || 0;
        const second = parseFloat(body.tech_second) || 0;
        const third = parseFloat(body.tech_third) || 0;
        const four = parseFloat(body.tech_four) || 0;
        const five = parseFloat(body.tech_five) || 0;
        const fiveb = parseFloat(body.tech_fiveb) || 0;
        const seven = parseFloat(body.tech_seven) || 0;
        const eight = parseFloat(body.tech_eight) || 0;
        const nine = parseFloat(body.tech_nine) || 0;
        const ten = parseFloat(body.tech_ten) || 0;
        const quantity = parseFloat(body.tech_quantity) || 0;

        const result = {};
        let batting, heading;

        if (operations == "3") {
            if (!isNaN(first) && !isNaN(second) && !isNaN(third)) {
                const a1 = second - third;
                batting = first / a1;
                heading = "Cricket Batting Average";
            } else {
                result.error = 'Please check your input';
                return result;
            }
        } else if (operations == "4") {
            if (!isNaN(first) && !isNaN(second)) {
                if (first != 0) {
                    batting = second / first;
                    heading = "Batting Average";
                } else {
                    result.error = 'At Bats cannot be zero';
                    return result;
                }
            } else {
                result.error = 'Please check your input';
                return result;
            }
        } else if (operations == "5") {
            if (!isNaN(first) && !isNaN(second) && !isNaN(third) && !isNaN(four) && !isNaN(five)) {
                const a1_ans = second + third + four;
                const a2_ans = first + third + four + five;
                if (a2_ans != 0) {
                    batting = a1_ans / a2_ans;
                    heading = "On Base Percentage";
                } else {
                    batting = 0;
                    heading = "On Base Percentage";
                }
            } else {
                result.error = 'Please check your input';
                return result;
            }
        } else if (operations == "6") {
            if (!isNaN(second) && !isNaN(third) && !isNaN(four) && !isNaN(first)) {
                if (first != 0) {
                    const d2 = third * 2;
                    const t3 = four * 3;
                    const h4 = five * 4;
                    const a1_ans = second + d2 + t3 + h4;
                    batting = a1_ans / first;
                    heading = "Slugging Percentage";
                } else {
                    result.error = 'At Bats cannot be zero';
                    return result;
                }
            } else {
                result.error = 'Please check your input';
                return result;
            }
        } else if (operations == "7") {
            if (!isNaN(first) && !isNaN(second) && !isNaN(third) && !isNaN(four) && !isNaN(five) && 
                !isNaN(fiveb) && !isNaN(quantity) && !isNaN(seven) && !isNaN(eight)) {
                if (eight != 0) {
                    const d2 = second * 2;
                    const t3 = third * 3;
                    const h4 = four * 4;
                    const TB = first + d2 + t3 + h4;
                    const SLG = TB / eight;
                    const OBP_T = five + quantity + seven;
                    const OBP_D = eight + quantity + fiveb + seven;
                    const OBP = OBP_T / OBP_D;
                    if (OBP_D !== 0) {
                        batting = OBP + SLG;
                        heading = "On-Base Plus Slugging";
                    } else {
                        batting = 0;
                        heading = "On-Base Plus Slugging";
                    }
                } else {
                    result.error = 'At Bats cannot be zero';
                    return result;
                }
            } else {
                result.error = 'Please check your input';
                return result;
            }
        } else if (operations == "8") {
            if (!isNaN(first) && !isNaN(second) && !isNaN(third) && !isNaN(four) && !isNaN(five) && 
                !isNaN(fiveb) && !isNaN(quantity) && !isNaN(seven)) {
                if (first != 0) {
                    const NIBB = second * 0.72;
                    const HBP = third * 0.72;
                    const B1 = four * 0.90;
                    const RBOE = seven * 0.92;
                    const B2 = five * 1.24;
                    const B3 = quantity * 1.56;
                    const HR = fiveb * 1.95;
                    const top_part = NIBB + HBP + B1 + RBOE + B2 + B3 + HR;
                    batting = top_part / first;
                    heading = "Weighted On Base Average";
                } else {
                    result.error = 'Appearances cannot be zero';
                    return result;
                }
            } else {
                result.error = 'Please check your input';
                return result;
            }
        } else if (operations == "9") {
            if (!isNaN(first) && !isNaN(second) && !isNaN(third) && !isNaN(four) && !isNaN(five)) {
                const b_top = second - third;
                const b_down = first - five - third + four;
                if (b_down != 0) {
                    batting = b_top / b_down;
                    heading = "Batting Average on Balls in Play";
                } else {
                    batting = 0;
                    heading = "Batting Average on Balls in Play";
                }
            } else {
                result.error = 'Please check your input';
                return result;
            }
        } else if (operations === "10") {
            if (!isNaN(first) && !isNaN(second) && !isNaN(third) && !isNaN(four)) {
                if (first != 0) {
                    const t2 = third * 2;
                    const h3 = four * 3;
                    const top_ans = second + t2 + h3;
                    batting = top_ans / first;
                    heading = "Isolated Power";
                } else {
                    result.error = 'At Bats cannot be zero';
                    return result;
                }
            } else {
                result.error = 'Please check your input';
                return result;
            }
        } else if (operations == "11") {
            if (!isNaN(first) && !isNaN(second) && !isNaN(third) && !isNaN(four) && !isNaN(five) && 
                !isNaN(quantity) && !isNaN(fiveb) && !isNaN(seven) && !isNaN(eight) && !isNaN(nine) && !isNaN(ten)) {
                const f_part = second + third - ten + five - quantity;

                const s2_part = third - fiveb + five;
                const s3_part = 0.26 * s2_part;
                const s_part = four + s3_part;

                const t2_part = seven + eight + nine;
                const t_part = 0.52 * t2_part;

                const down_part = first + third + five + seven + eight;
                const top_part = f_part * s_part + t_part;
                if (down_part != 0) {
                    batting = top_part / down_part;
                    heading = "Runs Created";
                } else {
                    batting = 0;
                    heading = "Runs Created";
                }
            } else {
                result.error = 'Please check your input';
                return result;
            }
        } else if (operations == "12") {
            if (!isNaN(first) && !isNaN(second) && !isNaN(third) && !isNaN(four) && !isNaN(five) && !isNaN(quantity)) {
                if (quantity != 0) {
                    const f_part = first - second;
                    const l_part = four - five;
                    const top_part = third + f_part + l_part;
                    batting = top_part / quantity;
                    heading = "Secondary Average";
                } else {
                    result.error = 'At Bats cannot be zero';
                    return result;
                }
            } else {
                result.error = 'Please check your input';
                return result;
            }
        } else if (operations == "13") {
            if (!isNaN(first) && !isNaN(second) && !isNaN(third) && !isNaN(four)) {
                const d2 = second * 2;
                const t3 = third * 3;
                const h4 = four * 4;
                batting = first + d2 + t3 + h4;
                heading = "Total Bases";
            } else {
                result.error = 'Please check your input';
                return result;
            }
        } else if (operations == "14") {
            if (!isNaN(first) && !isNaN(second)) {
                if (second != 0) {
                    batting = first / second;
                    heading = "At Bats per Home Run";
                } else {
                    result.error = 'Home Runs cannot be zero';
                    return result;
                }
            } else {
                result.error = 'Please check your input';
                return result;
            }
        } else if (operations == "15") {
            if (!isNaN(first) && !isNaN(second) && !isNaN(third)) {
                const top_part = first + second;
                const down_part = first + second + third;
                if (down_part != 0) {
                    batting = top_part / down_part;
                    heading = "Fielding Percentage";
                } else {
                    batting = 0;
                    heading = "Fielding Percentage";
                }
            } else {
                result.error = 'Please check your input';
                return result;
            }
        } else if (operations == "16") {
            if (!isNaN(first) && !isNaN(second) && !isNaN(third)) {
                if (first != 0) {
                    const top_part = second + third;
                    batting = top_part / first;
                    heading = "Range Factor Per Games Played";
                } else {
                    result.error = 'Games Played cannot be zero';
                    return result;
                }
            } else {
                result.error = 'Please check your input';
                return result;
            }
        } else if (operations == "17") {
            if (!isNaN(first) && !isNaN(second) && !isNaN(third)) {
                if (first != 0) {
                    const t_part = second + third;
                    const top_part = 9 * t_part;
                    batting = top_part / first;
                    heading = "Range Factor Per 9 Innings";
                } else {
                    result.error = 'Innings Played cannot be zero';
                    return result;
                }
            } else {
                result.error = 'Please check your input';
                return result;
            }
        } else if (operations == "18") {
            if (!isNaN(first) && !isNaN(second)) {
                if (second != 0) {
                    const top_part = 9 * first;
                    batting = top_part / second;
                    heading = "ERA";
                } else {
                    result.error = 'Innings Pitched cannot be zero';
                    return result;
                }
            } else {
                result.error = 'Please check your input';
                return result;
            }
        } else if (operations == "19") {
            if (!isNaN(first) && !isNaN(second) && !isNaN(third)) {
                if (third != 0) {
                    const top_part = first + second;
                    batting = top_part / third;
                    heading = "WHIP";
                } else {
                    result.error = 'Innings Pitched cannot be zero';
                    return result;
                }
            } else {
                result.error = 'Please check your input';
                return result;
            }
        } else if (operations == "20") {
            if (!isNaN(first) && !isNaN(second)) {
                if (first != 0) {
                    const top_part = second / first;
                    batting = 9 * top_part;
                    heading = "Hits Allowed Per 9 Innings";
                } else {
                    result.error = 'Innings Pitched cannot be zero';
                    return result;
                }
            } else {
                result.error = 'Please check your input';
                return result;
            }
        } else if (operations == "21") {
            if (!isNaN(first) && !isNaN(second)) {
                if (first != 0) {
                    const top_part = second / first;
                    batting = 9 * top_part;
                    heading = "Home Runs Allowed Per 9 Innings";
                } else {
                    result.error = 'Innings Pitched cannot be zero';
                    return result;
                }
            } else {
                result.error = 'Please check your input';
                return result;
            }
        } else if (operations == "22") {
            if (!isNaN(first) && !isNaN(second)) {
                if (first != 0) {
                    const top_part = second / first;
                    batting = 9 * top_part;
                    heading = "Strikeouts Per 9 Innings";
                } else {
                    result.error = 'Innings Pitched cannot be zero';
                    return result;
                }
            } else {
                result.error = 'Please check your input';
                return result;
            }
        } else if (operations == "23") {
            if (!isNaN(first) && !isNaN(second)) {
                if (first != 0) {
                    const top_part = second / first;
                    batting = 9 * top_part;
                    heading = "Walks Per 9 Innings";
                } else {
                    result.error = 'Innings Pitched cannot be zero';
                    return result;
                }
            } else {
                result.error = 'Please check your input';
                return result;
            }
        } else if (operations == "24") {
            if (!isNaN(first) && !isNaN(second)) {
                if (second != 0) {
                    batting = first / second;
                    heading = "Strikeout-to-Walk Ratio";
                } else {
                    result.error = 'Walks cannot be zero';
                    return result;
                }
            } else {
                result.error = 'Please check your input';
                return result;
            }
        } else {
            result.error = 'Invalid operation';
            return result;
        }

        // Format the result to 3 decimal places
        batting = Number(batting.toFixed(3));
        
        result.tech_batting = batting;
        result.tech_heading = heading;
        return result;
    }

      /**
    * getCalculationMpgCalculator: Service Method
    * POST: /api/calculators-lol/mpg-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationMpgCalculator(body) {
        const type = body.tech_type;
        const operations = body.tech_operations;
        const first = parseFloat(body.tech_first) || 0;
        const units1 = body.tech_units1;
        const second = parseFloat(body.tech_second) || 0;
        const units2 = body.tech_units2;
        const third = parseFloat(body.tech_third) || 0;
        const units3 = body.tech_units3;
        const four = parseFloat(body.tech_four) || 0;
        const units4 = body.tech_units4;
        const ad_first = parseFloat(body.tech_ad_first) || 0;
        const ad_second = parseFloat(body.tech_ad_second) || 0;
        const ad_third = parseFloat(body.tech_ad_third) || 0;
        const ad_units3 = body.tech_ad_units3;
        const ad_four = parseFloat(body.tech_ad_four) || 0;
        const ad_units4 = body.tech_ad_units4;
        const currancy = body.tech_currancy;

        const result = {};

        // Helper functions
        const calculate1 = (a, b) => {
            if (a == "1") {
                return b / 1.609;
            } else if (a == "2") {
                return b * 1;
            }
            return b;
        };

        const calculate2 = (a, b) => {
            if (a == "1") {
                return b / 3.785;
            } else if (a == "2") {
                return b * 1;
            } else if (a == "3") {
                return b * 1.20095;
            }
            return b;
        };

        const calculate3 = (a, b) => {
            if (a == "1") {
                return b / 235.215;
            } else if (a == "2") {
                return b * 1;
            } else if (a == "3") {
                return b * 1.201;
            } else if (a == "4") {
                return b * 2.352145;
            }
            return b;
        };

        // Convert units to numeric codes
        let units1Code, units2Code, units3Code, units4Code, adUnits3Code, adUnits4Code;

        // Convert units1
        if (units1 == 'km') {
            units1Code = "1";
        } else if (units1 == 'mi') {
            units1Code = "2";
        } else {
            units1Code = units1;
        }

        // Convert units2
        if (units2 == 'liters') {
            units2Code = "1";
        } else if (units2 == 'US gal') {
            units2Code = "2";
        } else if (units2 == 'UK gal') {
            units2Code = "3";
        } else {
            units2Code = units2;
        }

        // Convert units3
        if (units3 == 'L/100km') {
            units3Code = "1";
        } else if (units3 == 'US mpg') {
            units3Code = "2";
        } else if (units3 == 'UK mpg') {
            units3Code = "3";
        } else if (units3 == 'kmpl') {
            units3Code = "4";
        } else {
            units3Code = units3;
        }

        // Convert units4
        if (units4 == currancy + 'liters') {
            units4Code = "1";
        } else if (units4 == 'US gal') {
            units4Code = "2";
        } else if (units4 == 'UK gal') {
            units4Code = "2";
        } else {
            units4Code = units4;
        }

        // Convert ad_units3
        if (ad_units3 == 'liters') {
            adUnits3Code = "1";
        } else if (ad_units3 == 'US gal') {
            adUnits3Code = "2";
        } else if (ad_units3 == 'UK gal') {
            adUnits3Code = "2";
        } else {
            adUnits3Code = ad_units3;
        }

        // Convert ad_units4
        if (ad_units4 == currancy + 'liters') {
            adUnits4Code = "1";
        } else if (ad_units4 == currancy + 'US gal') {
            adUnits4Code = "2";
        } else if (ad_units4 == currancy + 'UK gal') {
            adUnits4Code = "2";
        } else {
            adUnits4Code = ad_units4;
        }

        // Convert inputs
        const convertedFirst = calculate1(units1Code, first);
        const convertedSecond = calculate2(units2Code, second);
        const convertedThird = calculate3(units3Code, third);
        const convertedAdThird = calculate2(adUnits3Code, ad_third);

        let jawab, petrol, cost, distance, km_dis, mi_jawab, km_jawab, ad_cost, ad_petrol;

        if (type == "first") {
            if (operations == "1") {
                if (!isNaN(convertedSecond) && !isNaN(convertedThird)) {
                    petrol = convertedSecond;
                    jawab = convertedSecond * convertedThird;
                } else {
                    result.error = 'Please check your input';
                    return result;
                }
            } else if (operations == "2") {
                if (!isNaN(convertedFirst) && !isNaN(convertedThird)) {
                    if (convertedThird != 0) {
                        jawab = convertedFirst / convertedThird;
                        petrol = jawab;
                    } else {
                        result.error = 'Fuel economy cannot be 0';
                        return result;
                    }
                } else {
                    result.error = 'Please check your input';
                    return result;
                }
            } else if (operations == "3") {
                if (!isNaN(convertedFirst) && !isNaN(convertedSecond)) {
                    if (convertedSecond != 0) {
                        jawab = convertedFirst / convertedSecond;
                        petrol = convertedSecond;
                    } else {
                        result.error = 'Fuel used cannot be 0';
                        return result;
                    }
                } else {
                    result.error = 'Please check your input';
                    return result;
                }
            } else {
                result.error = 'Invalid operation';
                return result;
            }

            // Calculate cost
            if (!isNaN(four)) {
                if (units4Code == "1") {
                    const cost1 = petrol * 3.785;
                    cost = cost1 * four;
                } else if (units4Code == "2") {
                    cost = petrol * four;
                } else if (units4Code == "3") {
                    const cost1 = petrol / 1.201;
                    cost = cost1 * four;
                } else {
                    cost = 0;
                }
                cost = Number(cost.toFixed(3));
                result.tech_cost = cost;
            }

            result.tech_jawab = jawab;

        } else if (type == "second") {
            if (!isNaN(ad_first) && !isNaN(ad_second) && !isNaN(convertedAdThird)) {
                if (ad_second > ad_first) {
                    if (convertedAdThird != 0) {
                        ad_petrol = convertedAdThird;
                        distance = ad_second - ad_first;
                        mi_jawab = distance / convertedAdThird;
                        km_dis = distance / 1.609;
                        km_jawab = km_dis / convertedAdThird;
                    } else {
                        result.error = 'Fuel used cannot be 0';
                        return result;
                    }
                } else {
                    result.error = 'End Trip must be greater than Start Trip';
                    return result;
                }
            } else {
                result.error = 'Please check your input';
                return result;
            }

            // Calculate additional cost
            if (!isNaN(ad_four)) {
                if (adUnits4Code == "1") {
                    const ad_cost1 = ad_petrol * 3.785;
                    ad_cost = ad_cost1 * ad_four;
                } else if (adUnits4Code == "2") {
                    ad_cost = ad_petrol * ad_four;
                } else if (adUnits4Code == "3") {
                    const ad_cost1 = ad_petrol / 1.201;
                    ad_cost = ad_cost1 * ad_four;
                } else {
                    ad_cost = 0;
                }
                ad_cost = Number(ad_cost.toFixed(3));
                result.tech_ad_cost = ad_cost;
            }

            result.tech_distance = distance;
            result.tech_km_dis = km_dis;
            result.tech_mi_jawab = mi_jawab;
            result.tech_km_jawab = km_jawab;

        } else {
            result.error = 'Invalid type';
            return result;
        }

        return result;
    }

      /**
    * getCalculationAquariumCalculator: Service Method
    * POST: /api/calculators-lol/aquarium-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationAquariumCalculator(body) {
      const shape = body.tech_shape;
      const length = parseFloat(body.tech_length) || 0;
      const length_unit = body.tech_length_unit;
      const width = parseFloat(body.tech_width) || 0;
      const width_unit = body.tech_width_unit;
      const height = parseFloat(body.tech_height) || 0;
      const height_unit = body.tech_height_unit;
      const fill_depth = parseFloat(body.tech_fill_depth) || 0;
      const fill_depth_unit = body.tech_fill_depth_unit;
      const front_pane = parseFloat(body.tech_front_pane) || 0;
      const front_pane_unit = body.tech_front_pane_unit;
      const end_pane = parseFloat(body.tech_end_pane) || 0;
      const end_pane_unit = body.tech_end_pane_unit;
      const radius = parseFloat(body.tech_radius) || 0;
      const radius_unit = body.tech_radius_unit;
      const radius_one = parseFloat(body.tech_radius_one) || 0;
      const radius_one_unit = body.tech_radius_one_unit;
      const radius_two = parseFloat(body.tech_radius_two) || 0;
      const radius_two_unit = body.tech_radius_two_unit;
      const long_side = parseFloat(body.tech_long_side) || 0;
      const long_side_unit = body.tech_long_side_unit;
      const short_side = parseFloat(body.tech_short_side) || 0;
      const short_side_unit = body.tech_short_side_unit;
      const len_one = parseFloat(body.tech_len_one) || 0;
      const len_one_unit = body.tech_len_one_unit;
      const len_two = parseFloat(body.tech_len_two) || 0;
      const len_two_unit = body.tech_len_two_unit;
      const wid_one = parseFloat(body.tech_wid_one) || 0;
      const wid_one_unit = body.tech_wid_one_unit;
      const wid_two = parseFloat(body.tech_wid_two) || 0;
      const wid_two_unit = body.tech_wid_two_unit;
      const full_width = parseFloat(body.tech_full_width) || 0;
      const full_width_unit = body.tech_full_width_unit;

      const result = {};

      const convertCm = (value, unit) => {
          if (unit == "cm") {
              return value * 1;
          } else if (unit == "m") {
              return value * 100;
          } else if (unit == "in") {
              return value * 2.54;
          } else if (unit == "ft") {
              return value * 30.48;
          } else if (unit == "yd") {
              return value * 91.44;
          }
          return value;
      };

      let volume, filled_volume;

      if (shape == "1") {
          if (!isNaN(length) && !isNaN(width) && !isNaN(height)) {
              const lv = convertCm(length, length_unit);
              const wv = convertCm(width, width_unit);
              const hv = convertCm(height, height_unit);
              volume = lv * wv * hv;

              if (fill_depth != "" && !isNaN(fill_depth)) {
                  if (fill_depth > height) {
                      result.error = 'The fill depth cannot be greater than the height of the aquarium.';
                      return result;
                  } else {
                      const fv = convertCm(fill_depth, fill_depth_unit);
                      filled_volume = lv * wv * fv;
                      result.tech_filled_volume = filled_volume;
                  }
              }
          } else {
              result.error = 'Please! Check Input';
              return result;
          }
      } else if (shape == "2") {
          if (!isNaN(length)) {
              const lv = convertCm(length, length_unit);
              volume = lv * lv * lv;

              if (fill_depth != "" && !isNaN(fill_depth)) {
                  if (fill_depth > length) {
                      result.error = 'The fill depth cannot be greater than the length of the aquarium.';
                      return result;
                  } else {
                      const fv = convertCm(fill_depth, fill_depth_unit);
                      filled_volume = lv * lv * fv;
                      result.tech_filled_volume = filled_volume;
                  }
              }
          } else {
              result.error = 'Please! Check Input';
              return result;
          }
      } else if (shape == "3") {
          if (!isNaN(length) && !isNaN(width) && !isNaN(height) && !isNaN(front_pane)) {
              const lv = convertCm(length, length_unit);
              const wv = convertCm(width, width_unit);
              const hv = convertCm(height, height_unit);
              const fr_pane = convertCm(front_pane, front_pane_unit);
              volume = ((wv * lv) - ((wv * (lv - fr_pane)) / 2)) * hv;

              if (fill_depth != "" && !isNaN(fill_depth)) {
                  if (fill_depth > height) {
                      result.error = 'The fill depth cannot be greater than the height of the aquarium.';
                      return result;
                  } else {
                      const fv = convertCm(fill_depth, fill_depth_unit);
                      filled_volume = ((wv * lv) - ((wv * (lv - fr_pane)) / 2)) * fv;
                      result.tech_filled_volume = filled_volume;
                  }
              }
          } else {
              result.error = 'Please! Check Input';
              return result;
          }
      } else if (shape == "4" || shape == "5") {
          if (!isNaN(length) && !isNaN(width) && !isNaN(height) && !isNaN(front_pane) && !isNaN(end_pane)) {
              const lv = convertCm(length, length_unit);
              const wv = convertCm(width, width_unit);
              const hv = convertCm(height, height_unit);
              const fr_pane = convertCm(front_pane, front_pane_unit);
              const en_pane = convertCm(end_pane, end_pane_unit);

              if (shape == "4") {
                  volume = ((wv * lv - (lv - fr_pane) * (wv - en_pane) / 2) * hv);
              } else if (shape == "5") {
                  volume = 0.5 * ((wv * lv) + (wv * fr_pane) + (en_pane * lv) - (fr_pane * en_pane)) * hv;
              }

              if (fill_depth != "" && !isNaN(fill_depth)) {
                  if (fill_depth > height) {
                      result.error = 'The fill depth cannot be greater than the height of the aquarium.';
                      return result;
                  } else {
                      const fv = convertCm(fill_depth, fill_depth_unit);
                      if (shape == "4") {
                          filled_volume = ((wv * lv - (lv - fr_pane) * (wv - en_pane) / 2) * fv);
                      } else if (shape == "5") {
                          filled_volume = 0.5 * ((wv * lv) + (wv * fr_pane) + (en_pane * lv) - (fr_pane * en_pane)) * fv;
                      }
                      result.tech_filled_volume = filled_volume;
                  }
              }
          } else {
              result.error = 'Please! Check Input';
              return result;
          }
      } else if (shape == "6" || shape == "7" || shape == "8") {
          if (!isNaN(height) && !isNaN(radius)) {
              const hv = convertCm(height, height_unit);
              const ra = convertCm(radius, radius_unit);

              if (shape == "6") {
                  volume = (Math.PI * ra * ra) * hv;
              } else if (shape == "7") {
                  volume = (Math.PI * ra * ra) * (hv / 2);
              } else if (shape == "8") {
                  volume = (Math.PI * ra * ra) * (hv / 4);
              }

              if (fill_depth != "" && !isNaN(fill_depth)) {
                  if (fill_depth > height) {
                      result.error = 'The fill depth cannot be greater than the height of the aquarium.';
                      return result;
                  } else {
                      const fv = convertCm(fill_depth, fill_depth_unit);
                      if (shape == "6") {
                          filled_volume = (Math.PI * ra * ra) * fv;
                      } else if (shape == "7") {
                          filled_volume = (Math.PI * ra * ra) * (fv / 2);
                      } else if (shape == "8") {
                          filled_volume = (Math.PI * ra * ra) * (fv / 4);
                      }
                      result.tech_filled_volume = filled_volume;
                  }
              }
          } else {
              result.error = 'Please! Check Input';
              return result;
          }
      } else if (shape == "9") {
          if (!isNaN(height) && !isNaN(radius_one) && !isNaN(radius_two)) {
              const hv = convertCm(height, height_unit);
              const r1 = convertCm(radius_one, radius_one_unit);
              const r2 = convertCm(radius_two, radius_two_unit);
              volume = (Math.PI * (hv * r1 * r2));

              if (fill_depth != "" && !isNaN(fill_depth)) {
                  if (fill_depth > height) {
                      result.error = 'The fill depth cannot be greater than the height of the aquarium.';
                      return result;
                  } else {
                      const fv = convertCm(fill_depth, fill_depth_unit);
                      filled_volume = (Math.PI * (r1 * r2 * fv));
                      result.tech_filled_volume = filled_volume;
                  }
              }
          } else {
              result.error = 'Please! Check Input';
              return result;
          }
      } else if (shape == "10") {
          if (!isNaN(long_side) && !isNaN(short_side) && !isNaN(height)) {
              const hv = convertCm(height, height_unit);
              const l1 = convertCm(long_side, long_side_unit);
              const l2 = convertCm(short_side, short_side_unit);
              volume = 0.5 * (l1 * l1 + 2 * l2 * l1 - l2 * l2) * hv;

              if (fill_depth != "" && !isNaN(fill_depth)) {
                  if (fill_depth > height) {
                      result.error = 'The fill depth cannot be greater than the height of the aquarium.';
                      return result;
                  } else {
                      const fv = convertCm(fill_depth, fill_depth_unit);
                      filled_volume = 0.5 * (l1 * l1 + 2 * l2 * l1 - l2 * l2) * fv;
                      result.tech_filled_volume = filled_volume;
                  }
              }
          } else {
              result.error = 'Please! Check Input';
              return result;
          }
      } else if (shape == "11") {
          if (!isNaN(len_one) && !isNaN(len_two) && !isNaN(wid_one) && !isNaN(wid_two) && !isNaN(height)) {
              const hv = convertCm(height, height_unit);
              const l1 = convertCm(len_one, len_one_unit);
              const l2 = convertCm(len_two, len_two_unit);
              const w1 = convertCm(wid_one, wid_one_unit);
              const w2 = convertCm(wid_two, wid_two_unit);
              volume = (((l1 - w2) * w1) + (l2 * w2)) * hv;

              if (fill_depth != "" && !isNaN(fill_depth)) {
                  if (fill_depth > height) {
                      result.error = 'The fill depth cannot be greater than the height of the aquarium.';
                      return result;
                  } else {
                      const fv = convertCm(fill_depth, fill_depth_unit);
                      filled_volume = (((l1 - w2) * w1) + (l2 * w2)) * fv;
                      result.tech_filled_volume = filled_volume;
                  }
              }
          } else {
              result.error = 'Please! Check Input';
              return result;
          }
      } else if (shape == "12") {
          if (!isNaN(len_one) && !isNaN(len_two) && !isNaN(height)) {
              const hv = convertCm(height, height_unit);
              const l1 = convertCm(len_one, len_one_unit);
              const l2 = convertCm(len_two, len_two_unit);
              volume = 0.5 * ((l1 * l2) * hv);

              if (fill_depth != "" && !isNaN(fill_depth)) {
                  if (fill_depth > height) {
                      result.error = 'The fill depth cannot be greater than the height of the aquarium.';
                      return result;
                  } else {
                      const fv = convertCm(fill_depth, fill_depth_unit);
                      filled_volume = 0.5 * ((l1 * l2) * fv);
                      result.tech_filled_volume = filled_volume;
                  }
              }
          } else {
              result.error = 'Please! Check Input';
              return result;
          }
      } else if (shape == "13") {
          if (!isNaN(length) && !isNaN(width) && !isNaN(height) && !isNaN(full_width)) {
              if (full_width > width) {
                  const lv = convertCm(length, length_unit);
                  const wv = convertCm(width, width_unit);
                  const hv = convertCm(height, height_unit);
                  const fw = convertCm(full_width, full_width_unit);
                  const lvd = lv / 2;
                  const diff = fw - wv;

                  if (diff <= lvd) {
                      volume = (((Math.PI * (lv / 2) * (fw - wv)) / 2) + (lv * wv)) * hv;
                  } else {
                      result.error = 'The difference between full width and width should be smaller or equal to half of aquarium length';
                      return result;
                  }
              } else {
                  result.error = 'The full width should be greater than width';
                  return result;
              }
          } else {
              result.error = 'Please! Check Input';
              return result;
          }
      } else {
          result.error = 'Invalid shape type';
          return result;
      }

      result.tech_volume = volume;
      return result;
  }

      /**
    * getCalculationPlantSpacingCalculator: Service Method
    * POST: /api/calculators-lol/plant-spacing
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationPlantSpacingCalculator(body) {
      const bed = body.tech_bed;
      const grid = body.tech_grid;
      const hedgerows = parseFloat(body.tech_hedgerows) || 0;
      const length = parseFloat(body.tech_length) || 0;
      const length_unit = body.tech_length_unit;
      const width = parseFloat(body.tech_width) || 0;
      const width_unit = body.tech_width_unit;
      const want = body.tech_want;
      const border = parseFloat(body.tech_border) || 0;
      const border_unit = body.tech_border_unit;
      const plant_spacing = parseFloat(body.tech_plant_spacing) || 0;
      const plant_spacing_unit = body.tech_plant_spacing_unit;
      const row_spacing = parseFloat(body.tech_row_spacing) || 0;
      const row_spacing_unit = body.tech_row_spacing_unit;
      const hedge = parseFloat(body.tech_hedge) || 0;
      const hedge_unit = body.tech_hedge_unit;
      const total_plants = parseFloat(body.tech_total_plants) || 0;
      const total_rows = parseFloat(body.tech_total_rows) || 0;
      const no_of_plant = parseFloat(body.tech_no_of_plant) || 0;
      const plant_price = parseFloat(body.tech_plant_price) || 0;

      const result = {};

      const convertToMeter = (unit, value) => {
          if (unit == 'cm') {
              return value / 100;
          } else if (unit == 'm') {
              return value;
          } else if (unit == 'in') {
              return value / 39.37;
          } else if (unit == 'ft') {
              return value / 3.281;
          } else if (unit == 'yd') {
              return value / 1.094;
          } else if (unit == 'dm') {
              return value / 10;
          }
          return value;
      };

      // Calculate total plant cost
      if (!isNaN(no_of_plant) && !isNaN(plant_price)) {
          const total_plant_cost = no_of_plant * plant_price;
          result.tech_total_plant_cost = total_plant_cost;
      } else {
          result.error = 'Please! Check Your Input';
          return result;
      }

      if (bed == 'grid') {
          if (grid == 'square' || grid == 'rectangular' || grid == 'triangular') {
              if (!isNaN(length) && !isNaN(width) && !isNaN(border)) {
                  const length_m = convertToMeter(length_unit, length);
                  const width_m = convertToMeter(width_unit, width);
                  const border_m = convertToMeter(border_unit, border);
                  const area = length_m * width_m;

                  if (grid == 'square') {
                      if (!isNaN(plant_spacing) && plant_spacing !== 0) {
                          const plant_spacing_m = convertToMeter(plant_spacing_unit, plant_spacing);
                          
                          let plant_rows = 0;
                          let plant_cols = 0;
                          
                          if (plant_spacing_m !== 0) {
                              plant_rows = Math.ceil((length_m - (border_m * 2)) / plant_spacing_m);
                              plant_cols = Math.ceil((width_m - (border_m * 2)) / plant_spacing_m);
                          }
                          
                          const plants = plant_rows * plant_cols;

                          result.tech_plant_rows = plant_rows;
                          result.tech_plant_cols = plant_cols;
                          result.tech_plants = plants;
                          return result;
                      } else {
                          result.error = 'Please! Check Your Input';
                          return result;
                      }
                  } else if (grid == 'triangular') {
                      if (!isNaN(plant_spacing) && plant_spacing !== 0) {
                          const plant_spacing_m = convertToMeter(plant_spacing_unit, plant_spacing);
                          const row_spacing_calc = plant_spacing_m * 0.866;
                          
                          let odd_num_plant = 0;
                          let evn_num_plant = 0;
                          let total_rows_calc = 0;
                          
                          if (plant_spacing_m !== 0) {
                              odd_num_plant = Math.floor((length_m - (border_m * 2)) / plant_spacing_m);
                              evn_num_plant = Math.floor(((length_m - (border_m * 2)) - (plant_spacing_m * 0.5)) / plant_spacing_m);
                          }
                          
                          if (row_spacing_calc !== 0) {
                              total_rows_calc = Math.round((((width_m - (border_m * 2)) - plant_spacing_m) / row_spacing_calc) + 1);
                          }
                          
                          const evn_rows = Math.floor(total_rows_calc / 2);
                          const odd_rows = Math.floor(total_rows_calc - evn_rows);
                          const total_plants_calc = (evn_num_plant * evn_rows) + (odd_num_plant * odd_rows);

                          result.tech_total_plants = total_plants_calc;
                          result.tech_total_rows = total_rows_calc;
                          result.tech_row_spacing = Number(row_spacing_calc.toFixed(4));
                          result.tech_plant_spacing_m = Number(plant_spacing_m.toFixed(4));
                          result.tech_evn_rows = evn_rows;
                          result.tech_odd_rows = odd_rows;
                          result.tech_odd_num_plant = odd_num_plant;
                          result.tech_evn_num_plant = evn_num_plant;
                          return result;
                      } else {
                          result.error = 'Please! Check Your Input';
                          return result;
                      }
                  } else if (grid == 'rectangular') {
                      if (want == 'amount') {
                          if (!isNaN(row_spacing) && !isNaN(plant_spacing) && plant_spacing !== 0) {
                              const plant_spacing_m = convertToMeter(plant_spacing_unit, plant_spacing);
                              const row_spacing_m = convertToMeter(row_spacing_unit, row_spacing);
                              
                              let plant_rows = 0;
                              let plant_cols = 0;
                              
                              if (row_spacing_m !== 0) {
                                  plant_rows = Math.ceil((length_m - (border_m * 2)) / row_spacing_m);
                              }
                              
                              if (plant_spacing_m !== 0) {
                                  plant_cols = Math.ceil((width_m - (border_m * 2)) / plant_spacing_m);
                              }
                              
                              const plants = plant_rows * plant_cols;

                              result.tech_plant_rows = plant_rows;
                              result.tech_plant_cols = plant_cols;
                              result.tech_plants = plants;
                              return result;
                          } else {
                              result.error = 'Please! Check Your Input';
                              return result;
                          }
                      } else if (want == 'arrange') {
                          if (!isNaN(total_rows) && !isNaN(total_plants)) {
                              const cols = total_plants / total_rows;
                              const row_space = (length_m - (border_m * 2)) / total_rows;
                              const plant_spacing_calc = (width_m - (border_m * 2)) / cols;

                              result.tech_cols = cols;
                              result.tech_row_space = Number(row_space.toFixed(4));
                              result.tech_plant_spacing = Number(plant_spacing_calc.toFixed(4));
                              return result;
                          } else {
                              result.error = 'Please! Check Your Input';
                              return result;
                          }
                      }
                  }
              } else {
                  result.error = 'Please! Check Your Input';
                  return result;
              }
          }
      } else {
          if (want == 'amount') {
              if (!isNaN(hedge) && !isNaN(plant_spacing) && !isNaN(hedgerows)) {
                  const plant_spacing_m = convertToMeter(plant_spacing_unit, plant_spacing);
                  const hedge_m = convertToMeter(hedge_unit, hedge);
                  
                  let plant_per_row = 0;
                  if (plant_spacing_m !== 0) {
                      plant_per_row = hedge_m / plant_spacing_m;
                  }
                  
                  const total_plants_calc = Math.round(plant_per_row * hedgerows);

                  result.tech_total_plants = total_plants_calc;
                  return result;
              } else {
                  result.error = 'Please! Check Your Input';
                  return result;
              }
          } else {
              if (!isNaN(hedge) && !isNaN(total_plants) && !isNaN(hedgerows)) {
                  const hedge_m = convertToMeter(hedge_unit, hedge);
                  const plant_space = hedge_m / total_plants;
                  const plant_per_row = Math.round(total_plants / hedgerows);

                  result.tech_plant_space = plant_space;
                  result.tech_plant_per_row = plant_per_row;
                  return result;
              } else {
                  result.error = 'Please! Check Your Input';
                  return result;
              }
          }
      }

      // If no condition matched
      result.error = 'Invalid input parameters';
      return result;
  }

    /**
    * getCalculationGasCalculator: Service Method
    * POST: /api/calculators-lol/gas-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

  async getCalculationGasCalculator(body) {
      const type = body.tech_type;
      const week_day = parseFloat(body.tech_week_day) || 0;
      const distance = parseFloat(body.tech_distance) || 0;
      const distance_unit = body.tech_distance_unit;
      const price = parseFloat(body.tech_price) || 0;
      const price_unit = body.tech_price_unit;
      const trip_type = parseFloat(body.tech_trip_type) || 0;
      const peoples = parseFloat(body.tech_peoples) || 0;
      const name_v1 = body.tech_name_v1;
      const fule_effi_v1 = parseFloat(body.tech_fule_effi_v1) || 0;
      const fule_effi_v1_unit = body.tech_fule_effi_v1_unit;
      const name_v2 = body.tech_name_v2;
      const fule_effi_v2 = parseFloat(body.tech_fule_effi_v2) || 0;
      const fule_effi_v2_unit = body.tech_fule_effi_v2_unit;
      const currancy = body.tech_currancy;

      const result = {};

      // Helper functions
      const convertToMile = (unit, value) => {
          if (unit == 'km') {
              return value / 1.609;
          } else {
              return value;
          }
      };

      const convertToKm = (unit, value) => {
          if (unit == 'mi') {
              return value * 1.609;
          } else {
              return value;
          }
      };

      const convertToMpg = (unit, value) => {
          if (unit == 'kmpl') {
              return value * 2.352;
          } else {
              return value;
          }
      };

      const convertToKmpl = (unit, value) => {
          if (unit == 'mpg') {
              return value / 2.352;
          } else {
              return value;
          }
      };

      // Remove currency symbol from price_unit
      const cleanPriceUnit = price_unit.replace(currancy, '');

      // Validate required inputs
      if (type && trip_type && name_v1 && !isNaN(fule_effi_v2) && name_v2 && 
          !isNaN(distance) && !isNaN(week_day) && !isNaN(price) && !isNaN(fule_effi_v1)) {
          
          let distance_f, fule_effi_v1_f, fule_effi_v2_f, price_f;

          if (distance_unit == 'km') {
              distance_f = convertToKm(distance_unit, distance);
              fule_effi_v1_f = convertToKmpl(fule_effi_v1_unit, fule_effi_v1);
              fule_effi_v2_f = convertToKmpl(fule_effi_v2_unit, fule_effi_v2);
              price_f = (cleanPriceUnit == " liter") ? price : price / 3.785;
          } else {
              distance_f = convertToMile(distance_unit, distance);
              fule_effi_v1_f = convertToMpg(fule_effi_v1_unit, fule_effi_v1);
              fule_effi_v2_f = convertToMpg(fule_effi_v2_unit, fule_effi_v2);
              price_f = (cleanPriceUnit == " gallon") ? price : price * 3.785;
          }

          if (type == "first") {
              const fule_req = Number((distance_f / fule_effi_v1_f).toFixed(2));
              const fule_price_daily = Number((fule_req * price_f).toFixed(2));

              const fule_req_weekly = Number((fule_req * week_day).toFixed(2));
              const fule_price_weekly = Number((fule_price_daily * week_day).toFixed(2));

              const fule_req_biweekly = Number((fule_req_weekly * 2).toFixed(2));
              const fule_price_biweekly = Number((fule_price_weekly * 2).toFixed(2));

              const fule_req_monthly = Number((fule_req_weekly * 4.345).toFixed(2));
              const fule_price_monthly = Number((fule_price_weekly * 4.345).toFixed(2));

              const fule_req_yearly = Number((fule_req_weekly * 52).toFixed(2));
              const fule_price_yearly = Number((fule_price_weekly * 52).toFixed(2));

              if (peoples && !isNaN(peoples)) {
                  const each_pay = Number((fule_price_daily / peoples).toFixed(2));
                  result.tech_each_pay = each_pay;
              }

              result.tech_fule_req = fule_req;
              result.tech_fule_req_weekly = fule_req_weekly;
              result.tech_fule_req_biweekly = fule_req_biweekly;
              result.tech_fule_req_monthly = fule_req_monthly;
              result.tech_fule_req_yearly = fule_req_yearly;
              result.tech_fule_price_daily = fule_price_daily;
              result.tech_fule_price_weekly = fule_price_weekly;
              result.tech_fule_price_biweekly = fule_price_biweekly;
              result.tech_fule_price_monthly = fule_price_monthly;
              result.tech_fule_price_yearly = fule_price_yearly;
              return result;

          } else {
              const fule_req_v1 = Number(((distance_f * trip_type) / fule_effi_v1_f).toFixed(2));
              const price_price_v1 = Number((fule_req_v1 * price_f).toFixed(2));

              const fule_req_v2 = Number(((distance_f * trip_type) / fule_effi_v2_f).toFixed(2));
              const price_price_v2 = Number((fule_req_v2 * price_f).toFixed(2));

              const diff = Math.abs(price_price_v1 - price_price_v2);
              const weekly_saving = Number((diff * week_day).toFixed(2));
              const monthly_saving = Number((weekly_saving * 4.345).toFixed(2));
              const yearly_saving = Number((weekly_saving * 52).toFixed(2));

              result.tech_fule_req_v1 = fule_req_v1;
              result.tech_price_price_v1 = price_price_v1;
              result.tech_fule_req_v2 = fule_req_v2;
              result.tech_price_price_v2 = price_price_v2;
              result.tech_diff = diff;
              result.tech_weekly_saving = weekly_saving;
              result.tech_monthly_saving = monthly_saving;
              result.tech_yearly_saving = yearly_saving;
              return result;
          }
      } else {
          result.error = 'Please! Check Your Input';
          return result;
      }
  }


      /**
    * getCalculationHowManyPagesCalculator: Service Method
    * POST: /api/calculators-lol/how-many-pages-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationHowManyPagesCalculator(body) {
        const page = parseFloat(body.tech_page) || 0;
        const size = body.tech_size;
        const font = body.tech_font;
        const space = body.tech_space;
        const page2 = parseFloat(body.tech_page2) || 0;
        const title = body.tech_title;
        const lang = body.tech_lang;
        const main = parseInt(body.tech_main) || 0;

        const result = {};

        if (main == 1) {
            const fontSize = body.tech_size;
            const fontStyle = body.tech_font;
            const spacing = body.tech_space;
            const totalWords = parseFloat(body.tech_page) || 0;

            const data = {
                'Times': {
                    '10': { 'single': 900, '1.5': 600, 'double': 400 },
                    '11': { 'single': 650, '1.5': 440, 'double': 320 },
                    '12': { 'single': 650, '1.5': 400, 'double': 300 },
                    '13': { 'single': 470, '1.5': 320, 'double': 220 },
                    '14': { 'single': 475, '1.5': 300, 'double': 230 }
                },
                'Calibri': {
                    '10': { 'single': 900, '1.5': 560, 'double': 400 },
                    '11': { 'single': 600, '1.5': 385, 'double': 280 },
                    '12': { 'single': 650, '1.5': 400, 'double': 300 },
                    '13': { 'single': 435, '1.5': 270, 'double': 210 },
                    '14': { 'single': 430, '1.5': 300, 'double': 200 }
                },
                'Courier': {
                    '10': { 'single': 650, '1.5': 450, 'double': 300 },
                    '12': { 'single': 450, '1.5': 310, 'double': 250 },
                    '13': { 'single': 325, '1.5': 210, 'double': 160 },
                    '14': { 'single': 350, '1.5': 220, 'double': 170 }
                },
                'Garamond': {
                    '10': { 'single': 1000, '1.5': 630, 'double': 480 },
                    '11': { 'single': 680, '1.5': 460, 'double': 320 },
                    '12': { 'single': 700, '1.5': 450, 'double': 310 },
                    '13': { 'single': 500, '1.5': 320, 'double': 220 },
                    '14': { 'single': 500, '1.5': 310, 'double': 240 }
                },
                'Verdana': {
                    '10': { 'single': 750, '1.5': 480, 'double': 370 },
                    '11': { 'single': 500, '1.5': 325, 'double': 220 },
                    '12': { 'single': 500, '1.5': 310, 'double': 230 },
                    '13': { 'single': 350, '1.5': 220, 'double': 170 },
                    '14': { 'single': 370, '1.5': 240, 'double': 200 }
                },
                'Arial': {
                    '10': { 'single': 890, '1.5': 600, 'double': 400 },
                    '11': { 'single': 600, '1.5': 410, 'double': 310 },
                    '12': { 'single': 600, '1.5': 360, 'double': 260 },
                    '13': { 'single': 430, '1.5': 285, 'double': 210 },
                    '14': { 'single': 460, '1.5': 280, 'double': 200 }
                },
                'Helvetica': {
                    '10': { 'single': 750, '1.5': 500, 'double': 480 },
                    '11': { 'single': 635, '1.5': 440, 'double': 320 },
                    '12': { 'single': 560, '1.5': 360, 'double': 280 },
                    '13': { 'single': 460, '1.5': 320, 'double': 220 },
                    '14': { 'single': 400, '1.5': 260, 'double': 190 }
                },
                'Century Gothic': {
                    '10': { 'single': 600, '1.5': 430, 'double': 310 },
                    '11': { 'single': 490, '1.5': 360, 'double': 220 },
                    '12': { 'single': 560, '1.5': 280, 'double': 210 },
                    '13': { 'single': 380, '1.5': 220, 'double': 190 },
                    '14': { 'single': 315, '1.5': 200, 'double': 150 }
                },
                'Candara': {
                    '10': { 'single': 670, '1.5': 460, 'double': 350 },
                    '11': { 'single': 550, '1.5': 385, 'double': 280 },
                    '12': { 'single': 590, '1.5': 315, 'double': 220 },
                    '13': { 'single': 420, '1.5': 260, 'double': 190 },
                    '14': { 'single': 350, '1.5': 220, 'double': 170 }
                },
                'Cambria': {
                    '10': { 'single': 710, '1.5': 490, 'double': 360 },
                    '11': { 'single': 590, '1.5': 400, 'double': 300 },
                    '12': { 'single': 490, '1.5': 320, 'double': 220 },
                    '13': { 'single': 435, '1.5': 270, 'double': 190 },
                    '14': { 'single': 380, '1.5': 220, 'double': 170 }
                }
            };

            // Check if font style and size exist in data
            if (!data[fontStyle] || !data[fontStyle][fontSize]) {
                result.error = 'Invalid font style or size';
                return result;
            }

            const wordsPerPage = data[fontStyle][fontSize][spacing];

            if (!isNaN(totalWords) && totalWords > 0) {
                if (wordsPerPage && wordsPerPage > 0) {
                    const pages = Math.ceil(totalWords / wordsPerPage);
                    result.tech_counter = pages;
                } else {
                    result.error = 'Invalid spacing value';
                    return result;
                }
            } else {
                result.error = 'Please add Number of Words';
                return result;
            }
            return result;
        } else {
            if (title != 'Empty' && page2 != '' && page2 != 0) {
                result.error = "Please choose either a title or a Enter length (not both).";
                return result;
            } else {
                let counter = 0;

                if (title == "Empty") {
                    if (!page2 || page2 == 0) {
                        result.error = "Please choose either a title or a Enter length (not both).";
                        return result;
                    } else {
                        counter = page2 / 242;
                    }
                } else if (title == 'Quran') {
                    counter = 604;
                } else if (title == 'Bible') {
                    counter = 1120;
                } else if (title == 'Gatsby') {
                    counter = 218;
                } else if (title == 'Harry') {
                    counter = 3407;
                } else if (title == 'Av_noval') {
                    counter = 300;
                } else if (title == 'Hobbit') {
                    counter = 310;
                } else if (title == 'Rings') {
                    counter = 1191;
                } else if (title == 'Peace') {
                    counter = 1225;
                } else if (title == 'Pride') {
                    counter = 248;
                } else if (title == 'Rich') {
                    counter = 336;
                } else if (title == 'War') {
                    counter = 1400;
                } else if (title == 'Great_Ex') {
                    counter = 544;
                } else if (title == 'Shakespearean') {
                    counter = 444;
                } else {
                    result.error = 'Invalid title selected';
                    return result;
                }

                result.tech_counter = Number(counter.toFixed(0));
                return result;
            }
        }
    }

       /**
    * getCalculationHowManyWordsCalculator: Service Method
    * POST: /api/calculators-lol/how-many-words-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationHowManyWordsCalculator(body) {
      const page = parseFloat(body.tech_page) || 0;
      const size = body.tech_size;
      const font = body.tech_font;
      const space = body.tech_space;
      const page2 = parseFloat(body.tech_page2) || 0;
      const title = body.tech_title;
      const sp_title = body.tech_sp_title;
      const lang = body.tech_lang;
      const main = parseInt(body.tech_main) || 0;

      const result = {};

      if (main == 1) {
          const fontSize = body.tech_size;
          const fontStyle = body.tech_font;
          const spacing = body.tech_space;
          let wordCount = 0;

          const data = {
              'Times': {
                  '10': { 'single': 900, '1.5': 600, 'double': 400 },
                  '11': { 'single': 650, '1.5': 440, 'double': 320 },
                  '12': { 'single': 650, '1.5': 400, 'double': 300 },
                  '13': { 'single': 470, '1.5': 320, 'double': 220 },
                  '14': { 'single': 475, '1.5': 300, 'double': 230 }
              },
              'Calibri': {
                  '10': { 'single': 900, '1.5': 560, 'double': 400 },
                  '11': { 'single': 600, '1.5': 385, 'double': 280 },
                  '12': { 'single': 650, '1.5': 400, 'double': 300 },
                  '13': { 'single': 435, '1.5': 270, 'double': 210 },
                  '14': { 'single': 430, '1.5': 300, 'double': 200 }
              },
              'Courier': {
                  '10': { 'single': 650, '1.5': 450, 'double': 300 },
                  '12': { 'single': 450, '1.5': 310, 'double': 250 },
                  '13': { 'single': 325, '1.5': 210, 'double': 160 },
                  '14': { 'single': 350, '1.5': 220, 'double': 170 }
              },
              'Garamond': {
                  '10': { 'single': 1000, '1.5': 630, 'double': 480 },
                  '11': { 'single': 680, '1.5': 460, 'double': 320 },
                  '12': { 'single': 700, '1.5': 450, 'double': 310 },
                  '13': { 'single': 500, '1.5': 320, 'double': 220 },
                  '14': { 'single': 500, '1.5': 310, 'double': 240 }
              },
              'Verdana': {
                  '10': { 'single': 750, '1.5': 480, 'double': 370 },
                  '11': { 'single': 500, '1.5': 325, 'double': 220 },
                  '12': { 'single': 500, '1.5': 310, 'double': 230 },
                  '13': { 'single': 350, '1.5': 220, 'double': 170 },
                  '14': { 'single': 370, '1.5': 240, 'double': 200 }
              },
              'Arial': {
                  '10': { 'single': 890, '1.5': 600, 'double': 400 },
                  '11': { 'single': 600, '1.5': 410, 'double': 310 },
                  '12': { 'single': 600, '1.5': 360, 'double': 260 },
                  '13': { 'single': 430, '1.5': 285, 'double': 210 },
                  '14': { 'single': 460, '1.5': 280, 'double': 200 }
              },
              'Helvetica': {
                  '10': { 'single': 750, '1.5': 500, 'double': 480 },
                  '11': { 'single': 635, '1.5': 440, 'double': 320 },
                  '12': { 'single': 560, '1.5': 360, 'double': 280 },
                  '13': { 'single': 460, '1.5': 320, 'double': 220 },
                  '14': { 'single': 400, '1.5': 260, 'double': 190 }
              },
              'Century Gothic': {
                  '10': { 'single': 600, '1.5': 430, 'double': 310 },
                  '11': { 'single': 490, '1.5': 360, 'double': 220 },
                  '12': { 'single': 560, '1.5': 280, 'double': 210 },
                  '13': { 'single': 380, '1.5': 220, 'double': 190 },
                  '14': { 'single': 315, '1.5': 200, 'double': 150 }
              },
              'Candara': {
                  '10': { 'single': 670, '1.5': 460, 'double': 350 },
                  '11': { 'single': 550, '1.5': 385, 'double': 280 },
                  '12': { 'single': 590, '1.5': 315, 'double': 220 },
                  '13': { 'single': 420, '1.5': 260, 'double': 190 },
                  '14': { 'single': 350, '1.5': 220, 'double': 170 }
              },
              'Cambria': {
                  '10': { 'single': 710, '1.5': 490, 'double': 360 },
                  '11': { 'single': 590, '1.5': 400, 'double': 300 },
                  '12': { 'single': 490, '1.5': 320, 'double': 220 },
                  '13': { 'single': 435, '1.5': 270, 'double': 190 },
                  '14': { 'single': 380, '1.5': 220, 'double': 170 }
              }
          };

          if (page && !isNaN(page)) {
              // Check if font data exists
              if (data[fontStyle] && data[fontStyle][fontSize] && data[fontStyle][fontSize][spacing]) {
                  const wordsPerPage = data[fontStyle][fontSize][spacing];
                  wordCount = wordsPerPage * page;
              } else {
                  result.error = 'Invalid font style, size, or spacing';
                  return result;
              }
          } else {
              result.error = 'Please add Number of Pages';
              return result;
          }
          
          result.tech_counter = wordCount;
          return result;

      } else if (main == 2) {
          if (title != 'Empty' && page2 != '' && page2 != 0) {
              result.error = "Please choose either a title or a Enter length (not both).";
              return result;
          } else {
              let counter = 0;

              if (title == "Empty") {
                  if (!page2 || isNaN(page2)) {
                      result.error = "Please choose either a title or a Enter length (not both).";
                      return result;
                  } else {
                      counter = page2 * 242;
                  }
              } else if (title == 'Quran') {
                  counter = 77439;
              } else if (title == 'Bible') {
                  counter = 783137;
              } else if (title == 'Gatsby') {
                  counter = 47094;
              } else if (title == 'Harry') {
                  counter = 1084170;
              } else if (title == 'Av_noval') {
                  counter = 90000;
              } else if (title == 'Hobbit') {
                  counter = 95022;
              } else if (title == 'Rings') {
                  counter = 455125;
              } else if (title == 'Peace') {
                  counter = 587287;
              } else if (title == 'Pride') {
                  counter = 122204;
              } else if (title == 'Rich') {
                  counter = 72000;
              } else if (title == 'War') {
                  counter = 587287;
              } else if (title == 'Great_Ex') {
                  counter = 132500;
              } else if (title == 'Shakespearean') {
                  counter = 29551;
              } else {
                  result.error = 'Invalid title selected';
                  return result;
              }

              result.counter = counter.toLocaleString();
              return result;
          }
      } else if (main == 3) {
          const currentTitle = sp_title;
          
          if (currentTitle != 'Empty' && page2 != '' && page2 != 0) {
              result.error = "Please choose either a title or a Enter length (not both).";
              return result;
          } else {
              let counter = 0;

              if (currentTitle == "Empty") {
                  if (!page2 || isNaN(page2)) {
                      result.error = "Please choose either a title or a Enter length (not both).";
                      return result;
                  } else {
                      counter = page2 * 130;
                  }
              } else if (currentTitle == 'Perfect') {
                  counter = 4891;
              } else if (currentTitle == 'Gettysburg') {
                  counter = 272;
              } else if (currentTitle == 'Dream') {
                  counter = 1667;
              } else if (currentTitle == 'Beaches') {
                  counter = 3855;
              } else {
                  result.error = 'Invalid special title selected';
                  return result;
              }

              result.tech_counter = counter.toLocaleString();
              return result;
          }
      } else if (main == 4) {
          let counter = 0;

          if (lang == 'English') {
              counter = 170000;
          } else if (lang == 'French') {
              counter = 70000;
          } else if (lang == 'German') {
              counter = 145000;
          } else if (lang == 'Russian') {
              counter = 150000;
          } else if (lang == 'Spanish') {
              counter = 93000;
          } else if (lang == 'Japanese') {
              counter = 500000;
          } else if (lang == 'Korean') {
              counter = 511282;
          } else if (lang == 'Portuguese') {
              counter = 818000;
          } else if (lang == 'Swedish') {
              counter = 600000;
          } else if (lang == 'Italian') {
              counter = 500000;
          } else if (lang == 'Hindi') {
              counter = 183175;
          } else if (lang == 'Urdu') {
              counter = 286563;
          } else if (lang == 'Arabic') {
              counter = 170000;
          } else if (lang == 'Turkish') {
              counter = 316000;
          } else if (lang == 'Chinese') {
              counter = 370000;
          } else {
              result.error = 'Invalid language selected';
              return result;
          }

          result.tech_counter = counter.toLocaleString();
          return result;
      } else {
          result.error = 'Invalid main mode selected';
          return result;
      }
  }


    /**
    * getCalculationWeightlossCalculator: Service Method
    * POST: /api/calculators-lol/weightloss-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

   async getCalculationWeightlossCalculator(body) {
    // Extract request data
    const submit = body.tech_unit;
    const gender = body.tech_gender;
    const age = body.tech_age;
    const height_ft = body.tech_height_ft;
    const height_in = body.tech_height_in;
    const height_cm = body.tech_height_cm;
    const hightUnit = body.tech_hightUnit;
    const weight = body.tech_weight;
    const lose_w = body.tech_lose_w;
    const lose_unit = body.tech_lose_unit;
    const activity = body.tech_activity;
    const weight_unit = body.tech_unit;
    const start = body.tech_start;
    const end = body.tech_target;
    const choose = body.tech_choose;
    const enter_calories = body.tech_enter_calories;

      const all_activites = [
        [2.3, "Activity promoting video game (e.g., Wii Fit), light effort (e.g., balance, yoga)", 'Activity promoting video game'],
        [3.8, "Activity promoting video game (e.g., Wii Fit), moderate effort (e.g., aerobic, resistance)", 'Activity promoting video game'],
        [7.2, "Activity promoting video/arcade game (e.g., Exergaming, Dance Dance Revolution), vigorous effort", 'Activity promoting video game'],
        [10.0, "Aerobic dance wearing 10-15 lb weights", 'aerobics'],
        [7.3, "Aerobic, general", 'aerobics'],
        [7.3, "Aerobic, high impact", 'aerobics'],
        [5.0, "Aerobic, low impact", 'aerobics'],
        [9.5, "Aerobic, step, with 10 - 12 inch step", 'aerobics'],
        [5.5, "Aerobic, step, with 4-inch step", 'aerobics'],
        [7.5, "Aerobic, step, with 6 - 8 inch step", 'aerobics'],
        [5.5, "Alaska Native Games, Eskimo Olympics, general", 'Alaska Native Games'],
        [5.5, "Anishinaabe Jingle Dancing", 'Anishinaabe Jingle Dancing'],
        [4.3, "Archery, non-hunting", 'Archery'],
        [5.0, "Army type obstacle course exercise, boot camp training program", 'Army type obstacle course exercise'],
        [8.5, "Auto racing, open wheel", 'Auto racing'],
        [2.5, "Automobile or light truck (not a semi) driving", 'Automobile or light truck driving'],
        [7.0, "Backpacking (Taylor Code 050)", 'Backpacking'],
        [7.8, "Backpacking, hiking or organized walking with a daypack", 'Backpacking'],
        [7.0, "Badminton, competitive (Taylor Code 450)", 'Badminton'],
        [5.5, "Badminton, social singles and doubles, general", 'Badminton'],
        [5.0, "Ballet, modern, or jazz, general, rehearsal or class", 'Ballet, modern, or jazz'],
        [6.8, "Ballet, modern, or jazz, performance, vigorous effort", 'Ballet, modern, or jazz'],
        [11.3, "Ballroom dancing, competitive, general", 'Ballroom'],
        [5.5, "Ballroom, fast (Taylor Code 125)", 'Ballroom'],
        [3.0, "Ballroom, slow (e.g., waltz, foxtrot, slow dancing, samba, tango, 19th century dance, mambo, cha cha)", 'Ballroom'],
        [9.3, "Basketball, drills, practice", 'Basketball'],
        [8.0, "Basketball, game (Taylor Code 490)", 'Basketball'],
        [6.5, "Basketball, general", 'Basketball'],
        [6.0, "Basketball, non-game, general (Taylor Code 480)", 'Basketball'],
        [7.0, "Basketball, officiating (Taylor Code 500)", 'Basketball'],
        [4.5, "Basketball, shooting baskets", 'Basketball'],
        [7.8, "Basketball, wheelchair", 'Basketball'],
        [8.5, "Bench step class, general", 'Bench step class'],
        [6.8, "Bicycling, 10-11.9 mph, leisure, slow, light effort", 'Bicycling'],
        [8.5, "Bicycling, 12 mph, seated, hands on brake hoods or bar drops, 80 rpm", 'Bicycling'],
        [9.0, "Bicycling, 12 mph, standing, hands on brake hoods, 60 rpm", 'Bicycling'],
        [8.0, "Bicycling, 12-13.9 mph, leisure, moderate effort", 'Bicycling'],
        [10.0, "Bicycling, 14-15.9 mph, racing or leisure, fast, vigorous effort", 'Bicycling'],
        [12.0, "Bicycling, 16-19 mph, racing/not drafting or > 19 mph drafting, very fast, racing general", 'Bicycling'],
        [4.0, "Bicycling, <10 mph, leisure, to work or for pleasure (Taylor Code 115)", 'Bicycling'],
        [15.8, "Bicycling, > 20 mph, racing, not drafting", 'Bicycling'],
        [8.5, "Bicycling, BMX", 'Bicycling'],
        [7.5, "Bicycling, general", 'Bicycling'],
        [3.5, "Bicycling, leisure, 5.5 mph", 'Bicycling'],
        [5.8, "Bicycling, leisure, 9.4 mph", 'Bicycling'],
        [16.0, "Bicycling, mountain, competitive, racing", 'Bicycling'],
        [8.5, "Bicycling, mountain, general", 'Bicycling'],
        [14.0, "Bicycling, mountain, uphill, vigorous", 'Bicycling'],
        [5.8, "Bicycling, on dirt or farm road, moderate pace", 'Bicycling'],
        [8.8, "Bicycling, stationary, 101-160 watts, vigorous effort", 'Bicycling'],
        [11.0, "Bicycling, stationary, 161-200 watts, vigorous effort", 'Bicycling'],
        [14.0, "Bicycling, stationary, 201-270 watts, very vigorous effort", 'Bicycling'],
        [3.5, "Bicycling, stationary, 30-50 watts, very light to light effort", 'Bicycling'],
        [4.8, "Bicycling, stationary, 51-89 watts, light-to-moderate effort", 'Bicycling'],
        [6.8, "Bicycling, stationary, 90-100 watts, moderate to vigorous effort", 'Bicycling'],
        [7.0, "Bicycling, stationary, general", 'Bicycling'],
        [8.5, "Bicycling, stationary, RPM/Spin bike class", 'Bicycling'],
        [6.8, "Bicycling, to/from work, self selected pace", 'Bicycling'],
        [2.5, "Billiards", 'Billiards'],
        [2.5, "Bird watching, slow walk", 'Bird watching'],
        [2.5, "Boating, power, driving", 'Boating'],
        [1.3, "Boating, power, passenger, light", 'Boating'],
        [3.0, "Bowling (Taylor Code 390)", 'Bowling'],
        [3.8, "Bowling, indoor, bowling alley", 'Bowling'],
        [12.8, "Boxing, in ring, general", 'Boxing'],
        [5.5, "Boxing, punching bag", 'Boxing'],
        [7.8, "Boxing, sparring", 'Boxing'],
        [7.0, "Broomball", 'Broomball'],
        [8.0, "Calisthenics (e.g., push ups, sit ups, pull-ups, jumping jacks), vigorous effort", 'Calisthenics'],
        [3.8, "Calisthenics (e.g., push ups, sit ups, pull-ups, lunges), moderate effort", 'Calisthenics'],
        [2.8, "Calisthenics (e.g., situps, abdominal crunches), light effort", 'Calisthenics'],
        [3.5, "Calisthenics, light or moderate effort, general (e.g., back exercises), going up & down from floor (Taylor Code 150)", 'Calisthenics'],
        [3.3, "Canoeing, harvesting wild rice, knocking rice off the stalks", 'Canoeing'],
        [4.0, "Canoeing, on camping trip (Taylor Code 270)", 'Canoeing'],
        [7.0, "Canoeing, portaging", 'Canoeing'],
        [2.8, "Canoeing, rowing, 2.0-3.9 mph, light effort", 'Canoeing'],
        [5.8, "Canoeing, rowing, 4.0-5.9 mph, moderate effort", 'Canoeing'],
        [3.5, "Canoeing, rowing, for pleasure, general (Taylor Code 250)", 'Canoeing'],
        [12.0, "Canoeing, rowing, in competition, or crew or sculling (Taylor Code 260)", 'Canoeing'],
        [12.5, "Canoeing, rowing, kayaking, competition, >6 mph, vigorous effort", 'Canoeing'],
        [3.5, "Caribbean dance (Abakua, Beguine, Bellair, Bongo, Brukin's, Caribbean Quadrills, Dinki Mini, Gere, Gumbay, Ibo, Jonkonnu, Kumina, Oreisha, Jambu)", '0'],
        [5.0, "Carrying 1 to 15 lb load, upstairs", 'Carrying'],
        [2.3, "Carrying 15 lb child, slow walking", 'Carrying'],
        [5.0, "Carrying 15 pound load (e.g. suitcase), level ground or downstairs", 'Carrying'],
        [6.0, "Carrying 16 to 24 lb load, upstairs", 'Carrying'],
        [8.0, "Carrying 25 to 49 lb load, upstairs", 'Carrying'],
        [10.0, "Carrying 50 to 74 lb load, upstairs", 'Carrying'],
        [12.0, "Carrying > 74 lb load, upstairs", 'Carrying'],
        [8.3, "Carrying load upstairs, general", 'Carrying'],
        [6.0, "Cheerleading, gymnastic moves, competitive", 'Cheerleading'],
        [5.8, "Children's games, adults playing (e.g., hopscotch, 4-square, dodgeball, playground apparatus, t-ball, tetherball, marbles, arcade games), moderate effort", 'Childrens games'],
        [8.0, "Circuit training, including kettlebells, some aerobic movement with minimal rest, general, vigorous intensity", 'Circuit training'],
        [4.3, "Circuit training, moderate effort", 'Circuit training'],
        [6.5, "Climbing hills with 0 to 9 lb load", 'Climbing'],
        [7.3, "Climbing hills with 10 to 20 lb load", 'Climbing'],
        [8.3, "Climbing hills with 21 to 42 lb load", 'Climbing'],
        [9.0, "Climbing hills with 42+ lb load", 'Climbing'],
        [6.3, "Climbing hills, no load", 'Climbing'],
        [8.0, "Coaching, actively playing sport with players", 'Coaching'],
        [4.0, "Coaching, football, soccer, basketball, baseball, swimming, etc.", 'Coaching'],
        [4.8, "Cricket, batting, bowling, fielding", 'Cricket'],
        [3.3, "Croquet", 'Croquet'],
        [4.0, "Curling", 'Curling'],
        [3.5, "Curves(TM) Eexercise routines in women", 'Curves'],
        [2.5, "Darts, wall or lawn", 'Darts'],
        [3.5, "Descending stairs", 'Descending'],
        [3.0, "Diving, springboard or platform", 'Diving'],
        [7.5, "Dog sledding, mushing", 'Dog sledding'],
        [2.5, "Dog sledding, passenger", 'Dog sledding'],
        [6.0, "Drag racing, pushing or driving a car", 'Drag racing'],
        [5.0, "Elliptical trainer, moderate effort", 'Elliptical trainer'],
        [4.5, "Ethnic or cultural dancing (e.g., Greek, Middle Eastern, hula, salsa, merengue, bamba y plena, flamenco, belly, and swing)", 'Ethnic'],
        [6.0, "Fencing", 'Fencing'],
        [1.8, "Flying airplane or helicopter", 'Flying airplane'],
        [2.5, "Football or baseball, playing catch", 'Football'],
        [8.0, "Football, competitive", 'Football'],
        [8.0, "Football, touch, flag, general (Taylor Code 510)", 'Football'],
        [4.0, "Football, touch, flag, light effort", 'Football'],
        [3.0, "Frisbee playing, general", 'Frisbee'],
        [8.0, "Frisbee, ultimate", 'Frisbee'],
        [7.8, "General dancing (e.g., disco, folk, Irish step dancing, line dancing, polka, contra, country)", 'General dancing'],
        [4.8, "Golf, general", 'Golf'],
        [3.0, "Golf, miniature, driving range", 'Golf'],
        [3.5, "Golf, using power cart (Taylor Code 070)", 'Golf'],
        [4.3, "Golf, walking, carrying clubs", 'Golf'],
        [5.3, "Golf, walking, pulling clubs", 'Golf'],
        [3.8, "Gymnastics, general", 'Gymnastics'],
        [4.0, "Hacky sack", 'Hacky sack'],
        [12.0, "Handball, general (Taylor Code 520)", 'Handball'],
        [8.0, "Handball, team", 'Handball'],
        [3.5, "Hang gliding", 'Hang gliding'],
        [5.0, "Health club exercise classes, general, gym/weight training combined in one visit", 'Health club'],
        [7.8, "Health club exercise, conditioning classes", 'Health club'],
        [5.5, "Health club exercise, general (Taylor Code 160)", 'Health club'],
        [4.0, "High ropes course, multiple elements", 'High ropes course'],
        [5.3, "Hiking or walking at a normal pace through fields and hillsides", 'Hiking'],
        [6.0, "Hiking, cross country (Taylor Code 040)", 'Hiking'],
        [7.8, "Hockey, field", 'Hockey'],
        [10.0, "Hockey, ice, competitive", 'Hockey'],
        [8.0, "Hockey, ice, general", 'Hockey'],
        [3.8, "Home exercise, general", 'Home exercise'],
        [1.8, "Horse cart, driving, standing or sitting", 'Horse cart'],
        [4.3, "Horse chores, feeding, watering, cleaning stalls, implied walking and lifting loads", 'Horse chores'],
        [7.3, "Horseback riding, canter or gallop", 'Horseback riding'],
        [5.5, "Horseback riding, general", 'Horseback riding'],
        [9.0, "Horseback riding, jumping", 'Horseback riding'],
        [5.8, "Horseback riding, trotting", 'Horseback riding'],
        [3.8, "Horseback riding,walking", 'Horseback riding'],
        [3.0, "Horseshoe pitching, quoits", 'Horseshoe pitching'],
        [2.0, "Ice fishing, sitting", 'Ice fishing'],
        [12.0, "Jai alai", 'Jai alai'],
        [7.0, "Jet skiing, driving, in water", 'Jet skiing'],
        [6.0, "Jog/walk combination (jogging component of less than 10 minutes) (Taylor Code 180)", 'walk combination'],
        [7.0, "Jogging, general", 'Jogging'],
        [8.0, "Jogging, in place", 'Jogging'],
        [4.5, "Jogging, on a mini-tramp", 'Jogging'],
        [4.0, "Juggling", 'Juggling'],
        [5.0, "Kayaking, moderate effort", 'Kayaking'],
        [7.0, "Kickball", 'Kickball'],
        [8.0, "Lacrosse", 'Lacrosse'],
        [3.3, "Lawn bowling, bocce ball, outdoor", 'Lawn bowling'],
        [3.5, "Loading /unloading a car, implied walking", 'unloading a car'],
        [8.0, "Marching rapidly, military, no pack", 'Marching rapidly'],
        [4.5, "Marching, moderate speed, military, no pack", 'Marching'],
        [10.3, "Martial arts, different types, moderate pace (e.g., judo, jujitsu, karate, kick boxing, tae kwan do, tai-bo, Muay Thai boxing)", 'Martial arts'],
        [5.3, "Martial arts, different types, slower pace, novice performers, practice", 'Martial arts'],
        [4.0, "Moto-cross, off-road motor sports, all-terrain vehicle, general", 'Moto-cross'],
        [3.5, "Motor scooter, motorcycle", 'Motor scooter'],
        [6.0, "Moving ice house, set up/drill holes", 'Moving ice house'],
        [9.0, "Orienteering", 'Orienteering'],
        [6.0, "Paddle boarding, standing", 'Paddle boarding'],
        [4.0, "Paddle boat", 'Paddle boat'],
        [6.0, "Paddleball, casual, general (Taylor Code 460)", 'Paddleball'],
        [10.0, "Paddleball, competitive", 'Paddleball'],
        [3.0, "Pilates, general", 'Pilates'],
        [8.0, "Polo, on horseback", 'Polo'],
        [6.3, "Pulling rickshaw", 'Pulling rickshaw'],
        [3.8, "Pushing a wheelchair, non-occupational", 'Pushing a wheelchair'],
        [4.0, "Pushing or pulling stroller with child or walking with children, 2.5 to 3.1 mph", 'Pushing'],
        [6.0, "Pushing plane in and out of hangar", 'Pushing plane in and out of hangar'],
        [6.5, "Race walking", 'Race walking'],
        [10.0, "Racquetball, competitive", 'Racquetball'],
        [7.0, "Racquetball, general (Taylor Code 470)", 'Racquetball'],
        [3.5, "Resistance (weight) training, multiple exercises, 8-15 repetitions at varied resistance", 'Resistance'],
        [5.0, "Resistance (weight) training, squats , slow or explosive effort", 'Resistance'],
        [6.0, "Resistance training (weight lifting, free weight, nautilus or universal), power lifting or body building, vigorous effort (Taylor Code 210)", 'Resistance'],
        [1.3, "Riding in a bus or train", 'Riding in a bus or train'],
        [1.3, "Riding in a car or truck", 'Riding in a car or truck'],
        [5.8, "Rock climbing, ascending or traversing rock, low-to-moderate difficulty", 'Rock climbing'],
        [7.5, "Rock climbing, ascending rock, high difficulty", 'Rock climbing'],
        [5.0, "Rock climbing, rappelling", 'Rock climbing'],
        [8.0, "Rock or mountain climbing (Taylor Code 470) (Formerly code = 17120)", 'Rock or mountain climbing'],
        [4.0, "Rodeo sports, general, light effort", 'Rodeo sports'],
        [5.5, "Rodeo sports, general, moderate effort", 'Rodeo sports'],
        [7.0, "Rodeo sports, general, vigorous effort", 'Rodeo sports'],
        [7.5, "Rollerblading, in-line skating, 14.4 km/h (9.0 mph), recreational pace", 'Rollerblading'],
        [9.8, "Rollerblading, in-line skating, 17.7 km/h (11.0 mph), moderate pace, exercise training", 'Rollerblading'],
        [12.3, "Rollerblading, in-line skating, 21.0 to 21.7 km/h (13.0 to 13.6 mph), fast pace, exercise training", 'Rollerblading'],
        [14.0, "Rollerblading, in-line skating, 24.0 km/h (15.0 mph), maximal effort", 'Rollerblading'],
        [12.3, "Rope jumping, fast pace, 120-160 skips/min", 'Rope jumping'],
        [11.8, "Rope jumping, moderate pace, 100-120 skips/min, general, 2 foot skip, plain bounce", 'Rope jumping'],
        [8.8, "Rope jumping, slow pace, < 100 skips/min, 2 foot skip, rhythm bounce", 'Rope jumping'],
        [12.3, "Rope skipping, general", 'Rope skipping'],
        [6.0, "Rowing, stationary ergometer, general, vigorous effort", 'Rowing'],
        [7.0, "Rowing, stationary, 100 watts, moderate effort", 'Rowing'],
        [8.5, "Rowing, stationary, 150 watts, vigorous effort", 'Rowing'],
        [12.0, "Rowing, stationary, 200 watts, very vigorous effort", 'Rowing'],
        [4.8, "Rowing, stationary, general, moderate effort", 'Rowing'],
        [6.3, "Rugby, touch, non-competitive", 'Rugby'],
        [8.3, "Rugby, union, team, competitive", 'Rugby'],
        [8.0, "Running, (Taylor code 200)", 'Running'],
        [14.5, "Running, 10 mph (6 min/mile)", 'Running'],
        [16.0, "Running, 11 mph (5.5 min/mile)", 'Running'],
        [19.0, "Running, 12 mph (5 min/mile)", 'Running'],
        [19.8, "Running, 13 mph (4.6 min/mile)", 'Running'],
        [23.0, "Running, 14 mph (4.3 min/mile)", 'Running'],
        [6.0, "Running, 4 mph (13 min/mile)", 'Running'],
        [8.3, "Running, 5 mph (12 min/mile)", 'Running'],
        [9.0, "Running, 5.2 mph (11.5 min/mile)", 'Running'],
        [9.8, "Running, 6 mph (10 min/mile)", 'Running'],
        [10.5, "Running, 6.7 mph (9 min/mile)", 'Running'],
        [11.0, "Running, 7 mph (8.5 min/mile)", 'Running'],
        [11.5, "Running, 7.5 mph (8 min/mile)", 'Running'],
        [11.8, "Running, 8 mph (7.5 min/mile)", 'Running'],
        [12.3, "Running, 8.6 mph (7 min/mile)", 'Running'],
        [12.8, "Running, 9 mph (6.5 min/mile)", 'Running'],
        [9.0, "Running, cross country", 'Running'],
        [13.3, "Running, marathon", 'Running'],
        [10.0, "Running, on a track, team practice", 'Running'],
        [15.0, "Running, stairs, up", 'Running'],
        [8.0, "Running, training, pushing a wheelchair or baby carrier", 'Running'],
        [4.5, "Saddling, cleaning, grooming, harnessing and unharnessing horse", 'Saddling'],
        [3.0, "Sailing, boat and board sailing, windsurfing, ice sailing, general (Taylor Code 235)", 'Sailing'],
        [4.5, "Sailing, in competition", 'Sailing'],
        [3.3, "Sailing, Sunfish/Laser/Hobby Cat, Keel boats, ocean sailing, yachting, leisure", 'Sailing'],
        [3.0, "Shuffleboard", 'Shuffleboard'],
        [6.0, "Skateboarding, competitive, vigorous effort", 'Skateboarding'],
        [5.0, "Skateboarding, general, moderate effort", 'Skateboarding'],
        [7.0, "Skating, ice dancing", 'Skating'],
        [5.5, "Skating, ice, 9 mph or less", 'Skating'],
        [7.0, "Skating, ice, general (Taylor Code 360)", 'Skating'],
        [9.0, "Skating, ice, rapidly, more than 9 mph, not competitive", 'Skating'],
        [7.0, "Skating, roller (Taylor Code 360)", 'Skating'],
        [13.3, "Skating, speed, competitive", 'Skating'],
        [7.0, "Ski jumping, climb up carrying skis", 'Ski jumping'],
        [6.8, "Ski machine, general", 'Ski machine'],
        [6.8, "Skiing, cross country, 2.5 mph, slow or light effort, ski walking", 'Skiing'],
        [9.0, "Skiing, cross country, 4.0-4.9 mph, moderate speed and effort, general", 'Skiing'],
        [12.5, "Skiing, cross country, 5.0-7.9 mph, brisk speed, vigorous effort", 'Skiing'],
        [15.0, "Skiing, cross country, >8.0 mph, elite skier, racing", 'Skiing'],
        [15.5, "Skiing, cross country, hard snow, uphill, maximum, snow mountaineering", 'Skiing'],
        [13.5, "Skiing, cross-country, biathlon, skating technique", 'Skiing'],
        [13.3, "Skiing, cross-country, skating", 'Skiing'],
        [4.3, "Skiing, downhill, alpine or snowboarding, light effort, active time only", 'Skiing'],
        [5.3, "Skiing, downhill, alpine or snowboarding, moderate effort, general, active time only", 'Skiing'],
        [8.0, "Skiing, downhill, vigorous effort, racing", 'Skiing'],
        [7.0, "Skiing, general", 'Skiing'],
        [12.5, "Skiing, roller, elite racers", 'Skiing'],
        [6.0, "Skiing, water or wakeboarding (Taylor Code 220)", 'Skiing'],
        [15.8, "Skindiving, fast", 'Skindiving'],
        [11.8, "Skindiving, moderate", 'Skindiving'],
        [7.0, "Skindiving, scuba diving, general (Taylor Code 310)", 'Skindiving'],
        [3.5, "Skydiving, base jumping, bungee jumping", 'Skindiving'],
        [7.0, "Sledding, tobogganing, bobsledding, luge (Taylor Code 370)", 'Sledding'],
        [11.0, "Slide board exercise, general", 'Slide board exercise'],
        [6.0, "Slimnastics, Jazzercise", 'Slimnastics'],
        [5.0, "Snorkeling (Taylor Code 310)", 'Snorkeling'],
        [2.5, "Snow blower, walking and pushing", 'Snow blower'],
        [5.3, "Snow shoeing, moderate effort", 'Snow shoeing'],
        [10.0, "Snow shoeing, vigorous effort", 'Snow shoeing'],
        [5.3, "Snow shoveling, by hand, moderate effort", 'Snow shoveling'],
        [7.5, "Snow shoveling, by hand, vigorous effort", 'Snow shoveling'],
        [3.5, "Snowmobiling, driving, moderate", 'Snowmobiling'],
        [2.0, "Snowmobiling, passenger", 'Snowmobiling'],
        [7.0, "Soccer, casual, general (Taylor Code 540)", 'Soccer'],
        [10.0, "Soccer, competitive", 'Soccer'],
        [5.0, "Softball or baseball, fast or slow pitch, general (Taylor Code 440)", 'Softball'],
        [4.0, "Softball, officiating", 'Softball'],
        [4.0, "Softball, practice", 'Softball'],
        [6.0, "Softball,pitching", 'Softball'],
        [3.3, "Sports spectator, very excited, emotional, physically moving", 'Sports spectator'],
        [12.0, "Squash (Taylor Code 530)", 'Squash'],
        [7.3, "Squash, general", 'Squash'],
        [8.8, "Stair climbing, fast pace", 'Stair climbing'],
        [4.0, "Stair climbing, slow pace", 'Stair climbing'],
        [8.0, "Stair climbing, using or climbing up ladder (Taylor Code 030)", 'Stair climbing'],
        [9.0, "Stair-treadmill ergometer, general", 'Stair-treadmill ergometer'],
        [2.3, "Stretching, mild", 'Stretching'],
        [5.0, "Surfing, body or board, competitive", 'Surfing'],
        [3.0, "Surfing, body or board, general", 'Surfing'],
        [9.8, "Swimming laps, freestyle, fast, vigorous effort", 'Swimming'],
        [5.8, "Swimming laps, freestyle, front crawl, slow, light or moderate effort", 'Swimming'],
        [9.5, "Swimming, backstroke, general, training or competition", 'Swimming'],
        [4.8, "Swimming, backstroke, recreational", 'Swimming'],
        [10.3, "Swimming, breaststroke, general, training or competition", 'Swimming'],
        [5.3, "Swimming, breaststroke, recreational", 'Swimming'],
        [13.8, "Swimming, butterfly, general", 'Swimming'],
        [10.0, "Swimming, crawl, fast speed, ~75 yards/minute, vigorous effort", 'Swimming'],
        [8.3, "Swimming, crawl, medium speed, ~50 yards/minute, vigorous effort", 'Swimming'],
        [6.0, "Swimming, lake, ocean, river (Taylor Codes 280, 295)", 'Swimming'],
        [6.0, "Swimming, leisurely, not lap swimming, general", 'Swimming'],
        [7.0, "Swimming, sidestroke, general", 'Swimming'],
        [8.0, "Swimming, synchronized", 'Swimming'],
        [9.8, "Swimming, treading water, fast, vigorous effort", 'Swimming'],
        [3.5, "Swimming, treading water, moderate effort, general", 'Swimming'],
        [4.0, "Table tennis, ping pong (Taylor Code 410)", 'Table tennis'],
        [3.0, "Tai chi, qi gong, general", 'Tai chi'],
        [1.5, "Tai chi, qi gong, sitting, light effort", 'Tai chi'],
        [4.8, "Tap", 'Tap'],
        [6.8, "Teaching exercise class (e.g., aerobic, water)", 'Teaching exercise class'],
        [4.5, "Tennis, doubles", 'Tennis'],
        [6.0, "Tennis, doubles (Taylor Code 430)", 'Tennis'],
        [7.3, "Tennis, general", 'Tennis'],
        [5.0, "Tennis, hitting balls, non-game play, moderate effort", 'Tennis'],
        [8.0, "Tennis, singles (Taylor Code 420)", 'Tennis'],
        [2.8, "Therapeutic exercise ball, Fitball exercise", 'Therapeutic'],
        [6.0, "Track and field (e.g., high jump, long jump, triple jump, javelin, pole vault)", 'Track and field'],
        [4.0, "Track and field (e.g., shot, discus, hammer throw)", 'Track and field'],
        [10.0, "Track and field (e.g., steeplechase, hurdles)", 'Track and field'],
        [4.5, "Trampoline, competitive", 'Trampoline'],
        [3.5, "Trampoline, recreational", 'Trampoline'],
        [2.5, "Truck, semi, tractor, > 1 ton, or bus, driving", 'Truck, semi, tractor'],
        [2.3, "Tubing, floating on a river, general", 'Tubing'],
        [5.0, "Unicycling", 'Unicycling'],
        [2.8, "Upper body exercise, arm ergometer", 'Upper body exercise'],
        [4.3, "Upper body exercise, stationary bicycle - Airdyne (arms only) 40 rpm, moderate", 'Upper body exercise'],
        [5.0, "Using crutches", 'Using crutches'],
        [4.0, "Video exercise workouts, TV conditioning programs (e.g., cardio-resistance), moderate effort", 'Video exercise'],
        [6.0, "Video exercise workouts, TV conditioning programs (e.g., cardio-resistance), vigorous effort", 'Video exercise'],
        [2.3, "Video exercise workouts, TV conditioning programs (e.g., yoga, stretching), light effort", 'Video exercise'],
        [4.0, "Volleyball (Taylor Code 400)", 'Volleyball'],
        [8.0, "Volleyball, beach, in sand", 'Volleyball'],
        [6.0, "Volleyball, competitive, in gymnasium", 'Volleyball'],
        [3.0, "Volleyball, non-competitive, 6 - 9 member team, general", 'Volleyball'],
        [3.5, "Walking for pleasure (Taylor Code 010)", 'Walking'],
        [3.5, "Walking for transportation, 2.8-3.2 mph, level, moderate pace, firm surface", 'Walking'],
        [2.5, "Walking from house to car or bus, from car or bus to go places, from car or bus to and from the worksite", 'Walking'],
        [3.0, "Walking the dog", 'Walking'],
        [2.5, "Walking to neighbor's house or family's house for social reasons", 'Walking'],
        [2.8, "Walking, 2.0 mph, level, slow pace, firm surface", 'Walking'],
        [3.3, "Walking, 2.5 mph, downhill", 'Walking'],
        [3.0, "Walking, 2.5 mph, level, firm surface", 'Walking'],
        [3.5, "Walking, 2.8 to 3.2 mph, level, moderate pace, firm surface", 'Walking'],
        [5.3, "Walking, 2.9 to 3.5 mph, uphill, 1 to 5% grade", 'Walking'],
        [8.0, "Walking, 2.9 to 3.5 mph, uphill, 6% to 15% grade", 'Walking'],
        [4.3, "Walking, 3.5 mph, level, brisk, firm surface, walking for exercise", 'Walking'],
        [5.0, "Walking, 4.0 mph, level, firm surface, very brisk pace", 'Walking'],
        [7.0, "Walking, 4.5 mph, level, firm surface, very, very brisk", 'Walking'],
        [8.3, "Walking, 5.0 mph, level, firm surface", 'Walking'],
        [9.8, "Walking, 5.0 mph, uphill, 3% grade", 'Walking'],
        [6.0, "Walking, backwards, 3.5 mph, level", 'Walking'],
        [8.0, "Walking, backwards, 3.5 mph, uphill, 5% grade", 'Walking'],
        [4.8, "Walking, for exercise, 3.5 to 4 mph, with ski poles, Nordic walking, level, moderate pace", 'Walking'],
        [9.5, "Walking, for exercise, 5.0 mph, with ski poles, Nordic walking, level, fast pace", 'Walking'],
        [6.8, "Walking, for exercise, with ski poles, Nordic walking, uphill", 'Walking'],
        [3.5, "Walking, for pleasure, work break", 'Walking'],
        [4.8, "Walking, grass track", 'Walking'],
        [2.0, "Walking, household", 'Walking'],
        [2.0, "Walking, less than 2.0 mph, level, strolling, very slow", 'Walking'],
        [4.5, "Walking, normal pace, plowed field or sand", 'Walking'],
        [2.5, "Walking, to and from an outhouse", 'Walking'],
        [4.0, "Walking, to work or class (Taylor Code 015)", 'Walking'],
        [7.0, "Wallyball, general", 'Wallyball'],
        [5.5, "Water aerobics, water calisthenics", 'Water aerobics'],
        [5.3, "Water aerobics, water calisthenics, water exercise", 'Water aerobics'],
        [9.8, "Water jogging", 'Water jogging'],
        [10.0, "Water polo", 'Water polo'],
        [3.0, "Water volleyball", 'Water volleyball'],
        [2.5, "Water walking, light effort, slow pace", 'Water walking'],
        [4.5, "Water walking, moderate effort, moderate pace", 'Water walking'],
        [6.8, "Water walking, vigorous effort, brisk pace", 'Water walking'],
        [1.3, "Whirlpool, sitting", 'Whirlpool'],
        [5.0, "Whitewater rafting, kayaking, or canoeing", 'Whitewater rafting'],
        [11.0, "Windsurfing or kitesurfing, crossing trial", 'Windsurfing'],
        [13.5, "Windsurfing, competition, pumping for speed", 'Windsurfing'],
        [5.0, "Windsurfing, not pumping for speed", 'Windsurfing'],
        [6.0, "Wrestling (one match = 5 minutes)", 'Wresling'],
        [2.5, "Yoga, Hatha", 'yoga'],
        [2.0, "Yoga, Nadisodhana", 'yoga'],
        [4.0, "Yoga, Power", 'yoga'],
        [3.3, "Yoga, Surya Namaskar", 'yoga']
    ];

    function getClosest(search, arr) {
        let closest = null;
        for (const item of arr) {
            const [calories_burn_act, act_name_ans_pandran, act_img_name] = item.split("@@");
            if (closest == null || Math.abs(search - closest) > Math.abs(calories_burn_act - search)) {
                closest = calories_burn_act;
            }
        }
        return closest;
    }

    if (isNumeric(age) && isNumeric(weight) && isNumeric(lose_w) && gender && activity) {
        let lose_w_lbs, lose_w_kg;
        
        if (lose_unit == "lbs") {
            lose_w_lbs = lose_w;
            lose_w_kg = lose_w / 2.205;
        } else {
            lose_w_kg = lose_w;
            lose_w_lbs = lose_w * 2.205;
        }

        let weight_lbs, weight_kg, new_lose_kg, new_lose_lbs;
        
        if (weight_unit == "lbs") {
            weight_lbs = weight;
            weight_kg = weight / 2.205;
            new_lose_kg = lose_w_lbs / 2.205;
            new_lose_lbs = lose_w_lbs;
        } else {
            weight_kg = weight;
            weight_lbs = weight * 2.205;
            new_lose_kg = lose_w_lbs * 2.205;
            new_lose_lbs = lose_w_lbs;
        }

        const weight_diff_kg = weight_kg - new_lose_kg;
        const weight_diff_lbs = weight_lbs - new_lose_lbs;

        let final_height_cm;
        
        if (hightUnit == "ft/in") {
            if (isNumeric(height_ft) && isNumeric(height_in)) {
                if (body.tech_unit_ft_in == 'ft/in') {
                    final_height_cm = height_ft * 30.48;
                    if (height_in != null) {
                        const height_in_cm = height_in * 2.54;
                        final_height_cm += height_in_cm;
                    }
                }
            } else {
                return { error: 'Please Enter Height.' };
            }
        } else {
            if (isNumeric(height_cm)) {
                final_height_cm = height_cm;
            } else {
                return { error: 'Please Enter Height.' };
            }
        }

        const height_m = final_height_cm / 100;
        const height_in_total = final_height_cm / 2.54;

        let new_BMR, ibw;
        
        if (gender == 'Male') {
            new_BMR = Math.round((10 * weight_kg) + (6.25 * final_height_cm) - (5 * age) + 5);
            ibw = 50 + (2.3 * (height_in_total - 60));
        } else {
            new_BMR = Math.round((10 * weight_kg) + (6.25 * final_height_cm) - (5 * age) - 161);
            ibw = 45.5 + (2.3 * (height_in_total - 60));
        }

        const BMI = Math.round((weight_kg / (height_m * height_m)) * 100) / 100;
        let you_are;
        
        if (BMI <= 18.5) {
            you_are = 'Underweight';
        } else if (BMI > 18.5 && BMI <= 24.9) {
            you_are = 'Normal Weight';
        } else if (BMI > 24.9 && BMI <= 29.9) {
            you_are = 'Overweight';
        } else if (BMI > 29.9 && BMI <= 35) {
            you_are = 'Obesity';
        } else {
            you_are = 'Severe Obesity';
        }

        const activity_multiplier = Math.round(new_BMR * activity);
        const calories = Math.round(new_BMR + activity_multiplier);

        let calories_less, calories_daily, pounds_daily, days;

        if (choose == "by_calories") {
            if (!enter_calories) {
                return { error: 'Enter Kcal/day are you ready to reduce.' };
            }
            calories_less = enter_calories;
            calories_daily = calories - calories_less;
            pounds_daily = Math.round((calories_less / 3500) * 1000) / 1000;
            days = Math.round(weight_diff_lbs / pounds_daily);
        } else {
            const startDate = new Date(start);
            const endDate = new Date(end);
            const timeDiff = endDate.getTime() - startDate.getTime();
            days = Math.ceil(timeDiff / (1000 * 3600 * 24));
            
            if (days == 0) {
                return { error: 'Start and target dates must not be the same.' };
            }
            
            pounds_daily = Math.round((weight_diff_lbs / days) * 100) / 100;
            calories_less = Math.round(pounds_daily * 3500);
            calories_daily = calories - calories_less;
        }

        const sab_ki_calories_pandran = [];
        const sab_ki_calories_adha = [];
        const sab_ki_calories_pona = [];
        const sab_ki_calories_hour = [];
        const sab_ki_calories_sawa = [];
        const sab_ki_calories_dher = [];
        const sab_ki_calories_pone = [];
        const sab_ki_calories_do = [];

        for (const act_val of all_activites) {
            sab_ki_calories_pandran.push(Math.round(new_BMR * act_val[0] * (15/1440)) + "@@" + act_val[1] + "@@" + act_val[2]);
            sab_ki_calories_adha.push(Math.round(new_BMR * act_val[0] * (30/1440)) + "@@" + act_val[1] + "@@" + act_val[2]);
            sab_ki_calories_pona.push(Math.round(new_BMR * act_val[0] * (45/1440)) + "@@" + act_val[1] + "@@" + act_val[2]);
            sab_ki_calories_hour.push(Math.round(new_BMR * act_val[0] * (60/1440)) + "@@" + act_val[1] + "@@" + act_val[2]);
            sab_ki_calories_sawa.push(Math.round(new_BMR * act_val[0] * (75/1440)) + "@@" + act_val[1] + "@@" + act_val[2]);
            sab_ki_calories_dher.push(Math.round(new_BMR * act_val[0] * (90/1440)) + "@@" + act_val[1] + "@@" + act_val[2]);
            sab_ki_calories_pone.push(Math.round(new_BMR * act_val[0] * (105/1440)) + "@@" + act_val[1] + "@@" + act_val[2]);
            sab_ki_calories_do.push(Math.round(new_BMR * act_val[0] * (120/1440)) + "@@" + act_val[1] + "@@" + act_val[2]);
        }

        const diff_array_pandran = [];
        const diff_array_adha = [];
        const diff_array_pona = [];
        const diff_array = [];
        const diff_array_sawa = [];
        const diff_array_dher = [];
        const diff_array_pone = [];
        const diff_array_do = [];

        for (let i = 0; i < sab_ki_calories_hour.length; i++) {
            const [cal_ans_pandran, name_ans_pandran, img_name_pandran] = sab_ki_calories_pandran[i].split("@@");
            const [cal_ans_adha, name_ans_adha, img_name_adha] = sab_ki_calories_adha[i].split("@@");
            const [cal_ans_pona, name_ans_pona, img_name_pona] = sab_ki_calories_pona[i].split("@@");
            const [cal_ans, name_ans, img_name] = sab_ki_calories_hour[i].split("@@");
            const [cal_ans_sawa, name_ans_sawa, img_name_sawa] = sab_ki_calories_sawa[i].split("@@");
            const [cal_ans_dher, name_ans_dher, img_name_dher] = sab_ki_calories_dher[i].split("@@");
            const [cal_ans_pone, name_ans_pone, img_name_pone] = sab_ki_calories_pone[i].split("@@");
            const [cal_ans_do, name_ans_do, img_name_do] = sab_ki_calories_do[i].split("@@");

            diff_array_pandran.push([Math.abs(cal_ans_pandran - calories_less), cal_ans_pandran, name_ans_pandran, img_name_pandran]);
            diff_array_adha.push([Math.abs(cal_ans_adha - calories_less), cal_ans_adha, name_ans_adha, img_name_adha]);
            diff_array_pona.push([Math.abs(cal_ans_pona - calories_less), cal_ans_pona, name_ans_pona, img_name_pona]);
            diff_array.push([Math.abs(cal_ans - calories_less), cal_ans, name_ans, img_name]);
            diff_array_sawa.push([Math.abs(cal_ans_sawa - calories_less), cal_ans_sawa, name_ans_sawa, img_name_sawa]);
            diff_array_dher.push([Math.abs(cal_ans_dher - calories_less), cal_ans_dher, name_ans_dher, img_name_dher]);
            diff_array_pone.push([Math.abs(cal_ans_pone - calories_less), cal_ans_pone, name_ans_pone, img_name_pone]);
            diff_array_do.push([Math.abs(cal_ans_do - calories_less), cal_ans_do, name_ans_do, img_name_do]);
        }

        diff_array_pandran.sort((a, b) => a[0] - b[0]);
        diff_array_adha.sort((a, b) => a[0] - b[0]);
        diff_array_pona.sort((a, b) => a[0] - b[0]);
        diff_array.sort((a, b) => a[0] - b[0]);
        diff_array_sawa.sort((a, b) => a[0] - b[0]);
        diff_array_dher.sort((a, b) => a[0] - b[0]);
        diff_array_pone.sort((a, b) => a[0] - b[0]);
        diff_array_do.sort((a, b) => a[0] - b[0]);

        const slice_pandran = diff_array_pandran.slice(0, 15);
        const slice_adha = diff_array_adha.slice(0, 15);
        const slice_pona = diff_array_pona.slice(0, 15);
        const slice = diff_array.slice(0, 15);
        const slice_sawa = diff_array_sawa.slice(0, 15);
        const slice_dher = diff_array_dher.slice(0, 15);
        const slice_pone = diff_array_pone.slice(0, 15);
        const slice_do = diff_array_do.slice(0, 15);

        const final_array_pandran = [];
        const final_array_adha = [];
        const final_array_pona = [];
        const final_array = [];
        const final_array_sawa = [];
        const final_array_dher = [];
        const final_array_pone = [];
        const final_array_do = [];

        for (let i = 0; i < slice.length; i++) {
            final_array_pandran.push(slice_pandran[i][1] + "@@" + slice_pandran[i][2] + "@@" + slice_pandran[i][3]);
            final_array_adha.push(slice_adha[i][1] + "@@" + slice_adha[i][2] + "@@" + slice_adha[i][3]);
            final_array_pona.push(slice_pona[i][1] + "@@" + slice_pona[i][2] + "@@" + slice_pona[i][3]);
            final_array.push(slice[i][1] + "@@" + slice[i][2] + "@@" + slice[i][3]);
            final_array_sawa.push(slice_sawa[i][1] + "@@" + slice_sawa[i][2] + "@@" + slice_sawa[i][3]);
            final_array_dher.push(slice_dher[i][1] + "@@" + slice_dher[i][2] + "@@" + slice_dher[i][3]);
            final_array_pone.push(slice_pone[i][1] + "@@" + slice_pone[i][2] + "@@" + slice_pone[i][3]);
            final_array_do.push(slice_do[i][1] + "@@" + slice_do[i][2] + "@@" + slice_do[i][3]);
        }

        final_array_pandran.sort();
        final_array_adha.sort();
        final_array_pona.sort();
        final_array.sort();
        final_array_sawa.sort();
        final_array_dher.sort();
        final_array_pone.sort();
        final_array_do.sort();

        const activity_first = Math.round(((0.2 * new_BMR * 7) / 3500) * 100) / 100;
        const activity_second = Math.round(((0.375 * new_BMR * 7) / 3500) * 100) / 100;
        const activity_third = Math.round(((0.55 * new_BMR * 7) / 3500) * 100) / 100;
        const activity_four = Math.round(((0.725 * new_BMR * 7) / 3500) * 100) / 100;
        const activity_five = Math.round(((0.9 * new_BMR * 7) / 3500) * 100) / 100;

        const ans_weight = (submit == "lbs") ? weight_lbs : weight_kg;

        return {
            tech_PoundsDaily: pounds_daily,
            tech_CaloriesDaily: calories_daily,
            tech_Calories: calories,
            tech_days: days,
            tech_ans_weight: ans_weight,
            tech_BMR: new_BMR,
            tech_BMI: BMI,
            tech_you_are: you_are,
            tech_ibw: ibw,
            tech_submit: submit,
            tech_lose_w: lose_w,
            tech_weight: weight,
            tech_final_array_pandran: final_array_pandran,
            tech_final_array_adha: final_array_adha,
            tech_final_array_pona: final_array_pona,
            tech_final_array: final_array,
            tech_final_array_sawa: final_array_sawa,
            tech_final_array_dher: final_array_dher,
            tech_final_array_pone: final_array_pone,
            tech_final_array_do: final_array_do,
            tech_diff_array_pandran: diff_array_pandran,
            tech_diff_array_adha: diff_array_adha,
            tech_diff_array_pona: diff_array_pona,
            tech_diff_array: diff_array,
            tech_diff_array_sawa: diff_array_sawa,
            tech_diff_array_dher: diff_array_dher,
            tech_diff_array_pone: diff_array_pone,
            tech_diff_array_do: diff_array_do,
            tech_activity_first: activity_first,
            tech_activity_second: activity_second,
            tech_activity_third: activity_third,
            tech_activity_four: activity_four,
            tech_activity_five: activity_five,
        };
    } else {
        return { error: 'Please! Check Your Input.' };
    }
    
    // Helper function to check if value is numeric
    function isNumeric(value) {
        return !isNaN(parseFloat(value)) && isFinite(value);
    }
}

   /**
    * getCalculationOvulationCalculator: Service Method
    * POST: /api/calculators-lol/ovulation-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationOvulationCalculator(body) {
      const request = body;
      
      // Validate input
      if (!isNaN(request.tech_days) && request.tech_date) {
        const datepicker = request.tech_date;
        const exp = datepicker.split('-');
        let dateyear = parseInt(exp[0]);
        let datemonth = parseInt(exp[1]);
        let dateday = parseInt(exp[2]);
        
        // Set default values
        let days = parseInt(request.tech_days) || 28;
        let ldays = parseInt(request.tech_Luteal) || 14;
        
        let table = '';
        
        // Helper function to format date
        const formatDate = (d, format) => {
          const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
          const month = months[d.getMonth()];
          const day = String(d.getDate()).padStart(2, '0');
          const year = d.getFullYear();
          
          if (format == 'M d, Y') return `${month} ${day}, ${year}`;
          if (format == 'M d') return `${month} ${day}`;
          if (format == 'M d - ') return `${month} ${day} - `;
          if (format == 'M d ') return `${month} ${day} `;
          if (format == 'Y-m-d') return `${year}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
          return d;
        };
        
        // Helper function to add days
        const addDays = (date, days) => {
          const result = new Date(date);
          result.setDate(result.getDate() + days);
          return result;
        };
        
        // Parse date string to create proper date
        const parseDate = (dateStr) => {
          const parts = dateStr.split(', ');
          const monthDay = parts[0].split(' ');
          const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
          const month = monthNames.indexOf(monthDay[0]);
          const day = parseInt(monthDay[1]);
          const year = parts[1] ? parseInt(parts[1]) : new Date().getFullYear();
          return new Date(year, month, day);
        };
        
        // Initial date
        const date = `${dateyear}-${datemonth}-${dateday}`;
        const dateObj = new Date(dateyear, datemonth - 1, dateday);
        
        const start_period = formatDate(dateObj, 'M d, Y');
        const start_perio = formatDate(dateObj, 'M d');
        const save1 = formatDate(dateObj, 'M d ');
        const save2 = formatDate(addDays(dateObj, 6), 'M d');
        const save = `${save1}to ${save2}`;
        
        // Next period calculation
        const next_period_date = addDays(dateObj, days);
        const next_period = formatDate(next_period_date, 'M d, Y');
        const save3 = formatDate(next_period_date, 'M d');
        const save4 = formatDate(addDays(next_period_date, -6), 'M d');
        const saven = `${save4} to ${save3}`;
        
        // Ovulation date calculation
        const ovu_date_obj = addDays(next_period_date, -ldays);
        const ovu_date = formatDate(ovu_date_obj, 'M d, Y');
        const firstday = formatDate(addDays(ovu_date_obj, -2), 'M d');
        const lastday = formatDate(addDays(ovu_date_obj, 2), 'M d');
        const testdate = formatDate(addDays(ovu_date_obj, 9), 'M d, Y');
        const inter = formatDate(addDays(addDays(ovu_date_obj, 2), -7), 'M d - ');
        
        const diff = 280 + (days - 28);
        const duedate = formatDate(addDays(dateObj, diff), 'M d, Y');
        
        // Build table first row
        table += `<tr><td class="border-b-dark font-s-12">${start_perio}</td><td class="border-b-dark font-s-12 border-s-dark">${firstday} - ${lastday}</td><td class="border-b-dark font-s-12 border-s-dark">${duedate}</td></tr>`;
        
        // Build table rows for next 5 cycles
        let current_period_str = start_period;
        for (let i = 0; i < 5; i++) {
          const current = parseDate(current_period_str);
          const next_current = addDays(current, days);
          current_period_str = formatDate(next_current, 'M d, Y');
          const start_period_display = formatDate(next_current, 'M d');
          
          const next = addDays(next_current, days);
          const ovu = addDays(next, -ldays);
          const first = formatDate(addDays(ovu, -2), 'M d');
          const last = formatDate(addDays(ovu, 2), 'M d');
          const d_date = formatDate(addDays(next_current, diff), 'M d, Y');
          const border_b = i == 4 ? '' : 'border-b-dark';
          
          table += `<tr><td class="${border_b} font-s-12">${start_period_display}</td><td class="${border_b} font-s-12 border-s-dark">${first} - ${last}</td><td class="${border_b} font-s-12 border-s-dark">${d_date}</td></tr>`;
        }
        
        // Calculate chance
        const aj_ki_date = formatDate(new Date(), 'M d, Y');
        const one = formatDate(addDays(ovu_date_obj, -2), 'M d, Y');
        const two = formatDate(addDays(ovu_date_obj, -1), 'M d, Y');
        const three = formatDate(addDays(ovu_date_obj, 2), 'M d, Y');
        const four = formatDate(addDays(ovu_date_obj, 1), 'M d, Y');
        
        let chance;
        if (aj_ki_date == ovu_date) {
          chance = 'High';
        } else if (aj_ki_date == one || aj_ki_date == two || aj_ki_date == three || aj_ki_date == four) {
          chance = 'Medium';
        } else {
          chance = 'Low';
        }
        
        // Calculate all event dates - FIXED LOGIC
        const event1 = formatDate(dateObj, 'Y-m-d');
        const event2 = formatDate(next_period_date, 'Y-m-d');
        const event3 = formatDate(addDays(ovu_date_obj, -2), 'Y-m-d');
        const event4 = formatDate(addDays(ovu_date_obj, -1), 'Y-m-d');
        const event5 = formatDate(ovu_date_obj, 'Y-m-d');
        const event6 = formatDate(addDays(ovu_date_obj, 1), 'Y-m-d');
        const event7 = formatDate(addDays(ovu_date_obj, 2), 'Y-m-d');
        
        // event8-12: Next fertile window
        const event7_date = addDays(ovu_date_obj, 2);
        const event8 = formatDate(addDays(event7_date, days - 4), 'Y-m-d');
        const event9 = formatDate(addDays(event7_date, days - 3), 'Y-m-d');
        const event10 = formatDate(addDays(event7_date, days - 2), 'Y-m-d');
        const event11 = formatDate(addDays(event7_date, days - 1), 'Y-m-d');
        const event12 = formatDate(addDays(event7_date, days), 'Y-m-d');
        
        // event13-17: Third fertile window
        const event13 = formatDate(addDays(event7_date, days + (days - 4)), 'Y-m-d');
        const event14 = formatDate(addDays(event7_date, days + (days - 3)), 'Y-m-d');
        const event15 = formatDate(addDays(event7_date, days + (days - 2)), 'Y-m-d');
        const event16 = formatDate(addDays(event7_date, days + (days - 1)), 'Y-m-d');
        const event17 = formatDate(addDays(event7_date, days + days), 'Y-m-d');
        
        // event18-22: Fourth fertile window
        const event18 = formatDate(addDays(event7_date, (days * 2) + (days - 4)), 'Y-m-d');
        const event19 = formatDate(addDays(event7_date, (days * 2) + (days - 3)), 'Y-m-d');
        const event20 = formatDate(addDays(event7_date, (days * 2) + (days - 2)), 'Y-m-d');
        const event21 = formatDate(addDays(event7_date, (days * 2) + (days - 1)), 'Y-m-d');
        const event22 = formatDate(addDays(event7_date, (days * 2) + days), 'Y-m-d');
        
        // event23-27: Fifth fertile window
        const event23 = formatDate(addDays(event7_date, (days * 3) + (days - 4)), 'Y-m-d');
        const event24 = formatDate(addDays(event7_date, (days * 3) + (days - 3)), 'Y-m-d');
        const event25 = formatDate(addDays(event7_date, (days * 3) + (days - 2)), 'Y-m-d');
        const event26 = formatDate(addDays(event7_date, (days * 3) + (days - 1)), 'Y-m-d');
        const event27 = formatDate(addDays(event7_date, (days * 3) + days), 'Y-m-d');
        
        // event28-32: Sixth fertile window
        const event28 = formatDate(addDays(event7_date, (days * 4) + (days - 4)), 'Y-m-d');
        const event29 = formatDate(addDays(event7_date, (days * 4) + (days - 3)), 'Y-m-d');
        const event30 = formatDate(addDays(event7_date, (days * 4) + (days - 2)), 'Y-m-d');
        const event31 = formatDate(addDays(event7_date, (days * 4) + (days - 1)), 'Y-m-d');
        const event32 = formatDate(addDays(event7_date, (days * 4) + days), 'Y-m-d');
        
        const lasttime_date = addDays(ovu_date_obj, -2);
        lasttime_date.setHours(0, 0, 0, 0);
        const lasttime = Math.floor(lasttime_date.getTime() / 1000);
        
        // Return result object
        return {
          tech_Date: date,
          tech_First_day: firstday,
          tech_Ovu_date: ovu_date,
          tech_Last_day: lastday,
          tech_Next_period: next_period,
          tech_table: table,
          tech_test: testdate,
          tech_inter: inter,
          tech_save: save,
          tech_saven: saven,
          tech_chance: chance,
          tech_Due_date: duedate,
          tech_event1: event1, 
          tech_event2: event2, 
          tech_event3: event3, 
          tech_event4: event4, 
          tech_event5: event5, 
          tech_event6: event6, 
          tech_event7: event7,
          tech_event8: event8, 
          tech_event9: event9, 
          tech_event10: event10, 
          tech_event11: event11, 
          tech_event12: event12, 
          tech_event13: event13, 
          tech_event14: event14,
          tech_event15: event15, 
          tech_event16: event16, 
          tech_event17: event17, 
          tech_event18: event18, 
          tech_event19: event19, 
          tech_event20: event20, 
          tech_event21: event21,
          tech_event22: event22, 
          tech_event23: event23, 
          tech_event24: event24, 
          tech_event25: event25, 
          tech_event26: event26, 
          tech_event27: event27, 
          tech_event28: event28,
          tech_event29: event29, 
          tech_event30: event30, 
          tech_event31: event31, 
          tech_event32: event32,
          tech_lasttime: lasttime,
          request: request,
        };
      } else {
        return {
          error: 'Invalid Input.'
        };
      }
    }

     /**
    * getCalculationOvulationCalculator: Service Method
    * POST: /api/calculators-lol/pregnancy-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */
   

      async getCalculationPregnancyCalculator(body) {
        const param = {};
        let fieldsDone = 0;

        // Check if date is provided
        if (!body.tech_date) {
          param.error = 'Please Fill All Fields.';
          return param;
        }

        fieldsDone = 1;
        const dop = body.tech_date; // Expected format: YYYY-MM-DD
        const dop2 = dop.split("-");

        // Convert month string to number
        let month = parseInt(dop2[1], 10);
        const year = parseInt(dop2[0], 10);
        const day = parseInt(dop2[2], 10);

        let ovu_date, modi_ageEsimated, due_date;
        let weeksRemaining, daysRemaining;

        if (body.tech_method == 'Last') {
          // Last Menstrual Period method
          if (!body.tech_cycle) {
            param.error = 'Please Fill All Fields.';
            return param;
          }

          const cycle = parseInt(body.tech_cycle, 10);
          const startDate = new Date(year, month - 1, day);
          
          // Calculate ovulation date
          const ovuDateTime = new Date(startDate);
          ovuDateTime.setDate(ovuDateTime.getDate() + cycle - 14);
          ovu_date = formatDate(ovuDateTime, 'MMM dd, yyyy');
          
          // Calculate due date (ovulation + 266 days)
          const dueDateTime = new Date(ovuDateTime);
          dueDateTime.setDate(dueDateTime.getDate() + 266);
          modi_ageEsimated = formatDate(dueDateTime, 'MMM dd, yyyy');
          
          // Calculate current pregnancy progress
          const bday = new Date(dueDateTime);
          bday.setDate(bday.getDate() - 280);
          const today = new Date();
          const diff = dateDiff(bday, today);
          
          const months = diff.months;
          if (months > 9) {
            param.error = 'You are not pregnant yet.';
            return param;
          }
          
          const days = (months * 30.417) + diff.days;
          weeksRemaining = Math.floor(days / 7);
          daysRemaining = Math.floor(days % 7);
        } 
        else if (body.tech_method == 'Due') {
          // Due Date method
          const dueDate = new Date(year, month - 1, day);
          
          // Calculate ovulation date (due date - 266 days)
          const ovuDateTime = new Date(dueDate);
          ovuDateTime.setDate(ovuDateTime.getDate() - 266);
          ovu_date = formatDate(ovuDateTime, 'MMM dd, yyyy');
          
          due_date = formatDate(dueDate, 'MMM dd, yyyy');
          modi_ageEsimated = formatDate(dueDate, 'MM/dd/yyyy');
          
          // Calculate current pregnancy progress
          const bday = new Date(dueDate);
          bday.setDate(bday.getDate() - 280);
          const today = new Date();
          const diff = dateDiff(bday, today);
          
          const months = diff.months;
        
          if (months > 9) {
            param.error = 'You are not pregnant yet.';
            return param;
          }
          
          const days = (months * 30.417) + diff.days;
          weeksRemaining = Math.floor(days / 7);
          daysRemaining = Math.floor(days % 7);
        } 
        else if (body.tech_method == 'Conception') {
          // Conception Date method
          const conceptionDate = new Date(year, month - 1, day);
          ovu_date = formatDate(conceptionDate, 'MMM dd, yyyy');
          
          // Calculate due date (conception + 266 days)
          const dueDateTime = new Date(conceptionDate);
          dueDateTime.setDate(dueDateTime.getDate() + 266);
          due_date = formatDate(dueDateTime, 'yyyy-MM-dd');
          modi_ageEsimated = formatDate(dueDateTime, 'MM/dd/yyyy');
          
          // Calculate current pregnancy progress
          const bday = new Date(dueDateTime);
          bday.setDate(bday.getDate() - 280);
          const today = new Date();
          const diff = dateDiff(bday, today);
          
          const months = diff.months;
          if (months > 9) {
            param.error = 'You are not pregnant yet.';
            return param;
          }
          
          const days = (months * 30.417) + diff.days;
          weeksRemaining = Math.floor(days / 7);
          daysRemaining = Math.floor(days % 7);
        } 
        else if (body.tech_method == 'IVF') {
          // IVF Transfer Date method
          let ivfDays = body.tech_ivf;
          
          // Convert string values to numbers
          if (ivfDays == 'Last') {
            ivfDays = 280;
          } else if (ivfDays == 'Due') {
            ivfDays = 0;
          } else if (ivfDays == 'Conception') {
            ivfDays = 266;
          } else if (ivfDays == 'IVF') {
            ivfDays = 266;
          } else if (ivfDays == 'Ultrasound') {
            ivfDays = 250;
          }
          
          const daysToAdd = 266 - ivfDays;
          const transferDate = new Date(year, month - 1, day);
          
          // Calculate due date
          const dueDateTime = new Date(transferDate);
          dueDateTime.setDate(dueDateTime.getDate() + daysToAdd);
          due_date = formatDate(dueDateTime, 'yyyy-MM-dd');
          modi_ageEsimated = formatDate(dueDateTime, 'MM/dd/yyyy');
          
          // Calculate ovulation date (due date - 38 weeks)
          const ovuDateTime = new Date(dueDateTime);
          ovuDateTime.setDate(ovuDateTime.getDate() - (38 * 7));
          ovu_date = formatDate(ovuDateTime, 'MMM dd, yyyy');
          
          // Calculate current pregnancy progress
          const bday = new Date(dueDateTime);
          bday.setDate(bday.getDate() - 280);
          const today = new Date();
          const diff = dateDiff(bday, today);
          
          const months = diff.months;
          if (months > 9) {
            param.error = 'You are not pregnant yet.';
            return param;
          }
          
          const days = (months * 30.417) + diff.days;
          weeksRemaining = Math.floor(days / 7);
          daysRemaining = Math.floor(days % 7);
        } 
        else if (body.tech_method == 'Ultrasound') { 
          // Ultrasound method
          const weeks = body.tech_week ? parseInt(body.tech_week, 10) : 0;
          const days = body.tech_days ? parseInt(body.tech_days, 10) : 0;
          
          // Check if at least one value is numeric and greater than 0
          if ((isNaN(weeks) || weeks === 0) && (isNaN(days) || days === 0)) {
            param.error = 'Please enter weeks or days.';
            return param;
          }
          
          const pregLength = 40 * 7; // 280 days
          const totalDays = (weeks * 7) + days;
          
          // Calculate pregnancy start date (subtract totalDays from scan date)
          const scanDate = new Date(year, month - 1, day);
          const pregStartDate = new Date(scanDate);
          pregStartDate.setDate(pregStartDate.getDate() - totalDays);
          
          // Calculate due date (add 280 days to pregnancy start date)
          const dueDateTime = new Date(pregStartDate);
          dueDateTime.setDate(dueDateTime.getDate() + pregLength);
          due_date = formatDate(dueDateTime, 'yyyy-MM-dd');
          modi_ageEsimated = due_date;
          
          // Calculate ovulation date (due date - 38 weeks)
          const ovuDateTime = new Date(dueDateTime);
          ovuDateTime.setDate(ovuDateTime.getDate() - (38 * 7));
          ovu_date = formatDate(ovuDateTime, 'MMM dd, yyyy');
          
          // Calculate current pregnancy progress
          const today = new Date();
          const diff = dateDiff(pregStartDate, today);
          
          const months = diff.months;  // Now this matches Laravel's $diff->m
          console.log('Years:', diff.years, 'Months:', months, 'Days:', diff.days);
          
          if (months > 9 || diff.years > 0) {
            param.error = 'You are not pregnant yet.';
            return param;
          }
          
          const calcDays = (months * 30.417) + diff.days;
          weeksRemaining = Math.floor(calcDays / 7);
          daysRemaining = Math.floor(calcDays % 7);
      }

        // Check if due date has passed
      const today = new Date();
      const estimatedDate = new Date(modi_ageEsimated);

      // normalize both to midnight (date-only)
        today.setHours(0, 0, 0, 0);
          estimatedDate.setHours(0, 0, 0, 0);
                  // console.log(today,modi_ageEsimated);
          if (today > estimatedDate) {
              param.error = 'You are not pregnant yet.111';
              return param;
            }

        // Check if all fields are done
        if (!fieldsDone) {
          param.error = 'Please Fill All Fields.';
          return param;
        }

        // Set trimester indicators
        if (weeksRemaining >= 0 && weeksRemaining < 5) {
          param.tech_one_t = 'bg-dark-blue text-white';
        } else if (weeksRemaining > 4 && weeksRemaining < 9) {
          param.tech_two_t = 'bg-dark-blue text-white';
        } else if (weeksRemaining > 8 && weeksRemaining < 14) {
          param.tech_three_t = 'bg-dark-blue text-white';
        } else if (weeksRemaining > 13 && weeksRemaining < 18) {
          param.tech_four_t = 'bg-dark-blue text-white';
        } else if (weeksRemaining > 17 && weeksRemaining < 22) {
          param.tech_five_t = 'bg-dark-blue text-white';
        } else if (weeksRemaining > 21 && weeksRemaining < 28) {
          param.tech_six_t = 'bg-dark-blue text-white';
        } else if (weeksRemaining > 27 && weeksRemaining < 32) {
          param.tech_seven_t = 'bg-dark-blue text-white';
        } else if (weeksRemaining > 31 && weeksRemaining < 36) {
          param.tech_eight_t = 'bg-dark-blue text-white';
        } else if (weeksRemaining > 35 && weeksRemaining < 41) {
          param.tech_nine_t = 'bg-dark-blue text-white';
        }

        // Set return values
        param.tech_RemainingWeeks = weeksRemaining;
        param.tech_RemainingDays = daysRemaining;
        param.tech_EstimatedAge = modi_ageEsimated;
        param.tech_ovu_date = ovu_date;

        return param;

        // Helper function to calculate date difference

        // Helper function to calculate date difference (like Laravel's DateTime diff)
          function dateDiff(date1, date2) {
            const d1 = new Date(date1);
            const d2 = new Date(date2);
            
            // Calculate year and month difference
            let years = d2.getFullYear() - d1.getFullYear();
            let months = d2.getMonth() - d1.getMonth();
            let days = d2.getDate() - d1.getDate();
            
            // Adjust if days are negative
            if (days < 0) {
              months--;
              const lastMonth = new Date(d2.getFullYear(), d2.getMonth(), 0);
              days += lastMonth.getDate();
            }
            
            // Adjust if months are negative
            if (months < 0) {
              years--;
              months += 12;
            }
            
            // Return only months within current year cycle (like Laravel's DateInterval->m)
            // Laravel's ->m is the month component, not total months
            return { 
              years: years,
              months: months,  // This is like $diff->m (0-11 range)
              days: days 
            };
          }

      

        // Helper function to format dates
        function formatDate(date, format) {
          const d = new Date(date);
          const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                          'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
          
          if (format == 'MMM dd, yyyy') {
            return `${months[d.getMonth()]} ${String(d.getDate()).padStart(2, '0')}, ${d.getFullYear()}`;
          } else if (format == 'MM/dd/yyyy') {
            return `${String(d.getMonth() + 1).padStart(2, '0')}/${String(d.getDate()).padStart(2, '0')}/${d.getFullYear()}`;
          } else if (format == 'yyyy-MM-dd') {
            return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
          }
          
          return d.toString();
        }
  }

    /**
    * getCalculationTdeeCalculator: Service Method
    * POST: /api/calculators-lol/tdee-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */
   

     async getCalculationTdeeCalculator(body) {
      const result = {};
      try {
          let age = body.tech_age;
        let gender = body.tech_gender;
        let ft_in = body.tech_ft_in;
        let inputWeight = body.tech_weight;
        let percent = body.tech_percent;
        let activity = body.tech_activity;
        let unit = body.tech_unit;
        let height_ft = body.tech_height_ft;
        let height_in = body.tech_height_in;
        let inputHeightCm = body.tech_height_cm;
        let hightUnit = body.tech_hightUnit;
        let unit_ft_in = body.tech_unit_ft_in;


        // Validation
        if (!age || !inputWeight || !gender || !activity || 
            isNaN(age) || isNaN(inputWeight)) {
          result.error = 'Please fill All fields.';
          return result;
        }

        if (percent && percent > 100) {
          result.error = 'Body Fat Percentage cannot greater than 100.';
          return result;
        }

        // Weight conversion
        let weight = parseFloat(inputWeight);
        if (unit == 'lbs') {
          weight = weight / 2.205;
        }

        // Height conversion to cm
        let height_cm;
        
        if (hightUnit == 'ft/in') {
          if (ft_in) {
            height_cm = parseFloat(ft_in) * 2.54;
          } else {
            if (height_ft && height_in && !isNaN(height_ft) && !isNaN(height_in)) {
              if (unit_ft_in === 'ft/in') {
                height_cm = parseFloat(height_ft) * 30.48;
                if (height_in != null) {
                  const heightInCm = parseFloat(height_in) * 2.54;
                  height_cm = height_cm + heightInCm;
                }
              }
            } else {
              result.error = 'Please Enter Height.';
              return result;
            }
          }
        } else {
          if (inputHeightCm && !isNaN(inputHeightCm)) {
            height_cm = parseFloat(inputHeightCm);
          } else {
            result.error = 'Please Enter Height.';
            return result;
          }
        }

        // Calculate BMI
        const height_m = height_cm / 100;
        const BMI = Math.round((weight / (height_m * height_m)) * 100) / 100;

        // Determine BMI category
        let you_are;
        if (BMI <= 18.5) {
          you_are = 'Underweight';
        } else if (BMI > 18.5 && BMI <= 24.9) {
          you_are = 'Normal Weight';
        } else if (BMI > 24.9 && BMI <= 29.9) {
          you_are = 'Overweight';
        } else if (BMI > 29.9 && BMI <= 35) {
          you_are = 'Obesity';
        } else {
          you_are = 'Severe Obesity';
        }

        // Calculate BMR (Mifflin-St Jeor Equation)
        let BMR;
        if (gender == 'female') {
          BMR = Math.round((weight * 10) + (height_cm * 6.25) - (age * 5) - 161);
        } else {
          BMR = Math.round((10 * weight) + (6.25 * height_cm) - (5 * age) + 5);
        }

        // Calculate TDEE
        let tdee;
        const activityMultipliers = {
          'Sedentary': 1.2,
          'Lightly Active': 1.375,
          'Moderately Active': 1.55,
          'Very Active': 1.725,
          'Extra Active': 1.9
        };
        
        tdee = Math.round(BMR * (activityMultipliers[activity] || 1.2));

        // Helper function for macro calculations
        const calculateMacros = (calories, proPercent, fatPercent, carbPercent) => {
          const pro = (proPercent * calories) / 100;
          const pro_ans = Math.round(pro / 4);
          
          const fat = (fatPercent * calories) / 100;
          const fat_ans = Math.round(fat / 9);
          
          const carb = (carbPercent * calories) / 100;
          const carb_ans = Math.round(carb / 4);
          
          const total = pro_ans + fat_ans + carb_ans;
          
          return {
            pro_per_ans: Math.round((pro_ans / total) * 100),
            fat_per_ans: Math.round((fat_ans / total) * 100),
            carb_per_ans: Math.round((carb_ans / total) * 100)
          };
        };

        // MAINTENANCE
        const main_mod = calculateMacros(tdee, 30, 35, 35);
        const main_low = calculateMacros(tdee, 40, 40, 20);
        const main_high = calculateMacros(tdee, 30, 20, 50);

        // CUTTING
        const cut_mod = calculateMacros(tdee - 500, 30, 35, 35);
        const cut_low = calculateMacros(tdee - 500, 40, 40, 20);
        const cut_high = calculateMacros(tdee - 500, 30, 20, 50);

        // BULKING
        const bulk_mod = calculateMacros(tdee + 500, 30, 35, 35);
        const bulk_low = calculateMacros(tdee + 500, 40, 40, 20);
        const bulk_high = calculateMacros(tdee + 500, 30, 20, 50);

        // Populate result object
        result.tech_tdee = tdee;
        result.tech_height_cm = height_cm;
        result.tech_weight = weight;
        result.tech_BMR = Math.round(BMR);
        result.tech_BMI = BMI;
        result.tech_you_are = you_are;
        result.tech_calories = tdee;
        result.tech_submit = unit;

        // Maintenance
        result.tech_main_mod_pro_per_ans = main_mod.pro_per_ans;
        result.tech_main_mod_fat_per_ans = main_mod.fat_per_ans;
        result.tech_main_mod_carb_per_ans = main_mod.carb_per_ans;
        
        result.tech_main_low_pro_per_ans = main_low.pro_per_ans;
        result.tech_main_low_fat_per_ans = main_low.fat_per_ans;
        result.tech_main_low_carb_per_ans = main_low.carb_per_ans;
        
        result.tech_main_high_pro_per_ans = main_high.pro_per_ans;
        result.tech_main_high_fat_per_ans = main_high.fat_per_ans;
        result.tech_main_high_carb_per_ans = main_high.carb_per_ans;

        // Cutting
        result.tech_cut_mod_pro_per_ans = cut_mod.pro_per_ans;
        result.tech_cut_mod_fat_per_ans = cut_mod.fat_per_ans;
        result.tech_cut_mod_carb_per_ans = cut_mod.carb_per_ans;
        
        result.tech_cut_low_pro_per_ans = cut_low.pro_per_ans;
        result.tech_cut_low_fat_per_ans = cut_low.fat_per_ans;
        result.tech_cut_low_carb_per_ans = cut_low.carb_per_ans;
        
        result.tech_cut_high_pro_per_ans = cut_high.pro_per_ans;
        result.tech_cut_high_fat_per_ans = cut_high.fat_per_ans;
        result.tech_cut_high_carb_per_ans = cut_high.carb_per_ans;

        // Bulking
        result.tech_bulk_mod_pro_per_ans = bulk_mod.pro_per_ans;
        result.tech_bulk_mod_fat_per_ans = bulk_mod.fat_per_ans;
        result.tech_bulk_mod_carb_per_ans = bulk_mod.carb_per_ans;
        
        result.tech_bulk_low_pro_per_ans = bulk_low.pro_per_ans;
        result.tech_bulk_low_fat_per_ans = bulk_low.fat_per_ans;
        result.tech_bulk_low_carb_per_ans = bulk_low.carb_per_ans;
        
        result.tech_bulk_high_pro_per_ans = bulk_high.pro_per_ans;
        result.tech_bulk_high_fat_per_ans = bulk_high.fat_per_ans;
        result.tech_bulk_high_carb_per_ans = bulk_high.carb_per_ans;

        result.tech_disable = 'disable';
        return result;

      } catch (error) {
        result.error = 'An error occurred during calculation.';
        console.error('TDEE Calculation Error:', error);
        return result;
      }
    }

     /**
    * getCalculationCalorieDeficitCalculator: Service Method
    * POST: /api/calculators-lol/calorie-deficit-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationCalorieDeficitCalculator(body) {
      let submit = body.tech_unit_type;
      let gender = body.tech_gender;
      let age = body.tech_age;
      let ft_in = body.tech_ft_in;
      let height_cm = body.tech_height_cm;
      let weight = body.tech_weight;
      let target = body.tech_target;
      let activity = body.tech_activity;
      // Helper functions
      function isNumeric(value) {
          return !isNaN(parseFloat(value)) && isFinite(value);
      }

      function getDateDifference(start, end) {
          let years = end.getFullYear() - start.getFullYear();
          let months = end.getMonth() - start.getMonth();
          let days = end.getDate() - start.getDate();

          if (days < 0) {
              months--;
              const prevMonth = new Date(end.getFullYear(), end.getMonth(), 0);
              days += prevMonth.getDate();
          }

          if (months < 0) {
              years--;
              months += 12;
          }

          return { years, months, days };
      }

      function formatDate(date) {
          const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
          const day = date.getDate().toString().padStart(2, '0');
          const month = months[date.getMonth()];
          const year = date.getFullYear();
          return `${day}-${month}-${year}`;
      }

      // Custom rounding function
      function customRound(num) {
          if (num >= 50) {
              return Math.ceil(num / 100) * 100;
          } else {
              return Math.ceil(num / 50) * 50;
          }
      }

      // Validation
      if (!isNumeric(age) || !isNumeric(weight) || !isNumeric(target) || !gender || !activity) {
          return { error: 'Please! Check your input.' };
      }

      let weight_kg, target_kg, height_cm_val;

      if (submit == "lbs") {
          if (!ft_in) {
              return { error: 'Please Select Height.' };
          }
          weight_kg = weight / 2.205;
          target_kg = target / 2.205;
          height_cm_val = ft_in * 2.54;
      } else {
          if (!height_cm) {
              return { error: 'Please Enter Height.' };
          }
          weight_kg = weight;
          target_kg = target;
          height_cm_val = height_cm;
      }

      if (target > weight) {
          return { error: 'Your target weight must be lower than your current weight.' };
      }

      const height_m = height_cm_val / 100;
      const height_in = height_cm_val / 2.54;
      const weight_lbs = weight_kg * 2.205;
      const target_lbs = target_kg * 2.205;

      let RMR, BMR, LBM, RMR_target, BMR_target, LBM_target;
      let Robinson, Miller, Devine, Hamwi;

      if (gender === 'Male') {
          RMR = Math.round(66 + (13.7 * weight_kg) + (5 * height_cm_val) - (6.8 * age));
          BMR = Math.round((height_cm_val * 6.25) + (weight_kg * 10) - (age * 5) + 5);
          LBM = Math.round((0.32810 * weight) + (0.33929 * height_cm_val) - 29.5336);
          RMR_target = Math.round(66 + (13.7 * target_kg) + (5 * height_cm_val) - (6.8 * age));
          BMR_target = Math.round((height_cm_val * 6.25) + (target_kg * 10) - (age * 5) + 5);
          LBM_target = Math.round((0.32810 * target_kg) + (0.33929 * height_cm_val) - 29.5336);
          Robinson = Math.round(52 + (1.9 * (height_in - 60)));
          Miller = Math.round(56.2 + (1.41 * (height_in - 60)));
          Devine = Math.round(50 + (2.3 * (height_in - 60)));
          Hamwi = Math.round(48 + (2.7 * (height_in - 60)));
      } else {
          RMR = Math.round(655 + (9.6 * weight_kg) + (1.8 * height_cm_val) - (4.7 * age));
          BMR = Math.round((height_cm_val * 6.25) + (weight_kg * 10) - (age * 5) - 161);
          LBM = Math.round((0.29569 * weight) + (0.41813 * height_cm_val) - 43.2933);
          RMR_target = Math.round(655 + (9.6 * target_kg) + (1.8 * height_cm_val) - (4.7 * age));
          BMR_target = Math.round((height_cm_val * 6.25) + (target_kg * 10) - (age * 5) - 161);
          LBM_target = Math.round((0.29569 * target_kg) + (0.41813 * height_cm_val) - 43.2933);
          Robinson = Math.round(49 + (1.7 * (height_in - 60)));
          Miller = Math.round(53.1 + (1.36 * (height_in - 60)));
          Devine = Math.round(45.5 + (2.3 * (height_in - 60)));
          Hamwi = Math.round(45 + (2.2 * (height_in - 60)));
      }

      const BMI = Math.round((weight_kg / (height_m * height_m)) * 100) / 100;
      const BMI_target = Math.round((target_kg / (height_m * height_m)) * 100) / 100;

      let ibw;
      if (Hamwi >= Miller) {
          ibw = Miller + ' - ' + Hamwi;
      } else {
          ibw = Hamwi + ' - ' + Miller;
      }

      if (submit == "lbs") {
          Miller = Miller * 2.205;
          Hamwi = Hamwi * 2.205;
          if (Hamwi >= Miller) {
              ibw = Math.round(Miller) + '-' + Math.round(Hamwi);
          } else {
              ibw = Math.round(Hamwi) + '-' + Math.round(Miller);
          }
      }

      const tdee = Math.round(BMR * activity);
      const tdee_target = Math.round(BMR_target * activity);
      
      const first_num = tdee.toString().substring(0, 2);
      const last_num = tdee.toString().slice(-2);
      
      let table_cal;
      if (parseInt(last_num) < 50) {
          table_cal = parseInt(first_num + "00");
      } else {
          table_cal = parseInt(first_num + "50");
      }

      let x = table_cal;
      const main_cal_less = tdee - table_cal;
      let jama = 50;
      const intake_cal_array = [];

      while (x >= 1000) {
          const intake_cal = x;
          const calories_less = jama + main_cal_less;
          const calories_daily = intake_cal - calories_less;
          const pounds_daily = Math.round((calories_less / 3500) * 1000) / 1000;
          const days = Math.round((weight_lbs - target_lbs) / pounds_daily);

          const start_date = new Date();
          const end_date = new Date(start_date);
          end_date.setDate(start_date.getDate() + days);

          const diff = getDateDifference(start_date, end_date);
          let yrs;
          if (diff.years > 0) {
              yrs = `${diff.years} years ${diff.months} months ${diff.days} days`;
          } else {
              yrs = `${diff.months} months ${diff.days} days`;
          }

          const NewDate = formatDate(end_date);
          intake_cal_array.push(`${intake_cal}@@${yrs}@@${NewDate}@@${calories_less}`);
          
          x -= 50;
          jama += 50;
      }

      const weight_loss_cal = Math.round(0.8 * tdee);
      const calorie_def_cal = Math.round(tdee - weight_loss_cal);

      // Calculate final days and pounds_daily
      const final_calories_less = (jama - 50) + main_cal_less;
      const final_pounds_daily = Math.round((final_calories_less / 3500) * 1000) / 1000;
      const final_days = Math.round((weight_lbs - target_lbs) / final_pounds_daily);

      return {
          tech_height_in:height_in,
          tech_tdee:tdee,
          tech_RMR:RMR,
          tech_LBM:LBM,
          tech_tdee_target:tdee_target,
          tech_RMR_target:RMR_target,
          tech_LBM_target:LBM_target,
          tech_BMI:BMI,
          tech_BMI_target:BMI_target,
          tech_intake_cal_array:intake_cal_array,
          tech_age:age,
          tech_gender:gender,
          tech_weight:weight,
          tech_submit:submit,
          tech_target:target,
          tech_activity:activity,
          tech_days: final_days,
          tech_pounds_daily: final_pounds_daily,
          tech_BMR:BMR,
          tech_ibw:ibw,
          tech_weight_loss_cal:weight_loss_cal,
          tech_calorie_def_cal:calorie_def_cal,
      };
  }


       /**
    * getCalculationIpptCalculator: Service Method
    * POST: /api/calculators-lol/ippt-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

   async getCalculationIpptCalculator(body) {
      if (isNaN(body.tech_age) || isNaN(body.tech_push) || isNaN(body.tech_sit)) {
        return { error: "Please! Check Your Input." };
      }

      let age = Number(body.tech_age);
      let push = Number(body.tech_push) - 1;
      let sit = Number(body.tech_sit) - 1;
      let gender = body.gender;
      let time = gender == "Male" ? body.tech_time : body.tech_time_fe;
      let type = body.tech_type;

      // ✅ Determine Age Group
      let age_g = 0;
      if (age < 22) age_g = 0;
      else if (age > 21 && age < 25) age_g = 1;
      else if (age > 24 && age < 28) age_g = 2;
      else if (age > 27 && age < 31) age_g = 3;
      else if (age > 30 && age < 34) age_g = 4;
      else if (age > 33 && age < 37) age_g = 5;
      else if (age > 36 && age < 40) age_g = 6;
      else if (age > 39 && age < 43) age_g = 7;
      else if (age > 42 && age < 46) age_g = 8;
      else if (age > 45 && age < 49) age_g = 9;
      else if (age > 48 && age < 52) age_g = 10;
      else if (age > 51 && age < 55) age_g = 11;
      else if (age > 54 && age < 58) age_g = 12;
      else if (age > 57 && age < 61) age_g = 13;


      // ✅ Male / Female Scoring Arrays
      if (gender == "Male") {
         var pusha = [
                  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,4,6,8,9,10,11,12,13,14,15,15,16,16,16,17,17,17,18,18,18,19,19,19,20,20,20,20,21,21,21,21,22,22,22,22,23,23,23,23,24,24,24,24,25],
                  [0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,4,6,8,9,10,11,12,13,14,15,15,16,16,16,17,17,17,18,18,18,19,19,19,20,20,20,20,21,21,21,21,22,22,22,22,23,23,23,23,24,24,24,24,25,25],
                  [0,0,0,0,0,0,0,0,0,0,0,0,1,2,4,6,8,9,10,11,12,13,14,15,15,16,16,16,17,17,17,18,18,18,19,19,19,20,20,20,20,21,21,21,21,22,22,22,22,23,23,23,23,24,24,24,24,25,25,25],
                  [0,0,0,0,0,0,0,0,0,0,0,1,2,4,6,8,9,10,11,12,13,14,15,15,16,16,16,17,17,17,18,18,18,19,19,19,20,20,20,20,21,21,21,21,22,22,22,22,23,23,23,23,24,24,24,24,25,25,25,25],
                  [0,0,0,0,0,0,0,0,0,0,1,2,4,6,8,9,10,11,12,13,14,15,15,16,16,16,17,17,17,18,18,18,19,19,19,20,20,20,20,21,21,21,21,22,22,22,22,23,23,23,23,24,24,24,24,25,25,25,25,25],
                  [0,0,0,0,0,0,0,0,0,1,2,4,6,8,9,10,11,12,13,14,15,15,16,16,16,17,17,17,18,18,18,19,19,19,20,20,20,20,21,21,21,21,22,22,22,22,23,23,23,23,24,24,24,24,25,25,25,25,25,25],
                  [0,0,0,0,0,0,0,0,1,2,4,6,8,9,10,11,12,13,14,15,15,16,16,16,17,17,17,18,18,18,19,19,19,20,20,20,20,21,21,21,21,22,22,22,22,23,23,23,23,24,24,24,24,25,25,25,25,25,25,25],
                  [0,0,0,0,0,0,0,1,2,4,6,8,9,10,11,12,13,14,15,15,16,16,16,17,17,17,18,18,18,19,19,19,20,20,20,20,21,21,21,21,22,22,22,22,23,23,23,23,24,24,24,24,25,25,25,25,25,25,25,25],
                  [0,0,0,0,0,0,1,2,4,6,8,9,10,11,12,13,14,15,15,16,16,16,17,17,17,18,18,18,19,19,19,20,20,20,21,21,21,21,22,22,22,22,23,23,23,23,24,24,24,24,25,25,25,25,25,25,25,25,25,25],
                  [0,0,0,0,0,1,2,4,6,8,9,10,11,12,13,14,15,15,16,16,16,17,17,17,18,18,18,19,19,19,20,20,20,21,21,21,22,22,22,22,23,23,23,23,24,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25],
                  [0,0,0,0,1,2,4,6,8,9,10,11,12,13,14,15,15,16,16,16,17,17,17,18,18,18,19,19,19,20,20,20,21,21,21,22,22,22,23,23,23,23,24,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25],
                  [0,0,0,1,2,4,6,8,9,10,11,12,13,14,15,15,16,16,16,17,17,17,18,18,18,19,19,19,20,20,20,21,21,21,22,22,22,23,23,23,24,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25],
                  [0,0,1,2,4,6,8,9,10,11,12,13,14,15,15,16,16,16,17,17,17,18,18,18,19,19,19,20,20,21,21,21,22,22,22,23,23,23,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25],
                  [0,1,2,4,6,8,9,10,11,12,13,14,15,15,16,16,16,17,17,17,18,18,18,19,19,19,20,20,21,21,22,22,22,23,23,23,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25]
              ];
              
              var sita = [
                  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,6,7,7,8,9,10,11,12,13,13,14,14,15,16,17,18,18,19,19,20,20,20,20,21,21,21,21,21,22,22,22,22,23,23,23,23,24,24,24,25],
                  [0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,6,7,7,8,9,10,11,12,13,13,14,14,15,16,17,18,18,19,19,20,20,20,20,20,21,21,21,21,22,22,22,22,23,23,23,23,24,24,24,25,25],
                  [0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,6,7,7,8,9,10,11,12,13,13,14,14,15,16,17,18,18,19,19,20,20,20,20,21,21,21,21,22,22,22,22,23,23,23,23,24,24,24,24,25,25,25],
                  [0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,6,7,7,8,9,10,11,12,13,13,14,14,15,16,17,18,18,19,19,20,20,20,20,20,21,21,21,21,22,22,22,22,23,23,23,23,24,24,24,25,25,25,25],
                  [0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,6,7,7,8,9,10,11,12,13,14,14,15,16,16,17,18,18,19,19,20,20,20,20,21,21,21,21,22,22,22,22,23,23,23,23,24,24,24,24,25,25,25,25,25],
                  [0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,6,7,7,8,9,10,11,12,13,14,14,15,16,16,17,18,18,19,19,20,20,20,20,20,21,21,23,21,22,22,22,22,23,23,23,23,24,24,24,25,25,25,25,25,25],
                  [0,0,0,0,0,0,0,0,1,2,3,4,5,6,6,7,7,8,9,10,11,12,13,14,14,15,16,16,17,18,18,19,19,20,20,20,20,21,21,21,21,22,22,22,22,23,23,23,23,24,24,24,24,25,25,25,25,25,25,25],
                  [0,0,0,0,0,0,0,1,2,3,4,5,6,6,7,7,8,9,10,11,12,13,14,14,15,16,16,17,18,18,19,19,20,20,20,20,20,21,21,23,21,22,22,22,22,23,23,23,23,24,24,24,25,25,25,25,25,25,25,25],
                  [0,0,0,0,0,0,1,2,3,4,5,6,6,7,7,8,9,10,11,12,13,14,14,15,16,16,17,18,18,19,19,20,20,20,20,21,21,21,21,22,22,22,22,23,23,23,23,24,24,24,25,25,25,25,25,25,25,25,25,25],
                  [0,0,0,0,0,1,2,3,4,5,6,6,7,7,8,9,10,11,12,13,14,14,15,16,16,17,18,18,19,19,20,20,20,20,20,21,21,21,23,22,22,22,23,23,23,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25],
                  [0,0,0,0,1,2,3,4,5,6,6,7,7,8,9,10,11,12,13,14,14,15,16,16,17,18,18,19,19,20,20,20,20,20,21,21,21,21,22,22,22,23,23,23,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25],
                  [0,0,0,1,2,3,4,5,6,6,7,7,8,9,10,11,12,13,14,14,15,16,16,17,18,18,19,19,20,20,20,20,21,21,21,21,22,22,22,23,23,23,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25],
                  [0,0,1,2,3,4,5,6,6,7,7,8,9,10,11,12,13,14,14,15,16,16,17,18,18,19,19,20,20,20,20,23,21,21,22,22,22,23,23,23,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25],
                  [0,1,2,3,4,5,6,6,7,7,8,9,10,11,12,13,14,14,15,16,16,17,18,18,19,19,20,20,20,21,21,21,22,22,22,23,23,23,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25]
              ];
              
              var timea = [
                  [50,49,48,47,46,45,44,43,42,41,40,39,38,38,37,37,36,36,35,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,16,14,12,10,8,6,4,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                  [50,50,49,48,47,46,45,44,43,42,41,40,39,38,38,37,37,36,36,35,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,16,14,12,10,8,6,4,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                  [50,50,50,49,48,47,46,45,44,43,42,41,40,39,38,38,37,37,36,36,35,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,16,14,12,10,8,6,4,2,1,0,0,0,0,0,0,0,0,0,0,0,0],
                  [50,50,50,50,50,49,48,47,46,45,44,43,42,41,40,39,38,38,37,37,36,36,35,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,16,14,12,10,8,6,4,2,1,0,0,0,0,0,0,0,0,0,0],
                  [50,50,50,50,50,50,49,48,47,46,45,44,43,42,41,40,39,38,38,37,37,36,36,35,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,16,14,12,10,8,6,4,2,1,0,0,0,0,0,0,0,0,0],
                  [50,50,50,50,50,50,50,49,48,47,46,45,44,43,42,41,40,39,38,38,37,37,36,36,35,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,16,14,12,10,8,6,4,2,1,0,0,0,0,0,0,0,0],
                  [50,50,50,50,50,50,50,50,49,48,47,46,45,44,43,42,41,40,39,38,38,37,37,36,36,35,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,16,14,12,10,8,6,4,2,1,0,0,0,0,0,0,0],
                  [50,50,50,50,50,50,50,50,50,49,48,47,46,45,44,43,42,41,40,39,38,38,37,37,36,36,35,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,16,14,12,10,8,6,4,2,1,0,0,0,0,0,0],
                  [50,50,50,50,50,50,50,50,50,50,49,48,47,46,45,44,43,42,41,40,39,38,38,37,37,36,36,35,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,16,14,12,10,8,6,4,2,1,0,0,0,0,0],
                  [50,50,50,50,50,50,50,50,50,50,50,49,48,47,46,45,44,43,42,41,40,39,38,38,37,37,36,36,35,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,16,14,12,10,8,6,4,2,1,0,0,0,0],
                  [50,50,50,50,50,50,50,50,50,50,50,50,49,48,47,46,45,44,43,42,41,40,39,38,38,37,37,36,36,35,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,16,14,12,10,8,6,4,2,1,0,0,0],
                  [50,50,50,50,50,50,50,50,50,50,50,50,50,49,48,47,46,45,44,43,42,41,40,39,38,38,37,37,36,36,35,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,16,14,12,10,8,6,4,2,1,0,0],
                  [50,50,50,50,50,50,50,50,50,50,50,50,50,50,49,48,47,46,45,44,43,42,41,40,39,38,38,37,37,36,36,35,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,16,14,12,10,8,6,4,2,1,0],
                  [50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,49,48,47,46,45,44,43,42,41,40,39,38,38,37,37,36,36,35,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,16,14,12,10,8,6,4,2,1]
              ];
      } else {
        var pusha = [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,5,10,15,15,16,17,18,18,18,19,19,19,20,20,20,20,20,21,21,21,21,22,22,22,22,23,23,23,23,24,24,24,24,24,25],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,1,5,10,15,15,16,17,18,18,18,19,19,19,20,20,20,20,20,21,21,21,21,22,22,22,22,23,23,23,23,24,24,24,24,25,25,25],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,5,10,15,15,16,17,18,18,18,19,19,19,20,20,20,20,21,21,21,21,22,22,22,22,23,23,23,23,24,24,24,24,25,25,25,25,25],
                [0,0,0,0,0,0,0,0,0,0,0,1,5,10,15,15,16,17,18,18,18,19,19,19,20,20,20,21,21,21,21,22,22,22,22,23,23,23,23,24,24,24,24,25,25,25,25,25,25,25],
                [0,0,0,0,0,0,0,0,0,0,1,5,10,15,15,16,17,18,18,18,19,19,19,20,20,20,21,21,21,22,22,22,22,23,23,23,23,24,24,24,24,25,25,25,25,25,25,25,25,25],
                [0,0,0,0,0,0,0,0,0,1,5,10,15,15,16,17,18,18,18,19,19,19,20,20,20,21,21,21,22,22,22,23,23,23,23,24,24,24,24,25,25,25,25,25,25,25,25,25,25,25],
                [0,0,0,0,0,0,0,0,1,5,10,15,15,16,17,18,18,18,19,19,19,20,20,20,21,21,21,22,22,22,23,23,23,24,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25],
                [0,0,0,0,0,0,0,1,5,10,15,15,16,17,18,18,18,19,19,19,20,20,20,21,21,21,22,22,22,23,23,23,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25],
                [0,0,0,0,0,0,1,5,10,15,15,16,17,18,18,19,19,19,20,20,20,21,21,21,22,22,22,23,23,23,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25],
                [0,0,0,0,0,1,5,10,15,15,16,17,18,18,19,19,20,20,20,21,21,21,22,22,22,23,23,23,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25],
                [0,0,0,0,1,5,10,15,15,16,17,18,18,19,19,20,20,21,21,22,22,22,23,23,23,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25],
                [0,0,0,1,5,10,15,15,16,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25],
                [0,0,1,5,10,15,15,16,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25],
                [0,1,5,10,15,15,16,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,50]
            ];
            
            var sita = [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,4,6,8,10,11,12,13,14,15,15,16,16,17,18,18,18,19,19,19,20,20,20,21,21,21,22,22,22,23,23,23,24,24,24,24,25],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,4,6,8,10,11,12,13,14,15,15,16,16,17,18,18,18,19,19,19,20,20,20,21,21,21,22,22,22,23,23,23,24,24,24,25,25,25],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,2,4,6,8,10,11,12,13,14,15,15,16,16,17,18,18,19,19,19,20,20,20,21,21,21,22,22,22,23,23,23,24,24,24,25,25,25,25,25],
                [0,0,0,0,0,0,0,0,0,0,0,1,2,4,6,8,10,11,12,13,14,15,15,16,16,17,18,18,19,19,20,20,20,21,21,21,22,22,22,23,23,23,24,24,24,25,25,25,25,25,25,25],
                [0,0,0,0,0,0,0,0,0,0,1,2,4,6,8,10,11,12,13,14,15,15,16,16,17,18,18,19,19,20,20,21,21,22,22,22,23,23,23,24,24,24,25,25,25,25,25,25,25,25,25,25],
                [0,0,0,0,0,0,0,0,0,1,2,4,6,8,10,11,12,13,14,15,15,16,16,17,18,18,19,19,20,20,21,21,22,22,23,23,23,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25],
                [0,0,0,0,0,0,0,0,1,2,4,6,8,10,11,12,13,14,15,15,16,16,17,18,18,19,19,20,20,21,21,22,22,23,23,23,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25],
                [0,0,0,0,0,0,0,1,2,4,6,8,10,11,12,13,14,15,15,16,16,17,18,18,19,19,20,20,21,21,22,22,23,23,23,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25],
                [0,0,0,0,0,0,1,2,4,6,8,10,11,12,13,14,15,15,16,16,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25],
                [0,0,0,0,0,1,2,4,6,8,10,11,12,13,14,15,15,16,16,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25],
                [0,0,0,0,1,2,4,6,8,10,11,12,13,14,15,15,16,16,17,18,18,19,19,20,21,22,23,23,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25],
                [0,0,0,1,2,4,6,8,10,11,12,13,14,15,15,16,16,17,18,18,19,19,20,21,22,23,23,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25],
                [0,0,1,2,4,6,8,10,11,12,13,14,15,15,16,16,17,18,18,19,19,20,21,22,23,23,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25],
                [0,1,2,4,6,8,10,11,12,13,14,15,15,16,16,17,18,18,19,19,20,21,22,23,23,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25]
            ];
            
            var timea = [
                [50,49,48,47,47,46,46,45,45,44,44,43,43,42,42,41,41,39,39,38,38,38,37,37,37,36,36,36,35,35,35,34,34,33,33,32,32,31,31,30,30,29,28,27,26,25,24,23,22,21,20,18,16,14,12,10,8,6,4,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [50,50,50,49,48,47,46,46,45,45,44,44,43,43,42,42,41,41,39,39,38,38,38,37,37,37,36,36,36,35,35,35,34,34,33,33,32,32,31,31,30,30,29,28,27,26,25,24,23,22,21,20,18,16,14,12,10,8,6,4,2,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [50,50,50,50,49,48,47,46,46,45,45,44,44,43,43,42,42,41,41,39,39,38,38,38,37,37,37,36,36,36,35,35,35,34,34,33,33,32,32,31,31,30,30,29,28,27,26,25,24,23,22,21,20,18,16,14,12,10,8,6,4,2,1,0,0,0,0,0,0,0,0,0,0,0],
                [50,50,50,50,50,49,48,47,46,46,45,45,44,44,43,43,42,42,41,41,39,39,38,38,38,37,37,37,36,36,36,35,35,35,34,34,33,33,32,32,31,31,30,30,29,28,27,26,25,24,23,22,21,20,18,16,14,12,10,8,6,4,2,1,0,0,0,0,0,0,0,0,0,0],
                [50,50,50,50,50,50,49,48,47,46,46,45,45,44,44,43,43,42,42,41,41,39,39,38,38,38,37,37,37,36,36,36,35,35,35,34,34,33,33,32,32,31,31,30,30,29,28,27,26,25,24,23,22,21,20,18,16,14,12,10,8,6,4,2,1,0,0,0,0,0,0,0,0,0],
                [50,50,50,50,50,50,50,49,48,47,46,46,45,45,44,44,43,43,42,42,41,41,39,39,38,38,38,37,37,37,36,36,36,35,35,35,34,34,33,33,32,32,31,31,30,30,29,28,27,26,25,24,23,22,21,20,18,16,14,12,10,8,6,4,2,1,0,0,0,0,0,0,0,0],
                [50,50,50,50,50,50,50,50,49,48,47,46,46,45,45,44,44,43,43,42,42,41,41,39,39,38,38,38,37,37,37,36,36,36,35,35,35,34,34,33,33,32,32,31,31,30,30,29,28,27,26,25,24,23,22,21,20,18,16,14,12,10,8,6,4,2,1,0,0,0,0,0,0,0],
                [50,50,50,50,50,50,50,50,50,49,48,47,46,46,45,45,44,44,43,43,42,42,41,41,39,39,38,38,38,37,37,37,36,36,36,35,35,35,34,34,33,33,32,32,31,31,30,30,29,28,27,26,25,24,23,22,21,20,18,16,14,12,10,8,6,4,2,1,0,0,0,0,0,0],
                [50,50,50,50,50,50,50,50,50,50,49,48,47,46,46,45,45,44,44,43,43,42,42,41,41,39,39,38,38,38,37,37,37,36,36,36,35,35,35,34,34,33,33,32,32,31,31,30,30,29,28,27,26,25,24,23,22,21,20,18,16,14,12,10,8,6,4,2,1,0,0,0,0,0],
                [50,50,50,50,50,50,50,50,50,50,50,49,48,47,46,46,45,45,44,44,43,43,42,42,41,41,39,39,38,38,38,37,37,37,36,36,36,35,35,35,34,34,33,33,32,32,31,31,30,30,29,28,27,26,25,24,23,22,21,20,18,16,14,12,10,8,6,4,2,1,0,0,0,0],
                [50,50,50,50,50,50,50,50,50,50,50,50,50,50,49,48,47,46,45,44,44,43,43,42,42,41,41,39,39,38,38,38,37,37,37,36,36,36,35,35,35,34,34,33,33,32,32,31,31,30,30,29,28,27,26,25,24,23,22,21,20,18,16,14,12,10,8,6,4,2,1,0,0,0],
                [50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,49,48,47,46,45,44,44,43,43,42,42,41,41,39,39,38,38,38,37,37,37,36,36,36,35,35,35,34,34,33,33,32,32,31,31,30,30,29,28,27,26,25,24,23,22,21,20,18,16,14,12,10,8,6,4,2,1,0,0],
                [50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,49,48,47,46,45,44,43,43,42,42,41,41,39,39,38,38,38,37,37,37,36,36,36,35,35,35,34,34,33,33,32,32,31,31,30,30,29,28,27,26,25,24,23,22,21,20,18,16,14,12,10,8,6,4,2,1,0],
                [50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,49,48,47,46,45,44,43,42,42,41,41,39,39,38,38,38,37,37,37,36,36,36,35,35,35,34,34,33,33,32,32,31,31,30,30,29,28,27,26,25,24,23,22,21,20,18,16,14,12,10,8,6,4,2,1]
            ];
      }

      // ✅ Get Scores
      const push_s = pusha[age_g][push];
      const sit_s = sita[age_g][sit];
      const run_s = timea[age_g][time];
      const score = push_s + sit_s + run_s;

      // ✅ Determine Status
      let status = "";
      let to_next = 0;

      if (score < 51) {
        status = "Fail";
        to_next = 51 - score;
      } else if (type == "NSF" && score < 61) {
        status = "Fail";
        to_next = 61 - score;
      } else if (type == "NSM" && score > 50 && score < 61) {
        status = "Pass";
        to_next = 61 - score;
      } else if (type == "NSF" && score > 60 && score < 75) {
        status = "Pass";
        to_next = 75 - score;
      } else if (type == "NSM" && score > 60 && score < 75) {
        status = "incentive";
        to_next = 75 - score;
      } else if (score > 74 && score < 85) {
        status = "Silver";
        to_next = 85 - score;
      } else if (score > 84 && score < 90) {
        status = "Gold";
        to_next = 90 - score;
      } else if (score > 89) {
        status = "Gold1";
      }

      // ✅ Male & Female Running Time Lists
      const male_r = [
        "18:20","18:10","18:00","17:50","17:40","17:30","17:20","17:10","17:00",
        "16:50","16:40","16:30","16:20","16:10","16:00","15:50","15:40","15:30",
        "15:20","15:10","15:00","14:50","14:40","14:30","14:20","14:10","14:00",
        "13:50","13:40","13:30","13:20","13:10","13:00","12:50","12:40","12:30",
        "12:20","12:10","12:00","11:50","11:40","11:30","11:20","11:10","11:00",
        "10:50","10:40","10:30","10:20","10:10","10:00","9:50","9:40","9:30","9:20",
        "9:10","9:00","8:50","8:40","8:30"
      ];

      const female_r = [
        "10:00","10:10","10:20","10:30","10:40","10:50","11:00","11:10","11:20",
        "11:30","11:40","11:50","12:00","12:10","12:20","12:30","12:40","12:50",
        "13:00","13:10","13:20","13:30","13:40","13:50","14:00","14:10","14:20",
        "14:30","14:40","14:50","15:00","15:10","15:20","15:30","15:40","15:50",
        "16:00","16:10","16:20","16:30","16:40","16:50","17:00","17:10","17:20",
        "17:30","17:40","17:50","18:00","18:10","18:20","18:30","18:40","18:50",
        "19:00","19:10","19:20","19:30","19:40","19:50","20:00","20:10","20:20",
        "20:30","20:40","20:50","21:00","21:10","21:20","21:30","21:40","21:50",
        "22:00","22:10"
      ];

      // ✅ Needed push-ups/sit-ups for next level
      const need_push_val = push_s + to_next;
      const need_push = pusha[age_g].indexOf(need_push_val) + 1;

      const need_sit_val = sit_s + to_next;
      const need_sit = sita[age_g].indexOf(need_sit_val) + 1;

      // ✅ Return Response
      return {
        tech_status:status,
        tech_need_push:need_push,
        tech_need_sit:need_sit,
        tech_to_next:to_next,
        tech_score:score,
        tech_push_s:push_s,
        tech_sit_s:sit_s,
        tech_run_s:run_s,
      };
    }

   /**
    * getCalculationHeightPercentileCalculator: Service Method
    * POST: /api/calculators-lol/height-percentile-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

  async  getCalculationHeightPercentileCalculator(body) {
      let height_ft = body.tech_height_ft;
      let height_in = body.tech_height_in;
      let height_cm = body.tech_height_cm;
      let age = body.tech_age;
      let age_unit = body.tech_age_unit;
      let gender = body.tech_gender;
      let unit_ft_in = body.tech_unit_ft_in;

      let ageUnit = age_unit;
      if (age_unit == 'days') {
          ageUnit = 1;
      } else if (age_unit == 'weeks') {
          ageUnit = 2;
      } else if (age_unit == 'months') {
          ageUnit = 3;
      } else if (age_unit == 'years') {
          ageUnit = 4;
      }

      function umar(a, b) {
          let kini;
          if (a == "1") {
              kini = b / 365;
          } else if (a == "2") {
              kini = b / 52.143;
          } else if (a == "3") {
              kini = b / 12;
          } else if (a == "4") {
              kini = b * 1;
          }
          return kini;
      }

      const girls_to_13w = [
          { name: "a", uid: "4292594509", values: { age: 0, P01: "43.4", P1: "44.8", P3: "45.6", P5: "46.1", P10: "46.8", P15: "47.2", P25: "47.9", P50: "49.1", P75: "50.4", P85: "51.1", P90: "51.5", P95: "52.2", P97: "52.7", P99: "53.5", P999: "54.9" } },
          { name: 1, uid: "1320094567", values: { age: 1, P01: "44.5", P1: "45.9", P3: "46.8", P5: "47.2", P10: "47.9", P15: "48.4", P25: "49.1", P50: "50.3", P75: "51.6", P85: "52.3", P90: "52.7", P95: "53.4", P97: "53.9", P99: "54.7", P999: "56.1" } },
          { name: 2, uid: "2956171945", values: { age: 2, P01: "45.6", P1: "47.1", P3: "47.9", P5: "48.4", P10: "49.1", P15: "49.5", P25: "50.2", P50: "51.5", P75: "52.8", P85: "53.5", P90: 54, P95: "54.6", P97: "55.1", P99: "55.9", P999: "57.4" } },
          { name: 3, uid: "655667886", values: { age: 3, P01: "46.5", P1: 48, P3: "48.8", P5: "49.3", P10: 50, P15: "50.5", P25: "51.2", P50: "52.5", P75: "53.8", P85: "54.5", P90: "54.9", P95: "55.6", P97: "56.1", P99: "56.9", P999: "58.4" } },
          { name: 4, uid: "1735974756", values: { age: 4, P01: "47.4", P1: "48.9", P3: "49.7", P5: "50.2", P10: "50.9", P15: "51.4", P25: "52.1", P50: "53.4", P75: "54.7", P85: "55.4", P90: "55.9", P95: "56.6", P97: 57, P99: "57.9", P999: "59.4" } },
          { name: 5, uid: "2331707210", values: { age: 5, P01: "48.2", P1: "49.7", P3: "50.5", P5: 51, P10: "51.7", P15: "52.2", P25: "52.9", P50: "54.2", P75: "55.6", P85: "56.3", P90: "56.8", P95: "57.5", P97: "57.9", P99: "58.8", P999: "60.3" } },
          { name: 6, uid: "627454600", values: { age: 6, P01: "48.9", P1: "50.4", P3: "51.3", P5: "51.8", P10: "52.5", P15: 53, P25: "53.7", P50: "55.1", P75: "56.4", P85: "57.1", P90: "57.6", P95: "58.3", P97: "58.8", P99: "59.7", P999: "61.2" } },
          { name: 7, uid: "926254527", values: { age: 7, P01: "49.6", P1: "51.2", P3: "52.1", P5: "52.5", P10: "53.3", P15: "53.8", P25: "54.5", P50: "55.8", P75: "57.2", P85: "57.9", P90: "58.4", P95: "59.1", P97: "59.6", P99: "60.5", P999: 62 } },
          { name: 8, uid: "1934482258", values: { age: 8, P01: "50.3", P1: "51.9", P3: "52.8", P5: "53.2", P10: 54, P15: "54.5", P25: "55.2", P50: "56.6", P75: "57.9", P85: "58.7", P90: "59.2", P95: "59.9", P97: "60.4", P99: "61.3", P999: "62.8" } },
          { name: 9, uid: "915270415", values: { age: 9, P01: 51, P1: "52.5", P3: "53.4", P5: "53.9", P10: "54.7", P15: "55.2", P25: "55.9", P50: "57.3", P75: "58.7", P85: "59.4", P90: "59.9", P95: "60.6", P97: "61.1", P99: 62, P999: "63.6" } },
          { name: 10, uid: "1188328851", values: { age: 10, P01: "51.6", P1: "53.2", P3: "54.1", P5: "54.6", P10: "55.3", P15: "55.8", P25: "56.6", P50: "57.9", P75: "59.3", P85: "60.1", P90: "60.6", P95: "61.3", P97: "61.8", P99: "62.7", P999: "64.3" } },
          { name: 11, uid: "108398006", values: { age: 11, P01: "52.2", P1: "53.8", P3: "54.7", P5: "55.2", P10: "55.9", P15: "56.4", P25: "57.2", P50: "58.6", P75: 60, P85: "60.7", P90: "61.2", P95: 62, P97: "62.5", P99: "63.4", P999: 65 } },
          { name: 12, uid: "2249598896", values: { age: 12, P01: "52.7", P1: "54.3", P3: "55.3", P5: "55.8", P10: "56.5", P15: 57, P25: "57.8", P50: "59.2", P75: "60.6", P85: "61.4", P90: "61.9", P95: "62.6", P97: "63.1", P99: "64.1", P999: "65.6" } },
          { name: 13, uid: "728608598", values: { age: 13, P01: "53.3", P1: "54.9", P3: "55.8", P5: "56.3", P10: "57.1", P15: "57.6", P25: "58.4", P50: "59.8", P75: "61.2", P85: 62, P90: "62.5", P95: "63.2", P97: "63.7", P99: "64.7", P999: "66.3" } }
      ];

        const boys_to_5y = [
          { name: "a", uid: "4292594509", values: { age: 0, P01: "43.4", P1: "44.8", P3: "45.6", P5: "46.1", P10: "46.8", P15: "47.2", P25: "47.9", P50: "49.1", P75: "50.4", P85: "51.1", P90: "51.5", P95: "52.2", P97: "52.7", P99: "53.5", P999: "54.9" } },
          { name: 1, uid: "1694182680", values: { age: 1, P01: "47.6", P1: "49.1", P3: 50, P5: "50.5", P10: "51.2", P15: "51.7", P25: "52.4", P50: "53.7", P75: 55, P85: "55.7", P90: "56.2", P95: "56.9", P97: "57.4", P99: "58.2", P999: "59.7" } },
          { name: 2, uid: "3836906478", values: { age: 2, P01: "50.8", P1: "52.3", P3: "53.2", P5: "53.7", P10: "54.5", P15: 55, P25: "55.7", P50: "57.1", P75: "58.4", P85: "59.2", P90: "59.7", P95: "60.4", P97: "60.9", P99: "61.8", P999: "63.4" } },
          { name: 3, uid: "1857069783", values: { age: 3, P01: "53.3", P1: "54.9", P3: "55.8", P5: "56.3", P10: "57.1", P15: "57.6", P25: "58.4", P50: "59.8", P75: "61.2", P85: 62, P90: "62.5", P95: "63.3", P97: "63.8", P99: "64.7", P999: "66.3" } },
          { name: 4, uid: "2510953547", values: { age: 4, P01: "55.4", P1: "57.1", P3: 58, P5: "58.5", P10: "59.3", P15: "59.8", P25: "60.6", P50: "62.1", P75: "63.5", P85: "64.3", P90: "64.9", P95: "65.7", P97: "66.2", P99: "67.1", P999: "68.8" } },
          { name: 5, uid: "2879534329", values: { age: 5, P01: "57.2", P1: "58.9", P3: "59.9", P5: "60.4", P10: "61.2", P15: "61.7", P25: "62.5", P50: 64, P75: "65.5", P85: "66.3", P90: "66.9", P95: "67.7", P97: "68.2", P99: "69.2", P999: "70.9" } },
          { name: 6, uid: "3934177210", values: { age: 6, P01: "58.7", P1: "60.5", P3: "61.5", P5: 62, P10: "62.8", P15: "63.4", P25: "64.2", P50: "65.7", P75: "67.3", P85: "68.1", P90: "68.6", P95: "69.5", P97: 70, P99: 71, P999: "72.7" } },
          { name: 7, uid: "4181026999", values: { age: 7, P01: "60.1", P1: "61.9", P3: "62.9", P5: "63.5", P10: "64.3", P15: "64.9", P25: "65.7", P50: "67.3", P75: "68.8", P85: "69.7", P90: "70.3", P95: "71.1", P97: "71.6", P99: "72.7", P999: "74.4" } },
          { name: 8, uid: "1331713863", values: { age: 8, P01: "61.4", P1: "63.2", P3: "64.3", P5: "64.9", P10: "65.7", P15: "66.3", P25: "67.2", P50: "68.7", P75: "70.3", P85: "71.2", P90: "71.8", P95: "72.6", P97: "73.2", P99: "74.3", P999: "76.1" } },
          { name: 9, uid: "2290555629", values: { age: 9, P01: "62.7", P1: "64.5", P3: "65.6", P5: "66.2", P10: 67, P15: "67.6", P25: "68.5", P50: "70.1", P75: "71.8", P85: "72.6", P90: "73.2", P95: "74.1", P97: "74.7", P99: "75.8", P999: "77.6" } },
          { name: 10, uid: "2889369098", values: { age: 10, P01: "63.9", P1: "65.7", P3: "66.8", P5: "67.4", P10: "68.3", P15: "68.9", P25: "69.8", P50: "71.5", P75: "73.1", P85: 74, P90: "74.6", P95: "75.5", P97: "76.1", P99: "77.2", P999: "79.1" } },
          { name: 11, uid: "2996673809", values: { age: 11, P01: 65, P1: "66.9", P3: 68, P5: "68.6", P10: "69.5", P15: "70.2", P25: "71.1", P50: "72.8", P75: "74.5", P85: "75.4", P90: 76, P95: "76.9", P97: "77.5", P99: "78.6", P999: "80.6" } },
          { name: 12, uid: "2016267904", values: { age: 12, P01: "66.1", P1: 68, P3: "69.2", P5: "69.8", P10: "70.7", P15: "71.3", P25: "72.3", P50: 74, P75: "75.8", P85: "76.7", P90: "77.3", P95: "78.3", P97: "78.9", P99: 80, P999: 82 } },
          { name: 13, uid: "2499511250", values: { age: 13, P01: "67.1", P1: "69.1", P3: "70.3", P5: "70.9", P10: "71.8", P15: "72.5", P25: "73.4", P50: "75.2", P75: 77, P85: "77.9", P90: "78.6", P95: "79.5", P97: "80.2", P99: "81.3", P999: "83.3" } },
          { name: 14, uid: "3001587822", values: { age: 14, P01: "68.1", P1: "70.1", P3: "71.3", P5: 72, P10: "72.9", P15: "73.6", P25: "74.6", P50: "76.4", P75: "78.2", P85: "79.2", P90: "79.8", P95: "80.8", P97: "81.4", P99: "82.6", P999: "84.7" } },
          { name: 15, uid: "2541104492", values: { age: 15, P01: 69, P1: "71.1", P3: "72.4", P5: 73, P10: 74, P15: "74.7", P25: "75.7", P50: "77.5", P75: "79.4", P85: "80.3", P90: 81, P95: 82, P97: "82.7", P99: "83.9", P999: 86 } },
          { name: 16, uid: "3609313349", values: { age: 16, P01: 70, P1: "72.1", P3: "73.3", P5: 74, P10: 75, P15: "75.7", P25: "76.7", P50: "78.6", P75: "80.5", P85: "81.5", P90: "82.2", P95: "83.2", P97: "83.9", P99: "85.1", P999: "87.2" } },
          { name: 17, uid: "3392822480", values: { age: 17, P01: "70.9", P1: 73, P3: "74.3", P5: 75, P10: 76, P15: "76.7", P25: "77.7", P50: "79.7", P75: "81.6", P85: "82.6", P90: "83.3", P95: "84.4", P97: 85, P99: "86.3", P999: "88.5" } },
          { name: 18, uid: "3429818064", values: { age: 18, P01: "71.7", P1: 74, P3: "75.2", P5: "75.9", P10: 77, P15: "77.7", P25: "78.7", P50: "80.7", P75: "82.7", P85: "83.7", P90: "84.4", P95: "85.5", P97: "86.2", P99: "87.5", P999: "89.7" } },
          { name: 19, uid: "73114113", values: { age: 19, P01: "72.6", P1: "74.8", P3: "76.2", P5: "76.9", P10: "77.9", P15: "78.7", P25: "79.7", P50: "81.7", P75: "83.7", P85: "84.8", P90: "85.5", P95: "86.6", P97: "87.3", P99: "88.6", P999: "90.9" } },
          { name: 20, uid: "3424860360", values: { age: 20, P01: "73.4", P1: "75.7", P3: 77, P5: "77.7", P10: "78.8", P15: "79.6", P25: "80.7", P50: "82.7", P75: "84.7", P85: "85.8", P90: "86.6", P95: "87.7", P97: "88.4", P99: "89.7", P999: 92 } },
          { name: 21, uid: "99668725", values: { age: 21, P01: "74.2", P1: "76.5", P3: "77.9", P5: "78.6", P10: "79.7", P15: "80.5", P25: "81.6", P50: "83.7", P75: "85.7", P85: "86.8", P90: "87.6", P95: "88.7", P97: "89.4", P99: "90.8", P999: "93.1" } },
          { name: 22, uid: "1332685489", values: { age: 22, P01: 75, P1: "77.3", P3: "78.7", P5: "79.5", P10: "80.6", P15: "81.4", P25: "82.5", P50: "84.6", P75: "86.7", P85: "87.8", P90: "88.6", P95: "89.7", P97: "90.5", P99: "91.9", P999: "94.2" } },
          { name: 23, uid: "2477842487", values: { age: 23, P01: "75.7", P1: "78.1", P3: "79.6", P5: "80.3", P10: "81.5", P15: "82.2", P25: "83.4", P50: "85.5", P75: "87.7", P85: "88.8", P90: "89.6", P95: "90.7", P97: "91.5", P99: "92.9", P999: "95.3" } },
          { name: 24, uid: "3947959837", values: { age: 24, P01: "76.4", P1: "78.9", P3: "80.3", P5: "81.1", P10: "82.3", P15: "83.1", P25: "84.2", P50: "86.4", P75: "88.6", P85: "89.8", P90: "90.6", P95: "91.7", P97: "92.5", P99: "93.9", P999: "96.4" } },
          { name: 25, uid: "3437703006", values: { age: 25, P01: "76.5", P1: 79, P3: "80.4", P5: "81.2", P10: "82.4", P15: "83.2", P25: "84.4", P50: "86.6", P75: "88.8", P85: 90, P90: "90.8", P95: 92, P97: "92.8", P99: "94.2", P999: "96.7" } },
          { name: 26, uid: "2008451231", values: { age: 26, P01: "77.2", P1: "79.7", P3: "81.2", P5: 82, P10: "83.2", P15: 84, P25: "85.2", P50: "87.4", P75: "89.7", P85: "90.9", P90: "91.7", P95: "92.9", P97: "93.7", P99: "95.2", P999: "97.7" } },
          { name: 27, uid: "3869042796", values: { age: 27, P01: "77.8", P1: "80.4", P3: "81.9", P5: "82.7", P10: "83.9", P15: "84.8", P25: 86, P50: "88.3", P75: "90.6", P85: "91.8", P90: "92.6", P95: "93.8", P97: "94.6", P99: "96.1", P999: "98.7" } },
          { name: 28, uid: "488631192", values: { age: 28, P01: "78.5", P1: "81.1", P3: "82.6", P5: "83.5", P10: "84.7", P15: "85.5", P25: "86.8", P50: "89.1", P75: "91.4", P85: "92.7", P90: "93.5", P95: "94.7", P97: "95.6", P99: "97.1", P999: "99.7" } },
          { name: 29, uid: "225902613", values: { age: 29, P01: "79.1", P1: "81.8", P3: "83.4", P5: "84.2", P10: "85.4", P15: "86.3", P25: "87.6", P50: "89.9", P75: "92.2", P85: "93.5", P90: "94.4", P95: "95.6", P97: "96.4", P99: 98, P999: "100.7" } },
          { name: 30, uid: "3905580519", values: { age: 30, P01: "79.8", P1: "82.5", P3: 84, P5: "84.9", P10: "86.2", P15: 87, P25: "88.3", P50: "90.7", P75: "93.1", P85: "94.3", P90: "95.2", P95: "96.5", P97: "97.3", P99: "98.9", P999: "101.6" } },
          { name: 31, uid: "4141214059", values: { age: 31, P01: "80.4", P1: "83.1", P3: "84.7", P5: "85.6", P10: "86.9", P15: "87.7", P25: 89, P50: "91.4", P75: "93.9", P85: "95.2", P90: 96, P95: "97.3", P97: "98.2", P99: "99.8", P999: "102.5" } },
          { name: 32, uid: "2921275721", values: { age: 32, P01: 81, P1: "83.8", P3: "85.4", P5: "86.2", P10: "87.5", P15: "88.4", P25: "89.7", P50: "92.2", P75: "94.6", P85: "95.9", P90: "96.8", P95: "98.2", P97: 99, P99: "100.6", P999: "103.4" } },
          { name: 33, uid: "3413164629", values: { age: 33, P01: "81.6", P1: "84.4", P3: 86, P5: "86.9", P10: "88.2", P15: "89.1", P25: "90.4", P50: "92.9", P75: "95.4", P85: "96.7", P90: "97.6", P95: 99, P97: "99.8", P99: "101.5", P999: "104.3" } },
          { name: 34, uid: "3660971566", values: { age: 34, P01: "82.2", P1: 85, P3: "86.7", P5: "87.5", P10: "88.9", P15: "89.8", P25: "91.1", P50: "93.6", P75: "96.2", P85: "97.5", P90: "98.4", P95: "99.8", P97: "100.6", P99: "102.3", P999: "105.1" } },
          { name: 35, uid: "47436646", values: { age: 35, P01: "82.7", P1: "85.6", P3: "87.3", P5: "88.2", P10: "89.5", P15: "90.5", P25: "91.8", P50: "94.4", P75: "96.9", P85: "98.3", P90: "99.2", P95: "100.5", P97: "101.4", P99: "103.1", P999: 106 } },
          { name: 36, uid: "3561310937", values: { age: 36, P01: "83.3", P1: "86.2", P3: "87.9", P5: "88.8", P10: "90.2", P15: "91.1", P25: "92.5", P50: "95.1", P75: "97.6", P85: 99, P90: "99.9", P95: "101.3", P97: "102.2", P99: "103.9", P999: "106.8" } },
          { name: 37, uid: "1340891525", values: { age: 37, P01: "83.8", P1: "86.8", P3: "88.5", P5: "89.4", P10: "90.8", P15: "91.7", P25: "93.1", P50: "95.7", P75: "98.3", P85: "99.7", P90: "100.7", P95: "102.1", P97: 103, P99: "104.7", P999: "107.6" } },
          { name: 38, uid: "3975654557", values: { age: 38, P01: "84.4", P1: "87.4", P3: "89.1", P5: 90, P10: "91.4", P15: "92.4", P25: "93.8", P50: "96.4", P75: 99, P85: "100.5", P90: "101.4", P95: "102.8", P97: "103.7", P99: "105.5", P999: "108.5" } },
          { name: 39, uid: "4249632025", values: { age: 39, P01: "84.9", P1: "87.9", P3: "89.7", P5: "90.6", P10: 92, P15: 93, P25: "94.4", P50: "97.1", P75: "99.7", P85: "101.2", P90: "102.1", P95: "103.6", P97: "104.5", P99: "106.3", P999: "109.3" } },
          { name: 40, uid: "3256697291", values: { age: 40, P01: "85.4", P1: "88.5", P3: "90.3", P5: "91.2", P10: "92.6", P15: "93.6", P25: "95.1", P50: "97.7", P75: "100.4", P85: "101.9", P90: "102.9", P95: "104.3", P97: "105.2", P99: 107, P999: "110.1" } },
          { name: 41, uid: "1994271769", values: { age: 41, P01: 86, P1: 89, P3: "90.8", P5: "91.8", P10: "93.2", P15: "94.2", P25: "95.7", P50: "98.4", P75: "101.1", P85: "102.6", P90: "103.6", P95: 105, P97: 106, P99: "107.8", P999: "110.8" } },
          { name: 42, uid: "3024703670", values: { age: 42, P01: "86.5", P1: "89.6", P3: "91.4", P5: "92.4", P10: "93.8", P15: "94.8", P25: "96.3", P50: 99, P75: "101.8", P85: "103.3", P90: "104.3", P95: "105.7", P97: "106.7", P99: "108.5", P999: "111.6" } },
          { name: 43, uid: "539761812", values: { age: 43, P01: 87, P1: "90.1", P3: 92, P5: "92.9", P10: "94.4", P15: "95.4", P25: "96.9", P50: "99.7", P75: "102.4", P85: "103.9", P90: "104.9", P95: "106.4", P97: "107.4", P99: "109.2", P999: "112.4" } },
          { name: 44, uid: "1131637531", values: { age: 44, P01: "87.5", P1: "90.7", P3: "92.5", P5: "93.5", P10: 95, P15: 96, P25: "97.5", P50: "100.3", P75: "103.1", P85: "104.6", P90: "105.6", P95: "107.1", P97: "108.1", P99: 110, P999: "113.1" } },
          { name: 45, uid: "770128760", values: { age: 45, P01: 88, P1: "91.2", P3: 93, P5: 94, P10: "95.6", P15: "96.6", P25: "98.1", P50: "100.9", P75: "103.7", P85: "105.3", P90: "106.3", P95: "107.8", P97: "108.8", P99: "110.7", P999: "113.9" } },
          { name: 46, uid: "867275806", values: { age: 46, P01: "88.5", P1: "91.7", P3: "93.6", P5: "94.6", P10: "96.1", P15: "97.2", P25: "98.7", P50: "101.5", P75: "104.4", P85: "105.9", P90: 107, P95: "108.5", P97: "109.5", P99: "111.4", P999: "114.6" } },
          { name: 47, uid: "413845457", values: { age: 47, P01: "88.9", P1: "92.2", P3: "94.1", P5: "95.1", P10: "96.7", P15: "97.7", P25: "99.3", P50: "102.1", P75: 105, P85: "106.6", P90: "107.6", P95: "109.2", P97: "110.2", P99: "112.1", P999: "115.3" } },
          { name: 48, uid: "2294614592", values: { age: 48, P01: "89.4", P1: "92.7", P3: "94.6", P5: "95.6", P10: "97.2", P15: "98.3", P25: "99.8", P50: "102.7", P75: "105.6", P85: "107.2", P90: "108.3", P95: "109.8", P97: "110.8", P99: "112.8", P999: 116 } },
          { name: 49, uid: "2068353644", values: { age: 49, P01: "89.9", P1: "93.2", P3: "95.1", P5: "96.2", P10: "97.8", P15: "98.8", P25: "100.4", P50: "103.3", P75: "106.3", P85: "107.8", P90: "108.9", P95: "110.5", P97: "111.5", P99: "113.4", P999: "116.7" } },
          { name: 50, uid: "1795226332", values: { age: 50, P01: "90.4", P1: "93.7", P3: "95.7", P5: "96.7", P10: "98.3", P15: "99.4", P25: "100.9", P50: "103.9", P75: "106.9", P85: "108.4", P90: "109.5", P95: "111.1", P97: "112.1", P99: "114.1", P999: "117.5" } },
          { name: 51, uid: "1971330515", values: { age: 51, P01: "90.8", P1: "94.2", P3: "96.2", P5: "97.2", P10: "98.8", P15: "99.9", P25: "101.5", P50: "104.5", P75: "107.5", P85: "109.1", P90: "110.1", P95: "111.8", P97: "112.8", P99: "114.8", P999: "118.1" } },
          { name: 52, uid: "1318538245", values: { age: 52, P01: "91.3", P1: "94.7", P3: "96.7", P5: "97.7", P10: "99.3", P15: "100.4", P25: 102, P50: 105, P75: "108.1", P85: "109.7", P90: "110.8", P95: "112.4", P97: "113.4", P99: "115.4", P999: "118.8" } },
          { name: 53, uid: "2514551350", values: { age: 53, P01: "91.7", P1: "95.2", P3: "97.2", P5: "98.2", P10: "99.9", P15: 101, P25: "102.6", P50: "105.6", P75: "108.6", P85: "110.3", P90: "111.4", P95: 113, P97: "114.1", P99: "116.1", P999: "119.5" } },
          { name: 54, uid: "3747670552", values: { age: 54, P01: "92.2", P1: "95.6", P3: "97.6", P5: "98.7", P10: "100.4", P15: "101.5", P25: "103.1", P50: "106.2", P75: "109.2", P85: "110.9", P90: 112, P95: "113.6", P97: "114.7", P99: "116.7", P999: "120.2" } },
          { name: 55, uid: "2605612880", values: { age: 55, P01: "92.6", P1: "96.1", P3: "98.1", P5: "99.2", P10: "100.9", P15: 102, P25: "103.6", P50: "106.7", P75: "109.8", P85: "111.5", P90: "112.6", P95: "114.3", P97: "115.3", P99: "117.4", P999: "120.9" } },
          { name: 56, uid: "163409046", values: { age: 56, P01: 93, P1: "96.6", P3: "98.6", P5: "99.7", P10: "101.4", P15: "102.5", P25: "104.2", P50: "107.3", P75: "110.4", P85: "112.1", P90: "113.2", P95: "114.9", P97: 116, P99: 118, P999: "121.5" } },
          { name: 57, uid: "1692115043", values: { age: 57, P01: "93.5", P1: 97, P3: "99.1", P5: "100.2", P10: "101.9", P15: 103, P25: "104.7", P50: "107.8", P75: 111, P85: "112.6", P90: "113.8", P95: "115.5", P97: "116.6", P99: "118.6", P999: "122.2" } },
          { name: 58, uid: "588246151", values: { age: 58, P01: "93.9", P1: "97.5", P3: "99.6", P5: "100.7", P10: "102.4", P15: "103.5", P25: "105.2", P50: "108.4", P75: "111.5", P85: "113.2", P90: "114.4", P95: "116.1", P97: "117.2", P99: "119.3", P999: "122.8" } },
          { name: 59, uid: "144235665", values: { age: 59, P01: "94.3", P1: "97.9", P3: 100, P5: "101.1", P10: "102.8", P15: 104, P25: "105.7", P50: "108.9", P75: "112.1", P85: "113.8", P90: "114.9", P95: "116.7", P97: "117.8", P99: "119.9", P999: "123.5" } },
          { name: 60, uid: "1501489022", values: { age: 60, P01: "94.7", P1: "98.4", P3: "100.5", P5: "101.6", P10: "103.3", P15: "104.5", P25: "106.2", P50: "109.4", P75: "112.6", P85: "114.4", P90: "115.5", P95: "117.2", P97: "118.4", P99: "120.5", P999: "124.1" } },
          { name: 61, uid: "430782244", values: { age: 61, P01: "96.076", P1: "99.583", P3: "101.629", P5: "102.712", P10: "104.381", P15: "105.506", P25: "107.168", P50: "110.265", P75: "113.362", P85: "115.023", P90: "116.149", P95: "117.817", P97: "118.9", P99: "120.946", P999: "124.453" } },
          { name: 62, uid: "1304649232", values: { age: 62, P01: "96.516", P1: "100.047", P3: "102.106", P5: "103.197", P10: "104.876", P15: "106.01", P25: "107.683", P50: "110.801", P75: "113.918", P85: "115.592", P90: "116.725", P95: "118.404", P97: "119.495", P99: "121.554", P999: "125.086" } },
          { name: 63, uid: "3948184828", values: { age: 63, P01: "96.953", P1: "100.508", P3: "102.581", P5: "103.679", P10: "105.37", P15: "106.51", P25: "108.195", P50: "111.334", P75: "114.473", P85: "116.157", P90: "117.298", P95: "118.989", P97: "120.087", P99: "122.16", P999: "125.715" } },
          { name: 64, uid: "2595030366", values: { age: 64, P01: "97.39", P1: "100.968", P3: "103.054", P5: "104.16", P10: "105.861", P15: "107.009", P25: "108.704", P50: "111.864", P75: "115.023", P85: "116.718", P90: "117.866", P95: "119.568", P97: "120.673", P99: "122.76", P999: "126.337" } },
          { name: 65, uid: "2817129998", values: { age: 65, P01: "97.82", P1: "101.421", P3: "103.522", P5: "104.634", P10: "106.347", P15: "107.503", P25: "109.209", P50: "112.39", P75: "115.57", P85: "117.276", P90: "118.432", P95: "120.145", P97: "121.257", P99: "123.358", P999: "126.959" } },
          { name: 66, uid: "1434310053", values: { age: 66, P01: "98.246", P1: "101.871", P3: "103.985", P5: "105.105", P10: "106.829", P15: "107.992", P25: "109.71", P50: "112.911", P75: "116.112", P85: "117.83", P90: "118.993", P95: "120.717", P97: "121.837", P99: "123.951", P999: "127.576" } },
          { name: 67, uid: "700646132", values: { age: 67, P01: "98.668", P1: "102.316", P3: "104.444", P5: "105.571", P10: "107.307", P15: "108.478", P25: "110.206", P50: "113.428", P75: "116.65", P85: "118.378", P90: "119.549", P95: "121.285", P97: "122.412", P99: "124.54", P999: "128.188" } },
          { name: 68, uid: "3040033768", values: { age: 68, P01: "99.089", P1: "102.76", P3: "104.902", P5: "106.036", P10: "107.782", P15: "108.96", P25: "110.699", P50: "113.941", P75: "117.183", P85: "118.922", P90: "120.1", P95: "121.846", P97: "122.98", P99: "125.122", P999: "128.793" } },
          { name: 69, uid: "3714514231", values: { age: 69, P01: "99.504", P1: "103.198", P3: "105.353", P5: "106.494", P10: "108.252", P15: "109.437", P25: "111.188", P50: "114.45", P75: "117.712", P85: "119.463", P90: "120.648", P95: "122.406", P97: "123.547", P99: "125.702", P999: "129.396" } },
          { name: 70, uid: "2632755756", values: { age: 70, P01: "99.914", P1: "103.632", P3: "105.801", P5: "106.949", P10: "108.717", P15: "109.91", P25: "111.672", P50: "114.955", P75: "118.238", P85: "119.999", P90: "121.192", P95: "122.961", P97: "124.109", P99: "126.277", P999: "129.995" } },
          { name: 71, uid: "3066781923", values: { age: 71, P01: "100.324", P1: "104.064", P3: "106.246", P5: "107.401", P10: "109.18", P15: "110.38", P25: "112.152", P50: "115.455", P75: "118.758", P85: "120.53", P90: "121.73", P95: "123.509", P97: "124.664", P99: "126.846", P999: "130.586" } },
          { name: 72, uid: "2078397296", values: { age: 72, P01: "100.726", P1: "104.49", P3: "106.685", P5: "107.847", P10: "109.637", P15: "110.845", P25: "112.628", P50: "115.951", P75: "119.274", P85: "121.057", P90: "122.265", P95: "124.055", P97: "125.217", P99: "127.412", P999: "131.176" } },
          { name: 73, uid: "1729440127", values: { age: 73, P01: "101.125", P1: "104.912", P3: "107.12", P5: "108.29", P10: "110.091", P15: "111.306", P25: "113.1", P50: "116.443", P75: "119.787", P85: "121.581", P90: "122.796", P95: "124.597", P97: "125.766", P99: "127.975", P999: "131.761" } },
          { name: 74, uid: "418257979", values: { age: 74, P01: "101.525", P1: "105.333", P3: "107.555", P5: "108.731", P10: "110.543", P15: "111.765", P25: "113.569", P50: "116.932", P75: "120.296", P85: "122.1", P90: "123.322", P95: "125.134", P97: "126.31", P99: "128.532", P999: "132.34" } },
          { name: 75, uid: "2741082608", values: { age: 75, P01: "101.918", P1: "105.75", P3: "107.985", P5: "109.169", P10: "110.991", P15: "112.221", P25: "114.036", P50: "117.42", P75: "120.803", P85: "122.619", P90: "123.848", P95: "125.67", P97: "126.854", P99: "129.089", P999: "132.921" } },
          { name: 76, uid: "3602540926", values: { age: 76, P01: "102.31", P1: "106.165", P3: "108.414", P5: "109.604", P10: "111.437", P15: "112.674", P25: "114.501", P50: "117.905", P75: "121.308", P85: "123.135", P90: "124.372", P95: "126.205", P97: "127.396", P99: "129.644", P999: "133.499" } },
          { name: 77, uid: "845527562", values: { age: 77, P01: "102.704", P1: "106.581", P3: "108.842", P5: "110.04", P10: "111.884", P15: "113.128", P25: "114.965", P50: "118.388", P75: "121.811", P85: "123.648", P90: "124.892", P95: "126.736", P97: "127.934", P99: "130.195", P999: "134.072" } },
          { name: 78, uid: "880310114", values: { age: 78, P01: "103.093", P1: "106.993", P3: "109.268", P5: "110.472", P10: "112.327", P15: "113.579", P25: "115.426", P50: "118.87", P75: "122.314", P85: "124.161", P90: "125.413", P95: "127.268", P97: "128.472", P99: "130.747", P999: "134.647" } },
          { name: 79, uid: "1584461390", values: { age: 79, P01: "103.48", P1: "107.403", P3: "109.692", P5: "110.903", P10: "112.769", P15: "114.028", P25: "115.887", P50: "119.351", P75: "122.815", P85: "124.674", P90: "125.932", P95: "127.798", P97: "129.01", P99: "131.298", P999: "135.221" } },
          { name: 80, uid: "149966327", values: { age: 80, P01: "103.867", P1: "107.813", P3: "110.114", P5: "111.333", P10: "113.21", P15: "114.476", P25: "116.346", P50: "119.83", P75: "123.315", P85: "125.184", P90: "126.451", P95: "128.327", P97: "129.546", P99: "131.848", P999: "135.794" } },
          { name: 81, uid: "2312031320", values: { age: 81, P01: "104.255", P1: "108.223", P3: "110.538", P5: "111.764", P10: "113.651", P15: "114.924", P25: "116.805", P50: "120.308", P75: "123.812", P85: "125.693", P90: "126.966", P95: "128.853", P97: "130.079", P99: "132.394", P999: "136.362" } },
          { name: 82, uid: "3476139249", values: { age: 82, P01: "104.638", P1: "108.63", P3: "110.958", P5: "112.191", P10: "114.089", P15: "115.37", P25: "117.261", P50: "120.785", P75: "124.31", P85: "126.201", P90: "127.482", P95: "129.38", P97: "130.613", P99: "132.941", P999: "136.932" } },
          { name: 83, uid: "624866038", values: { age: 83, P01: "105.02", P1: "109.034", P3: "111.376", P5: "112.616", P10: "114.525", P15: "115.814", P25: "117.716", P50: "121.26", P75: "124.805", P85: "126.707", P90: "127.995", P95: "129.905", P97: "131.145", P99: "133.486", P999: "137.501" } },
          { name: 84, uid: "601447789", values: { age: 84, P01: "105.4", P1: "109.437", P3: "111.793", P5: "113.04", P10: "114.96", P15: "116.256", P25: "118.169", P50: "121.734", P75: "125.299", P85: "127.212", P90: "128.508", P95: "130.428", P97: "131.675", P99: "134.03", P999: "138.068" } },
          { name: 85, uid: "1847062413", values: { age: 85, P01: "105.778", P1: "109.839", P3: "112.207", P5: "113.461", P10: "115.393", P15: "116.696", P25: "118.62", P50: "122.205", P75: "125.791", P85: "127.715", P90: "129.018", P95: "130.949", P97: "132.203", P99: "134.572", P999: "138.633" } },
          { name: 86, uid: "1221853667", values: { age: 86, P01: "106.154", P1: "110.238", P3: "112.62", P5: "113.881", P10: "115.824", P15: "117.134", P25: "119.069", P50: "122.675", P75: "126.281", P85: "128.216", P90: "129.526", P95: "131.469", P97: "132.73", P99: "135.112", P999: "139.196" } },
          { name: 87, uid: "4114931826", values: { age: 87, P01: "106.529", P1: "110.635", P3: "113.031", P5: "114.299", P10: "116.253", P15: "117.571", P25: "119.517", P50: "123.143", P75: "126.769", P85: "128.715", P90: "130.033", P95: "131.986", P97: "133.255", P99: "135.65", P999: "139.757" } },
          { name: 88, uid: "2324485048", values: { age: 88, P01: "106.901", P1: "111.031", P3: "113.44", P5: "114.716", P10: "116.68", P15: "118.006", P25: "119.962", P50: "123.609", P75: "127.256", P85: "129.213", P90: "130.538", P95: "132.502", P97: "133.778", P99: "136.187", P999: "140.317" } },
          { name: 89, uid: "1017747503", values: { age: 89, P01: "107.272", P1: "111.425", P3: "113.848", P5: "115.131", P10: "117.106", P15: "118.439", P25: "120.406", P50: "124.074", P75: "127.741", P85: "129.709", P90: "131.041", P95: "133.017", P97: "134.299", P99: "136.722", P999: "140.875" } },
          { name: 90, uid: "1505881967", values: { age: 90, P01: "107.641", P1: "111.818", P3: "114.254", P5: "115.543", P10: "117.53", P15: "118.87", P25: "120.849", P50: "124.536", P75: "128.224", P85: "130.202", P90: "131.543", P95: "133.529", P97: "134.819", P99: "137.255", P999: "141.431" } },
          { name: 91, uid: "3488173932", values: { age: 91, P01: "108.008", P1: "112.208", P3: "114.657", P5: "115.954", P10: "117.951", P15: "119.299", P25: "121.288", P50: "124.996", P75: "128.704", P85: "130.694", P90: "132.042", P95: "134.039", P97: "135.336", P99: "137.785", P999: "141.984" } },
          { name: 92, uid: "401697859", values: { age: 92, P01: "108.373", P1: "112.596", P3: "115.058", P5: "116.363", P10: "118.371", P15: "119.726", P25: "121.726", P50: "125.454", P75: "129.183", P85: "131.183", P90: "132.538", P95: "134.546", P97: "135.851", P99: "138.313", P999: "142.536" } },
          { name: 93, uid: "2397012861", values: { age: 93, P01: "108.736", P1: "112.981", P3: "115.458", P5: "116.769", P10: "118.788", P15: "120.15", P25: "122.162", P50: "125.91", P75: "129.659", P85: "131.671", P90: "133.033", P95: "135.052", P97: "136.363", P99: "138.84", P999: "143.085" } },
          { name: 94, uid: "590217990", values: { age: 94, P01: "109.096", P1: "113.365", P3: "115.854", P5: "117.173", P10: "119.203", P15: "120.573", P25: "122.595", P50: "126.364", P75: "130.133", P85: "132.155", P90: "133.525", P95: "135.555", P97: "136.874", P99: "139.363", P999: "143.632" } },
          { name: 95, uid: "1259371169", values: { age: 95, P01: "109.455", P1: "113.746", P3: "116.249", P5: "117.575", P10: "119.616", P15: "120.993", P25: "123.026", P50: "126.816", P75: "130.605", P85: "132.638", P90: "134.015", P95: "136.056", P97: "137.382", P99: "139.885", P999: "144.176" } },
          { name: 96, uid: "890803329", values: { age: 96, P01: "109.811", P1: "114.126", P3: "116.642", P5: "117.975", P10: "120.027", P15: "121.411", P25: "123.456", P50: "127.265", P75: "131.075", P85: "133.119", P90: "134.503", P95: "136.555", P97: "137.888", P99: "140.404", P999: "144.719" } },
          { name: 97, uid: "3747565444", values: { age: 97, P01: "110.166", P1: "114.504", P3: "117.034", P5: "118.373", P10: "120.436", P15: "121.828", P25: "123.883", P50: "127.713", P75: "131.543", P85: "133.598", P90: "134.99", P95: "137.053", P97: "138.392", P99: "140.922", P999: "145.26" } },
          { name: 98, uid: "779671503", values: { age: 98, P01: "110.519", P1: "114.88", P3: "117.423", P5: "118.77", P10: "120.844", P15: "122.243", P25: "124.309", P50: "128.159", P75: "132.009", P85: "134.075", P90: "135.474", P95: "137.548", P97: "138.895", P99: "141.438", P999: "145.799" } },
          { name: 99, uid: "2353325356", values: { age: 99, P01: "110.871", P1: "115.254", P3: "117.811", P5: "119.165", P10: "121.249", P15: "122.656", P25: "124.733", P50: "128.603", P75: "132.474", P85: "134.551", P90: "135.957", P95: "138.042", P97: "139.396", P99: "141.953", P999: "146.336" } },
          { name: 100, uid: "2983512797", values: { age: 100, P01: "111.221", P1: "115.627", P3: "118.197", P5: "119.558", P10: "121.654", P15: "123.068", P25: "125.156", P50: "129.047", P75: "132.937", P85: "135.025", P90: "136.439", P95: "138.535", P97: "139.896", P99: "142.466", P999: "146.872" } },
          { name: 101, uid: "3769753469", values: { age: 101, P01: "111.57", P1: "115.999", P3: "118.583", P5: "119.951", P10: "122.058", P15: "123.479", P25: "125.578", P50: "129.489", P75: "133.4", P85: "135.498", P90: "136.92", P95: "139.026", P97: "140.394", P99: "142.978", P999: "147.407" } },
          { name: 102, uid: "289944114", values: { age: 102, P01: "111.914", P1: "116.367", P3: "118.965", P5: "120.341", P10: "122.459", P15: "123.888", P25: "125.998", P50: "129.93", P75: "133.862", P85: "135.972", P90: "137.401", P95: "139.519", P97: "140.895", P99: "143.493", P999: "147.946" } },
          { name: 103, uid: "2174618243", values: { age: 103, P01: "112.261", P1: "116.738", P3: "119.349", P5: "120.731", P10: "122.86", P15: "124.297", P25: "126.418", P50: "130.37", P75: "134.323", P85: "136.444", P90: "137.881", P95: "140.01", P97: "141.392", P99: "144.003", P999: "148.48" } },
          { name: 104, uid: "3159005784", values: { age: 104, P01: "112.608", P1: "117.107", P3: "119.732", P5: "121.121", P10: "123.261", P15: "124.705", P25: "126.837", P50: "130.81", P75: "134.783", P85: "136.915", P90: "138.359", P95: "140.499", P97: "141.889", P99: "144.513", P999: "149.013" } },
          { name: 105, uid: "1635282944", values: { age: 105, P01: "112.953", P1: "117.476", P3: "120.114", P5: "121.511", P10: "123.662", P15: "125.113", P25: "127.256", P50: "131.25", P75: "135.243", P85: "137.386", P90: "138.837", P95: "140.988", P97: "142.385", P99: "145.023", P999: "149.546" } },
          { name: 106, uid: "2635518549", values: { age: 106, P01: "113.298", P1: "117.844", P3: "120.496", P5: "121.9", P10: "124.062", P15: "125.521", P25: "127.675", P50: "131.688", P75: "135.702", P85: "137.856", P90: "139.315", P95: "141.477", P97: "142.881", P99: "145.532", P999: "150.078" } },
          { name: 107, uid: "1879569795", values: { age: 107, P01: "113.643", P1: "118.212", P3: "120.877", P5: "122.288", P10: "124.461", P15: "125.928", P25: "128.093", P50: "132.127", P75: "136.161", P85: "138.326", P90: "139.792", P95: "141.965", P97: "143.377", P99: "146.042", P999: "150.611" } },
          { name: 108, uid: "1683816934", values: { age: 108, P01: "113.987", P1: "118.58", P3: "121.258", P5: "122.677", P10: "124.861", P15: "126.334", P25: "128.51", P50: "132.565", P75: "136.62", P85: "138.796", P90: "140.27", P95: "142.454", P97: "143.872", P99: "146.551", P999: "151.143" } },
          { name: 109, uid: "4176610999", values: { age: 109, P01: "114.331", P1: "118.947", P3: "121.639", P5: "123.064", P10: "125.26", P15: "126.741", P25: "128.928", P50: "133.003", P75: "137.079", P85: "139.266", P90: "140.747", P95: "142.942", P97: "144.367", P99: "147.06", P999: "151.675" } },
          { name: 110, uid: "3844025369", values: { age: 110, P01: "114.674", P1: "119.313", P3: "122.019", P5: "123.451", P10: "125.658", P15: "127.146", P25: "129.344", P50: "133.44", P75: "137.536", P85: "139.735", P90: "141.223", P95: "143.429", P97: "144.862", P99: "147.568", P999: "152.207" } },
          { name: 111, uid: "3683987628", values: { age: 111, P01: "115.016", P1: "119.678", P3: "122.398", P5: "123.838", P10: "126.055", P15: "127.551", P25: "129.76", P50: "133.877", P75: "137.994", P85: "140.203", P90: "141.699", P95: "143.916", P97: "145.356", P99: "148.076", P999: "152.738" } },
          { name: 112, uid: "137361947", values: { age: 112, P01: "115.361", P1: "120.046", P3: "122.779", P5: "124.226", P10: "126.454", P15: "127.957", P25: "130.177", P50: "134.313", P75: "138.449", P85: "140.669", P90: "142.172", P95: "144.4", P97: "145.847", P99: "148.58", P999: "153.265" } },
          { name: 113, uid: "451296020", values: { age: 113, P01: "115.702", P1: "120.41", P3: "123.156", P5: "124.61", P10: "126.85", P15: "128.36", P25: "130.591", P50: "134.748", P75: "138.905", P85: "141.136", P90: "142.647", P95: "144.886", P97: "146.34", P99: "149.086", P999: "153.795" } },
          { name: 114, uid: "2373802134", values: { age: 114, P01: "116.042", P1: "120.773", P3: "123.533", P5: "124.995", P10: "127.245", P15: "128.763", P25: "131.005", P50: "135.183", P75: "139.361", P85: "141.603", P90: "143.121", P95: "145.371", P97: "146.833", P99: "149.592", P999: "154.324" } },
          { name: 115, uid: "667841728", values: { age: 115, P01: "116.385", P1: "121.139", P3: "123.912", P5: "125.38", P10: "127.641", P15: "129.167", P25: "131.419", P50: "135.617", P75: "139.814", P85: "142.067", P90: "143.592", P95: "145.853", P97: "147.322", P99: "150.095", P999: "154.849" } },
          { name: 116, uid: "1272808188", values: { age: 116, P01: "116.723", P1: "121.501", P3: "124.287", P5: "125.763", P10: "128.035", P15: "129.568", P25: "131.832", P50: "136.05", P75: "140.269", P85: "142.532", P90: "144.065", P95: "146.337", P97: "147.813", P99: "150.6", P999: "155.377" } },
          { name: 117, uid: "2924658003", values: { age: 117, P01: "117.065", P1: "121.865", P3: "124.665", P5: "126.147", P10: "128.43", P15: "129.97", P25: "132.245", P50: "136.483", P75: "140.721", P85: "142.996", P90: "144.536", P95: "146.819", P97: "148.301", P99: "151.101", P999: "155.901" } },
          { name: 118, uid: "292285188", values: { age: 118, P01: "117.402", P1: "122.225", P3: "125.039", P5: "126.529", P10: "128.823", P15: "130.371", P25: "132.656", P50: "136.915", P75: "141.174", P85: "143.46", P90: "145.008", P95: "147.302", P97: "148.792", P99: "151.605", P999: "156.429" } },
          { name: 119, uid: "1775430122", values: { age: 119, P01: "117.743", P1: "122.589", P3: "125.416", P5: "126.912", P10: "129.217", P15: "130.772", P25: "133.068", P50: "137.347", P75: "141.626", P85: "143.923", P90: "145.478", P95: "147.782", P97: "149.279", P99: "152.106", P999: "156.952" } },
          { name: 120, uid: "2517110824", values: { age: 120, P01: "118.083", P1: "122.952", P3: "125.792", P5: "127.296", P10: "129.611", P15: "131.174", P25: "133.481", P50: "137.78", P75: "142.078", P85: "144.385", P90: "145.948", P95: "148.263", P97: "149.767", P99: "152.607", P999: "157.476" } },
          { name: 121, uid: "3473313914", values: { age: 121, P01: "118.424", P1: "123.315", P3: "126.169", P5: "127.679", P10: "130.006", P15: "131.575", P25: "133.893", P50: "138.212", P75: "142.531", P85: "144.849", P90: "146.418", P95: "148.744", P97: "150.255", P99: "153.108", P999: 158 } },
          { name: 122, uid: "1917767853", values: { age: 122, P01: "118.765", P1: "123.679", P3: "126.546", P5: "128.064", P10: "130.401", P15: "131.978", P25: "134.306", P50: "138.645", P75: "142.984", P85: "145.313", P90: "146.89", P95: "149.227", P97: "150.745", P99: "153.611", P999: "158.525" } },
          { name: 123, uid: "4188619211", values: { age: 123, P01: "119.107", P1: "124.044", P3: "126.924", P5: "128.449", P10: "130.797", P15: "132.381", P25: "134.72", P50: "139.08", P75: "143.439", P85: "145.778", P90: "147.362", P95: "149.71", P97: "151.235", P99: "154.115", P999: "159.052" } },
          { name: 124, uid: "3109720063", values: { age: 124, P01: "119.451", P1: "124.411", P3: "127.304", P5: "128.836", P10: "131.195", P15: "132.786", P25: "135.136", P50: "139.516", P75: "143.895", P85: "146.245", P90: "147.837", P95: "150.196", P97: "151.728", P99: "154.621", P999: "159.581" } },
          { name: 125, uid: "2302253123", values: { age: 125, P01: "119.796", P1: "124.779", P3: "127.685", P5: "129.224", P10: "131.594", P15: "133.193", P25: "135.554", P50: "139.954", P75: "144.354", P85: "146.715", P90: "148.314", P95: "150.684", P97: "152.223", P99: "155.129", P999: "160.112" } },
          { name: 126, uid: "2964250079", values: { age: 126, P01: "120.147", P1: "125.152", P3: "128.071", P5: "129.617", P10: "131.998", P15: "133.604", P25: "135.975", P50: "140.395", P75: "144.814", P85: "147.186", P90: "148.792", P95: "151.172", P97: "152.718", P99: "155.638", P999: "160.643" } },
          { name: 127, uid: "338678783", values: { age: 127, P01: "120.496", P1: "125.525", P3: "128.458", P5: "130.011", P10: "132.403", P15: "134.016", P25: "136.399", P50: "140.839", P75: "145.279", P85: "147.661", P90: "149.275", P95: "151.666", P97: "153.22", P99: "156.153", P999: "161.181" } },
          { name: 128, uid: "1263138964", values: { age: 128, P01: "120.853", P1: "125.904", P3: "128.85", P5: "130.41", P10: "132.812", P15: "134.433", P25: "136.826", P50: "141.286", P75: "145.746", P85: "148.139", P90: "149.76", P95: "152.162", P97: "153.722", P99: "156.668", P999: "161.719" } },
          { name: 129, uid: "1817793496", values: { age: 129, P01: "121.212", P1: "126.286", P3: "129.245", P5: "130.812", P10: "133.225", P15: "134.853", P25: "137.257", P50: "141.737", P75: "146.217", P85: "148.621", P90: "150.249", P95: "152.662", P97: "154.229", P99: "157.188", P999: "162.261" } },
          { name: 130, uid: "3021169938", values: { age: 130, P01: "121.575", P1: "126.671", P3: "129.644", P5: "131.218", P10: "133.642", P15: "135.277", P25: "137.692", P50: "142.192", P75: "146.692", P85: "149.106", P90: "150.742", P95: "153.165", P97: "154.74", P99: "157.712", P999: "162.808" } },
          { name: 131, uid: "933563622", values: { age: 131, P01: "121.94", P1: "127.06", P3: "130.046", P5: "131.627", P10: "134.062", P15: "135.704", P25: "138.13", P50: "142.65", P75: "147.17", P85: "149.596", P90: "151.239", P95: "153.673", P97: "155.255", P99: "158.241", P999: "163.36" } },
          { name: 132, uid: "230550625", values: { age: 132, P01: "122.314", P1: "127.455", P3: "130.454", P5: "132.042", P10: "134.487", P15: "136.137", P25: "138.573", P50: "143.113", P75: "147.652", P85: "150.088", P90: "151.738", P95: "154.183", P97: "155.771", P99: "158.77", P999: "163.912" } },
          { name: 133, uid: "2510808441", values: { age: 133, P01: "122.686", P1: "127.851", P3: "130.863", P5: "132.458", P10: "134.915", P15: "136.572", P25: "139.019", P50: "143.58", P75: "148.14", P85: "150.587", P90: "152.244", P95: "154.701", P97: "156.296", P99: "159.308", P999: "164.473" } },
          { name: 134, uid: "2619878640", values: { age: 134, P01: "123.067", P1: "128.254", P3: "131.279", P5: "132.882", P10: "135.349", P15: "137.013", P25: "139.471", P50: "144.051", P75: "148.631", P85: "151.089", P90: "152.754", P95: "155.221", P97: "156.823", P99: "159.848", P999: "165.036" } },
          { name: 135, uid: "2556350469", values: { age: 135, P01: "123.451", P1: "128.661", P3: "131.7", P5: "133.309", P10: "135.787", P15: "137.459", P25: "139.927", P50: "144.528", P75: "149.128", P85: "151.596", P90: "153.268", P95: "155.746", P97: "157.355", P99: "160.394", P999: "165.604" } },
          { name: 136, uid: "3460670524", values: { age: 136, P01: "123.845", P1: "129.077", P3: "132.128", P5: "133.744", P10: "136.232", P15: "137.911", P25: "140.39", P50: "145.009", P75: "149.629", P85: "152.108", P90: "153.786", P95: "156.275", P97: "157.89", P99: "160.942", P999: "166.174" } },
          { name: 137, uid: "3314160856", values: { age: 137, P01: "124.238", P1: "129.493", P3: "132.558", P5: "134.181", P10: "136.681", P15: "138.367", P25: "140.857", P50: "145.496", P75: "150.136", P85: "152.626", P90: "154.312", P95: "156.811", P97: "158.435", P99: "161.5", P999: "166.754" } },
          { name: 138, uid: "504113973", values: { age: 138, P01: "124.641", P1: "129.918", P3: "132.996", P5: "134.626", P10: "137.136", P15: "138.829", P25: "141.33", P50: "145.989", P75: "150.649", P85: "153.149", P90: "154.842", P95: "157.352", P97: "158.982", P99: "162.06", P999: "167.337" } },
          { name: 139, uid: "1400014522", values: { age: 139, P01: "125.049", P1: "130.348", P3: "133.439", P5: "135.076", P10: "137.597", P15: "139.297", P25: "141.808", P50: "146.488", P75: "151.167", P85: "153.678", P90: "155.379", P95: "157.899", P97: "159.536", P99: "162.627", P999: "167.927" } },
          { name: 140, uid: "1168911856", values: { age: 140, P01: "125.462", P1: "130.784", P3: "133.888", P5: "135.532", P10: "138.064", P15: "139.771", P25: "142.293", P50: "146.993", P75: "151.692", P85: "154.214", P90: "155.922", P95: "158.453", P97: "160.097", P99: "163.201", P999: "168.524" } },
          { name: 141, uid: "3128175767", values: { age: 141, P01: "125.88", P1: "131.225", P3: "134.343", P5: "135.994", P10: "138.536", P15: "140.252", P25: "142.784", P50: "147.504", P75: "152.224", P85: "154.757", P90: "156.472", P95: "159.014", P97: "160.665", P99: "163.783", P999: "169.128" } },
          { name: 142, uid: "3558648845", values: { age: 142, P01: "126.309", P1: "131.676", P3: "134.807", P5: "136.465", P10: "139.017", P15: "140.74", P25: "143.283", P50: "148.022", P75: "152.762", P85: "155.305", P90: "157.027", P95: "159.58", P97: "161.238", P99: "164.369", P999: "169.736" } },
          { name: 143, uid: "2307687108", values: { age: 143, P01: "126.743", P1: "132.133", P3: "135.277", P5: "136.942", P10: "139.505", P15: "141.235", P25: "143.789", P50: "148.548", P75: "153.307", P85: "155.861", P90: "157.59", P95: "160.154", P97: "161.819", P99: "164.963", P999: "170.353" } },
          { name: 144, uid: "1262322983", values: { age: 144, P01: "127.184", P1: "132.597", P3: "135.754", P5: "137.426", P10: 140, P15: "141.737", P25: "144.301", P50: "149.081", P75: "153.86", P85: "156.425", P90: "158.162", P95: "160.736", P97: "162.408", P99: "165.565", P999: "170.977" } },
          { name: 145, uid: "279612429", values: { age: 145, P01: "127.636", P1: "133.07", P3: "136.24", P5: "137.919", P10: "140.504", P15: "142.248", P25: "144.823", P50: "149.621", P75: "154.42", P85: "156.995", P90: "158.739", P95: "161.323", P97: "163.002", P99: "166.172", P999: "171.607" } },
          { name: 146, uid: "3142117998", values: { age: 146, P01: "128.09", P1: "133.548", P3: "136.731", P5: "138.417", P10: "141.013", P15: "142.764", P25: "145.35", P50: "150.169", P75: "154.989", P85: "157.575", P90: "159.326", P95: "161.922", P97: "163.608", P99: "166.791", P999: "172.249" } },
          { name: 147, uid: "3231907183", values: { age: 147, P01: "128.559", P1: "134.039", P3: "137.235", P5: "138.927", P10: "141.533", P15: "143.291", P25: "145.887", P50: "150.726", P75: "155.564", P85: "158.16", P90: "159.918", P95: "162.524", P97: "164.217", P99: "167.413", P999: "172.892" } },
          { name: 148, uid: "197365089", values: { age: 148, P01: "129.031", P1: "134.533", P3: "137.743", P5: "139.442", P10: "142.059", P15: "143.825", P25: "146.432", P50: "151.29", P75: "156.148", P85: "158.755", P90: "160.521", P95: "163.138", P97: "164.837", P99: "168.046", P999: "173.549" } },
          { name: 149, uid: "2572357721", values: { age: 149, P01: "129.515", P1: "135.039", P3: "138.261", P5: "139.967", P10: "142.595", P15: "144.367", P25: "146.985", P50: "151.862", P75: "156.74", P85: "159.357", P90: "161.13", P95: "163.757", P97: "165.464", P99: "168.686", P999: "174.21" } },
          { name: 150, uid: "3333712994", values: { age: 150, P01: "130.005", P1: "135.551", P3: "138.786", P5: "140.499", P10: "143.137", P15: "144.917", P25: "147.545", P50: "152.442", P75: "157.34", P85: "159.968", P90: "161.748", P95: "164.386", P97: "166.099", P99: "169.334", P999: "174.88" } },
          { name: 151, uid: "2104858378", values: { age: 151, P01: "130.506", P1: "136.073", P3: "139.321", P5: "141.041", P10: "143.689", P15: "145.475", P25: "148.114", P50: "153.03", P75: "157.946", P85: "160.584", P90: "162.371", P95: "165.019", P97: "166.739", P99: "169.986", P999: "175.554" } },
          { name: 152, uid: "514590605", values: { age: 152, P01: "131.007", P1: "136.598", P3: "139.859", P5: "141.585", P10: "144.244", P15: "146.038", P25: "148.687", P50: "153.623", P75: "158.56", P85: "161.209", P90: "163.003", P95: "165.661", P97: "167.388", P99: "170.649", P999: "176.24" } },
          { name: 153, uid: "2398471900", values: { age: 153, P01: "131.523", P1: "137.134", P3: "140.407", P5: "142.14", P10: "144.809", P15: "146.609", P25: "149.268", P50: "154.222", P75: "159.177", P85: "161.836", P90: "163.636", P95: "166.305", P97: "168.038", P99: "171.311", P999: "176.922" } },
          { name: 154, uid: "4041165890", values: { age: 154, P01: "132.037", P1: "137.67", P3: "140.956", P5: "142.696", P10: "145.375", P15: "147.183", P25: "149.852", P50: "154.826", P75: "159.8", P85: "162.469", P90: "164.276", P95: "166.956", P97: "168.695", P99: "171.981", P999: "177.614" } },
          { name: 155, uid: "791916420", values: { age: 155, P01: "132.56", P1: "138.214", P3: "141.512", P5: "143.258", P10: "145.947", P15: "147.762", P25: "150.441", P50: "155.433", P75: "160.425", P85: "163.104", P90: "164.919", P95: "167.608", P97: "169.354", P99: "172.652", P999: "178.306" } },
          { name: 156, uid: "326613932", values: { age: 156, P01: "133.09", P1: "138.763", P3: "142.073", P5: "143.825", P10: "146.524", P15: "148.344", P25: "151.033", P50: "156.043", P75: "161.052", P85: "163.741", P90: "165.561", P95: "168.26", P97: "170.012", P99: "173.322", P999: "178.996" } },
          { name: 157, uid: "3943529072", values: { age: 157, P01: "133.621", P1: "139.314", P3: "142.635", P5: "144.394", P10: "147.102", P15: "148.929", P25: "151.627", P50: "156.654", P75: "161.681", P85: "164.379", P90: "166.206", P95: "168.914", P97: "170.673", P99: "173.994", P999: "179.687" } },
          { name: 158, uid: "3092908032", values: { age: 158, P01: "134.152", P1: "139.866", P3: "143.198", P5: "144.963", P10: "147.681", P15: "149.514", P25: "152.221", P50: "157.266", P75: "162.311", P85: "165.018", P90: "166.851", P95: "169.569", P97: "171.334", P99: "174.666", P999: "180.38" } },
          { name: 159, uid: "2750463162", values: { age: 159, P01: "134.684", P1: "140.417", P3: "143.761", P5: "145.532", P10: "148.259", P15: "150.099", P25: "152.815", P50: "157.878", P75: "162.94", P85: "165.656", P90: "167.496", P95: "170.223", P97: "171.994", P99: "175.338", P999: "181.071" } },
          { name: 160, uid: "4045070226", values: { age: 160, P01: "135.219", P1: "140.97", P3: "144.325", P5: "146.102", P10: "148.837", P15: "150.683", P25: "153.408", P50: "158.487", P75: "163.566", P85: "166.291", P90: "168.137", P95: "170.872", P97: "172.649", P99: "176.004", P999: "181.756" } },
          { name: 161, uid: "81391415", values: { age: 161, P01: "135.756", P1: "141.525", P3: "144.89", P5: "146.671", P10: "149.415", P15: "151.266", P25: 154, P50: "159.094", P75: "164.188", P85: "166.921", P90: "168.772", P95: "171.516", P97: "173.298", P99: "176.663", P999: "182.432" } },
          { name: 162, uid: "1329091151", values: { age: 162, P01: "136.285", P1: "142.072", P3: "145.447", P5: "147.235", P10: "149.987", P15: "151.844", P25: "154.586", P50: "159.696", P75: "164.806", P85: "167.548", P90: "169.405", P95: "172.158", P97: "173.945", P99: "177.321", P999: "183.108" } },
          { name: 163, uid: "3164086796", values: { age: 163, P01: "136.815", P1: "142.618", P3: "146.004", P5: "147.796", P10: "150.557", P15: "152.419", P25: "155.169", P50: "160.294", P75: "165.419", P85: "168.169", P90: "170.031", P95: "172.791", P97: "174.584", P99: "177.969", P999: "183.773" } },
          { name: 164, uid: "1140954684", values: { age: 164, P01: "137.345", P1: "143.164", P3: "146.558", P5: "148.356", P10: "151.123", P15: "152.991", P25: "155.748", P50: "160.886", P75: "166.024", P85: "168.782", P90: "170.649", P95: "173.417", P97: "175.214", P99: "178.608", P999: "184.427" } },
          { name: 165, uid: "2986250480", values: { age: 165, P01: "137.87", P1: "143.704", P3: "147.107", P5: "148.909", P10: "151.684", P15: "153.556", P25: "156.32", P50: "161.472", P75: "166.624", P85: "169.388", P90: "171.26", P95: "174.035", P97: "175.837", P99: "179.24", P999: "185.074" } },
          { name: 166, uid: "2306330411", values: { age: 166, P01: "138.389", P1: "144.238", P3: "147.649", P5: "149.456", P10: "152.238", P15: "154.115", P25: "156.886", P50: "162.05", P75: "167.215", P85: "169.986", P90: "171.863", P95: "174.645", P97: "176.452", P99: "179.863", P999: "185.712" } },
          { name: 167, uid: "3261233776", values: { age: 167, P01: "138.901", P1: "144.764", P3: "148.184", P5: "149.995", P10: "152.784", P15: "154.665", P25: "157.444", P50: "162.621", P75: "167.798", P85: "170.576", P90: "172.458", P95: "175.246", P97: "177.057", P99: "180.477", P999: "186.34" } },
          { name: 168, uid: "2172835202", values: { age: 168, P01: "139.41", P1: "145.286", P3: "148.714", P5: "150.529", P10: "153.323", P15: "155.209", P25: "157.993", P50: "163.182", P75: "168.37", P85: "171.154", P90: "173.04", P95: "175.834", P97: "177.649", P99: "181.077", P999: "186.953" } },
          { name: 169, uid: "2205288039", values: { age: 169, P01: "139.916", P1: "145.803", P3: "149.237", P5: "151.055", P10: "153.855", P15: "155.744", P25: "158.534", P50: "163.732", P75: "168.93", P85: "171.72", P90: "173.609", P95: "176.409", P97: "178.227", P99: "181.661", P999: "187.548" } },
          { name: 170, uid: "2284826073", values: { age: 170, P01: "140.408", P1: "146.307", P3: "149.747", P5: "151.569", P10: "154.375", P15: "156.268", P25: "159.063", P50: "164.272", P75: "169.48", P85: "172.275", P90: "174.168", P95: "176.974", P97: "178.796", P99: "182.237", P999: "188.136" } },
          { name: 171, uid: "2641770925", values: { age: 171, P01: "140.894", P1: "146.804", P3: "150.25", P5: "152.075", P10: "154.886", P15: "156.782", P25: "159.582", P50: "164.799", P75: "170.017", P85: "172.817", P90: "174.713", P95: "177.523", P97: "179.349", P99: "182.795", P999: "188.704" } },
          { name: 172, uid: "271759548", values: { age: 172, P01: "141.37", P1: "147.289", P3: "150.742", P5: "152.57", P10: "155.385", P15: "157.284", P25: "160.088", P50: "165.314", P75: "170.541", P85: "173.345", P90: "175.244", P95: "178.059", P97: "179.887", P99: "183.34", P999: "189.259" } },
          { name: 173, uid: "1031940298", values: { age: 173, P01: "141.841", P1: "147.767", P3: "151.224", P5: "153.055", P10: "155.874", P15: "157.775", P25: "160.583", P50: "165.816", P75: "171.05", P85: "173.858", P90: "175.759", P95: "178.578", P97: "180.409", P99: "183.866", P999: "189.792" } },
          { name: 174, uid: "3443775443", values: { age: 174, P01: "142.3", P1: "148.234", P3: "151.695", P5: "153.528", P10: "156.35", P15: "158.254", P25: "161.065", P50: "166.305", P75: "171.545", P85: "174.356", P90: "176.26", P95: "179.082", P97: "180.915", P99: "184.376", P999: "190.31" } },
          { name: 175, uid: "1048606429", values: { age: 175, P01: "142.747", P1: "148.688", P3: "152.153", P5: "153.988", P10: "156.813", P15: "158.72", P25: "161.534", P50: "166.78", P75: "172.025", P85: "174.84", P90: "176.746", P95: "179.572", P97: "181.407", P99: "184.872", P999: "190.812" } },
          { name: 176, uid: "1846791124", values: { age: 176, P01: "143.184", P1: "149.131", P3: "152.599", P5: "154.436", P10: "157.265", P15: "159.173", P25: "161.991", P50: "167.242", P75: "172.492", P85: "175.31", P90: "177.218", P95: "180.047", P97: "181.884", P99: "185.352", P999: "191.299" } },
          { name: 177, uid: "1135524415", values: { age: 177, P01: "143.614", P1: "149.566", P3: "153.037", P5: "154.875", P10: "157.705", P15: "159.615", P25: "162.435", P50: "167.69", P75: "172.945", P85: "175.765", P90: "177.674", P95: "180.505", P97: "182.343", P99: "185.814", P999: "191.766" } },
          { name: 178, uid: "343553084", values: { age: 178, P01: "144.034", P1: "149.989", P3: "153.463", P5: "155.302", P10: "158.135", P15: "160.045", P25: "162.867", P50: "168.126", P75: "173.384", P85: "176.206", P90: "178.116", P95: "180.949", P97: "182.788", P99: "186.262", P999: "192.217" } },
          { name: 179, uid: "3983184467", values: { age: 179, P01: "144.443", P1: "150.402", P3: "153.877", P5: "155.718", P10: "158.552", P15: "160.464", P25: "163.287", P50: "168.548", P75: "173.809", P85: "176.633", P90: "178.545", P95: "181.379", P97: "183.219", P99: "186.695", P999: "192.653" } },
          { name: 180, uid: "3560003606", values: { age: 180, P01: "144.841", P1: "150.803", P3: "154.28", P5: "156.121", P10: "158.957", P15: "160.869", P25: "163.694", P50: "168.958", P75: "174.222", P85: "177.047", P90: "178.959", P95: "181.795", P97: "183.636", P99: "187.113", P999: "193.075" } },
          { name: 181, uid: "2234758627", values: { age: 181, P01: "145.234", P1: "151.196", P3: "154.674", P5: "156.516", P10: "159.352", P15: "161.265", P25: "164.09", P50: "169.355", P75: "174.62", P85: "177.445", P90: "179.358", P95: "182.194", P97: "184.036", P99: "187.513", P999: "193.476" } },
          { name: 182, uid: "4177063850", values: { age: 182, P01: "145.616", P1: "151.579", P3: "155.057", P5: "156.899", P10: "159.735", P15: "161.648", P25: "164.474", P50: "169.739", P75: "175.004", P85: "177.83", P90: "179.743", P95: "182.579", P97: "184.421", P99: "187.899", P999: "193.862" } },
          { name: 183, uid: "3844135236", values: { age: 183, P01: "145.986", P1: "151.95", P3: "155.428", P5: "157.27", P10: "160.106", P15: "162.019", P25: "164.845", P50: "170.11", P75: "175.375", P85: "178.201", P90: "180.114", P95: "182.95", P97: "184.792", P99: "188.27", P999: "194.233" } },
          { name: 184, uid: "3258713263", values: { age: 184, P01: "146.346", P1: "152.309", P3: "155.787", P5: "157.629", P10: "160.465", P15: "162.378", P25: "165.203", P50: "170.468", P75: "175.733", P85: "178.558", P90: "180.471", P95: "183.307", P97: "185.149", P99: "188.627", P999: "194.59" } },
          { name: 185, uid: "3139626585", values: { age: 185, P01: "146.696", P1: "152.658", P3: "156.135", P5: "157.976", P10: "160.812", P15: "162.725", P25: "165.55", P50: "170.814", P75: "176.078", P85: "178.902", P90: "180.815", P95: "183.651", P97: "185.492", P99: "188.97", P999: "194.931" } },
          { name: 186, uid: "2767316396", values: { age: 186, P01: "147.035", P1: "152.995", P3: "156.472", P5: "158.313", P10: "161.147", P15: "163.06", P25: "165.884", P50: "171.147", P75: "176.41", P85: "179.234", P90: "181.146", P95: "183.981", P97: "185.822", P99: "189.298", P999: "195.259" } },
          { name: 187, uid: "2933110036", values: { age: 187, P01: "147.369", P1: "153.326", P3: "156.801", P5: "158.641", P10: "161.474", P15: "163.386", P25: "166.208", P50: "171.468", P75: "176.728", P85: "179.55", P90: "181.462", P95: "184.295", P97: "186.135", P99: "189.61", P999: "195.567" } },
          { name: 188, uid: "1281656912", values: { age: 188, P01: "147.688", P1: "153.643", P3: "157.116", P5: "158.955", P10: "161.787", P15: "163.698", P25: "166.519", P50: "171.777", P75: "177.035", P85: "179.857", P90: "181.767", P95: "184.599", P97: "186.439", P99: "189.912", P999: "195.866" } },
          { name: 189, uid: "1867385945", values: { age: 189, P01: "148.002", P1: "153.953", P3: "157.424", P5: "159.262", P10: "162.092", P15: "164.001", P25: "166.821", P50: "172.075", P75: "177.329", P85: "180.148", P90: "182.058", P95: "184.888", P97: "186.726", P99: "190.197", P999: "196.147" } },
          { name: 190, uid: "505316266", values: { age: 190, P01: "148.307", P1: "154.253", P3: "157.721", P5: "159.557", P10: "162.385", P15: "164.293", P25: "167.111", P50: "172.361", P75: "177.611", P85: "180.428", P90: "182.336", P95: "185.164", P97: 187, P99: "190.468", P999: "196.414" } },
          { name: 191, uid: "1725374003", values: { age: 191, P01: "148.596", P1: "154.538", P3: "158.004", P5: "159.839", P10: "162.665", P15: "164.572", P25: "167.388", P50: "172.634", P75: "177.881", P85: "180.697", P90: "182.604", P95: "185.43", P97: "187.265", P99: "190.731", P999: "196.673" } },
          { name: 192, uid: "1234191081", values: { age: 192, P01: "148.88", P1: "154.817", P3: "158.28", P5: "160.113", P10: "162.937", P15: "164.842", P25: "167.655", P50: "172.897", P75: "178.139", P85: "180.952", P90: "182.857", P95: "185.68", P97: "187.514", P99: "190.976", P999: "196.913" } },
          { name: 193, uid: "2073103163", values: { age: 193, P01: "149.155", P1: "155.085", P3: "158.545", P5: "160.377", P10: "163.197", P15: "165.1", P25: "167.91", P50: "173.147", P75: "178.384", P85: "181.194", P90: "183.097", P95: "185.917", P97: "187.749", P99: "191.209", P999: "197.139" } },
          { name: 194, uid: "4135110570", values: { age: 194, P01: "149.419", P1: "155.344", P3: "158.799", P5: "160.629", P10: "163.446", P15: "165.348", P25: "168.155", P50: "173.386", P75: "178.617", P85: "181.424", P90: "183.325", P95: "186.142", P97: "187.972", P99: "191.428", P999: "197.352" } },
          { name: 195, uid: "3815559940", values: { age: 195, P01: "149.674", P1: "155.591", P3: "159.043", P5: "160.871", P10: "163.685", P15: "165.584", P25: "168.388", P50: "173.613", P75: "178.838", P85: "181.641", P90: "183.54", P95: "186.355", P97: "188.182", P99: "191.634", P999: "197.551" } },
          { name: 196, uid: "2257090442", values: { age: 196, P01: "149.919", P1: "155.829", P3: "159.276", P5: "161.102", P10: "163.913", P15: "165.809", P25: "168.609", P50: "173.828", P75: "179.047", P85: "181.847", P90: "183.743", P95: "186.554", P97: "188.38", P99: "191.827", P999: "197.737" } },
          { name: 197, uid: "3411115778", values: { age: 197, P01: "150.154", P1: "156.056", P3: "159.499", P5: "161.322", P10: "164.13", P15: "166.024", P25: "168.82", P50: "174.032", P75: "179.244", P85: "182.041", P90: "183.935", P95: "186.742", P97: "188.565", P99: "192.008", P999: "197.91" } },
          { name: 198, uid: "19388084", values: { age: 198, P01: "150.38", P1: "156.274", P3: "159.712", P5: "161.533", P10: "164.336", P15: "166.228", P25: "169.02", P50: "174.225", P75: "179.43", P85: "182.223", P90: "184.114", P95: "186.917", P97: "188.738", P99: "192.176", P999: "198.071" } },
          { name: 199, uid: "2852858453", values: { age: 199, P01: "150.596", P1: "156.482", P3: "159.915", P5: "161.733", P10: "164.532", P15: "166.421", P25: "169.21", P50: "174.407", P75: "179.604", P85: "182.393", P90: "184.282", P95: "187.081", P97: "188.899", P99: "192.332", P999: "198.218" } },
          { name: 200, uid: "1068750170", values: { age: 200, P01: "150.803", P1: "156.68", P3: "160.108", P5: "161.923", P10: "164.719", P15: "166.604", P25: "169.389", P50: "174.578", P75: "179.768", P85: "182.552", P90: "184.438", P95: "187.233", P97: "189.049", P99: "192.477", P999: "198.354" } },
          { name: 201, uid: "957430453", values: { age: 201, P01: "151.001", P1: "156.869", P3: "160.292", P5: "162.104", P10: "164.895", P15: "166.778", P25: "169.558", P50: "174.739", P75: "179.92", P85: "182.701", P90: "184.583", P95: "187.374", P97: "189.187", P99: "192.609", P999: "198.477" } },
          { name: 202, uid: "3600189363", values: { age: 202, P01: "151.191", P1: "157.049", P3: "160.466", P5: "162.275", P10: "165.061", P15: "166.941", P25: "169.717", P50: "174.89", P75: "180.062", P85: "182.838", P90: "184.718", P95: "187.504", P97: "189.313", P99: "192.73", P999: "198.588" } },
          { name: 203, uid: "2405910515", values: { age: 203, P01: "151.366", P1: "157.216", P3: "160.628", P5: "162.435", P10: "165.217", P15: "167.094", P25: "169.865", P50: "175.03", P75: "180.195", P85: "182.967", P90: "184.844", P95: "187.626", P97: "189.432", P99: "192.844", P999: "198.694" } },
          { name: 204, uid: "2700706876", values: { age: 204, P01: "151.539", P1: "157.378", P3: "160.784", P5: "162.588", P10: "165.365", P15: "167.238", P25: "170.005", P50: "175.161", P75: "180.317", P85: "183.083", P90: "184.957", P95: "187.734", P97: "189.538", P99: "192.944", P999: "198.783" } },
          { name: 205, uid: "2380778449", values: { age: 205, P01: "151.704", P1: "157.532", P3: "160.932", P5: "162.732", P10: "165.504", P15: "167.374", P25: "170.136", P50: "175.282", P75: "180.429", P85: "183.19", P90: "185.061", P95: "187.833", P97: "189.633", P99: "193.033", P999: "198.861" } },
          { name: 206, uid: "2527733938", values: { age: 206, P01: "151.856", P1: "157.674", P3: "161.068", P5: "162.866", P10: "165.633", P15: "167.5", P25: "170.257", P50: "175.395", P75: "180.533", P85: "183.29", P90: "185.157", P95: "187.925", P97: "189.722", P99: "193.116", P999: "198.935" } },
          { name: 207, uid: "2473704154", values: { age: 207, P01: "152.006", P1: "157.813", P3: "161.201", P5: "162.994", P10: "165.756", P15: "167.62", P25: "170.372", P50: "175.5", P75: "180.627", P85: "183.379", P90: "185.243", P95: "188.005", P97: "189.798", P99: "193.186", P999: "198.993" } },
          { name: 208, uid: "2496321499", values: { age: 208, P01: "152.143", P1: "157.941", P3: "161.322", P5: "163.113", P10: "165.87", P15: "167.73", P25: "170.477", P50: "175.596", P75: "180.715", P85: "183.462", P90: "185.322", P95: "188.079", P97: "189.87", P99: "193.251", P999: "199.048" } },
          { name: 209, uid: "3124782586", values: { age: 209, P01: "152.28", P1: "158.066", P3: "161.44", P5: "163.227", P10: "165.979", P15: "167.835", P25: "170.577", P50: "175.685", P75: "180.793", P85: "183.535", P90: "185.391", P95: "188.143", P97: "189.93", P99: "193.304", P999: "199.09" } },
          { name: 210, uid: "298051321", values: { age: 210, P01: "152.406", P1: "158.181", P3: "161.549", P5: "163.333", P10: "166.079", P15: "167.932", P25: "170.668", P50: "175.767", P75: "180.866", P85: "183.602", P90: "185.455", P95: "188.202", P97: "189.986", P99: "193.354", P999: "199.129" } },
          { name: 211, uid: "1299803586", values: { age: 211, P01: "152.526", P1: "158.29", P3: "161.652", P5: "163.432", P10: "166.173", P15: "168.023", P25: "170.754", P50: "175.843", P75: "180.933", P85: "183.664", P90: "185.513", P95: "188.254", P97: "190.035", P99: "193.396", P999: "199.16" } },
          { name: 212, uid: "1352546306", values: { age: 212, P01: "152.641", P1: "158.394", P3: "161.749", P5: "163.526", P10: "166.262", P15: "168.108", P25: "170.834", P50: "175.913", P75: "180.993", P85: "183.719", P90: "185.564", P95: "188.3", P97: "190.077", P99: "193.433", P999: "199.185" } },
          { name: 213, uid: "609848827", values: { age: 213, P01: "152.752", P1: "158.493", P3: "161.842", P5: "163.615", P10: "166.346", P15: "168.188", P25: "170.909", P50: "175.978", P75: "181.048", P85: "183.768", P90: "185.61", P95: "188.341", P97: "190.114", P99: "193.463", P999: "199.204" } },
          { name: 214, uid: "2467335667", values: { age: 214, P01: "152.858", P1: "158.588", P3: "161.93", P5: "163.7", P10: "166.425", P15: "168.264", P25: "170.979", P50: "176.038", P75: "181.097", P85: "183.812", P90: "185.651", P95: "188.376", P97: "190.146", P99: "193.488", P999: "199.218" } },
          { name: 215, uid: "2631080298", values: { age: 215, P01: "152.961", P1: "158.679", P3: "162.014", P5: "163.781", P10: "166.5", P15: "168.335", P25: "171.044", P50: "176.094", P75: "181.143", P85: "183.852", P90: "185.687", P95: "188.406", P97: "190.173", P99: "193.508", P999: "199.226" } },
          { name: 216, uid: "2108238642", values: { age: 216, P01: "153.06", P1: "158.766", P3: "162.095", P5: "163.857", P10: "166.571", P15: "168.402", P25: "171.106", P50: "176.145", P75: "181.184", P85: "183.887", P90: "185.718", P95: "188.432", P97: "190.195", P99: "193.523", P999: "199.23" } },
          { name: 217, uid: "1505008879", values: { age: 217, P01: "153.15", P1: "158.846", P3: "162.168", P5: "163.928", P10: "166.637", P15: "168.464", P25: "171.163", P50: "176.192", P75: "181.222", P85: "183.921", P90: "185.748", P95: "188.457", P97: "190.217", P99: "193.539", P999: "199.235" } },
          { name: 218, uid: "3383194047", values: { age: 218, P01: "153.243", P1: "158.927", P3: "162.242", P5: "163.998", P10: "166.701", P15: "168.525", P25: "171.218", P50: "176.237", P75: "181.255", P85: "183.949", P90: "185.772", P95: "188.476", P97: "190.231", P99: "193.546", P999: "199.23" } },
          { name: 219, uid: "1989401026", values: { age: 219, P01: "153.328", P1: "159.001", P3: "162.31", P5: "164.062", P10: "166.76", P15: "168.581", P25: "171.269", P50: "176.278", P75: "181.287", P85: "183.975", P90: "185.795", P95: "188.494", P97: "190.246", P99: "193.555", P999: "199.228" } },
          { name: 220, uid: "1323052124", values: { age: 220, P01: "153.41", P1: "159.073", P3: "162.375", P5: "164.124", P10: "166.817", P15: "168.634", P25: "171.317", P50: "176.316", P75: "181.316", P85: "183.999", P90: "185.815", P95: "188.508", P97: "190.257", P99: "193.56", P999: "199.222" } },
          { name: 221, uid: "740013408", values: { age: 221, P01: "153.49", P1: "159.142", P3: "162.438", P5: "164.183", P10: "166.871", P15: "168.684", P25: "171.362", P50: "176.352", P75: "181.342", P85: "184.019", P90: "185.833", P95: "188.52", P97: "190.266", P99: "193.562", P999: "199.213" } },
          { name: 222, uid: "993165819", values: { age: 222, P01: "153.574", P1: "159.213", P3: "162.502", P5: "164.243", P10: "166.925", P15: "168.734", P25: "171.406", P50: "176.385", P75: "181.364", P85: "184.036", P90: "185.845", P95: "188.527", P97: "190.269", P99: "193.558", P999: "199.196" } },
          { name: 223, uid: "1025189630", values: { age: 223, P01: "153.645", P1: "159.274", P3: "162.557", P5: "164.295", P10: "166.973", P15: "168.779", P25: "171.446", P50: "176.416", P75: "181.386", P85: "184.054", P90: "185.86", P95: "188.537", P97: "190.276", P99: "193.559", P999: "199.188" } },
          { name: 224, uid: "1537328397", values: { age: 224, P01: "153.719", P1: "159.337", P3: "162.613", P5: "164.349", P10: "167.02", P15: "168.823", P25: "171.485", P50: "176.445", P75: "181.406", P85: "184.067", P90: "185.87", P95: "188.542", P97: "190.277", P99: "193.554", P999: "199.172" } },
          { name: 225, uid: "2412384672", values: { age: 225, P01: "153.792", P1: "159.398", P3: "162.668", P5: "164.4", P10: "167.066", P15: "168.866", P25: "171.522", P50: "176.472", P75: "181.423", P85: "184.079", P90: "185.878", P95: "188.545", P97: "190.276", P99: "193.547", P999: "199.153" } },
          { name: 226, uid: "2338598534", values: { age: 226, P01: "153.863", P1: "159.458", P3: "162.721", P5: "164.45", P10: "167.111", P15: "168.906", P25: "171.557", P50: "176.498", P75: "181.438", P85: "184.089", P90: "185.885", P95: "188.546", P97: "190.274", P99: "193.537", P999: "199.132" } },
          { name: 227, uid: "3070697871", values: { age: 227, P01: "153.927", P1: "159.512", P3: "162.77", P5: "164.495", P10: "167.151", P15: "168.943", P25: "171.59", P50: "176.521", P75: "181.453", P85: "184.099", P90: "185.891", P95: "188.547", P97: "190.273", P99: "193.53", P999: "199.115" } },
          { name: 228, uid: "2595842587", values: { age: 228, P01: "153.99", P1: "159.565", P3: "162.817", P5: "164.539", P10: "167.19", P15: "168.979", P25: "171.621", P50: "176.543", P75: "181.466", P85: "184.107", P90: "185.896", P95: "188.548", P97: "190.27", P99: "193.522", P999: "199.097" } }
      ];


      const boys_to_13w = [
          { name: "a", uid: "1589549939", values: { age: 0, P01: 44, P1: "45.5", P3: "46.3", P5: "46.8", P10: "47.5", P15: "47.9", P25: "48.6", P50: "49.9", P75: "51.2", P85: "51.8", P90: "52.3", P95: 53, P97: "53.4", P99: "54.3", P999: "55.7" } },
          { name: 1, uid: "1309102428", values: { age: 1, P01: "45.2", P1: "46.7", P3: "47.5", P5: 48, P10: "48.7", P15: "49.1", P25: "49.8", P50: "51.1", P75: "52.4", P85: "53.1", P90: "53.6", P95: "54.2", P97: "54.7", P99: "55.5", P999: 57 } },
          { name: 2, uid: "3205415503", values: { age: 2, P01: "46.4", P1: "47.9", P3: "48.8", P5: "49.2", P10: "49.9", P15: "50.4", P25: "51.1", P50: "52.3", P75: "53.6", P85: "54.3", P90: "54.8", P95: "55.5", P97: "55.9", P99: "56.8", P999: "58.3" } },
          { name: 3, uid: "1029676985", values: { age: 3, P01: "47.4", P1: "48.9", P3: "49.8", P5: "50.2", P10: "50.9", P15: "51.4", P25: "52.1", P50: "53.4", P75: "54.7", P85: "55.4", P90: "55.9", P95: "56.6", P97: 57, P99: "57.9", P999: "59.3" } },
          { name: 4, uid: "1524543629", values: { age: 4, P01: "48.4", P1: "49.9", P3: "50.7", P5: "51.2", P10: "51.9", P15: "52.4", P25: "53.1", P50: "54.4", P75: "55.7", P85: "56.4", P90: "56.9", P95: "57.6", P97: 58, P99: "58.9", P999: "60.4" } },
          { name: 5, uid: "3324676590", values: { age: 5, P01: "49.3", P1: "50.8", P3: "51.7", P5: "52.1", P10: "52.8", P15: "53.3", P25: 54, P50: "55.3", P75: "56.7", P85: "57.4", P90: "57.8", P95: "58.6", P97: 59, P99: "59.9", P999: "61.4" } },
          { name: 6, uid: "2861606192", values: { age: 6, P01: "50.2", P1: "51.7", P3: "52.5", P5: 53, P10: "53.7", P15: "54.2", P25: "54.9", P50: "56.2", P75: "57.6", P85: "58.3", P90: "58.8", P95: "59.5", P97: "59.9", P99: "60.8", P999: "62.3" } },
          { name: 7, uid: "1891408407", values: { age: 7, P01: 51, P1: "52.5", P3: "53.4", P5: "53.8", P10: "54.5", P15: 55, P25: "55.7", P50: "57.1", P75: "58.4", P85: "59.1", P90: "59.6", P95: "60.3", P97: "60.8", P99: "61.7", P999: "63.2" } },
          { name: 8, uid: "3962747673", values: { age: 8, P01: "51.7", P1: "53.3", P3: "54.1", P5: "54.6", P10: "55.3", P15: "55.8", P25: "56.5", P50: "57.9", P75: "59.2", P85: 60, P90: "60.4", P95: "61.2", P97: "61.6", P99: "62.5", P999: 64 } },
          { name: 9, uid: "2156180893", values: { age: 9, P01: "52.5", P1: 54, P3: "54.9", P5: "55.4", P10: "56.1", P15: "56.6", P25: "57.3", P50: "58.7", P75: 60, P85: "60.7", P90: "61.2", P95: "61.9", P97: "62.4", P99: "63.3", P999: "64.8" } },
          { name: 10, uid: "2889875267", values: { age: 10, P01: "53.2", P1: "54.7", P3: "55.6", P5: "56.1", P10: "56.8", P15: "57.3", P25: 58, P50: "59.4", P75: "60.7", P85: "61.5", P90: 62, P95: "62.7", P97: "63.2", P99: "64.1", P999: "65.6" } },
          { name: 11, uid: "188111283", values: { age: 11, P01: "53.8", P1: "55.4", P3: "56.3", P5: "56.8", P10: "57.5", P15: 58, P25: "58.7", P50: "60.1", P75: "61.5", P85: "62.2", P90: "62.7", P95: "63.4", P97: "63.9", P99: "64.8", P999: "66.3" } },
          { name: 12, uid: "2298099179", values: { age: 12, P01: "54.5", P1: 56, P3: "56.9", P5: "57.4", P10: "58.2", P15: "58.7", P25: "59.4", P50: "60.8", P75: "62.1", P85: "62.9", P90: "63.4", P95: "64.1", P97: "64.6", P99: "65.5", P999: 67 } },
          { name: 13, uid: "399350150", values: { age: 13, P01: "55.1", P1: "56.6", P3: "57.6", P5: 58, P10: "58.8", P15: "59.3", P25: 60, P50: "61.4", P75: "62.8", P85: "63.5", P90: 64, P95: "64.8", P97: "65.2", P99: "66.2", P999: "67.7" } }
      ];

      const girls_to_5y = [
      {"name":"a","uid":"1589549939","values":{"age":0,"P01":44,"P1":"45.5","P3":"46.3","P5":"46.8","P10":"47.5","P15":"47.9","P25":"48.6","P50":"49.9","P75":"51.2","P85":"51.8","P90":"52.3","P95":53,"P97":"53.4","P99":"54.3","P999":"55.7"}},
      {"name":1,"uid":"4093758805","values":{"age":1,"P01":"48.7","P1":"50.2","P3":"51.1","P5":"51.5","P10":"52.2","P15":"52.7","P25":"53.4","P50":"54.7","P75":56,"P85":"56.7","P90":"57.2","P95":"57.9","P97":"58.4","P99":"59.3","P999":"60.7"}},
      {"name":2,"uid":"4049563981","values":{"age":2,"P01":"52.2","P1":"53.8","P3":"54.7","P5":"55.1","P10":"55.9","P15":"56.4","P25":"57.1","P50":"58.4","P75":"59.8","P85":"60.5","P90":61,"P95":"61.7","P97":"62.2","P99":"63.1","P999":"64.6"}},
      {"name":3,"uid":"3461950553","values":{"age":3,"P01":"55.1","P1":"56.7","P3":"57.6","P5":"58.1","P10":"58.8","P15":"59.3","P25":"60.1","P50":"61.4","P75":"62.8","P85":"63.5","P90":64,"P95":"64.8","P97":"65.3","P99":"66.2","P999":"67.7"}},
      {"name":4,"uid":"5364138","values":{"age":4,"P01":"57.5","P1":59,"P3":60,"P5":"60.5","P10":"61.2","P15":"61.7","P25":"62.5","P50":"63.9","P75":"65.3","P85":66,"P90":"66.6","P95":"67.3","P97":"67.8","P99":"68.7","P999":"70.3"}},
      {"name":5,"uid":"2984285765","values":{"age":5,"P01":"59.4","P1":61,"P3":"61.9","P5":"62.4","P10":"63.2","P15":"63.7","P25":"64.5","P50":"65.9","P75":"67.3","P85":"68.1","P90":"68.6","P95":"69.4","P97":"69.9","P99":"70.8","P999":"72.4"}},
      {"name":6,"uid":"935059469","values":{"age":6,"P01":61,"P1":"62.6","P3":"63.6","P5":"64.1","P10":"64.9","P15":"65.4","P25":"66.2","P50":"67.6","P75":"69.1","P85":"69.8","P90":"70.4","P95":"71.1","P97":"71.6","P99":"72.6","P999":"74.2"}},
      {"name":7,"uid":"2162721115","values":{"age":7,"P01":"62.5","P1":"64.1","P3":"65.1","P5":"65.6","P10":"66.4","P15":"66.9","P25":"67.7","P50":"69.2","P75":"70.6","P85":"71.4","P90":"71.9","P95":"72.7","P97":"73.2","P99":"74.2","P999":"75.9"}},
      {"name":8,"uid":"125627344","values":{"age":8,"P01":"63.8","P1":"65.5","P3":"66.5","P5":67,"P10":"67.8","P15":"68.3","P25":"69.1","P50":"70.6","P75":"72.1","P85":"72.9","P90":"73.4","P95":"74.2","P97":"74.7","P99":"75.7","P999":"77.4"}},
      {"name":9,"uid":"3418199007","values":{"age":9,"P01":65,"P1":"66.8","P3":"67.7","P5":"68.3","P10":"69.1","P15":"69.6","P25":"70.5","P50":72,"P75":"73.5","P85":"74.3","P90":"74.8","P95":"75.7","P97":"76.2","P99":"77.2","P999":"78.9"}},
      {"name":10,"uid":"2989642416","values":{"age":10,"P01":"66.2","P1":68,"P3":69,"P5":"69.5","P10":"70.4","P15":"70.9","P25":"71.7","P50":"73.3","P75":"74.8","P85":"75.6","P90":"76.2","P95":77,"P97":"77.6","P99":"78.6","P999":"80.3"}},
      {"name":11,"uid":"1933077736","values":{"age":11,"P01":"67.3","P1":"69.1","P3":"70.2","P5":"70.7","P10":"71.6","P15":"72.1","P25":73,"P50":"74.5","P75":"76.1","P85":77,"P90":"77.5","P95":"78.4","P97":"78.9","P99":80,"P999":"81.7"}},
      {"name":12,"uid":"3974467696","values":{"age":12,"P01":"68.4","P1":"70.2","P3":"71.3","P5":"71.8","P10":"72.7","P15":"73.3","P25":"74.1","P50":"75.7","P75":"77.4","P85":"78.2","P90":"78.8","P95":"79.7","P97":"80.2","P99":"81.3","P999":"83.1"}},
      {"name":13,"uid":"3537086184","values":{"age":13,"P01":"69.4","P1":"71.3","P3":"72.4","P5":"72.9","P10":"73.8","P15":"74.4","P25":"75.3","P50":"76.9","P75":"78.6","P85":"79.4","P90":80,"P95":"80.9","P97":"81.5","P99":"82.6","P999":"84.4"}},
      {"name":14,"uid":"576952500","values":{"age":14,"P01":"70.4","P1":"72.3","P3":"73.4","P5":74,"P10":"74.9","P15":"75.5","P25":"76.4","P50":78,"P75":"79.7","P85":"80.6","P90":"81.2","P95":"82.1","P97":"82.7","P99":"83.8","P999":"85.7"}},
      {"name":15,"uid":"3702332655","values":{"age":15,"P01":"71.3","P1":"73.3","P3":"74.4","P5":75,"P10":"75.9","P15":"76.5","P25":"77.4","P50":"79.1","P75":"80.9","P85":"81.8","P90":"82.4","P95":"83.3","P97":"83.9","P99":85,"P999":87}},
      {"name":16,"uid":"2629194847","values":{"age":16,"P01":"72.2","P1":"74.2","P3":"75.4","P5":76,"P10":"76.9","P15":"77.5","P25":"78.5","P50":"80.2","P75":82,"P85":"82.9","P90":"83.5","P95":"84.5","P97":"85.1","P99":"86.2","P999":"88.2"}},
      {"name":17,"uid":"4002604646","values":{"age":17,"P01":"73.1","P1":"75.1","P3":"76.3","P5":"76.9","P10":"77.9","P15":"78.5","P25":"79.5","P50":"81.2","P75":83,"P85":84,"P90":"84.6","P95":"85.6","P97":"86.2","P99":"87.4","P999":"89.4"}},
      {"name":18,"uid":"133910667","values":{"age":18,"P01":"73.9","P1":76,"P3":"77.2","P5":"77.8","P10":"78.8","P15":"79.5","P25":"80.4","P50":"82.3","P75":"84.1","P85":"85.1","P90":"85.7","P95":"86.7","P97":"87.3","P99":"88.5","P999":"90.6"}},
      {"name":19,"uid":"2724884999","values":{"age":19,"P01":"74.7","P1":"76.8","P3":"78.1","P5":"78.7","P10":"79.7","P15":"80.4","P25":"81.4","P50":"83.2","P75":"85.1","P85":"86.1","P90":"86.8","P95":"87.8","P97":"88.4","P99":"89.7","P999":"91.8"}},
      {"name":20,"uid":"97698012","values":{"age":20,"P01":"75.5","P1":"77.7","P3":"78.9","P5":"79.6","P10":"80.6","P15":"81.3","P25":"82.3","P50":"84.2","P75":"86.1","P85":"87.1","P90":"87.8","P95":"88.8","P97":"89.5","P99":"90.7","P999":"92.9"}},
      {"name":21,"uid":"2943559141","values":{"age":21,"P01":"76.3","P1":"78.4","P3":"79.7","P5":"80.4","P10":"81.5","P15":"82.2","P25":"83.2","P50":"85.1","P75":"87.1","P85":"88.1","P90":"88.8","P95":"89.9","P97":"90.5","P99":"91.8","P999":94}},
      {"name":22,"uid":"3376612254","values":{"age":22,"P01":77,"P1":"79.2","P3":"80.5","P5":"81.2","P10":"82.3","P15":83,"P25":"84.1","P50":86,"P75":88,"P85":"89.1","P90":"89.8","P95":"90.9","P97":"91.6","P99":"92.9","P999":"95.1"}},
      {"name":23,"uid":"3494845315","values":{"age":23,"P01":"77.7","P1":80,"P3":"81.3","P5":82,"P10":"83.1","P15":"83.8","P25":"84.9","P50":"86.9","P75":89,"P85":90,"P90":"90.8","P95":"91.9","P97":"92.6","P99":"93.9","P999":"96.2"}},
      {"name":24,"uid":"3273731722","values":{"age":24,"P01":"78.4","P1":"80.7","P3":"82.1","P5":"82.8","P10":"83.9","P15":"84.6","P25":"85.8","P50":"87.8","P75":"89.9","P85":91,"P90":"91.7","P95":"92.8","P97":"93.6","P99":"94.9","P999":"97.3"}},
      {"name":25,"uid":"169556906","values":{"age":25,"P01":"78.3","P1":"80.7","P3":"82.1","P5":"82.8","P10":84,"P15":"84.7","P25":"85.9","P50":88,"P75":"90.1","P85":"91.2","P90":92,"P95":"93.1","P97":"93.8","P99":"95.2","P999":"97.6"}},
      {"name":26,"uid":"1531721040","values":{"age":26,"P01":79,"P1":"81.4","P3":"82.8","P5":"83.6","P10":"84.7","P15":"85.5","P25":"86.7","P50":"88.8","P75":"90.9","P85":"92.1","P90":"92.9","P95":94,"P97":"94.8","P99":"96.2","P999":"98.6"}},
      {"name":27,"uid":"2591991239","values":{"age":27,"P01":"79.6","P1":"82.1","P3":"83.5","P5":"84.3","P10":"85.5","P15":"86.3","P25":"87.4","P50":"89.6","P75":"91.8","P85":93,"P90":"93.8","P95":"94.9","P97":"95.7","P99":"97.1","P999":"99.6"}},
      {"name":28,"uid":"2883704525","values":{"age":28,"P01":"80.2","P1":"82.8","P3":"84.2","P5":85,"P10":"86.2","P15":87,"P25":"88.2","P50":"90.4","P75":"92.6","P85":"93.8","P90":"94.6","P95":"95.8","P97":"96.6","P99":"98.1","P999":"100.6"}},
      {"name":29,"uid":"2189393354","values":{"age":29,"P01":"80.8","P1":"83.4","P3":"84.9","P5":"85.7","P10":"86.9","P15":"87.7","P25":"88.9","P50":"91.2","P75":"93.4","P85":"94.7","P90":"95.5","P95":"96.7","P97":"97.5","P99":99,"P999":"101.5"}},
      {"name":30,"uid":"1338886867","values":{"age":30,"P01":"81.4","P1":84,"P3":"85.5","P5":"86.3","P10":"87.6","P15":"88.4","P25":"89.6","P50":"91.9","P75":"94.2","P85":"95.5","P90":"96.3","P95":"97.5","P97":"98.3","P99":"99.9","P999":"102.5"}},
      {"name":31,"uid":"2874105084","values":{"age":31,"P01":82,"P1":"84.6","P3":"86.2","P5":87,"P10":"88.2","P15":"89.1","P25":"90.3","P50":"92.7","P75":95,"P85":"96.2","P90":"97.1","P95":"98.4","P97":"99.2","P99":"100.7","P999":"103.4"}},
      {"name":32,"uid":"3579270741","values":{"age":32,"P01":"82.5","P1":"85.2","P3":"86.8","P5":"87.6","P10":"88.9","P15":"89.7","P25":91,"P50":"93.4","P75":"95.7","P85":97,"P90":"97.9","P95":"99.2","P97":100,"P99":"101.5","P999":"104.2"}},
      {"name":33,"uid":"572763733","values":{"age":33,"P01":"83.1","P1":"85.8","P3":"87.4","P5":"88.2","P10":"89.5","P15":"90.4","P25":"91.7","P50":"94.1","P75":"96.5","P85":"97.8","P90":"98.6","P95":"99.9","P97":"100.8","P99":"102.4","P999":"105.1"}},
      {"name":34,"uid":"3809508546","values":{"age":34,"P01":"83.6","P1":"86.4","P3":88,"P5":"88.8","P10":"90.1","P15":91,"P25":"92.3","P50":"94.8","P75":"97.2","P85":"98.5","P90":"99.4","P95":"100.7","P97":"101.5","P99":"103.2","P999":"105.9"}},
      {"name":35,"uid":"2832660290","values":{"age":35,"P01":"84.1","P1":"86.9","P3":"88.5","P5":"89.4","P10":"90.7","P15":"91.6","P25":93,"P50":"95.4","P75":"97.9","P85":"99.2","P90":"100.1","P95":"101.4","P97":"102.3","P99":"103.9","P999":"106.7"}},
      {"name":36,"uid":"2593086519","values":{"age":36,"P01":"84.6","P1":"87.5","P3":"89.1","P5":90,"P10":"91.3","P15":"92.2","P25":"93.6","P50":"96.1","P75":"98.6","P85":"99.9","P90":"100.8","P95":"102.2","P97":"103.1","P99":"104.7","P999":"107.5"}},
      {"name":37,"uid":"2576968997","values":{"age":37,"P01":"85.1","P1":88,"P3":"89.7","P5":"90.6","P10":"91.9","P15":"92.8","P25":"94.2","P50":"96.7","P75":"99.3","P85":"100.6","P90":"101.5","P95":"102.9","P97":"103.8","P99":"105.5","P999":"108.3"}},
      {"name":38,"uid":"3163459531","values":{"age":38,"P01":"85.6","P1":"88.5","P3":"90.2","P5":"91.1","P10":"92.5","P15":"93.4","P25":"94.8","P50":"97.4","P75":"99.9","P85":"101.3","P90":"102.2","P95":"103.6","P97":"104.5","P99":"106.2","P999":"109.1"}},
      {"name":39,"uid":"4294052699","values":{"age":39,"P01":"86.1","P1":"89.1","P3":"90.8","P5":"91.7","P10":"93.1","P15":94,"P25":"95.4","P50":98,"P75":"100.6","P85":102,"P90":"102.9","P95":"104.3","P97":"105.2","P99":"106.9","P999":"109.9"}},
      {"name":40,"uid":"250775112","values":{"age":40,"P01":"86.6","P1":"89.6","P3":"91.3","P5":"92.2","P10":"93.7","P15":"94.6","P25":96,"P50":"98.6","P75":"101.3","P85":"102.7","P90":"103.6","P95":105,"P97":"105.9","P99":"107.7","P999":"110.6"}},
      {"name":41,"uid":"4094003707","values":{"age":41,"P01":"87.1","P1":"90.1","P3":"91.9","P5":"92.8","P10":"94.2","P15":"95.2","P25":"96.6","P50":"99.2","P75":"101.9","P85":"103.3","P90":"104.3","P95":"105.7","P97":"106.6","P99":"108.4","P999":"111.4"}},
      {"name":42,"uid":"833569153","values":{"age":42,"P01":"87.6","P1":"90.6","P3":"92.4","P5":"93.3","P10":"94.8","P15":"95.7","P25":"97.2","P50":"99.9","P75":"102.5","P85":104,"P90":"104.9","P95":"106.4","P97":"107.3","P99":"109.1","P999":"112.1"}},
      {"name":43,"uid":"2968591951","values":{"age":43,"P01":"88.1","P1":"91.1","P3":"92.9","P5":"93.9","P10":"95.3","P15":"96.3","P25":"97.7","P50":"100.4","P75":"103.1","P85":"104.6","P90":"105.6","P95":107,"P97":108,"P99":"109.8","P999":"112.8"}},
      {"name":44,"uid":"543345448","values":{"age":44,"P01":"88.5","P1":"91.6","P3":"93.4","P5":"94.4","P10":"95.9","P15":"96.8","P25":"98.3","P50":101,"P75":"103.8","P85":"105.2","P90":"106.2","P95":"107.7","P97":"108.6","P99":"110.4","P999":"113.5"}},
      {"name":45,"uid":"1532667843","values":{"age":45,"P01":89,"P1":"92.1","P3":"93.9","P5":"94.9","P10":"96.4","P15":"97.4","P25":"98.9","P50":"101.6","P75":"104.4","P85":"105.8","P90":"106.8","P95":"108.3","P97":"109.3","P99":"111.1","P999":"114.2"}},
      {"name":46,"uid":"3991254004","values":{"age":46,"P01":"89.5","P1":"92.6","P3":"94.4","P5":"95.4","P10":"96.9","P15":"97.9","P25":"99.4","P50":"102.2","P75":105,"P85":"106.5","P90":"107.5","P95":109,"P97":"109.9","P99":"111.8","P999":"114.9"}},
      {"name":47,"uid":"3897932360","values":{"age":47,"P01":"89.9","P1":"93.1","P3":"94.9","P5":"95.9","P10":"97.4","P15":"98.5","P25":100,"P50":"102.8","P75":"105.6","P85":"107.1","P90":"108.1","P95":"109.6","P97":"110.6","P99":"112.4","P999":"115.6"}},
      {"name":48,"uid":"1523726453","values":{"age":48,"P01":"90.4","P1":"93.6","P3":"95.4","P5":"96.4","P10":98,"P15":99,"P25":"100.5","P50":"103.3","P75":"106.2","P85":"107.7","P90":"108.7","P95":"110.2","P97":"111.2","P99":"113.1","P999":"116.3"}},
      {"name":49,"uid":"2666968585","values":{"age":49,"P01":"90.8","P1":94,"P3":"95.9","P5":"96.9","P10":"98.5","P15":"99.5","P25":101,"P50":"103.9","P75":"106.7","P85":"108.3","P90":"109.3","P95":"110.8","P97":"111.8","P99":"113.7","P999":117}},
      {"name":50,"uid":"1664314738","values":{"age":50,"P01":"91.3","P1":"94.5","P3":"96.4","P5":"97.4","P10":99,"P15":100,"P25":"101.6","P50":"104.4","P75":"107.3","P85":"108.9","P90":"109.9","P95":"111.5","P97":"112.5","P99":"114.4","P999":"117.6"}},
      {"name":51,"uid":"3071254588","values":{"age":51,"P01":"91.7","P1":95,"P3":"96.9","P5":"97.9","P10":"99.5","P15":"100.5","P25":"102.1","P50":105,"P75":"107.9","P85":"109.5","P90":"110.5","P95":"112.1","P97":"113.1","P99":115,"P999":"118.3"}},
      {"name":52,"uid":"1165396677","values":{"age":52,"P01":"92.1","P1":"95.5","P3":"97.4","P5":"98.4","P10":100,"P15":"101.1","P25":"102.6","P50":"105.6","P75":"108.5","P85":"110.1","P90":"111.1","P95":"112.7","P97":"113.7","P99":"115.7","P999":119}},
      {"name":53,"uid":"1938953078","values":{"age":53,"P01":"92.6","P1":"95.9","P3":"97.9","P5":"98.9","P10":"100.5","P15":"101.6","P25":"103.2","P50":"106.1","P75":"109.1","P85":"110.7","P90":"111.7","P95":"113.3","P97":"114.3","P99":"116.3","P999":"119.6"}},
      {"name":54,"uid":"3800210561","values":{"age":54,"P01":93,"P1":"96.4","P3":"98.4","P5":"99.4","P10":101,"P15":"102.1","P25":"103.7","P50":"106.7","P75":"109.6","P85":"111.2","P90":"112.3","P95":"113.9","P97":115,"P99":"116.9","P999":"120.3"}},
      {"name":55,"uid":"3638779759","values":{"age":55,"P01":"93.5","P1":"96.9","P3":"98.8","P5":"99.9","P10":"101.5","P15":"102.6","P25":"104.2","P50":"107.2","P75":"110.2","P85":"111.8","P90":"112.9","P95":"114.5","P97":"115.6","P99":"117.6","P999":121}},
      {"name":56,"uid":"2271954843","values":{"age":56,"P01":"93.9","P1":"97.3","P3":"99.3","P5":"100.4","P10":102,"P15":"103.1","P25":"104.7","P50":"107.8","P75":"110.8","P85":"112.4","P90":"113.5","P95":"115.2","P97":"116.2","P99":"118.2","P999":"121.6"}},
      {"name":57,"uid":"3319396319","values":{"age":57,"P01":"94.3","P1":"97.8","P3":"99.8","P5":"100.9","P10":"102.5","P15":"103.6","P25":"105.3","P50":"108.3","P75":"111.4","P85":113,"P90":"114.1","P95":"115.8","P97":"116.8","P99":"118.8","P999":"122.3"}},
      {"name":58,"uid":"1502254666","values":{"age":58,"P01":"94.8","P1":"98.3","P3":"100.3","P5":"101.4","P10":103,"P15":"104.1","P25":"105.8","P50":"108.9","P75":"111.9","P85":"113.6","P90":"114.7","P95":"116.4","P97":"117.4","P99":"119.5","P999":123}},
      {"name":59,"uid":"3781244486","values":{"age":59,"P01":"95.2","P1":"98.7","P3":"100.8","P5":"101.9","P10":"103.5","P15":"104.7","P25":"106.3","P50":"109.4","P75":"112.5","P85":"114.2","P90":"115.3","P95":117,"P97":"118.1","P99":"120.1","P999":"123.6"}},
      {"name":60,"uid":"3913722680","values":{"age":60,"P01":"95.6","P1":"99.2","P3":"101.2","P5":"102.3","P10":104,"P15":"105.2","P25":"106.8","P50":110,"P75":"113.1","P85":"114.8","P90":"115.9","P95":"117.6","P97":"118.7","P99":"120.7","P999":"124.3"}},
      {"name":61,"uid":"3968796314","values":{"age":61,"P01":"94.851","P1":"98.498","P3":"100.624","P5":"101.75","P10":"103.485","P15":"104.655","P25":"106.382","P50":"109.602","P75":"112.821","P85":"114.549","P90":"115.719","P95":"117.453","P97":"118.579","P99":"120.706","P999":"124.352"}},
      {"name":62,"uid":"1926228040","values":{"age":62,"P01":"95.274","P1":"98.946","P3":"101.087","P5":"102.221","P10":"103.967","P15":"105.145","P25":"106.884","P50":"110.126","P75":"113.367","P85":"115.107","P90":"116.285","P95":"118.031","P97":"119.165","P99":"121.306","P999":"124.977"}},
      {"name":63,"uid":"276734375","values":{"age":63,"P01":"95.693","P1":"99.389","P3":"101.545","P5":"102.686","P10":"104.444","P15":"105.63","P25":"107.382","P50":"110.645","P75":"113.909","P85":"115.66","P90":"116.846","P95":"118.604","P97":"119.745","P99":"121.901","P999":"125.597"}},
      {"name":64,"uid":"1935845972","values":{"age":64,"P01":"96.107","P1":"99.828","P3":"101.998","P5":"103.147","P10":"104.917","P15":"106.111","P25":"107.874","P50":"111.16","P75":"114.445","P85":"116.208","P90":"117.402","P95":"119.172","P97":"120.321","P99":"122.491","P999":"126.212"}},
      {"name":65,"uid":"2722387667","values":{"age":65,"P01":"96.52","P1":"100.265","P3":"102.449","P5":"103.606","P10":"105.387","P15":"106.589","P25":"108.363","P50":"111.67","P75":"114.976","P85":"116.751","P90":"117.952","P95":"119.733","P97":"120.89","P99":"123.074","P999":"126.819"}},
      {"name":66,"uid":"1801737758","values":{"age":66,"P01":"96.926","P1":"100.696","P3":"102.894","P5":"104.059","P10":"105.851","P15":"107.061","P25":"108.847","P50":"112.175","P75":"115.504","P85":"117.29","P90":"118.499","P95":"120.292","P97":"121.456","P99":"123.655","P999":"127.424"}},
      {"name":67,"uid":"3816341125","values":{"age":67,"P01":"97.332","P1":"101.125","P3":"103.337","P5":"104.509","P10":"106.313","P15":"107.53","P25":"109.327","P50":"112.677","P75":"116.026","P85":"117.823","P90":"119.04","P95":"120.844","P97":"122.016","P99":"124.229","P999":"128.022"}},
      {"name":68,"uid":"2299436138","values":{"age":68,"P01":"97.733","P1":"101.55","P3":"103.776","P5":"104.955","P10":"106.771","P15":"107.995","P25":"109.804","P50":"113.174","P75":"116.544","P85":"118.353","P90":"119.577","P95":"121.393","P97":"122.572","P99":"124.798","P999":"128.615"}},
      {"name":69,"uid":"4030610008","values":{"age":69,"P01":"98.131","P1":"101.971","P3":"104.212","P5":"105.398","P10":"107.224","P15":"108.457","P25":"110.276","P50":"113.667","P75":"117.058","P85":"118.878","P90":"120.11","P95":"121.937","P97":"123.123","P99":"125.363","P999":"129.203"}},
      {"name":70,"uid":"4271451318","values":{"age":70,"P01":"98.525","P1":"102.389","P3":"104.643","P5":"105.836","P10":"107.674","P15":"108.914","P25":"110.745","P50":"114.156","P75":"117.568","P85":"119.399","P90":"120.639","P95":"122.477","P97":"123.67","P99":"125.924","P999":"129.788"}},
      {"name":71,"uid":"975409861","values":{"age":71,"P01":"98.916","P1":"102.803","P3":"105.071","P5":"106.272","P10":"108.12","P15":"109.368","P25":"111.21","P50":"114.642","P75":"118.075","P85":"119.916","P90":"121.164","P95":"123.013","P97":"124.213","P99":"126.481","P999":"130.368"}},
      {"name":72,"uid":"2768087330","values":{"age":72,"P01":"99.304","P1":"103.214","P3":"105.496","P5":"106.703","P10":"108.563","P15":"109.818","P25":"111.671","P50":"115.124","P75":"118.578","P85":"120.431","P90":"121.685","P95":"123.545","P97":"124.753","P99":"127.034","P999":"130.945"}},
      {"name":73,"uid":"2649971862","values":{"age":73,"P01":"99.692","P1":"103.626","P3":"105.92","P5":"107.135","P10":"109.005","P15":"110.267","P25":"112.131","P50":"115.604","P75":"119.077","P85":"120.94","P90":"122.203","P95":"124.073","P97":"125.288","P99":"127.582","P999":"131.515"}},
      {"name":74,"uid":"2317805115","values":{"age":74,"P01":"100.079","P1":"104.034","P3":"106.342","P5":"107.564","P10":"109.445","P15":"110.714","P25":"112.588","P50":"116.081","P75":"119.574","P85":"121.448","P90":"122.718","P95":"124.599","P97":"125.821","P99":"128.128","P999":"132.084"}},
      {"name":75,"uid":"2987046175","values":{"age":75,"P01":"100.46","P1":"104.439","P3":"106.76","P5":"107.989","P10":"109.881","P15":"111.158","P25":"113.043","P50":"116.557","P75":"120.07","P85":"121.956","P90":"123.232","P95":"125.125","P97":"126.354","P99":"128.675","P999":"132.654"}},
      {"name":76,"uid":"3839387394","values":{"age":76,"P01":"100.847","P1":"104.848","P3":"107.181","P5":"108.417","P10":"110.319","P15":"111.603","P25":"113.499","P50":"117.031","P75":"120.563","P85":"122.459","P90":"123.743","P95":"125.645","P97":"126.881","P99":"129.215","P999":"133.215"}},
      {"name":77,"uid":"838665935","values":{"age":77,"P01":"101.23","P1":"105.253","P3":"107.599","P5":"108.842","P10":"110.755","P15":"112.046","P25":"113.952","P50":"117.504","P75":"121.057","P85":"122.963","P90":"124.254","P95":"126.167","P97":"127.41","P99":"129.756","P999":"133.779"}},
      {"name":78,"uid":"3604004576","values":{"age":78,"P01":"101.611","P1":"105.657","P3":"108.016","P5":"109.266","P10":"111.19","P15":"112.488","P25":"114.405","P50":"117.977","P75":"121.549","P85":"123.466","P90":"124.764","P95":"126.688","P97":"127.938","P99":"130.297","P999":"134.343"}},
      {"name":79,"uid":"4288201111","values":{"age":79,"P01":"101.996","P1":"106.063","P3":"108.435","P5":"109.691","P10":"111.626","P15":"112.931","P25":"114.858","P50":"118.449","P75":"122.04","P85":"123.967","P90":"125.272","P95":"127.207","P97":"128.463","P99":"130.835","P999":"134.902"}},
      {"name":80,"uid":"2590690822","values":{"age":80,"P01":"102.376","P1":"106.466","P3":"108.851","P5":"110.115","P10":"112.06","P15":"113.372","P25":"115.31","P50":"118.921","P75":"122.532","P85":"124.47","P90":"125.782","P95":"127.727","P97":"128.99","P99":"131.376","P999":"135.465"}},
      {"name":81,"uid":"661306056","values":{"age":81,"P01":"102.76","P1":"106.872","P3":"109.27","P5":"110.54","P10":"112.495","P15":"113.814","P25":"115.762","P50":"119.393","P75":"123.023","P85":"124.971","P90":"126.29","P95":"128.246","P97":"129.515","P99":"131.914","P999":"136.025"}},
      {"name":82,"uid":"1330435487","values":{"age":82,"P01":"103.144","P1":"107.278","P3":"109.688","P5":"110.965","P10":"112.931","P15":"114.257","P25":"116.215","P50":"119.865","P75":"123.514","P85":"125.473","P90":"126.799","P95":"128.765","P97":"130.041","P99":"132.452","P999":"136.585"}},
      {"name":83,"uid":"3856719168","values":{"age":83,"P01":"103.529","P1":"107.684","P3":"110.107","P5":"111.391","P10":"113.367","P15":"114.7","P25":"116.669","P50":"120.337","P75":"124.006","P85":"125.975","P90":"127.308","P95":"129.284","P97":"130.568","P99":"132.991","P999":"137.146"}},
      {"name":84,"uid":"29131266","values":{"age":84,"P01":"103.917","P1":"108.093","P3":"110.529","P5":"111.819","P10":"113.805","P15":"115.145","P25":"117.123","P50":"120.81","P75":"124.498","P85":"126.476","P90":"127.816","P95":"129.802","P97":"131.092","P99":"133.528","P999":"137.704"}},
      {"name":85,"uid":"3985664247","values":{"age":85,"P01":"104.302","P1":"108.5","P3":"110.949","P5":"112.245","P10":"114.242","P15":"115.589","P25":"117.578","P50":"121.284","P75":"124.991","P85":"126.98","P90":"128.327","P95":"130.323","P97":"131.62","P99":"134.068","P999":"138.266"}},
      {"name":86,"uid":"3048211084","values":{"age":86,"P01":"104.691","P1":"108.91","P3":"111.371","P5":"112.674","P10":"114.681","P15":"116.035","P25":"118.034","P50":"121.759","P75":"125.484","P85":"127.483","P90":"128.837","P95":"130.843","P97":"132.146","P99":"134.607","P999":"138.826"}},
      {"name":87,"uid":"110214633","values":{"age":87,"P01":"105.077","P1":"109.318","P3":"111.792","P5":"113.102","P10":"115.119","P15":"116.48","P25":"118.489","P50":"122.234","P75":"125.978","P85":"127.988","P90":"129.349","P95":"131.366","P97":"132.676","P99":"135.149","P999":"139.39"}},
      {"name":88,"uid":"574047370","values":{"age":88,"P01":"105.467","P1":"109.73","P3":"112.216","P5":"113.532","P10":"115.559","P15":"116.927","P25":"118.946","P50":"122.71","P75":"126.473","P85":"128.493","P90":"129.86","P95":"131.887","P97":"133.204","P99":"135.69","P999":"139.952"}},
      {"name":89,"uid":"1606933422","values":{"age":89,"P01":"105.862","P1":"110.145","P3":"112.643","P5":"113.965","P10":"116.002","P15":"117.376","P25":"119.405","P50":"123.187","P75":"126.968","P85":"128.997","P90":"130.371","P95":"132.408","P97":"133.731","P99":"136.229","P999":"140.511"}},
      {"name":90,"uid":"3441949055","values":{"age":90,"P01":"106.254","P1":"110.558","P3":"113.068","P5":"114.397","P10":"116.444","P15":"117.825","P25":"119.864","P50":"123.665","P75":"127.465","P85":"129.504","P90":"130.885","P95":"132.932","P97":"134.261","P99":"136.772","P999":"141.075"}},
      {"name":91,"uid":"3134682649","values":{"age":91,"P01":"106.646","P1":"110.971","P3":"113.494","P5":"114.83","P10":"116.887","P15":"118.275","P25":"120.324","P50":"124.144","P75":"127.963","P85":"130.012","P90":"131.4","P95":"133.457","P97":"134.793","P99":"137.316","P999":"141.641"}},
      {"name":92,"uid":"1977243054","values":{"age":92,"P01":"107.043","P1":"111.389","P3":"113.923","P5":"115.266","P10":"117.333","P15":"118.727","P25":"120.786","P50":"124.623","P75":"128.461","P85":"130.52","P90":"131.914","P95":"133.981","P97":"135.323","P99":"137.858","P999":"142.204"}},
      {"name":93,"uid":"2292899005","values":{"age":93,"P01":"107.441","P1":"111.807","P3":"114.354","P5":"115.702","P10":"117.779","P15":"119.18","P25":"121.249","P50":"125.104","P75":"128.96","P85":"131.029","P90":"132.43","P95":"134.507","P97":"135.855","P99":"138.402","P999":"142.768"}},
      {"name":94,"uid":"2783376787","values":{"age":94,"P01":"107.839","P1":"112.226","P3":"114.785","P5":"116.14","P10":"118.227","P15":"119.635","P25":"121.713","P50":"125.587","P75":"129.461","P85":"131.539","P90":"132.947","P95":"135.033","P97":"136.388","P99":"138.947","P999":"143.334"}},
      {"name":95,"uid":"375939122","values":{"age":95,"P01":"108.239","P1":"112.647","P3":"115.218","P5":"116.579","P10":"118.676","P15":"120.09","P25":"122.179","P50":"126.071","P75":"129.963","P85":"132.051","P90":"133.465","P95":"135.562","P97":"136.923","P99":"139.494","P999":"143.902"}},
      {"name":96,"uid":"2100455971","values":{"age":96,"P01":"108.64","P1":"113.069","P3":"115.652","P5":"117.02","P10":"119.126","P15":"120.547","P25":"122.645","P50":"126.556","P75":"130.466","P85":"132.565","P90":"133.986","P95":"136.092","P97":"137.46","P99":"140.043","P999":"144.471"}},
      {"name":97,"uid":"2020133764","values":{"age":97,"P01":"109.042","P1":"113.492","P3":"116.087","P5":"117.461","P10":"119.577","P15":"121.005","P25":"123.114","P50":"127.042","P75":"130.971","P85":"133.08","P90":"134.507","P95":"136.623","P97":"137.998","P99":"140.593","P999":"145.043"}},
      {"name":98,"uid":"701015530","values":{"age":98,"P01":"109.449","P1":"113.919","P3":"116.526","P5":"117.906","P10":"120.032","P15":"121.466","P25":"123.584","P50":"127.53","P75":"131.477","P85":"133.595","P90":"135.029","P95":"137.155","P97":"138.535","P99":"141.142","P999":"145.612"}},
      {"name":99,"uid":"2653791429","values":{"age":99,"P01":"109.857","P1":"114.347","P3":"116.966","P5":"118.352","P10":"120.488","P15":"121.928","P25":"124.056","P50":"128.02","P75":"131.984","P85":"134.111","P90":"135.552","P95":"137.687","P97":"139.074","P99":"141.693","P999":"146.182"}},
      {"name":100,"uid":"4253640637","values":{"age":100,"P01":"110.267","P1":"114.777","P3":"117.407","P5":"118.8","P10":"120.945","P15":"122.392","P25":"124.529","P50":"128.511","P75":"132.493","P85":"134.63","P90":"136.077","P95":"138.222","P97":"139.615","P99":"142.245","P999":"146.755"}},
      {"name":101,"uid":"4210049726","values":{"age":101,"P01":"110.678","P1":"115.208","P3":"117.85","P5":"119.249","P10":"121.404","P15":"122.857","P25":"125.004","P50":"129.004","P75":"133.003","P85":"135.15","P90":"136.603","P95":"138.758","P97":"140.157","P99":"142.799","P999":"147.329"}},
      {"name":102,"uid":"235972243","values":{"age":102,"P01":"111.089","P1":"115.64","P3":"118.294","P5":"119.699","P10":"121.863","P15":"123.324","P25":"125.48","P50":"129.498","P75":"133.515","P85":"135.671","P90":"137.132","P95":"139.296","P97":"140.701","P99":"143.355","P999":"147.906"}},
      {"name":103,"uid":"1157942180","values":{"age":103,"P01":"111.507","P1":"116.076","P3":"118.742","P5":"120.153","P10":"122.327","P15":"123.793","P25":"125.958","P50":"129.993","P75":"134.028","P85":"136.193","P90":"137.66","P95":"139.833","P97":"141.245","P99":"143.91","P999":"148.48"}},
      {"name":104,"uid":"3405265845","values":{"age":104,"P01":"111.925","P1":"116.514","P3":"119.191","P5":"120.608","P10":"122.791","P15":"124.264","P25":"126.438","P50":"130.49","P75":"134.543","P85":"136.717","P90":"138.19","P95":"140.372","P97":"141.79","P99":"144.467","P999":"149.056"}},
      {"name":105,"uid":"665405026","values":{"age":105,"P01":"112.341","P1":"116.95","P3":"119.639","P5":"121.063","P10":"123.255","P15":"124.735","P25":"126.919","P50":"130.989","P75":"135.059","P85":"137.244","P90":"138.723","P95":"140.915","P97":"142.339","P99":"145.028","P999":"149.638"}},
      {"name":106,"uid":"896393632","values":{"age":106,"P01":"112.766","P1":"117.394","P3":"120.094","P5":"121.523","P10":"123.725","P15":"125.21","P25":"127.403","P50":"131.49","P75":"135.576","P85":"137.769","P90":"139.254","P95":"141.456","P97":"142.885","P99":"145.585","P999":"150.213"}},
      {"name":107,"uid":"2008885367","values":{"age":107,"P01":"113.188","P1":"117.836","P3":"120.547","P5":"121.983","P10":"124.193","P15":"125.685","P25":"127.887","P50":"131.991","P75":"136.095","P85":"138.298","P90":"139.789","P95":142,"P97":"143.435","P99":"146.147","P999":"150.795"}},
      {"name":108,"uid":"3342909536","values":{"age":108,"P01":"113.611","P1":"118.279","P3":"121.002","P5":"122.443","P10":"124.663","P15":"126.161","P25":"128.373","P50":"132.494","P75":"136.616","P85":"138.828","P90":"140.326","P95":"142.546","P97":"143.987","P99":"146.71","P999":"151.378"}},
      {"name":109,"uid":"4284483256","values":{"age":109,"P01":"114.04","P1":"118.726","P3":"121.46","P5":"122.907","P10":"125.136","P15":"126.64","P25":"128.861","P50":"132.999","P75":"137.137","P85":"139.358","P90":"140.862","P95":"143.09","P97":"144.538","P99":"147.272","P999":"151.958"}},
      {"name":110,"uid":"961487787","values":{"age":110,"P01":"114.469","P1":"119.175","P3":"121.919","P5":"123.372","P10":"125.61","P15":"127.12","P25":"129.35","P50":"133.505","P75":"137.659","P85":"139.889","P90":"141.399","P95":"143.637","P97":"145.09","P99":"147.835","P999":"152.54"}},
      {"name":111,"uid":"2375108930","values":{"age":111,"P01":"114.9","P1":"119.624","P3":"122.38","P5":"123.839","P10":"126.086","P15":"127.602","P25":"129.84","P50":"134.012","P75":"138.183","P85":"140.422","P90":"141.938","P95":"144.185","P97":"145.644","P99":"148.399","P999":"153.124"}},
      {"name":112,"uid":"748591566","values":{"age":112,"P01":"115.332","P1":"120.075","P3":"122.842","P5":"124.307","P10":"126.562","P15":"128.085","P25":"130.332","P50":"134.52","P75":"138.708","P85":"140.956","P90":"142.478","P95":"144.734","P97":"146.199","P99":"148.966","P999":"153.709"}},
      {"name":113,"uid":"441365422","values":{"age":113,"P01":"115.769","P1":"120.53","P3":"123.307","P5":"124.778","P10":"127.042","P15":"128.57","P25":"130.826","P50":"135.03","P75":"139.234","P85":"141.49","P90":"143.018","P95":"145.282","P97":"146.753","P99":"149.53","P999":"154.291"}},
      {"name":114,"uid":"2224665166","values":{"age":114,"P01":"116.203","P1":"120.983","P3":"123.771","P5":"125.248","P10":"127.521","P15":"129.055","P25":"131.32","P50":"135.541","P75":"139.762","P85":"142.027","P90":"143.561","P95":"145.834","P97":"147.311","P99":"150.099","P999":"154.879"}},
      {"name":115,"uid":"3065071094","values":{"age":115,"P01":"116.642","P1":"121.44","P3":"124.239","P5":"125.721","P10":"128.003","P15":"129.543","P25":"131.816","P50":"136.053","P75":"140.29","P85":"142.564","P90":"144.103","P95":"146.386","P97":"147.868","P99":"150.666","P999":"155.465"}},
      {"name":116,"uid":"1949369109","values":{"age":116,"P01":"117.086","P1":"121.902","P3":"124.711","P5":"126.198","P10":"128.488","P15":"130.033","P25":"132.315","P50":"136.567","P75":"140.819","P85":"143.101","P90":"144.646","P95":"146.936","P97":"148.423","P99":"151.232","P999":"156.048"}},
      {"name":117,"uid":"4271350892","values":{"age":117,"P01":"117.528","P1":"122.362","P3":"125.181","P5":"126.674","P10":"128.973","P15":"130.524","P25":"132.814","P50":"137.082","P75":"141.35","P85":"143.64","P90":"145.191","P95":"147.49","P97":"148.983","P99":"151.803","P999":"156.636"}},
      {"name":118,"uid":"579455541","values":{"age":118,"P01":"117.971","P1":"122.823","P3":"125.653","P5":"127.151","P10":"129.459","P15":"131.016","P25":"133.315","P50":"137.599","P75":"141.883","P85":"144.182","P90":"145.739","P95":"148.046","P97":"149.545","P99":"152.375","P999":"157.226"}},
      {"name":119,"uid":"3714037045","values":{"age":119,"P01":"118.419","P1":"123.288","P3":"126.128","P5":"127.632","P10":"129.948","P15":"131.51","P25":"133.817","P50":"138.117","P75":"142.416","P85":"144.723","P90":"146.285","P95":"148.601","P97":"150.105","P99":"152.945","P999":"157.814"}},
      {"name":120,"uid":"3680569762","values":{"age":120,"P01":"118.869","P1":"123.755","P3":"126.605","P5":"128.115","P10":"130.439","P15":"132.007","P25":"134.322","P50":"138.636","P75":"142.951","P85":"145.266","P90":"146.834","P95":"149.158","P97":"150.667","P99":"153.517","P999":"158.404"}},
      {"name":121,"uid":"1259939703","values":{"age":121,"P01":"119.325","P1":"124.227","P3":"127.087","P5":"128.601","P10":"130.933","P15":"132.506","P25":"134.829","P50":"139.158","P75":"143.486","P85":"145.809","P90":"147.382","P95":"149.714","P97":"151.228","P99":"154.088","P999":"158.99"}},
      {"name":122,"uid":"4249505179","values":{"age":122,"P01":"119.777","P1":"124.697","P3":"127.567","P5":"129.086","P10":"131.426","P15":"133.005","P25":"135.336","P50":"139.68","P75":"144.024","P85":"146.356","P90":"147.934","P95":"150.274","P97":"151.794","P99":"154.664","P999":"159.583"}},
      {"name":123,"uid":"2825003937","values":{"age":123,"P01":"120.236","P1":"125.172","P3":"128.051","P5":"129.576","P10":"131.923","P15":"133.507","P25":"135.846","P50":"140.205","P75":"144.563","P85":"146.902","P90":"148.486","P95":"150.834","P97":"152.359","P99":"155.238","P999":"160.174"}},
      {"name":124,"uid":"1101631835","values":{"age":124,"P01":"120.696","P1":"125.648","P3":"128.537","P5":"130.067","P10":"132.422","P15":"134.012","P25":"136.358","P50":"140.731","P75":"145.104","P85":"147.451","P90":"149.04","P95":"151.396","P97":"152.925","P99":"155.814","P999":"160.767"}},
      {"name":125,"uid":"1651618125","values":{"age":125,"P01":"121.157","P1":"126.127","P3":"129.025","P5":"130.56","P10":"132.923","P15":"134.517","P25":"136.872","P50":"141.259","P75":"145.647","P85":"148.001","P90":"149.596","P95":"151.959","P97":"153.494","P99":"156.392","P999":"161.361"}},
      {"name":126,"uid":"1269441904","values":{"age":126,"P01":"121.621","P1":"126.606","P3":"129.514","P5":"131.054","P10":"133.425","P15":"135.025","P25":"137.387","P50":"141.789","P75":"146.191","P85":"148.554","P90":"150.153","P95":"152.524","P97":"154.064","P99":"156.972","P999":"161.958"}},
      {"name":127,"uid":"1382264475","values":{"age":127,"P01":"122.09","P1":"127.091","P3":"130.008","P5":"131.552","P10":"133.931","P15":"135.535","P25":"137.905","P50":"142.321","P75":"146.736","P85":"149.106","P90":"150.711","P95":"153.089","P97":"154.634","P99":"157.551","P999":"162.552"}},
      {"name":128,"uid":"2565375047","values":{"age":128,"P01":"122.56","P1":"127.576","P3":"130.502","P5":"132.052","P10":"134.437","P15":"136.047","P25":"138.424","P50":"142.853","P75":"147.283","P85":"149.66","P90":"151.269","P95":"153.655","P97":"155.205","P99":"158.13","P999":"163.147"}},
      {"name":129,"uid":"4113192923","values":{"age":129,"P01":"123.031","P1":"128.063","P3":"130.998","P5":"132.552","P10":"134.946","P15":"136.56","P25":"138.944","P50":"143.387","P75":"147.83","P85":"150.215","P90":"151.829","P95":"154.222","P97":"155.777","P99":"158.712","P999":"163.743"}},
      {"name":130,"uid":"732554308","values":{"age":130,"P01":"123.504","P1":"128.551","P3":"131.495","P5":"133.054","P10":"135.454","P15":"137.074","P25":"139.466","P50":"143.922","P75":"148.379","P85":"150.77","P90":"152.39","P95":"154.791","P97":"156.349","P99":"159.293","P999":"164.341"}},
      {"name":131,"uid":"2188387991","values":{"age":131,"P01":"123.976","P1":"129.039","P3":"131.992","P5":"133.556","P10":"135.964","P15":"137.588","P25":"139.987","P50":"144.458","P75":"148.928","P85":"151.327","P90":"152.951","P95":"155.359","P97":"156.923","P99":"159.876","P999":"164.939"}},
      {"name":132,"uid":"605831249","values":{"age":132,"P01":"124.454","P1":"129.531","P3":"132.492","P5":"134.06","P10":"136.475","P15":"138.104","P25":"140.51","P50":"144.993","P75":"149.476","P85":"151.882","P90":"153.511","P95":"155.925","P97":"157.494","P99":"160.455","P999":"165.532"}},
      {"name":133,"uid":"1162492173","values":{"age":133,"P01":"124.931","P1":"130.022","P3":"132.992","P5":"134.565","P10":"136.986","P15":"138.62","P25":"141.032","P50":"145.528","P75":"150.024","P85":"152.436","P90":"154.07","P95":"156.491","P97":"158.064","P99":"161.034","P999":"166.125"}},
      {"name":134,"uid":"4172267192","values":{"age":134,"P01":"125.408","P1":"130.513","P3":"133.491","P5":"135.068","P10":"137.497","P15":"139.135","P25":"141.554","P50":"146.062","P75":"150.57","P85":"152.99","P90":"154.628","P95":"157.056","P97":"158.633","P99":"161.611","P999":"166.717"}},
      {"name":135,"uid":"3402045358","values":{"age":135,"P01":"125.888","P1":"131.007","P3":"133.992","P5":"135.573","P10":"138.008","P15":"139.65","P25":"142.075","P50":"146.595","P75":"151.115","P85":"153.54","P90":"155.183","P95":"157.617","P97":"159.198","P99":"162.184","P999":"167.302"}},
      {"name":136,"uid":"2294822336","values":{"age":136,"P01":"126.362","P1":"131.495","P3":"134.489","P5":"136.074","P10":"138.515","P15":"140.162","P25":"142.594","P50":"147.126","P75":"151.658","P85":"154.09","P90":"155.737","P95":"158.178","P97":"159.764","P99":"162.758","P999":"167.89"}},
      {"name":137,"uid":"3593258071","values":{"age":137,"P01":"126.839","P1":"131.984","P3":"134.986","P5":"136.575","P10":"139.022","P15":"140.673","P25":"143.111","P50":"147.655","P75":"152.198","P85":"154.636","P90":"156.287","P95":"158.735","P97":"160.324","P99":"163.325","P999":"168.471"}},
      {"name":138,"uid":"1175695338","values":{"age":138,"P01":"127.313","P1":"132.472","P3":"135.48","P5":"137.073","P10":"139.527","P15":"141.182","P25":"143.626","P50":"148.18","P75":"152.735","P85":"155.179","P90":"156.834","P95":"159.287","P97":"160.881","P99":"163.889","P999":"169.047"}},
      {"name":139,"uid":"1747060025","values":{"age":139,"P01":"127.785","P1":"132.955","P3":"135.971","P5":"137.568","P10":"140.028","P15":"141.687","P25":"144.137","P50":"148.702","P75":"153.268","P85":"155.718","P90":"157.377","P95":"159.836","P97":"161.433","P99":"164.449","P999":"169.62"}},
      {"name":140,"uid":"845391807","values":{"age":140,"P01":"128.257","P1":"133.439","P3":"136.461","P5":"138.062","P10":"140.526","P15":"142.189","P25":"144.644","P50":"149.22","P75":"153.795","P85":"156.25","P90":"157.913","P95":"160.378","P97":"161.978","P99":"165.001","P999":"170.182"}},
      {"name":141,"uid":"4129363247","values":{"age":141,"P01":"128.721","P1":"133.915","P3":"136.944","P5":"138.548","P10":"141.018","P15":"142.685","P25":"145.146","P50":"149.732","P75":"154.318","P85":"156.779","P90":"158.446","P95":"160.916","P97":"162.52","P99":"165.55","P999":"170.744"}},
      {"name":142,"uid":"2887641460","values":{"age":142,"P01":"129.184","P1":"134.389","P3":"137.425","P5":"139.032","P10":"141.507","P15":"143.177","P25":"145.643","P50":"150.239","P75":"154.835","P85":"157.301","P90":"158.971","P95":"161.446","P97":"163.053","P99":"166.089","P999":"171.294"}},
      {"name":143,"uid":"187161073","values":{"age":143,"P01":"129.642","P1":"134.857","P3":"137.899","P5":"139.51","P10":"141.99","P15":"143.664","P25":"146.135","P50":"150.739","P75":"155.344","P85":"157.815","P90":"159.489","P95":"161.969","P97":"163.58","P99":"166.621","P999":"171.836"}},
      {"name":144,"uid":"2446965742","values":{"age":144,"P01":"130.095","P1":"135.32","P3":"138.368","P5":"139.981","P10":"142.467","P15":"144.143","P25":"146.619","P50":"151.233","P75":"155.846","P85":"158.322","P90":"159.999","P95":"162.484","P97":"164.098","P99":"167.146","P999":"172.371"}},
      {"name":145,"uid":"1591309892","values":{"age":145,"P01":"130.545","P1":"135.779","P3":"138.832","P5":"140.448","P10":"142.938","P15":"144.617","P25":"147.097","P50":"151.718","P75":"156.34","P85":"158.819","P90":"160.499","P95":"162.988","P97":"164.605","P99":"167.657","P999":"172.891"}},
      {"name":146,"uid":"43489725","values":{"age":146,"P01":"130.984","P1":"136.227","P3":"139.285","P5":"140.905","P10":"143.399","P15":"145.081","P25":"147.565","P50":"152.195","P75":"156.825","P85":"159.309","P90":"160.992","P95":"163.485","P97":"165.105","P99":"168.163","P999":"173.406"}},
      {"name":147,"uid":"1327634788","values":{"age":147,"P01":"131.419","P1":"136.671","P3":"139.733","P5":"141.355","P10":"143.853","P15":"145.538","P25":"148.026","P50":"152.663","P75":"157.3","P85":"159.788","P90":"161.473","P95":"163.97","P97":"165.592","P99":"168.655","P999":"173.906"}},
      {"name":148,"uid":"3198890813","values":{"age":148,"P01":"131.842","P1":"137.102","P3":"140.17","P5":"141.794","P10":"144.296","P15":"145.984","P25":"148.476","P50":"153.121","P75":"157.765","P85":"160.257","P90":"161.945","P95":"164.447","P97":"166.071","P99":"169.139","P999":"174.399"}},
      {"name":149,"uid":"3744078175","values":{"age":149,"P01":"132.26","P1":"137.527","P3":"140.599","P5":"142.226","P10":"144.731","P15":"146.421","P25":"148.917","P50":"153.568","P75":"158.219","P85":"160.714","P90":"162.404","P95":"164.909","P97":"166.536","P99":"169.608","P999":"174.876"}},
      {"name":150,"uid":"4148094079","values":{"age":150,"P01":"132.669","P1":"137.943","P3":"141.019","P5":"142.648","P10":"145.156","P15":"146.849","P25":"149.347","P50":"154.004","P75":"158.661","P85":"161.16","P90":"162.852","P95":"165.36","P97":"166.989","P99":"170.065","P999":"175.339"}},
      {"name":151,"uid":"1221654597","values":{"age":151,"P01":"133.069","P1":"138.349","P3":"141.428","P5":"143.059","P10":"145.571","P15":"147.265","P25":"149.767","P50":"154.429","P75":"159.091","P85":"161.593","P90":"163.287","P95":"165.799","P97":"167.43","P99":"170.509","P999":"175.789"}},
      {"name":152,"uid":"1940742844","values":{"age":152,"P01":"133.463","P1":"138.748","P3":"141.83","P5":"143.463","P10":"145.976","P15":"147.672","P25":"150.176","P50":"154.842","P75":"159.509","P85":"162.013","P90":"163.709","P95":"166.222","P97":"167.854","P99":"170.937","P999":"176.222"}},
      {"name":153,"uid":"2228871445","values":{"age":153,"P01":"133.843","P1":"139.133","P3":"142.218","P5":"143.852","P10":"146.368","P15":"148.066","P25":"150.573","P50":"155.244","P75":"159.915","P85":"162.421","P90":"164.119","P95":"166.635","P97":"168.269","P99":"171.355","P999":"176.645"}},
      {"name":154,"uid":"1931102725","values":{"age":154,"P01":"134.212","P1":"139.507","P3":"142.596","P5":"144.231","P10":"146.749","P15":"148.449","P25":"150.958","P50":"155.633","P75":"160.308","P85":"162.817","P90":"164.517","P95":"167.035","P97":"168.67","P99":"171.759","P999":"177.054"}},
      {"name":155,"uid":"3891889879","values":{"age":155,"P01":"134.576","P1":"139.874","P3":"142.965","P5":"144.601","P10":"147.121","P15":"148.821","P25":"151.332","P50":"156.01","P75":"160.689","P85":"163.199","P90":"164.899","P95":"167.419","P97":"169.056","P99":"172.146","P999":"177.445"}},
      {"name":156,"uid":"1077532422","values":{"age":156,"P01":"134.924","P1":"140.227","P3":"143.319","P5":"144.957","P10":"147.479","P15":"149.18","P25":"151.693","P50":"156.375","P75":"161.057","P85":"163.569","P90":"165.271","P95":"167.793","P97":"169.43","P99":"172.523","P999":"177.826"}},
      {"name":157,"uid":"2759846483","values":{"age":157,"P01":"135.267","P1":"140.571","P3":"143.666","P5":"145.304","P10":"147.827","P15":"149.529","P25":"152.043","P50":"156.727","P75":"161.411","P85":"163.924","P90":"165.627","P95":"168.15","P97":"169.788","P99":"172.882","P999":"178.187"}},
      {"name":158,"uid":"733135620","values":{"age":158,"P01":"135.599","P1":"140.905","P3":"144.001","P5":"145.64","P10":"148.164","P15":"149.866","P25":"152.381","P50":"157.067","P75":"161.752","P85":"164.267","P90":"165.97","P95":"168.493","P97":"170.133","P99":"173.228","P999":"178.535"}},
      {"name":159,"uid":"1844233434","values":{"age":159,"P01":"135.92","P1":"141.228","P3":"144.324","P5":"145.964","P10":"148.488","P15":"150.191","P25":"152.707","P50":"157.394","P75":"162.081","P85":"164.596","P90":"166.299","P95":"168.824","P97":"170.463","P99":"173.559","P999":"178.867"}},
      {"name":160,"uid":"4197343225","values":{"age":160,"P01":"136.226","P1":"141.536","P3":"144.633","P5":"146.274","P10":"148.799","P15":"150.503","P25":"153.019","P50":"157.708","P75":"162.397","P85":"164.913","P90":"166.617","P95":"169.143","P97":"170.783","P99":"173.88","P999":"179.191"}},
      {"name":161,"uid":"4014774874","values":{"age":161,"P01":"136.526","P1":"141.836","P3":"144.934","P5":"146.574","P10":"149.1","P15":"150.804","P25":"153.321","P50":"158.01","P75":"162.7","P85":"165.216","P90":"166.92","P95":"169.446","P97":"171.086","P99":"174.184","P999":"179.495"}},
      {"name":162,"uid":"4047542558","values":{"age":162,"P01":"136.815","P1":"142.126","P3":"145.223","P5":"146.864","P10":"149.39","P15":"151.094","P25":"153.61","P50":"158.3","P75":"162.989","P85":"165.506","P90":"167.21","P95":"169.736","P97":"171.376","P99":"174.474","P999":"179.785"}},
      {"name":163,"uid":"106257909","values":{"age":163,"P01":"137.094","P1":"142.404","P3":"145.502","P5":"147.142","P10":"149.668","P15":"151.372","P25":"153.888","P50":"158.577","P75":"163.266","P85":"165.782","P90":"167.486","P95":"170.012","P97":"171.652","P99":"174.75","P999":"180.06"}},
      {"name":164,"uid":"2523502217","values":{"age":164,"P01":"137.362","P1":"142.672","P3":"145.769","P5":"147.409","P10":"149.935","P15":"151.638","P25":"154.154","P50":"158.842","P75":"163.531","P85":"166.047","P90":"167.75","P95":"170.276","P97":"171.916","P99":"175.013","P999":"180.323"}},
      {"name":165,"uid":"1964351237","values":{"age":165,"P01":"137.616","P1":"142.926","P3":"146.023","P5":"147.663","P10":"150.188","P15":"151.892","P25":"154.408","P50":"159.096","P75":"163.784","P85":"166.3","P90":"168.004","P95":"170.529","P97":"172.169","P99":"175.266","P999":"180.576"}},
      {"name":166,"uid":"270629889","values":{"age":166,"P01":"137.865","P1":"143.173","P3":"146.269","P5":"147.909","P10":"150.433","P15":"152.136","P25":"154.651","P50":"159.338","P75":"164.025","P85":"166.54","P90":"168.243","P95":"170.768","P97":"172.407","P99":"175.503","P999":"180.811"}},
      {"name":167,"uid":"780913863","values":{"age":167,"P01":"138.104","P1":"143.41","P3":"146.505","P5":"148.144","P10":"150.667","P15":"152.37","P25":"154.884","P50":"159.569","P75":"164.254","P85":"166.768","P90":"168.471","P95":"170.994","P97":"172.633","P99":"175.728","P999":"181.034"}},
      {"name":168,"uid":"1382052324","values":{"age":168,"P01":"138.334","P1":"143.638","P3":"146.731","P5":"148.369","P10":"150.891","P15":"152.593","P25":"155.106","P50":"159.789","P75":"164.472","P85":"166.985","P90":"168.687","P95":"171.209","P97":"172.847","P99":"175.94","P999":"181.244"}},
      {"name":169,"uid":"4233914812","values":{"age":169,"P01":"138.555","P1":"143.855","P3":"146.947","P5":"148.584","P10":"151.105","P15":"152.806","P25":"155.318","P50":"159.998","P75":"164.679","P85":"167.19","P90":"168.891","P95":"171.412","P97":"173.049","P99":"176.141","P999":"181.442"}},
      {"name":170,"uid":"1955243579","values":{"age":170,"P01":"138.762","P1":"144.06","P3":"147.151","P5":"148.788","P10":"151.308","P15":"153.008","P25":"155.518","P50":"160.197","P75":"164.876","P85":"167.386","P90":"169.087","P95":"171.607","P97":"173.243","P99":"176.334","P999":"181.633"}},
      {"name":171,"uid":"3975149856","values":{"age":171,"P01":"138.965","P1":"144.26","P3":"147.348","P5":"148.984","P10":"151.502","P15":"153.201","P25":"155.71","P50":"160.386","P75":"165.061","P85":"167.57","P90":"169.269","P95":"171.788","P97":"173.423","P99":"176.512","P999":"181.807"}},
      {"name":172,"uid":"4211715664","values":{"age":172,"P01":"139.159","P1":"144.45","P3":"147.537","P5":"149.171","P10":"151.687","P15":"153.385","P25":"155.892","P50":"160.564","P75":"165.236","P85":"167.743","P90":"169.441","P95":"171.958","P97":"173.592","P99":"176.678","P999":"181.97"}},
      {"name":173,"uid":"2454048041","values":{"age":173,"P01":"139.34","P1":"144.628","P3":"147.713","P5":"149.346","P10":"151.861","P15":"153.558","P25":"156.064","P50":"160.733","P75":"165.403","P85":"167.908","P90":"169.605","P95":"172.12","P97":"173.754","P99":"176.838","P999":"182.126"}},
      {"name":174,"uid":"352251968","values":{"age":174,"P01":"139.518","P1":"144.802","P3":"147.884","P5":"149.516","P10":"152.028","P15":"153.724","P25":"156.227","P50":"160.893","P75":"165.558","P85":"168.061","P90":"169.757","P95":"172.27","P97":"173.902","P99":"176.984","P999":"182.267"}},
      {"name":175,"uid":"391855851","values":{"age":175,"P01":"139.683","P1":"144.963","P3":"148.043","P5":"149.674","P10":"152.185","P15":"153.879","P25":"156.381","P50":"161.043","P75":"165.705","P85":"168.207","P90":"169.901","P95":"172.412","P97":"174.043","P99":"177.123","P999":"182.403"}},
      {"name":176,"uid":"1082844531","values":{"age":176,"P01":"139.846","P1":"145.121","P3":"148.197","P5":"149.827","P10":"152.335","P15":"154.028","P25":"156.527","P50":"161.184","P75":"165.842","P85":"168.341","P90":"170.034","P95":"172.542","P97":"174.172","P99":"177.248","P999":"182.523"}},
      {"name":177,"uid":"358547978","values":{"age":177,"P01":"139.996","P1":"145.267","P3":"148.341","P5":"149.969","P10":"152.475","P15":"154.167","P25":"156.664","P50":"161.318","P75":"165.971","P85":"168.469","P90":"170.16","P95":"172.666","P97":"174.294","P99":"177.368","P999":"182.639"}},
      {"name":178,"uid":"1714672419","values":{"age":178,"P01":"140.14","P1":"145.406","P3":"148.477","P5":"150.104","P10":"152.608","P15":"154.298","P25":"156.793","P50":"161.442","P75":"166.092","P85":"168.587","P90":"170.277","P95":"172.781","P97":"174.408","P99":"177.479","P999":"182.745"}},
      {"name":179,"uid":"1830292910","values":{"age":179,"P01":"140.276","P1":"145.537","P3":"148.606","P5":"150.231","P10":"152.733","P15":"154.421","P25":"156.914","P50":"161.56","P75":"166.205","P85":"168.698","P90":"170.386","P95":"172.888","P97":"174.513","P99":"177.582","P999":"182.843"}},
      {"name":180,"uid":"3200121327","values":{"age":180,"P01":"140.411","P1":"145.666","P3":"148.731","P5":"150.354","P10":"152.853","P15":"154.54","P25":"157.029","P50":"161.669","P75":"166.309","P85":"168.799","P90":"170.485","P95":"172.984","P97":"174.607","P99":"177.672","P999":"182.927"}},
      {"name":181,"uid":"2807941529","values":{"age":181,"P01":"140.535","P1":"145.785","P3":"148.847","P5":"150.468","P10":"152.965","P15":"154.649","P25":"157.137","P50":"161.772","P75":"166.407","P85":"168.894","P90":"170.579","P95":"173.075","P97":"174.697","P99":"177.759","P999":"183.008"}},
      {"name":182,"uid":"2203905691","values":{"age":182,"P01":"140.653","P1":"145.897","P3":"148.956","P5":"150.576","P10":"153.07","P15":"154.752","P25":"157.237","P50":"161.867","P75":"166.498","P85":"168.982","P90":"170.665","P95":"173.159","P97":"174.779","P99":"177.837","P999":"183.081"}},
      {"name":183,"uid":"1873072924","values":{"age":183,"P01":"140.761","P1":146,"P3":"149.056","P5":"150.675","P10":"153.166","P15":"154.848","P25":"157.33","P50":"161.956","P75":"166.583","P85":"169.065","P90":"170.746","P95":"173.238","P97":"174.856","P99":"177.912","P999":"183.152"}},
      {"name":184,"uid":"256042732","values":{"age":184,"P01":"140.868","P1":"146.101","P3":"149.154","P5":"150.77","P10":"153.259","P15":"154.939","P25":"157.418","P50":"162.039","P75":"166.66","P85":"169.14","P90":"169.819","P95":"173.308","P97":"174.925","P99":"177.977","P999":"183.211"}},
      {"name":185,"uid":"2572440135","values":{"age":185,"P01":"140.97","P1":"146.197","P3":"149.246","P5":"150.861","P10":"153.347","P15":"155.024","P25":"157.501","P50":"162.116","P75":"166.732","P85":"169.209","P90":"170.886","P95":"173.372","P97":"174.987","P99":"178.035","P999":"183.263"}},
      {"name":186,"uid":"95867344","values":{"age":186,"P01":"141.067","P1":"146.288","P3":"149.334","P5":"150.946","P10":"153.429","P15":"155.104","P25":"157.578","P50":"162.188","P75":"166.798","P85":"169.272","P90":"170.947","P95":"173.43","P97":"175.042","P99":"178.088","P999":"183.309"}},
      {"name":187,"uid":"1653293342","values":{"age":187,"P01":"141.155","P1":"146.371","P3":"149.413","P5":"151.024","P10":"153.504","P15":"155.178","P25":"157.649","P50":"162.254","P75":"166.859","P85":"169.331","P90":"171.004","P95":"173.485","P97":"175.096","P99":"178.138","P999":"183.353"}},
      {"name":188,"uid":"2888966573","values":{"age":188,"P01":"141.244","P1":"146.452","P3":"149.491","P5":"151.099","P10":"153.577","P15":"155.248","P25":"157.716","P50":"162.315","P75":"166.915","P85":"169.383","P90":"171.054","P95":"173.531","P97":"175.14","P99":"178.178","P999":"183.387"}},
      {"name":189,"uid":"2356285949","values":{"age":189,"P01":"141.323","P1":"146.526","P3":"149.561","P5":"151.168","P10":"153.643","P15":"155.312","P25":"157.778","P50":"162.372","P75":"166.966","P85":"169.432","P90":"171.101","P95":"173.576","P97":"175.183","P99":"178.218","P999":"183.421"}},
      {"name":190,"uid":"3029970325","values":{"age":190,"P01":"141.398","P1":"146.596","P3":"149.627","P5":"151.232","P10":"153.704","P15":"155.372","P25":"157.835","P50":"162.424","P75":"167.013","P85":"169.476","P90":"171.143","P95":"173.615","P97":"175.221","P99":"178.252","P999":"183.45"}},
      {"name":191,"uid":"2363310069","values":{"age":191,"P01":"141.475","P1":"146.665","P3":"149.693","P5":"151.296","P10":"153.764","P15":"155.43","P25":"157.889","P50":"162.472","P75":"167.055","P85":"169.514","P90":"171.179","P95":"173.648","P97":"175.251","P99":"178.278","P999":"183.468"}},
      {"name":192,"uid":"2075253118","values":{"age":192,"P01":"141.543","P1":"146.727","P3":"149.751","P5":"151.353","P10":"153.818","P15":"155.482","P25":"157.938","P50":"162.516","P75":"167.093","P85":"169.55","P90":"171.213","P95":"173.679","P97":"175.28","P99":"178.304","P999":"183.488"}},
      {"name":193,"uid":"905466505","values":{"age":193,"P01":"141.609","P1":"146.787","P3":"149.807","P5":"151.406","P10":"153.869","P15":"155.53","P25":"157.984","P50":"162.556","P75":"167.128","P85":"169.582","P90":"171.243","P95":"173.706","P97":"175.305","P99":"178.325","P999":"183.503"}},
      {"name":194,"uid":"499760512","values":{"age":194,"P01":"141.671","P1":"146.843","P3":"149.86","P5":"151.457","P10":"153.917","P15":"155.576","P25":"158.027","P50":"162.593","P75":"167.16","P85":"169.61","P90":"171.27","P95":"173.73","P97":"175.327","P99":"178.344","P999":"183.515"}},
      {"name":195,"uid":"2112949532","values":{"age":195,"P01":"141.731","P1":"146.897","P3":"149.91","P5":"151.505","P10":"153.962","P15":"155.619","P25":"158.067","P50":"162.628","P75":"167.189","P85":"169.636","P90":"171.294","P95":"173.75","P97":"175.346","P99":"178.358","P999":"183.524"}},
      {"name":196,"uid":"1934508512","values":{"age":196,"P01":"141.789","P1":"146.948","P3":"149.957","P5":"151.551","P10":"154.004","P15":"155.66","P25":"158.104","P50":"162.659","P75":"167.215","P85":"169.659","P90":"171.315","P95":"173.768","P97":"175.362","P99":"178.371","P999":"183.53"}},
      {"name":197,"uid":"2863660879","values":{"age":197,"P01":"141.84","P1":"146.994","P3":150,"P5":"151.592","P10":"154.043","P15":"155.696","P25":"158.138","P50":"162.689","P75":"167.24","P85":"169.682","P90":"171.335","P95":"173.786","P97":"175.378","P99":"178.384","P999":"183.538"}},
      {"name":198,"uid":"3633744753","values":{"age":198,"P01":"141.894","P1":"147.041","P3":"150.044","P5":"151.633","P10":"154.081","P15":"155.733","P25":"158.172","P50":"162.716","P75":"167.261","P85":"169.7","P90":"171.352","P95":"173.8","P97":"175.389","P99":"178.392","P999":"183.539"}},
      {"name":199,"uid":"1427476772","values":{"age":199,"P01":"141.942","P1":"147.084","P3":"150.083","P5":"151.671","P10":"154.116","P15":"155.766","P25":"158.202","P50":"162.742","P75":"167.283","P85":"169.719","P90":"171.369","P95":"173.814","P97":"175.402","P99":"178.401","P999":"183.543"}},
      {"name":200,"uid":"3434279385","values":{"age":200,"P01":"141.994","P1":"147.129","P3":"150.124","P5":"151.71","P10":"154.152","P15":"155.8","P25":"158.233","P50":"162.767","P75":"167.301","P85":"169.734","P90":"171.382","P95":"173.824","P97":"175.41","P99":"178.405","P999":"183.54"}},
      {"name":201,"uid":"717939969","values":{"age":201,"P01":"142.039","P1":"147.169","P3":"150.161","P5":"151.745","P10":"154.185","P15":"155.831","P25":"158.261","P50":"162.79","P75":"167.32","P85":"169.75","P90":"171.396","P95":"173.836","P97":"175.42","P99":"178.412","P999":"183.542"}},
      {"name":202,"uid":"874345614","values":{"age":202,"P01":"142.089","P1":"147.212","P3":"150.2","P5":"151.782","P10":"154.218","P15":"155.862","P25":"158.289","P50":"162.813","P75":"167.336","P85":"169.763","P90":"171.407","P95":"173.843","P97":"175.426","P99":"178.414","P999":"183.536"}},
      {"name":203,"uid":"1734021569","values":{"age":203,"P01":"142.133","P1":"147.25","P3":"150.235","P5":"151.815","P10":"154.249","P15":"155.891","P25":"158.316","P50":"162.834","P75":"167.352","P85":"169.777","P90":"171.419","P95":"173.853","P97":"175.433","P99":"178.418","P999":"183.535"}},
      {"name":204,"uid":"1299629719","values":{"age":204,"P01":"142.176","P1":"147.287","P3":"150.269","P5":"151.848","P10":"154.279","P15":"155.919","P25":"158.341","P50":"162.854","P75":"167.368","P85":"169.79","P90":"171.43","P95":"173.861","P97":"175.44","P99":"178.422","P999":"183.533"}},
      {"name":205,"uid":"3332136068","values":{"age":205,"P01":"142.218","P1":"147.324","P3":"150.302","P5":"151.88","P10":"154.308","P15":"155.946","P25":"158.366","P50":"162.874","P75":"167.383","P85":"169.802","P90":"171.441","P95":"173.869","P97":"175.446","P99":"178.424","P999":"183.531"}},
      {"name":206,"uid":"1473239117","values":{"age":206,"P01":"142.26","P1":"147.36","P3":"150.335","P5":"151.911","P10":"154.337","P15":"155.973","P25":"158.39","P50":"162.894","P75":"167.397","P85":"169.814","P90":"171.45","P95":"173.876","P97":"175.452","P99":"178.427","P999":"183.527"}},
      {"name":207,"uid":"1706489484","values":{"age":207,"P01":"142.301","P1":"147.396","P3":"150.368","P5":"151.941","P10":"154.365","P15":"155.999","P25":"158.413","P50":"162.912","P75":"167.411","P85":"169.825","P90":"171.459","P95":"173.883","P97":"175.456","P99":"178.428","P999":"183.523"}},
      {"name":208,"uid":"1102095774","values":{"age":208,"P01":"142.342","P1":"147.431","P3":"150.4","P5":"151.972","P10":"154.392","P15":"156.025","P25":"158.436","P50":"162.93","P75":"167.424","P85":"169.835","P90":"171.468","P95":"173.888","P97":"175.46","P99":"178.429","P999":"183.518"}},
      {"name":209,"uid":"3995344323","values":{"age":209,"P01":"142.383","P1":"147.466","P3":"150.431","P5":"152.001","P10":"154.419","P15":"156.05","P25":"158.459","P50":"162.948","P75":"167.436","P85":"169.845","P90":"171.476","P95":"173.894","P97":"175.464","P99":"178.429","P999":"183.512"}},
      {"name":210,"uid":"2458929740","values":{"age":210,"P01":"142.418","P1":"147.497","P3":"150.46","P5":"152.028","P10":"154.444","P15":"156.074","P25":"158.48","P50":"162.965","P75":"167.45","P85":"169.856","P90":"171.486","P95":"173.901","P97":"175.47","P99":"178.433","P999":"183.512"}},
      {"name":211,"uid":"3242933941","values":{"age":211,"P01":"142.458","P1":"147.531","P3":"150.49","P5":"152.057","P10":"154.47","P15":"156.098","P25":"158.502","P50":"162.982","P75":"167.461","P85":"169.865","P90":"171.493","P95":"173.906","P97":"175.473","P99":"178.432","P999":"183.505"}},
      {"name":212,"uid":"738616686","values":{"age":212,"P01":"142.493","P1":"147.561","P3":"150.518","P5":"152.084","P10":"154.494","P15":"156.121","P25":"158.523","P50":"162.998","P75":"167.474","P85":"169.876","P90":"171.502","P95":"173.913","P97":"175.479","P99":"178.435","P999":"183.504"}},
      {"name":213,"uid":"2363032163","values":{"age":213,"P01":"142.532","P1":"147.595","P3":"150.548","P5":"152.112","P10":"154.52","P15":"156.145","P25":"158.544","P50":"163.014","P75":"167.485","P85":"169.884","P90":"171.509","P95":"173.917","P97":"175.481","P99":"178.434","P999":"183.497"}},
      {"name":214,"uid":"2678594119","values":{"age":214,"P01":"142.566","P1":"147.624","P3":"150.575","P5":"152.137","P10":"154.543","P15":"156.166","P25":"158.563","P50":"163.03","P75":"167.497","P85":"169.894","P90":"171.517","P95":"173.923","P97":"175.485","P99":"178.436","P999":"183.494"}},
      {"name":215,"uid":"1263598448","values":{"age":215,"P01":"142.599","P1":"147.653","P3":"150.601","P5":"152.162","P10":"154.566","P15":"156.188","P25":"158.582","P50":"163.045","P75":"167.508","P85":"169.903","P90":"171.524","P95":"173.928","P97":"175.489","P99":"178.437","P999":"183.491"}},
      {"name":216,"uid":"1791049428","values":{"age":216,"P01":"142.637","P1":"147.685","P3":"150.63","P5":"152.189","P10":"154.59","P15":"156.21","P25":"158.602","P50":"163.06","P75":"167.517","P85":"169.909","P90":"171.529","P95":"173.93","P97":"175.489","P99":"178.434","P999":"183.482"}},
      {"name":217,"uid":"650079837","values":{"age":217,"P01":"142.669","P1":"147.713","P3":"150.655","P5":"152.213","P10":"154.611","P15":"156.23","P25":"158.62","P50":"163.073","P75":"167.527","P85":"169.917","P90":"171.535","P95":"173.934","P97":"175.492","P99":"178.434","P999":"183.478"}},
      {"name":218,"uid":"1346409268","values":{"age":218,"P01":"142.7","P1":"147.74","P3":"150.679","P5":"152.235","P10":"154.632","P15":"156.249","P25":"158.637","P50":"163.086","P75":"167.536","P85":"169.923","P90":"171.54","P95":"173.937","P97":"175.493","P99":"178.433","P999":"183.472"}},
      {"name":219,"uid":"320096602","values":{"age":219,"P01":"142.731","P1":"147.766","P3":"150.702","P5":"152.257","P10":"154.652","P15":"156.267","P25":"158.653","P50":"163.098","P75":"167.544","P85":"169.929","P90":"171.545","P95":"173.939","P97":"175.494","P99":"178.431","P999":"183.465"}},
      {"name":220,"uid":"2947940617","values":{"age":220,"P01":"142.761","P1":"147.791","P3":"150.725","P5":"152.278","P10":"154.671","P15":"156.285","P25":"158.668","P50":"163.109","P75":"167.551","P85":"169.934","P90":"171.548","P95":"173.94","P97":"175.494","P99":"178.428","P999":"183.458"}},
      {"name":221,"uid":"4027603167","values":{"age":221,"P01":"142.785","P1":"147.811","P3":"150.743","P5":"152.296","P10":"154.686","P15":"156.299","P25":"158.681","P50":"163.119","P75":"167.557","P85":"169.939","P90":"171.552","P95":"173.943","P97":"175.495","P99":"178.427","P999":"183.454"}},
      {"name":222,"uid":"1892824652","values":{"age":222,"P01":"142.813","P1":"147.834","P3":"150.763","P5":"152.315","P10":"154.703","P15":"156.314","P25":"158.694","P50":"163.128","P75":"167.562","P85":"169.941","P90":"171.553","P95":"173.941","P97":"175.492","P99":"178.421","P999":"183.443"}},
      {"name":223,"uid":"3571097475","values":{"age":223,"P01":"142.839","P1":"147.856","P3":"150.783","P5":"152.332","P10":"154.718","P15":"156.328","P25":"158.706","P50":"163.136","P75":"167.565","P85":"169.943","P90":"171.553","P95":"173.939","P97":"175.488","P99":"178.415","P999":"183.432"}},
      {"name":224,"uid":"2469886881","values":{"age":224,"P01":"142.86","P1":"147.874","P3":"150.798","P5":"152.346","P10":"154.731","P15":"156.339","P25":"158.715","P50":"163.142","P75":"167.569","P85":"169.944","P90":"171.553","P95":"173.937","P97":"175.486","P99":"178.41","P999":"183.424"}},
      {"name":225,"uid":"4133763121","values":{"age":225,"P01":"142.885","P1":"147.893","P3":"150.815","P5":"152.362","P10":"154.744","P15":"156.351","P25":"158.724","P50":"163.147","P75":"167.569","P85":"169.943","P90":"171.55","P95":"173.932","P97":"175.479","P99":"178.4","P999":"183.409"}},
      {"name":226,"uid":"1051777605","values":{"age":226,"P01":"142.903","P1":"147.908","P3":"150.828","P5":"152.373","P10":"154.754","P15":"156.36","P25":"158.731","P50":"163.151","P75":"167.57","P85":"169.942","P90":"171.548","P95":"173.928","P97":"175.474","P99":"178.393","P999":"183.398"}},
      {"name":227,"uid":"2180644588","values":{"age":227,"P01":"142.926","P1":"147.926","P3":"150.842","P5":"152.387","P10":"154.765","P15":"156.369","P25":"158.738","P50":"163.153","P75":"167.568","P85":"169.938","P90":"171.542","P95":"173.92","P97":"175.465","P99":"178.381","P999":"183.381"}},
      {"name":228,"uid":"38776938","values":{"age":228,"P01":"142.942","P1":"147.938","P3":"150.853","P5":"152.396","P10":"154.772","P15":"156.376","P25":"158.743","P50":"163.155","P75":"167.567","P85":"169.934","P90":"171.537","P95":"173.914","P97":"175.457","P99":"178.371","P999":"183.368"}}
  ];

      let convertHight;
      const unitH1 = unit_ft_in;

      if (unitH1 == "ft/in") {
          if (isNumeric(height_ft) || isNumeric(height_in)) {
              convertHight = ((parseFloat(height_ft) * 12) + parseFloat(height_in));
          } else {
              return { error: 'Please! Check your input.' };
          }
      } else if (unitH1 == "cm") {
          if (isNumeric(height_cm)) {
              convertHight = (parseFloat(height_cm) / 2.54);
          } else {
              return { error: 'Please! Check your input.' };
          }
      } else if (unitH1 == "ft") {
          if (isNumeric(height_cm)) {
              convertHight = (parseFloat(height_cm) * 12);
          } else {
              return { error: 'Please! Check your input.' };
          }
      } else if (unitH1 == "in") {
          if (isNumeric(height_cm)) {
              convertHight = (parseFloat(height_cm) * 1);
          } else {
              return { error: 'Please! Check your input.' };
          }
      } else if (unitH1 === "m") {
          if (isNumeric(height_cm)) {
              convertHight = (parseFloat(height_cm) * 39.37);
          } else {
              return { error: 'Please! Check your input.' };
          }
      }

      const calculatedAge = umar(ageUnit.toString(), parseFloat(age));

      if (isNumeric(calculatedAge)) {
          if (calculatedAge > 0 && calculatedAge <= 19) {
            const ageInMonths = calculatedAge * 12;
            let takeRow;
            if (gender == 0) { // Girls
              if (ageInMonths <= 13 * 0.23) {
                      for (let i = 0; i < girls_to_13w.length; i++) {
                          if ((ageInMonths <= 0.23 * girls_to_13w[i].values.age) && (i === 0 || ageInMonths > 0.23 * girls_to_13w[i - 1].values.age)) {
                              takeRow = girls_to_13w[i].values;
                              break;
                          }
                      }
                  } else {
                      for (let i = 0; i < girls_to_5y.length; i++) {
                          if ((ageInMonths <= girls_to_5y[i].values.age) && (i === 0 || ageInMonths > girls_to_5y[i - 1].values.age)) {
                              takeRow = girls_to_5y[i].values;
                              break;
                          }
                      }
                  }
              } else if (gender == 1) { // Boys
                  if (ageInMonths <= 13 * 0.23) {
                      for (let i = 0; i < boys_to_13w.length; i++) {
                          if ((ageInMonths <= 0.23 * boys_to_13w[i].values.age) && (i === 0 || ageInMonths > 0.23 * boys_to_13w[i - 1].values.age)) {
                              takeRow = boys_to_13w[i].values;
                              break;
                          }
                      }
                  } else {
                      for (let i = 0; i < boys_to_5y.length; i++) {
                          if ((ageInMonths <= boys_to_5y[i].values.age) && (i === 0 || ageInMonths > boys_to_5y[i - 1].values.age)) {
                              takeRow = boys_to_5y[i].values;
                              break;
                          }
                      }
                  }

              }

              const actualCm = convertHight * 2.54;
              const weight = convertHight * 2.54;
              let result;
              let firstAns;
              let percentile;
              let line;
              let image;
              if (weight <= parseFloat(takeRow.P01)) {
                  result = 0.1;
              } else if (weight <= parseFloat(takeRow.P1)) {
                  result = ((weight - parseFloat(takeRow.P01)) / (parseFloat(takeRow.P1) - parseFloat(takeRow.P01)) * (1 - 0.1) + 0.1);
              } else if (weight <= parseFloat(takeRow.P3)) {
                  result = ((weight - parseFloat(takeRow.P1)) / (parseFloat(takeRow.P3) - parseFloat(takeRow.P1)) * (3 - 1) + 1);
              } else if (weight <= parseFloat(takeRow.P5)) {
                  result = ((weight - parseFloat(takeRow.P3)) / (parseFloat(takeRow.P5) - parseFloat(takeRow.P3)) * 2 + 3);
              } else if (weight <= parseFloat(takeRow.P10)) {
                  result = ((weight - parseFloat(takeRow.P5)) / (parseFloat(takeRow.P10) - parseFloat(takeRow.P5)) * 5 + 5);
              } else if (weight <= parseFloat(takeRow.P15)) {
                  result = ((weight - parseFloat(takeRow.P10)) / (parseFloat(takeRow.P15) - parseFloat(takeRow.P10)) * 5 + 10);
              } else if (weight <= parseFloat(takeRow.P25)) {
                  result = ((weight - parseFloat(takeRow.P15)) / (parseFloat(takeRow.P25) - parseFloat(takeRow.P15)) * 10 + 10);
              } else if (weight <= parseFloat(takeRow.P50)) {
                  result = ((weight - parseFloat(takeRow.P25)) / (parseFloat(takeRow.P50) - parseFloat(takeRow.P25)) * 25 + 25);
              } else if (weight <= parseFloat(takeRow.P75)) {
                  result = ((weight - parseFloat(takeRow.P50)) / (parseFloat(takeRow.P75) - parseFloat(takeRow.P50)) * 25 + 50);
              } else if (weight <= parseFloat(takeRow.P85)) {
                  result = ((weight - parseFloat(takeRow.P75)) / (parseFloat(takeRow.P85) - parseFloat(takeRow.P75)) * 10 + 75);
              } else if (weight <= parseFloat(takeRow.P90)) {
                  result = ((weight - parseFloat(takeRow.P85)) / (parseFloat(takeRow.P90) - parseFloat(takeRow.P85)) * 5 + 85);
              } else if (weight <= parseFloat(takeRow.P95)) {
                  result = ((weight - parseFloat(takeRow.P90)) / (parseFloat(takeRow.P95) - parseFloat(takeRow.P90)) * 5 + 90);
              } else if (weight <= parseFloat(takeRow.P97)) {
                  result = ((weight - parseFloat(takeRow.P95)) / (parseFloat(takeRow.P97) - parseFloat(takeRow.P95)) * 2 + 95);
              } else if (weight <= parseFloat(takeRow.P99)) {
                  result = ((weight - parseFloat(takeRow.P97)) / (parseFloat(takeRow.P99) - parseFloat(takeRow.P97)) * 2 + 97);
              } else if (weight <= parseFloat(takeRow.P999)) {
                  result = ((weight - parseFloat(takeRow.P99)) / (parseFloat(takeRow.P999) - parseFloat(takeRow.P99)) * 0.99 + 99);
              } else {
                  result = 100;
              }

              firstAns = round(result, 2);

              if (weight <= parseFloat(takeRow.P01)) {
                  result = 0.1;
              } else if (weight <= parseFloat(takeRow.P1)) {
                  result = 1;
              } else if (weight <= parseFloat(takeRow.P3)) {
                  result = 3;
              } else if (weight <= parseFloat(takeRow.P5)) {
                  result = 5;
              } else if (weight <= parseFloat(takeRow.P10)) {
                  result = 10;
              } else if (weight <= parseFloat(takeRow.P15)) {
                  result = 15;
              } else if (weight <= parseFloat(takeRow.P25)) {
                  result = 25;
              } else if (weight <= parseFloat(takeRow.P50)) {
                  result = 50;
              } else if (weight <= parseFloat(takeRow.P75)) {
                  result = 75;
              } else if (weight <= parseFloat(takeRow.P85)) {
                  result = 85;
              } else if (weight <= parseFloat(takeRow.P90)) {
                  result = 90;
              } else if (weight <= parseFloat(takeRow.P95)) {
                  result = 95;
              } else if (weight <= parseFloat(takeRow.P97)) {
                  result = 97;
              } else if (weight <= parseFloat(takeRow.P99)) {
                  result = 99;
              } else if (weight <= parseFloat(takeRow.P999)) {
                  result = 99.9;
              } else {
                  result = 100;
              }

              percentile = result;

              if (percentile == 0.1) {
                  line = 'The result is below <b> 0.1 percentile </b><br />' + 'It seems that your child may be short for their age. Check if they have always been in those ranges. <b>If they have entered these ranges recently, consult a doctor.</b>';
              } else if (percentile == 1) {
                  line = 'Between <b>0.1</b> and <b>1st percentile</b><br />' + 'It seems that your child may be short for their age. Check if they have always been in those ranges. <b>If they have entered these ranges recently, consult a doctor.</b>';
              } else if (percentile == 3) {
                  line = 'Between <b>1st</b> and <b>3rd percentile</b><br />' + 'It seems that your child may be short for their age. Check if they have always been in those ranges. <b>If they have entered these ranges recently, consult a doctor.</b>';
              } else if (percentile == 5) {
                  line = 'Between the <b>3rd</b> and <b>5th percentiles</b>';
              } else if (percentile == 10) {
                  line = 'Between the <b>5th</b> and <b>10th percentiles</b>';
              } else if (percentile == 15) {
                  line = 'Between the <b>10th</b> and <b>15th percentiles<b>';
              } else if (percentile == 25) {
                  line = 'Between the <b>15th</b> and <b>25th percentiles</b>';
              } else if (percentile == 50) {
                  line = 'Between the <b>25th</b> and <b>50th percentiles</b>';
              } else if (percentile == 75) {
                  line = 'Between the <b>50th</b> and <b>75th percentiles</b>';
              } else if (percentile == 85) {
                  line = 'Between the <b>75th</b> and <b>85th percentiles</b>';
              } else if (percentile == 90) {
                  line = 'Between the <b>85th</b> and <b>90th percentiles</b><br\>';
              } else if (percentile == 95) {
                  line = 'Between the <b>90th</b> and <b>95th percentiles</b><br\>';
              } else if (percentile == 97) {
                  line = 'Between the <b>95th</b> and <b>97th percentiles</b><br\>';
              } else if (percentile == 99) {
                  line = 'Between the <b>97th</b> and <b>99th percentiles</b><br />' + 'It seems that your child is taller than their peers. Check if they have always been in those ranges. <b>If they have entered these ranges recently, consult a doctor.</b>';
              } else if (percentile == 99.9) {
                  line = 'Between the <b> 99th</b> and <b>99.9th percentiles</b><br />' + 'It seems that your child is taller than their peers. Check if they have always been in those ranges. <b>If they have entered these ranges recently, consult a doctor.</b>';
              } else if (percentile == 100) {
                  line = 'The result is above the <b>99.9th percentile</b><br />' + 'It seems that your child is taller than their peers. Check if they have always been in those ranges. <b>If they have entered these ranges recently, consult a doctor.</b>';
              }

              if (percentile < 3) {
                  image = "image_1";
              } else if (percentile === 3) {
                  image = "image_2";
              } else if (percentile < 4) {
                  image = "image_3";
              } else if (percentile < 5) {
                  image = "image_4";
              } else if (percentile === 5) {
                  image = "image_5";
              } else if (percentile < 10) {
                  image = "image_6";
              } else if (percentile < 15) {
                  image = "image_7";
              } else if (percentile === 15) {
                  image = "image_8";
              } else if (percentile < 20) {
                  image = "image_9";
              } else if (percentile < 25) {
                  image = "image_10";
              } else if (percentile === 25) {
                  image = "image_11";
              } else if (percentile < 37) {
                  image = "image_12";
              } else if (percentile < 50) {
                  image = "image_13";
              } else if (percentile === 50) {
                  image = "image_14";
              } else if (percentile < 63) {
                  image = "image_15";
              } else if (percentile < 75) {
                  image = "image_16";
              } else if (percentile === 75) {
                  image = "image_17";
              } else if (percentile < 80) {
                  image = "image_18";
              } else if (percentile < 85) {
                  image = "image_19";
              } else if (percentile === 85) {
                  image = "image_20";
              } else if (percentile < 90) {
                  image = "image_21";
              } else if (percentile < 95) {
                  image = "image_22";
              } else if (percentile === 95) {
                  image = "image_23";
              } else if (percentile < 96) {
                  image = "image_24";
              } else if (percentile < 97) {
                  image = "image_25";
              } else if (percentile === 97) {
                  image = "image_26";
              } else if (percentile > 97) {
                  image = "image_27";
              }

              return {
                  tech_first_ans: firstAns,
                  tech_line: line,
                  tech_image: image,
                  tech_actual_cm: actualCm,
              };
          } else {
              return { error: 'This BMI percentile calculator is only for children up to the age of 19.' };
          }
      } else {
          return { error: 'Please! Check your input.' };
      }
      
      // Helper functions
      function isNumeric(value) {
          return !isNaN(parseFloat(value)) && isFinite(value);
      }
      
      function round(value, decimals) {
          return Number(Math.round(value + 'e' + decimals) + 'e-' + decimals);
      }
  }


   /**
    * getCalculationJumpRopeCalorieCalculator: Service Method
    * POST: /api/calculators-lol/jump-rope-calorie-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

async getCalculationJumpRopeCalorieCalculator(body) {
      let operations = body.tech_operations;
        let age = parseFloat(body.tech_age);
        let gender = body.tech_gender;
        let first = body.tech_first;
        let units1 = body.tech_units1;
        let second = body.tech_second;
        let units2 = body.tech_units2;
        let height_ft = body.tech_height_ft;
        let height_in = body.tech_height_in;
        let height_cm = body.tech_height_cm;
        let h_unit = body.tech_unit_ft_in;


    let param = {};

    try {
      // Convert weight unit to numeric code
      let unitWeight = 0;
      if (units1 == "kg") unitWeight = 1;
      else if (units1 == "lbs") unitWeight = 2;
      else if (units1 == "stone") unitWeight = 3;

      // Convert time unit to numeric code
      let unitTime = 0;
      if (units2 == "sec") unitTime = 1;
      else if (units2 == "min") unitTime = 2;
      else if (units2 == "hrs") unitTime = 3;

      // helper: time conversion
      function time2(a, b) {
        if (a == 1) return b * 0.016667;
        if (a == 2) return b * 1;
        if (a == 3) return b * 60;
        return 0;
      }

      // helper: weight conversion
      function weight(a, b) {
        if (a == 1) return b * 1;
        if (a == 2) return b * 0.4536;
        if (a == 3) return b * 6.35;
        return 0;
      }

      let firstVal = weight(unitWeight, parseFloat(first));
      let secondVal = time2(unitTime, parseFloat(second));
      if (!isNaN(firstVal) && !isNaN(secondVal)) {
        if (firstVal > 30) {
          if (firstVal < 300) {
            if (secondVal > 0) {
              let heightInches = parseFloat(height_in) || 0;
              let heightFeet = parseFloat(height_ft) || 0;
              
              if (h_unit == "cm") {
                heightInches = 0;
                heightFeet = height_cm / 30.48;
                heightInches = heightFeet * 12 + heightInches;
              }
              heightInches = heightFeet * 12 + heightInches;
              //  console.log(heightFeet,heightInches);
              const cbr_ans = (operations * firstVal * 7) / 400;
              const cb_ans = cbr_ans * secondVal;

              let BMR = 0;
              if (gender == "1") {
                BMR =
                  13.397 * firstVal +
                  4.799 * heightInches * 2.54 -
                  5.677 * age +
                  88.362;
              } else {
                BMR =
                  9.247 * firstVal +
                  3.098 * heightInches * 2.54 -
                  4.33 * age +
                  447.593;
              }
              // console.log(BMR,firstVal,heightInches,age);
              param = {
                tech_cbr_ans:cbr_ans,
                tech_cb_ans:cb_ans,
                tech_BMR:BMR,
                tech_met: operations,
              };
            } else {
              param.error = "Time must be more than zero.";
            }
          } else {
            param.error = "Your weight cannot be more than 660 lb (300 kg).";
          }
        } else {
          param.error = "Your weight cannot be less than 66 lb (30 kg).";
        }
      } else {
        param.error = "Please! Check your input.";
      }

      return param;
    } catch (error) {
      console.error("Jump Rope Calculator Error:", error);
      return {
        status: "fail",
        error: error.message,
      };
    }
  }

   /**
    * getCalculationBiologicalAgeCalculator: Service Method
    * POST: /api/calculators-lol/biological-age-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

   async getCalculationBiologicalAgeCalculator(body) {
      let m1 = body.tech_m1;
      let m2 = body.tech_m2;
      let m3 = body.tech_m3;
      let m5 = body.tech_m5;
      let m6 = body.tech_m6;
      let m7 = body.tech_m7;
      let m8 = body.tech_m8;
      let m11 = body.tech_m11;
      let m12 = body.tech_m12;
      let m13 = body.tech_m13;
      let m14 = body.tech_m14;
      let m16 = body.tech_m16;
      let m17 = body.tech_m17;
      let m18 = body.tech_m18;
      let m19 = body.tech_m19;
      let m20 = body.tech_m20;
      let m21 = body.tech_m21;
      let m22 = body.tech_m22;
      let m23 = body.tech_m23;
      let m24 = body.tech_m24;
      let m27 = body.tech_m27;
      let m28 = body.tech_m28;
      let m30 = body.tech_m30;
      let m31 = body.tech_m31;
      let m34 = body.tech_m34;
      let m35 = body.tech_m35;
      let m36 = body.tech_m36;
      let age = body.tech_age;


      let param = {};

      try {
        let ageVal = parseFloat(age) || 0;

        // Base calculations
        const M = 75.4140596125 +
          0.0618445029 * ageVal -
          0.0013020249 * Math.pow(ageVal, 2) +
          0.0000231775 * Math.pow(ageVal, 3) +
          0.0000001066 * Math.pow(ageVal, 4);

        const F = 80.6705634463 +
          0.0374221292 * ageVal -
          0.0005304983 * Math.pow(ageVal, 2) -
          0.0000008558 * Math.pow(ageVal, 3) +
          0.0000002442 * Math.pow(ageVal, 4);

        const typ = Math.round(
          10 *
          (78.0916570818 +
            0.0525689171 * ageVal -
            0.0009946587 * Math.pow(ageVal, 2) +
            0.0000124103 * Math.pow(ageVal, 3) +
            0.0000001689 * Math.pow(ageVal, 4))
        ) / 10;

        let RaceAge = 0;

        // Race & Gender based calculations
        if ((m1 == "male" || m1 == "m") && m2 == "white") {
          RaceAge = M + 0.55 - 0.009964 * ageVal - 0.000027 * Math.pow(ageVal, 2);
        } else if ((m1 == "male" || m1 == "m") && m2 == "black") {
          RaceAge =
            M -
            5.592857 -
            0.01625 * ageVal +
            0.001732 * Math.pow(ageVal, 2) -
            0.000009 * Math.pow(ageVal, 3);
        } else if ((m1 == "male" || m1 == "m") && m2 == "hispanic") {
          RaceAge = M + 3.1 - 0.06975 * ageVal + 0.000338 * Math.pow(ageVal, 2);
        } else if ((m1 == "male" || m1 == "m") && m2 == "asian") {
          RaceAge = M + 6.8 - 0.153 * ageVal + 0.00085 * Math.pow(ageVal, 2);
        } else if ((m1 == "male" || m1 == "m") && m2 == "amindian") {
          RaceAge = M - 1.2 + 0.007 * ageVal + 0.0001 * Math.pow(ageVal, 2);
        } else if ((m1 == "male" || m1 == "m") && (m2 == "other" || m2 == "oth")) {
          RaceAge = M + 0;
        } else if (m1 == "female" && m2 == "white") {
          RaceAge = F + 0.396429 - 0.003946 * ageVal - 0.000013 * Math.pow(ageVal, 2);
        } else if (m1 == "female" && m2 == "black") {
          RaceAge =
            F -
            3.815873 -
            0.022566 * ageVal +
            0.001428 * Math.pow(ageVal, 2) -
            0.000008 * Math.pow(ageVal, 3);
        } else if (m1 == "female" && m2 == "hispanic") {
          RaceAge = F + 3.9 - 0.08775 * ageVal + 0.000488 * Math.pow(ageVal, 2);
        } else if (m1 == "female" && m2 == "asian") {
          RaceAge = F + 6.7 - 0.15075 * ageVal + 0.000838 * Math.pow(ageVal, 2);
        } else if (m1 == "female" && m2 == "amindian") {
          RaceAge = F + 2.2 - 0.0695 * ageVal + 0.000525 * Math.pow(ageVal, 2);
        } else if (m1 == "female" && (m2 == "other" || m2 == "oth")) {
          RaceAge = F + 0;
        }

        // Sectional calculations
        const RaceAdj = RaceAge - typ;
        const personalT = Math.round(10 * (RaceAdj + Number(m3) + Number(m5))) / 10;
        const cadT = Number(m6) + Number(m7) + Number(m8) + Number(m11) + Number(m12);
        const medicalIT =
          Number(m13) +
          Number(m14) +
          Number(m16) +
          Number(m17) +
          Number(m18) +
          Number(m19) +
          Number(m20);
        const dietT = Number(m21) + Number(m22) + Number(m23) + Number(m24);
        const psychT = Number(m27) + Number(m28) + Number(m30) + Number(m31);
        const safetyT = Number(m34) + Number(m35) + Number(m36);

        // Final totals
        const total_value =
          personalT + cadT + medicalIT + dietT + psychT + safetyT;

        const expectancy = Math.round(10 * (typ + total_value)) / 10;
        const healthage_value = ageVal - total_value;

        // Results
        param = {
          tech_typ:typ,
          tech_exp: expectancy,
          tech_bio: healthage_value,
          tech_per: personalT,
          tech_med: medicalIT,
          tech_saf: safetyT,
          tech_tot: total_value,
          tech_psychT:psychT,
          tech_nut: dietT,
          tech_cad: cadT,
        };

        return param;
      } catch (error) {
        console.error("Biological Age Calculator Error:", error);
        return {
          status: "fail",
          message: "Internal Server Error",
          error: error.message,
        };
      }
    }

      /**
    * getCalculationPregnancyWeightGainCalculator: Service Method
    * POST: /api/calculators-lol/pregnancy-weight-gain-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

  async getCalculationPregnancyWeightGainCalculator(body) {
        let height_ft = body.tech_height_ft;
    let height_in = body.tech_height_in;
    let height_cm = body.tech_height_cm;
    let h_unit = body.tech_unit_ft_in;
    let weight = body.tech_weight;
    let w_unit = body.tech_w_unit;
    let week = body.tech_week;
    let activity = body.tech_activity;


      let param = {};
      let check = false;

      // --- Unit conversion for weight ---
      let weightUnit;
      if (w_unit == 'lbs') {
        weightUnit = 0.453592;
      } else if (w_unit == 'oz') {
        weightUnit = 0.0283495;
      } else if (w_unit == 'kg') {
        weightUnit = 1;
      } else if (w_unit == 'stone') {
        weightUnit = 6.35029;
      }

      // --- Full data array copied as-is ---
      const data = [
        [
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0.09, 0.4, 0.09, 0.4, 0.09, 0.4, 0.09, 0.4],
          [0.2, 0.7, 0.2, 0.7, 0.2, 0.7, 0.2, 0.7],
          [0.3, 1.1, 0.3, 1.1, 0.3, 1.1, 0.3, 1.1],
          [0.4, 1.5, 0.4, 1.5, 0.4, 1.5, 0.4, 1.5],
          [0.5, 1.8, 0.5, 1.8, 0.5, 1.8, 0.5, 1.8],
          [0.6, 2.2, 0.6, 2.2, 0.6, 2.2, 0.6, 2.2],
          [0.6, 2.6, 0.6, 2.6, 0.6, 2.6, 0.6, 2.6],
          [0.7, 2.9, 0.7, 2.9, 0.7, 2.9, 0.7, 2.9],
          [0.8, 3.3, 0.8, 3.3, 0.8, 3.3, 0.8, 3.3],
          [0.9, 3.7, 0.9, 3.7, 0.9, 3.7, 0.9, 3.7],
          [1, 4, 1, 4, 1, 4, 1, 4],
          [1.1, 4.4, 1.1, 4.4, 1.1, 4.4, 1.1, 4.4],
          [2.1, 5.7, 2, 5.5, 1.6, 5.2, 1.5, 5],
          [3.1, 7, 2.9, 6.7, 2.1, 5.9, 1.8, 5.6],
          [4.1, 8.4, 3.8, 7.8, 2.6, 6.7, 2.2, 6.1],
          [5.1, 9.6, 4.6, 8.9, 3.2, 7.5, 2.6, 6.7],
          [6.1, 11, 5.5, 10.1, 3.7, 8.2, 2.9, 7.3],
          [7.1, 12.3, 6.4, 11.2, 4.2, 9, 3.3, 7.9],
          [8.1, 13.6, 7.3, 12.3, 4.7, 9.7, 3.7, 8.4],
          [9.1, 14.9, 8.2, 13.5, 5.2, 10.5, 4, 9],
          [10.1, 16.3, 9.1, 14.6, 5.7, 11.3, 4.4, 9.6],
          [11.1, 17.6, 10, 15.7, 6.2, 12, 4.8, 10.2],
          [12.1, 18.9, 10.8, 16.9, 6.8, 12.8, 5.1, 10.8],
          [13.1, 20.2, 11.7, 18, 7.3, 13.6, 5.5, 11.3],
          [14.1, 21.5, 12.6, 19.1, 7.8, 14.3, 5.9, 11.9],
          [15, 22.9, 13.5, 20.3, 8.3, 15.1, 6.2, 12.5],
          [16, 24.2, 14.4, 21.4, 8.8, 15.8, 6.6, 13.1],
          [17, 25.5, 15.3, 22.5, 9.3, 16.6, 7, 13.6],
          [18, 26.8, 16.1, 23.7, 9.9, 17.4, 7.3, 14.2],
          [19, 28.1, 17, 24.8, 10.4, 18.1, 7.7, 14.8],
          [20, 29.5, 17.9, 25.9, 10.9, 18.9, 8.1, 15.4],
          [21, 30.8, 18.8, 27.1, 11.4, 19.7, 8.4, 16],
          [22, 32.1, 19.7, 28.2, 11.9, 20.4, 8.8, 16.5],
          [23, 33.4, 20.6, 29.3, 12.4, 21.2, 9.2, 17.1],
          [24, 34.7, 21.5, 30.5, 12.9, 21.9, 9.5, 17.7],
          [25, 36, 22.3, 31.6, 13.5, 22.7, 9.9, 18.3],
          [26, 37.4, 23.2, 32.7, 14, 23.5, 10.3, 18.8],
          [27, 38.7, 24.1, 33.9, 14.5, 24.2, 10.6, 19.4],
          [28, 40, 25, 35, 15, 25, 11, 20],
        ],
        [
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0.09, 0.4, 0.09, 0.4, 0.09, 0.4, 0.09, 0.4],
          [0.2, 0.7, 0.2, 0.7, 0.2, 0.7, 0.2, 0.7],
          [0.3, 1.1, 0.3, 1.1, 0.3, 1.1, 0.3, 1.1],
          [0.4, 1.5, 0.4, 1.5, 0.4, 1.5, 0.4, 1.5],
          [0.5, 1.8, 0.5, 1.8, 0.5, 1.8, 0.5, 1.8],
          [0.6, 2.2, 0.6, 2.2, 0.6, 2.2, 0.6, 2.2],
          [0.6, 2.6, 0.6, 2.6, 0.6, 2.6, 0.6, 2.6],
          [0.7, 2.9, 0.7, 2.9, 0.7, 2.9, 0.7, 2.9],
          [0.8, 3.3, 0.8, 3.3, 0.8, 3.3, 0.8, 3.3],
          [0.9, 3.7, 0.9, 3.7, 0.9, 3.7, 0.9, 3.7],
          [1, 4, 1, 4, 1, 4, 1, 4],
          [1.1, 4.4, 1.1, 4.4, 1.1, 4.4, 1.1, 4.4],
          [2.4, 6.2, 2.4, 6.2, 2.2, 6.1, 2, 5.8],
          [3.8, 8.1, 3.8, 8.1, 3.3, 7.8, 2.9, 7.2],
          [5.1, 9.9, 5.1, 9.9, 4.4, 9.5, 3.8, 8.6],
          [6.4, 11.7, 6.4, 11.7, 5.5, 11.2, 4.6, 10],
          [7.7, 13.6, 7.7, 13.6, 6.6, 12.8, 5.5, 11.4],
          [9.1, 15.4, 9.1, 15.4, 7.7, 14.5, 6.4, 12.8],
          [10.4, 17.3, 10.4, 17.3, 8.9, 16.2, 7.3, 14.1],
          [11.7, 19.1, 11.7, 19.1, 10, 17.9, 8.2, 15.5],
          [13.1, 20.9, 13.1, 20.9, 11.1, 19.6, 9.1, 16.9],
          [14.4, 22.8, 14.4, 22.8, 12.2, 21.3, 10, 18.3],
          [15.7, 24.6, 15.7, 24.6, 13.3, 23, 10.8, 19.7],
          [17.1, 26.4, 17.1, 26.4, 14.4, 24.7, 11.7, 21.1],
          [18.4, 28.3, 18.4, 28.3, 15.5, 26.4, 12.6, 22.5],
          [19.7, 30.1, 19.7, 30.1, 16.6, 28, 13.5, 23.9],
          [21, 32, 21, 32, 17.7, 29.7, 14.4, 25.3],
          [22.4, 33.8, 22.4, 33.8, 18.8, 31.4, 15.3, 26.7],
          [23.7, 35.6, 23.7, 35.6, 19.9, 33.1, 16.1, 28.1],
          [25, 37.5, 25, 37.5, 21, 34.8, 17, 29.5],
          [26.4, 39.3, 26.4, 39.3, 22.1, 36.5, 17.9, 30.9],
          [27.7, 41.1, 27.7, 41.1, 23.2, 38.2, 18.8, 32.3],
          [29, 43, 29, 43, 24.4, 39.9, 19.7, 33.6],
          [30.4, 44.8, 30.4, 44.8, 25.5, 41.6, 20.6, 35],
          [31.7, 46.7, 31.7, 46.7, 26.6, 43.2, 21.5, 36.4],
          [33, 48.5, 33, 48.5, 27.7, 44.9, 22.3, 37.8],
          [34.3, 50.3, 34.3, 50.3, 28.8, 46.6, 23.2, 39.2],
          [35.7, 52.2, 35.7, 52.2, 29.9, 48.3, 24.1, 40.6],
          [37, 54, 37, 54, 31, 50, 25, 42],
        ],
      ];

      // --- Input validation ---
      if (
        (h_unit == 'ft/in' && !isNaN(weight) && !isNaN(height_ft)) ||
        (h_unit != 'ft/in' && !isNaN(weight) && (!isNaN(height_in) || !isNaN(height_cm)))
      ) {
        check = true;
      }

      if (!check) {
        param.error = 'Please! Check your input.';
        return param;
      }

      // --- Convert units ---
      let weight_kg = weight * weightUnit;
      let heightInInches;


      	if (h_unit == 'cm') {
				height_in = 0;
				height_ft = (height_cm / 30.48);
				height_in = parseFloat(height_ft) * 12 + parseFloat(height_in);							
			}

     height_in = parseFloat(height_ft) * 12 + parseFloat(height_in);	
      const height_m = height_in / 39.37;
      const BMI = +(weight_kg / (height_m ** 2)).toFixed(2);
      console.log(BMI,weight_kg,height_m);
      // --- Determine category ---
      let you_are, category;
      if (BMI <= 18.5) {
        you_are = 'Underweight';
        category = 1;
      } else if (BMI <= 24.9) {
        you_are = 'Normal Weight';
        category = 2;
      } else if (BMI <= 29.9) {
        you_are = 'Excess Weight';
        category = 3;
      } else if (BMI <= 35) {
        you_are = 'Obesity';
        category = 4;
      } else {
        you_are = 'Extremely Obesity';
        category = 4;
      }

      // --- Compute gain ---
      const offset = 2 * (category - 1);
      const offset_min = 2 * (category - 1) + parseInt(activity);

      const min_weight = data[0][week - 1][offset_min];
      const max_weight = data[1][week - 1][offset_min];

      const min_weight_gain = +(min_weight / 2.205).toFixed(1);
      const max_weight_gain = +(max_weight / 2.205).toFixed(1);

      const min_weight_ans = +(weight_kg + min_weight_gain).toFixed(1);
      const max_weight_ans = +(weight_kg + max_weight_gain).toFixed(1);

      const gain = [];
      const all = [];

      for (const value of data[activity]) {
        const min = value[offset];
        const max = value[offset + 1];
        gain.push(`${min} - ${max} kg`);
        all.push(`${(weight_kg + min).toFixed(1)} - ${(weight_kg + max).toFixed(1)} kg`);
      }

      // --- Response ---
      param.tech_min_weight_ans = min_weight_ans;
      param.tech_max_weight_ans = max_weight_ans;
      param.tech_min_weight_gain = min_weight_gain;
      param.tech_max_weight_gain = max_weight_gain;
      param.tech_BMI = BMI;
      param.tech_you_are = you_are;
      param.tech_gain = gain;
      param.tech_all = all;

      return param;
    }

        /**
    * getCalculationStrokeVolumeCalculator: Service Method
    * POST: /api/calculators-lol/stroke-volume-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationStrokeVolumeCalculator(body) {
      try {
          let Cardiac = body.tech_Cardiac;
      let Cardiac_unit = body.tech_Cardiac_unit;
      let heart = body.tech_heart;
      let height = body.tech_height_cm;
      let one_height = body.tech_height_ft;
      let sec_height = body.tech_height_in;
      let height_unit = body.tech_unit_ft_in;
      let weight = body.tech_weight;
      let weight_unit = body.tech_weight_unit;


        Cardiac = parseFloat(Cardiac);
        heart = parseFloat(heart);
        height = parseFloat(height);
        one_height = parseFloat(one_height);
        sec_height = parseFloat(sec_height);
        weight = parseFloat(weight);

        if (!Cardiac_unit) Cardiac_unit = "";
        Cardiac_unit = Cardiac_unit.replace("/min ", "").trim();
        height_unit = height_unit?.trim();

        // Helper functions
        function unitToLiters(Cardiac, Cardiac_unit) {
          switch (Cardiac_unit) {
            case "mm³": return Cardiac / 1e9;
            case "cm³": return Cardiac / 1000;
            case "dm³": return Cardiac;
            case "m³": return Cardiac * 1000;
            case "in³": return Cardiac / 61023.7;
            case "ft³": return Cardiac * 28.3168;
            case "yd³": return Cardiac / 764.555;
            case "ml": return Cardiac / 1000;
            case "cl": return Cardiac / 100;
            case "l": return Cardiac;
            case "US gal": return Cardiac * 3.78541;
            case "UK gal": return Cardiac * 4.54609;
            case "US fl oz": return Cardiac / 33.814;
            case "UK fl oz": return Cardiac / 35.1951;
            case "cups": return Cardiac * 0.284131;
            case "tbsp": return Cardiac / 67.628;
            case "tsp": return Cardiac / 202.884;
            case "US qt": return Cardiac * 0.946353;
            case "UK qt": return Cardiac * 1.13652;
            case "US pt": return Cardiac / 1.05669;
            case "UK pt": return Cardiac / 1.13652;
            default: return null;
          }
        }

        function lambai_unit(height, height_unit) {
          switch (height_unit) {
            case "mm": return height / 10;
            case "cm": return height;
            case "m": return height * 100;
            case "km": return height * 100000;
            case "in": return height * 2.54;
            case "ft": return height * 30.48;
            case "yd": return height * 91.44;
            case "mi": return height * 160934;
            case "nmi": return height * 185200;
            default: return height;
          }
        }

        function other_lamba(one_height, sec_height, height_unit) {
          if (height_unit === "ft/in") {
            return one_height * 30.48 + sec_height * 2.54;
          } else if (height_unit === "m/cm") {
            return one_height * 100 + sec_height;
          }
          return 0;
        }

        function wazan_unit(weight, weight_unit) {
          switch (weight_unit) {
            case "µg": return weight / 1000000;
            case "mg": return weight / 1000;
            case "g": return weight;
            case "dag": return weight / 100;
            case "kg": return weight;
            case "t": return weight * 1000;
            case "gr": return weight / 15.4324;
            case "dr": return weight / 56479.1;
            case "oz": return weight / 35.274;
            case "lbs": return weight / 2.20462;
            case "st": return weight / 0.157473;
            case "US ton": return weight * 907.185;
            case "long ton": return weight * 1016.05;
            case "Earths": return weight * 5.9722e24;
            case "me": return weight * 9.10938356e-31;
            case "u": return weight * 1.66053904e-27;
            case "oz t": return weight / 35.27396;
            default: return weight;
          }
        }

        // Validation
        if (
          isNaN(Cardiac) ||
          isNaN(heart) ||
          isNaN(weight) ||
          (isNaN(height) && isNaN(one_height) && isNaN(sec_height))
        ) {
          return { status: "fail", error: "Please! Check Your Input." };
        }

        Cardiac = unitToLiters(Cardiac, Cardiac_unit);
        if (Cardiac <= 0)
          return { status: "fail", error: "Cardiac output should be an integer greater than 0." };
        if (heart <= 0)
          return { status: "fail", error: "Heart rate should be an integer greater than 0." };
        if (weight <= 0)
          return { status: "fail", error: "Weight should be an integer greater than 0." };

        const stroke_volume = Cardiac / heart;

        if (!one_height && !sec_height && !height)
          return { status: "fail", error: "Please! Enter Input." };

        one_height = one_height || 0;
        sec_height = sec_height || 0;

        if (height_unit == "ft/in" || height_unit == "m/cm") {
          height = other_lamba(one_height, sec_height, height_unit);
        } else {
          height = lambai_unit(height, height_unit);
        }

        weight = wazan_unit(weight, weight_unit);
        if (height <= 0)
          return { status: "fail", error: "Height should be an integer greater than 0." };

        // Calculations
        const bsa = 0.007184 * Math.pow(height, 0.725) * Math.pow(weight, 0.425);
        const stroke_val_index = Cardiac / bsa;
        const stroke_index = stroke_volume / bsa;

        return {
          tech_status: "success",
          tech_stroke_volume:stroke_volume,
          tech_bsa:bsa,
          tech_stroke_val_index:stroke_val_index,
          tech_stroke_index:stroke_index,
        };
      } catch (error) {
        return {
          status: "fail",
          error: error.message || "Something went wrong in Stroke Volume Calculator.",
        };
      }
    }


         /**
    * getCalculationNavyBodyFatCalculator: Service Method
    * POST: /api/calculators-lol/navy-body-fat-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationNavyBodyFatCalculator(body) {
      try {
         const weight = body.tech_weight;
        const weight_unit = body.tech_weight_unit;
        const age = body.tech_age;
        const gender = body.tech_gender;

        const height_cm = body.tech_height_cm;
        const height_unit = body.tech_unit_ft_in;
        const height_ft = body.tech_height_ft;
        const height_in = body.tech_height_in;

        const neck_cm = body.tech_neck_cm;
        const neck_unit = body.tech_unit_ft_in1;
        const neck_ft = body.tech_neck_ft;
        const neck_in = body.tech_neck_in;

        const waist_cm = body.tech_waist_cm;
        const waist_unit = body.tech_unit_ft_in2;
        const waist_ft = body.tech_waist_ft;
        const waist_in = body.tech_waist_in;

        const hip_cm = body.tech_hip_cm;
        const hip_unit = body.tech_unit_ft_in3;
        const hip_ft = body.tech_hip_ft;
        const hip_in = body.tech_hip_in;


          let height = height_cm;
          let weightLbs = weight;
          let waist = waist_cm;
          let neck = neck_cm;
          let hip = null;
          
          // Check if hip input is provided for females
          if (gender === 'female') {
              hip = hip_cm || null;
          }

          // Convert height to cm
          if (height_unit) {
              if (height_unit === 'ft/in') {
                  const feet_to_cm = height_ft * 30.48;
                  const inches_to_cm = height_in * 2.54;
                  height = feet_to_cm + inches_to_cm;
              } else if (height_unit === 'cm') {
                  height = height_cm;
              } else if (height_unit === 'm') {
                  height = height_cm * 100;
              } else if (height_unit === 'ft') {
                  height = height_cm * 30.48;
              } else if (height_unit === 'in') {
                  height = height_cm * 2.54;
              }
          }

          // Convert weight to lbs
          if (weight_unit) {
              if (weight_unit === 'lbs') {
                  weightLbs = weight;
              } else if (height_unit === 'kg') {
                  weightLbs = weight * 2.20462;
              }
          }
          // console.log(weightLbs,weight_unit);
          // Convert waist to cm
          if (waist_unit) {
              if (waist_unit == 'ft/in') {
                  const feet_to_cm = waist_ft * 30.48;
                  const inches_to_cm = waist_in * 2.54;
                  waist = feet_to_cm + inches_to_cm;
              } else if (waist_unit == 'cm') {
                  waist = waist_cm;
              } else if (waist_unit == 'm') {
                  waist = waist_cm * 100;
              } else if (waist_unit == 'ft') {
                  waist = waist_cm * 30.48;
              } else if (waist_unit == 'in') {
                  waist = waist_cm * 2.54;
              }
          }

          // Convert neck to cm
          if (neck_unit) {
              if (neck_unit == 'ft/in') {
                  const feet_to_cm = neck_ft * 30.48;
                  const inches_to_cm = neck_in * 2.54;
                  neck = feet_to_cm + inches_to_cm;
              } else if (neck_unit == 'cm') {
                  neck = neck_cm;
              } else if (neck_unit == 'm') {
                  neck = neck_cm * 100;
              } else if (neck_unit == 'ft') {
                  neck = neck_cm * 30.48;
              } else if (neck_unit == 'in') {
                  neck = neck_cm * 2.54;
              }
          }

          // Convert hip to cm
          if (hip_unit && gender == 'female') {
              if (hip_unit == 'ft/in') {
                  const feet_to_cm = hip_ft * 30.48;
                  const inches_to_cm = hip_in * 2.54;
                  hip = feet_to_cm + inches_to_cm;
              } else if (hip_unit == 'cm') {
                  hip = hip_cm;
              } else if (hip_unit == 'm') {
                  hip = hip_cm * 100;
              } else if (hip_unit == 'ft') {
                  hip = hip_cm * 30.48;
              } else if (hip_unit == 'in') {
                  hip = hip_cm * 2.54;
              }
          }

          // Validate inputs
          const isValid = !isNaN(height) && !isNaN(waist) && !isNaN(neck) && !isNaN(weightLbs) && 
                        (gender == 'male' || (gender == 'female' && !isNaN(hip)));

          if (!isValid) {
              return {
                  error: 'Please! Check Your Input.',
                  RESULT: 0
              };
          }

          // Calculate body fat percentage
          let bodyFat;
          if (gender == 'male') {
              bodyFat = 495 / (1.0324 - 0.19077 * Math.log10(waist - neck) + 0.15456 * Math.log10(height)) - 450;
          } else {
              bodyFat = 495 / (1.29579 - 0.35004 * Math.log10(waist + hip - neck) + 0.22100 * Math.log10(height)) - 450;
          }

          // Calculate Fat Mass and Lean Mass
          const fatMass = parseFloat(weightLbs) * (bodyFat / 100);
          const leanMass = parseFloat(weightLbs) - fatMass;
          // console.log(fatMass,weightLbs,bodyFat);
          // Determine Body Fat Category
          let bodyFatCategory;
          if (gender == 'male') {
              if (age >= 17 && age <= 26) {
                  if (bodyFat < 6) {
                      bodyFatCategory = 'Essential Fat';
                  } else if (bodyFat >= 6 && bodyFat < 16) {
                      bodyFatCategory = 'Athletic';
                  } else if (bodyFat >= 16 && bodyFat < 20) {
                      bodyFatCategory = 'Fit';
                  } else {
                      bodyFatCategory = 'Acceptable';
                  }
              } else {
                  if (bodyFat < 10) {
                      bodyFatCategory = 'Essential Fat';
                  } else if (bodyFat >= 10 && bodyFat < 20) {
                      bodyFatCategory = 'Athletic';
                  } else if (bodyFat >= 20 && bodyFat < 24) {
                      bodyFatCategory = 'Fit';
                  } else {
                      bodyFatCategory = 'Acceptable';
                  }
              }
          } else {
              if (age >= 17 && age <= 26) {
                  if (bodyFat < 16) {
                      bodyFatCategory = 'Essential Fat';
                  } else if (bodyFat >= 16 && bodyFat < 24) {
                      bodyFatCategory = 'Athletic';
                  } else if (bodyFat >= 24 && bodyFat < 30) {
                      bodyFatCategory = 'Fit';
                  } else {
                      bodyFatCategory = 'Acceptable';
                  }
              } else {
                  if (bodyFat < 20) {
                      bodyFatCategory = 'Essential Fat';
                  } else if (bodyFat >= 20 && bodyFat < 28) {
                      bodyFatCategory = 'Athletic';
                  } else if (bodyFat >= 28 && bodyFat < 34) {
                      bodyFatCategory = 'Fit';
                  } else {
                      bodyFatCategory = 'Acceptable';
                  }
              }
          }

          return {
              tech_bodyFat: parseFloat(bodyFat.toFixed(2)),
              tech_fatMass: Math.abs(parseFloat(fatMass.toFixed(2))),
              tech_leanMass: parseFloat(leanMass.toFixed(2)),
              tech_bodyFatCategory: bodyFatCategory,
          };

      } catch (error) {
          return {
              error: 'An error occurred during calculation.',
              RESULT: 0
          };
      }
  }

     /**
    * getCalculationEerCalculator: Service Method
    * POST: /api/calculators-lol/eer-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

  async getCalculationEerCalculator(body) {
    const param = {};
    const request = body;

    // Validate gender
    if (['Male', 'Female', 'pergnant', 'lac'].includes(request.tech_gender)) {
      // Validate numeric inputs
      if (
        !isNaN(request.tech_age) && 
        !isNaN(request.tech_weight) && 
        (!isNaN(request['tech_height-ft']) || !isNaN(request['tech_height-in']) || !isNaN(request['tech_height-cm']))
      ) {
        let age = parseFloat(request.tech_age);
        let height_ft = parseFloat(request['tech_height-ft']) || 0;
        let height_in = parseFloat(request['tech_height-in']) || 0;
        let height_cm = parseFloat(request['tech_height-cm']) || 0;
        let weight = parseFloat(request.tech_weight);

        // Convert weight if in lbs
        if (request.tech_unit == "lbs") {
          weight = weight / 2.205;
        }

        // Convert height to cm
        if (request.tech_unit_ft_in == 'ft/in') {
          height_cm = height_ft * 30.48;
          if (height_in != null) {
            height_in = height_in * 2.54;
            height_cm = height_cm + height_in;
          }
        }

        // Set activity level physical activity coefficient
        let pa;
        if (request.tech_activity == "Sedentary") {
          pa = 1.0;
          param.tech_stand = 'bg-gradient text-white';
        } else if (request.tech_activity == "Lightly Active") {
          pa = 1.11;
          param.tech_light = 'bg-gradient text-white';
        } else if (request.tech_activity == "Moderately Active") {
          pa = 1.25;
          param.tech_mod = 'bg-gradient text-white';
        } else {
          pa = 1.48;
          param.tech_very = 'bg-gradient text-white';
        }

        // Calculate BMR and RMR
        let bmr, rmr;
        if (request.tech_gender == 'Female') {
          bmr = Math.round(((9.99 * weight) + (6.25 * height_cm) - (4.92 * age) - 161) * 100) / 100;
          rmr = Math.round((655 + (9.6 * weight) + (1.8 * height_cm) - (4.7 * age)) * 100) / 100;
        } else {
          bmr = Math.round(((9.99 * weight) + (6.25 * height_cm) - (4.92 * age) + 5) * 100) / 100;
          rmr = Math.round((66 + (13.7 * weight) + (5 * height_cm) - (6.8 * age)) * 100) / 100;
        }

        // Calculate height in meters
        const height_m = height_cm / 100;
        const convert_hight = height_m * 39.37;

        // Calculate IBW (Ideal Body Weight)
        if (request.tech_gender == 'Female') {
          const Robinson = Math.round(49 + (1.7 * (convert_hight - 60)));
          const Hamwi = Math.round(45 + (2.2 * (convert_hight - 60)));
          
          if (request.tech_unit == 'kg') {
            param.tech_ibw = `${Math.round(Robinson * 2.205)}-${Math.round(Hamwi * 2.205)} lbs`;
          } else if (request.tech_unit == 'lbs') {
            param.tech_ibw = `${Robinson} - ${Hamwi} kg`;
          }
        } else if (request.tech_gender == 'Male') {
          const Robinson = Math.round(52 + (1.9 * (convert_hight - 60)));
          const Hamwi = Math.round(48 + (2.7 * (convert_hight - 60)));
          
          if (request.tech_unit == 'kg') {
            param.tech_ibw = `${Math.round(Robinson * 2.205)}-${Math.round(Hamwi * 2.205)} lbs`;
          } else if (request.tech_unit == 'lbs') {
            param.tech_ibw = `${Robinson} - ${Hamwi} kg`;
          }
        }

        // Calculate BMI
        const BMI = Math.round((weight / (height_m * height_m)) * 100) / 100;

        // Calculate EER for Female/Pregnant/Lactating
        let EER, s, l, m, v;
        if (['Female', 'pergnant', 'lac'].includes(request.tech_gender)) {
          if (age < 9) {
            EER = Math.round(((135.3 - (30.8 * age)) + pa * ((10.0 * weight) + (934 * height_m)) + 20) * 100) / 100;
            s = Math.round(((135.3 - (30.8 * age)) + 1.0 * ((10.0 * weight) + (934 * height_m)) + 20) * 100) / 100;
            l = Math.round(((135.3 - (30.8 * age)) + 1.11 * ((10.0 * weight) + (934 * height_m)) + 20) * 100) / 100;
            m = Math.round(((135.3 - (30.8 * age)) + 1.25 * ((10.0 * weight) + (934 * height_m)) + 20) * 100) / 100;
            v = Math.round(((135.3 - (30.8 * age)) + 1.48 * ((10.0 * weight) + (934 * height_m)) + 20) * 100) / 100;
          } else if (age > 8 && age < 19) {
            EER = Math.round(((135.3 - (30.8 * age)) + pa * ((10.0 * weight) + (934 * height_m)) + 25) * 100) / 100;
            s = Math.round(((135.3 - (30.8 * age)) + 1.0 * ((10.0 * weight) + (934 * height_m)) + 25) * 100) / 100;
            l = Math.round(((135.3 - (30.8 * age)) + 1.11 * ((10.0 * weight) + (934 * height_m)) + 25) * 100) / 100;
            m = Math.round(((135.3 - (30.8 * age)) + 1.25 * ((10.0 * weight) + (934 * height_m)) + 25) * 100) / 100;
            v = Math.round(((135.3 - (30.8 * age)) + 1.48 * ((10.0 * weight) + (934 * height_m)) + 25) * 100) / 100;
          } else {
            EER = Math.round(((354 - (6.91 * age)) + pa * ((9.36 * weight) + (726 * height_m))) * 100) / 100;
            s = Math.round(((354 - (6.91 * age)) + 1.0 * ((9.36 * weight) + (726 * height_m))) * 100) / 100;
            l = Math.round(((354 - (6.91 * age)) + 1.11 * ((9.36 * weight) + (726 * height_m))) * 100) / 100;
            m = Math.round(((354 - (6.91 * age)) + 1.25 * ((9.36 * weight) + (726 * height_m))) * 100) / 100;
            v = Math.round(((354 - (6.91 * age)) + 1.48 * ((9.36 * weight) + (726 * height_m))) * 100) / 100;
            // console.log(EER,age,pa,weight,height_m);
          }
          // Pregnancy adjustments
          if (request.tech_gender == 'pergnant') {
            if (request.tech_trim == '2nd') {
              EER += 340; s += 340; l += 340; m += 340; v += 340;
            }
            if (request.tech_trim == '3rd') {
              EER += 452; s += 452; l += 452; m += 452; v += 452;
            }
          }
          // Lactation adjustments
          if (request.tech_gender == 'lac') {
            if (request.tech_trim == '1st6') {
              EER += 330; s += 330; l += 330; m += 330; v += 330;
            }
            if (request.tech_trim == '2nd6') {
              EER += 400; s += 400; l += 400; m += 400; v += 400;
            }
          }
        } else if (request.tech_gender == 'Male') {
          // Calculate EER for Male
          if (age < 9) {
            EER = Math.round(((88.5 - (61.9 * age)) + pa * ((26.7 * weight) + (903 * height_m)) + 20) * 100) / 100;
            s = Math.round(((88.5 - (61.9 * age)) + 1.0 * ((26.7 * weight) + (903 * height_m)) + 20) * 100) / 100;
            l = Math.round(((88.5 - (61.9 * age)) + 1.11 * ((26.7 * weight) + (903 * height_m)) + 20) * 100) / 100;
            m = Math.round(((88.5 - (61.9 * age)) + 1.25 * ((26.7 * weight) + (903 * height_m)) + 20) * 100) / 100;
            v = Math.round(((88.5 - (61.9 * age)) + 1.48 * ((26.7 * weight) + (903 * height_m)) + 20) * 100) / 100;
          } else if (age > 8 && age < 19) {
            EER = Math.round(((88.5 - (61.9 * age)) + pa * ((26.7 * weight) + (903 * height_m)) + 25) * 100) / 100;
            s = Math.round(((88.5 - (61.9 * age)) + 1.0 * ((26.7 * weight) + (903 * height_m)) + 25) * 100) / 100;
            l = Math.round(((88.5 - (61.9 * age)) + 1.11 * ((26.7 * weight) + (903 * height_m)) + 25) * 100) / 100;
            m = Math.round(((88.5 - (61.9 * age)) + 1.25 * ((26.7 * weight) + (903 * height_m)) + 25) * 100) / 100;
            v = Math.round(((88.5 - (61.9 * age)) + 1.48 * ((26.7 * weight) + (903 * height_m)) + 25) * 100) / 100;
          } else {
            EER = Math.round(((662 - (9.53 * age)) + pa * ((15.91 * weight) + (539.6 * height_m))) * 100) / 100;
            s = Math.round(((662 - (9.53 * age)) + 1.0 * ((15.91 * weight) + (539.6 * height_m))) * 100) / 100;
            l = Math.round(((662 - (9.53 * age)) + 1.11 * ((15.91 * weight) + (539.6 * height_m))) * 100) / 100;
            m = Math.round(((662 - (9.53 * age)) + 1.25 * ((15.91 * weight) + (539.6 * height_m))) * 100) / 100;
            v = Math.round(((662 - (9.53 * age)) + 1.48 * ((15.91 * weight) + (539.6 * height_m))) * 100) / 100;
          }
        }

        // Adjust for weight goals
        if (request.tech_goal == 'lose') {
          EER -= 500; s -= 500; l -= 500; m -= 500; v -= 500;
        }
        if (request.tech_goal == 'gain') {
          EER += 500; s += 500; l += 500; m += 500; v += 500;
        }

        // Determine BMI class
        let bmiClass;
        if (BMI <= 18.5) {
          bmiClass = 'under';
        } else if (BMI > 18.5 && BMI <= 24.9) {
          bmiClass = 'health';
        } else if (BMI > 24.9 && BMI <= 29.9) {
          bmiClass = 'over';
        } else if (BMI > 29.9 && BMI <= 35) {
          bmiClass = 'obese';
        } else if (BMI > 35) {
          bmiClass = 's_obese';
        }

        // Set return parameters
        param.tech_EER = EER;
        param.tech_bmr = bmr;
        param.tech_rmr = rmr;
        param.tech_BMI = BMI;
        param.tech_s = s;
        param.tech_l = l;
        param.tech_m = m;
        param.tech_v = v;
        param.tech_class = bmiClass;

        return param;
      } else {
        param.error = 'Please fill All fields.';
        return param;
      }
    } else if (request.tech_gender == 'child') {
      // Child EER calculation
      if (!isNaN(request.tech_child_age) && !isNaN(request.tech_weight)) {
        let weight = parseFloat(request.tech_weight);
        
        if (request.tech_unit == "lbs") {
          weight = weight / 2.205;
        }

        let EER;
        const child_age = parseFloat(request.tech_child_age);
        
        if (child_age < 4) {
          EER = Math.round(((89 * weight - 100) + 175) * 100) / 100;
        } else if (child_age > 4 && child_age < 7) {
          EER = Math.round(((89 * weight - 100) + 56) * 100) / 100;
        } else if (child_age > 6 && child_age < 13) {
          EER = Math.round(((89 * weight - 100) + 22) * 100) / 100;
        } else if (child_age > 12 && child_age < 36) {
          EER = Math.round(((89 * weight - 100) + 20) * 100) / 100;
        }

        param.tech_EER = EER;
        param.tech_EER_child = "Child";
        return param;
      } else {
        param.error = 'Please fill All fields.';
        return param;
      }
    } else {
      // Obese children calculation
      if (
        !isNaN(request.tech_age) && 
        !isNaN(request.tech_weight) && 
        (!isNaN(request['tech_height-ft']) || !isNaN(request['tech_height-in']) || !isNaN(request['tech_height-cm']))
      ) {
        let age = parseFloat(request.tech_age);
        
        if (age < 3 || age > 18) {
          param.error = 'Age must be 3 to 18 years.';
          return param;
        }

        let height_ft = parseFloat(request['tech_height-ft']) || 0;
        let height_in = parseFloat(request['tech_height-in']) || 0;
        let height_cm = parseFloat(request['tech_height-cm']) || 0;
        let weight = parseFloat(request.tech_weight);

        if (request.tech_unit == "lbs") {
          weight = weight / 2.205;
        }

        if (request.tech_unit_ft_in == 'ft/in') {
          height_cm = height_ft * 30.48;
          if (height_in != null) {
            height_in = height_in * 2.54;
            height_cm = height_cm + height_in;
          }
        }

        const height_m = height_cm / 100;

        let bee, tee, s, l, m, v, bmr, rmr, pa;

        if (request.tech_gender == 'obs_girl') {
          if (request.tech_activity === "Sedentary") {
            pa = 1.0;
            param.tech_stand = 'bg-gradient text-white';
          } else if (request.tech_activity == "Lightly Active") {
            pa = 1.18;
            param.tech_light = 'bg-gradient text-white';
          } else if (request.tech_activity == "Moderately Active") {
            pa = 1.35;
            param.tech_mod = 'bg-gradient text-white';
          } else {
            pa = 1.60;
            param.tech_very = 'bg-gradient text-white';
          }

          bee = Math.round((516 - (26.8 * age) + 347 * height_m + 12.4 * weight) * 100) / 100;
          tee = Math.round((389 - (41.2 * age) + pa * (15.0 * weight) + (701.6 * height_m)) * 100) / 100;
          s = Math.round((389 - (41.2 * age) + 1.0 * (15.0 * weight) + (701.6 * height_m)) * 100) / 100;
          l = Math.round((389 - (41.2 * age) + 1.18 * (15.0 * weight) + (701.6 * height_m)) * 100) / 100;
          m = Math.round((389 - (41.2 * age) + 1.35 * (15.0 * weight) + (701.6 * height_m)) * 100) / 100;
          v = Math.round((389 - (41.2 * age) + 1.60 * (15.0 * weight) + (701.6 * height_m)) * 100) / 100;
          bmr = Math.round(((9.99 * weight) + (6.25 * height_cm) - (4.92 * age) - 161) * 100) / 100;
          rmr = Math.round((655 + (9.6 * weight) + (1.8 * height_cm) - (4.7 * age)) * 100) / 100;
          console.log(tee,age,height_m,weight);
        } else {
          if (request.tech_activity == "Sedentary") {
            pa = 1.0;
            param.tech_stand = 'bg-gradient text-white';
          } else if (request.tech_activity == "Lightly Active") {
            pa = 1.12;
            param.tech_light = 'bg-gradient text-white';
          } else if (request.tech_activity == "Moderately Active") {
            pa = 1.24;
            param.tech_mod = 'bg-gradient text-white';
          } else {
            pa = 1.45;
            param.tech_very = 'bg-gradient text-white';
          }

          bee = Math.round((420 - (33.5 * age) + 418.9 * height_m + 16.7 * weight) * 100) / 100;
          tee = Math.round((114 - (50.9 * age) + pa * (19.5 * weight + 1161.4 * height_m)) * 100) / 100;
          s = Math.round((114 - (50.9 * age) + 1.0 * (19.5 * weight + 1161.4 * height_m)) * 100) / 100;
          l = Math.round((114 - (50.9 * age) + 1.12 * (19.5 * weight + 1161.4 * height_m)) * 100) / 100;
          m = Math.round((114 - (50.9 * age) + 1.24 * (19.5 * weight + 1161.4 * height_m)) * 100) / 100;
          v = Math.round((114 - (50.9 * age) + 1.45 * (19.5 * weight + 1161.4 * height_m)) * 100) / 100;
          bmr = Math.round(((9.99 * weight) + (6.25 * height_cm) - (4.92 * age) + 5) * 100) / 100;
          rmr = Math.round((66 + (13.7 * weight) + (5 * height_cm) - (6.8 * age)) * 100) / 100;
        }

        const BMI = Math.round((weight / (height_m * height_m)) * 100) / 100;

        let bmiClass;
        if (BMI <= 18.5) {
          bmiClass = 'under';
        } else if (BMI > 18.5 && BMI <= 24.9) {
          bmiClass = 'health';
        } else if (BMI > 24.9 && BMI <= 29.9) {
          bmiClass = 'over';
        } else if (BMI > 29.9 && BMI <= 35) {
          bmiClass = 'obese';
        } else if (BMI > 35) {
          bmiClass = 's_obese';
        }

        param.tech_tee = tee;
        param.tech_bee = bee;
        param.tech_bmr = bmr;
        param.tech_rmr = rmr;
        param.tech_BMI = BMI;
        param.tech_s = s;
        param.tech_l = l;
        param.tech_m = m;
        param.tech_v = v;
        param.tech_class = bmiClass;

        return param;
      } else {
        param.error = 'Please fill All fields.';
        return param;
      }
    }
  }


     /**
    * getCalculationAcftCalculator: Service Method
    * POST: /api/calculators-lol/acft-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

  
    async getCalculationAcftCalculator(body) {
          const request = body;
          const unit_type = request.tech_unit_type;
          const test_units = request.tech_test_units;
          const deadlift = request.tech_deadlift;
          const standing_power_throw = request.tech_standing_power_throw;
          const hand_release = request.tech_hand_release;
          const sprint_min = request.tech_sprint_min;
          const sprint_sec = request.tech_sprint_sec;
          const plank_min = request.tech_plank_min;
          const plank_sec = request.tech_plank_sec;
          const mile_min = request.tech_mile_min;
          const mile_sec = request.tech_mile_sec;
          const leg_tuck = request.tech_leg_tuck;

          const dead_lift_score = {
              "340": "100", "330": "97", "320": "94", "310": "92", "300": "90", 
              "290": "88", "280": "86", "270": "84", "260": "82", "250": "80",
              "240": "78", "230": "76", "220": "74", "210": "72", "200": "70",
              "190": "68", "180": "65", "170": "64", "160": "63", "150": "62",
              "140": "60", "130": "50", "120": "40", "110": "30", "100": "20",
              "90": "10", "80": "0"
          };

          const power_throw_score = {
              "12.5": "100", "12.4": "99", "12.3": "98", "12.2": "98", "12.1": "97",
              "12.0": "96", "11.9": "96", "11.8": "95", "11.7": "94", "11.6": "94",
              "11.5": "93", "11.4": "92", "11.3": "92", "11.2": "91", "11.1": "90",
              "11.0": "90", "10.9": "89", "10.8": "88", "10.7": "88", "10.6": "87",
              "10.5": "86", "10.4": "86", "10.3": "85", "10.2": "84", "10.1": "84",
              "10.0": "83", "9.9": "82", "9.8": "82", "9.7": "81", "9.6": "80",
              "9.5": "80", "9.4": "79", "9.3": "78", "9.2": "78", "9.1": "77",
              "9.0": "76", "8.9": "76", "8.8": "75", "8.7": "74", "8.6": "74",
              "8.5": "73", "8.4": "72", "8.3": "72", "8.2": "71", "8.1": "70",
              "8.0": "70", "7.9": "69", "7.8": "69", "7.7": "68", "7.6": "68",
              "7.5": "68", "7.4": "67", "7.3": "67", "7.2": "67", "7.1": "67",
              "7.0": "66", "6.9": "66", "6.8": "66", "6.7": "65", "6.6": "65",
              "6.5": "65", "6.4": "64", "6.3": "65", "6.2": "64", "6.1": "63",
              "6.0": "63", "5.9": "63", "5.8": "63", "5.7": "62", "5.6": "62",
              "5.5": "62", "5.4": "62", "5.3": "61", "5.2": "61", "5.1": "61",
              "5.0": "61", "4.9": "61", "4.8": "60", "4.7": "60", "4.5": "60",
              "4.6": "60", "4.4": "55", "4.3": "50", "4.2": "45", "4.1": "40",
              "4.0": "35", "3.9": "30", "3.8": "25", "3.7": "20", "3.6": "15",
              "3.5": "10", "3.4": "5", "3.3": "1", "3.2": "0"
          };

          const hand_release_score = {
              "60": "100", "59": "99", "58": "98", "57": "97", "56": "96", "55": "95",
              "54": "94", "53": "93", "52": "92", "51": "91", "50": "90", "49": "89",
              "48": "88", "47": "87", "46": "86", "45": "85", "44": "84", "43": "83",
              "42": "82", "41": "81", "40": "80", "39": "79", "38": "78", "37": "77",
              "36": "76", "35": "75", "34": "74", "33": "73", "32": "72", "31": "71",
              "30": "70", "29": "69", "28": "69", "27": "68", "26": "68", "25": "67",
              "24": "67", "23": "66", "22": "66", "21": "65", "20": "65", "19": "64",
              "18": "64", "17": "63", "16": "63", "15": "62", "14": "62", "13": "61",
              "12": "61", "10": "60", "9": "55", "8": "50", "7": "45", "6": "40",
              "5": "35", "4": "30", "3": "25", "2": "20", "1": "15", "0": "0"
          };

          const spring_drag_score = {
              "1:33": "100", "1.34": "99", "1:35": "99", "1.36": "99", "1.37": "99",
              "1.38": "99", "1:39": "98", "1:40": "98", "1:41": "97", "1:42": "97",
              "1:43": "96", "1:44": "96", "1:45": "95", "1:46": "94", "1:47": "93",
              "1:48": "92", "1:49": "91", "1:50": "90", "1:51": "89", "1:52": "88",
              "1:53": "87", "1:54": "86", "1:55": "85", "1:56": "84", "1:57": "83",
              "1:58": "82", "1:59": "81", "2:00": "80", "2:01": "79", "2:02": "78",
              "2:03": "77", "2:04": "76", "2:05": "75", "2:06": "74", "2:07": "73",
              "2:08": "72", "2:09": "71", "2:10": "70", "2.11": "69", "2.12": "69",
              "2.13": "69", "2:14": "69", "2:18": "68", "2.15": "68", "2.16": "68",
              "2.17": "68", "2.19": "68", "2.20": "67", "2.21": "67", "2.23": "66",
              "2.24": "66", "2.25": "66", "2.27": "65", "2.28": "65", "2.29": "65",
              "2.31": "64", "2.32": "64", "2.33": "64", "2.34": "64", "2.36": "63",
              "2.37": "63", "2.38": "63", "2.39": "63", "2.41": "62", "2.42": "62",
              "2.43": "62", "2.44": "62", "2.46": "61", "2.47": "61", "2.48": "61",
              "2.49": "61", "2:22": "67", "2:26": "66", "2:30": "65", "2:35": "64",
              "2:40": "63", "2:45": "62", "2:50": "61", "3:00": "60", "3:01": "59",
              "3:02": "58", "3:03": "57", "3:04": "56", "3:05": "55", "3:06": "54",
              "3:07": "53", "3:08": "52", "3:09": "51", "3:10": "50", "3:11": "48",
              "3:12": "46", "3:13": "44", "3:14": "42", "3:15": "40", "3:16": "38",
              "3:17": "36", "3:18": "34", "3:19": "32", "3:20": "30", "3:21": "28",
              "3:22": "26", "3:23": "24", "3:24": "22", "3:25": "20", "3:26": "18",
              "3:27": "16", "3:28": "14", "3:29": "12", "3:30": "10", "3:31": "8",
              "3:32": "6", "3:33": "4", "3:34": "2", "3:35": "0"
          };

          const leg_tuck_score = {
              "20": "100", "19": "98", "18": "96", "17": "94", "16": "92", "15": "90",
              "14": "88", "13": "86", "12": "84", "11": "82", "10": "80", "9": "78",
              "8": "76", "7": "74", "6": "72", "5": "70", "4": "68", "3": "65",
              "2": "62", "1": "60", "0": "0"
          };

          const two_miles_run = {
              "13:30": "100", "13:39": "99", "13:38": "99", "13:37": "99", "13:36": "99",
              "13:35": "99", "13:34": "99", "13:33": "99", "13:32": "99", "13.31": "99",
              "13:40": "98", "13:41": "98", "13:42": "98", "13:43": "98", "13:44": "98",
              "13.45": "98", "13.46": "98", "13.47": "98", "13:48": "98", "13:49": "97",
              "13:50": "97", "13:51": "97", "13:52": "97", "13:53": "97", "13:54": "97",
              "13:55": "97", "13:56": "97", "13:57": "97", "13:58": "96", "13:59": "96",
              "14:00": "96", "14:01": "96", "14:02": "96", "14:03": "96", "14:04": "96",
              "14:05": "96", "14:06": "96", "14:07": "95", "14:08": "95", "14:09": "95",
              "14:10": "95", "14:11": "95", "14:12": "95", "14:13": "95", "14:14": "95",
              "14:15": "95", "14:16": "94", "14:17": "94", "14:18": "94", "14:19": "94",
              "14:20": "94", "14:21": "94", "14:22": "94", "14:23": "94", "14:24": "94",
              "14:25": "93", "14:26": "93", "14:27": "93", "14:28": "93", "14:29": "93",
              "14:30": "93", "14:31": "93", "14:32": "93", "14:33": "93", "14:34": "92",
              "14:35": "92", "14:36": "92", "14:37": "92", "14:38": "92", "14:39": "92",
              "14:40": "92", "14:41": "92", "14:42": "92", "14:43": "91", "14:44": "91",
              "14:45": "91", "14:46": "91", "14:47": "91", "14:48": "91", "14:49": "91",
              "14:50": "91", "14:51": "91", "15:00": "90", "15:01": "89", "15:02": "89",
              "15:03": "89", "15:04": "89", "15:05": "89", "15:06": "89", "15:07": "89",
              "15:08": "89", "15:09": "89", "15:10": "88", "15:11": "88", "15:12": "88",
              "15:13": "88", "15:14": "88", "15:15": "88", "15:16": "88", "15:17": "88",
              "15:18": "88", "15:19": "87", "15:20": "87", "15:21": "87", "15:22": "87",
              "15:23": "87", "15:24": "87", "15:25": "87", "15:26": "87", "15:27": "87",
              "15:28": "86", "15:29": "86", "15:30": "86", "15:31": "86", "15:32": "86",
              "15:33": "86", "15:34": "86", "15:35": "86", "15:36": "86", "15:37": "85",
              "15:38": "85", "15:39": "85", "15:40": "85", "15:41": "85", "15:42": "85",
              "15:43": "85", "15:44": "85", "15:45": "85", "15:46": "84", "15:47": "84",
              "15:48": "84", "15:49": "84", "15:50": "84", "15:51": "84", "15:52": "84",
              "15.53": "84", "15:54": "84", "16:03": "83", "16:04": "82", "16:05": "82",
              "16:06": "82", "16:07": "82", "16:08": "82", "16:09": "82", "16:10": "82",
              "16:11": "82", "16:12": "82", "16:13": "81", "16:14": "81", "16:15": "81",
              "16:16": "81", "16:17": "81", "16:18": "81", "16:19": "81", "16:20": "81",
              "16:21": "81", "16:22": "80", "16:23": "80", "16:24": "80", "16:25": "80",
              "16:26": "80", "16:27": "80", "16:28": "80", "16:29": "80", "16:30": "80",
              "16:31": "79", "16:32": "79", "16:33": "79", "16:34": "79", "16:35": "79",
              "16:36": "79", "16:37": "79", "16:38": "79", "16:39": "79", "16:40": "78",
              "16:41": "78", "16:42": "78", "16:43": "78", "16:44": "78", "16:45": "78",
              "16:46": "78", "16:47": "78", "16:48": "78", "16:49": "77", "16:50": "77",
              "16:51": "77", "16:52": "77", "16:53": "77", "16:54": "77", "16:55": "77",
              "16:56": "77", "16:57": "77", "17:06": "76", "17:07": "75", "17:08": "75",
              "17:09": "75", "17:10": "75", "17:11": "75", "17:12": "75", "17:13": "75",
              "17:14": "75", "17:15": "75", "17:16": "74", "17:17": "74", "17:18": "74",
              "17:19": "74", "17:20": "74", "17:21": "74", "17:22": "74", "17:23": "74",
              "17:24": "74", "17:25": "73", "17:26": "73", "17:27": "73", "17:28": "73",
              "17:29": "73", "17:30": "73", "17:31": "73", "17:32": "73", "17:33": "73",
              "17:34": "72", "17:35": "72", "17:36": "72", "17:37": "72", "17:38": "72",
              "17:39": "72", "17:40": "72", "17:41": "72", "17:42": "72", "17:43": "71",
              "17:44": "71", "17:45": "71", "17:46": "71", "17:47": "71", "17:48": "71",
              "17:49": "71", "17:50": "71", "17:51": "71", "18:00": "69", "18:01": "69",
              "18:02": "69", "18:03": "69", "18:04": "69", "18:05": "69", "18:06": "69",
              "18:07": "69", "18:08": "69", "18:09": "69", "18:10": "69", "18:11": "69",
              "18:12": "69", "18:13": "68", "18:14": "68", "18:15": "68", "18:16": "68",
              "18:17": "68", "18:18": "68", "18:19": "68", "18:20": "68", "18:21": "68",
              "18:22": "68", "18:23": "68", "18:24": "68", "18:25": "67", "18:26": "67",
              "18:27": "67", "18:28": "67", "18:29": "67", "18:30": "67", "18:31": "67",
              "18:32": "67", "18:33": "67", "18:34": "67", "18:35": "67", "18:36": "67",
              "18:37": "66", "18:38": "66", "18:39": "66", "18:40": "66", "18:41": "66",
              "18:42": "66", "18:43": "66", "18:44": "66", "18:45": "66", "18:46": "66",
              "18:47": "66", "18:48": "66", "19:00": "65", "19:01": "64", "19:02": "64",
              "19:03": "64", "19:04": "64", "19:05": "64", "19:06": "64", "19:07": "64",
              "19:08": "64", "19:09": "64", "19:10": "64", "19:11": "64", "19:12": "64",
              "19:13": "64", "19:14": "64", "19:15": "64", "19:16": "64", "19:17": "64",
              "19:18": "64", "19:19": "64", "19:20": "64", "19:21": "64", "19:22": "64",
              "19:23": "64", "19:24": "64", "19:24": "64", "19:25": "63", "19:26": "63",
              "19:27": "63", "19:28": "63", "19:29": "63", "19:30": "63", "19:31": "63",
              "19:32": "63", "19:33": "63", "19:34": "63", "19:35": "63", "19:36": "63",
              "1937": "63", "19:38": "63", "19:39": "63", "19:40": "63", "19:41": "63",
              "19:42": "63", "19:43": "63", "19:44": "63", "19:45": "63", "19:46": "63",
              "19:47": "63", "19:48": "63", "20:12": "62", "20:13": "61", "20:14": "61",
              "20:15": "61", "20:16": "61", "20:17": "61", "20:18": "61", "20:19": "61",
              "20:20": "61", "20:21": "61", "20:22": "61", "20:23": "61", "20:24": "61",
              "20:25": "61", "20:26": "61", "20:27": "61", "20:28": "61", "20:29": "61",
              "20:30": "61", "20:31": "61", "20:32": "61", "20:33": "61", "20:34": "61",
              "20:35": "61", "20:36": "61", "21:00": "60", "21:01": "59", "21:02": "58",
              "21:03": "58", "21:04": "57", "21:05": "57", "21:06": "56", "21:07": "56",
              "21:08": "55", "21:09": "55", "21:10": "54", "21:11": "53", "21:12": "53",
              "21:13": "52", "21:14": "52", "21:15": "51", "21:16": "51", "21:17": "50",
              "21:18": "50", "21:19": "48", "21:20": "48", "21:21": "48", "21:22": "47",
              "21:23": "47", "21:24": "46", "21:25": "46", "21:26": "45", "21:27": "45",
              "21:28": "44", "21:29": "43", "21:30": "43", "21:31": "42", "21:32": "42",
              "21:33": "41", "21:34": "41", "21:35": "40", "21:36": "40", "21:37": "39",
              "21:38": "38", "21:39": "38", "21:40": "37", "21:41": "37", "21:42": "36",
              "21:43": "36", "21:44": "35", "21:45": "35", "21:46": "34", "21:47": "33",
              "22:48": "33", "21:49": "32", "21:50": "32", "21:51": "31", "21:52": "31",
              "21:53": "30", "21:54": "30", "21:55": "29", "21:56": "28", "21:57": "28",
              "21:58": "27", "21:59": "27", "22:01": "26", "22:02": "25", "22:03": "25",
              "22:04": "24", "22:05": "23", "22:06": "23", "22:07": "22", "22:08": "22",
              "22:09": "21", "22:10": "21", "22:11": "20", "22:12": "20", "22:13": "19",
              "22:14": "18", "22:15": "18", "22:16": "17", "22:17": "17", "22:18": "16",
              "22:19": "16", "22:20": "15", "22:21": "15", "22:22": "14", "22:23": "13",
              "22:24": "13", "22:25": "12", "22:26": "12", "22:27": "11", "22:28": "11",
              "22:29": "10", "22:30": "10", "22:31": "9", "22:32": "8", "22:33": "8",
              "22:34": "7", "22:35": "7", "22:36": "6", "22:37": "6", "22:38": "5",
              "22:39": "5", "22:40": "4", "22:41": "3", "22:42": "3", "22:43": "2",
              "22:44": "2", "22:45": "1", "22:46": "1", "22:47": "0", "22:48": "0"
          };

          const plunk = {
              "2:03": "58", "2:04": "58", "2:05": "58", "2:06": "59", "2:07": "59",
              "2:08": "59", "2:09": "60", "2:10": "60", "2:11": "60", "2:12": "61",
              "2:13": "61", "2:14": "61", "2:15": "62", "2:16": "62", "2:17": "62",
              "2:18": "63", "2:19": "63", "2:20": "63", "2:21": "64", "2:22": "64",
              "2:23": "64", "2:24": "65", "2:25": "65", "2:26": "65", "2:27": "66",
              "2:28": "66", "2:29": "66", "2:30": "67", "2:31": "67", "2:32": "67",
              "2:33": "68", "2:34": "68", "2:35": "68", "2:36": "69", "2:37": "69",
              "2:38": "69", "2:39": "69", "2:40": "70", "2:41": "70", "2:42": "70",
              "2:43": "71", "2:44": "71", "2:45": "71", "2:46": "72", "2:47": "72",
              "2:48": "72", "2:49": "72", "2:50": "73", "2:51": "73", "2:52": "73",
              "2:53": "74", "2:54": "74", "2:55": "74", "2:56": "75", "2:57": "75",
              "2:58": "75", "3:02": "76", "3:03": "76", "3:04": "76", "3:05": "77",
              "3:06": "77", "3:07": "77", "3:08": "78", "3:09": "78", "3:10": "78",
              "3:11": "78", "3:12": "79", "3:13": "79", "3:14": "79", "3:15": "80",
              "3:16": "80", "3:17": "80", "3:18": "81", "3:19": "81", "3:20": "81",
              "3:21": "82", "3:22": "82", "3:23": "82", "3:24": "82", "3:25": "83",
              "3:26": "83", "3:27": "83", "3:28": "84", "3:29": "84", "3:30": "84",
              "3:31": "85", "3:32": "85", "3:33": "85", "3:34": "85", "3:35": "86",
              "3:36": "86", "3:37": "86", "3:38": "87", "3:39": "87", "3:40": "87",
              "3:41": "88", "3:42": "88", "3:43": "88", "3:44": "89", "3:45": "89",
              "3:46": "89", "3:47": "89", "3:48": "90", "3:49": "90", "3:50": "90",
              "3:51": "91", "3:52": "91", "3:53": "91", "3:54": "92", "3:55": "92",
              "3:56": "92", "3:57": "92", "3:58": "93", "3:59": "93", "4:0": "93",
              "4:1": "94", "4:2": "94", "4:3": "94", "4:4": "95", "4:5": "95",
              "4:6": "95", "4:7": "96", "4:8": "96", "4:9": "96", "4:10": "96",
              "4:11": "97", "4:12": "97", "4:13": "97", "4:14": "98", "4:15": "98",
              "4:16": "98", "4:17": "99", "4:18": "99", "4:19": "99", "4:20": "100"
          };

          const param = {};

          // Unit type configuration
          if (unit_type == "1") { // Heavy
              param.tech_min_score = 70;
              param.tech_mdl_value = 200;
              param.tech_spt_value = 8.0;
              param.tech_hrp_value = 30;
              param.tech_sdc_value = "2:10";
              param.tech_ltk_value = 5;
              param.tech_plk_value = "2:42";
              param.tech_two_miles_value = "18:00";
          } else if (unit_type == "2") { // Significant
              param.tech_min_score = 65;
              param.tech_mdl_value = 180;
              param.tech_spt_value = 6.5;
              param.tech_hrp_value = 20;
              param.tech_sdc_value = "2:30";
              param.tech_ltk_value = 3;
              param.tech_plk_value = "2:26";
              param.tech_two_miles_value = "19:00";
          } else if (unit_type == "3") { // Moderate
              param.tech_min_score = 60;
              param.tech_mdl_value = 140;
              param.tech_spt_value = 4.5;
              param.tech_hrp_value = 10;
              param.tech_sdc_value = "3:00";
              param.tech_ltk_value = 1;
              param.tech_plk_value = "2:09";
              param.tech_two_miles_value = "21:00";
          }

          // Test units processing - PLANK VALIDATION FIRST
          if (test_units == "2") {
              if (isNumeric(plank_min) && isNumeric(plank_sec)) {
                  const combine_plank = `${plank_min}:${plank_sec}`;
                  
                  // YAHI CHANGE KIYA HAI - sirf yeh error return karo
                  if (compareTimes(combine_plank, "4:00") > 0) {
                      return {
                          error: "Plank Time cannot be more than 4:00."
                      };
                  }
              }
          }

          // Baaki ka code continue karo...
          if (test_units == "1") {
              if (isNumeric(leg_tuck)) {
                  // 7-Leg Tuck
                  if (leg_tuck < 0) {
                      param.error = 'Leg Tuck Reps cannot be less than 0.';
                      return param;
                  } else if (leg_tuck > 20) {
                      param.error = 'Leg Tuck Reps cannot be more than 20.';
                      return param;
                  } else {
                      let leg_tuck_answer = leg_tuck_score[leg_tuck.toString()];
                      param.tech_leg_tuck_answer = leg_tuck_answer;
                  }
              } else {
                  param.error = 'Please! Check Your Input.';
                  return param;
              }
          } else if (test_units == "2") {
              if (isNumeric(plank_min) && isNumeric(plank_sec)) {
                  // 6-Plank Min
                  const combine_plank = `${plank_min}:${plank_sec}`;
                  
                  if (compareTimes(combine_plank, "2:03") < 0) {
                      param.error = 'Plank Time cannot be less than 2:03.';
                      return param;
                  } else if (compareTimes(combine_plank, "2:59") >= 0 && compareTimes(combine_plank, "3:01") <= 0) {
                      param.tech_plank_answer = 75;
                  } else if (compareTimes(combine_plank, "3:59") >= 0 && compareTimes(combine_plank, "4:00") <= 0) {
                      param.tech_plank_answer = 93;
                  } else {
                      param.plank_answer = plunk[combine_plank];
                  }
              } else {
                  param.error = 'Please! Check Your Input.';
                  return param;
              }
          }

          // Main calculations
          if (isNumeric(deadlift) && isNumeric(standing_power_throw) && isNumeric(hand_release) && 
              isNumeric(sprint_min) && isNumeric(sprint_sec)) {
              
              let dead_lift_answer, power_throw_score_answer, hand_release_score_answer, sst, two_mile_answer;

              // 1-DeadLift Validation and Calculation
              if (deadlift < 80) {
                  param.error = 'DeadLift pounds cannot be less than 80.';
                  return param;
              } else if (deadlift > 340) {
                  param.error = 'DeadLift pounds cannot be more than 340.';
                  return param;
              } else {
                  dead_lift_answer = dead_lift_score[deadlift.toString()];
              }

              // 2-Power Throw Score
              if (standing_power_throw > 12.5) {
                  param.error = 'Standing Power Throw meters cannot be greater than 12.5.';
                  return param;
              } else if (standing_power_throw < 3.2) {
                  param.error = 'Standing Power Throw meters cannot be less than 3.2.';
                  return param;
              } else {
                  power_throw_score_answer = power_throw_score[standing_power_throw.toString()];
              }

              // 3-Hand-release push-up
              if (hand_release > 60) {
                  param.error = 'Hand Release Push Up cannot be greater than 60.';
                  return param;
              } else if (hand_release < 0) {
                  param.error = 'Hand Release Push Up cannot be less than 0.';
                  return param;
              } else {
                  hand_release_score_answer = hand_release_score[hand_release.toString()];
              }

              // 4-Sprint Drag and Carry
              const spring_drag_score_value = `${sprint_min}:${sprint_sec}`;
              if (compareTimes(spring_drag_score_value, "3:35") > 0) {
                  param.error = 'Spring Drag and Carry Time cannot be greater than 3:35.';
                  return param;
              } else if (compareTimes(spring_drag_score_value, "1:33") < 0) {
                  param.error = 'Spring Drag and Carry Time cannot be less than 1:33.';
                  return param;
              } else if (compareTimes(spring_drag_score_value, "1:60") >= 0 && compareTimes(spring_drag_score_value, "1:99") <= 0) {
                  sst = 80;
              } else if (compareTimes(spring_drag_score_value, "2:51") >= 0 && compareTimes(spring_drag_score_value, "2:99") <= 0) {
                  sst = 60;
              } else {
                  sst = spring_drag_score[spring_drag_score_value];
              }

              // 5-Two Mile Run
              const combine_mile_value = `${mile_min}:${mile_sec}`;
              if (compareTimes(combine_mile_value, "13:30") < 0) {
                  param.error = 'Two Mile Run Time cannot be less than 13:30.';
                  return param;
              } else if (compareTimes(combine_mile_value, "22:48") > 0) {
                  param.error = 'Two Mile Run Time cannot be greater than 22:48.';
                  return param;
              } else if (compareTimes(combine_mile_value, "13:60") >= 0 && compareTimes(combine_mile_value, "13:99") <= 0) {
                  two_mile_answer = 96;
              } else if (compareTimes(combine_mile_value, "14:52") >= 0 && compareTimes(combine_mile_value, "14:99") <= 0) {
                  two_mile_answer = 90;
              } else if (compareTimes(combine_mile_value, "15:55") >= 0 && compareTimes(combine_mile_value, "16:02") <= 0) {
                  two_mile_answer = 83;
              } else if (compareTimes(combine_mile_value, "16:58") >= 0 && compareTimes(combine_mile_value, "17:05") <= 0) {
                  two_mile_answer = 76;
              } else if (compareTimes(combine_mile_value, "17:52") >= 0 && compareTimes(combine_mile_value, "17:99") <= 0) {
                  two_mile_answer = 70;
              } else if (compareTimes(combine_mile_value, "18:49") >= 0 && compareTimes(combine_mile_value, "18:99") <= 0) {
                  two_mile_answer = 65;
              } else if (compareTimes(combine_mile_value, "19:49") >= 0 && compareTimes(combine_mile_value, "20:11") <= 0) {
                  two_mile_answer = 62;
              } else if (compareTimes(combine_mile_value, "20:37") >= 0 && compareTimes(combine_mile_value, "20:99") <= 0) {
                  two_mile_answer = 60;
              } else if (compareTimes(combine_mile_value, "21:60") >= 0 && compareTimes(combine_mile_value, "22:00") <= 0) {
                  two_mile_answer = 26;
              } else {
                  two_mile_answer = two_miles_run[combine_mile_value];
              }

              param.tech_dead_lift_score = dead_lift_answer;
              param.tech_power_throw_score_answer = power_throw_score_answer;
              param.tech_two_miles_run_values = two_mile_answer;
              param.tech_spring_drag_score_answer = sst;
              param.tech_hand_release_answer = hand_release_score_answer;
              param.tech_request = request;
              
          } else {
              param.error = 'Please! Check Your Input.';
              return param;
          }

          return param;
          
          // Helper functions
          function isNumeric(value) {
              return !isNaN(parseFloat(value)) && isFinite(value);
          }
          
          function compareTimes(time1, time2) {
              const [min1, sec1] = time1.split(':').map(Number);
              const [min2, sec2] = time2.split(':').map(Number);
              
              const total1 = min1 * 60 + sec1;
              const total2 = min2 * 60 + sec2;
              
              if (total1 < total2) return -1;
              if (total1 > total2) return 1;
              return 0;
          }
      }
    
         /**
    * getCalculationCarboplatinCalculator: Service Method
    * POST: /api/calculators-lol/carboplatin-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

  
   async getCalculationCarboplatinCalculator(body) {
        const request = body;
        
        const type = request.tech_type;
        const operations = request.tech_operations;
        const first = parseFloat(request.tech_first);
        const second = parseFloat(request.tech_second);
        const s_units = request.tech_s_units;
        const third = parseFloat(request.tech_third);
        const t_units = request.tech_t_units;
        const four = parseFloat(request.tech_four);
        const five = parseFloat(request.tech_five);
        const f_units = request.tech_f_units;

        let s_units_val = 1;
        if (s_units == 'kg') {
            s_units_val = 1;
        } else if (s_units == 'lbs') {
            s_units_val = 2;
        } else if (s_units == 'stone') {
            s_units_val = 3;
        }

        let t_units_val = 1;
        if (t_units == 'mg/dL') {
            t_units_val = 1;
        } else if (t_units == 'μmol/L') {
            t_units_val = 2;
        }

        let f_units_val = 1;
        if (f_units == 'in') {
            f_units_val = 1;
        } else if (f_units == 'cm') {
            f_units_val = 2;
        }

        // Helper functions
        function baby(a, b) {
            if (a == "1") {
                return b * 1;
            } else if (a == "2") {
                return b * 0.011312;
            }
            return b;
        }

        function baby2(a, b) {
            if (a == "1") {
                return b * 88.4;
            } else if (a == "2") {
                return b * 1;
            }
            return b;
        }

        function wazan(a, b) {
            if (a == "1") {
                return b * 1;
            } else if (a == "2") {
                return b * 0.4536;
            } else if (a == "3") {
                return b * 6.35;
            }
            return b;
        }

        function kad(a, b) {
            if (a == "1") {
                return b * 2.54;
            } else if (a == "2") {
                return b * 1;
            }
            return b;
        }

        function kad2(a, b) {
            if (a == "1") {
                return b * 1;
            } else if (a == "2") {
                return b / 2.54;
            }
            return b;
        }

        const five2 = five;
        const f_units2 = f_units_val;
        const third2 = third;
        const t_units2 = t_units_val;
        
        const third_converted = baby(t_units_val.toString(), third);
        const second_converted = wazan(s_units_val.toString(), second);
        const five_converted = kad(f_units_val.toString(), five);
        const five2_converted = kad2(f_units2.toString(), five2);
        const third2_converted = baby2(t_units2.toString(), third2);

        const param = {};

        if (type == "first") {
            if (first >= 18) {
                const batien = 140 - first;
                const divi = 72 * third_converted;
                const dosra = second_converted / divi;
                const grf = batien * dosra;
                
                let answer;
                if (operations == "1") {
                    answer = grf;
                } else if (operations == "2") {
                    answer = 0.85 * grf;
                }
                
                const max_dos = four * 150;
                const car_dos = four * (answer + 25);

                param.tech_answer = answer;
                param.tech_max_dos = max_dos;
                param.tech_car_dos = car_dos;
            } else {
                param.error = 'This calculator should not be used in patients <18 years old.';
                return param;
            }
        } else if (type == "second") {
            if (first >= 18) {
                if (!isNaN(second) && !isNaN(third) && !isNaN(five)) {
                    const second_pow = Math.pow(second_converted, 0.425);
                    const five_pow = Math.pow(five_converted, 0.725);
                    const bsa = 0.007184 * second_pow * five_pow;

                    if (operations == 1) {
                        // Male calculations
                        const minus = five2_converted - 60;
                        const multi = 2.3 * minus;
                        const ibw = 50 + multi;
                        
                        // abw and abw alt answer
                        const minus2 = second_converted - ibw;
                        const multi2 = 0.4 * minus2;
                        const abw = ibw + multi2;
                        const multi3 = 0.3 * minus2;
                        const abw_alt = ibw + multi3;
                        
                        // jellife first (ml/min)
                        const minus1 = first - 20;
                        const mul1 = 0.8 * minus1;
                        const minus11 = 98 - mul1;
                        const jell_ans1 = minus11 / third_converted;
                        const jell_ans11 = (jell_ans1 + 25) * four;

                        // jellife second (ml/min)
                        const bsa_div = bsa / 1.73;
                        const up_sol = minus11 * bsa_div;
                        const div_sol = third2_converted * 0.0113;
                        const jell_ans2 = up_sol / div_sol;
                        const jell_ans22 = (jell_ans2 + 25) * four;

                        // Cockcroft & Gault actual body weight (ml/min)
                        const cg_minus = 140 - 22;
                        const cgup_mul = second_converted * cg_minus;
                        const cglo_mul = 72 * third_converted;
                        const cg_ac_ans = cgup_mul / cglo_mul;
                        const cg_ac_ans2 = (cg_ac_ans + 25) * four;

                        // Cockcroft & Gault ideal body weight (ml/min)
                        const cgup_mul1 = ibw * cg_minus;
                        const cg_ibw_ans = cgup_mul1 / cglo_mul;
                        const cg_ibw_ans2 = (cg_ibw_ans + 25) * four;

                        // Cockcroft & Gault adjusted body weight (ml/min)
                        const cgup_mul2 = abw * cg_minus;
                        const cg_abw_ans = cgup_mul2 / cglo_mul;
                        const cg_abw_ans2 = (cg_abw_ans + 25) * four;

                        // Cockcroft & Gault adjusted body weight alt (ml/min)
                        const cgup_mul3 = abw_alt * cg_minus;
                        const cg_abwalt_ans = cgup_mul3 / cglo_mul;
                        const cg_abwalt_ans2 = (cg_abwalt_ans + 25) * four;

                        // Store results
                        param.tech_bsa = Number(bsa.toFixed(2));
                        param.tech_ibw = ibw;
                        param.tech_abw = abw;
                        param.tech_abw_alt = abw_alt;
                        param.tech_jell_ans1 = jell_ans1;
                        param.tech_jell_ans2 = jell_ans2;
                        param.tech_cg_ac_ans = cg_ac_ans;
                        param.tech_cg_ibw_ans = cg_ibw_ans;
                        param.tech_cg_abw_ans = cg_abw_ans;
                        param.tech_cg_abwalt_ans = cg_abwalt_ans;
                        param.tech_jell_ans11 = jell_ans11;
                        param.tech_jell_ans22 = jell_ans22;
                        param.tech_cg_ac_ans2 = cg_ac_ans2;
                        param.tech_cg_ibw_ans2 = cg_ibw_ans2;
                        param.tech_cg_abw_ans2 = cg_abw_ans2;
                        param.tech_cg_abwalt_ans2 = cg_abwalt_ans2;

                    } else if (operations == 2) {
                        // Female calculations
                        const minus = five2_converted - 60;
                        const multi = 2.3 * minus;
                        const ibw = 45.5 + multi;
                        
                        // abw and abw alt answer
                        const minus2 = second_converted - ibw;
                        const multi2 = 0.4 * minus2;
                        const abw = ibw + multi2;
                        const multi3 = 0.3 * minus2;
                        const abw_alt = ibw + multi3;
                        
                        // jellife first (ml/min)
                        const minus1 = first - 20;
                        const mul1 = 0.8 * minus1;
                        const minus11 = 98 - mul1;
                        const female_jell = minus11 / third_converted;
                        const jell_ans1 = female_jell * 0.9;
                        const jell_ans11 = (jell_ans1 + 25) * four;

                        // jellife second (ml/min)
                        const bsa_div = bsa / 1.73;
                        const up_sol = minus11 * bsa_div * 0.9;
                        const div_sol = third2_converted * 0.0113;
                        const jell_ans2 = up_sol / div_sol;
                        const jell_ans22 = (jell_ans2 + 25) * four;

                        // Cockcroft & Gault actual body weight (ml/min)
                        const cg_minus = 140 - 22;
                        const cgup_mul = second_converted * cg_minus;
                        const cglo_mul = 72 * third_converted;
                        const cg_female = cgup_mul / cglo_mul;
                        const cg_ac_ans = cg_female * 0.85;
                        const cg_ac_ans2 = (cg_ac_ans + 25) * four;

                        // Cockcroft & Gault ideal body weight (ml/min)
                        const cgup_mul1 = ibw * cg_minus;
                        const cg_ibw_fe = cgup_mul1 / cglo_mul;
                        const cg_ibw_ans = cg_ibw_fe * 0.85;
                        const cg_ibw_ans2 = (cg_ibw_ans + 25) * four;

                        // Cockcroft & Gault adjusted body weight (ml/min)
                        const cgup_mul2 = abw * cg_minus;
                        const cg_abw_fe = cgup_mul2 / cglo_mul;
                        const cg_abw_ans = cg_abw_fe * 0.85;
                        const cg_abw_ans2 = (cg_abw_ans + 25) * four;

                        // Cockcroft & Gault adjusted body weight alt (ml/min)
                        const cgup_mul3 = abw_alt * cg_minus;
                        const cg_abwalt_fe = cgup_mul3 / cglo_mul;
                        const cg_abwalt_ans = cg_abwalt_fe * 0.85;
                        const cg_abwalt_ans2 = (cg_abwalt_ans + 25) * four;

                        // Store results
                        param.tech_bsa = Number(bsa.toFixed(2));
                        param.tech_ibw = ibw;
                        param.tech_abw = abw;
                        param.tech_abw_alt = abw_alt;
                        param.tech_jell_ans1 = jell_ans1;
                        param.tech_jell_ans2 = jell_ans2;
                        param.tech_cg_ac_ans = cg_ac_ans;
                        param.tech_cg_ibw_ans = cg_ibw_ans;
                        param.tech_cg_abw_ans = cg_abw_ans;
                        param.tech_cg_abwalt_ans = cg_abwalt_ans;
                        param.tech_jell_ans11 = jell_ans11;
                        param.tech_jell_ans22 = jell_ans22;
                        param.tech_cg_ac_ans2 = cg_ac_ans2;
                        param.tech_cg_ibw_ans2 = cg_ibw_ans2;
                        param.tech_cg_abw_ans2 = cg_abw_ans2;
                        param.tech_cg_abwalt_ans2 = cg_abwalt_ans2;
                    }
                } else {
                    param.error = 'Please check your input.';
                    return param;
                }
            } else {
                param.error = 'This calculator should not be used in patients <18 years old.';
                return param;
            }
        }

        param.tech_request = request;
        return param;
    }

           /**
    * getCalculationVo2MaxCalculator: Service Method
    * POST: /api/calculators-lol/vo2-max-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

     async getCalculationVo2MaxCalculator(body) {
        const request = body;
        const methods = request.tech_methods;
        const operations1 = request.tech_operations1;
        const operations2 = request.tech_operations2;
        const first = parseFloat(request.tech_first);
        var second = parseFloat(request.tech_second);
        const units2 = request.tech_units2;
        var third = parseFloat(request.tech_third);
        const units3 = request.tech_units3;
        const four = parseFloat(request.tech_four);
        let wazan;
        let units2_val = 1;
        if (units2 == 'kg') {
            units2_val = 1;
        } else if (units2 == 'lbs') {
            units2_val = 2;
        }

        let units3_val = 1;
        if (units3 == 'sec') {
            units3_val = 1;
        } else if (units3 == 'min') {
            units3_val = 2;
        }

        // Helper functions
          function kilo(a,b){
        if(a == "1"){
          wazan = b * 2.205;
          //  console.log(a,b,wazan);
        }else if (a == "2") {
          wazan = b * 1;
        }
        return wazan;
        }


        function secint(a, b) {
            if (a == "1") {
                return b / 60;
            } else if (a == "2") {
                return b * 1;
            }
            return b;
        }

       var  second = kilo(units2_val.toString(), second);
        var third = secint(units3_val.toString(), third);

        const param = {};
        let answer;

        if (methods == "1") {
            if (!isNaN(first) && !isNaN(four)) {
                const mul1 = 0.7 * first;
                const mhr = 208 - mul1;
                const rhr = four * 3;
                const divide = mhr / rhr;
                answer = 15.3 * divide;
            } else {
                param.error = 'Please! Check Your Input.';
                return param;
            }
        } else if (methods == "2") {
            if (!isNaN(first) && !isNaN(second) && !isNaN(third) && !isNaN(four)) {
                if (operations1 == 1) {
                    answer = 132.853 - (0.0769 * second) - (0.3877 * first) + (6.315 * 1) - (3.2649 * third) - (0.1565 * four * 6);
                } else if (operations1 == 0) {
                    answer = 132.853 - (0.0769 * second) - (0.3877 * first) - (3.2649 * third) - (0.1565 * four * 6);
                }
            } else {
                param.error = 'Please! Check Your Input.';
                return param;
            }
        } else if (methods == "3") {
            if (!isNaN(four)) {
                if (operations1 == 1) {
                    answer = 111.33 - (0.42 * four * 4);
                } else if (operations1 == 0) {
                    answer = 65.81 - (0.1847 * four * 4);
                }
            } else {
                param.error = 'Please! Check Your Input.';
                return param;
            }
        } else if (methods == "4") {
            if (!isNaN(third)) {
                answer = (483 / third) + 3.5;
            } else {
                param.error = 'Please! Check Your Input.';
                return param;
            }
        } else if (methods == "5") {
            if (!isNaN(second) && !isNaN(third)) {
              var second = second * 0.45359237; // lb -> kg
                if (operations1 == 1) {
                    if (operations2 == 2) {
                        if (second <= 75.0) {
                            answer = ((15.1 - (1.5 * third)) * 1000) / second;
                        } else if (second > 75.0) {
                            answer = ((15.7 - (1.5 * third)) * 1000) / second;
                        }
                    } else if (operations2 == 1) {
                        answer = ((10.7 - (0.9 * third)) * 1000) / second;
                    }
                } else if (operations1 == 0) {
                    if (operations2 == 2) {
                        if (second <= 61.36) {
                            answer = ((14.6 - (1.5 * third)) * 1000) / second;
                        } else if (second > 61.36) {
                            answer = ((14.9 - (1.5 * third)) * 1000) / second;
                        }
                    } else if (operations2 == 1) {
                        answer = ((10.26 - (0.93 * third)) * 1000) / second;
                    }
                }
            } else {
                param.error = 'Please! Check Your Input.';
                return param;
            }
        }

        param.tech_answer = answer;
        return param;
    }
  
       /**
    * getCalculationWeightPercentileCalculator: Service Method
    * POST: /api/calculators-lol/weight-percentile-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationWeightPercentileCalculator(body) {

        const weight = body.tech_weight;
        const w_unit = body.tech_w_unit;
        const age = body.tech_age;
        const age_unit = body.tech_age_unit;
        const gender = body.tech_gender;

          function wazan(a, b) {
              if (a == "g") {
                  return b / 1000;
              } else if (a == "dag") {
                  return b / 100;
              } else if (a == "kg") {
                  return b * 1;
              } else if (a == "oz") {
                  return b / 35.274;
              } else if (a == "lbs") {
                  return b / 2.205;
              }
              return b;
          }

          function umar(a, b) {
              if (a == "days") {
                  return b / 365;
              } else if (a == "weeks") {
                  return b / 52.143;
              } else if (a == "months") {
                  return b / 12;
              } else if (a == "years") {
                  return b * 1;
              }
              return b;
          }

          const girls_to_13w = [
              { "name": "a", "uid": "2101522777", "values": { "age": 0, "P01": 2, "P1": "2.3", "P3": "2.4", "P5": "2.5", "P10": "2.7", "P15": "2.8", "P25": "2.9", "P50": "3.2", "P75": "3.6", "P85": "3.7", "P90": "3.9", "P95": 4, "P97": "4.2", "P99": "4.4", "P999": "4.8" } },
              { "name": 1, "uid": "1344046595", "values": { "age": 1, "P01": "2.1", "P1": "2.3", "P3": "2.5", "P5": "2.6", "P10": "2.8", "P15": "2.9", "P25": 3, "P50": "3.3", "P75": "3.7", "P85": "3.9", "P90": 4, "P95": "4.2", "P97": "4.4", "P99": "4.6", "P999": "5.1" } },
              { "name": 2, "uid": "3902805028", "values": { "age": 2, "P01": "2.2", "P1": "2.5", "P3": "2.7", "P5": "2.8", "P10": 3, "P15": "3.1", "P25": "3.2", "P50": "3.6", "P75": "3.9", "P85": "4.1", "P90": "4.3", "P95": "4.5", "P97": "4.6", "P99": "4.9", "P999": "5.4" } },
              { "name": 3, "uid": "3908778857", "values": { "age": 3, "P01": "2.4", "P1": "2.7", "P3": "2.9", "P5": 3, "P10": "3.2", "P15": "3.3", "P25": "3.5", "P50": "3.8", "P75": "4.2", "P85": "4.4", "P90": "4.6", "P95": "4.8", "P97": 5, "P99": "5.3", "P999": "5.8" } },
              { "name": 4, "uid": "2653126873", "values": { "age": 4, "P01": "2.6", "P1": "2.9", "P3": "3.1", "P5": "3.3", "P10": "3.4", "P15": "3.5", "P25": "3.7", "P50": "4.1", "P75": "4.5", "P85": "4.7", "P90": "4.9", "P95": "5.1", "P97": "5.3", "P99": "5.6", "P999": "6.2" } },
              { "name": 5, "uid": "543034340", "values": { "age": 5, "P01": "2.8", "P1": "3.1", "P3": "3.3", "P5": "3.5", "P10": "3.6", "P15": "3.8", "P25": 4, "P50": "4.3", "P75": "4.8", "P85": 5, "P90": "5.2", "P95": "5.4", "P97": "5.6", "P99": "5.9", "P999": "6.5" } },
              { "name": 6, "uid": "986480501", "values": { "age": 6, "P01": 3, "P1": "3.3", "P3": "3.5", "P5": "3.7", "P10": "3.8", "P15": 4, "P25": "4.2", "P50": "4.6", "P75": 5, "P85": "5.3", "P90": "5.4", "P95": "5.7", "P97": "5.9", "P99": "6.2", "P999": "6.8" } },
              { "name": 7, "uid": "481225376", "values": { "age": 7, "P01": "3.2", "P1": "3.5", "P3": "3.7", "P5": "3.8", "P10": 4, "P15": "4.2", "P25": "4.4", "P50": "4.8", "P75": "5.2", "P85": "5.5", "P90": "5.7", "P95": "5.9", "P97": "6.1", "P99": "6.5", "P999": "7.1" } },
              { "name": 8, "uid": "2437632715", "values": { "age": 8, "P01": "3.3", "P1": "3.7", "P3": "3.9", "P5": 4, "P10": "4.2", "P15": "4.4", "P25": "4.6", "P50": 5, "P75": "5.5", "P85": "5.7", "P90": "5.9", "P95": "6.2", "P97": "6.4", "P99": "6.7", "P999": "7.4" } },
              { "name": 9, "uid": "253589758", "values": { "age": 9, "P01": "3.4", "P1": "3.8", "P3": "4.1", "P5": "4.2", "P10": "4.4", "P15": "4.5", "P25": "4.7", "P50": "5.2", "P75": "5.7", "P85": "5.9", "P90": "6.1", "P95": "6.4", "P97": "6.6", "P99": 7, "P999": "7.7" } },
              { "name": 10, "uid": "4090155017", "values": { "age": 10, "P01": "3.6", "P1": 4, "P3": "4.2", "P5": "4.3", "P10": "4.5", "P15": "4.7", "P25": "4.9", "P50": "5.4", "P75": "5.8", "P85": "6.1", "P90": "6.3", "P95": "6.6", "P97": "6.8", "P99": "7.2", "P999": "7.9" } },
              { "name": 11, "uid": "2979536176", "values": { "age": 11, "P01": "3.7", "P1": "4.1", "P3": "4.3", "P5": "4.5", "P10": "4.7", "P15": "4.8", "P25": "5.1", "P50": "5.5", "P75": 6, "P85": "6.3", "P90": "6.5", "P95": "6.8", "P97": 7, "P99": "7.4", "P999": "8.2" } },
              { "name": 12, "uid": "565790788", "values": { "age": 12, "P01": "3.8", "P1": "4.2", "P3": "4.5", "P5": "4.6", "P10": "4.8", "P15": 5, "P25": "5.2", "P50": "5.7", "P75": "6.2", "P85": "6.5", "P90": "6.7", "P95": 7, "P97": "7.2", "P99": "7.6", "P999": "8.4" } },
              { "name": 13, "uid": "2929341763", "values": { "age": 13, "P01": "3.9", "P1": "4.3", "P3": "4.6", "P5": "4.7", "P10": 5, "P15": "5.1", "P25": "5.4", "P50": "5.8", "P75": "6.4", "P85": "6.7", "P90": "6.9", "P95": "7.2", "P97": "7.4", "P99": "7.8", "P999": "8.6" } }
          ];

          const girls_to_5y = [
              { "name": "a", "uid": "2101522777", "values": { "age": 0, "P01": 2, "P1": "2.3", "P3": "2.4", "P5": "2.5", "P10": "2.7", "P15": "2.8", "P25": "2.9", "P50": "3.2", "P75": "3.6", "P85": "3.7", "P90": "3.9", "P95": 4, "P97": "4.2", "P99": "4.4", "P999": "4.8" } },
              { "name": 1, "uid": "2706677359", "values": { "age": 1, "P01": "2.7", "P1": 3, "P3": "3.2", "P5": "3.3", "P10": "3.5", "P15": "3.6", "P25": "3.8", "P50": "4.2", "P75": "4.6", "P85": "4.8", "P90": 5, "P95": "5.2", "P97": "5.4", "P99": "5.7", "P999": "6.3" } },
              { "name": 2, "uid": "2045929197", "values": { "age": 2, "P01": "3.4", "P1": "3.8", "P3": 4, "P5": "4.1", "P10": "4.3", "P15": "4.5", "P25": "4.7", "P50": "5.1", "P75": "5.6", "P85": "5.9", "P90": 6, "P95": "6.3", "P97": "6.5", "P99": "6.9", "P999": "7.6" } },
              { "name": 3, "uid": "1944736245", "values": { "age": 3, "P01": "3.9", "P1": "4.4", "P3": "4.6", "P5": "4.7", "P10": 5, "P15": "5.1", "P25": "5.4", "P50": "5.8", "P75": "6.4", "P85": "6.7", "P90": "6.9", "P95": "7.2", "P97": "7.4", "P99": "7.8", "P999": "8.6" } },
              { "name": 4, "uid": "2334392654", "values": { "age": 4, "P01": "4.4", "P1": "4.8", "P3": "5.1", "P5": "5.2", "P10": "5.5", "P15": "5.6", "P25": "5.9", "P50": "6.4", "P75": 7, "P85": "7.3", "P90": "7.5", "P95": "7.9", "P97": "8.1", "P99": "8.6", "P999": "9.4" } },
              { "name": 5, "uid": "33396477", "values": { "age": 5, "P01": "4.7", "P1": "5.2", "P3": "5.5", "P5": "5.6", "P10": "5.9", "P15": "6.1", "P25": "6.4", "P50": "6.9", "P75": "7.5", "P85": "7.8", "P90": "8.1", "P95": "8.4", "P97": "8.7", "P99": "9.2", "P999": "10.1" } },
              { "name": 6, "uid": "3435625595", "values": { "age": 6, "P01": 5, "P1": "5.5", "P3": "5.8", "P5": 6, "P10": "6.2", "P15": "6.4", "P25": "6.7", "P50": "7.3", "P75": "7.9", "P85": "8.3", "P90": "8.5", "P95": "8.9", "P97": "9.2", "P99": "9.7", "P999": "10.7" } },
              { "name": 7, "uid": "3561095891", "values": { "age": 7, "P01": "5.3", "P1": "5.8", "P3": "6.1", "P5": "6.3", "P10": "6.5", "P15": "6.7", "P25": 7, "P50": "7.6", "P75": "8.3", "P85": "8.7", "P90": "8.9", "P95": "9.4", "P97": "9.6", "P99": "10.2", "P999": "11.2" } },
              { "name": 8, "uid": "2388008358", "values": { "age": 8, "P01": "5.5", "P1": 6, "P3": "6.3", "P5": "6.5", "P10": "6.8", "P15": 7, "P25": "7.3", "P50": "7.9", "P75": "8.6", "P85": 9, "P90": "9.3", "P95": "9.7", "P97": 10, "P99": "10.6", "P999": "11.7" } },
              { "name": 9, "uid": "1160676723", "values": { "age": 9, "P01": "5.7", "P1": "6.2", "P3": "6.6", "P5": "6.8", "P10": 7, "P15": "7.3", "P25": "7.6", "P50": "8.2", "P75": "8.9", "P85": "9.3", "P90": "9.6", "P95": "10.1", "P97": "10.4", "P99": 11, "P999": "12.1" } },
              { "name": 10, "uid": "1340343038", "values": { "age": 10, "P01": "5.9", "P1": "6.4", "P3": "6.8", "P5": 7, "P10": "7.3", "P15": "7.5", "P25": "7.8", "P50": "8.5", "P75": "9.2", "P85": "9.6", "P90": "9.9", "P95": "10.4", "P97": "10.7", "P99": "11.3", "P999": "12.5" } },
              { "name": 11, "uid": "3907737903", "values": { "age": 11, "P01": 6, "P1": "6.6", "P3": 7, "P5": "7.2", "P10": "7.5", "P15": "7.7", "P25": 8, "P50": "8.7", "P75": "9.5", "P85": "9.9", "P90": "10.2", "P95": "10.7", "P97": 11, "P99": "11.7", "P999": "12.9" } },
              { "name": 12, "uid": "3689416734", "values": { "age": 12, "P01": "6.2", "P1": "6.8", "P3": "7.1", "P5": "7.3", "P10": "7.7", "P15": "7.9", "P25": "8.2", "P50": "8.9", "P75": "9.7", "P85": "10.2", "P90": "10.5", "P95": 11, "P97": "11.3", "P99": 12, "P999": "13.3" } },
              { "name": 13, "uid": "14789121", "values": { "age": 13, "P01": "6.4", "P1": "6.9", "P3": "7.3", "P5": "7.5", "P10": "7.9", "P15": "8.1", "P25": "8.4", "P50": "9.2", "P75": 10, "P85": "10.4", "P90": "10.8", "P95": "11.3", "P97": "11.6", "P99": "12.3", "P999": "13.6" } },
              { "name": 14, "uid": "2752563322", "values": { "age": 14, "P01": "6.5", "P1": "7.1", "P3": "7.5", "P5": "7.7", "P10": 8, "P15": "8.3", "P25": "8.6", "P50": "9.4", "P75": "10.2", "P85": "10.7", "P90": 11, "P95": "11.5", "P97": "11.9", "P99": "12.6", "P999": 14 } },
              { "name": 15, "uid": "626010922", "values": { "age": 15, "P01": "6.7", "P1": "7.3", "P3": "7.7", "P5": "7.9", "P10": "8.2", "P15": "8.5", "P25": "8.8", "P50": "9.6", "P75": "10.4", "P85": "10.9", "P90": "11.3", "P95": "11.8", "P97": "12.2", "P99": "12.9", "P999": "14.3" } },
              { "name": 16, "uid": "2127088523", "values": { "age": 16, "P01": "6.8", "P1": "7.4", "P3": "7.8", "P5": "8.1", "P10": "8.4", "P15": "8.7", "P25": 9, "P50": "9.8", "P75": "10.7", "P85": "11.2", "P90": "11.5", "P95": "12.1", "P97": "12.5", "P99": "13.2", "P999": "14.6" } },
              { "name": 17, "uid": "3753768630", "values": { "age": 17, "P01": 7, "P1": "7.6", "P3": 8, "P5": "8.2", "P10": "8.6", "P15": "8.8", "P25": "9.2", "P50": 10, "P75": "10.9", "P85": "11.4", "P90": "11.8", "P95": "12.3", "P97": "12.7", "P99": "13.5", "P999": 15 } },
              { "name": 18, "uid": "3733619177", "values": { "age": 18, "P01": "7.1", "P1": "7.8", "P3": "8.2", "P5": "8.4", "P10": "8.8", "P15": 9, "P25": "9.4", "P50": "10.2", "P75": "11.1", "P85": "11.6", "P90": 12, "P95": "12.6", "P97": 13, "P99": "13.8", "P999": "15.3" } },
              { "name": 19, "uid": "3267869332", "values": { "age": 19, "P01": "7.3", "P1": "7.9", "P3": "8.3", "P5": "8.6", "P10": "8.9", "P15": "9.2", "P25": "9.6", "P50": "10.4", "P75": "11.4", "P85": "11.9", "P90": "12.3", "P95": "12.9", "P97": "13.3", "P99": "14.1", "P999": "15.6" } },
              { "name": 20, "uid": "3513952144", "values": { "age": 20, "P01": "7.4", "P1": "8.1", "P3": "8.5", "P5": "8.7", "P10": "9.1", "P15": "9.4", "P25": "9.8", "P50": "10.6", "P75": "11.6", "P85": "12.1", "P90": "12.5", "P95": "13.1", "P97": "13.5", "P99": "14.4", "P999": "15.9" } },
              { "name": 21, "uid": "3891989198", "values": { "age": 21, "P01": "7.6", "P1": "8.2", "P3": "8.7", "P5": "8.9", "P10": "9.3", "P15": "9.6", "P25": 10, "P50": "10.9", "P75": "11.8", "P85": "12.4", "P90": "12.8", "P95": "13.4", "P97": "13.8", "P99": "14.6", "P999": "16.2" } },
              { "name": 22, "uid": "3205526744", "values": { "age": 22, "P01": "7.7", "P1": "8.4", "P3": "8.8", "P5": "9.1", "P10": "9.5", "P15": "9.8", "P25": "10.2", "P50": "11.1", "P75": 12, "P85": "12.6", "P90": 13, "P95": "13.6", "P97": "14.1", "P99": "14.9", "P999": "16.6" } },
              { "name": 23, "uid": "318713343", "values": { "age": 23, "P01": "7.8", "P1": "8.5", "P3": 9, "P5": "9.2", "P10": "9.7", "P15": "9.9", "P25": "10.4", "P50": "11.3", "P75": "12.3", "P85": "12.8", "P90": "13.3", "P95": "13.9", "P97": "14.3", "P99": "15.2", "P999": "16.9" } },
              { "name": 24, "uid": "2283995645", "values": { "age": 24, "P01": 8, "P1": "8.7", "P3": "9.2", "P5": "9.4", "P10": "9.8", "P15": "10.1", "P25": "10.6", "P50": "11.5", "P75": "12.5", "P85": "13.1", "P90": "13.5", "P95": "14.2", "P97": "14.6", "P99": "15.5", "P999": "17.2" } },
              { "name": 25, "uid": "836552489", "values": { "age": 25, "P01": "8.1", "P1": "8.9", "P3": "9.3", "P5": "9.6", "P10": 10, "P15": "10.3", "P25": "10.8", "P50": "11.7", "P75": "12.7", "P85": "13.3", "P90": "13.8", "P95": "14.4", "P97": "14.9", "P99": "15.8", "P999": "17.6" } },
              { "name": 26, "uid": "2043973312", "values": { "age": 26, "P01": "8.3", "P1": 9, "P3": "9.5", "P5": "9.8", "P10": "10.2", "P15": "10.5", "P25": "10.9", "P50": "11.9", "P75": "12.9", "P85": "13.6", "P90": 14, "P95": "14.7", "P97": "15.2", "P99": "16.1", "P999": "17.9" } },
              { "name": 27, "uid": "1521245358", "values": { "age": 27, "P01": "8.4", "P1": "9.2", "P3": "9.6", "P5": "9.9", "P10": "10.4", "P15": "10.7", "P25": "11.1", "P50": "12.1", "P75": "13.2", "P85": "13.8", "P90": "14.3", "P95": 15, "P97": "15.4", "P99": "16.4", "P999": "18.2" } },
              { "name": 28, "uid": "1855939437", "values": { "age": 28, "P01": "8.5", "P1": "9.3", "P3": "9.8", "P5": "10.1", "P10": "10.5", "P15": "10.8", "P25": "11.3", "P50": "12.3", "P75": "13.4", "P85": 14, "P90": "14.5", "P95": "15.2", "P97": "15.7", "P99": "16.7", "P999": "18.6" } },
              { "name": 29, "uid": "2945180243", "values": { "age": 29, "P01": "8.7", "P1": "9.5", "P3": 10, "P5": "10.2", "P10": "10.7", "P15": 11, "P25": "11.5", "P50": "12.5", "P75": "13.6", "P85": "14.3", "P90": "14.7", "P95": "15.5", "P97": 16, "P99": 17, "P999": "18.9" } },
              { "name": 30, "uid": "2415524738", "values": { "age": 30, "P01": "8.8", "P1": "9.6", "P3": "10.1", "P5": "10.4", "P10": "10.9", "P15": "11.2", "P25": "11.7", "P50": "12.7", "P75": "13.8", "P85": "14.5", "P90": 15, "P95": "15.7", "P97": "16.2", "P99": "17.3", "P999": "19.2" } },
              { "name": 31, "uid": "287207066", "values": { "age": 31, "P01": "8.9", "P1": "9.7", "P3": "10.3", "P5": "10.5", "P10": 11, "P15": "11.3", "P25": "11.9", "P50": "12.9", "P75": "14.1", "P85": "14.7", "P90": "15.2", "P95": 16, "P97": "16.5", "P99": "17.6", "P999": "19.6" } },
              { "name": 32, "uid": "811578739", "values": { "age": 32, "P01": 9, "P1": "9.9", "P3": "10.4", "P5": "10.7", "P10": "11.2", "P15": "11.5", "P25": 12, "P50": "13.1", "P75": "14.3", "P85": 15, "P90": "15.5", "P95": "16.2", "P97": "16.8", "P99": "17.8", "P999": "19.9" } },
              { "name": 33, "uid": "3413938318", "values": { "age": 33, "P01": "9.2", "P1": 10, "P3": "10.5", "P5": "10.8", "P10": "11.3", "P15": "11.7", "P25": "12.2", "P50": "13.3", "P75": "14.5", "P85": "15.2", "P90": "15.7", "P95": "16.5", "P97": 17, "P99": "18.1", "P999": "20.2" } },
              { "name": 34, "uid": "1773830548", "values": { "age": 34, "P01": "9.3", "P1": "10.1", "P3": "10.7", "P5": 11, "P10": "11.5", "P15": "11.8", "P25": "12.4", "P50": "13.5", "P75": "14.7", "P85": "15.4", "P90": "15.9", "P95": "16.8", "P97": "17.3", "P99": "18.4", "P999": "20.6" } },
              { "name": 35, "uid": "3772242904", "values": { "age": 35, "P01": "9.4", "P1": "10.3", "P3": "10.8", "P5": "11.1", "P10": "11.6", "P15": 12, "P25": "12.5", "P50": "13.7", "P75": "14.9", "P85": "15.7", "P90": "16.2", "P95": 17, "P97": "17.6", "P99": "18.7", "P999": "20.9" } },
              { "name": 36, "uid": "365540925", "values": { "age": 36, "P01": "9.5", "P1": "10.4", "P3": 11, "P5": "11.3", "P10": "11.8", "P15": "12.1", "P25": "12.7", "P50": "13.9", "P75": "15.1", "P85": "15.9", "P90": "16.4", "P95": "17.3", "P97": "17.8", "P99": 19, "P999": "21.2" } },
              { "name": 37, "uid": "2362720420", "values": { "age": 37, "P01": "9.6", "P1": "10.5", "P3": "11.1", "P5": "11.4", "P10": "11.9", "P15": "12.3", "P25": "12.9", "P50": 14, "P75": "15.3", "P85": "16.1", "P90": "16.7", "P95": "17.5", "P97": "18.1", "P99": "19.3", "P999": "21.6" } },
              { "name": 38, "uid": "414420137", "values": { "age": 38, "P01": "9.7", "P1": "10.6", "P3": "11.2", "P5": "11.6", "P10": "12.1", "P15": "12.5", "P25": 13, "P50": "14.2", "P75": "15.6", "P85": "16.3", "P90": "16.9", "P95": "17.8", "P97": "18.4", "P99": "19.6", "P999": "21.9" } },
              { "name": 39, "uid": "1174097024", "values": { "age": 39, "P01": "9.8", "P1": "10.8", "P3": "11.4", "P5": "11.7", "P10": "12.2", "P15": "12.6", "P25": "13.2", "P50": "14.4", "P75": "15.8", "P85": "16.6", "P90": "17.1", "P95": 18, "P97": "18.6", "P99": "19.9", "P999": "22.3" } },
              { "name": 40, "uid": "2395446952", "values": { "age": 40, "P01": 10, "P1": "10.9", "P3": "11.5", "P5": "11.8", "P10": "12.4", "P15": "12.8", "P25": "13.4", "P50": "14.6", "P75": 16, "P85": "16.8", "P90": "17.4", "P95": "18.3", "P97": "18.9", "P99": "20.2", "P999": "22.6" } },
              { "name": 41, "uid": "1406042376", "values": { "age": 41, "P01": "10.1", "P1": 11, "P3": "11.6", "P5": 12, "P10": "12.5", "P15": "12.9", "P25": "13.5", "P50": "14.8", "P75": "16.2", "P85": 17, "P90": "17.6", "P95": "18.6", "P97": "19.2", "P99": "20.5", "P999": 23 } },
              { "name": 42, "uid": "188749328", "values": { "age": 42, "P01": "10.2", "P1": "11.1", "P3": "11.8", "P5": "12.1", "P10": "12.7", "P15": "13.1", "P25": "13.7", "P50": 15, "P75": "16.4", "P85": "17.3", "P90": "17.9", "P95": "18.8", "P97": "19.5", "P99": "20.8", "P999": "23.3" } },
              { "name": 43, "uid": "3574731008", "values": { "age": 43, "P01": "10.3", "P1": "11.3", "P3": "11.9", "P5": "12.2", "P10": "12.8", "P15": "13.2", "P25": "13.9", "P50": "15.2", "P75": "16.6", "P85": "17.5", "P90": "18.1", "P95": "19.1", "P97": "19.7", "P99": "21.1", "P999": "23.7" } },
              { "name": 44, "uid": "1847243750", "values": { "age": 44, "P01": "10.4", "P1": "11.4", "P3": 12, "P5": "12.4", "P10": 13, "P15": "13.4", "P25": 14, "P50": "15.3", "P75": "16.8", "P85": "17.7", "P90": "18.3", "P95": "19.3", "P97": 20, "P99": "21.4", "P999": "24.1" } },
              { "name": 45, "uid": "2731735734", "values": { "age": 45, "P01": "10.5", "P1": "11.5", "P3": "12.1", "P5": "12.5", "P10": "13.1", "P15": "13.5", "P25": "14.2", "P50": "15.5", "P75": 17, "P85": "17.9", "P90": "18.6", "P95": "19.6", "P97": "20.3", "P99": "21.7", "P999": "24.4" } },
              { "name": 46, "uid": "1946702498", "values": { "age": 46, "P01": "10.6", "P1": "11.6", "P3": "12.3", "P5": "12.6", "P10": "13.2", "P15": "13.7", "P25": "14.3", "P50": "15.7", "P75": "17.3", "P85": "18.2", "P90": "18.8", "P95": "19.9", "P97": "20.6", "P99": 22, "P999": "24.8" } },
              { "name": 47, "uid": "3162328368", "values": { "age": 47, "P01": "10.7", "P1": "11.7", "P3": "12.4", "P5": "12.8", "P10": "13.4", "P15": "13.8", "P25": "14.5", "P50": "15.9", "P75": "17.5", "P85": "18.4", "P90": "19.1", "P95": "20.1", "P97": "20.8", "P99": "22.3", "P999": "25.2" } },
              { "name": 48, "uid": "1840523714", "values": { "age": 48, "P01": "10.8", "P1": "11.8", "P3": "12.5", "P5": "12.9", "P10": "13.5", "P15": 14, "P25": "14.7", "P50": "16.1", "P75": "17.7", "P85": "18.6", "P90": "19.3", "P95": "20.4", "P97": "21.1", "P99": "22.6", "P999": "25.5" } },
              { "name": 49, "uid": "3046199322", "values": { "age": 49, "P01": "10.9", "P1": "11.9", "P3": "12.6", "P5": 13, "P10": "13.7", "P15": "14.1", "P25": "14.8", "P50": "16.3", "P75": "17.9", "P85": "18.9", "P90": "19.5", "P95": "20.6", "P97": "21.4", "P99": "22.9", "P999": "25.9" } },
              { "name": 50, "uid": "1128574067", "values": { "age": 50, "P01": 11, "P1": "12.1", "P3": "12.8", "P5": "13.2", "P10": "13.8", "P15": "14.3", "P25": 15, "P50": "16.4", "P75": "18.1", "P85": "19.1", "P90": "19.8", "P95": "20.9", "P97": "21.7", "P99": "23.2", "P999": "26.3" } },
              { "name": 51, "uid": "2932598118", "values": { "age": 51, "P01": "11.1", "P1": "12.2", "P3": "12.9", "P5": "13.3", "P10": "13.9", "P15": "14.4", "P25": "15.1", "P50": "16.6", "P75": "18.3", "P85": "19.3", "P90": 20, "P95": "21.2", "P97": 22, "P99": "23.5", "P999": "26.7" } },
              { "name": 52, "uid": "2592184625", "values": { "age": 52, "P01": "11.2", "P1": "12.3", "P3": 13, "P5": "13.4", "P10": "14.1", "P15": "14.5", "P25": "15.3", "P50": "16.8", "P75": "18.5", "P85": "19.5", "P90": "20.3", "P95": "21.4", "P97": "22.2", "P99": "23.9", "P999": 27 } },
              { "name": 53, "uid": "2000089489", "values": { "age": 53, "P01": "11.3", "P1": "12.4", "P3": "13.1", "P5": "13.5", "P10": "14.2", "P15": "14.7", "P25": "15.4", "P50": 17, "P75": "18.7", "P85": "19.8", "P90": "20.5", "P95": "21.7", "P97": "22.5", "P99": "24.2", "P999": "27.4" } },
              { "name": 54, "uid": "2638138720", "values": { "age": 54, "P01": "11.3", "P1": "12.5", "P3": "13.2", "P5": "13.7", "P10": "14.3", "P15": "14.8", "P25": "15.6", "P50": "17.2", "P75": "18.9", "P85": 20, "P90": "20.8", "P95": 22, "P97": "22.8", "P99": "24.5", "P999": "27.8" } },
              { "name": 55, "uid": "2745248364", "values": { "age": 55, "P01": "11.4", "P1": "12.6", "P3": "13.4", "P5": "13.8", "P10": "14.5", "P15": 15, "P25": "15.8", "P50": "17.3", "P75": "19.1", "P85": "20.2", "P90": 21, "P95": "22.2", "P97": "23.1", "P99": "24.8", "P999": "28.2" } },
              { "name": 56, "uid": "3637147298", "values": { "age": 56, "P01": "11.5", "P1": "12.7", "P3": "13.5", "P5": "13.9", "P10": "14.6", "P15": "15.1", "P25": "15.9", "P50": "17.5", "P75": "19.3", "P85": "20.4", "P90": "21.2", "P95": "22.5", "P97": "23.3", "P99": "25.1", "P999": "28.5" } },
              { "name": 57, "uid": "1827613279", "values": { "age": 57, "P01": "11.6", "P1": "12.8", "P3": "13.6", "P5": 14, "P10": "14.8", "P15": "15.3", "P25": "16.1", "P50": "17.7", "P75": "19.6", "P85": "20.7", "P90": "21.5", "P95": "22.7", "P97": "23.6", "P99": "25.4", "P999": "28.9" } },
              { "name": 58, "uid": "3251797700", "values": { "age": 58, "P01": "11.7", "P1": "12.9", "P3": "13.7", "P5": "14.2", "P10": "14.9", "P15": "15.4", "P25": "16.2", "P50": "17.9", "P75": "19.8", "P85": "20.9", "P90": "21.7", "P95": 23, "P97": "23.9", "P99": "25.7", "P999": "29.3" } },
              { "name": 59, "uid": "2504439315", "values": { "age": 59, "P01": "11.8", "P1": "13.1", "P3": "13.8", "P5": "14.3", "P10": 15, "P15": "15.5", "P25": "16.4", "P50": 18, "P75": 20, "P85": "21.1", "P90": "21.9", "P95": "23.3", "P97": "24.2", "P99": 26, "P999": "29.6" } },
              { "name": 60, "uid": "470741983", "values": { "age": 60, "P01": "11.9", "P1": "13.2", "P3": 14, "P5": "14.4", "P10": "15.2", "P15": "15.7", "P25": "16.5", "P50": "18.2", "P75": "20.2", "P85": "21.3", "P90": "22.2", "P95": "23.5", "P97": "24.4", "P99": "26.3", "P999": 30 } }
          ];

          const boys_to_13w = [
              { "name": "a", "uid": "174380932", "values": { "age": 0, "P01": 2, "P1": "2.3", "P3": "2.5", "P5": "2.6", "P10": "2.8", "P15": "2.9", "P25": 3, "P50": "3.3", "P75": "3.7", "P85": "3.9", "P90": 4, "P95": "4.2", "P97": "4.3", "P99": "4.6", "P999": "5.1" } },
              { "name": 1, "uid": "1361477978", "values": { "age": 1, "P01": "2.2", "P1": "2.4", "P3": "2.6", "P5": "2.7", "P10": "2.9", "P15": 3, "P25": "3.2", "P50": "3.5", "P75": "3.8", "P85": 4, "P90": "4.2", "P95": "4.4", "P97": "4.5", "P99": "4.8", "P999": "5.3" } },
              { "name": 2, "uid": "3568377109", "values": { "age": 2, "P01": "2.4", "P1": "2.7", "P3": "2.8", "P5": 3, "P10": "3.1", "P15": "3.2", "P25": "3.4", "P50": "3.8", "P75": "4.1", "P85": "4.3", "P90": "4.5", "P95": "4.7", "P97": "4.9", "P99": "5.1", "P999": "5.7" } },
              { "name": 3, "uid": "1284471549", "values": { "age": 3, "P01": "2.6", "P1": "2.9", "P3": "3.1", "P5": "3.2", "P10": "3.4", "P15": "3.5", "P25": "3.7", "P50": "4.1", "P75": "4.5", "P85": "4.7", "P90": "4.8", "P95": "5.1", "P97": "5.2", "P99": "5.5", "P999": "6.1" } },
              { "name": 4, "uid": "163197567", "values": { "age": 4, "P01": "2.8", "P1": "3.2", "P3": "3.4", "P5": "3.5", "P10": "3.7", "P15": "3.8", "P25": 4, "P50": "4.4", "P75": "4.8", "P85": 5, "P90": "5.2", "P95": "5.4", "P97": "5.6", "P99": "5.9", "P999": "6.5" } },
              { "name": 5, "uid": "2239250885", "values": { "age": 5, "P01": 3, "P1": "3.4", "P3": "3.6", "P5": "3.7", "P10": "3.9", "P15": "4.1", "P25": "4.3", "P50": "4.7", "P75": "5.1", "P85": "5.3", "P90": "5.5", "P95": "5.8", "P97": "5.9", "P99": "6.3", "P999": "6.9" } },
              { "name": 6, "uid": "1861435883", "values": { "age": 6, "P01": "3.2", "P1": "3.6", "P3": "3.8", "P5": 4, "P10": "4.2", "P15": "4.3", "P25": "4.5", "P50": "4.9", "P75": "5.4", "P85": "5.6", "P90": "5.8", "P95": "6.1", "P97": "6.3", "P99": "6.6", "P999": "7.2" } },
              { "name": 7, "uid": "3846148424", "values": { "age": 7, "P01": "3.4", "P1": "3.8", "P3": "4.1", "P5": "4.2", "P10": "4.4", "P15": "4.5", "P25": "4.8", "P50": "5.2", "P75": "5.6", "P85": "5.9", "P90": "6.1", "P95": "6.4", "P97": "6.5", "P99": "6.9", "P999": "7.6" } },
              { "name": 8, "uid": "2001806356", "values": { "age": 8, "P01": "3.6", "P1": 4, "P3": "4.3", "P5": "4.4", "P10": "4.6", "P15": "4.7", "P25": 5, "P50": "5.4", "P75": "5.9", "P85": "6.2", "P90": "6.3", "P95": "6.6", "P97": "6.8", "P99": "7.2", "P999": "7.9" } },
              { "name": 9, "uid": "1714284403", "values": { "age": 9, "P01": "3.8", "P1": "4.2", "P3": "4.4", "P5": "4.6", "P10": "4.8", "P15": "4.9", "P25": "5.2", "P50": "5.6", "P75": "6.1", "P85": "6.4", "P90": "6.6", "P95": "6.9", "P97": "7.1", "P99": "7.4", "P999": "8.1" } },
              { "name": 10, "uid": "316784701", "values": { "age": 10, "P01": 4, "P1": "4.4", "P3": "4.6", "P5": "4.8", "P10": 5, "P15": "5.1", "P25": "5.4", "P50": "5.8", "P75": "6.3", "P85": "6.6", "P90": "6.8", "P95": "7.1", "P97": "7.3", "P99": "7.7", "P999": "8.4" } },
              { "name": 11, "uid": "834857604", "values": { "age": 11, "P01": "4.1", "P1": "4.5", "P3": "4.8", "P5": "4.9", "P10": "5.2", "P15": "5.3", "P25": "5.6", "P50": 6, "P75": "6.5", "P85": "6.8", "P90": 7, "P95": "7.3", "P97": "7.5", "P99": "7.9", "P999": "8.6" } },
              { "name": 12, "uid": "1982219379", "values": { "age": 12, "P01": "4.2", "P1": "4.7", "P3": "4.9", "P5": "5.1", "P10": "5.3", "P15": "5.5", "P25": "5.7", "P50": "6.2", "P75": "6.7", "P85": 7, "P90": "7.2", "P95": "7.5", "P97": "7.7", "P99": "8.1", "P999": "8.8" } },
              { "name": 13, "uid": "2585205816", "values": { "age": 13, "P01": "4.4", "P1": "4.8", "P3": "5.1", "P5": "5.2", "P10": "5.5", "P15": "5.6", "P25": "5.9", "P50": "6.4", "P75": "6.9", "P85": "7.2", "P90": "7.4", "P95": "7.7", "P97": "7.9", "P99": "8.3", "P999": "9.1" } }
          ];

          const boys_to_5y = [
              { "name": "a", "uid": "174380932", "values": { "age": 0, "P01": 2, "P1": "2.3", "P3": "2.5", "P5": "2.6", "P10": "2.8", "P15": "2.9", "P25": 3, "P50": "3.3", "P75": "3.7", "P85": "3.9", "P90": 4, "P95": "4.2", "P97": "4.3", "P99": "4.6", "P999": "5.1" } },
              { "name": 1, "uid": "1393043846", "values": { "age": 1, "P01": "2.9", "P1": "3.2", "P3": "3.4", "P5": "3.6", "P10": "3.8", "P15": "3.9", "P25": "4.1", "P50": "4.5", "P75": "4.9", "P85": "5.1", "P90": "5.3", "P95": "5.5", "P97": "5.7", "P99": 6, "P999": "6.6" } },
              { "name": 2, "uid": "3408545268", "values": { "age": 2, "P01": "3.7", "P1": "4.1", "P3": "4.4", "P5": "4.5", "P10": "4.7", "P15": "4.9", "P25": "5.1", "P50": "5.6", "P75": 6, "P85": "6.3", "P90": "6.5", "P95": "6.8", "P97": 7, "P99": "7.4", "P999": "8.1" } },
              { "name": 3, "uid": "3641033609", "values": { "age": 3, "P01": "4.4", "P1": "4.8", "P3": "5.1", "P5": "5.2", "P10": "5.5", "P15": "5.6", "P25": "5.9", "P50": "6.4", "P75": "6.9", "P85": "7.2", "P90": "7.4", "P95": "7.7", "P97": "7.9", "P99": "8.3", "P999": "9.1" } },
              { "name": 4, "uid": "1456690596", "values": { "age": 4, "P01": "4.9", "P1": "5.4", "P3": "5.6", "P5": "5.8", "P10": 6, "P15": "6.2", "P25": "6.5", "P50": 7, "P75": "7.6", "P85": "7.9", "P90": "8.1", "P95": "8.4", "P97": "8.6", "P99": "9.1", "P999": "9.8" } },
              { "name": 5, "uid": "3471436701", "values": { "age": 5, "P01": "5.3", "P1": "5.8", "P3": "6.1", "P5": "6.2", "P10": "6.5", "P15": "6.7", "P25": 7, "P50": "7.5", "P75": "8.1", "P85": "8.4", "P90": "8.6", "P95": 9, "P97": "9.2", "P99": "9.7", "P999": "10.5" } },
              { "name": 6, "uid": "1670941587", "values": { "age": 6, "P01": "5.6", "P1": "6.1", "P3": "6.4", "P5": "6.6", "P10": "6.9", "P15": "7.1", "P25": "7.4", "P50": "7.9", "P75": "8.5", "P85": "8.9", "P90": "9.1", "P95": "9.5", "P97": "9.7", "P99": "10.2", "P999": "11.1" } },
              { "name": 7, "uid": "1355367027", "values": { "age": 7, "P01": "5.9", "P1": "6.4", "P3": "6.7", "P5": "6.9", "P10": "7.2", "P15": "7.4", "P25": "7.7", "P50": "8.3", "P75": "8.9", "P85": "9.3", "P90": "9.5", "P95": "9.9", "P97": "10.2", "P99": "10.7", "P999": "11.5" } },
              { "name": 8, "uid": "9139636", "values": { "age": 8, "P01": "6.1", "P1": "6.7", "P3": 7, "P5": "7.2", "P10": "7.5", "P15": "7.7", "P25": 8, "P50": "8.6", "P75": "9.3", "P85": "9.6", "P90": "9.9", "P95": "10.3", "P97": "10.5", "P99": "11.1", "P999": 12 } },
              { "name": 9, "uid": "3536012642", "values": { "age": 9, "P01": "6.3", "P1": "6.9", "P3": "7.2", "P5": "7.4", "P10": "7.7", "P15": "7.9", "P25": "8.3", "P50": "8.9", "P75": "9.6", "P85": 10, "P90": "10.2", "P95": "10.6", "P97": "10.9", "P99": "11.4", "P999": "12.4" } },
              { "name": 10, "uid": "643284964", "values": { "age": 10, "P01": "6.5", "P1": "7.1", "P3": "7.5", "P5": "7.7", "P10": 8, "P15": "8.2", "P25": "8.5", "P50": "9.2", "P75": "9.9", "P85": "10.3", "P90": "10.5", "P95": "10.9", "P97": "11.2", "P99": "11.8", "P999": "12.8" } },
              { "name": 11, "uid": "3093453099", "values": { "age": 11, "P01": "6.7", "P1": "7.3", "P3": "7.7", "P5": "7.9", "P10": "8.2", "P15": "8.4", "P25": "8.7", "P50": "9.4", "P75": "10.1", "P85": "10.5", "P90": "10.8", "P95": "11.2", "P97": "11.5", "P99": "12.1", "P999": "13.1" } },
              { "name": 12, "uid": "190355866", "values": { "age": 12, "P01": "6.9", "P1": "7.5", "P3": "7.8", "P5": "8.1", "P10": "8.4", "P15": "8.6", "P25": 9, "P50": "9.6", "P75": "10.4", "P85": "10.8", "P90": "11.1", "P95": "11.5", "P97": "11.8", "P99": "12.4", "P999": "13.5" } },
              { "name": 13, "uid": "1493861541", "values": { "age": 13, "P01": 7, "P1": "7.6", "P3": 8, "P5": "8.2", "P10": "8.6", "P15": "8.8", "P25": "9.2", "P50": "9.9", "P75": "10.6", "P85": "11.1", "P90": "11.4", "P95": "11.8", "P97": "12.1", "P99": "12.7", "P999": "13.8" } },
              { "name": 14, "uid": "2725543586", "values": { "age": 14, "P01": "7.2", "P1": "7.8", "P3": "8.2", "P5": "8.4", "P10": "8.8", "P15": 9, "P25": "9.4", "P50": "10.1", "P75": "10.9", "P85": "11.3", "P90": "11.6", "P95": "12.1", "P97": "12.4", "P99": 13, "P999": "14.1" } },
              { "name": 15, "uid": "2781236091", "values": { "age": 15, "P01": "7.3", "P1": 8, "P3": "8.4", "P5": "8.6", "P10": 9, "P15": "9.2", "P25": "9.6", "P50": "10.3", "P75": "11.1", "P85": "11.6", "P90": "11.9", "P95": "12.3", "P97": "12.7", "P99": "13.3", "P999": "14.5" } },
              { "name": 16, "uid": "1561580394", "values": { "age": 16, "P01": "7.5", "P1": "8.1", "P3": "8.5", "P5": "8.8", "P10": "9.1", "P15": "9.4", "P25": "9.8", "P50": "10.5", "P75": "11.3", "P85": "11.8", "P90": "12.1", "P95": "12.6", "P97": "12.9", "P99": "13.6", "P999": "14.8" } },
              { "name": 17, "uid": "510295962", "values": { "age": 17, "P01": "7.6", "P1": "8.3", "P3": "8.7", "P5": "8.9", "P10": "9.3", "P15": "9.6", "P25": 10, "P50": "10.7", "P75": "11.6", "P85": 12, "P90": "12.4", "P95": "12.9", "P97": "13.2", "P99": "13.9", "P999": "15.1" } },
              { "name": 18, "uid": "3259109840", "values": { "age": 18, "P01": "7.7", "P1": "8.4", "P3": "8.9", "P5": "9.1", "P10": "9.5", "P15": "9.7", "P25": "10.1", "P50": "10.9", "P75": "11.8", "P85": "12.3", "P90": "12.6", "P95": "13.1", "P97": "13.5", "P99": "14.2", "P999": "15.4" } },
              { "name": 19, "uid": "73934774", "values": { "age": 19, "P01": "7.9", "P1": "8.6", "P3": 9, "P5": "9.3", "P10": "9.7", "P15": "9.9", "P25": "10.3", "P50": "11.1", "P75": 12, "P85": "12.5", "P90": "12.9", "P95": "13.4", "P97": "13.7", "P99": "14.4", "P999": "15.7" } },
              { "name": 20, "uid": "2494669100", "values": { "age": 20, "P01": 8, "P1": "8.7", "P3": "9.2", "P5": "9.4", "P10": "9.8", "P15": "10.1", "P25": "10.5", "P50": "11.3", "P75": "12.2", "P85": "12.7", "P90": "13.1", "P95": "13.6", "P97": 14, "P99": "14.7", "P999": 16 } },
              { "name": 21, "uid": "1549215921", "values": { "age": 21, "P01": "8.2", "P1": "8.9", "P3": "9.3", "P5": "9.6", "P10": 10, "P15": "10.3", "P25": "10.7", "P50": "11.5", "P75": "12.5", "P85": 13, "P90": "13.3", "P95": "13.9", "P97": "14.3", "P99": 15, "P999": "16.4" } },
              { "name": 22, "uid": "1604773991", "values": { "age": 22, "P01": "8.3", "P1": 9, "P3": "9.5", "P5": "9.8", "P10": "10.2", "P15": "10.5", "P25": "10.9", "P50": "11.8", "P75": "12.7", "P85": "13.2", "P90": "13.6", "P95": "14.2", "P97": "14.5", "P99": "15.3", "P999": "16.7" } },
              { "name": 23, "uid": "524159043", "values": { "age": 23, "P01": "8.4", "P1": "9.2", "P3": "9.7", "P5": "9.9", "P10": "10.3", "P15": "10.6", "P25": "11.1", "P50": 12, "P75": "12.9", "P85": "13.4", "P90": "13.8", "P95": "14.4", "P97": "14.8", "P99": "15.6", "P999": 17 } },
              { "name": 24, "uid": "227731272", "values": { "age": 24, "P01": "8.5", "P1": "9.3", "P3": "9.8", "P5": "10.1", "P10": "10.5", "P15": "10.8", "P25": "11.3", "P50": "12.2", "P75": "13.1", "P85": "13.7", "P90": "14.1", "P95": "14.7", "P97": "15.1", "P99": "15.9", "P999": "17.3" } },
              { "name": 25, "uid": "2229866116", "values": { "age": 25, "P01": "8.7", "P1": "9.5", "P3": 10, "P5": "10.2", "P10": "10.7", "P15": 11, "P25": "11.4", "P50": "12.4", "P75": "13.3", "P85": "13.9", "P90": "14.3", "P95": "14.9", "P97": "15.3", "P99": "16.1", "P999": "17.6" } },
              { "name": 26, "uid": "630704040", "values": { "age": 26, "P01": "8.8", "P1": "9.6", "P3": "10.1", "P5": "10.4", "P10": "10.8", "P15": "11.1", "P25": "11.6", "P50": "12.5", "P75": "13.6", "P85": "14.1", "P90": "14.6", "P95": "15.2", "P97": "15.6", "P99": "16.4", "P999": 18 } },
              { "name": 27, "uid": "4073619105", "values": { "age": 27, "P01": "8.9", "P1": "9.7", "P3": "10.2", "P5": "10.5", "P10": 11, "P15": "11.3", "P25": "11.8", "P50": "12.7", "P75": "13.8", "P85": "14.4", "P90": "14.8", "P95": "15.4", "P97": "15.9", "P99": "16.7", "P999": "18.3" } },
              { "name": 28, "uid": "2086572634", "values": { "age": 28, "P01": 9, "P1": "9.9", "P3": "10.4", "P5": "10.7", "P10": "11.1", "P15": "11.5", "P25": 12, "P50": "12.9", "P75": 14, "P85": "14.6", "P90": 15, "P95": "15.7", "P97": "16.1", "P99": 17, "P999": "18.6" } },
              { "name": 29, "uid": "2507550460", "values": { "age": 29, "P01": "9.2", "P1": 10, "P3": "10.5", "P5": "10.8", "P10": "11.3", "P15": "11.6", "P25": "12.1", "P50": "13.1", "P75": "14.2", "P85": "14.8", "P90": "15.2", "P95": "15.9", "P97": "16.4", "P99": "17.3", "P999": "18.9" } },
              { "name": 30, "uid": "1164010091", "values": { "age": 30, "P01": "9.3", "P1": "10.1", "P3": "10.7", "P5": 11, "P10": "11.4", "P15": "11.8", "P25": "12.3", "P50": "13.3", "P75": "14.4", "P85": 15, "P90": "15.5", "P95": "16.2", "P97": "16.6", "P99": "17.5", "P999": "19.2" } },
              { "name": 31, "uid": "3228793166", "values": { "age": 31, "P01": "9.4", "P1": "10.3", "P3": "10.8", "P5": "11.1", "P10": "11.6", "P15": "11.9", "P25": "12.4", "P50": "13.5", "P75": "14.6", "P85": "15.2", "P90": "15.7", "P95": "16.4", "P97": "16.9", "P99": "17.8", "P999": "19.5" } },
              { "name": 32, "uid": "2440582334", "values": { "age": 32, "P01": "9.5", "P1": "10.4", "P3": "10.9", "P5": "11.2", "P10": "11.7", "P15": "12.1", "P25": "12.6", "P50": "13.7", "P75": "14.8", "P85": "15.5", "P90": "15.9", "P95": "16.6", "P97": "17.1", "P99": 18, "P999": "19.8" } },
              { "name": 33, "uid": "79372125", "values": { "age": 33, "P01": "9.6", "P1": "10.5", "P3": "11.1", "P5": "11.4", "P10": "11.9", "P15": "12.2", "P25": "12.8", "P50": "13.8", "P75": 15, "P85": "15.7", "P90": "16.1", "P95": "16.9", "P97": "17.3", "P99": "18.3", "P999": "20.1" } },
              { "name": 34, "uid": "2362803091", "values": { "age": 34, "P01": "9.7", "P1": "10.6", "P3": "11.2", "P5": "11.5", "P10": 12, "P15": "12.4", "P25": "12.9", "P50": 14, "P75": "15.2", "P85": "15.9", "P90": "16.3", "P95": "17.1", "P97": "17.6", "P99": "18.6", "P999": "20.4" } },
              { "name": 35, "uid": "2023835620", "values": { "age": 35, "P01": "9.8", "P1": "10.7", "P3": "11.3", "P5": "11.6", "P10": "12.2", "P15": "12.5", "P25": "13.1", "P50": "14.2", "P75": "15.4", "P85": "16.1", "P90": "16.6", "P95": "17.3", "P97": "17.8", "P99": "18.8", "P999": "20.7" } },
              { "name": 36, "uid": "2993730527", "values": { "age": 36, "P01": "9.9", "P1": "10.8", "P3": "11.4", "P5": "11.8", "P10": "12.3", "P15": "12.7", "P25": "13.2", "P50": "14.3", "P75": "15.6", "P85": "16.3", "P90": "16.8", "P95": "17.5", "P97": 18, "P99": "19.1", "P999": 21 } },
              { "name": 37, "uid": "538042987", "values": { "age": 37, "P01": 10, "P1": 11, "P3": "11.6", "P5": "11.9", "P10": "12.4", "P15": "12.8", "P25": "13.4", "P50": "14.5", "P75": "15.8", "P85": "16.5", "P90": 17, "P95": "17.8", "P97": "18.3", "P99": "19.3", "P999": "21.2" } },
              { "name": 38, "uid": "2477976915", "values": { "age": 38, "P01": "10.1", "P1": "11.1", "P3": "11.7", "P5": 12, "P10": "12.6", "P15": "12.9", "P25": "13.5", "P50": "14.7", "P75": "15.9", "P85": "16.7", "P90": "17.2", "P95": 18, "P97": "18.5", "P99": "19.6", "P999": "21.5" } },
              { "name": 39, "uid": "1933586597", "values": { "age": 39, "P01": "10.2", "P1": "11.2", "P3": "11.8", "P5": "12.2", "P10": "12.7", "P15": "13.1", "P25": "13.7", "P50": "14.8", "P75": "16.1", "P85": "16.9", "P90": "17.4", "P95": "18.2", "P97": "18.7", "P99": "19.8", "P999": "21.8" } },
              { "name": 40, "uid": "113334890", "values": { "age": 40, "P01": "10.3", "P1": "11.3", "P3": "11.9", "P5": "12.3", "P10": "12.8", "P15": "13.2", "P25": "13.8", "P50": 15, "P75": "16.3", "P85": "17.1", "P90": "17.6", "P95": "18.4", "P97": 19, "P99": "20.1", "P999": "22.1" } },
              { "name": 41, "uid": "909726333", "values": { "age": 41, "P01": "10.4", "P1": "11.4", "P3": "12.1", "P5": "12.4", "P10": 13, "P15": "13.4", "P25": 14, "P50": "15.2", "P75": "16.5", "P85": "17.3", "P90": "17.8", "P95": "18.6", "P97": "19.2", "P99": "20.3", "P999": "22.4" } },
              { "name": 42, "uid": "2372119879", "values": { "age": 42, "P01": "10.5", "P1": "11.5", "P3": "12.2", "P5": "12.5", "P10": "13.1", "P15": "13.5", "P25": "14.1", "P50": "15.3", "P75": "16.7", "P85": "17.5", "P90": 18, "P95": "18.9", "P97": "19.4", "P99": "20.6", "P999": "22.7" } },
              { "name": 43, "uid": "1733486684", "values": { "age": 43, "P01": "10.6", "P1": "11.7", "P3": "12.3", "P5": "12.7", "P10": "13.2", "P15": "13.6", "P25": "14.3", "P50": "15.5", "P75": "16.9", "P85": "17.7", "P90": "18.2", "P95": "19.1", "P97": "19.7", "P99": "20.8", "P999": 23 } },
              { "name": 44, "uid": "3599131016", "values": { "age": 44, "P01": "10.7", "P1": "11.8", "P3": "12.4", "P5": "12.8", "P10": "13.4", "P15": "13.8", "P25": "14.4", "P50": "15.7", "P75": "17.1", "P85": "17.9", "P90": "18.4", "P95": "19.3", "P97": "19.9", "P99": "21.1", "P999": "23.3" } },
              { "name": 45, "uid": "182517539", "values": { "age": 45, "P01": "10.8", "P1": "11.9", "P3": "12.5", "P5": "12.9", "P10": "13.5", "P15": "13.9", "P25": "14.6", "P50": "15.8", "P75": "17.3", "P85": "18.1", "P90": "18.6", "P95": "19.5", "P97": "20.1", "P99": "21.3", "P999": "23.6" } },
              { "name": 46, "uid": "1609782514", "values": { "age": 46, "P01": "10.9", "P1": 12, "P3": "12.7", "P5": 13, "P10": "13.6", "P15": "14.1", "P25": "14.7", "P50": 16, "P75": "17.4", "P85": "18.3", "P90": "18.9", "P95": "19.8", "P97": "20.4", "P99": "21.6", "P999": "23.9" } },
              { "name": 47, "uid": "3663334905", "values": { "age": 47, "P01": 11, "P1": "12.1", "P3": "12.8", "P5": "13.2", "P10": "13.8", "P15": "14.2", "P25": "14.9", "P50": "16.2", "P75": "17.6", "P85": "18.5", "P90": "19.1", "P95": 20, "P97": "20.6", "P99": "21.9", "P999": "24.2" } },
              { "name": 48, "uid": "3032606303", "values": { "age": 48, "P01": "11.1", "P1": "12.2", "P3": "12.9", "P5": "13.3", "P10": "13.9", "P15": "14.3", "P25": 15, "P50": "16.3", "P75": "17.8", "P85": "18.7", "P90": "19.3", "P95": "20.2", "P97": "20.9", "P99": "22.1", "P999": "24.5" } },
              { "name": 49, "uid": "3408935369", "values": { "age": 49, "P01": "11.2", "P1": "12.3", "P3": 13, "P5": "13.4", "P10": 14, "P15": "14.5", "P25": "15.2", "P50": "16.5", "P75": 18, "P85": "18.9", "P90": "19.5", "P95": "20.4", "P97": "21.1", "P99": "22.4", "P999": "24.8" } },
              { "name": 50, "uid": "1589457419", "values": { "age": 50, "P01": "11.3", "P1": "12.4", "P3": "13.1", "P5": "13.5", "P10": "14.2", "P15": "14.6", "P25": "15.3", "P50": "16.7", "P75": "18.2", "P85": "19.1", "P90": "19.7", "P95": "20.7", "P97": "21.3", "P99": "22.6", "P999": "25.1" } },
              { "name": 51, "uid": "2469851358", "values": { "age": 51, "P01": "11.4", "P1": "12.5", "P3": "13.3", "P5": "13.7", "P10": "14.3", "P15": "14.7", "P25": "15.4", "P50": "16.8", "P75": "18.4", "P85": "19.3", "P90": "19.9", "P95": "20.9", "P97": "21.6", "P99": "22.9", "P999": "25.4" } },
              { "name": 52, "uid": "2105380869", "values": { "age": 52, "P01": "11.5", "P1": "12.6", "P3": "13.4", "P5": "13.8", "P10": "14.4", "P15": "14.9", "P25": "15.6", "P50": 17, "P75": "18.6", "P85": "19.5", "P90": "20.1", "P95": "21.1", "P97": "21.8", "P99": "23.2", "P999": "25.7" } },
              { "name": 53, "uid": "3127741612", "values": { "age": 53, "P01": "11.6", "P1": "12.7", "P3": "13.5", "P5": "13.9", "P10": "14.6", "P15": 15, "P25": "15.7", "P50": "17.2", "P75": "18.8", "P85": "19.7", "P90": "20.3", "P95": "21.4", "P97": "22.1", "P99": "23.4", "P999": 26 } },
              { "name": 54, "uid": "3412750668", "values": { "age": 54, "P01": "11.7", "P1": "12.9", "P3": "13.6", "P5": 14, "P10": "14.7", "P15": "15.2", "P25": "15.9", "P50": "17.3", "P75": 19, "P85": "19.9", "P90": "20.6", "P95": "21.6", "P97": "22.3", "P99": "23.7", "P999": "26.3" } },
              { "name": 55, "uid": "988126842", "values": { "age": 55, "P01": "11.8", "P1": 13, "P3": "13.7", "P5": "14.1", "P10": "14.8", "P15": "15.3", "P25": 16, "P50": "17.5", "P75": "19.2", "P85": "20.1", "P90": "20.8", "P95": "21.8", "P97": "22.5", "P99": 24, "P999": "26.6" } },
              { "name": 56, "uid": "2605626522", "values": { "age": 56, "P01": "11.9", "P1": "13.1", "P3": "13.8", "P5": "14.3", "P10": "14.9", "P15": "15.4", "P25": "16.2", "P50": "17.7", "P75": "19.3", "P85": "20.3", "P90": 21, "P95": "22.1", "P97": "22.8", "P99": "24.2", "P999": 27 } },
              { "name": 57, "uid": "446950455", "values": { "age": 57, "P01": 12, "P1": "13.2", "P3": "13.9", "P5": "14.4", "P10": "15.1", "P15": "15.6", "P25": "16.3", "P50": "17.8", "P75": "19.5", "P85": "20.5", "P90": "21.2", "P95": "22.3", "P97": 23, "P99": "24.5", "P999": "27.3" } },
              { "name": 58, "uid": "882269578", "values": { "age": 58, "P01": 12, "P1": "13.3", "P3": "14.1", "P5": "14.5", "P10": "15.2", "P15": "15.7", "P25": "16.5", "P50": 18, "P75": "19.7", "P85": "20.7", "P90": "21.4", "P95": "22.5", "P97": "23.3", "P99": "24.8", "P999": "27.6" } },
              { "name": 59, "uid": "3274138806", "values": { "age": 59, "P01": "12.1", "P1": "13.4", "P3": "14.2", "P5": "14.6", "P10": "15.3", "P15": "15.8", "P25": "16.6", "P50": "18.2", "P75": "19.9", "P85": "20.9", "P90": "21.6", "P95": "22.8", "P97": "23.5", "P99": 25, "P999": "27.9" } },
              { "name": 60, "uid": "2229502958", "values": { "age": 60, "P01": "12.2", "P1": "13.5", "P3": "14.3", "P5": "14.7", "P10": "15.5", "P15": 16, "P25": "16.7", "P50": "18.3", "P75": "20.1", "P85": "21.1", "P90": "21.9", "P95": 23, "P97": "23.8", "P99": "25.3", "P999": "28.2" } }
          ];

          const convertedAge = umar(age_unit, age);
          const convertedWeight = wazan(w_unit, weight);

          let result = {};
          
          if (isNaN(convertedWeight)) {
              result.error = 'Please! Check your input.';
              return result;
          }

          if (isNaN(convertedAge)) {
              result.error = 'Please! Check your input.';
              return result;
          }

          if (convertedAge > 0 && convertedAge <= 5) {
              const ageInMonths = convertedAge * 12;
              let take_row = null;

              if (gender == 0) { // Girls
                  if (ageInMonths <= 13 * 0.23) {
                      for (let i = 0; i < girls_to_13w.length; i++) {
                          if ((ageInMonths <= 0.23 * girls_to_13w[i].values.age) && 
                              (i === 0 || ageInMonths > 0.23 * girls_to_13w[i-1].values.age)) {
                              take_row = girls_to_13w[i].values;
                              break;
                          }
                      }
                  } else {
                      for (let i = 0; i < girls_to_5y.length; i++) {
                          if ((ageInMonths <= girls_to_5y[i].values.age) && 
                              (i == 0 || ageInMonths > girls_to_5y[i-1].values.age)) {
                              take_row = girls_to_5y[i].values;
                              break;
                          }
                      }
                  }
              } else if (gender == 1) { // Boys
                  if (ageInMonths <= 13 * 0.23) {
                      for (let i = 0; i < boys_to_13w.length; i++) {
                          if ((ageInMonths <= 0.23 * boys_to_13w[i].values.age) && 
                              (i == 0 || ageInMonths > 0.23 * boys_to_13w[i-1].values.age)) {
                              take_row = boys_to_13w[i].values;
                              break;
                          }
                      }
                  } else {
                      for (let i = 0; i < boys_to_5y.length; i++) {
                          if ((ageInMonths <= boys_to_5y[i].values.age) && 
                              (i == 0 || ageInMonths > boys_to_5y[i-1].values.age)) {
                              take_row = boys_to_5y[i].values;
                              break;
                          }
                      }
                  }
              }

              if (!take_row) {
                  result.error = 'No matching data found for the given parameters.';
                  return result;
              }

              // Convert string values to numbers in take_row
              Object.keys(take_row).forEach(key => {
                  if (typeof take_row[key] == 'string') {
                      take_row[key] = parseFloat(take_row[key]);
                  }
              });

              let first_ans = 0;
              let percentile = 0;
              let line = '';
              let image = '';

              // Calculate percentile value
              if (convertedWeight <= take_row.P01) {
                  first_ans = 0.1;
              } else if (convertedWeight <= take_row.P1) {
                  first_ans = ((convertedWeight - take_row.P01) / (take_row.P1 - take_row.P01) * (1 - 0.1) + 0.1);
              } else if (convertedWeight <= take_row.P3) {
                  first_ans = ((convertedWeight - take_row.P1) / (take_row.P3 - take_row.P1) * (3 - 1) + 1);
              } else if (convertedWeight <= take_row.P5) {
                  first_ans = ((convertedWeight - take_row.P3) / (take_row.P5 - take_row.P3) * 2 + 3);
              } else if (convertedWeight <= take_row.P10) {
                  first_ans = ((convertedWeight - take_row.P5) / (take_row.P10 - take_row.P5) * 5 + 5);
              } else if (convertedWeight <= take_row.P15) {
                  first_ans = ((convertedWeight - take_row.P10) / (take_row.P15 - take_row.P10) * 5 + 10);
              } else if (convertedWeight <= take_row.P25) {
                  first_ans = ((convertedWeight - take_row.P15) / (take_row.P25 - take_row.P15) * 10 + 10);
              } else if (convertedWeight <= take_row.P50) {
                  first_ans = ((convertedWeight - take_row.P25) / (take_row.P50 - take_row.P25) * 25 + 25);
              } else if (convertedWeight <= take_row.P75) {
                  first_ans = ((convertedWeight - take_row.P50) / (take_row.P75 - take_row.P50) * 25 + 50);
              } else if (convertedWeight <= take_row.P85) {
                  first_ans = ((convertedWeight - take_row.P75) / (take_row.P85 - take_row.P75) * 10 + 75);
              } else if (convertedWeight <= take_row.P90) {
                  first_ans = ((convertedWeight - take_row.P85) / (take_row.P90 - take_row.P85) * 5 + 85);
              } else if (convertedWeight <= take_row.P95) {
                  first_ans = ((convertedWeight - take_row.P90) / (take_row.P95 - take_row.P90) * 5 + 90);
              } else if (convertedWeight <= take_row.P97) {
                  first_ans = ((convertedWeight - take_row.P95) / (take_row.P97 - take_row.P95) * 2 + 95);
              } else if (convertedWeight <= take_row.P99) {
                  first_ans = ((convertedWeight - take_row.P97) / (take_row.P99 - take_row.P97) * 2 + 97);
              } else if (convertedWeight <= take_row.P999) {
                  first_ans = ((convertedWeight - take_row.P99) / (take_row.P999 - take_row.P99) * 0.99 + 99);
              } else {
                  first_ans = 100;
              }

              first_ans = Math.round(first_ans * 100) / 100;

              // Determine percentile category
              if (convertedWeight <= take_row.P01) {
                  percentile = 0.1;
                  line = 'The result is below <b> 0.1 percentile </b><br /><br />It seems that your child may be short for their age. Check if they have always been in those ranges. <b>If they have entered these ranges recently, consult a doctor.</b>';
              } else if (convertedWeight <= take_row.P1) {
                  percentile = 1;
                  line = 'Between <b>0.1</b> and <b>1st percentile</b><br /><br />It seems that your child may be short for their age. Check if they have always been in those ranges. <b>If they have entered these ranges recently, consult a doctor.</b>';
              } else if (convertedWeight <= take_row.P3) {
                  percentile = 3;
                  line = 'Between <b>1st</b> and <b>3rd percentile</b><br /><br />It seems that your child may be short for their age. Check if they have always been in those ranges. <b>If they have entered these ranges recently, consult a doctor.</b>';
              } else if (convertedWeight <= take_row.P5) {
                  percentile = 5;
                  line = 'Between the <b>3rd</b> and <b>5th percentiles</b>';
              } else if (convertedWeight <= take_row.P10) {
                  percentile = 10;
                  line = 'Between the <b>5th</b> and <b>10th percentiles</b>';
              } else if (convertedWeight <= take_row.P15) {
                  percentile = 15;
                  line = 'Between the <b>10th</b> and <b>15th percentiles<b>';
              } else if (convertedWeight <= take_row.P25) {
                  percentile = 25;
                  line = 'Between the <b>15th</b> and <b>25th percentiles</b>';
              } else if (convertedWeight <= take_row.P50) {
                  percentile = 50;
                  line = 'Between the <b>25th</b> and <b>50th percentiles</b>';
              } else if (convertedWeight <= take_row.P75) {
                  percentile = 75;
                  line = 'Between the <b>50th</b> and <b>75th percentiles</b>';
              } else if (convertedWeight <= take_row.P85) {
                  percentile = 85;
                  line = 'Between the <b>75th</b> and <b>85th percentiles</b>';
              } else if (convertedWeight <= take_row.P90) {
                  percentile = 90;
                  line = 'Between the <b>85th</b> and <b>90th percentiles</b><br\\>';
              } else if (convertedWeight <= take_row.P95) {
                  percentile = 95;
                  line = 'Between the <b>90th</b> and <b>95th percentiles</b><br\\>';
              } else if (convertedWeight <= take_row.P97) {
                  percentile = 97;
                  line = 'Between the <b>95th</b> and <b>97th percentiles</b><br\\>';
              } else if (convertedWeight <= take_row.P99) {
                  percentile = 99;
                  line = 'Between the <b>97th</b> and <b>99th percentiles</b><br /><br />It seems that your child is taller than their peers. Check if they have always been in those ranges. <b>If they have entered these ranges recently, consult a doctor.</b>';
              } else if (convertedWeight <= take_row.P999) {
                  percentile = 99.9;
                  line = 'Between the <b> 99th</b> and <b>99.9th percentiles</b><br /><br />It seems that your child is taller than their peers. Check if they have always been in those ranges. <b>If they have entered these ranges recently, consult a doctor.</b>';
              } else {
                  percentile = 100;
                  line = 'The result is above the <b>99.9th percentile</b><br /><br />It seems that your child is taller than their peers. Check if they have always been in those ranges. <b>If they have entered these ranges recently, consult a doctor.</b>';
              }

              // Determine image based on percentile
              if (percentile < 3) {
                  image = "image_1";
              } else if (percentile == 3) {
                  image = "image_2";
              } else if (percentile < 4) {
                  image = "image_3";
              } else if (percentile < 5) {
                  image = "image_4";
              } else if (percentile == 5) {
                  image = "image_5";
              } else if (percentile < 10) {
                  image = "image_6";
              } else if (percentile < 15) {
                  image = "image_7";
              } else if (percentile == 15) {
                  image = "image_8";
              } else if (percentile < 20) {
                  image = "image_9";
              } else if (percentile < 25) {
                  image = "image_10";
              } else if (percentile == 25) {
                  image = "image_11";
              } else if (percentile < 37) {
                  image = "image_12";
              } else if (percentile < 50) {
                  image = "image_13";
              } else if (percentile == 50) {
                  image = "image_14";
              } else if (percentile < 63) {
                  image = "image_15";
              } else if (percentile < 75) {
                  image = "image_16";
              } else if (percentile == 75) {
                  image = "image_17";
              } else if (percentile < 80) {
                  image = "image_18";
              } else if (percentile < 85) {
                  image = "image_19";
              } else if (percentile == 85) {
                  image = "image_20";
              } else if (percentile < 90) {
                  image = "image_21";
              } else if (percentile < 95) {
                  image = "image_22";
              } else if (percentile == 95) {
                  image = "image_23";
              } else if (percentile < 96) {
                  image = "image_24";
              } else if (percentile < 97) {
                  image = "image_25";
              } else if (percentile == 97) {
                  image = "image_26";
              } else if (percentile > 97) {
                  image = "image_27";
              }

              result.tech_first_ans = first_ans;
              result.tech_line = line;
              result.tech_image = image;

          } else {
              result.error = 'This BMI percentile calculator is only for children up to the age of 5.';
          }

          return result;
      }
        
           /**
    * getCalculationHeightCalculator: Service Method
    * POST: /api/calculators-lol/weight-percentile-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationHeightCalculator(body) {
      const result = {};
      const submit = body.tech_calculator_n || body.tech_calculator_name;

      if (submit == 'calculator1') {
        // Khamis-Roche Height Calculator
        const m_height_ft = body['tech_m-height-ft'];
        const m_height_in = body['tech_m-height-in'];
        const m_height_cm = body['tech_m-height-cm'];
        const m_unit_h = body.tech_mother_1_unit;

        const f_height_ft = body['tech_f-height-ft'];
        const f_height_in = body['tech_f-height-in'];
        const f_height_cm = body['tech_f-height-cm'];
        const f_unit_h = body.tech_father_1_unit;

        const c_height_ft = body['tech_c-height-ft'];
        const c_height_in = body['tech_c-height-in'];
        const c_height_cm = body['tech_c-height-cm'];
        const c_unit_h = body.tech_child_unit || body.tech_c_unit_h;

        const c_weight_lbs = body['tech_c-weight-lbs'];
        const c_weight_kg = body['tech_c-weight-kg'];
        const c_unit_w = body.tech_c_unit_w;

        const gender = body.tech_gender;
        const age = body.tech_age;

        const data = [
          {
            "4": [-0.087235, 1.23812, 0.50286, -10.2567],
            "4.5": [-0.074454, 1.15964, 0.52887, -10.719],
            "5": [-0.064778, 1.10674, 0.53919, -11.0213],
            "5.5": [-0.05776, 1.0748, 0.53691, -11.1556],
            "6": [-0.052947, 1.05923, 0.52513, -11.1138],
            "6.5": [-0.049892, 1.05542, 0.50692, -11.0221],
            "7": [-0.048144, 1.05877, 0.48538, -10.9984],
            "7.5": [-0.047256, 1.06467, 0.46361, -11.0214],
            "8": [-0.046778, 1.06853, 0.44469, -11.0696],
            "8.5": [-0.046261, 1.06572, 0.43171, -11.122],
            "9": [-0.045254, 1.05166, 0.42776, -11.1571],
            "9.5": [-0.043311, 1.02174, 0.43593, -11.1405],
            "10": [-0.039981, 0.97135, 0.45932, -12.0222],
            "10.5": [-0.034814, 0.89589, 0.50101, -10.8286],
            "11": [-0.02905, 0.81239, 0.54781, -10.4917],
            "11.5": [-0.024167, 0.74134, 0.58409, -10.0065],
            "12": [-0.020076, 0.68325, 0.60927, -9.3522],
            "12.5": [-0.016681, 0.63869, 0.62279, -8.6055],
            "13": [-0.013895, 0.60818, 0.62407, -7.8632],
            "13.5": [-0.011624, 0.59228, 0.61253, -7.1348],
            "14": [-0.009776, 0.59151, 0.58762, -6.4299],
            "14.5": [-0.008261, 0.60643, 0.54875, -5.7578],
            "15": [-0.006988, 0.63757, 0.49536, -5.1282],
            "15.5": [-0.005863, 0.68548, 0.42687, -4.5092],
            "16": [-0.004795, 0.75069, 0.34271, -3.9292],
            "16.5": [-0.003695, 0.83375, 0.24231, -3.4873],
            "17": [-0.00247, 0.9352, 0.1251, -3.283],
            "17.5": [-0.001027, 1.05558, -0.0095, -3.4156]
          },
          {
            "4": [-0.19435, 1.24768, 0.44774, -8.1325],
            "4.5": [-0.18519, 1.22177, 0.41381, -6.47656],
            "5": [-0.1753, 1.19932, 0.38467, -5.13583],
            "5.5": [-0.16484, 1.1788, 0.36039, -4.13791],
            "6": [-0.154, 1.15866, 0.34105, -3.51039],
            "6.5": [-0.14294, 1.13737, 0.32672, -3.14322],
            "7": [-0.13184, 1.11342, 0.31748, -2.87645],
            "7.5": [-0.12086, 1.08525, 0.3134, -2.66291],
            "8": [-0.11019, 1.05135, 0.31457, -2.45559],
            "8.5": [-0.09999, 1.01018, 0.32105, -2.20728],
            "9": [-0.09044, 0.9602, 0.33291, -1.87098],
            "9.5": [-0.08171, 0.89989, 0.35025, -1.0633],
            "10": [-0.07397, 0.82771, 0.37312, 0.33468],
            "10.5": [-0.06739, 0.74213, 0.40161, 1.97366],
            "11": [-0.06136, 0.67173, 0.42042, 3.50436],
            "11.5": [-0.05518, 0.6415, 0.41686, 4.57747],
            "12": [-0.04894, 0.64452, 0.3949, 4.84365],
            "12.5": [-0.04272, 0.67386, 0.3585, 4.27869],
            "13": [-0.03661, 0.7226, 0.31163, 3.21417],
            "13.5": [-0.03067, 0.78383, 0.25826, 1.83456],
            "14": [-0.025, 0.85062, 0.20235, 0.32425],
            "14.5": [-0.01967, 0.91605, 0.14787, -1.13224],
            "15": [-0.01477, 0.97319, 0.0988, -2.35055],
            "15.5": [-0.01037, 1.01514, 0.05909, -3.10326],
            "16": [-0.00655, 1.03496, 0.03272, -3.17885],
            "16.5": [-0.0034, 1.02573, 0.02364, -2.41657],
            "17": [-0.001, 0.98054, 0.03584, -0.65579],
            "17.5": [0.00057, 0.89246, 0.07327, 2.26429]
          }
        ];

        let m_height, f_height, c_height, c_weight;

        // Convert mother's height to inches
        if (m_unit_h == 'ft/in') {
          if (!m_height_ft || !isFinite(m_height_ft) || !m_height_in || !isFinite(m_height_in)) {
            result.error = "Please check mother's height input.";
            return result;
          }
          m_height = (parseFloat(m_height_ft) * 12) + parseFloat(m_height_in);
        } else {
          if (!m_height_cm || !isFinite(m_height_cm)) {
            result.error = "Please check mother's height input.";
            return result;
          }
          m_height = parseFloat(m_height_cm) / 2.54;
        }

        // Convert father's height to inches
        if (f_unit_h == 'ft/in') {
          if (!f_height_ft || !isFinite(f_height_ft) || !f_height_in || !isFinite(f_height_in)) {
            result.error = "Please check father's height input.";
            return result;
          }
          f_height = (parseFloat(f_height_ft) * 12) + parseFloat(f_height_in);
        } else {
          if (!f_height_cm || !isFinite(f_height_cm)) {
            result.error = "Please check father's height input.";
            return result;
          }
          f_height = parseFloat(f_height_cm) / 2.54;
        }

        // Convert child's height to inches
        if (c_unit_h == 'ft/in') {
          if (!c_height_ft || !isFinite(c_height_ft) || !c_height_in || !isFinite(c_height_in)) {
            result.error = "Please check child's height input.";
            return result;
          }
          c_height = (parseFloat(c_height_ft) * 12) + parseFloat(c_height_in);
        } else {
          if (!c_height_cm || !isFinite(c_height_cm)) {
            result.error = "Please check child's height input.";
            return result;
          }
          c_height = parseFloat(c_height_cm) / 2.54;
        }

        // Convert child's weight to pounds
        if (c_unit_w == 'lbs') {
          if (!c_weight_lbs || !isFinite(c_weight_lbs)) {
            result.error = "Please check child's weight input.";
            return result;
          }
          c_weight = parseFloat(c_weight_lbs);
        } else {
          if (!c_weight_kg || !isFinite(c_weight_kg)) {
            result.error = "Please check child's weight input.";
            return result;
          }
          c_weight = parseFloat(c_weight_kg) * 2.20462;
        }

        // Validation
        if (m_height <= 0) {
          result.error = "Mother's height must be greater than zero.";
          return result;
        }
        if (f_height <= 0) {
          result.error = "Father's height must be greater than zero.";
          return result;
        }
        if (c_weight <= 0) {
          result.error = "Child's weight must be greater than zero.";
          return result;
        }
        if (c_height <= 0) {
          result.error = "Child's height must be greater than zero.";
          return result;
        }

        // Calculate Khamis-Roche height (in inches)
        const d = data[parseInt(gender)][age];
        const khamis_height = d[0] * c_weight + d[1] * c_height + (d[2] * (m_height + f_height)) / 2 + d[3];
        const f_ans = (khamis_height < c_height) ? c_height : khamis_height;
        const final_ans_inches = Math.round(f_ans);

        // Gender and margin setup
        let sex, margin;
        if (gender == 0) {
          sex = "boys";
          margin = 2.1; // inches
        } else {
          sex = "girls";
          margin = 1.7; // inches
        }

        // Determine output format based on child's height unit
        const output_unit = (c_unit_h == 'ft/in') ? 'imperial' : 'metric';
        let final_ans, minHeight, maxHeight;

        if (output_unit == 'imperial') {
          const final_ans_in = Math.round(final_ans_inches % 12);
          const final_ans_feet = Math.floor(final_ans_inches / 12);
          final_ans = final_ans_feet + 'ft ' + final_ans_in + 'in';

          const minH = Math.round(f_ans - margin);
          const minHeight_in = Math.round(minH % 12);
          const minHeight_feet = Math.floor(minH / 12);
          minHeight = minHeight_feet + 'ft ' + minHeight_in + 'in';

          const maxH = Math.round(f_ans + margin);
          const maxHeight_in = Math.round(maxH % 12);
          const maxHeight_feet = Math.floor(maxH / 12);
          maxHeight = maxHeight_feet + 'ft ' + maxHeight_in + 'in';
        } else {
          final_ans = Math.round(final_ans_inches * 2.54) + ' cm';
          minHeight = Math.round((f_ans - margin) * 2.54) + ' cm';
          maxHeight = Math.round((f_ans + margin) * 2.54) + ' cm';
          margin = Math.round(margin * 2.54 * 100) / 100;
        }

        // Set response parameters
        result.tech_click_val = output_unit;
        result.tech_submit = submit;
        result.tech_final_ans = final_ans;
        result.tech_minHeight = minHeight;
        result.tech_maxHeight = maxHeight;
        result.tech_sex = sex;
        result.tech_mother_h = m_height_cm || (m_height * 2.54);
        result.tech_father_h = f_height_cm || (f_height * 2.54);
        result.tech_gender = gender;
        result.tech_margin = margin;
        result.tech_disable = "disable";

        return result;

      } else {
        // Mid-Parental Height Calculator
        const m_height_ft = body['tech_m-height-ft'];
        const m_height_in = body['tech_m-height-in'];
        const f_height_ft = body['tech_f-height-ft'];
        const f_height_in = body['tech_f-height-in'];
        const m_height_cm = body['tech_height-cm'];
        const f_height_cm = body['tech_f-height-cm'];
        const mother_entry_unit = body.tech_mother_entry_unit;
        const father_entry_unit = body.tech_father_entry_unit;

        const ft_and_in_to_cm = (ft, inch) => {
          return (ft * 30.48) + (inch * 2.54);
        };

        const cm_to_ft_and_in = (cm) => {
          const inches = cm / 2.54;
          const feet = Math.floor(inches / 12);
          const inch = inches % 12;
          return feet + 'ft ' + Math.floor(inch) + 'in';
        };

        let m_height, f_height;

        // Process mother's height
        if (mother_entry_unit === 'ft/in') {
          if (!m_height_ft || !m_height_in) {
            result.error = "Please! Check your input for mother's height.";
            return result;
          }
          m_height = ft_and_in_to_cm(parseFloat(m_height_ft), parseFloat(m_height_in));
        } else {
          if (!m_height_cm) {
            result.error = "Please! Check your input for mother's height.";
            return result;
          }
          m_height = parseFloat(m_height_cm);
        }

        // Process father's height
        if (father_entry_unit === 'ft/in') {
          if (!f_height_ft || !f_height_in) {
            result.error = "Please! Check your input for father's height.";
            return result;
          }
          f_height = ft_and_in_to_cm(parseFloat(f_height_ft), parseFloat(f_height_in));
        } else {
          if (!f_height_cm) {
            result.error = "Please! Check your input for father's height.";
            return result;
          }
          f_height = parseFloat(f_height_cm);
        }

        const new_m_height = m_height;
        const new_f_height = f_height;

        if (isFinite(m_height) && isFinite(f_height)) {
          if (m_height > 0) {
            if (f_height > 0) {
              const margin = 4;
              const midparental_height = (m_height + f_height) / 2;
              const girls_height = midparental_height - 6.5;
              const boys_height = midparental_height + 6.5;

              const boy_mph = (new_f_height + new_m_height + 13) / 2;
              const girl_mph = (new_f_height + new_m_height - 13) / 2;

              let final_ans_boy = boy_mph;
              let final_ans_girl = girl_mph;

              let minHeightGirl = girls_height - margin;
              let maxHeightGirl = girls_height + margin;
              let minHeightBoy = boys_height - margin;
              let maxHeightBoy = boys_height + margin;

              const output_unit = mother_entry_unit;
              if (output_unit === 'ft/in') {
                final_ans_boy = cm_to_ft_and_in(final_ans_boy);
                final_ans_girl = cm_to_ft_and_in(final_ans_girl);
                minHeightGirl = cm_to_ft_and_in(minHeightGirl);
                maxHeightGirl = cm_to_ft_and_in(maxHeightGirl);
                minHeightBoy = cm_to_ft_and_in(minHeightBoy);
                maxHeightBoy = cm_to_ft_and_in(maxHeightBoy);
              } else {
                minHeightGirl = Math.round(minHeightGirl * 100) / 100;
                maxHeightGirl = Math.round(maxHeightGirl * 100) / 100;
                minHeightBoy = Math.round(minHeightBoy * 100) / 100;
                maxHeightBoy = Math.round(maxHeightBoy * 100) / 100;
              }

              result.tech_margin = margin;
              result.tech_submit = submit;
              result.tech_final_ans_boy = final_ans_boy;
              result.tech_final_ans_girl = final_ans_girl;
              result.tech_girls_height = girl_mph;
              result.tech_boys_height = boy_mph;
              result.tech_minHeightGirl = minHeightGirl;
              result.tech_maxHeightGirl = maxHeightGirl;
              result.tech_minHeightBoy = minHeightBoy;
              result.tech_maxHeightBoy = maxHeightBoy;
              result.tech_mother_height = new_m_height;
              result.tech_father_height = new_f_height;
              result.tech_mother_entry_unit = mother_entry_unit;
              result.tech_father_entry_unit = father_entry_unit;
              result.tech_disable = "disable";

              return result;
            } else {
              result.error = "Father's height must be greater than zero.";
              return result;
            }
          } else {
            result.error = "Mother's height must be greater than zero.";
            return result;
          }
        } else {
          result.error = 'Please! Check your input.';
          return result;
        }
      }
    }


     /**
    * getCalculationPaceCalculator: Service Method
    * POST: /api/calculators-lol/pace-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

      async getCalculationPaceCalculator(body) {
        // Helper functions
        const gethours = (total_sec = '') => {
            return String(Math.floor(total_sec / 3600)).padStart(2, "0");
        };

        const getmins = (total_sec = '') => {
            const mins = total_sec - (gethours(total_sec) * 3600);
            return String(Math.floor(mins / 60)).padStart(2, "0");
        };

        const getsecs = (value = '') => {
            return String(Math.round(value - (gethours(value) * 3600) - (getmins(value) * 60))).padStart(2, "0");
        };

        const gettime = (seconds) => {
            const hour = gethours(seconds);
            const mins = getmins(seconds);
            const sec = getsecs(seconds);
            return `${hour} : ${mins} : ${sec}`;
        };

        const request = body;
        const type = request.tech_type;
        const time = request.tech_time;
        const dis = request.tech_dis;
        const dis_unit = request.tech_dis_unit;
        const event = request.tech_event;
        let pace = request.tech_pace;
        const per = request.tech_per;

        const result = { };

        try { 

        if (request.tech_calculator_name == 'calculator3') {
              if (!request.tech_from) {
                  result.error = 'Please! Enter Valid Elapsed Time.';
                  return result;
              }

              const pace = request.tech_from;
              const to = request.tech_to;
              const per = request.tech_fromu;
              
              if (per == '1' || per == '2') {
                  const paceArr = pace.split(':');
                  let pace_check = true;
                  
                  // Check if all parts are numeric
                  paceArr.forEach(value => {
                      if (isNaN(parseFloat(value))) {
                          pace_check = false;
                      }
                  });

                  if (!pace_check) {
                      result.error = 'Please! Enter Valid pace.';
                      return result;
                  }

                  let hour, min, sec, tsec, thour, tmin;

                  if (paceArr.length === 3) {
                      hour = parseFloat(paceArr[0]);
                      min = parseFloat(paceArr[1]);
                      sec = parseFloat(paceArr[2]);
                      tsec = (hour * 60 * 60) + (min * 60) + sec;
                      thour = hour + (min / 60) + (sec / (60 * 60));
                      tmin = (hour * 60) + min + (sec / 60);
                  } else if (paceArr.length === 2) {
                      min = parseFloat(paceArr[0]);
                      sec = parseFloat(paceArr[1]);
                      tsec = (min * 60) + sec;
                      thour = (min / 60) + (sec / (60 * 60));
                      tmin = min + (sec / 60);
                  } else if (paceArr.length === 1) {
                      sec = parseFloat(paceArr[0]);
                      tsec = sec;
                      thour = (sec / (60 * 60));
                      tmin = (sec / 60);
                  }

                  // Rest of the calculation logic for per=1 or per=2
                  if (per == '1') {
                      switch (to) {
                          case '1':
                              result.tech_res = gettime(tsec);
                              break;
                          case '2':
                              result.tech_res = gettime(tsec * 0.621371);
                              break;
                          case '3':
                              result.tech_res = Number((1 / thour).toFixed(3));
                              break;
                          case '4':
                              result.tech_res = Number((1 / thour * 1.609344).toFixed(3));
                              break;
                          case '5':
                              result.tech_res = Number((1 / thour * 26.8224).toFixed(3));
                              break;
                          case '6':
                              result.tech_res = Number((1 / thour / 2.237).toFixed(3));
                              break;
                          case '7':
                              result.tech_res = Number((1 / thour * 29.3333).toFixed(3));
                              break;
                          case '8':
                              result.tech_res = Number((1 / thour * 0.488889).toFixed(3));
                              break;
                      }
                  } else {
                      tsec = tsec * 1.609344;
                      thour = thour * 1.609344;
                      
                      switch (to) {
                          case '1':
                              result.tech_res = gettime(tsec);
                              break;
                          case '2':
                              result.tech_res = gettime(tsec * 0.621371);
                              break;
                          case '3':
                              result.tech_res = Number((1 / thour).toFixed(3));
                              break;
                          case '4':
                              result.tech_res = Number((1 / thour * 1.609344).toFixed(3));
                              break;
                          case '5':
                              result.tech_res = Number((1 / thour * 26.8224).toFixed(3));
                              break;
                          case '6':
                              result.tech_res = Number((1 / thour / 2.237).toFixed(3));
                              break;
                          case '7':
                              result.tech_res = Number((1 / thour * 29.3333).toFixed(3));
                              break;
                          case '8':
                              result.tech_res = Number((1 / thour * 0.488889).toFixed(3));
                              break;
                      }
                  }
              } else {
                  // This section is for per=3,4,5,6,7,8 where pace should be a number
                  // Convert to number first
                  const paceNum = parseFloat(pace);
                  // FIXED: Corrected the condition - should be OR not AND
                  if (paceNum <= 0 || isNaN(paceNum)) {
                      result.error = 'Please! Enter positive value of pace.';
                      return result;
                  }

                  let tsec, thour;

                  switch (per) {
                      case '3':
                          tsec = (60 / paceNum) * 60;
                          thour = (60 / paceNum) / 60;
                          break;
                      case '4':
                          tsec = ((60 / paceNum) * 60) * 1.609344;
                          thour = ((60 / paceNum) / 60) * 1.609344;
                          break;
                      case '5':
                          tsec = (26.8224 / paceNum) * 60 * 60;
                          thour = (26.8224 / paceNum);
                          break;
                      case '6':
                          tsec = (26.8224 / paceNum) * 60;
                          thour = (26.8224 / paceNum) / 60;
                          break;
                      case '7':
                          tsec = (29.3333 / paceNum) * 60 * 60;
                          thour = (29.3333 / paceNum);
                          break;
                      case '8':
                          tsec = (29.3333 / paceNum) * 60;
                          thour = (29.3333 / paceNum) / 60;
                          break;
                  }

                  switch (to) {
                      case '1':
                          result.tech_res = gettime(tsec);
                          break;
                      case '2':
                          result.tech_res = gettime(tsec * 0.621371);
                          break;
                      case '3':
                          result.tech_res = Number((1 / thour).toFixed(3));
                          break;
                      case '4':
                          result.tech_res = Number((1 / thour * 1.609344).toFixed(3));
                          break;
                      case '5':
                          result.tech_res = Number((1 / thour * 26.8224).toFixed(3));
                          break;
                      case '6':
                          result.tech_res = Number((1 / thour / 2.237).toFixed(3));
                          break;
                      case '7':
                          result.tech_res = Number((1 / thour * 29.3333).toFixed(3));
                          break;
                      case '8':
                          result.tech_res = Number((1 / thour * 0.488889).toFixed(3));
                          break;
                  }
              }

              return result;
          } else if (request.tech_calculator_name == 'calculator4') {
                if (isNaN(request.tech_fdis) || !request.tech_ftime || isNaN(request.tech_ffdis)) {
                    result.error = 'Please! Check your input.';
                    return result;
                }

                const time = request.tech_ftime;
                const dis = parseFloat(request.tech_fdis);
                const dis_unit = request.tech_fdis_unit;
                const fdis = parseFloat(request.tech_ffdis);
                const fdis_unit = request.tech_ffdis_unit;

                const timeArr = time.split(':');
                let time_check = true;
                
                timeArr.forEach(value => {
                    if (isNaN(value)) {
                        time_check = false;
                    }
                });

                if (!time_check) {
                    result.error = 'Please! Enter Valid Elapsed Time.';
                    return result;
                }

                let hour, min, sec, tsec, thour, tmin;

                if (timeArr.length == 3) {
                    hour = parseFloat(timeArr[0]);
                    min = parseFloat(timeArr[1]);
                    sec = parseFloat(timeArr[2]);
                    tsec = (hour * 60 * 60) + (min * 60) + sec;
                    thour = hour + (min / 60) + (sec / (60 * 60));
                    tmin = (hour * 60) + min + (sec / 60);
                } else if (timeArr.length == 2) {
                    min = parseFloat(timeArr[0]);
                    sec = parseFloat(timeArr[1]);
                    tsec = (min * 60) + sec;
                    thour = (min / 60) + (sec / (60 * 60));
                    tmin = min + (sec / 60);
                } else if (timeArr.length == 1) {
                    sec = parseFloat(timeArr[0]);
                    tsec = sec;
                    thour = (sec / (60 * 60));
                    tmin = (sec / 60);
                }

                let dis_mi, dis_km, dis_m, dis_yd;

                switch (dis_unit) {
                    case 'mi':
                        dis_mi = dis;
                        dis_km = dis * 1.609344;
                        dis_m = dis * 1609.344;
                        dis_yd = dis * 1760;
                        break;
                    case 'km':
                        dis_mi = dis * 0.621371;
                        dis_km = dis;
                        dis_m = dis * 1000;
                        dis_yd = dis * 1093.613;
                        break;
                    case 'm':
                        dis_mi = dis * 0.000621371;
                        dis_km = dis / 1000;
                        dis_m = dis;
                        dis_yd = dis * 1.093613;
                        break;
                    case 'yd':
                        dis_mi = dis * 0.000568182;
                        dis_km = dis * 0.0009144;
                        dis_m = dis * 0.9144;
                        dis_yd = dis;
                        break;
                }

                result.tech_mi_h = Number((dis_mi / thour).toFixed(2));
                result.tech_km_h = Number((dis_km / thour).toFixed(2));
                result.tech_m_m = Number((dis_m / tmin).toFixed(2));
                result.tech_m_s = Number((dis_m / tsec).toFixed(2));
                result.tech_yd_m = Number((dis_yd / tmin).toFixed(2));
                result.tech_yd_s = Number((dis_yd / tsec).toFixed(2));
                
                result.tech_pacekm = tsec / dis_km;
                result.tech_pace = tsec / dis_mi;

                let main;
                switch (fdis_unit) {
                    case 'mi':
                        main = tsec / dis_mi;
                        result.tech_main = gettime(main * fdis);
                        break;
                    case 'km':
                        main = tsec / dis_km;
                        result.tech_main = gettime(main * fdis);
                        break;
                    case 'm':
                        main = tsec / dis_m;
                        result.tech_main = gettime(main * fdis);
                        break;
                    case 'yd':
                        main = tsec / dis_yd;
                        result.tech_main = gettime(main * fdis);
                        break;
                }

                return result;

            } else if (request.tech_calculator_name == 'calculator2') {
                let check = false;
                let per_dis = 0;
                let per_time = 0;
                let table = '';
                let atime = 0;
                const mile_secs = [];
                let stime = 0;

                for (let i = 1; i <= 8; i++) {
                    const timeField = request[`tech_time${i}`];
                    const disField = request[`tech_dis${i}`];
                    
                    if (timeField && !isNaN(disField)) {
                        check = true;
                        const time = timeField;
                        const dis = parseFloat(disField);
                        const dis_unit = request[`tech_dis_unit${i}`];

                        const timeArr = time.split(':');
                        let time_check = true;
                        
                        timeArr.forEach(value => {
                            if (isNaN(value)) {
                                time_check = false;
                            }
                        });

                        if (!time_check) {
                            result.error = `Please! Enter Valid Time for element #${i}.`;
                            return result;
                        }

                        let hour, min, sec, tsec, thour, tmin;

                        if (timeArr.length == 3) {
                            hour = parseFloat(timeArr[0]);
                            min = parseFloat(timeArr[1]);
                            sec = parseFloat(timeArr[2]);
                            tsec = (hour * 60 * 60) + (min * 60) + sec;
                            thour = hour + (min / 60) + (sec / (60 * 60));
                            tmin = (hour * 60) + min + (sec / 60);
                        } else if (timeArr.length == 2) {
                            min = parseFloat(timeArr[0]);
                            sec = parseFloat(timeArr[1]);
                            tsec = (min * 60) + sec;
                            thour = (min / 60) + (sec / (60 * 60));
                            tmin = min + (sec / 60);
                        } else if (timeArr.length == 1) {
                            sec = parseFloat(timeArr[0]);
                            tsec = sec;
                            thour = (sec / (60 * 60));
                            tmin = (sec / 60);
                        }

                        let dis_mi, dis_km, dis_m, dis_yd;

                        switch (dis_unit) {
                            case 'mi':
                                dis_mi = dis;
                                dis_km = dis * 1.609344;
                                dis_m = dis * 1609.344;
                                dis_yd = dis * 1760;
                                break;
                            case 'km':
                                dis_mi = dis * 0.621371;
                                dis_km = dis;
                                dis_m = dis * 1000;
                                dis_yd = dis * 1093.613;
                                break;
                            case 'm':
                                dis_mi = dis * 0.000621371;
                                dis_km = dis / 1000;
                                dis_m = dis;
                                dis_yd = dis * 1.093613;
                                break;
                            case 'yd':
                                dis_mi = dis * 0.000568182;
                                dis_km = dis * 0.0009144;
                                dis_m = dis * 0.9144;
                                dis_yd = dis;
                                break;
                        }

                        if (per_time >= tsec) {
                            result.error = `The time of element #${i} must be greater than the last time.`;
                            return result;
                        }

                        let dis_main, pace;
                        const base_dis_unit = request.tech_dis_unit1;

                        switch (base_dis_unit) {
                            case 'km':
                                if (per_dis >= dis_km) {
                                    result.error = `The distance of element ${i} must be greater than the above distance.`;
                                    return result;
                                }
                                dis_km = dis_km - per_dis;
                                dis_main = dis_km;
                                tsec = tsec - per_time;
                                per_dis = per_dis + dis_km;
                                per_time = per_time + tsec;
                                dis_mi = dis_km * 0.621371;
                                pace = tsec / dis_mi;
                                break;
                            case 'mi':
                                if (per_dis >= dis_mi) {
                                    result.error = `The distance of element ${i} must be greater than the above distance.`;
                                    return result;
                                }
                                dis_mi = dis_mi - per_dis;
                                dis_main = dis_mi;
                                tsec = tsec - per_time;
                                per_dis = per_dis + dis_mi;
                                per_time = per_time + tsec;
                                pace = tsec / dis_mi;
                                break;
                            case 'm':
                                if (per_dis >= dis_m) {
                                    result.error = `The distance of element ${i} must be greater than the above distance.`;
                                    return result;
                                }
                                dis_m = dis_m - per_dis;
                                dis_main = dis_m;
                                tsec = tsec - per_time;
                                per_dis = per_dis + dis_m;
                                per_time = per_time + tsec;
                                dis_mi = dis_m * 0.000621371;
                                pace = tsec / dis_mi;
                                break;
                            case 'yd':
                                if (per_dis >= dis_yd) {
                                    result.error = `The distance of element ${i} must be greater than the above distance.`;
                                    return result;
                                }
                                dis_yd = dis_yd - per_dis;
                                dis_main = dis_yd;
                                tsec = tsec - per_time;
                                per_dis = per_dis + dis_yd;
                                per_time = per_time + tsec;
                                dis_mi = dis_yd * 0.000568182;
                                pace = tsec / dis_mi;
                                break;
                        }

                        atime = (atime + pace);
                        stime = atime / i;
                        table += `<tr><td class="border-b py-2">${i}</td><td class="border-b py-2">${Number(dis_main.toFixed(2))}</td><td class="border-b py-2">${gettime(tsec)}</td><td class="border-b py-2">${gettime(pace)}</td><td class="border-b py-2">${gettime(stime)}</td></tr>`;
                        mile_secs.push(Number(pace.toFixed(2)));
                    }
                }

                if (check) {
                    result.tech_table = table;
                    result.tech_stime = stime;
                    result.tech_mile_secs = mile_secs;
                    return result;
                }

            } else if (request.tech_calculator_name == 'calculator1') {
                if (type == 'pace') {
                    if (!time || isNaN(dis)) {
                        result.error = 'Please! Check your input.';
                        return result;
                    }

                    const timeArr = time.split(':');
                    let time_check = true;
                    
                    timeArr.forEach(value => {
                        if (isNaN(value)) {
                            time_check = false;
                        }
                    });

                    if (!time_check) {
                        result.error = 'Please! Enter Valid Time.';
                        return result;
                    }

                    let hour, min, sec, tsec, thour, tmin;

                    if (timeArr.length == 3) {
                        hour = parseFloat(timeArr[0]);
                        min = parseFloat(timeArr[1]);
                        sec = parseFloat(timeArr[2]);
                        tsec = (hour * 60 * 60) + (min * 60) + sec;
                        thour = hour + (min / 60) + (sec / (60 * 60));
                        tmin = (hour * 60) + min + (sec / 60);
                    } else if (timeArr.length == 2) {
                        min = parseFloat(timeArr[0]);
                        sec = parseFloat(timeArr[1]);
                        tsec = (min * 60) + sec;
                        thour = (min / 60) + (sec / (60 * 60));
                        tmin = min + (sec / 60);
                    } else if (timeArr.length === 1) {
                        sec = parseFloat(timeArr[0]);
                        tsec = sec;
                        thour = (sec / (60 * 60));
                        tmin = (sec / 60);
                    }

                    let dis_mi, dis_km, dis_m, dis_yd;

                    switch (dis_unit) {
                        case 'mi':
                            dis_mi = parseFloat(dis);
                            dis_km = dis * 1.609344;
                            dis_m = dis * 1609.344;
                            dis_yd = dis * 1760;
                            break;
                        case 'km':
                            dis_mi = dis * 0.621371;
                            dis_km = parseFloat(dis);
                            dis_m = dis * 1000;
                            dis_yd = dis * 1093.613;
                            break;
                        case 'm':
                            dis_mi = dis * 0.000621371;
                            dis_km = dis / 1000;
                            dis_m = parseFloat(dis);
                            dis_yd = dis * 1.093613;
                            break;
                        case 'yd':
                            dis_mi = dis * 0.000568182;
                            dis_km = dis * 0.0009144;
                            dis_m = dis * 0.9144;
                            dis_yd = parseFloat(dis);
                            break;
                    }

                    result.tech_mi_h = Number((dis_mi / thour).toFixed(2));
                    result.tech_km_h = Number((dis_km / thour).toFixed(2));
                    result.tech_m_m = Number((dis_m / tmin).toFixed(2));
                    result.tech_m_s = Number((dis_m / tsec).toFixed(2));
                    
                    const pacekm = tsec / dis_km;
                    const P_hour_km = gethours(pacekm);
                    const P_min_km = getmins(pacekm);
                    const P_sec_km = getsecs(pacekm);

                    const pace_val = tsec / dis_mi;
                    const P_hour_mi = gethours(pace_val);
                    const P_min_mi = getmins(pace_val);
                    const P_sec_mi = getsecs(pace_val);
                    
                    result.tech_pace_mi = `${P_hour_mi} : ${P_min_mi} : ${P_sec_mi}`;
                    result.tech_pace_km = `${P_hour_km} : ${P_min_km} : ${P_sec_km}`;
                    result.tech_dis_km = dis_km;
                    result.tech_dis_mi = dis_mi;
                    result.tech_pacekm = pacekm;
                    result.tech_pace = pace_val;
                    result.tech_share = pace_val;
                    return result;

                } else if (type == 'time') {
                    if (!pace || isNaN(dis)) {
                        result.error = 'Please! Check your input.';
                        return result;
                    }

                    let dis_mi, dis_km, dis_m, dis_yd;

                    switch (dis_unit) {
                        case 'mi':
                            dis_mi = parseFloat(dis);
                            dis_km = dis * 1.609344;
                            dis_m = dis * 1609.344;
                            dis_yd = dis * 1760;
                            break;
                        case 'km':
                            dis_km = parseFloat(dis);
                            dis_mi = dis * 0.621371;
                            dis_m = dis * 1000;
                            dis_yd = dis * 1093.613;
                            break;
                        case 'm':
                            dis_m = parseFloat(dis);
                            dis_mi = dis * 0.000621371;
                            dis_km = dis / 1000;
                            dis_yd = dis * 1.093613;
                            break;
                        case 'yd':
                            dis_yd = parseFloat(dis);
                            dis_mi = dis * 0.000568182;
                            dis_km = dis * 0.0009144;
                            dis_m = dis * 0.9144;
                            break;
                    }

                    let timeres, pacekm, pace_val;

                    if (per == '1' || per == '2') {
                        const paceArr = pace.split(':');
                        let pace_check = true;
                        
                        paceArr.forEach(value => {
                            if (isNaN(value)) {
                                pace_check = false;
                            }
                        });

                        if (!pace_check) {
                            result.error = 'Please! Enter Valid pace.';
                            return result;
                        }

                        let phour, pmin, psec, ptsec, pthour, ptmin;

                        if (paceArr.length == 3) {
                            phour = parseFloat(paceArr[0]);
                            pmin = parseFloat(paceArr[1]);
                            psec = parseFloat(paceArr[2]);
                            ptsec = (phour * 60 * 60) + (pmin * 60) + psec;
                            pthour = phour + (pmin / 60) + (psec / (60 * 60));
                            ptmin = (phour * 60) + pmin + (psec / 60);
                        } else if (paceArr.length == 2) {
                            pmin = parseFloat(paceArr[0]);
                            psec = parseFloat(paceArr[1]);
                            ptsec = (pmin * 60) + psec;
                            pthour = (pmin / 60) + (psec / (60 * 60));
                            ptmin = pmin + (psec / 60);
                        } else if (paceArr.length == 1) {
                            psec = parseFloat(paceArr[0]);
                            ptsec = psec;
                            pthour = (psec / (60 * 60));
                            ptmin = (psec / 60);
                        }

                        if (per == '1') {
                            timeres = dis_mi * ptsec;
                            pacekm = ptsec * 0.621371;
                            pace_val = ptsec;
                        } else {
                            timeres = dis_km * ptsec;
                            pace_val = ptsec * 1.609344;
                            pacekm = ptsec;
                        }
                    } else {
                        if ((pace < 0 && pace == 0) || isNaN(pace)) {
                            result.error = 'Please! Enter positive value of pace.';
                            return result;
                        }

                        pace = parseFloat(pace);
                        let tsec, thour;

                        switch (per) {
                            case '3':
                                tsec = dis_mi / pace;
                                timeres = tsec * 3600;
                                pace_val = timeres / dis_mi;
                                pacekm = pace_val * 0.621371;
                                break;
                            case '4':
                                tsec = dis_km / pace;
                                timeres = tsec * 3600;
                                pacekm = timeres / dis_km;
                                pace_val = pacekm * 1.609344;
                                break;
                            case '5':
                                tsec = dis_m / pace;
                                timeres = tsec * 60;
                                pacekm = timeres / dis_km;
                                pace_val = pacekm * 1.609344;
                                break;
                            case '6':
                                tsec = dis_m / pace;
                                timeres = tsec;
                                pacekm = timeres / dis_km;
                                pace_val = pacekm * 1.609344;
                                break;
                            case '7':
                                tsec = dis_yd / pace;
                                timeres = tsec * 60;
                                pacekm = timeres / dis_km;
                                pace_val = pacekm * 1.609344;
                                break;
                            case '8':
                                tsec = dis_yd / pace;
                                timeres = tsec;
                                pacekm = timeres / dis_km;
                                pace_val = pacekm * 1.609344;
                                break;
                        }
                    }

                    result.tech_dis_km = dis_km;
                    result.tech_dis_mi = dis_mi;
                    result.tech_timeres = timeres;
                    result.tech_pacekm = pacekm;
                    result.tech_pace = pace_val;
                    result.tech_share = pace_val;
                    return result;

                } else if (type == 'distance') {
                    if (!time || !pace) {
                        result.error = 'Please! Check your input.';
                        return result;
                    }

                    const timeArr = time.split(':');
                    let time_check = true;
                    
                    timeArr.forEach(value => {
                        if (isNaN(value)) {
                            time_check = false;
                        }
                    });

                    if (!time_check) {
                        result.error = 'Please! Enter Valid Time.';
                        return result;
                    }

                    let hour, min, sec, tsec, thour, tmin;

                    if (timeArr.length === 3) {
                        hour = parseFloat(timeArr[0]);
                        min = parseFloat(timeArr[1]);
                        sec = parseFloat(timeArr[2]);
                        tsec = (hour * 60 * 60) + (min * 60) + sec;
                        thour = hour + (min / 60) + (sec / (60 * 60));
                        tmin = (hour * 60) + min + (sec / 60);
                    } else if (timeArr.length == 2) {
                        min = parseFloat(timeArr[0]);
                        sec = parseFloat(timeArr[1]);
                        tsec = (min * 60) + sec;
                        thour = (min / 60) + (sec / (60 * 60));
                        tmin = min + (sec / 60);
                    } else if (timeArr.length == 1) {
                        sec = parseFloat(timeArr[0]);
                        tsec = sec;
                        thour = (sec / (60 * 60));
                        tmin = (sec / 60);
                    }

                    let dis_km, dis_mi, dis_m, dis_yd, pacekm, pace_val;

                    if (per == '1' || per == '2') {
                        const paceArr = pace.split(':');
                        let pace_check = true;
                        
                        paceArr.forEach(value => {
                            if (isNaN(value)) {
                                pace_check = false;
                            }
                        });

                        if (!pace_check) {
                            result.error = 'Please! Enter Valid pace.';
                            return result;
                        }

                        let phour, pmin, psec, ptsec, pthour, ptmin;

                        if (paceArr.length == 3) {
                            phour = parseFloat(paceArr[0]);
                            pmin = parseFloat(paceArr[1]);
                            psec = parseFloat(paceArr[2]);
                            ptsec = (phour * 60 * 60) + (pmin * 60) + psec;
                            pthour = phour + (pmin / 60) + (psec / (60 * 60));
                            ptmin = (phour * 60) + pmin + (psec / 60);
                        } else if (paceArr.length == 2) {
                            pmin = parseFloat(paceArr[0]);
                            psec = parseFloat(paceArr[1]);
                            ptsec = (pmin * 60) + psec;
                            pthour = (pmin / 60) + (psec / (60 * 60));
                            ptmin = pmin + (psec / 60);
                        } else if (paceArr.length == 1) {
                            psec = parseFloat(paceArr[0]);
                            ptsec = psec;
                            pthour = (psec / (60 * 60));
                            ptmin = (psec / 60);
                        }

                        if (per == '1') {
                            dis_mi = Number((tsec / ptsec).toFixed(3));
                            dis_km = Number((dis_mi * 1.609344).toFixed(3));
                            dis_m = Number((dis_mi * 1609.344).toFixed(3));
                            dis_yd = Number((dis_mi * 1760).toFixed(3));
                            pacekm = ptsec * 0.621371;
                            pace_val = ptsec;
                        } else {
                            dis_km = Number((tsec / ptsec).toFixed(3));
                            dis_mi = Number((dis_km * 0.621371).toFixed(3));
                            dis_m = Number((dis_km * 1000).toFixed(3));
                            dis_yd = Number((dis_km * 1093.613).toFixed(3));
                            pace_val = ptsec * 1.609344;
                            pacekm = ptsec;
                        }
                    } else {
                        if ((pace < 0 && pace == 0) || isNaN(pace)) {
                            result.error = 'Please! Enter positive value of pace.';
                            return result;
                        }

                        pace = parseFloat(pace);

                        switch (per) {
                            case '3':
                                dis_mi = pace * thour;
                                dis_km = Number((dis_mi * 1.609344).toFixed(3));
                                dis_m = Number((dis_mi * 1609.344).toFixed(3));
                                dis_yd = Number((dis_mi * 1760).toFixed(3));
                                pace_val = tsec / dis_mi;
                                pacekm = pace_val * 0.621371;
                                break;
                            case '4':
                                dis_km = pace * thour;
                                dis_mi = Number((dis_km * 0.621371).toFixed(3));
                                dis_m = Number((dis_km * 1000).toFixed(3));
                                dis_yd = Number((dis_km * 1093.613).toFixed(3));
                                pacekm = tsec / dis_km;
                                pace_val = pacekm * 1.609344;
                                break;
                            case '5':
                                dis_m = pace * tmin;
                                dis_mi = Number((dis_m * 0.000621371).toFixed(3));
                                dis_km = Number((dis_m / 1000).toFixed(3));
                                dis_yd = Number((dis_m * 1.093613).toFixed(3));
                                pacekm = tsec / dis_km;
                                pace_val = pacekm * 1.609344;
                                break;
                            case '6':
                                dis_m = pace * tsec;
                                dis_mi = Number((dis_m * 0.000621371).toFixed(3));
                                dis_km = Number((dis_m / 1000).toFixed(3));
                                dis_yd = Number((dis_m * 1.093613).toFixed(3));
                                pacekm = tsec / dis_km;
                                pace_val = pacekm * 1.609344;
                                break;
                            case '7':
                                dis_yd = pace * tmin;
                                dis_mi = Number((dis_yd * 0.000568182).toFixed(3));
                                dis_km = Number((dis_yd * 0.0009144).toFixed(3));
                                dis_m = Number((dis_yd * 0.9144).toFixed(3));
                                pacekm = tsec / dis_km;
                                pace_val = pacekm * 1.609344;
                                break;
                            case '8':
                                dis_yd = pace * tsec;
                                dis_mi = Number((dis_yd * 0.000568182).toFixed(3));
                                dis_km = Number((dis_yd * 0.0009144).toFixed(3));
                                dis_m = Number((dis_yd * 0.9144).toFixed(3));
                                pacekm = tsec / dis_km;
                                pace_val = pacekm * 1.609344;
                                break;
                        }
                    }

                    result.tech_dis_km = dis_km;
                    result.tech_dis_m = dis_m;
                    result.tech_dis_mi = dis_mi;
                    result.tech_dis_yd = dis_yd;
                    result.tech_pacekm = pacekm;
                    result.tech_pace = pace_val;
                    result.tech_share = pace_val;
                    return result;
                }
            } 

            // If no calculator matched
            result.error = 'Invalid calculator name';
            return result;

        } catch (error) {
            result.error = `Calculation error: ${error.message}`;
            return result;
        }
    }

     /**
    * getCalculationBodyFatPercentageCalculator: Service Method
    * POST: /api/calculators-lol/body-fat-percentage-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

     async getCalculationBodyFatPercentageCalculator(body) {
          // Helper functions
          const isNumeric = (value) => {
            return !isNaN(parseFloat(value)) && isFinite(value);
          };

          const round = (value, decimals) => {
            return Number(Math.round(value + 'e' + decimals) + 'e-' + decimals);
          };

          const convertMeasurements = (request, fields) => {
            const result = {};
            
            fields.forEach(field => {
              const unitField = `unit_${field}`;
              const value = parseFloat(request[field]);
              
              if (request[unitField] == 'in') {
                result[field] = value * 25.4;
              } else if (request[unitField] == 'cm') {
                result[field] = value * 10;
              } else {
                result[field] = value;
              }
            });
            
            return result;
          };

          const calculateBodyFatResults = (body_fat, weight, request, category, color, left) => {
            const body_fat_w = round(body_fat / 100 * weight, 2);
            const lbm = round(weight - body_fat_w, 2);
            
            let fat_weight = weight * (body_fat / 100);
            let fat_weight_result = fat_weight;
            
            if (request.unit != 'kg') {
              fat_weight_result = fat_weight * 2.205;
            }

            const param = {};
            param.tech_body_fat = body_fat;
            param.tech_color = color;
            param.tech_left = left;
            param.tech_category = category;
            param.tech_lbm = lbm + " " + request.unit;
            param.tech_body_fat_w = body_fat_w + " " + request.unit;
            param.tech_fat_weight = round(fat_weight, 2);
            param.tech_fat_weight_unit = request.unit;

            return param;
          };

          // Main calculation logic
          const handleSimpleCalculator = (request) => {
            const param = {};
            
            if (isNumeric(request.age) && 
                isNumeric(request.weight) && 
                isNumeric(request.gender) && 
                isNumeric(request.neck) && 
                isNumeric(request.waist) && 
                (isNumeric(request['height-ft']) || isNumeric(request['height-in']) || isNumeric(request['height-cm']))) {
              
              if (request.gender == 'Female' && (!request.hip || request.hip == '')) {
                param.error = 'Please fill all fields.';
                return param;
              }

              let age = parseFloat(request.age);
              let height_ft = parseFloat(request['height-ft']) || 0;
              let height_in = parseFloat(request['height-in']) || 0;
              let height_cm = parseFloat(request['height-cm']) || 0;
              let weight = parseFloat(request.weight);

              // Weight conversion
              if (request.unit == "lbs") {
                weight = weight / 2.205;
              }

              // Height conversion
              if (request.unit_ft_in == 'ft/in') {
                height_cm = height_ft * 30.48;
                if (height_in !== null && !isNaN(height_in)) {
                  height_in = height_in * 2.54;
                  height_cm = height_cm + height_in;
                }
              }

              let Waist_in = parseFloat(request.waist);
              let Hip_in = parseFloat(request.hip) || 0;
              let neck_in = parseFloat(request.neck);
              
              let Waist = parseFloat(request.waist);
              let Hip = parseFloat(request.hip) || 0;
              let neck = parseFloat(request.neck);

              // Unit conversions
              if (request.unit_n == 'In') {
                neck = neck * 2.54;
              }
              if (request.unit_w == 'In') {
                Waist = Waist * 2.54;
              }
              if (request.unit_hip == 'In') {
                Hip = Hip * 2.54;
              }
              if (request.unit_n == 'cm') {
                neck_in = neck_in / 2.54;
              }
              if (request.unit_w == 'cm') {
                Waist_in = Waist_in / 2.54;
              }
              if (request.unit_hip == 'cm') {
                Hip_in = Hip_in / 2.54;
              }

              const height_meters = height_cm / 100;
              const height_inch = height_cm / 2.54;
              const BMI = weight / (height_meters * height_meters);
              const weight_lbs = weight * 2.205;

              let body_fat, army, ymca, child_body_fat, adult_body_fat, category, color, left;

              if (request.gender == 'Female') {
                body_fat = round(495 / (1.29579 - 0.35004 * Math.log10(Waist + Hip - neck) + 0.22100 * Math.log10(height_cm)) - 450, 2);
                army = round((163.205 * Math.log10(Waist_in + Hip_in - neck_in)) - (97.684 * Math.log10(height_inch)) - 78.387, 2);
                ymca = round(((((4.15 * Waist_in) - (0.082 * weight_lbs)) - 76.76) / weight_lbs) * 100, 2);
                child_body_fat = round((1.51 * BMI) - (0.70 * age) - (3.6 * 0) + 1.4, 2);
                adult_body_fat = round((1.20 * BMI) + (0.23 * age) - (10.8 * 0) - 5.4, 2);

                if (body_fat <= 9) {
                  category = "N/A";
                  color = "red";
                  left = "-2%";
                } else if (body_fat > 9 && body_fat <= 13) {
                  category = "Essential fat";
                  param.tech_Essential = "blue text-white";
                  color = "#0D47A1";
                  left = "2%";
                } else if (body_fat > 13 && body_fat <= 20) {
                  category = "Athletes";
                  param.tech_Athletes = "teal text-white";
                  color = "#00897B";
                  left = "20%";
                } else if (body_fat > 20 && body_fat <= 24) {
                  category = "Fitness";
                  param.tech_Fitness = "green text-white";
                  color = "#00C853";
                  left = "40%";
                } else if (body_fat > 24 && body_fat <= 31) {
                  category = "Average";
                  param.tech_Average = "yellow text-white";
                  color = "#FFEA00";
                  left = "60%";
                } else {
                  category = "Obese";
                  param.tech_Obese = "red text-white";
                  color = "#FF1744";
                  left = "80%";
                }
              } else {
                body_fat = round(495 / (1.0324 - 0.19077 * Math.log10(Waist - neck) + 0.15456 * Math.log10(height_cm)) - 450, 2);
                army = round((86.010 * Math.log10(Waist_in - neck_in)) - (70.041 * Math.log10(height_inch)) + 36.76, 2);
                ymca = round(((((4.15 * Waist_in) - (0.082 * weight_lbs)) - 98.42) / weight_lbs) * 100, 2);
                child_body_fat = round((1.51 * BMI) - (0.70 * age) - (3.6 * 1) + 1.4, 2);
                adult_body_fat = round((1.20 * BMI) + (0.23 * age) - (10.8 * 1) - 5.4, 2);

                if (body_fat < 2) {
                  category = "N/A";
                  color = "red";
                  left = "0%";
                } else if (body_fat >= 2 && body_fat <= 5) {
                  category = "Essential fat";
                  param.tech_Essential = "blue text-white";
                  color = "#0D47A1";
                  left = "2%";
                } else if (body_fat > 5 && body_fat <= 13) {
                  category = "Athletes";
                  param.tech_Athletes = "teal text-white";
                  color = "#00897B";
                  left = "20%";
                } else if (body_fat > 13 && body_fat <= 17) {
                  category = "Fitness";
                  param.tech_Fitness = "green text-white";
                  color = "#00C853";
                  left = "40%";
                } else if (body_fat > 17 && body_fat <= 24) {
                  category = "Average";
                  param.tech_Average = "yellow text-white";
                  color = "#FFEA00";
                  left = "60%";
                } else {
                  category = "Obese";
                  param.tech_Obese = "red text-white";
                  color = "#FF1744";
                  left = "80%";
                }
              }

              const BAI = round((Hip / Math.pow(height_meters, 1.5)) - 18, 2);
              const fat_mass = round((army / 100) * weight, 2);
              const lean_mass = round(weight - fat_mass, 2);

              param.tech_body_fat = body_fat;
              param.tech_army = army;
              param.tech_ymca = ymca;
              param.tech_color = color;
              param.tech_left = left;
              param.tech_child_body_fat = child_body_fat;
              param.tech_adult_body_fat = adult_body_fat;
              param.tech_BAI = BAI;
              param.tech_fat_mass = fat_mass;
              param.tech_category = category;
              param.tech_lean_mass = lean_mass;

              return param;
            } else {
              param.error = 'Please fill all fields.';
              return param;
            }
          };

          const handleMethod1 = (request) => {
            const param = {};
            
            if (isNumeric(request.neck) && isNumeric(request.waist) && isNumeric(request.weight)) {
              const age = parseFloat(request.age);
              let weight = parseFloat(request.weight);
              const height_ft = parseFloat(request['height-ft']) || 0;
              const height_in = parseFloat(request['height-in']) || 0;
              const height_cm = parseFloat(request['height-cm']) || 0;
              
              let Waist_in = parseFloat(request.waist);
              let Hip_in = parseFloat(request.hip) || 0;
              let neck_in = parseFloat(request.neck);
              const hightUnit = request.hightUnit;

              // Unit conversions
              let Waist_cm, Hip_cm, neck_cm;

              if (request.unit_n == 'cm') {
                neck_in = request.neck / 2.54;
                neck_cm = parseFloat(request.neck);
              } else {
                neck_in = parseFloat(request.neck);
                neck_cm = neck_in * 2.54;
              }

              if (request.unit_w == 'cm') {
                Waist_in = request.waist / 2.54;
                Waist_cm = parseFloat(request.waist);
              } else {
                Waist_in = parseFloat(request.waist);
                Waist_cm = Waist_in * 2.54;
              }

              if (request.unit_hip == 'cm') {
                Hip_in = request.hip / 2.54;
                Hip_cm = parseFloat(request.hip);
              } else {
                Hip_in = parseFloat(request.hip);
                Hip_cm = Hip_in * 2.54;
              }

              // Height handling
              let height_in_cm, height_in_in;
              if (hightUnit == "cm") {
                if (!height_cm) {
                  param.error = 'Please enter height in cm.';
                  return param;
                }
                height_in_cm = height_cm;
                height_in_in = height_cm / 2.54;
              } else {
                if (!height_ft && !height_in) {
                  param.error = 'Please enter height in ft/in.';
                  return param;
                }
                height_in_in = (height_ft * 12) + height_in;
                height_in_cm = height_in_in * 2.54;
              }

              const height_meters = height_in_cm / 100;
              const BMI = weight / (height_meters * height_meters);
              
              let weight_lbs, weight_kg;
              if (request.unit == "lbs") {
                weight_lbs = weight;
                weight_kg = weight / 2.205;
              } else {
                weight_lbs = weight * 2.205;
                weight_kg = weight;
              }

              if (request.gender == 'Female') {
                if (!request.hip || request.hip == '') {
                  param.error = 'Please fill all fields.';
                  return param;
                }
              }

              let body_fat, fat_weight, category, color, left;
              let army, ymca, child_body_fat, adult_body_fat;

              if (request.gender == 'Female') {
                if (request.unit == "lbs") {
                  body_fat = (163.205 * Math.log10(Waist_in + Hip_in - neck_in)) - (97.684 * Math.log10(height_in_in)) - 78.387;
                  fat_weight = (body_fat / 100) * weight_lbs;
                } else {
                  body_fat = (495 / (1.29579 - (0.35004 * Math.log10(Waist_cm + Hip_cm - neck_cm)) + (0.22100 * Math.log10(height_in_cm)))) - 450;
                  fat_weight = (body_fat / 100) * weight_kg;
                }

                // Additional calculations
                army = round((163.205 * Math.log10(Waist_in + Hip_in - neck_in)) - (97.684 * Math.log10(height_in_in)) - 78.387, 2);
                ymca = round(((((4.15 * Waist_in) - (0.082 * weight_lbs)) - 76.76) / weight_lbs) * 100, 2);
                child_body_fat = round((1.51 * BMI) - (0.70 * age) - (3.6 * 0) + 1.4, 2);
                adult_body_fat = round((1.20 * BMI) + (0.23 * age) - (10.8 * 0) - 5.4, 2);

                if (body_fat <= 9) {
                  category = "N/A";
                  color = "red";
                  left = "-2%";
                } else if (body_fat > 9 && body_fat <= 13) {
                  category = "Essential fat";
                  param.tech_Essential = "blue text-white";
                  color = "#0D47A1";
                  left = "2%";
                } else if (body_fat > 13 && body_fat <= 20) {
                  category = "Athletes";
                  param.tech_Athletes = "teal text-white";
                  color = "#00897B";
                  left = "20%";
                } else if (body_fat > 20 && body_fat <= 24) {
                  category = "Fitness";
                  param.tech_Fitness = "green text-white";
                  color = "#00C853";
                  left = "40%";
                } else if (body_fat > 24 && body_fat <= 31) {
                  category = "Average";
                  param.tech_Average = "yellow text-white";
                  color = "#FFEA00";
                  left = "60%";
                } else {
                  category = "Obese";
                  param.tech_Obese = "red text-white";
                  color = "#FF1744";
                  left = "80%";
                }
              } else {
                if (request.unit == "lbs") {
                  body_fat = (86.010 * Math.log10(Waist_in - neck_in)) - (70.041 * Math.log10(height_in_in)) + 36.76;
                  fat_weight = (body_fat / 100) * weight_lbs;
                } else {
                  body_fat = (495 / (1.0324 - (0.19077 * Math.log10(Waist_cm - neck_cm)) + (0.15456 * Math.log10(height_in_cm)))) - 450;
                  fat_weight = (body_fat / 100) * weight_kg;
                }

                // Additional calculations
                army = round((86.010 * Math.log10(Waist_in - neck_in)) - (70.041 * Math.log10(height_in_in)) + 36.76, 2);
                ymca = round(((((4.15 * Waist_in) - (0.082 * weight_lbs)) - 98.42) / weight_lbs) * 100, 2);
                child_body_fat = round((1.51 * BMI) - (0.70 * age) - (3.6 * 1) + 1.4, 2);
                adult_body_fat = round((1.20 * BMI) + (0.23 * age) - (10.8 * 1) - 5.4, 2);

                if (body_fat < 2) {
                  category = "N/A";
                  color = "red";
                  left = "0%";
                } else if (body_fat > 1 && body_fat <= 5) {
                  category = "Essential fat";
                  param.tech_Essential = "blue text-white";
                  color = "#0D47A1";
                  left = "2%";
                } else if (body_fat > 5 && body_fat <= 13) {
                  category = "Athletes";
                  param.tech_Athletes = "teal text-white";
                  color = "#00897B";
                  left = "20%";
                } else if (body_fat > 13 && body_fat <= 17) {
                  category = "Fitness";
                  param.tech_Fitness = "green text-white";
                  color = "#00C853";
                  left = "40%";
                } else if (body_fat > 17 && body_fat <= 24) {
                  category = "Average";
                  param.tech_Average = "yellow text-white";
                  color = "#FFEA00";
                  left = "60%";
                } else {
                  category = "Obese";
                  param.tech_Obese = "red text-white";
                  color = "#FF1744";
                  left = "80%";
                }
              }

              let Hip = 0;
              if (request.unit_hip == 'cm') {
                Hip = parseFloat(request.hip);
              } else {
                Hip = parseFloat(request.hip) * 2.54;
              }

              const BAI = round((Hip / Math.pow(height_meters, 1.5)) - 18, 2);
              body_fat = round(body_fat, 2);
              const fat_mass = round((army / 100) * weight, 2);
              const lean_mass = round(weight - fat_mass, 2);

              param.tech_body_fat = body_fat;
              param.tech_army = body_fat;
              param.tech_ymca = ymca;
              param.tech_color = color;
              param.tech_left = left;
              param.tech_child_body_fat = child_body_fat;
              param.tech_adult_body_fat = adult_body_fat;
              param.tech_BAI = BAI;
              param.tech_fat_mass = fat_mass;
              param.tech_category = category;
              param.tech_lean_mass = lean_mass;
              param.tech_fat_weight = round(fat_weight, 2);
              param.tech_fat_weight_unit = request.unit;

              return param;
            } else {
              param.error = 'Please fill all fields.';
              return param;
            }
          };

          const handleMethod2 = (request) => {
            const param = {};
            
            if (isNumeric(request.chest) && isNumeric(request.abd) && 
                isNumeric(request.thigh) && isNumeric(request.tricep) && 
                isNumeric(request.sub) && isNumeric(request.sup) && 
                isNumeric(request.mid)) {
              
              const measurements = convertMeasurements(request, [
                'chest', 'abd', 'thigh', 'tricep', 'sub', 'sup', 'mid'
              ]);

              const sum = Object.values(measurements).reduce((a, b) => a + b, 0);
              const weight = parseFloat(request.weight);
              const age = parseFloat(request.age);

              let body_fat, category, color, left;

              if (request.gender == 'Male') {
                const body_den = 1.112 - (0.00043499 * sum) + (0.00000055 * Math.pow(sum, 2)) - (0.00028826 * age);
                body_fat = round((495 / body_den) - 450, 2);
                
                if (body_fat < 2) {
                  category = "N/A";
                  color = "red";
                  left = "0%";
                } else if (body_fat > 1 && body_fat <= 5) {
                  category = "Essential fat";
                  param.tech_Essential = "blue text-white";
                  color = "#0D47A1";
                  left = "2%";
                } else if (body_fat > 5 && body_fat <= 13) {
                  category = "Athletes";
                  param.tech_Athletes = "teal text-white";
                  color = "#00897B";
                  left = "20%";
                } else if (body_fat > 13 && body_fat <= 17) {
                  category = "Fitness";
                  param.tech_Fitness = "green text-white";
                  color = "#00C853";
                  left = "40%";
                } else if (body_fat > 17 && body_fat <= 24) {
                  category = "Average";
                  param.tech_Average = "yellow text-white";
                  color = "#FFEA00";
                  left = "60%";
                } else {
                  category = "Obese";
                  param.tech_Obese = "red text-white";
                  color = "#FF1744";
                  left = "80%";
                }
              } else {
                const body_den = 1.097 - (0.00046971 * sum) + (0.00000056 * Math.pow(sum, 2)) - (0.00012828 * age);
                body_fat = round((495 / body_den) - 450, 2);
                
                if (body_fat <= 9) {
                  category = "N/A";
                  color = "red";
                  left = "-2%";
                } else if (body_fat > 9 && body_fat <= 13) {
                  category = "Essential fat";
                  param.tech_Essential = "blue text-white";
                  color = "#0D47A1";
                  left = "2%";
                } else if (body_fat > 13 && body_fat <= 20) {
                  category = "Athletes";
                  param.tech_Athletes = "teal text-white";
                  color = "#00897B";
                  left = "20%";
                } else if (body_fat > 20 && body_fat <= 24) {
                  category = "Fitness";
                  param.tech_Fitness = "green text-white";
                  color = "#00C853";
                  left = "40%";
                } else if (body_fat > 24 && body_fat <= 31) {
                  category = "Average";
                  param.tech_Average = "yellow text-white";
                  color = "#FFEA00";
                  left = "60%";
                } else {
                  category = "Obese";
                  param.tech_Obese = "red text-white";
                  color = "#FF1744";
                  left = "80%";
                }
              }

              const body_fat_w = round(body_fat / 100 * weight, 2);
              const lbm = round(weight - body_fat_w, 2);
              
              let fat_weight = weight * (body_fat / 100);
              let fat_weight_result = fat_weight;
              
              if (request.unit != 'kg') {
                fat_weight_result = fat_weight * 2.205;
              }

              param.tech_body_fat = body_fat;
              param.tech_color = color;
              param.tech_left = left;
              param.tech_category = category;
              param.tech_lbm = lbm + " " + request.unit;
              param.tech_body_fat_w = body_fat_w + " " + request.unit;
              param.tech_fat_weight = round(fat_weight, 2);
              param.tech_fat_weight_unit = request.unit;

              return param;
            } else {
              param.error = 'Please fill all fields.';
              return param;
            }
          };

          const handleMethod3 = (request) => {
            const param = {};
            
            if (isNumeric(request.abd) && isNumeric(request.thigh) && 
                isNumeric(request.tricep) && isNumeric(request.sup)) {
              
              const measurements = convertMeasurements(request, ['abd', 'thigh', 'tricep', 'sup']);
              const sum = Object.values(measurements).reduce((a, b) => a + b, 0);
              const weight = parseFloat(request.weight);
              const age = parseFloat(request.age);

              let body_fat, category, color, left;

              if (request.gender == 'Male') {
                body_fat = round((0.29288 * sum) - (0.0005 * Math.pow(sum, 2)) + (0.15845 * age) - 5.76377, 2);
                
                if (body_fat < 2) {
                  category = "N/A";
                  color = "red";
                  left = "0%";
                } else if (body_fat > 1 && body_fat <= 5) {
                  category = "Essential fat";
                  param.tech_Essential = "blue text-white";
                  color = "#0D47A1";
                  left = "2%";
                } else if (body_fat > 5 && body_fat <= 13) {
                  category = "Athletes";
                  param.tech_Athletes = "teal text-white";
                  color = "#00897B";
                  left = "20%";
                } else if (body_fat > 13 && body_fat <= 17) {
                  category = "Fitness";
                  param.tech_Fitness = "green text-white";
                  color = "#00C853";
                  left = "40%";
                } else if (body_fat > 17 && body_fat <= 24) {
                  category = "Average";
                  param.tech_Average = "yellow text-white";
                  color = "#FFEA00";
                  left = "60%";
                } else {
                  category = "Obese";
                  param.tech_Obese = "red text-white";
                  color = "#FF1744";
                  left = "80%";
                }
              } else {
                body_fat = round((0.29669 * sum) - (0.00043 * Math.pow(sum, 2)) + (0.02963 * age) + 1.4072, 2);
                
                if (body_fat <= 9) {
                  category = "N/A";
                  color = "red";
                  left = "-2%";
                } else if (body_fat > 9 && body_fat <= 13) {
                  category = "Essential fat";
                  param.tech_Essential = "blue text-white";
                  color = "#0D47A1";
                  left = "2%";
                } else if (body_fat > 13 && body_fat <= 20) {
                  category = "Athletes";
                  param.tech_Athletes = "teal text-white";
                  color = "#00897B";
                  left = "20%";
                } else if (body_fat > 20 && body_fat <= 24) {
                  category = "Fitness";
                  param.tech_Fitness = "green text-white";
                  color = "#00C853";
                  left = "40%";
                } else if (body_fat > 24 && body_fat <= 31) {
                  category = "Average";
                  param.tech_Average = "yellow text-white";
                  color = "#FFEA00";
                  left = "60%";
                } else {
                  category = "Obese";
                  param.tech_Obese = "red text-white";
                  color = "#FF1744";
                  left = "80%";
                }
              }

              return calculateBodyFatResults(body_fat, weight, request, category, color, left);
            } else {
              param.error = 'Please fill all fields.';
              return param;
            }
          };

          const handleMethod4 = (request) => {
            const param = {};
            
            if (isNumeric(request.thigh) && isNumeric(request.tricep) && isNumeric(request.sup)) {
              const measurements = convertMeasurements(request, ['thigh', 'tricep', 'sup']);
              const sum = Object.values(measurements).reduce((a, b) => a + b, 0);
              const weight = parseFloat(request.weight);
              const age = parseFloat(request.age);

              let body_fat, category, color, left;

              if (request.gender == 'Male') {
                const body_den = 1.10938 - (0.0008267 * sum) + (0.0000016 * Math.pow(sum, 2)) - (0.0002574 * age);
                body_fat = round((495 / body_den) - 450, 2);
                
                if (body_fat < 2) {
                  category = "N/A";
                  color = "red";
                  left = "0%";
                } else if (body_fat > 1 && body_fat <= 5) {
                  category = "Essential fat";
                  param.tech_Essential = "blue text-white";
                  color = "#0D47A1";
                  left = "2%";
                } else if (body_fat > 5 && body_fat <= 13) {
                  category = "Athletes";
                  param.tech_Athletes = "teal text-white";
                  color = "#00897B";
                  left = "20%";
                } else if (body_fat > 13 && body_fat <= 17) {
                  category = "Fitness";
                  param.tech_Fitness = "green text-white";
                  color = "#00C853";
                  left = "40%";
                } else if (body_fat > 17 && body_fat <= 24) {
                  category = "Average";
                  param.tech_Average = "yellow text-white";
                  color = "#FFEA00";
                  left = "60%";
                } else {
                  category = "Obese";
                  param.tech_Obese = "red text-white";
                  color = "#FF1744";
                  left = "80%";
                }
              } else {
                const body_den = 1.0994921 - (0.0009929 * sum) + (0.0000023 * Math.pow(sum, 2)) - (0.0001392 * age);
                body_fat = round((495 / body_den) - 450, 2);
                
                if (body_fat <= 9) {
                  category = "N/A";
                  color = "red";
                  left = "-2%";
                } else if (body_fat > 9 && body_fat <= 13) {
                  category = "Essential fat";
                  param.tech_Essential = "blue text-white";
                  color = "#0D47A1";
                  left = "2%";
                } else if (body_fat > 13 && body_fat <= 20) {
                  category = "Athletes";
                  param.tech_Athletes = "teal text-white";
                  color = "#00897B";
                  left = "20%";
                } else if (body_fat > 20 && body_fat <= 24) {
                  category = "Fitness";
                  param.tech_Fitness = "green text-white";
                  color = "#00C853";
                  left = "40%";
                } else if (body_fat > 24 && body_fat <= 31) {
                  category = "Average";
                  param.tech_Average = "yellow text-white";
                  color = "#FFEA00";
                  left = "60%";
                } else {
                  category = "Obese";
                  param.tech_Obese = "red text-white";
                  color = "#FF1744";
                  left = "80%";
                }
              }

              return calculateBodyFatResults(body_fat, weight, request, category, color, left);
            } else {
              param.error = 'Please fill all fields.';
              return param;
            }
          };

          const handleMethod5 = (request) => {
            const param = {};
            
            if (isNumeric(request.chest) && isNumeric(request.abd) && 
                isNumeric(request.thigh) && isNumeric(request.tricep) && 
                isNumeric(request.sub) && isNumeric(request.sup) && 
                isNumeric(request.bicep) && isNumeric(request.back) && 
                isNumeric(request.calf)) {
              
              const measurements = convertMeasurements(request, [
                'chest', 'abd', 'thigh', 'tricep', 'sub', 'sup', 'bicep', 'back', 'calf'
              ]);

              const sum = Object.values(measurements).reduce((a, b) => a + b, 0);
              let weight = parseFloat(request.weight);
              
              if (request.unit == "kg") {
                weight = weight * 2.205;
              }
              
              const body_fat = round((27 * sum) / weight, 2);
              let category, color, left;

              if (request.gender == 'Male') {
                if (body_fat < 2) {
                  category = "N/A";
                  color = "red";
                  left = "0%";
                } else if (body_fat > 1 && body_fat <= 5) {
                  category = "Essential fat";
                  param.tech_Essential = "blue text-white";
                  color = "#0D47A1";
                  left = "2%";
                } else if (body_fat > 5 && body_fat <= 13) {
                  category = "Athletes";
                  param.tech_Athletes = "teal text-white";
                  color = "#00897B";
                  left = "20%";
                } else if (body_fat > 13 && body_fat <= 17) {
                  category = "Fitness";
                  param.tech_Fitness = "green text-white";
                  color = "#00C853";
                  left = "40%";
                } else if (body_fat > 17 && body_fat <= 24) {
                  category = "Average";
                  param.tech_Average = "yellow text-white";
                  color = "#FFEA00";
                  left = "60%";
                } else {
                  category = "Obese";
                  param.tech_Obese = "red text-white";
                  color = "#FF1744";
                  left = "80%";
                }
              } else {
                if (body_fat <= 9) {
                  category = "N/A";
                  color = "red";
                  left = "-2%";
                } else if (body_fat > 9 && body_fat <= 13) {
                  category = "Essential fat";
                  param.tech_Essential = "blue text-white";
                  color = "#0D47A1";
                  left = "2%";
                } else if (body_fat > 13 && body_fat <= 20) {
                  category = "Athletes";
                  param.tech_Athletes = "teal text-white";
                  color = "#00897B";
                  left = "20%";
                } else if (body_fat > 20 && body_fat <= 24) {
                  category = "Fitness";
                  param.tech_Fitness = "green text-white";
                  color = "#00C853";
                  left = "40%";
                } else if (body_fat > 24 && body_fat <= 31) {
                  category = "Average";
                  param.tech_Average = "yellow text-white";
                  color = "#FFEA00";
                  left = "60%";
                } else {
                  category = "Obese";
                  param.tech_Obese = "red text-white";
                  color = "#FF1744";
                  left = "80%";
                }
              }

              const body_fat_w = round(body_fat / 100 * weight, 2);
              const lbm = round(weight - body_fat_w, 2);
              
              let fat_weight = weight * (body_fat / 100);
              let fat_weight_result = fat_weight;
              
              if (request.unit != 'kg') {
                fat_weight_result = fat_weight * 2.205;
              }

              param.tech_body_fat = body_fat;
              param.tech_color = color;
              param.tech_left = left;
              param.tech_category = category;
              param.tech_lbm = lbm + " lbs";
              param.tech_body_fat_w = body_fat_w + " lbs";
              param.tech_fat_weight = round(fat_weight_result, 2);
              param.tech_fat_weight_unit = request.unit;

              return param;
            } else {
              param.error = 'Please fill all fields.';
              return param;
            }
          };

          const handleMethod6 = (request) => {
            const param = {};
            
            if (isNumeric(request.tricep) && isNumeric(request.sub) && 
                isNumeric(request.sup) && isNumeric(request.bicep)) {
              
              const measurements = convertMeasurements(request, ['tricep', 'sub', 'sup', 'bicep']);
              const sum = Object.values(measurements).reduce((a, b) => a + b, 0);
              const weight = parseFloat(request.weight);
              const age = parseFloat(request.age);

              let body_fat, category, color, left;

              if (request.gender == 'Male') {
                let body_den;
                const l = Math.log10(sum);
                
                if (age < 17) {
                  body_den = 1.1533 - (0.0643 * l);
                } else if (age >= 17 && age <= 19) {
                  body_den = 1.1620 - (0.0630 * l);
                } else if (age >= 20 && age <= 29) {
                  body_den = 1.1631 - (0.0632 * l);
                } else if (age >= 30 && age <= 39) {
                  body_den = 1.1422 - (0.0544 * l);
                } else if (age >= 40 && age <= 49) {
                  body_den = 1.1620 - (0.0700 * l);
                } else {
                  body_den = 1.1715 - (0.0779 * l);
                }
                
                body_fat = round((495 / body_den) - 450, 2);
                
                if (body_fat < 2) {
                  category = "N/A";
                  color = "red";
                  left = "0%";
                } else if (body_fat > 1 && body_fat <= 5) {
                  category = "Essential fat";
                  param.tech_Essential = "blue text-white";
                  color = "#0D47A1";
                  left = "2%";
                } else if (body_fat > 5 && body_fat <= 13) {
                  category = "Athletes";
                  param.tech_Athletes = "teal text-white";
                  color = "#00897B";
                  left = "20%";
                } else if (body_fat > 13 && body_fat <= 17) {
                  category = "Fitness";
                  param.tech_Fitness = "green text-white";
                  color = "#00C853";
                  left = "40%";
                } else if (body_fat > 17 && body_fat <= 24) {
                  category = "Average";
                  param.tech_Average = "yellow text-white";
                  color = "#FFEA00";
                  left = "60%";
                } else {
                  category = "Obese";
                  param.tech_Obese = "red text-white";
                  color = "#FF1744";
                  left = "80%";
                }
              } else {
                let body_den;
                const l = Math.log10(sum);
                
                if (age < 17) {
                  body_den = 1.1369 - (0.0598 * l);
                } else if (age >= 17 && age <= 19) {
                  body_den = 1.1549 - (0.0678 * l);
                } else if (age >= 20 && age <= 29) {
                  body_den = 1.1599 - (0.0717 * l);
                } else if (age >= 30 && age <= 39) {
                  body_den = 1.1423 - (0.0632 * l);
                } else if (age >= 40 && age <= 49) {
                  body_den = 1.1333 - (0.0612 * l);
                } else {
                  body_den = 1.1339 - (0.0645 * l);
                }
                
                body_fat = round((495 / body_den) - 450, 2);
                
                if (body_fat <= 9) {
                  category = "N/A";
                  color = "red";
                  left = "-2%";
                } else if (body_fat > 9 && body_fat <= 13) {
                  category = "Essential fat";
                  param.tech_Essential = "blue text-white";
                  color = "#0D47A1";
                  left = "2%";
                } else if (body_fat > 13 && body_fat <= 20) {
                  category = "Athletes";
                  param.tech_Athletes = "teal text-white";
                  color = "#00897B";
                  left = "20%";
                } else if (body_fat > 20 && body_fat <= 24) {
                  category = "Fitness";
                  param.tech_Fitness = "green text-white";
                  color = "#00C853";
                  left = "40%";
                } else if (body_fat > 24 && body_fat <= 31) {
                  category = "Average";
                  param.tech_Average = "yellow text-white";
                  color = "#FFEA00";
                  left = "60%";
                } else {
                  category = "Obese";
                  param.tech_Obese = "red text-white";
                  color = "#FF1744";
                  left = "80%";
                }
              }

              return calculateBodyFatResults(body_fat, weight, request, category, color, left);
            } else {
              param.error = 'Please fill all fields.';
              return param;
            }
          };

          const handleMethod7 = (request) => {
            const param = {};
            
            if (isNumeric(request.weight) && 
                (isNumeric(request['height-ft']) || isNumeric(request['height-cm'])) && 
                isNumeric(request.age) && request.gender) {
              
              let weight = parseFloat(request.weight);
              if (request.unit == 'lbs') {
                weight = weight * 0.453592;
              }

              let height = 0;
              if (request.hightUnit == 'ft/in') {
                const feet = parseFloat(request['height-ft']);
                const inches = parseFloat(request['height-in']) || 0;
                height = (feet * 12 + inches) * 0.0254;
              } else if (request.hightUnit == 'cm') {
                height = parseFloat(request['height-cm']) / 100;
              }

              const bmi = round(weight / (height * height), 2);
              const age = parseFloat(request.age);
              const gender = request.gender.toLowerCase();

              let bfp;
              if (gender == 'male') {
                if (age <= 18) {
                  bfp = round((1.51 * bmi) + (0.70 * age) - 2.2, 2);
                } else {
                  bfp = round((1.20 * bmi) + (0.23 * age) - 16.2, 2);
                }
              } else if (gender == 'female') {
                if (age <= 18) {
                  bfp = round((1.51 * bmi) + (0.70 * age) - 1.4, 2);
                } else {
                  bfp = round((1.20 * bmi) + (0.23 * age) - 5.4, 2);
                }
              } else {
                bfp = 0;
              }

              let category, color, left;
              if (request.gender == 'Male') {
                if (bfp < 2) {
                  category = "N/A";
                  color = "red";
                  left = "0%";
                } else if (bfp > 1 && bfp <= 5) {
                  category = "Essential fat";
                  param.tech_Essential = "blue text-white";
                  color = "#0D47A1";
                  left = "2%";
                } else if (bfp > 5 && bfp <= 13) {
                  category = "Athletes";
                  param.tech_Athletes = "teal text-white";
                  color = "#00897B";
                  left = "20%";
                } else if (bfp > 13 && bfp <= 17) {
                  category = "Fitness";
                  param.tech_Fitness = "green text-white";
                  color = "#00C853";
                  left = "40%";
                } else if (bfp > 17 && bfp <= 24) {
                  category = "Average";
                  param.tech_Average = "yellow text-white";
                  color = "#FFEA00";
                  left = "60%";
                } else {
                  category = "Obese";
                  param.tech_Obese = "red text-white";
                  color = "#FF1744";
                  left = "80%";
                }
              } else {
                if (bfp <= 9) {
                  category = "N/A";
                  color = "red";
                  left = "-2%";
                } else if (bfp > 9 && bfp <= 13) {
                  category = "Essential fat";
                  param.tech_Essential = "blue text-white";
                  color = "#0D47A1";
                  left = "2%";
                } else if (bfp > 13 && bfp <= 20) {
                  category = "Athletes";
                  param.tech_Athletes = "teal text-white";
                  color = "#00897B";
                  left = "20%";
                } else if (bfp > 20 && bfp <= 24) {
                  category = "Fitness";
                  param.tech_Fitness = "green text-white";
                  color = "#00C853";
                  left = "40%";
                } else if (bfp > 24 && bfp <= 31) {
                  category = "Average";
                  param.tech_Average = "yellow text-white";
                  color = "#FFEA00";
                  left = "60%";
                } else {
                  category = "Obese";
                  param.tech_Obese = "red text-white";
                  color = "#FF1744";
                  left = "80%";
                }
              }

              const body_fat_w = round((bfp / 100) * weight, 2);
              const lbm = round(weight - body_fat_w, 2);

              const fat_weight_kg = weight * (bfp / 100);
              const fat_weight_lbs = fat_weight_kg * 2.205;

              param.tech_fat_weight = request.unit == 'kg' ? round(fat_weight_kg, 2) : round(fat_weight_lbs, 2);
              param.tech_fat_weight_unit = request.unit;
              param.tech_body_fat = bfp;
              param.tech_color = color;
              param.tech_left = left;
              param.tech_category = category;
              param.tech_lbm = lbm + " kg";
              param.tech_body_fat_w = body_fat_w + " kg";

              return param;
            } else {
              param.error = 'Please fill all fields.';
              return param;
            }
          };

          const handleAdvancedCalculator = (request) => {
            // Store data (in Node.js you might want to use sessions instead of cookies)
            Object.keys(request).forEach(key => {
              // Session storage logic would go here
            });

            switch (request.method) {
              case '1':
                return handleMethod1(request);
              case '2':
                return handleMethod2(request);
              case '3':
                return handleMethod3(request);
              case '4':
                return handleMethod4(request);
              case '5':
                return handleMethod5(request);
              case '6':
                return handleMethod6(request);
              case '7':
                return handleMethod7(request);
              default:
                const param = {};
                param.error = 'Invalid method';
                return param;
            }
          };
          // Main execution
          try {
            if (body.calculator_type == 'simple') {
              return handleSimpleCalculator(body);
            } else {
              return handleAdvancedCalculator(body);
            }
          } catch (error) {
            return { error: 'Calculation failed: ' + error.message };
          }
        }
    

      /**
    * getCalculationPercentageCalculator: Service Method
    * POST: /api/calculators-lol/percentage-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

  async getCalculationPercentageCalculator(body) {
      const result = {};
      
      // Check locale (assuming you have a way to get locale in your app)
      const locale = body.tech_locale || 'en'; // default to 'en' if not provided
      
      if (locale == 'id') {
        // Indonesian locale calculations
        const angka_1 = body.tech_angka_1;
        const angka_2 = body.tech_angka_2;
        const angka_3 = body.tech_angka_3;
        const angka_4 = body.tech_angka_4;
        const pembilang_1 = body.tech_pembilang_1;
        const penyebut_1 = body.tech_penyebut_1;
        const perubahan_1 = body.tech_perubahan_1;
        const perubahan_2 = body.tech_perubahan_2;
        const calc_type = body.tech_submit;
        
        let hasil_1, hasil_2, hasil_3, hasil_4;
        
        if (calc_type == '1') {
          if (!isNaN(angka_1) && !isNaN(angka_2)) {
            hasil_1 = (angka_1 / 100) * angka_2;
          } else {
            result.error = 'Please! Fill both input fields.';
            return result;
          }
        } else if (calc_type == '2') {
          if (!isNaN(pembilang_1) && !isNaN(penyebut_1)) {
            hasil_2 = (pembilang_1 / penyebut_1) * 100;
          } else {
            result.error = 'Please! Fill both input fields.';
            return result;
          }
        } else if (calc_type == '3') {
          if (!isNaN(angka_3) && !isNaN(angka_4)) {
            hasil_3 = (angka_3 / angka_4) * 100;
          } else {
            result.error = 'Please! Fill both input fields.';
            return result;
          }
        } else if (calc_type == '4') {
          if (!isNaN(perubahan_1) && !isNaN(perubahan_2)) {
            hasil_4 = ((perubahan_2 - perubahan_1) / perubahan_1) * 100;
          } else {
            result.error = 'Please! Fill both input fields.';
            return result;
          }
        }
        
        result.tech_hasil_1 = hasil_1;
        result.tech_hasil_2 = hasil_2;
        result.tech_hasil_3 = hasil_3;
        result.tech_hasil_4 = hasil_4;
        result.tech_disable = 'zain';
        return result;
        
      } else {
        // English locale calculations
        const method = body.tech_method;
        const p = parseFloat(body.tech_p);
        const x = parseFloat(body.tech_x);
        
        if (method == '1') {
          if (!isNaN(p) && !isNaN(x)) {
            result.tech_ans = Math.round((p / 100) * x * 100) / 100;
            return result;
          } else {
            result.error = 'Please! Check Your Input.';
            return result;
          }
        } else if (method == '2') {
          if (!isNaN(p) && !isNaN(x)) {
            result.tech_ans = (Math.round((p / x) * 100 * 100) / 100) + '%';
            return result;
          } else {
            result.error = 'Please! Check Your Input.';
            return result;
          }
        } else if (method == '3') {
          if (!isNaN(p) && !isNaN(x)) {
            result.tech_ans = Math.round((p / (x / 100)) * 100) / 100;
            return result;
          } else {
            result.error = 'Please! Check Your Input.';
            return result;
          }
        } else if (method == '4') {
          if (!isNaN(x) && !isNaN(p)) {
            result.tech_ans = (Math.round((x / p) * 100 * 100) / 100) + '%';
            return result;
          } else {
            result.error = 'Please! Check Your Input.';
            return result;
          }
        } else if (method == '5') {
          if (!isNaN(p) && !isNaN(x)) {
            result.tech_ans = Math.round((x / (p / 100)) * 100) / 100;
            return result;
          } else {
            result.error = 'Please! Check Your Input.';
            return result;
          }
        } else if (method == '6') {
          if (!isNaN(p) && !isNaN(x)) {
            result.tech_ans = Math.round((p / 100) * x * 100) / 100;
            return result;
          } else {
            result.error = 'Please! Check Your Input.';
            return result;
          }
        } else if (method == '7') {
          if (!isNaN(p) && !isNaN(x)) {
            result.tech_ans = Math.round((p / (x / 100)) * 100) / 100;
            return result;
          } else {
            result.error = 'Please! Check Your Input.';
            return result;
          }
        } else if (method == '8') {
          if (!isNaN(p) && !isNaN(x)) {
            result.tech_ans = Math.round((x / 100) * p * 100) / 100;
            return result;
          } else {
            result.error = 'Please! Check Your Input.';
            return result;
          }
        } else if (method == '9') {
          if (!isNaN(x) && !isNaN(p)) {
            result.tech_ans = (Math.round((p / x) * 100 * 100) / 100) + '%';
            return result;
          } else {
            result.error = 'Please! Check Your Input.';
            return result;
          }
        } else if (method == '10') {
          if (!isNaN(p) && !isNaN(x)) {
            result.tech_ans = Math.round(p * (1 + (x / 100)) * 100) / 100;
            return result;
          } else {
            result.error = 'Please! Check Your Input.';
            return result;
          }
        } else if (method == '11') {
          if (!isNaN(p) && !isNaN(x)) {
            result.tech_ans = (Math.round(((x / p) - 1) * 100 * 100) / 100) + '%';
            return result;
          } else {
            result.error = 'Please! Check Your Input.';
            return result;
          }
        } else if (method == '12') {
          if (!isNaN(p) && !isNaN(x)) {
            result.tech_ans = Math.round((x / (1 + (p / 100))) * 100) / 100;
            return result;
          } else {
            result.error = 'Please! Check Your Input.';
            return result;
          }
        } else if (method == '13') {
          if (!isNaN(p) && !isNaN(x)) {
            result.tech_ans = Math.round(p * (1 - (x / 100)) * 100) / 100;
            return result;
          } else {
            result.error = 'Please! Check Your Input.';
            return result;
          }
        } else if (method == '14') {
          if (!isNaN(p) && !isNaN(x)) {
            result.tech_ans = (Math.round((1 - (x / p)) * 100 * 100) / 100) + '%';
            return result;
          } else {
            result.error = 'Please! Check Your Input.';
            return result;
          }
        } else if (method == '15') {
          if (!isNaN(p) && !isNaN(x)) {
            result.tech_ans = Math.round((x / (1 - (p / 100))) * 100) / 100;
            return result;
          } else {
            result.error = 'Please! Check Your Input.';
            return result;
          }
        }
      }
      
      return result;
    }

    /**
    * getCalculationFractionCalculator: Service Method
    * POST: /api/calculators-lol/fraction-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

  async getCalculationFractionCalculator(body) {
      const param = {};
      const request = body;
      const calculate_type = request.tech_calculate_type;

      // Helper Functions
      function gcd(a, b) {
        a = Math.abs(a);
        b = Math.abs(b);

        if (a < b) {
          [a, b] = [b, a];
        }
        if (b === 0) {
          return 1;
        }
        let r = a % b;
        while (r > 0) {
          a = b;
          b = r;
          r = a % b;
        }
        return b;
      }

      function lcmofn(numbers, n) {
        let ans = numbers[0];
        for (let i = 1; i < n; i++) {
          ans = ((numbers[i] * ans)) / (gcd(numbers[i], ans));
        }
        return ans;
      }

      function reduce(num, den) {
        const g = gcd(num, den);
        return [num / g, den / g];
      }

      if (calculate_type == 'fraction_type') {
        const fraction_types = request.tech_fraction_types;
        let a1 = request.tech_a1;
        let b1 = request.tech_b1;
        let N1 = request.tech_N1;
        let N2 = request.tech_N2;
        let N3 = request.tech_N3;
        let N4 = request.tech_N4;
        let D1 = request.tech_D1;
        let D2 = request.tech_D2;
        let D3 = request.tech_D3;
        let D4 = request.tech_D4;
        const action = request.tech_action;
        const action1 = request.tech_action1;
        const action2 = request.tech_action2;

        if (fraction_types == "simple_frac") {
          if (D1 == 0 || D2 == 0) {
            param.error = 'Denominator can not be 0.';
            return param;
          }
          if (!isNaN(N1) && !isNaN(D1) && !isNaN(N2) && !isNaN(D2)) {
            if (N1 == 0 || N2 == 0) {
              param.error = 'Please provide none zero numbers.';
              return param;
            }
            if (D1 == 0 || D2 == 0) {
              param.error = 'Denominator can not be 0';
              return param;
            }

            let totalN, totalD;
            if (action == '+') {
              totalN = (N1 * D2) + (N2 * D1);
              totalD = (D1 * D2);
            } else if (action == '-') {
              totalN = (N1 * D2) - (N2 * D1);
              totalD = (D1 * D2);
            } else if (action == '÷') {
              totalN = (N1 * D2);
              totalD = (N2 * D1);
            } else if (action == '×' || action == 'of') {
              totalN = (N1 * N2);
              totalD = (D1 * D2);
            } else if (action == '^') {
              totalN = Math.pow(N1, (N2 / D2));
              totalD = Math.pow(D1, (N2 / D2));
            }

            const g = gcd(totalN, totalD);
            const [upr, btm] = reduce(totalN, totalD);
            const lcd = lcmofn([D1, D2], 2);

            param.tech_lcd = lcd;
            param.tech_upr = upr;
            param.tech_btm = btm;
            param.tech_totalN = totalN;
            param.tech_totalD = totalD;
            param.tech_g = g;
            return param;
          } else {
            param.error = 'Please! Enter valid Input.';
            return param;
          }
        } else if (fraction_types == "three_frac") {
          if (D1 == 0 || D2 == 0 || D3 == 0) {
            param.error = 'Denominator can not be 0.';
            return param;
          }
          if (!isNaN(N1) && !isNaN(D1) && !isNaN(N2) && !isNaN(D2) && !isNaN(N3) && !isNaN(D3) && D1 !== 0 && D2 !== 0 && D3 !== 0) {
            if (N1 == 0 || N2 == 0 || N3 == 0) {
              param.error = 'Please provide none zero numbers.';
              return param;
            }
            if (D1 == 0 || D2 == 0 || D3 == 0) {
              param.error = 'Denominator can not be 0';
              return param;
            }

            let totalN, totalD;
            if ((action == '+' || action == '-') && (action1 == '+' || action1 == '-')) {
              const arr = [D1, D2, D3];
              const lcm = lcmofn(arr, 3);
              let first = action == '+' ? 
                (N1 * (lcm / D1)) + (N2 * (lcm / D2)) : 
                (N1 * (lcm / D1)) - (N2 * (lcm / D2));
              let second = action1 == '+' ? 
                first + (N3 * (lcm / D3)) : 
                first - (N3 * (lcm / D3));
              totalN = second;
              totalD = lcm;
            } else if ((action == '÷' || action == '×') && (action1 == '÷' || action1 == '×')) {
              if (action == '÷') {
                [N2, D2] = [D2, N2];
              }
              if (action1 == '÷') {
                [N3, D3] = [D3, N3];
              }
              totalN = N1 * N2 * N3;
              totalD = D1 * D2 * D3;
            } else if ((action == '÷' || action == '×') && (action1 == '+' || action1 == '-')) {
              if (action == '÷') {
                [N2, D2] = [D2, N2];
              }
              N2 = N1 * N2;
              D2 = D1 * D2;
              if (action1 == '+') {
                totalN = (N2 * D3) + (N3 * D2);
                totalD = (D2 * D3);
              } else if (action1 == '-') {
                totalN = (N2 * D3) - (N3 * D2);
                totalD = (D2 * D3);
              }
            } else if ((action1 == '÷' || action1 == '×') && (action == '+' || action == '-')) {
              if (action1 == '÷') {
                [N3, D3] = [D3, N3];
              }
              N2 = N3 * N2;
              D2 = D3 * D2;
              if (action == '+') {
                totalN = (N2 * D1) + (N1 * D2);
                totalD = (D2 * D1);
              } else if (action == '-') {
                totalN = (N2 * D1) - (N1 * D2);
                totalD = (D2 * D1);
              }
            }

            const g = gcd(totalN, totalD);
            const [upr, btm] = reduce(totalN, totalD);
            const lcd = lcmofn([D1, D2, D3], 3);

            param.tech_lcd = lcd;
            param.tech_upr = upr;
            param.tech_btm = btm;
            param.tech_totalN = totalN;
            param.tech_totalD = totalD;
            param.tech_g = g;
            return param;
          } else {
            param.error = 'Please! Enter valid Input.';
            return param;
          }
        } else if (fraction_types == "four_frac") {
          if (D1 == 0 || D2 == 0 || D3 == 0 || D4 == 0) {
            param.error = 'Denominator can not be 0.';
            return param;
          }
          if (!isNaN(N1) && !isNaN(D1) && !isNaN(N2) && !isNaN(D2) && !isNaN(N3) && !isNaN(D3) && !isNaN(N4) && !isNaN(D4) && D1 !== 0 && D2 !== 0 && D3 !== 0 && D4 !== 0) {
            if (N1 == 0 || N2 == 0 || N3 == 0 || N4 == 0) {
              param.error = 'Please provide none zero numbers.';
              return param;
            }
            if (D1 == 0 || D2 == 0 || D3 == 0 || D4 == 0) {
              param.error = 'Denominator can not be 0';
              return param;
            }

            let totalN, totalD;
            if ((action == '+' || action == '-') && (action1 == '+' || action1 == '-') && (action2 == '+' || action2 == '-')) {
              const arr = [D1, D2, D3, D4];
              const lcm = lcmofn(arr, 4);
              let first = action == '+' ? 
                (N1 * (lcm / D1)) + (N2 * (lcm / D2)) : 
                (N1 * (lcm / D1)) - (N2 * (lcm / D2));
              let second = action1 == '+' ? 
                first + (N3 * (lcm / D3)) : 
                first - (N3 * (lcm / D3));
              let third = action2 == '+' ? 
                second + (N4 * (lcm / D4)) : 
                second - (N4 * (lcm / D4));
              totalN = third;
              totalD = lcm;
            } else if ((action == '÷' || action == '×') && (action1 == '÷' || action1 == '×') && (action2 == '÷' || action2 == '×')) {
              if (action === '÷') {
                [N2, D2] = [D2, N2];
              }
              if (action1 === '÷') {
                [N3, D3] = [D3, N3];
              }
              if (action2 === '÷') {
                [N4, D4] = [D4, N4];
              }
              totalN = N1 * N2 * N3 * N4;
              totalD = D1 * D2 * D3 * D4;
            } else if ((action == '÷' || action == '×') && (action1 == '+' || action1 == '-') && (action2 == '+' || action2 == '-')) {
              if (action == '÷') {
                [N2, D2] = [D2, N2];
              }
              N2 = N1 * N2;
              D2 = D1 * D2;
              if (action1 == '+') {
                N3 = (N2 * D3) + (N3 * D2);
                D3 = (D2 * D3);
              } else if (action1 == '-') {
                N3 = (N2 * D3) - (N3 * D2);
                D3 = (D2 * D3);
              }
              if (action2 == '+') {
                totalN = (N3 * D4) + (N4 * D3);
                totalD = (D3 * D4);
              } else if (action2 == '-') {
                totalN = (N3 * D4) - (N4 * D3);
                totalD = (D3 * D4);
              }
            } else if ((action == '+' || action == '-') && (action1 == '÷' || action1 == '×') && (action2 == '+' || action2 == '-')) {
              if (action1 == '÷') {
                [N3, D3] = [D3, N3];
              }
              N3 = N3 * N2;
              D3 = D3 * D2;
              if (action == '+') {
                N3 = (N1 * D3) + (N3 * D1);
                D3 = (D3 * D1);
              } else if (action == '-') {
                N3 = (N1 * D3) - (N3 * D1);
                D3 = (D3 * D1);
              }
              if (action2 == '+') {
                totalN = (N3 * D4) + (N4 * D3);
                totalD = (D3 * D4);
              } else if (action2 == '-') {
                totalN = (N3 * D4) - (N4 * D3);
                totalD = (D3 * D4);
              }
            } else if ((action == '+' || action == '-') && (action1 == '+' || action1 == '-') && (action2 == '÷' || action2 == '×')) {
              if (action2 == '÷') {
                [N4, D4] = [D4, N4];
              }
              N3 = N3 * N4;
              D3 = D3 * D4;
              if (action == '+') {
                N2 = (N1 * D2) + (N2 * D1);
                D2 = (D1 * D2);
              } else if (action == '-') {
                N2 = (N1 * D2) - (N2 * D1);
                D2 = (D1 * D2);
              }
              if (action1 == '+') {
                totalN = (N2 * D3) + (N3 * D2);
                totalD = (D2 * D3);
              } else if (action1 == '-') {
                totalN = (N2 * D3) - (N3 * D2);
                totalD = (D2 * D3);
              }
            } else if ((action == '÷' || action == '×') && (action1 == '÷' || action1 == '×') && (action2 == '+' || action2 == '-')) {
              if (action1 == '÷') {
                [N3, D3] = [D3, N3];
              }
              N2 = N2 * N3;
              D2 = D2 * D3;
              if (action == '÷') {
                [N2, D2] = [D2, N2];
              }
              N1 = N1 * N2;
              D1 = D1 * D2;
              if (action2 == '+') {
                totalN = (N1 * D4) + (N4 * D1);
                totalD = (D1 * D4);
              } else if (action2 == '-') {
                totalN = (N1 * D4) - (N4 * D1);
                totalD = (D1 * D4);
              }
            } else if ((action == '÷' || action == '×') && (action1 == '+' || action1 == '-') && (action2 == '÷' || action2 == '×')) {
              if (action == '÷') {
                [N2, D2] = [D2, N2];
              }
              N2 = N1 * N2;
              D2 = D1 * D2;
              if (action2 == '÷') {
                [N4, D4] = [D4, N4];
              }
              N3 = N3 * N4;
              D3 = D3 * D4;
              if (action1 == '+') {
                totalN = (N2 * D3) + (N3 * D2);
                totalD = (D2 * D3);
              } else if (action1 == '-') {
                totalN = (N2 * D3) - (N3 * D2);
                totalD = (D2 * D3);
              }
            } else if ((action == '+' || action == '-') && (action1 == '÷' || action1 == '×') && (action2 == '÷' || action2 == '×')) {
              if (action1 == '÷') {
                [N3, D3] = [D3, N3];
              }
              if (action2 == '÷') {
                [N4, D4] = [D4, N4];
              }
              N3 = N3 * N4;
              D3 = D3 * D4;
              N2 = N2 * N3;
              D2 = D2 * D3;
              if (action == '+') {
                totalN = (N1 * D2) + (N2 * D1);
                totalD = (D1 * D2);
              } else if (action == '-') {
                totalN = (N1 * D2) - (N2 * D1);
                totalD = (D1 * D2);
              }
            }

            const g = gcd(totalN, totalD);
            const [upr, btm] = reduce(totalN, totalD);
            const lcd = lcmofn([D1, D2, D3, D4], 4);

            param.tech_lcd = lcd;
            param.tech_upr = upr;
            param.tech_btm = btm;
            param.tech_totalN = totalN;
            param.tech_totalD = totalD;
            param.tech_g = g;
            return param;
          } else {
            param.error = 'Please! Enter valid Input.';
            return param;
          }
        } else {
          if (parseFloat(request.tech_du1) == 0) {
            param.error = 'Denominator can not be 0.';
            return param;
          }
          if (!isNaN(request.tech_neo2) && !isNaN(request.tech_du1)) {
            let totalN = parseFloat(request.tech_neo2);
            let totalD = parseFloat(request.tech_du1);
            if (!isNaN(request.tech_ne1)) {
              const val1 = parseFloat(request.tech_ne1);
              if (val1 < 0 && totalN > 0) {
                totalN = totalN * (-1);
              }
              totalN = (totalD * val1) + totalN;
            }

            const g = gcd(totalN, totalD);
            const [upr, btm] = reduce(totalN, totalD);
            param.tech_upr = upr;
            param.tech_totalN = totalN;
            param.tech_totalD = totalD;
            param.tech_g = g;
            param.tech_btm = btm;
            return param;
          }
        }
      } else {
        if (!isNaN(request.tech_nu1) && !isNaN(request.tech_de1) && !isNaN(request.tech_nu2) && !isNaN(request.tech_de2)) {
      let N1 = parseFloat(request.tech_nu1);
      let D1 = parseFloat(request.tech_de1);
      let N2 = parseFloat(request.tech_nu2);
      let D2 = parseFloat(request.tech_de2);
      
          if (D1 == 0 || D2 == 0) {
            param.error = 'Denominator can not be 0';
            return param;
          }

          if (!isNaN(request.tech_s1)) {
            const val1 = parseFloat(request.tech_s1);
            if (val1 < 0 && N1 > 0) {
              N1 = N1 * (-1);
            }
            N1 = (D1 * val1) + N1;
          }
          if (!isNaN(request.tech_s2)) {
            const val2 = parseFloat(request.tech_s2);
            if (val2 < 0 && N2 > 0) {
              N2 = N2 * (-1);
            }
            N2 = (D2 * val2) + N2;
          }

          const action = request.tech_actions;
          let totalN, totalD;

          if (action == '+') {
            totalN = (N1 * D2) + (N2 * D1);
            totalD = (D1 * D2);
          } else if (action == '-') {
            totalN = (N1 * D2) - (N2 * D1);
            totalD = (D1 * D2);
          } else if (action == '÷') {
            totalN = (N1 * D2);
            totalD = (N2 * D1);
          } else if (action == '×') {
            totalN = (N1 * N2);
            totalD = (D1 * D2);
          }

          const g = gcd(totalN, totalD);
          const [upr, btm] = reduce(totalN, totalD);
          const lcd = lcmofn([D1, D2], 2);

          param.tech_upr = upr;
          param.tech_N1 = N1;
          param.tech_N2 = N2;
          param.tech_D1 = D1;
          param.tech_D2 = D2;
          param.tech_totalN = totalN;
          param.tech_totalD = totalD;
          param.tech_g = g;
          param.tech_btm = btm;
          param.tech_lcd = lcd;
          return param;
        } else {
          param.error = 'Please fill all fields.';
          return param;
        }
      }
    }

      /**
    * getCalculationIntegralCalculator: Service Method
    * POST: /api/calculators-lol/integral-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

  async getCalculationIntegralCalculator(body) {
        let EnterEq = body.tech_EnterEq;
        let ub = body.tech_ub;
        let lb = body.tech_lb;
        let form = body.tech_form;
        let wrt = body.tech_with;

        const param = {};

        // Input validation
        if (!EnterEq) {
            param.error = 'Please! Check Your Input.';
            return param;
        }

        // Regex validation
        const invalidPattern = /[<>&]/i;
        if (invalidPattern.test(EnterEq)) {
            param.error = 'Please! Check Your Input.';
            return param;
        }

        // Additional security validation
        const securityPattern = /\<|\>|\&|php|print_r|print|echo|script|=|&|%/i;
        if (securityPattern.test(EnterEq)) {
            param.error = 'Please! Check Your Input.';
            return param;
        }

        // Check for definite integral bounds
        if (form === 'def') {
            if (!ub || !lb) {
                param.error = 'Please! Check Your Input.';
                return param;
            }
        }

        // Process equation
        let parem = EnterEq;
        parem = parem.replace(/ /g, '');
        parem = parem.replace(/\+/g, 'plus');
        parem = parem.replace(/{/g, '(');
        parem = parem.replace(/}/g, ')');
        parem = parem.replace(/e\^/g, 'exp');
        parem = parem.replace(/exp\^/g, 'exp');
        parem = parem.replace(/\^/g, '**');
        parem = parem.replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

        const parem1 = wrt ? wrt.trim() : '';

        try {
            const axios = require('axios');
            let formData;

            if (form === 'def') {
                const ubProcessed = ub.replace(/\+/g, 'plus');
                const lbProcessed = lb.replace(/\+/g, 'plus');

                formData = {
                    equ: parem,
                    wrt: parem1,
                    ub: ubProcessed,
                    lb: lbProcessed
                };
            } else {
                formData = {
                    equ: parem,
                    wrt: parem1
                };
            }

            const response = await axios.post('http://167.172.134.148/new-integral', formData, {
                timeout: 120000,
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded'
                }
            });

            const buffer = response.data;

            param.tech_buffer = buffer[0];
            param.tech_ans = buffer[1];
            param.tech_enter = buffer[2];
            if (form === 'def') {
                param.tech_defi = buffer[3];
            }

            return param;

        } catch (error) {
            param.error = 'Please! Check Your Input.';
            return param;
        }
    }

         /**
    * getCalculationCircumferenceCalculator: Service Method
    * POST: /api/calculators-lol/circumference-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationCircumferenceCalculator(body) {
      // Helper function to check if value is numeric
      const isNumeric = (value) => {
          if (value == null || value == undefined || value == '') {
              return false;
          }
          return !isNaN(parseFloat(value)) && isFinite(value);
      };

      // Helper function to round numbers
      const round = (value, decimals) => {
          return Number(Math.round(value + 'e' + decimals) + 'e-' + decimals);
      };

          let radius = body.tech_radius;
          let diameter = body.tech_diameter;
          let circumference = body.tech_circumference;
          let area = body.tech_area;
          let s_area = body.tech_s_area;
          let vol = body.tech_vol;
          let unit_r = body.tech_unit_r;
          let unit_d = body.tech_unit_d;
          let unit_c = body.tech_unit_c;
          let unit_a = body.tech_unit_a;
          let unit_sa = body.tech_unit_sa;
          let unit_v = body.tech_unit_v;

      const param = {};

      // Check if at least one numeric value is provided
      if (!isNumeric(radius) && !isNumeric(diameter) && !isNumeric(circumference) && 
          !isNumeric(area) && !isNumeric(s_area) && !isNumeric(vol)) {
          param.error = 'Please enter any one value.';
          return param;
      }

      // Process Radius
      if (isNumeric(radius)) {
          if (!diameter && !circumference && !area && !s_area && !vol) {
              let Radius = parseFloat(radius);
              
              // Unit conversion for radius
              if (unit_r == 'mm') Radius = Radius / 10;
              if (unit_r == 'm') Radius = Radius * 100;
              if (unit_r == 'ft') Radius = Radius * 30.48;
              if (unit_r == 'in') Radius = Radius * 2.54;
              if (unit_r == 'km') Radius = Radius * 100000;
              if (unit_r == 'yd') Radius = Radius * 91.44;
              if (unit_r == 'mi') Radius = Radius * 160934;

              const Diameter = 2 * Radius;
              const Circumference = 2 * 3.14159 * Radius;
              const Area = 3.14159 * Math.pow(Radius, 2);

              param.tech_Radius = round(Radius, 5);
              param.tech_Diameter = round(Diameter, 5);
              param.tech_Circumference = round(Circumference, 5);
              param.tech_Area = round(Area, 5);
              return param;
          } else {
              param.error = 'You can enter only one value.';
              return param;
          }
      }

      // Process Diameter
      if (isNumeric(diameter)) {
          if (!radius && !circumference && !area && !s_area && !vol) {
              let Diameter = parseFloat(diameter);
              
              // Unit conversion for diameter
              if (unit_d == 'mm') Diameter = Diameter / 10;
              if (unit_d == 'm') Diameter = Diameter * 100;
              if (unit_d == 'ft') Diameter = Diameter * 30.48;
              if (unit_d == 'in') Diameter = Diameter * 2.54;
              if (unit_d == 'km') Diameter = Diameter * 100000;
              if (unit_d == 'yd') Diameter = Diameter * 91.44;
              if (unit_d == 'mi') Diameter = Diameter * 160934;

              const Radius = Diameter / 2;
              const Circumference = 2 * 3.14159 * Radius;
              const Area = 3.14159 * Math.pow(Radius, 2);

              param.tech_Radius = round(Radius, 5);
              param.tech_Diameter = round(Diameter, 5);
              param.tech_Circumference = round(Circumference, 5);
              param.tech_Area = round(Area, 5);
              return param;
          } else {
              param.error = 'You can enter only one value.';
              return param;
          }
      }

      // Process Circumference
      if (isNumeric(circumference)) {
          if (!radius && !diameter && !area && !s_area && !vol) {
              let Circumference = parseFloat(circumference);
              
              // Unit conversion for circumference
              if (unit_c == 'mm') Circumference = Circumference / 10;
              if (unit_c == 'm') Circumference = Circumference * 100;
              if (unit_c == 'ft') Circumference = Circumference * 30.48;
              if (unit_c == 'in') Circumference = Circumference * 2.54;
              if (unit_c == 'km') Circumference = Circumference * 100000;
              if (unit_c == 'yd') Circumference = Circumference * 91.44;
              if (unit_c == 'mi') Circumference = Circumference * 160934;

              const Radius = Circumference / (2 * 3.14159);
              const Diameter = 2 * Radius;
              const Area = 3.14159 * Math.pow(Radius, 2);

              param.tech_Radius = round(Radius, 5);
              param.tech_Diameter = round(Diameter, 5);
              param.tech_Circumference = round(Circumference, 5);
              param.tech_Area = round(Area, 5);
              return param;
          } else {
              param.error = 'You can enter only one value.';
              return param;
          }
      }

      // Process Area
      if (isNumeric(area)) {
          if (!radius && !diameter && !circumference && !s_area && !vol) {
              let Area = parseFloat(area);
              
              // Unit conversion for area
              if (unit_a == 'mm²') Area = Area / 100;
              if (unit_a == 'm²') Area = Area * 10000;
              if (unit_a == 'ft²') Area = Area * 929.03;
              if (unit_a == 'km²') Area = Area * 1e+10;
              if (unit_a == 'in²') Area = Area * 6.452;
              if (unit_a == 'mi²') Area = Area * 2.59e+10;
              if (unit_a == 'yd²') Area = Area * 8361.27;

              const Radius = Math.sqrt(Area / 3.14159);
              const Diameter = 2 * Radius;
              const Circumference = 2 * 3.14159 * Radius;

              param.tech_Radius = round(Radius, 5);
              param.tech_Diameter = round(Diameter, 5);
              param.tech_Circumference = round(Circumference, 5);
              param.tech_Area = round(Area, 5);
              return param;
          } else {
              param.error = 'You can enter only one value.';
              return param;
          }
      }

      // Process Surface Area
      if (isNumeric(s_area)) {
          if (!radius && !diameter && !circumference && !area && !vol) {
              let S_Area = parseFloat(s_area);
              
              // Unit conversion for surface area
              if (unit_sa == 'mm²') S_Area = S_Area / 100;
              if (unit_sa == 'm²') S_Area = S_Area * 10000;
              if (unit_sa == 'ft²') S_Area = S_Area * 929.03;
              if (unit_sa == 'km²') S_Area = S_Area * 1e+10;
              if (unit_sa == 'in²') S_Area = S_Area * 6.452;
              if (unit_sa == 'mi²') S_Area = S_Area * 2.59e+10;
              if (unit_sa == 'yd²') S_Area = S_Area * 8361.27;

              const Radius = Math.sqrt(S_Area / (4 * 3.14159));

              param.tech_Radius = round(Radius, 5);
              return param;
          } else {
              param.error = 'You can enter only one value.';
              return param;
          }
      }

      // Process Volume
      if (isNumeric(vol)) {
          if (!radius && !diameter && !circumference && !area && !s_area) {
              let Vol = parseFloat(vol);
              
              // Unit conversion for volume
              if (unit_v == 'm³') Vol = Vol * 1e+6;
              if (unit_v == 'ft³') Vol = Vol * 28316.8;
              if (unit_v == 'in³') Vol = Vol * 16.387;
              if (unit_v == 'km³') Vol = Vol * 1000000000000000;
              if (unit_v == 'yd³') Vol = Vol * 764555;
              if (unit_v == 'mi³') Vol = Vol * 4168181818124979;

              const Radius = Math.pow(((Vol * 3) / (4 * 3.14159)), 1/3);

              param.tech_Radius = round(Radius, 5);
              return param;
          } else {
              param.error = 'You can enter only one value.';
              return param;
          }
      }

      param.error = 'Please enter any one value.';
      return param;
  }


      /**
    * getCalculationLCMCalculator: Service Method
    * POST: /api/calculators-lol/lcm-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

  async getCalculationLCMCalculator(body) {
        // Helper function to calculate GCD
        const gcd = (a, b) => {
            if (b == 0) return a;
            return gcd(b, a % b);
        };

        // Helper function to calculate LCM of array
        const lcmOfArray = (numbers) => {
            let ans = numbers[0];
            for (let i = 1; i < numbers.length; i++) {
                ans = ((numbers[i] * ans)) / (gcd(numbers[i], ans));
            }
            return ans;
        };

        // Helper function for conditional plural
        const condPlural = (word, count) => {
            return count > 1 ? word + 's' : word;
        };

        let x = body.tech_x;
        let method = body.tech_method;
        const param = {};
        let check = true;

        // Check if x is empty
        if (!x) {
            check = false;
        }

        // Parse and validate numbers
        const numbers = x.split(',')
            .map(n => n.trim())
            .filter(n => n !== '')
            .map(n => parseFloat(n));

        // Validation checks
        for (let value of numbers) {
            // Check for decimal numbers
            const list = value.toString().split(".");
            if (list.length === 2 && list[1] !== '0') {
                param.error = "Please! Enter numeric values.";
                return param;
            }

            // Check if number is greater than 100000
            if (value > 100000) {
                param.error = "A number can't be greater than 100000.";
                return param;
            }

            // Check for negative numbers
            if (value < 0) {
                param.error = "Please! Enter Only Positive Numbers.";
                return param;
            }
        }

        // Check maximum 15 numbers
        if (numbers.length > 15) {
            param.error = "Please! Enter 15 numbers at most.";
            return param;
        }

        if (!check) {
            param.error = "Please fill all fields.";
            return param;
        }

        const n = numbers.length;
        const lcm = lcmOfArray(numbers);

        // Method: none (just calculate LCM)
        if (method == 'none') {
            param.tech_lcm = lcm;
            return param;
        }

        // Method: lm (Listing Multiples)
        if (method == 'lm') {
            const bruteForce = (newNumberList, lcm, decimalLength) => {
                let stepSolution = '';
                
                if (decimalLength > 0) {
                    stepSolution += '<i> • As not all of your numbers are integers, you first need to shift the decimal ' +
                        decimalLength + condPlural(' place', decimalLength) + ' to the right. This means we\'ll search for the LCM of the positive integers:<br></i>LCM(' + 
                        newNumberList.join(', ') + '),<i><br> and, at the end, we\'ll move the decimal point of the result ' + 
                        decimalLength + condPlural(' place', decimalLength) + ' to the left.</i><br>';
                }

                const lcmLong = lcm * Math.pow(10, decimalLength);

                for (let i = 0; i < newNumberList.length; i++) {
                    stepSolution += '• <b>Multiples of ' + newNumberList[i].toFixed(decimalLength) + ': </b>';
                    
                    if ((lcmLong / newNumberList[i]) + 4 < 100) {
                        for (let j = 1; j < (lcmLong / newNumberList[i]) + 4; j++) {
                            if (newNumberList[i] * j == lcmLong) {
                                stepSolution += '<b>' + (newNumberList[i] * j).toFixed(decimalLength) + '</b>, ';
                            } else if (j == (lcmLong / newNumberList[i]) + 3) {
                                stepSolution += (newNumberList[i] * j).toFixed(decimalLength) + ' ...';
                            } else {
                                stepSolution += (newNumberList[i] * j).toFixed(decimalLength) + ', ';
                            }
                        }
                    } else {
                        const N_numbers = 10; // must be even
                        
                        for (let j = 1; j < N_numbers; j++) {
                            if (j == N_numbers - 1) {
                                stepSolution += (newNumberList[i] * j).toFixed(decimalLength) + ', ..., ';
                            } else {
                                stepSolution += (newNumberList[i] * j).toFixed(decimalLength) + ', ';
                            }
                        }
                        
                        for (let j = Math.round((lcmLong / newNumberList[i]) / 2) - (N_numbers / 2); 
                            j < (lcmLong / newNumberList[i]) / 2 + Math.round(N_numbers / 2); j++) {
                            if (j == Math.round((lcmLong / newNumberList[i]) / 2) + (N_numbers / 2 - 1)) {
                                stepSolution += (newNumberList[i] * j).toFixed(decimalLength) + ', ..., ';
                            } else {
                                stepSolution += (newNumberList[i] * j).toFixed(decimalLength) + ', ';
                            }
                        }
                        
                        for (let j = (lcmLong / newNumberList[i]) - Math.round(N_numbers / 2); 
                            j < (lcmLong / newNumberList[i]) + Math.round(N_numbers / 2); j++) {
                            if (newNumberList[i] * j == lcmLong) {
                                stepSolution += '<b>' + (newNumberList[i] * j).toFixed(decimalLength) + '</b>, ';
                            } else if (j == (lcmLong / newNumberList[i]) + Math.round(N_numbers / 2 - 1)) {
                                stepSolution += (newNumberList[i] * j).toFixed(decimalLength) + ' ...';
                            } else {
                                stepSolution += (newNumberList[i] * j).toFixed(decimalLength) + ', ';
                            }
                        }
                    }
                    stepSolution += '<br><br>';
                }

                if (decimalLength > 0) {
                    stepSolution += 'Thus, <br><br><b>LCM(' + newNumberList.join(', ') + ') = ' + lcm + '</b>';
                }

                return stepSolution;
            };

            const sl = bruteForce(numbers, lcm, 0);
            param.tech_sl = sl;
            param.tech_lcm = lcm;
            return param;
        }

        // Method: Pf (Prime Factorization)
        if (method == 'Pf') {
            let sl = '';
            let ss = '';

            // Prime factorization for each number
            for (let value of numbers) {
                let x = value;
                sl += "<p class='mt-2'> Prime Factors of " + value + " = ";
                const arr = [];
                
                for (let i = 2; x > 1; i++) {
                    while (x % i === 0) {
                        x = x / i;
                        arr.push(i);
                    }
                }

                for (let j = 0; j < arr.length; j++) {
                    if (j !== arr.length - 1) {
                        sl += arr[j] + " x ";
                    } else {
                        sl += arr[j] + " </p>";
                    }
                }
            }

            // Prime factorization of LCM
            let s = lcm;
            const arr1 = [];
            
            for (let i = 2; s > 1; i++) {
                while (s % i === 0) {
                    s = s / i;
                    arr1.push(i);
                }
            }

            for (let j = 0; j < arr1.length; j++) {
                if (j !== arr1.length - 1) {
                    ss += arr1[j] + " x ";
                } else {
                    ss += arr1[j];
                }
            }

            param.tech_lcm = lcm;
            param.tech_sl = sl;
            param.tech_ss = ss;
            return param;
        }

        // Method: gcf (Greatest Common Factor Method)
        if (method == 'gcf') {
            let lce = '';

            for (let i = 0; i < numbers.length - 1; i++) {
                if (i === 0) {
                    const a = numbers[0];
                    const b = numbers[1];
                    lce += "LCM of (" + a + "," + b + ") = ";
                    const lc = (a * b) / (gcd(a, b));
                    lce += " " + lc + " ";
                } else {
                    const a = lcm;
                    const b = numbers[i + 1];
                    lce += "<p class='mt-2'>LCM of (" + a + "," + b + ") = ";
                    const lc = (a * b) / (gcd(a, b));
                    lce += " " + lc + " </p>";
                }
            }

            param.tech_lcm = lcm;
            param.tech_lce = lce;
            return param;
        }

        // Method: cl or dm (Cake/Ladder Method and Division Method)
        if (method == 'cl' || method == 'dm') {
            let sl = '';
            const sd = [];
            const fd = [];
            const ev = [...numbers];
            let arr = [...numbers];
            
            const final_arr = new Array(numbers.length).fill(1);
            let final_arr_c = [...arr];

            while (JSON.stringify(final_arr) !== JSON.stringify(final_arr_c)) {
                let arr1 = [];
                let p = 2;

                // Try dividing by p
                for (let value of arr) {
                    if (value % p === 0) {
                        arr1.push(value / p);
                    } else {
                        arr1.push(value);
                    }
                }

                final_arr_c = [...arr1];

                // Find next prime that divides at least one number
                while (JSON.stringify(arr) === JSON.stringify(arr1)) {
                    arr1 = [];
                    p++;
                    for (let value of arr) {
                        if (value % p === 0) {
                            arr1.push(value / p);
                        } else {
                            arr1.push(value);
                        }
                    }
                }

                if (JSON.stringify(arr) !== JSON.stringify(arr1)) {
                    arr = [...arr1];
                    fd.push(p);
                    sl += " (" + p + ") ";
                    for (let value1 of arr1) {
                        sd.push(value1);
                    }
                }

                final_arr_c = [...arr1];
            }

            param.tech_lcm = lcm;
            param.tech_sd = sd;
            param.tech_fd = fd;
            param.tech_sl = sl;
            param.tech_ev = ev;
            return param;
        }

        param.error = "Please fill all fields.";
        return param;
    }

          /**
    * getCalculationGCFCalculator: Service Method
    * POST: /api/calculators-lol/gcf-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

  async getCalculationGCFCalculator(body) {
      // Helper function to calculate GCD
      const gcd = (a, b) => {
          if (a == 0) return b;
          return gcd(b % a, a);
      };

      // Helper function to find GCD of array
      const findGCD = (arr) => {
          let result = arr[0];
          
          for (let i = 1; i < arr.length; i++) {
              result = gcd(arr[i], result);
              
              if (result === 1) {
                  return 1;
              }
          }
          return result;
      };

      let x = body.tech_x;
      let method = body.tech_method;
      const param = {};
      let check = true;

      // Check if x is empty
      if (!x) {
          check = false;
      }

      // Parse and validate numbers
      const numbers = x.split(',')
          .map(n => n.trim())
          .filter(n => n != '')
          .map(n => parseFloat(n));

      // Validation checks
      for (let value of numbers) {
          if (isNaN(value)) {
              check = false;
          } else {
              if (value > 1000000) {
                  param.error = 'Number must be less than or equal to 1000000.';
                  return param;
              }
          }
      }

      if (!check) {
          param.error = 'Please! Check Your Input.';
          return param;
      }

      // Check minimum 2 numbers
      if (numbers.length == 1) {
          param.error = 'Please! Enter at least two numbers.';
          return param;
      }

      // Check maximum 15 numbers
      if (numbers.length > 15) {
          param.error = 'You can enter up to 15 numbers.';
          return param;
      }

      const arr = numbers;
      const n = arr.length;
      const gcf = findGCD(arr);

      // Method: none (just calculate GCF)
      if (method == 'none') {
          param.tech_gcf = gcf;
          return param;
      }

      // Method: lm (Listing Multiples/Factors)
      if (method == 'lm') {
          let sl = '';
          let bl = '';

          // List factors for each number
          for (let value of arr) {
              sl += "<p class='mt-2'> Multiples of " + value + " = ";
              
              for (let i = 1; i <= value; i++) {
                  if (value % i === 0) {
                      if (i !== value) {
                          sl += i + ", ";
                      } else {
                          sl += i;
                          sl += "</p>";
                      }
                  }
              }
          }

          // List factors of GCF
          for (let j = 1; j <= gcf; j++) {
              if (gcf % j === 0) {
                  if (j !== gcf) {
                      bl += j + ", ";
                  } else {
                      bl += j;
                  }
              }
          }

          param.tech_gcf = gcf;
          param.tech_sl = sl;
          param.tech_bl = bl;
          return param;
      }

      // Method: Pf (Prime Factorization)
      if (method == 'Pf') {
          let al = '';
          let ss = '';
          let se = '';

          // Prime factorization for each number
          for (let value of arr) {
              let x = value;
              al += "<p class='mt-2'>Prime Factors of " + x + " = ";
              const primeFactors = [];
              
              for (let i = 2; x > 1; i++) {
                  while (x % i === 0) {
                      x = x / i;
                      primeFactors.push(i);
                  }
              }

              for (let j = 0; j < primeFactors.length; j++) {
                  if (j !== primeFactors.length - 1) {
                      al += " " + primeFactors[j] + " x ";
                  } else {
                      al += " " + primeFactors[j] + " </p>";
                  }
              }
          }

          // Prime factorization of GCF
          if (gcf == 1) {
              se = " There is No Common prime factorization . This means that the only common factor is 1 ";
          } else {
              let s = gcf;
              const arr1 = [];
              
              for (let i = 2; s > 1; i++) {
                  while (s % i === 0) {
                      s = s / i;
                      arr1.push(i);
                  }
              }

              for (let j = 0; j < arr1.length; j++) {
                  if (j !== arr1.length - 1) {
                      ss += arr1[j] + " x ";
                  } else {
                      ss += arr1[j];
                  }
              }
          }

          param.tech_gcf = gcf;
          param.tech_al = al;
          param.tech_se = se;
          param.tech_ss = ss;
          return param;
      }

      // Method: ea (Euclidean Algorithm)
      if (method == 'ea') {
          let sg = '';
          let i = '';
          let mi = '';
          let l = '';
          let j = 0;
          let k = 0;
          const arr1 = [];
          const arr2 = [];

          // Sort array
          const sortedArr = [...arr].sort((a, b) => a - b);
          
          for (let value of sortedArr) {
              sg += value + "  ";
          }

          const sm = Math.min(...sortedArr);

          // First iteration
          for (let value of sortedArr) {
              if (value !== sm) {
                  let x = value;
                  j = x % sm;
                  i += "<p class='mt-2'> => " + x + " mod of " + sm + " = " + j + " </p>";
                  arr1.push(j);
              }
              mi += " " + j + " ";
          }

          let si = '';
          if (j == 0) {
              si = gcf.toString();
          } else {
              si = mi + sm;
          }

          // Second iteration
          if (j != 0 && arr1.length > 0) {
              const smi = Math.min(...arr1);
              
              for (let value1 of arr1) {
                  if (value1 !== smi) {
                      let x = value1;
                      k = x % smi;
                      l += "<br/> => " + x + " mod of " + smi + " = " + k;
                      arr2.push(k);
                  } else {
                      let x = sm;
                      k = x % smi;
                      l += "<br/> => " + x + " mod of " + smi + " = " + k;
                  }
              }
          }

          // Third iteration if needed
          if (k != 0 && arr2.length > 0) {
              const smi = Math.min(...arr2);
              
              for (let value2 of arr2) {
                  if (value2 !== smi) {
                      let x = value2;
                      k = x % smi;
                      l += "<br/> => " + x + " mod of " + smi + " = " + k;
                      arr2.push(k);
                  } else {
                      let x = sm;
                      k = x % smi;
                      l += "<br/> => " + x + " mod of " + smi + " = " + k;
                  }
              }
          }

          param.tech_gcf = gcf;
          param.tech_sg = sg;
          param.tech_sm = sm;
          param.tech_i = i;
          param.tech_mi = mi;
          param.tech_si = si;
          param.tech_l = l;
          return param;
      }

      // Method: bs (Basic/Binary Search)
      if (method == 'bs') {
          param.tech_numbers = numbers;
          param.tech_gcf = gcf;
          return param;
      }

      param.error = 'Please! Check Your Input.';
      return param;
  }

     /**
    * getCalculationFactorialCalculator: Service Method
    * POST: /api/calculators-lol/factorial-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationFactorialCalculator(body) {
      let to_calculate = body.tech_to_calculate;
      let nvalue = body.tech_nvalue;
      let mvalue = body.tech_mvalue;
      const result = {};

      // Factorial calculation helper function
      function calculateFactorial(number) {
        let factorial = 1;
        for (let i = 1; i <= number; i++) {
          factorial = factorial * i;
        }
        return factorial;
      }

      // Generate factorial string representation
      function generateFactorialString(n) {
        let str = '';
        for (let i = 1; i <= n; i++) {
          if (i !== n) {
            str += ` ${i} *`;
          } else {
            str += ` ${i} `;
          }
        }
        return str;
      }

      // Check if number is too large
      function isInfinite(num) {
        return !isFinite(num);
      }

      // Single Factorial (f)
      if (to_calculate == 'f') {
        if (!isNaN(nvalue) && nvalue !== null && nvalue !== '') {
          const n = Number(nvalue);
          
          if (n > 170) {
            result.error = 'The factorial for a given number is too large, so try another value.';
            return result;
          }

          const fa = calculateFactorial(n);
          const a = generateFactorialString(n);

          if (isInfinite(fa)) {
            result.error = 'The factorial for a given number is too large, so try another value.';
            return result;
          }

          result.tech_fa = fa;
          result.tech_a = a;
          return result;
        } else {
          result.error = 'Please! Check Your Input.';
          return result;
        }
      }

      // Addition of Factorials (af)
      if (to_calculate == 'af') {
        if (!isNaN(nvalue) && !isNaN(mvalue) && nvalue !== null && mvalue !== null) {
          const n = Number(nvalue);
          const m = Number(mvalue);

          if (n > 170 || m > 170) {
            result.error = 'The factorial for a given number is too large, so try another value.';
            return result;
          }

          const fa = calculateFactorial(n);
          const fam = calculateFactorial(m);
          const a = generateFactorialString(n);
          const b = generateFactorialString(m);

          if (isInfinite(fa) || isInfinite(fam)) {
            result.error = 'The factorial for a given number is too large, so try another value.';
            return result;
          }

          const add = fa + fam;
          result.tech_fa = fa;
          result.tech_fam = fam;
          result.tech_a = a;
          result.tech_b = b;
          result.tech_add = add;
          return result;
        } else {
          result.error = 'Please! Check Your Input.';
          return result;
        }
      }

      // Subtraction of Factorials (sf)
      if (to_calculate == 'sf') {
        if (!isNaN(nvalue) && !isNaN(mvalue) && nvalue !== null && mvalue !== null) {
          const n = Number(nvalue);
          const m = Number(mvalue);

          if (n > 170 || m > 170) {
            result.error = 'The factorial for a given number is too large, so try another value.';
            return result;
          }

          const fa = calculateFactorial(n);
          const fam = calculateFactorial(m);
          const a = generateFactorialString(n);
          const b = generateFactorialString(m);

          if (isInfinite(fa) || isInfinite(fam)) {
            result.error = 'The factorial for a given number is too large, so try another value.';
            return result;
          }

          const sub = fa - fam;
          result.tech_fa = fa;
          result.tech_fam = fam;
          result.tech_a = a;
          result.tech_b = b;
          result.tech_sub = sub;
          return result;
        } else {
          result.error = 'Please! Check Your Input.';
          return result;
        }
      }

      // Multiplication of Factorials (mf)
      if (to_calculate == 'mf') {
        if (!isNaN(nvalue) && !isNaN(mvalue) && nvalue !== null && mvalue !== null) {
          const n = Number(nvalue);
          const m = Number(mvalue);

          if (n > 170 || m > 170) {
            result.error = 'The factorial for a given number is too large, so try another value.';
            return result;
          }

          const fa = calculateFactorial(n);
          const fam = calculateFactorial(m);
          const a = generateFactorialString(n);
          const b = generateFactorialString(m);

          if (isInfinite(fa) || isInfinite(fam)) {
            result.error = 'The factorial for a given number is too large, so try another value.';
            return result;
          }

          const mul = fa * fam;
          result.tech_fa = fa;
          result.tech_fam = fam;
          result.tech_a = a;
          result.tech_b = b;
          result.tech_mul = mul;
          return result;
        } else {
          result.error = 'Please! Check Your Input.';
          return result;
        }
      }

      // Division of Factorials (df)
      if (to_calculate == 'df') {
        if (!isNaN(nvalue) && !isNaN(mvalue) && nvalue !== null && mvalue !== null) {
          const n = Number(nvalue);
          const m = Number(mvalue);

          if (n > 170 || m > 170) {
            result.error = 'The factorial for a given number is too large, so try another value.';
            return result;
          }

          const fa = calculateFactorial(n);
          const fam = calculateFactorial(m);
          const a = generateFactorialString(n);
          const b = generateFactorialString(m);

          if (isInfinite(fa) || isInfinite(fam)) {
            result.error = 'The factorial for a given number is too large, so try another value.';
            return result;
          }

          const div = fa / fam;
          result.tech_fa = fa;
          result.tech_fam = fam;
          result.tech_a = a;
          result.tech_b = b;
          result.tech_div = div;
          return result;
        } else {
          result.error = 'Please! Check Your Input.';
          return result;
        }
      }

      // If no valid operation is found
      result.error = 'Invalid operation type.';
      return result;
    }


       /**
    * getCalculationRatioCalculator: Service Method
    * POST: /api/calculators-lol/ratio-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

  async getCalculationRatioCalculator(body) {
      // Extract and trim input values
      const a = body.tech_a ? String(body.tech_a).trim() : '';
      const b = body.tech_b ? String(body.tech_b).trim() : '';
      const c = body.tech_c ? String(body.tech_c).trim() : '';
      const c1 = body.tech_c1 ? String(body.tech_c1).trim() : '';
      const d = body.tech_d ? String(body.tech_d).trim() : '';
      const e = body.tech_e ? String(body.tech_e).trim() : '';
      const f = body.tech_f ? String(body.tech_f).trim() : '';
      const i = body.tech_i ? String(body.tech_i).trim() : '';
      const ratio_of = body.tech_ratio_of ? String(body.tech_ratio_of).trim() : '';
      const method = body.tech_method ? String(body.tech_method).trim() : '';
      const method1 = body.tech_method1 ? String(body.tech_method1).trim() : '';

      const result = {};

      // Helper function to check if value is numeric
      function isNumeric(value) {
        return value != '' && value !== null && !isNaN(value);
      }

      // Helper function to check if value is empty
      function isEmpty(value) {
        return value == '' || value == null || value == undefined;
      }

      // Helper function to check if value is double/float
      function isDouble(value) {
        return typeof value == 'number' && !Number.isInteger(value);
      }

      // GCD function for two numbers
      function gcd(a, b) {
        return b ? gcd(b, a % b) : a;
      }

      // GCD function for array of numbers
      function gcdArray(arr) {
        return arr.reduce((carry, item) => {
          return item ? gcd(item, carry % item) : carry;
        }, arr[0]);
      }

      // Ratio of 2 numbers (r2)
      if (method == '0' && ratio_of == 'r2') {
        if (isNumeric(a) && isNumeric(b) && isNumeric(c) && isNumeric(d)) {
          result.error = 'Please Enter 3 numbers & left 1 field empty!';
          return result;
        } else if (isEmpty(a) && isNumeric(b) && isNumeric(c) && isNumeric(d)) {
          const a_val = (Number(b) * Number(c)) / Number(d);
          result.tech_a_val = a_val;
        } else if (isNumeric(a) && isEmpty(b) && isNumeric(c) && isNumeric(d)) {
          const b_val = (Number(a) * Number(d)) / Number(c);
          result.tech_b_val = b_val;
        } else if (isNumeric(a) && isNumeric(b) && isEmpty(c) && isNumeric(d)) {
          const c_val = (Number(a) * Number(d)) / Number(b);
          result.tech_c_val = c_val;
        } else if (isNumeric(a) && isNumeric(b) && isNumeric(c) && isEmpty(d)) {
          const d_val = (Number(b) * Number(c)) / Number(a);
          result.tech_d_val = d_val;
        } else {
          result.error = 'Please Check Input!';
          return result;
        }
        result.tech_r2 = 'r2';
        return result;
      } 
      
      else if (method == '1' && ratio_of == 'r2') {
        if (isNumeric(a) && isNumeric(b) && isNumeric(i)) {
          const a_val1 = Number(a) * Number(i);
          const b_val1 = Number(b) * Number(i);
          result.tech_a_val1 = a_val1;
          result.tech_b_val1 = b_val1;
        } else {
          result.error = 'Please Fill All The Fields!';
          return result;
        }
        result.tech_r2 = 'r2';
        return result;
      } 
      
      else if (method == '2' && ratio_of == 'r2') {
        if (isNumeric(a) && isNumeric(b) && isNumeric(i)) {
          const a_val2 = Number(a) / Number(i);
          const b_val2 = Number(b) / Number(i);
          result.tech_a_val2 = a_val2;
          result.tech_b_val2 = b_val2;
        } else {
          result.error = 'Please Fill All The Fields!';
          return result;
        }
        result.tech_r2 = 'r2';
        return result;
      } 
      
      else if (method == '3' && ratio_of == 'r2') {
        if (isNumeric(a) && isNumeric(b)) {
          const gcf = gcd(Number(a), Number(b));
          const a_val3 = Number(a) / gcf;
          const b_val3 = Number(b) / gcf;
          
          if (gcf == 1) {
            result.tech_gcf = 'gcf';
          }
          result.tech_a_val3 = a_val3;
          result.tech_b_val3 = b_val3;
        } else {
          result.error = 'Please Fill All The Fields!';
          return result;
        }
        result.tech_r2 = 'r2';
        return result;
      } 
      
      else if (method == '4' && ratio_of == 'r2') {
        if (isNumeric(a) && isNumeric(b)) {
          const a_val4 = Number(a) / Number(a);
          const b_val4 = Number(b) / Number(a);
          result.tech_a_val4 = a_val4;
          result.tech_b_val4 = b_val4;
        } else {
          result.error = 'Please Fill All The Fields!';
          return result;
        }
        result.tech_r2 = 'r2';
        return result;
      } 
      
      else if (method == '5' && ratio_of == 'r2') {
        if (isNumeric(a) && isNumeric(b)) {
          const a_val5 = Number(a) / Number(b);
          const b_val5 = Number(b) / Number(b);
          result.tech_a_val5 = a_val5;
          result.tech_b_val5 = b_val5;
        } else {
          result.error = 'Please Fill All The Fields!';
          return result;
        }
        result.tech_r2 = 'r2';
        return result;
      }

      // Ratio of 3 numbers (r3)
      else if (method1 == '0' && ratio_of == 'r3') {
        if ((isNumeric(a) && isNumeric(b) && isNumeric(c1) && isNumeric(d) && isNumeric(e) && isNumeric(f)) ||
            (isNumeric(a) && isNumeric(b) && isNumeric(c1) && isNumeric(d) && isNumeric(e)) ||
            (isNumeric(a) && isNumeric(b) && isNumeric(c1) && isNumeric(d) && isNumeric(f)) ||
            (isNumeric(a) && isNumeric(b) && isNumeric(c1) && isNumeric(e) && isNumeric(f))) {
          result.error = 'Please Check Input!';
          return result;
        } else if (isNumeric(a) && isNumeric(b) && isNumeric(c1) && isNumeric(d)) {
          const x = Number(d) / Number(a);
          const e_val = Number(b) * x;
          const f_val = Number(c1) * x;
          
          if (isDouble(e_val) || isDouble(f_val)) {
            result.tech_dbl = 'dbl';
          }
          result.tech_r3 = 'r3';
          result.tech_e_val = Math.round(e_val * 100000) / 100000; // round to 5 decimal places
          result.tech_f_val = Math.round(f_val * 100000) / 100000;
          return result;
        } else {
          result.error = 'Please Check Input!';
          return result;
        }
      } 
      
      else if (method1 == '1' && ratio_of == 'r3') {
        if (isNumeric(a) && isNumeric(b) && isNumeric(c1) && isNumeric(i)) {
          const a_val1 = Number(a) * Number(i);
          const b_val1 = Number(b) * Number(i);
          const c_val1 = Number(c1) * Number(i);
          
          if (isDouble(a_val1) || isDouble(b_val1) || isDouble(c_val1)) {
            result.tech_dbl = 'dbl';
          }
          result.tech_a_val1 = a_val1;
          result.tech_b_val1 = b_val1;
          result.tech_c_val1 = c_val1;
        } else {
          result.error = 'Please Fill All The Fields!';
          return result;
        }
        result.tech_r3 = 'r3';
        return result;
      } 
      
      else if (method1 == '2' && ratio_of == 'r3') {
        if (isNumeric(a) && isNumeric(b) && isNumeric(c1) && isNumeric(i)) {
          const a_val2 = Number(a) / Number(i);
          const b_val2 = Number(b) / Number(i);
          const c_val2 = Number(c1) / Number(i);
          
          if (isDouble(a_val2) || isDouble(b_val2) || isDouble(c_val2)) {
            result.tech_dbl = 'dbl';
          }
          result.tech_a_val2 = a_val2;
          result.tech_b_val2 = b_val2;
          result.tech_c_val2 = c_val2;
        } else {
          result.error = 'Please Fill All The Fields!';
          return result;
        }
        result.tech_r3 = 'r3';
        return result;
      } 
      
      else if (method1 == '3' && ratio_of == 'r3') {
        if (isNumeric(a) && isNumeric(b) && isNumeric(c1)) {
          const arr = [Number(a), Number(b), Number(c1)];
          const gcf = gcdArray(arr);
          
          const a_val3 = Number(a) / gcf;
          const b_val3 = Number(b) / gcf;
          const c_val3 = Number(c1) / gcf;
          
          if (gcf == 1) {
            result.tech_gcf = 'gcf';
          }
          if (isDouble(a_val3) || isDouble(b_val3) || isDouble(c_val3)) {
            result.tech_dbl = 'dbl';
          }
          result.tech_a_val3 = a_val3;
          result.tech_b_val3 = b_val3;
          result.tech_c_val3 = c_val3;
        } else {
          result.error = 'Please Fill All The Fields!';
          return result;
        }
        result.tech_r3 = 'r3';
        return result;
      } 
      
      else if (method1 == '4' && ratio_of == 'r3') {
        if (isNumeric(a) && isNumeric(b) && isNumeric(c1)) {
          const a_val4 = Number(a) / Number(a);
          const b_val4 = Number(b) / Number(a);
          const c_val4 = Number(c1) / Number(a);
          
          if (isDouble(a_val4) || isDouble(b_val4) || isDouble(c_val4)) {
            result.tech_dbl = 'dbl';
          }
          result.tech_a_val4 = a_val4;
          result.tech_b_val4 = b_val4;
          result.tech_c_val4 = c_val4;
        } else {
          result.error = 'Please Fill All The Fields!';
          return result;
        }
        result.tech_r3 = 'r3';
        return result;
      } 
      
      else if (method1 == '5' && ratio_of == 'r3') {
        if (isNumeric(a) && isNumeric(b) && isNumeric(c1)) {
          const a_val5 = Number(a) / Number(b);
          const b_val5 = Number(b) / Number(b);
          const c_val5 = Number(c1) / Number(b);
          
          if (isDouble(a_val5) || isDouble(b_val5) || isDouble(c_val5)) {
            result.tech_dbl = 'dbl';
          }
          result.tech_a_val5 = a_val5;
          result.tech_b_val5 = b_val5;
          result.tech_c_val5 = c_val5;
        } else {
          result.error = 'Please Fill All The Fields!';
          return result;
        }
        result.tech_r3 = 'r3';
        return result;
      } 
      
      else if (method1 == '6' && ratio_of == 'r3') {
        if (isNumeric(a) && isNumeric(b) && isNumeric(c1)) {
          const a_val6 = Number(a) / Number(c1);
          const b_val6 = Number(b) / Number(c1);
          const c_val6 = Number(c1) / Number(c1);
          
          if (isDouble(a_val6) || isDouble(b_val6) || isDouble(c_val6)) {
            result.tech_dbl = 'dbl';
          }
          result.tech_a_val6 = a_val6;
          result.tech_b_val6 = b_val6;
          result.tech_c_val6 = c_val6;
        } else {
          result.error = 'Please Fill All The Fields!';
          return result;
        }
        result.tech_r3 = 'r3';
        return result;
      } 
      
      else {
        result.error = 'Please Check Input!';
        return result;
      }
    }

        /**
    * getCalculationIntervalNotationCalculator: Service Method
    * POST: /api/calculators-lol/interval-notation-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

  async getCalculationIntervalNotationCalculator(body) {
        let i = body.tech_i;
        const x = body.tech_x;
        const result = {};

        // Validation: Check for invalid characters (similar to regex in PHP)
        const invalidCharsRegex = /[<>&]/;
        if (!i || invalidCharsRegex.test(i)) {
          result.error = 'Please Enter Valid Input.';
          return result;
        }

        if (i && x) {
          // Clean up the input string
          i = i.replace(/ /g, '');
          i = i.replace(/,,/g, ',');
          i = i.replace(/,\(/g, '(');
          i = i.replace(/,,\(/g, '(');
          i = i.replace(/\(,/g, '(');
          i = i.replace(/\(,,/g, '(');
          i = i.replace(/,\[/g, '[');
          i = i.replace(/,,\[/g, '[');
          i = i.replace(/\[,/g, '[');
          i = i.replace(/\[,,/g, '[');
          i = i.replace(/,\)/g, ')');
          i = i.replace(/,,\)/g, ')');
          i = i.replace(/\),/g, ')');
          i = i.replace(/\),,/g, ')');
          i = i.replace(/,\]/g, ']');
          i = i.replace(/,,\]/g, ']');
          i = i.replace(/\],/g, ']');
          i = i.replace(/\],,/g, ']');

          // Check for multiple commas
          const commaMatches = i.match(/,/g);
          if (commaMatches && commaMatches.length > 1) {
            result.error = 'Please Enter Valid Input.';
            return result;
          }

          // Split by comma
          const arr = i.split(',');
          
          // Extract opening bracket
          const arr0Match = arr[0].match(/\(|\[/);
          if (!arr0Match) {
            result.error = 'Please Enter Valid Input.';
            return result;
          }
          
          // Extract closing bracket
          const arr1Match = arr[1].match(/\)|\]/);
          if (!arr1Match) {
            result.error = 'Please Enter Valid Input.';
            return result;
          }

          const arr0 = arr[0];
          const arr1 = arr[1];
          
          const arr00 = arr0.split(arr0Match[0]);
          const arr11 = arr1.split(arr1Match[0]);

          // Validate format
          if (arr00[0] != '') {
            result.error = 'Please Enter Valid Input.';
            return result;
          }
          if (arr11[1] !== '' && arr11[1] !== undefined) {
            result.error = 'Please Enter Valid Input.';
            return result;
          }

          const l = Number(arr00[1]);
          const r = Number(arr11[0]);

          if (!isNaN(l) && !isNaN(r)) {
            let lo, lc, ro, rc;

            // Check left bracket type
            const leftParenMatches = i.match(/\(/g);
            if (leftParenMatches) {
              if (leftParenMatches.length > 1) {
                result.error = 'Please Enter Valid Input.';
                return result;
              } else {
                lo = 'left open';
              }
            } else {
              const leftBracketMatches = i.match(/\[/g);
              if (leftBracketMatches) {
                if (leftBracketMatches.length > 1) {
                  result.error = 'Please Enter Valid Input.';
                  return result;
                } else {
                  lc = 'left closed';
                }
              }
            }

            // Check right bracket type
            const rightParenMatches = i.match(/\)/g);
            if (rightParenMatches) {
              if (rightParenMatches.length > 1) {
                result.error = 'Please Enter Valid Input.';
                return result;
              } else {
                ro = 'right open';
              }
            } else {
              const rightBracketMatches = i.match(/\]/g);
              if (rightBracketMatches) {
                if (rightBracketMatches.length > 1) {
                  result.error = 'Please Enter Valid Input.';
                  return result;
                } else {
                  rc = 'right closed';
                }
              }
            }

            result.tech_l = l;
            result.tech_r = r;

            let set = [];

            // Left open Right open
            if (lo && ro) {
              if (l > r) {
                if (l < 0 && r < 0) {
                  for (let idx = r + 1; idx <= l - 1; idx++) {
                    set.push(idx);
                  }
                } else if (l < 0) {
                  for (let idx = l + 1; idx <= r - 1; idx++) {
                    set.push(idx);
                  }
                } else {
                  for (let idx = r + 1; idx <= l - 1; idx++) {
                    set.push(idx);
                  }
                }
              } else {
                if (l < 0 && r < 0) {
                  for (let idx = l + 1; idx <= r - 1; idx++) {
                    set.push(idx);
                  }
                } else if (l < 0) {
                  for (let idx = r + 1; idx <= l - 1; idx++) {
                    set.push(idx);
                  }
                } else {
                  for (let idx = l + 1; idx <= r - 1; idx++) {
                    set.push(idx);
                  }
                }
              }
              result.tech_lo_ro = 'lo_ro';
              result.tech_set = set;
            }
            // Left open Right closed
            else if (lo && rc) {
              if (l > r) {
                if (l < 0 && r < 0) {
                  for (let idx = r; idx <= l - 1; idx++) {
                    set.push(idx);
                  }
                } else if (r < 0) {
                  for (let idx = r; idx <= l - 1; idx++) {
                    set.push(idx);
                  }
                } else {
                  for (let idx = r; idx <= l - 1; idx++) {
                    set.push(idx);
                  }
                }
              } else {
                if (l < 0 && r < 0) {
                  for (let idx = l + 1; idx <= r; idx++) {
                    set.push(idx);
                  }
                } else if (r < 0) {
                  for (let idx = r + 1; idx <= l - 1; idx++) {
                    set.push(idx);
                  }
                } else {
                  for (let idx = l + 1; idx <= r; idx++) {
                    set.push(idx);
                  }
                }
              }
              result.tech_lo_rc = 'lo_rc';
              result.tech_set = set;
            }
            // Left closed Right open
            else if (lc && ro) {
              if (l > r) {
                if (l < 0 && r < 0) {
                  for (let idx = r + 1; idx <= l; idx++) {
                    set.push(idx);
                  }
                } else if (r < 0) {
                  for (let idx = r + 1; idx <= l; idx++) {
                    set.push(idx);
                  }
                } else {
                  for (let idx = r + 1; idx <= l; idx++) {
                    set.push(idx);
                  }
                }
              } else {
                if (l < 0 && r < 0) {
                  for (let idx = l; idx <= r - 1; idx++) {
                    set.push(idx);
                  }
                } else if (l < 0) {
                  for (let idx = l; idx <= r - 1; idx++) {
                    set.push(idx);
                  }
                } else {
                  for (let idx = l; idx <= r - 1; idx++) {
                    set.push(idx);
                  }
                }
              }
              result.tech_lc_ro = 'lc_ro';
              result.tech_set = set;
            }
            // Left closed Right closed
            else if (lc && rc) {
              if (l > r) {
                if (l < 0) {
                  for (let idx = r; idx <= l; idx++) {
                    set.push(idx);
                  }
                } else {
                  for (let idx = r; idx <= l; idx++) {
                    set.push(idx);
                  }
                }
              } else {
                if (l < 0 && r < 0) {
                  for (let idx = l; idx <= r; idx++) {
                    set.push(idx);
                  }
                } else if (l < 0) {
                  for (let idx = l; idx <= r; idx++) {
                    set.push(idx);
                  }
                } else {
                  for (let idx = l; idx <= r; idx++) {
                    set.push(idx);
                  }
                }
              }
              result.tech_lc_rc = 'lc_rc';
              result.tech_set = set;
            }
          } else {
            result.error = 'Please Enter Valid Input.';
            return result;
          }

          return result;
        } else {
          result.error = 'Please Enter Valid Input.';
          return result;
        }
      }

     /**
    * getCalculationFactoringCalculator: Service Method
    * POST: /api/calculators-lol/factoring-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */


      async  getCalculationFactoringCalculator(body) {
          let submit = body.tech_type;
          let num1 = body.tech_num1;
          let num2 = body.tech_num2;
          let eq = body.tech_eq;

          const param = {};

          // Helper function to find divisors
          function printDivisors(n) {
              const divi = [];
              for (let i = 1; i <= n; i++) {
                  if (n % i === 0) {
                      divi.push(i.toString());
                  }
              }
              return divi;
          }

          if (submit == "factor") {
              if (!isNaN(num1) || !isNaN(num2)) {
                  // Process num1
                  if (!isNaN(num1) && num1) {
                      let newnum = parseInt(num1);
                      if (newnum > 10000000) {
                          param.error = 'Number is too large.';
                          return param;
                      }

                      let newtext = "";
                      let csv = "";
                      let chk = 2;
                      let prime = 0;

                      while ((chk * chk) <= newnum) {
                          if (newnum % chk == 0) {
                              newtext += chk;
                              csv += chk;
                              newnum = newnum / chk;
                              if (newnum !== 1) {
                                  newtext += " × ";
                                  csv += " , ";
                              }
                          } else {
                              chk++;
                          }
                      }

                      if (newnum != 1) {
                          newtext += newnum;
                          csv += newnum;
                      }

                      if (newtext == num1.toString()) {
                          newtext += " is a Prime number.";
                          prime = 1;
                      }

                      if (prime != 1) {
                          let number = parseInt(num1);
                          const divid = newtext.split(' × ');
                          let tree = `<tr><td class='py-2 text-center'>${number}</td><td class='py-2'>&nbsp;</td></tr>`;
                          
                          divid.forEach(value => {
                              if (parseInt(value) !== number) {
                                  number = number / parseInt(value);
                                  tree += `<tr><td class='py-2'>| </td><td class='py-2'>\\ </td></tr><tr><td class='py-2'>${number}</td><td class='py-2'>${value}</td></tr>`;
                              }
                          });
                          param.tech_tree1 = tree;
                      }

                      param.tech_Factors1 = newtext;
                      param.tech_csv1 = csv;
                  }

                  // Process num2
                  if (!isNaN(num2) && num2) {
                      let newnum2 = parseInt(num2);
                      if (newnum2 > 10000000) {
                          param.error = 'Number is too large.';
                          return param;
                      }

                      let newtext2 = "";
                      let csv2 = "";
                      let chk2 = 2;
                      let prime2 = 0;

                      while ((chk2 * chk2) <= newnum2) {
                          if (newnum2 % chk2 == 0) {
                              newtext2 += chk2;
                              csv2 += chk2;
                              newnum2 = newnum2 / chk2;
                              if (newnum2 != 1) {
                                  newtext2 += " × ";
                                  csv2 += " , ";
                              }
                          } else {
                              chk2++;
                          }
                      }

                      if (newnum2 != 1) {
                          newtext2 += newnum2;
                          csv2 += newnum2;
                      }

                      if (newtext2 == num2.toString()) {
                          newtext2 += " is a Prime number.";
                          prime2 = 1;
                      }

                      if (prime2 != 1) {
                          let number2 = parseInt(num2);
                          const divid2 = newtext2.split(' × ');
                          let tree2 = `<tr><td class='py-2 text-center'>${number2}</td><td class='py-2'>&nbsp;</td></tr>`;
                          
                          divid2.forEach(value2 => {
                              if (parseInt(value2) != number2) {
                                  number2 = number2 / parseInt(value2);
                                  tree2 += `<tr><td class='py-2'>| </td><td class='py-2'>\\ </td></tr><tr><td class='py-2'>${number2}</td><td class='py-2'>${value2}</td></tr>`;
                              }
                          });
                          param.tech_tree2 = tree2;
                      }

                      param.tech_Factors2 = newtext2;
                      param.tech_csv2 = csv2;
                  }
                  param.tech_submit = submit;
              } else {
                  param.error = 'Please Enter a Number.';
                  return param;
              }
          } else {
              // Equation factoring
              const variables_list = [];
              const letters = ['x', 'a', 'b', 'c', 'd', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'y', 'z'];
              
              letters.forEach(letter => {
                  const regex = new RegExp(letter, 'i');
                  if (regex.test(eq)) {
                      variables_list.push(letter);
                  }
              });

              if (variables_list.length == 1) {
                  // Validate input
                  if (/<|>|&|php|print_r|print|echo|script|=|%/i.test(eq)) {
                      param.error = 'Please! Check Your Input.';
                      return param;
                  }

                  let parem = eq;
                  parem = parem.replace(/\s/g, '');
                  parem = parem.replace(/\+/g, 'plus');
                  parem = parem.replace(/%20/g, '');
                  parem = parem.replace(/\{/g, '(');
                  parem = parem.replace(/\}/g, ')');
                  parem = parem.replace(/e\^/g, 'exp');
                  parem = parem.replace(/exp\^/g, 'exp');
                  parem = parem.replace(/\^/g, '**');
                  parem = parem.replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

                  try {
                      const response = await axios.post('http://167.172.134.148/new_factoring', 
                          new URLSearchParams({
                              equ: parem
                          }), 
                          {
                              timeout: 120000,
                              headers: {
                                  'Content-Type': 'application/x-www-form-urlencoded'
                              }
                          }
                      );

                      const buffer = response.data;
                      const factors = buffer[0];
                      const eq_enter = buffer[1];
                      const all_coeffs = buffer[2];
                      const eq_degree = buffer[3];

                      if (eq_degree == "2") {
                          const matches = all_coeffs.match(/(\+|-){0,1}\d+\.{0,1}\d*/g);
                          const eq_coeff_ans = matches;
                          const a = parseFloat(matches[0]);
                          const b = parseFloat(matches[1]);
                          const c = parseFloat(matches[2]);

                          if (a == 0) {
                              param.error = 'Please! Check Your Input.';
                              return param;
                          }

                          if (c != 0) {
                              const step1 = Math.abs(a * c);
                              const divisors_ans = printDivisors(step1);
                              let new_array = [...divisors_ans];
                              let median = 0;

                              if (divisors_ans.length % 2 != 0) {
                                  const length = divisors_ans.length;
                                  const half_length = length / 2;
                                  const median_index = Math.floor(half_length);
                                  median = parseInt(divisors_ans[median_index]);
                                  new_array.splice(median_index, 1);
                              }

                              const toote = new_array.length / 2;
                              const step2_array_first = new_array.slice(0, toote);
                              const step2_array_second = new_array.slice(toote).reverse();

                              if (median > 0) {
                                  step2_array_first.push(median.toString());
                                  step2_array_second.push(median.toString());
                              }

                              const step2_ans_array = [];
                              step2_array_first.forEach((value, key) => {
                                  step2_ans_array.push(parseInt(value) * parseInt(step2_array_second[key]));
                              });

                              const step3_array_first = [];
                              const step3_array_second = [];
                              step2_array_first.forEach((value, key) => {
                                  step3_array_first.push(value);
                                  step3_array_first.push("-" + value);
                                  step3_array_second.push(step2_array_second[key]);
                                  step3_array_second.push("-" + step2_array_second[key]);
                              });

                              const step3_ans_array = [];
                              let pair1, pair2;

                              step3_array_first.forEach((value, key) => {
                                  const val1 = parseInt(value);
                                  const val2 = parseInt(step3_array_second[key]);
                                  
                                  if (c < 0) {
                                      step3_ans_array.push(val1 - val2);
                                      if ((val1 - val2) === b) {
                                          pair1 = val1;
                                          pair2 = val2;
                                      }
                                  } else {
                                      step3_ans_array.push(val1 + val2);
                                      if ((val1 + val2) === b) {
                                          pair1 = val1;
                                          pair2 = val2;
                                      }
                                  }
                              });

                              const square = Math.pow(b, 2) - (4 * a * c);

                              param.tech_divisors_ans = divisors_ans;
                              param.tech_step2_array_first = step2_array_first;
                              param.tech_step2_array_second = step2_array_second;
                              param.tech_step2_ans_array = step2_ans_array;
                              param.tech_step3_array_first = step3_array_first;
                              param.tech_step3_array_second = step3_array_second;
                              param.tech_step3_ans_array = step3_ans_array;
                              param.tech_median = median;
                              param.tech_square = square;

                              if (pair1 !== undefined) param.tech_pair1 = pair1;
                              if (pair2 !== undefined) param.tech_pair2 = pair2;
                          }

                          const variable_ans = variables_list.join("");
                          param.tech_a = Math.floor(a);
                          param.tech_b = Math.floor(b);
                          param.tech_c = Math.floor(c);
                          param.tech_variable_ans = variable_ans;
                      } else {
                          param.tech_ans = buffer[0];
                          param.tech_enter = buffer[1];
                      }

                      param.tech_factors = factors;
                      param.tech_eq_enter = eq_enter;
                      param.tech_all_coeffs = all_coeffs;
                      param.tech_eq_degree = eq_degree;

                  } catch (error) {
                      param.error = 'Please! Check Your Input.';
                      return param;
                  }
              } else {
                  param.error = 'Please! Enter Valid Equation.';
                  return param;
              }
          }

          param.tech_submit = submit;
          return param;
      }

       /**
    * getCalculationLinearApproximationCalculator: Service Method
    * POST: /api/calculators-lol/linear-approximation-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */


    async  getCalculationLinearApproximationCalculator(body) {
              let type = body.tech_type;
              let EnterEq = body.tech_EnterEq;
              let EnterEq1 = body.tech_EnterEq1;
              let point = body.tech_point;

        const result = {};

        try {
            if (type == '1') {
                let eq = EnterEq;
                let pt = point;


                // Input validation
                if (pregMatch(/<|>|&|php|print_r|print|echo|script|=|&|%/i, eq)) {
                    result.error = "Please Enter Valid Input.";
                    return result;
                }

                if (!pt || !eq) {
                    result.error = "Please Enter Valid Input.";
                    return result;
                }

                // Parameter processing - FIXED VERSION
                let parem = processEquationFixed(eq);
                pt = processPoint(pt);


                try {
                    const response = await axios.post('http://167.172.134.148/new-linear', {
                        equ: parem,
                        wrt: 'x',
                        point: pt
                    }, {
                        timeout: 120000,
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded'
                        }
                    });

                    const buffer = response.data;
                      console.log(buffer[0]);
                    if (Array.isArray(buffer) && buffer.length >= 5) {
                        result.tech_fun = Math.round(buffer[0]);
                        result.tech_deri = buffer[1];
                        result.tech_res = buffer[2];
                        result.tech_enter = buffer[3];
                        result.tech_simple = buffer[4];
                    } else {
                        result.error = 'Invalid response format from API';
                    }
                    
                    return result;

                } catch (error) {
                    console.error('API Error Details:', error.response?.data || error.message);
                    result.error = 'Please! Check Your Input.';
                    return result;
                }

            } else if (type == '2') {
                // ... same as before for type 2
                let eq = EnterEq;
                let eq1 = EnterEq1;
                let pt = point;

                // console.log('Type 2 Request:', { eq, eq1, pt });

                if (pregMatch(/<|>|&|php|print_r|print|echo|script|=|&|%/i, eq) || 
                    pregMatch(/<|>|&|php|print_r|print|echo|script|=|&|%/i, eq1)) {
                    result.error = "Please Enter Valid Input.";
                    return result;
                }

                if (!pt || !eq || !eq1) {
                    result.error = "Please Enter Valid Input.";
                    return result;
                }

                let parem = processEquationFixed(eq);
                let parem1 = processEquationFixed(eq1);
                pt = processPoint(pt);

                // console.log('Processed params Type 2:', { parem, parem1, pt });

                try {
                    const response = await axios.get('http://167.172.134.148/linear1', {
                        params: {
                            equ: parem,
                            equ1: parem1,
                            point: pt
                        },
                        timeout: 120000
                    });

                    console.log('API Response Type 2:', response.data);

                    const buffer = response.data.split('@@@');
                    
                    if (buffer.length >= 10) {
                        result.tech_deri = buffer[0];
                        result.tech_deri1 = buffer[1];
                        result.tech_fun = buffer[2];
                        result.tech_fun1 = round(parseFloat(buffer[3]), 8);
                        result.tech_res = buffer[4];
                        result.tech_enter = buffer[5];
                        result.tech_enter1 = buffer[6];
                        result.tech_simple = buffer[7];
                        result.tech_uper = round(parseFloat(buffer[8]), 8);
                        result.tech_lower = round(parseFloat(buffer[9]), 8);
                    } else {
                        result.error = 'Invalid response format from API';
                    }
                    
                    return result;

                } catch (error) {
                    console.error('API Error Type 2:', error.response?.data || error.message);
                    result.error = 'Please! Check Your Input.';
                    return result;
                }

            } else if (type == '3') {
                // ... same as before for type 3
                let eq = EnterEq;
                let pt = point;

                // console.log('Type 3 Request:', { eq, pt });

                if (pregMatch(/<|>|&|php|print_r|print|echo|script|=|&|%/i, eq)) {
                    result.error = "Please Enter Valid Input.";
                    return result;
                }

                if (!eq || !pt) {
                    result.error = "Please Enter Valid Input.";
                    return result;
                }

                let parem = processEquationFixed(eq);
                pt = processPoint(pt);

                // console.log('Processed params Type 3:', { parem, pt });

                try {
                    const response = await axios.get('http://167.172.134.148/linear2', {
                        params: {
                            equ: parem,
                            point: pt
                        },
                        timeout: 120000
                    });

                    // console.log('API Response Type 3:', response.data);

                    const buffer = response.data.split('@@@');
                    
                    if (buffer.length >= 6) {
                        const pointVal = round(parseFloat(buffer[2]), 8);
                        const funDeri = round(parseFloat(buffer[3]), 8);
                        const sinr = round(parseFloat(buffer[4]), 15);
                        const cosr = round(parseFloat(buffer[5]), 15);
                        const soc = ((funDeri * sinr) + (pointVal * cosr)) / ((funDeri * cosr) - (pointVal * sinr));
                        const final = (pointVal * sinr) - (soc * (pointVal * cosr));

                        result.tech_enter = buffer[0];
                        result.tech_deri = buffer[1];
                        result.tech_point = pointVal;
                        result.tech_fun_deri = funDeri;
                        result.tech_sinr = sinr;
                        result.tech_cosr = cosr;
                        result.tech_soc = soc;
                        result.tech_final = final;
                    } else {
                        result.error = 'Invalid response format from API';
                    }
                    
                    return result;

                } catch (error) {
                    console.error('API Error Type 3:', error.response?.data || error.message);
                    result.error = 'Please! Check Your Input.';
                    return result;
                }
            } else {
                result.error = "Invalid type specified";
                return result;
            }

        } catch (error) {
            console.error('Unexpected Error:', error);
            result.error = 'An unexpected error occurred.';
            return result;
        }
        
        // FIXED Equation Processing Function
        function processEquationFixed(eq) {
            if (!eq) return '';
            
            return eq
                .replace(/ /g, '')
                .replace(/%20/g, '')
                .replace(/{/g, '(')
                .replace(/}/g, ')')
                .replace(/e\^/g, 'exp')
                .replace(/exp\^/g, 'exp')
                .replace(/\^/g, '**')
                .replace(/e\^sqrt\(x\)/g, 'exp(2*x)');
            // NOTE: + ko plus nahi replace karna - yehi problem hai
        }
        
        // Alternative: Agar API ko plus ki jarurat hai toh sirf specific cases mein replace karein
        function processEquationAlternative(eq) {
            if (!eq) return '';
            
            let processed = eq
                .replace(/ /g, '')
                .replace(/%20/g, '')
                .replace(/{/g, '(')
                .replace(/}/g, ')')
                .replace(/e\^/g, 'exp')
                .replace(/exp\^/g, 'exp')
                .replace(/\^/g, '**')
                .replace(/e\^sqrt\(x\)/g, 'exp(2*x)');
            
            // Sirf mathematical plus signs ko replace karein, variable names mein nahi
            processed = processed.replace(/(\d)(\+)(\d)/g, '$1plus$3');
            
            return processed;
        }
        
        // Helper functions
        function pregMatch(pattern, string) {
            return new RegExp(pattern.source || pattern).test(string);
        }
        
        function processPoint(point) {
            if (!point) return '';
            
            return point
                .replace(/inf/g, 'oo')
                .replace(/∞/g, 'oo')
                .replace(/e/g, '2.71828')
                .replace(/E/g, '2.71828');
        }
        
        function round(value, decimals) {
            if (isNaN(value)) return value;
            return Number(Math.round(parseFloat(value) + 'e' + decimals) + 'e-' + decimals);
        }
    }

   /**
    * getCalculationAverageTateOfChangeCalculator: Service Method
    * POST: /api/calculators-lol/average-rate-of-change-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */


 async getCalculationAverageTateOfChangeCalculator(body) {
        let x = body.tech_x;
        let x1 = body.tech_x1;
        let x2 = body.tech_x2;
      
      // Validation regex check
      if (/[<>&]|php|print_r|print|echo|script|=|sin|cos|tan|arcsin|arccos|arctan|&|%/i.test(x)) {
          return {
              error: 'Please! Check Your Input.'
          };
      }
      
      // Check if x1 and x2 are numeric and x is not empty
      if (!isNaN(parseFloat(x1)) && !isNaN(parseFloat(x2)) && x && x.trim() !== '') {
          let parem = x;
          
          // String replacements
          parem = parem.replace(/\s/g, '');
          parem = parem.replace(/\+/g, 'plus');
          parem = parem.replace(/%20/g, '');
          parem = parem.replace(/\{/g, '(');
          parem = parem.replace(/\}/g, ')');
          parem = parem.replace(/e\^/g, 'exp');
          parem = parem.replace(/exp\^/g, 'exp');
          parem = parem.replace(/\^/g, '**');
          parem = parem.replace(/e\^sqrt\(x\)/g, 'exp(2*x)');
          
          try {
              const axios = require('axios');
              
              const response = await axios.post('http://167.172.134.148/new-arocc', 
                  new URLSearchParams({
                      equ: parem,
                      x1: x1,
                      x2: x2
                  }), 
                  {
                      timeout: 120000,
                      headers: {
                          'Content-Type': 'application/x-www-form-urlencoded'
                      }
                  }
              );
              
              const buffer = response.data;
              
              return {
                  tech_eq: buffer[0],
                  tech_fx1: Math.round(buffer[1] * 100) / 100,
                  tech_fx2: Math.round(buffer[2] * 100) / 100,
                  tech_ans: Math.round(buffer[3] * 1000) / 1000,
              };
              
          } catch (error) {
              return {
                  error: 'Please! Check Your Input.'
              };
          }
      } else {
          return {
              error: 'Please! Check Your Input.'
          };
      }
  }

   /**
    * getCalculationEulersMethodCalculator: Service Method
    * POST: /api/calculators-lol/eulers-method-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */


    async getCalculationEulersMethodCalculator(body) {
      let EnterEq = body.tech_EnterEq;
      let steps = body.tech_steps;
      let size = body.tech_size;
      let ini = body.tech_ini;
      let con = body.tech_con;
      let find = body.tech_find;
      
      // Validation check
      if (!EnterEq || EnterEq.trim() == '') {
          return {
              error: 'Please! Check Your Input.'
          };
      }
      
      // Check equation for variables
      let check_eq = EnterEq.replace(/\s/g, '');
      check_eq = check_eq.replace(/sqrt/g, '');
      check_eq = check_eq.replace(/exp/g, '');
      check_eq = check_eq.replace(/y=/g, '');
      check_eq = check_eq.replace(/f\(x\)=/g, '');
      check_eq = check_eq.replace(/y′=/g, '');
      check_eq = check_eq.replace(/y'=/g, '');
      
      let check = '';
      let one = '';
      let two = '';
      
      if (/x/i.test(check_eq) && /y/i.test(check_eq)) {
          one = 'x';
          two = 'y';
          check = 'xy';
      }
      
      let check2 = '';
      if (/t/i.test(check_eq) && /y/i.test(check_eq)) {
          check2 = 'ty';
          one = 't';
          two = 'y';
      }
      
      // Check for conflicting variables
      if (check == 'xy' && check2 == 'ty') {
          return {
              error: 'Equestion contain more variables.'
          };
      }
      
      if (check2 == '' && check == '') {
          return {
              error: 'Please check equation.'
          };
      }
      
      // Check if all parameters are numeric
      if (!isNaN(parseFloat(size)) && !isNaN(parseFloat(ini)) && 
          !isNaN(parseFloat(con)) && !isNaN(parseFloat(find))) {
          
          let parem = EnterEq;
          parem = parem.replace(/\s/g, '');
          parem = parem.replace(/y=/g, '');
          parem = parem.replace(/f\(x\)=/g, '');
          parem = parem.replace(/y′=/g, '');
          parem = parem.replace(/y'=/g, '');
          parem = parem.replace(/\+/g, 'plus');
          parem = parem.replace(/\{/g, '(');
          parem = parem.replace(/\}/g, ')');
          parem = parem.replace(/e\^x/g, 'exp(x)');
          parem = parem.replace(/e\^y/g, 'exp(y)');
          parem = parem.replace(/e\^/g, 'exp');
          parem = parem.replace(/exp\^/g, 'exp');
          parem = parem.replace(/\^/g, '**');
          
          let end = parseFloat(ini);
          let h;
          
          // Calculate step size
          if (steps == 'h') {
              if (parseFloat(size) > parseFloat(find)) {
                  return {
                      error: 'Step Size cannot be greater than t1.'
                  };
              }
              h = parseFloat(size);
          } else {
              if (parseFloat(ini) >= parseFloat(find)) {
                  return {
                      error: 't1 value should be greater than the initial value.'
                  };
              }
              h = (parseFloat(find) - parseFloat(ini)) / parseFloat(size);
          }
          
          // Calculate length/iterations - YE LINE CHANGE HUI HAI
          let length = 0;
          let tempEnd = parseFloat(ini);
          // Floating point precision ke liye tolerance add kiya
          const tolerance = 1e-10;
          while (tempEnd < parseFloat(find) - tolerance) {
              tempEnd = tempEnd + h;
              length++;
          }
          
          if (length > 100) {
              if (steps == 'h') {
                  return {
                      error: 'Step Size too small.'
                  };
              } else {
                  return {
                      error: 'Number of steps too large.'
                  };
              }
          }
          
          try {
              const axios = require('axios');
              
              const response = await axios.post('http://167.172.134.148/new-eulers',
                  new URLSearchParams({
                      equ: parem,
                      one: one,
                      two: two,
                      ini: parseFloat(ini).toString(),
                      h: h.toString(),
                      con: parseFloat(con).toString(),
                      find: parseFloat(find).toString()
                  }),
                  {
                      timeout: 120000,
                      headers: {
                          'Content-Type': 'application/x-www-form-urlencoded'
                      }
                  }
              );
              
              const buffer = response.data;
              const steps_arr = buffer[0].split('HA');
              const steps1_arr = buffer[1].split('HA');
              
              return {
                  tech_steps: steps_arr,
                  tech_steps1: steps1_arr,
                  tech_ans: buffer[2],
                  tech_enter: buffer[3],
                  tech_one: one,
                  tech_two: two,
                  tech_ini: parseFloat(ini).toString(),
                  tech_h: h,
                  tech_con: parseFloat(con).toString(),
                  tech_step: steps,
                  tech_find: parseFloat(find).toString(),
              };
              
          } catch (error) {
              console.error('API Error:', error.message);
              return {
                  error: 'Please! Check Your Input.'
              };
          }
      } else {
          return {
              error: 'Please! Check Your Input.'
          };
      }
  }

    /**
    * getCalculationTriangleCalculator: Service Method
    * POST: /api/calculators-lol/triangle-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */


    async getCalculationTriangleCalculator(body) {
      // Helper function to convert decimal degrees to DMS
          function DDtoDMS(dec) {
              const vars = dec.toString().split(".");
              const deg = parseInt(vars[0]);
              let tempma = parseFloat("0." + (vars[1] || "0"));
              
              tempma = tempma * 3600;
              const min = Math.floor(tempma / 60);
              const sec = Math.round(tempma - (min * 60));
              
              return { deg: deg, min: min, sec: sec };
          }
          
          let a = body.tech_a;
          let b = body.tech_b;
          let c = body.tech_c;
          let A = body.tech_A;
          let B = body.tech_B;
          let C = body.tech_C;
          let unit = body.tech_unit;
          
          // Convert empty strings to null/undefined
          a = a == '' ? null : a;
          b = b == '' ? null : b;
          c = c == '' ? null : c;
          A = A == '' ? null : A;
          B = B == '' ? null : B;
          C = C == '' ? null : C;
          
          let check = false;
          let comb = 0;
          let Ar, Ad, At, Br, Bd, Bt, Cr, Cd, Ct;
          let area, peri, semi, ha, hb, hc, ma, mb, mc, inr, circ;
          let result = {};
          
          // Helper function to convert degrees to radians
          const deg2rad = (deg) => deg * (Math.PI / 180);
          
          // Helper function to convert radians to degrees
          const rad2deg = (rad) => rad * (180 / Math.PI);
          
          // Case 1: Three sides given (SSS)
          if (a != null && !isNaN(a) && b != null && !isNaN(b) && c != null && !isNaN(c) && 
              (A == null || A == '') && (B == null || B == '') && (C == null || C == '')) {
              
              a = parseFloat(a);
              b = parseFloat(b);
              c = parseFloat(c);
              
              A = (Math.pow(b, 2) + Math.pow(c, 2) - Math.pow(a, 2)) / (2 * b * c);
              Ar = Math.acos(A);
              Ad = rad2deg(Ar);
              At = DDtoDMS(Ad);
              
              B = (Math.pow(a, 2) + Math.pow(c, 2) - Math.pow(b, 2)) / (2 * a * c);
              Br = Math.acos(B);
              Bd = rad2deg(Br);
              Bt = DDtoDMS(Bd);
              
              C = (Math.pow(a, 2) + Math.pow(b, 2) - Math.pow(c, 2)) / (2 * a * b);
              Cr = Math.acos(C);
              Cd = rad2deg(Cr);
              Ct = DDtoDMS(Cd);
              
              check = true;
              comb = 1;
          }
          // Case 2: Two sides and one angle (a, b, A) - SSA
          else if (a != null && !isNaN(a) && b != null && !isNaN(b) && (c == null || c == '') && 
                  A != null && A !== '' && (B == null || B == '') && (C == null || C == '')) {
              
              a = parseFloat(a);
              b = parseFloat(b);
              
              // Process angle A
              if (unit == '1') {
                  Ad = parseFloat(A);
                  At = DDtoDMS(Ad);
                  Ar = deg2rad(Ad);
              } else {
                  const Ac = A.split('/');
                  if (Ac.length == 2) {
                      if (Ac[0] == 'pi' || Ac[0] == 'pi()') {
                          if (!isNaN(Ac[1])) {
                              Ad = 180 / parseFloat(Ac[1]);
                              Ar = deg2rad(Ad);
                              At = DDtoDMS(Ad);
                          } else {
                              return { error: 'Please! Check Your Input.' };
                          }
                      }
                  } else if (!isNaN(A)) {
                      Ar = parseFloat(A);
                      Ad = rad2deg(Ar);
                      At = DDtoDMS(Ad);
                  }
              }
              
              if (Ad >= 180) {
                  return { error: 'Angle ∠A is too big.' };
              }
              
              Br = Math.asin(b * Math.sin(Ar) / a);
              
              if (isNaN(Br) || !isFinite(Br)) {
                  return { error: "These three values can't be used to develop a valid triangle." };
              } else {
                  Bd = rad2deg(Br);
                  Bt = DDtoDMS(Bd);
                  Cd = 180 - Ad - Bd;
                  Cr = deg2rad(Cd);
                  Ct = DDtoDMS(Cd);
                  c = Math.round((a * Math.sin(Cr)) / Math.sin(Ar) * 100000) / 100000;
                  
                  const B1 = Math.asin((b * Math.sin(Ar)) / a);
                  const Bd1 = 180 - rad2deg(B1);
                  const Bt1 = DDtoDMS(Bd1);
                  const Br1 = deg2rad(Bd1);
                  const Cd1 = 180 - Bd1 - Ad;
                  
                  if (Cd1 > 0) {
                      const Ct1 = DDtoDMS(Cd1);
                      const Cr1 = deg2rad(Cd1);
                      const c1 = (a * Math.sin(Cr1)) / Math.sin(Ar);
                      const area1 = Math.round((a * b * Math.sin(Cr)) / 2 * 100000) / 100000;
                      const peri1 = a + b + c1;
                      const semi1 = Math.round((a + b + c1) / 2 * 100000) / 100000;
                      const ha1 = Math.round((2 * area1) / a * 100000) / 100000;
                      const hb1 = Math.round((2 * area1) / b * 100000) / 100000;
                      const hc1 = Math.round((2 * area1) / c1 * 100000) / 100000;
                      const ma1 = Math.round(Math.sqrt(Math.pow(a / 2, 2) + Math.pow(c1, 2) - (a * c1 * Math.cos(Br1))) * 100000) / 100000;
                      const mb1 = Math.round(Math.sqrt(Math.pow(b / 2, 2) + Math.pow(a, 2) - (a * b * Math.cos(Cr1))) * 100000) / 100000;
                      const mc1 = Math.round(Math.sqrt(Math.pow(c1 / 2, 2) + Math.pow(b, 2) - (b * c1 * Math.cos(Ar))) * 100000) / 100000;
                      const inr1 = Math.round(area1 / semi1 * 100000) / 100000;
                      const circ1 = Math.round(a / (2 * Math.sin(Ar)) * 100000) / 100000;
                      
                      result.comb2 = 2;
                      result.c1 = c1;
                      result.Br1 = Br1;
                      result.Bd1 = Bd1;
                      result.Bt1 = Bt1;
                      result.Cr1 = Cr1;
                      result.Cd1 = Cd1;
                      result.Ct1 = Ct1;
                      result.area1 = area1;
                      result.peri1 = peri1;
                      result.semi1 = semi1;
                      result.ha1 = ha1;
                      result.hb1 = hb1;
                      result.hc1 = hc1;
                      result.ma1 = ma1;
                      result.mb1 = mb1;
                      result.mc1 = mc1;
                      result.inr1 = inr1;
                      result.circ1 = circ1;
                  }
                  
                  check = true;
                  comb = 2;
              }
          }
          // Case 3: Two sides and one angle (a, b, B) - SSA
          else if (a != null && !isNaN(a) && b != null && !isNaN(b) && (c == null || c == '') && 
                  (A == null || A == '') && B != null && B != '' && (C == null || C == '')) {
              
              a = parseFloat(a);
              b = parseFloat(b);
              
              // Process angle B
              if (unit == '1') {
                  Bd = parseFloat(B);
                  Bt = DDtoDMS(Bd);
                  Br = deg2rad(Bd);
              } else {
                  const Bc = B.split('/');
                  if (Bc.length == 2) {
                      if (Bc[0] == 'pi' || Bc[0] == 'pi()') {
                          if (!isNaN(Bc[1])) {
                              Bd = 180 / parseFloat(Bc[1]);
                              Br = deg2rad(Bd);
                              Bt = DDtoDMS(Bd);
                          } else {
                              return { error: 'Please! Check Your Input.' };
                          }
                      }
                  } else if (!isNaN(B)) {
                      Br = parseFloat(B);
                      Bd = rad2deg(Br);
                      Bt = DDtoDMS(Bd);
                  }
              }
              
              if (Bd >= 180) {
                  return { error: 'Angle ∠B is too big.' };
              }
              
              A = Math.asin((a * Math.sin(Br)) / b);
              Ar = A;
              Ad = rad2deg(Ar);
              At = DDtoDMS(Ad);
              Cd = 180 - Ad - Bd;
              Ct = DDtoDMS(Cd);
              Cr = deg2rad(Cd);
              c = Math.round((b * Math.sin(Cr)) / Math.sin(Br) * 100000) / 100000;
              comb = 3;
              check = true;
          }
          // Case 4: Two sides and included angle (a, b, C) - SAS
          else if (a != null && !isNaN(a) && b != null && !isNaN(b) && (c == null || c == '') && 
                  (A == null || A == '') && (B == null || B == '') && C != null && C != '') {
              
              a = parseFloat(a);
              b = parseFloat(b);
              
              // Process angle C
              if (unit == '1') {
                  Cd = parseFloat(C);
                  Ct = DDtoDMS(Cd);
                  Cr = deg2rad(Cd);
              } else {
                  const Cc = C.split('/');
                  if (Cc.length == 2) {
                      if (Cc[0] == 'pi' || Cc[0] == 'pi()') {
                          if (!isNaN(Cc[1])) {
                              Cd = 180 / parseFloat(Cc[1]);
                              Cr = deg2rad(Cd);
                              Ct = DDtoDMS(Cd);
                          } else {
                              return { error: 'Please! Check Your Input.' };
                          }
                      }
                  } else if (!isNaN(C)) {
                      Cr = parseFloat(C);
                      Cd = rad2deg(Cr);
                      Ct = DDtoDMS(Cd);
                  }
              }
              
              if (Cd >= 180) {
                  return { error: 'Angle ∠C is too big.' };
              }
              
              c = Math.round(Math.sqrt(Math.pow(b, 2) + Math.pow(a, 2) - (2 * b * a * Math.cos(Cr))) * 100000) / 100000;
              B = Math.acos((Math.pow(c, 2) + Math.pow(a, 2) - Math.pow(b, 2)) / (2 * c * a));
              Br = B;
              Bd = rad2deg(Br);
              Bt = DDtoDMS(Bd);
              A = Math.acos((Math.pow(c, 2) + Math.pow(b, 2) - Math.pow(a, 2)) / (2 * c * b));
              Ar = A;
              Ad = rad2deg(Ar);
              At = DDtoDMS(Ad);
              comb = 4;
              check = true;
          }
          // Case 5: One side and two angles (a, A, B) - AAS
          else if (a != null && !isNaN(a) && (b == null || b == '') && (c == null || c == '') && 
                  A != null && A != '' && B != null && B != '' && (C == null || C == '')) {
              
              a = parseFloat(a);
              
              // Process angle B
              if (unit == '1') {
                  Bd = parseFloat(B);
                  Bt = DDtoDMS(Bd);
                  Br = deg2rad(Bd);
              } else {
                  const Bc = B.split('/');
                  if (Bc.length == 2) {
                      if (Bc[0] == 'pi' || Bc[0] == 'pi()') {
                          if (!isNaN(Bc[1])) {
                              Bd = 180 / parseFloat(Bc[1]);
                              Br = deg2rad(Bd);
                              Bt = DDtoDMS(Bd);
                          } else {
                              return { error: 'Please! Check Your Input.' };
                          }
                      }
                  } else if (!isNaN(B)) {
                      Br = parseFloat(B);
                      Bd = rad2deg(Br);
                      Bt = DDtoDMS(Bd);
                  }
              }
              
              if (Bd >= 180) {
                  return { error: 'Angle ∠B is too big.' };
              }
              
              // Process angle A
              if (unit == '1') {
                  Ad = parseFloat(A);
                  At = DDtoDMS(Ad);
                  Ar = deg2rad(Ad);
              } else {
                  const Ac = A.split('/');
                  if (Ac.length == 2) {
                      if (Ac[0] == 'pi' || Ac[0] == 'pi()') {
                          if (!isNaN(Ac[1])) {
                              Ad = 180 / parseFloat(Ac[1]);
                              Ar = deg2rad(Ad);
                              At = DDtoDMS(Ad);
                          } else {
                              return { error: 'Please! Check Your Input.' };
                          }
                      }
                  } else if (!isNaN(A)) {
                      Ar = parseFloat(A);
                      Ad = rad2deg(Ar);
                      At = DDtoDMS(Ad);
                  }
              }
              
              if (Ad >= 180) {
                  return { error: 'Angle ∠A is too big.' };
              }
              
              if ((Ad + Bd) >= 180) {
                  return { error: "These three values can't be used to develop a valid triangle." };
              }
              
              Cd = 180 - Ad - Bd;
              Cr = deg2rad(Cd);
              Ct = DDtoDMS(Cd);
              b = Math.round((a * Math.sin(Br)) / Math.sin(Ar) * 100000) / 100000;
              c = Math.round((a * Math.sin(Cr)) / Math.sin(Ar) * 100000) / 100000;
              comb = 5;
              check = true;
          }
          // Case 6: One side and two angles (b, A, B) - AAS
          else if ((a == null || a == '') && b != null && !isNaN(b) && (c == null || c == '') && 
                  A != null && A != '' && B != null && B !== '' && (C == null || C == '')) {
              
              b = parseFloat(b);
              
              // Process angle B
              if (unit == '1') {
                  Bd = parseFloat(B);
                  Bt = DDtoDMS(Bd);
                  Br = deg2rad(Bd);
              } else {
                  const Bc = B.split('/');
                  if (Bc.length == 2) {
                      if (Bc[0] == 'pi' || Bc[0] == 'pi()') {
                          if (!isNaN(Bc[1])) {
                              Bd = 180 / parseFloat(Bc[1]);
                              Br = deg2rad(Bd);
                              Bt = DDtoDMS(Bd);
                          } else {
                              return { error: 'Please! Check Your Input.' };
                          }
                      }
                  } else if (!isNaN(B)) {
                      Br = parseFloat(B);
                      Bd = rad2deg(Br);
                      Bt = DDtoDMS(Bd);
                  }
              }
              
              if (Bd >= 180) {
                  return { error: 'Angle ∠B is too big.' };
              }
              
              // Process angle A
              if (unit == '1') {
                  Ad = parseFloat(A);
                  At = DDtoDMS(Ad);
                  Ar = deg2rad(Ad);
              } else {
                  const Ac = A.split('/');
                  if (Ac.length == 2) {
                      if (Ac[0] == 'pi' || Ac[0] == 'pi()') {
                          if (!isNaN(Ac[1])) {
                              Ad = 180 / parseFloat(Ac[1]);
                              Ar = deg2rad(Ad);
                              At = DDtoDMS(Ad);
                          } else {
                              return { error: 'Please! Check Your Input.' };
                          }
                      }
                  } else if (!isNaN(A)) {
                      Ar = parseFloat(A);
                      Ad = rad2deg(Ar);
                      At = DDtoDMS(Ad);
                  }
              }
              
              if (Ad >= 180) {
                  return { error: 'Angle ∠A is too big.' };
              }
              
              if ((Ad + Bd) >= 180) {
                  return { error: "These three values can't be used to develop a valid triangle." };
              }
              
              Cd = 180 - Ad - Bd;
              Cr = deg2rad(Cd);
              Ct = DDtoDMS(Cd);
              a = Math.round((b * Math.sin(Ar)) / Math.sin(Br) * 100000) / 100000;
              c = Math.round((b * Math.sin(Cr)) / Math.sin(Br) * 100000) / 100000;
              comb = 6;
              check = true;
          }
          // Case 7: One side and two angles (c, A, B) - AAS
          else if ((a == null || a == '') && (b == null || b == '') && c != null && !isNaN(c) && 
                  A != null && A != '' && B != null && B != '' && (C == null || C == '')) {
              
              c = parseFloat(c);
              
              // Process angle B
              if (unit == '1') {
                  Bd = parseFloat(B);
                  Bt = DDtoDMS(Bd);
                  Br = deg2rad(Bd);
              } else {
                  const Bc = B.split('/');
                  if (Bc.length == 2) {
                      if (Bc[0] == 'pi' || Bc[0] == 'pi()') {
                          if (!isNaN(Bc[1])) {
                              Bd = 180 / parseFloat(Bc[1]);
                              Br = deg2rad(Bd);
                              Bt = DDtoDMS(Bd);
                          } else {
                              return { error: 'Please! Check Your Input.' };
                          }
                      }
                  } else if (!isNaN(B)) {
                      Br = parseFloat(B);
                      Bd = rad2deg(Br);
                      Bt = DDtoDMS(Bd);
                  }
              }
              
              if (Bd >= 180) {
                  return { error: 'Angle ∠B is too big.' };
              }
              
              // Process angle A
              if (unit == '1') {
                  Ad = parseFloat(A);
                  At = DDtoDMS(Ad);
                  Ar = deg2rad(Ad);
              } else {
                  const Ac = A.split('/');
                  if (Ac.length == 2) {
                      if (Ac[0] == 'pi' || Ac[0] == 'pi()') {
                          if (!isNaN(Ac[1])) {
                              Ad = 180 / parseFloat(Ac[1]);
                              Ar = deg2rad(Ad);
                              At = DDtoDMS(Ad);
                          } else {
                              return { error: 'Please! Check Your Input.' };
                          }
                      }
                  } else if (!isNaN(A)) {
                      Ar = parseFloat(A);
                      Ad = rad2deg(Ar);
                      At = DDtoDMS(Ad);
                  }
              }
              
              if (Ad >= 180) {
                  return { error: 'Angle ∠A is too big.' };
              }
              
              if ((Ad + Bd) >= 180) {
                  return { error: "These three values can't be used to develop a valid triangle." };
              }
              
              Cd = 180 - Ad - Bd;
              Cr = deg2rad(Cd);
              Ct = DDtoDMS(Cd);
              a = Math.round((c * Math.sin(Ar)) / Math.sin(Cr) * 100000) / 100000;
              b = Math.round((c * Math.sin(Br)) / Math.sin(Cr) * 100000) / 100000;
              comb = 7;
              check = true;
          }
          // Case 8: One side and two angles (a, A, C) - AAS
          else if (a != null && !isNaN(a) && (b == null || b == '') && (c == null || c == '') && 
                  A != null && A != '' && (B == null || B == '') && C != null && C != '') {
              
              a = parseFloat(a);
              
              // Process angle A
              if (unit == '1') {
                  Ad = parseFloat(A);
                  At = DDtoDMS(Ad);
                  Ar = deg2rad(Ad);
              } else {
                  const Ac = A.split('/');
                  if (Ac.length == 2) {
                      if (Ac[0] == 'pi' || Ac[0] == 'pi()') {
                          if (!isNaN(Ac[1])) {
                              Ad = 180 / parseFloat(Ac[1]);
                              Ar = deg2rad(Ad);
                              At = DDtoDMS(Ad);
                          } else {
                              return { error: 'Please! Check Your Input.' };
                          }
                      }
                  } else if (!isNaN(A)) {
                      Ar = parseFloat(A);
                      Ad = rad2deg(Ar);
                      At = DDtoDMS(Ad);
                  }
              }
              
              if (Ad >= 180) {
                  return { error: 'Angle ∠A is too big.' };
              }
              
              // Process angle C
              if (unit == '1') {
                  Cd = parseFloat(C);
                  Ct = DDtoDMS(Cd);
                  Cr = deg2rad(Cd);
              } else {
                  const Cc = C.split('/');
                  if (Cc.length == 2) {
                      if (Cc[0] == 'pi' || Cc[0] == 'pi()') {
                          if (!isNaN(Cc[1])) {
                              Cd = 180 / parseFloat(Cc[1]);
                              Cr = deg2rad(Cd);
                              Ct = DDtoDMS(Cd);
                          } else {
                              return { error: 'Please! Check Your Input.' };
                          }
                      }
                  } else if (!isNaN(C)) {
                      Cr = parseFloat(C);
                      Cd = rad2deg(Cr);
                      Ct = DDtoDMS(Cd);
                  }
              }
              
              if (Cd >= 180) {
                  return { error: "Angle ∠C is too big." };
              }
              
              if ((Ad + Cd) >= 180) {
                  return { error: "These three values can't be used to develop a valid triangle." };
              }
              
              Bd = 180 - Ad - Cd;
              Br = deg2rad(Bd);
              Bt = DDtoDMS(Bd);
              b = Math.round((a * Math.sin(Br)) / Math.sin(Ar) * 100000) / 100000;
              c = Math.round((a * Math.sin(Cr)) / Math.sin(Ar) * 100000) / 100000;
              comb = 8;
              check = true;
          }
          // Case 9: One side and two angles (b, A, C) - AAS
          else if ((a == null || a == '') && b != null && !isNaN(b) && (c == null || c == '') && 
                  A != null && A != '' && (B == null || B == '') && C != null && C != '') {
              
              b = parseFloat(b);
              
              // Process angle A
              if (unit == '1') {
                  Ad = parseFloat(A);
                  At = DDtoDMS(Ad);
                  Ar = deg2rad(Ad);
              } else {
                  const Ac = A.split('/');
                  if (Ac.length == 2) {
                      if (Ac[0] == 'pi' || Ac[0] == 'pi()') {
                          if (!isNaN(Ac[1])) {
                              Ad = 180 / parseFloat(Ac[1]);
                              Ar = deg2rad(Ad);
                              At = DDtoDMS(Ad);
                          } else {
                              return { error: 'Please! Check Your Input.' };
                          }
                      }
                  } else if (!isNaN(A)) {
                      Ar = parseFloat(A);
                      Ad = rad2deg(Ar);
                      At = DDtoDMS(Ad);
                  }
              }
              
              if (Ad >= 180) {
                  return { error: 'Angle ∠A is too big.' };
              }
              
              // Process angle C
              if (unit == '1') {
                  Cd = parseFloat(C);
                  Ct = DDtoDMS(Cd);
                  Cr = deg2rad(Cd);
              } else {
                  const Cc = C.split('/');
                  if (Cc.length == 2) {
                      if (Cc[0] == 'pi' || Cc[0] == 'pi()') {
                          if (!isNaN(Cc[1])) {
                              Cd = 180 / parseFloat(Cc[1]);
                              Cr = deg2rad(Cd);
                              Ct = DDtoDMS(Cd);
                          } else {
                              return { error: 'Please! Check Your Input.' };
                          }
                      }
                  } else if (!isNaN(C)) {
                      Cr = parseFloat(C);
                      Cd = rad2deg(Cr);
                      Ct = DDtoDMS(Cd);
                  }
              }
              
              if (Cd >= 180) {
                  return { error: "Angle ∠C is too big." };
              }
              
              if ((Ad + Cd) >= 180) {
                  return { error: "These three values can't be used to develop a valid triangle." };
              }
              
              Bd = 180 - Ad - Cd;
              Br = deg2rad(Bd);
              Bt = DDtoDMS(Bd);
              a = Math.round((b * Math.sin(Ar)) / Math.sin(Br) * 100000) / 100000;
              c = Math.round((b * Math.sin(Cr)) / Math.sin(Br) * 100000) / 100000;
              comb = 9;
              check = true;
          }
          // Case 10: One side and two angles (c, A, C) - AAS
          else if ((a == null || a == '') && (b == null || b == '') && c != null && !isNaN(c) && 
                  A != null && A != '' && (B == null || B == '') && C != null && C != '') {
              
              c = parseFloat(c);
              
              // Process angle A
              if (unit == '1') {
                  Ad = parseFloat(A);
                  At = DDtoDMS(Ad);
                  Ar = deg2rad(Ad);
              } else {
                  const Ac = A.split('/');
                  if (Ac.length == 2) {
                      if (Ac[0] == 'pi' || Ac[0] == 'pi()') {
                          if (!isNaN(Ac[1])) {
                              Ad = 180 / parseFloat(Ac[1]);
                              Ar = deg2rad(Ad);
                              At = DDtoDMS(Ad);
                          } else {
                              return { error: 'Please! Check Your Input.' };
                          }
                      }
                  } else if (!isNaN(A)) {
                      Ar = parseFloat(A);
                      Ad = rad2deg(Ar);
                      At = DDtoDMS(Ad);
                  }
              }
              
              if (Ad >= 180) {
                  return { error: 'Angle ∠A is too big.' };
              }
              
              // Process angle C
              if (unit == '1') {
                  Cd = parseFloat(C);
                  Ct = DDtoDMS(Cd);
                  Cr = deg2rad(Cd);
              } else {
                  const Cc = C.split('/');
                  if (Cc.length == 2) {
                      if (Cc[0] == 'pi' || Cc[0] == 'pi()') {
                          if (!isNaN(Cc[1])) {
                              Cd = 180 / parseFloat(Cc[1]);
                              Cr = deg2rad(Cd);
                              Ct = DDtoDMS(Cd);
                          } else {
                              return { error: 'Please! Check Your Input.' };
                          }
                      }
                  } else if (!isNaN(C)) {
                      Cr = parseFloat(C);
                      Cd = rad2deg(Cr);
                      Ct = DDtoDMS(Cd);
                  }
              }
              
              if ((Ad + Cd) >= 180) {
                  return { error: "These three values can't be used to develop a valid triangle." };
              }
              if (Cd >= 180) {
                  return { error: "Angle ∠C is too big." };
              }
              
              Bd = 180 - Ad - Cd;
              Br = deg2rad(Bd);
              Bt = DDtoDMS(Bd);
              a = Math.round((c * Math.sin(Ar)) / Math.sin(Cr) * 100000) / 100000;
              b = Math.round((c * Math.sin(Br)) / Math.sin(Cr) * 100000) / 100000;
              comb = 10;
              check = true;
          }
          // Case 11: One side and two angles (a, B, C) - AAS
          else if (a != null && !isNaN(a) && (b == null || b == '') && (c == null || c == '') && 
                  (A == null || A == '') && B != null && B != '' && C != null && C != '') {
              
              a = parseFloat(a);
              
              // Process angle C
              if (unit == '1') {
                  Cd = parseFloat(C);
                  Ct = DDtoDMS(Cd);
                  Cr = deg2rad(Cd);
              } else {
                  const Cc = C.split('/');
                  if (Cc.length == 2) {
                      if (Cc[0] == 'pi' || Cc[0] == 'pi()') {
                          if (!isNaN(Cc[1])) {
                              Cd = 180 / parseFloat(Cc[1]);
                              Cr = deg2rad(Cd);
                              Ct = DDtoDMS(Cd);
                          } else {
                              return { error: 'Please! Check Your Input.' };
                          }
                      }
                  } else if (!isNaN(C)) {
                      Cr = parseFloat(C);
                      Cd = rad2deg(Cr);
                      Ct = DDtoDMS(Cd);
                  }
              }
              
              if (Cd >= 180) {
                  return { error: "Angle ∠C is too big." };
              }
              
              // Process angle B
              if (unit == '1') {
                  Bd = parseFloat(B);
                  Bt = DDtoDMS(Bd);
                  Br = deg2rad(Bd);
              } else {
                  const Bc = B.split('/');
                  if (Bc.length == 2) {
                      if (Bc[0] == 'pi' || Bc[0] == 'pi()') {
                          if (!isNaN(Bc[1])) {
                              Bd = 180 / parseFloat(Bc[1]);
                              Br = deg2rad(Bd);
                              Bt = DDtoDMS(Bd);
                          } else {
                              return { error: 'Please! Check Your Input.' };
                          }
                      }
                  } else if (!isNaN(B)) {
                      Br = parseFloat(B);
                      Bd = rad2deg(Br);
                      Bt = DDtoDMS(Bd);
                  }
              }
              
              if (Bd >= 180) {
                  return { error: 'Angle ∠B is too big.' };
              }
              
              if ((Bd + Cd) >= 180) {
                  return { error: "These three values can't be used to develop a valid triangle." };
              }
              
              Ad = 180 - Bd - Cd;
              Ar = deg2rad(Ad);
              At = DDtoDMS(Ad);
              b = Math.round((a * Math.sin(Br)) / Math.sin(Ar) * 100000) / 100000;
              c = Math.round((a * Math.sin(Cr)) / Math.sin(Ar) * 100000) / 100000;
              comb = 11;
              check = true;
          }
          // Case 12: One side and two angles (b, B, C) - AAS
          else if ((a == null || a == '') && b != null && !isNaN(b) && (c == null || c == '') && 
                  (A == null || A == '') && B != null && B != '' && C != null && C != '') {
              
              b = parseFloat(b);
              
              // Process angle C
              if (unit == '1') {
                  Cd = parseFloat(C);
                  Ct = DDtoDMS(Cd);
                  Cr = deg2rad(Cd);
              } else {
                  const Cc = C.split('/');
                  if (Cc.length == 2) {
                      if (Cc[0] == 'pi' || Cc[0] == 'pi()') {
                          if (!isNaN(Cc[1])) {
                              Cd = 180 / parseFloat(Cc[1]);
                              Cr = deg2rad(Cd);
                              Ct = DDtoDMS(Cd);
                          } else {
                              return { error: 'Please! Check Your Input.' };
                          }
                      }
                  } else if (!isNaN(C)) {
                      Cr = parseFloat(C);
                      Cd = rad2deg(Cr);
                      Ct = DDtoDMS(Cd);
                  }
              }
              
              if (Cd >= 180) {
                  return { error: "Angle ∠C is too big." };
              }
              
              // Process angle B
              if (unit == '1') {
                  Bd = parseFloat(B);
                  Bt = DDtoDMS(Bd);
                  Br = deg2rad(Bd);
              } else {
                  const Bc = B.split('/');
                  if (Bc.length == 2) {
                      if (Bc[0] == 'pi' || Bc[0] == 'pi()') {
                          if (!isNaN(Bc[1])) {
                              Bd = 180 / parseFloat(Bc[1]);
                              Br = deg2rad(Bd);
                              Bt = DDtoDMS(Bd);
                          } else {
                              return { error: 'Please! Check Your Input.' };
                          }
                      }
                  } else if (!isNaN(B)) {
                      Br = parseFloat(B);
                      Bd = rad2deg(Br);
                      Bt = DDtoDMS(Bd);
                  }
              }
              
              if (Bd >= 180) {
                  return { error: 'Angle ∠B is too big.' };
              }
              
              if ((Bd + Cd) >= 180) {
                  return { error: "These three values can't be used to develop a valid triangle." };
              }
              
              Ad = 180 - Bd - Cd;
              Ar = deg2rad(Ad);
              At = DDtoDMS(Ad);
              a = Math.round((b * Math.sin(Ar)) / Math.sin(Br) * 100000) / 100000;
              c = Math.round((b * Math.sin(Cr)) / Math.sin(Br) * 100000) / 100000;
              comb = 12;
              check = true;
          }
          // Case 13: One side and two angles (c, B, C) - AAS
          else if ((a == null || a == '') && (b == null || b == '') && c != null && !isNaN(c) && 
                  (A == null || A == '') && B != null && B != '' && C != null && C != '') {
              
              c = parseFloat(c);
              
              // Process angle C
              if (unit == '1') {
                  Cd = parseFloat(C);
                  Ct = DDtoDMS(Cd);
                  Cr = deg2rad(Cd);
              } else {
                  const Cc = C.split('/');
                  if (Cc.length == 2) {
                      if (Cc[0] == 'pi' || Cc[0] == 'pi()') {
                          if (!isNaN(Cc[1])) {
                              Cd = 180 / parseFloat(Cc[1]);
                              Cr = deg2rad(Cd);
                              Ct = DDtoDMS(Cd);
                          } else {
                              return { error: 'Please! Check Your Input.' };
                          }
                      }
                  } else if (!isNaN(C)) {
                      Cr = parseFloat(C);
                      Cd = rad2deg(Cr);
                      Ct = DDtoDMS(Cd);
                  }
              }
              
              if (Cd >= 180) {
                  return { error: "Angle ∠C is too big." };
              }
              
              // Process angle B
              if (unit == '1') {
                  Bd = parseFloat(B);
                  Bt = DDtoDMS(Bd);
                  Br = deg2rad(Bd);
              } else {
                  const Bc = B.split('/');
                  if (Bc.length == 2) {
                      if (Bc[0] == 'pi' || Bc[0] == 'pi()') {
                          if (!isNaN(Bc[1])) {
                              Bd = 180 / parseFloat(Bc[1]);
                              Br = deg2rad(Bd);
                              Bt = DDtoDMS(Bd);
                          } else {
                              return { error: 'Please! Check Your Input.' };
                          }
                      }
                  } else if (!isNaN(B)) {
                      Br = parseFloat(B);
                      Bd = rad2deg(Br);
                      Bt = DDtoDMS(Bd);
                  }
              }
              
              if (Bd >= 180) {
                  return { error: 'Angle ∠B is too big.' };
              }
              
              if ((Bd + Cd) >= 180) {
                  return { error: "These three values can't be used to develop a valid triangle." };
              }
              
              Ad = 180 - Bd - Cd;
              Ar = deg2rad(Ad);
              At = DDtoDMS(Ad);
              a = Math.round((c * Math.sin(Ar)) / Math.sin(Cr) * 100000) / 100000;
              b = Math.round((c * Math.sin(Br)) / Math.sin(Cr) * 100000) / 100000;
              comb = 13;
              check = true;
          }
          
          // Calculate additional properties if triangle is valid
          if (check === true) {
              area = Math.round((a * b * Math.sin(Cr)) / 2 * 100000) / 100000;
              peri = a + b + c;
              semi = Math.round((a + b + c) / 2 * 100000) / 100000;
              ha = Math.round((2 * area) / a * 100000) / 100000;
              hb = Math.round((2 * area) / b * 100000) / 100000;
              hc = Math.round((2 * area) / c * 100000) / 100000;
              ma = Math.round(Math.sqrt(Math.pow(a / 2, 2) + Math.pow(c, 2) - (a * c * Math.cos(Br))) * 100000) / 100000;
              mb = Math.round(Math.sqrt(Math.pow(b / 2, 2) + Math.pow(a, 2) - (a * b * Math.cos(Cr))) * 100000) / 100000;
              mc = Math.round(Math.sqrt(Math.pow(c / 2, 2) + Math.pow(b, 2) - (b * c * Math.cos(Ar))) * 100000) / 100000;
              inr = Math.round(area / semi * 100000) / 100000;
              circ = Math.round(a / (2 * Math.sin(Ar)) * 100000) / 100000;
              
              result.tech_a = a;
              result.tech_b = b;
              result.tech_c = c;
              result.tech_Ar = Ar;
              result.tech_Ad = Ad;
              result.tech_At = At;
              result.tech_Br = Br;
              result.tech_Bd = Bd;
              result.tech_Bt = Bt;
              result.tech_Cr = Cr;
              result.tech_Cd = Cd;
              result.tech_Ct = Ct;
              result.tech_area = area;
              result.tech_peri = peri;
              result.tech_semi = semi;
              result.tech_ha = ha;
              result.tech_hb = hb;
              result.tech_hc = hc;
              result.tech_ma = ma;
              result.tech_mb = mb;
              result.tech_mc = mc;
              result.tech_inr = inr;
              result.tech_circ = circ;
              result.tech_comb = comb;
              
              return result;
          } else {
              return { error: "Please! Check Your Input." };
          }
      }


      /**
    * getCalculationTangentPlaneCalculator: Service Method
    * POST: /api/calculators-lol/tangent-plane-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */
    async getCalculationTangentPlaneCalculator(body) {
      let eq = body.tech_eq;
        let x = body.tech_x;
        let y = body.tech_y;
        let z = body.tech_z;
        let type = body.tech_type;
        
        // Validation check
        if (!eq || eq.trim() == '') {
            return {
                error: 'Please Enter Valid Input.'
            };
        }
        
        // Check for invalid characters
        if (/[<>&]|php|print_r|print|echo|script|&|%/i.test(eq)) {
            return {
                error: 'Please Enter Valid Input.'
            };
        }
        
        // Check if x and y are numeric and submit type exists
        if (!isNaN(parseFloat(x)) && !isNaN(parseFloat(y)) && type) {
            let parem = eq;
            parem = parem.replace(/\s/g, '');
            parem = parem.replace(/%20/g, '');
            parem = parem.replace(/\+/g, 'plus');
            parem = parem.replace(/\{/g, '(');
            parem = parem.replace(/\}/g, ')');
            parem = parem.replace(/e\^/g, 'exp');
            parem = parem.replace(/exp\^/g, 'exp');
            parem = parem.replace(/\^/g, '**');
            parem = parem.replace(/e\^sqrt\(x\)/g, 'exp(2*x)');
            
            // Split by = sign
            const paremParts = parem.split('=');
            let finalEq;
            
            if (paremParts.length == 2) {
                finalEq = '(' + paremParts[0] + ')-(' + paremParts[1] + ')';
            } else {
                finalEq = paremParts[0];
            }
            
            try {
                const axios = require('axios');
                let response;
                
                if (type == 'two') {
                    response = await axios.get('http://167.172.134.148/tpc', {
                        params: {
                            eq: finalEq,
                            x: x,
                            y: y,
                            method: type
                        },
                        timeout: 120000
                    });
                } else if (type == 'three') {
                    response = await axios.get('http://167.172.134.148/tpc', {
                        params: {
                            eq: finalEq,
                            x: x,
                            y: y,
                            z: z,
                            method: type
                        },
                        timeout: 120000
                    });
                } else {
                    return {
                        error: 'Please! Check Your Input.'
                    };
                }
                
                const buffer = response.data;
                const bufferParts = buffer.split("@@@");
                
                let result = {};
                
                if (type == 'two') {
                    result.tech_eq = bufferParts[0];
                    result.tech_t = bufferParts[1];
                    result.tech_diffa = bufferParts[2];
                    result.tech_diffb = bufferParts[3];
                    result.tech_stepsx = bufferParts[4];
                    result.tech_stepsy = bufferParts[5];
                    result.tech_a = bufferParts[6];
                    result.tech_b = bufferParts[7];
                    result.tech_c = bufferParts[8];
                } else if (type == 'three') {
                    result.tech_eq = bufferParts[0];
                    result.tech_t = bufferParts[1];
                    result.tech_diffa = bufferParts[2];
                    result.tech_diffb = bufferParts[3];
                    result.tech_diffc = bufferParts[4];
                    result.tech_stepsx = bufferParts[5];
                    result.tech_stepsy = bufferParts[6];
                    result.tech_stepsz = bufferParts[7];
                    result.tech_a = bufferParts[8];
                    result.tech_b = bufferParts[9];
                    result.tech_c = bufferParts[10];
                    result.tech_ans = bufferParts[11];
                }
                
                return result;
                
            } catch (error) {
                console.error('API Error:', error.message);
                return {
                    error: 'Please! Check Your Input.'
                };
            }
        } else {
            return {
                error: 'Please Enter Valid Input.'
            };
        }
    }

        /**
    * getCalculationPerimeterCalculator: Service Method
    * POST: /api/calculators-lol/perimeter-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */
    async getCalculationPerimeterCalculator(body) {
        // Helper function to convert units to cm
        function convertToCm(value, unit) {
            value = parseFloat(value);
            switch(unit) {
                case 'mm':
                    return value * 0.1;
                case 'm':
                    return value * 100;
                case 'in':
                    return value * 2.54;
                case 'ft':
                    return value * 30.48;
                case 'yd':
                    return value * 91.44;
                case 'cm':
                default:
                    return value;
            }
        }
        
        // Helper function to convert degrees to radians
        function deg2rad(deg) {
            return deg * (Math.PI / 180);
        }
        
        let shape = body.tech_shape;
        let given = body.tech_given;
        let givena = body.tech_givena;
        let r = body.tech_r;
        let r_unit = body.tech_r_unit;
        let b = body.tech_b;
        let b_unit = body.tech_b_unit;
        let c = body.tech_c;
        let c_unit = body.tech_c_unit;
        let d = body.tech_d;
        let d_unit = body.tech_d_unit;
        let angle = body.tech_angle;
        let angle_unit = body.tech_angle_unit;
        let angleb = body.tech_angleb;
        let angleb_unit = body.tech_angleb_unit;
        let nbr = body.tech_nbr;
        
        let peri;
        
        // Shape 1: Square
        if (shape == '1') {
            if (r && !isNaN(parseFloat(r))) {
                const rVal = parseFloat(r);
                peri = Math.round((rVal * 4) * 1000) / 1000 + ' ' + r_unit;
                return {
                    tech_peri: peri,
                };
            } else {
                return { error: 'Please! Check Your Input' };
            }
        }
        // Shape 2: Rectangle
        else if (shape == '2') {
            if (r && !isNaN(parseFloat(r)) && b && !isNaN(parseFloat(b))) {
                let rVal = parseFloat(r);
                let bVal = parseFloat(b);
                
                if (r_unit === b_unit) {
                    peri = Math.round(2 * (rVal + bVal) * 1000) / 1000 + ' ' + r_unit;
                } else {
                    rVal = convertToCm(rVal, r_unit);
                    bVal = convertToCm(bVal, b_unit);
                    peri = Math.round(2 * (rVal + bVal) * 1000) / 1000 + ' cm';
                }
                return {
                    tech_peri: peri,
                   
                };
            } else {
                return { error: 'Please! Check Your Input' };
            }
        }
        // Shape 3: Triangle
        else if (shape == '3') {
            if (given == '1') {
                // Three sides given
                if (r && !isNaN(parseFloat(r)) && b && !isNaN(parseFloat(b)) && c && !isNaN(parseFloat(c))) {
                    let rVal = parseFloat(r);
                    let bVal = parseFloat(b);
                    let cVal = parseFloat(c);
                    
                    if (r_unit == b_unit && r_unit == c_unit) {
                        peri = Math.round((rVal + bVal + cVal) * 1000) / 1000 + ' ' + r_unit;
                    } else {
                        rVal = convertToCm(rVal, r_unit);
                        bVal = convertToCm(bVal, b_unit);
                        cVal = convertToCm(cVal, c_unit);
                        peri = Math.round((rVal + bVal + cVal) * 1000) / 1000 + ' cm';
                    }
                    return {
                        tech_peri: peri,
                    };
                } else {
                    return { error: 'Please! Check Your Input' };
                }
            } else if (given == '2') {
                // Two sides and included angle
                if (r && !isNaN(parseFloat(r)) && b && !isNaN(parseFloat(b)) && angleb && !isNaN(parseFloat(angleb))) {
                    let rVal = parseFloat(r);
                    let bVal = parseFloat(b);
                    let anglebVal = parseFloat(angleb);
                    
                    if (angleb_unit == 'deg') {
                        anglebVal = deg2rad(anglebVal);
                    }
                    
                    if (r_unit == b_unit) {
                        peri = Math.round((rVal + bVal + Math.sqrt(Math.pow(rVal, 2) + Math.pow(bVal, 2) - (2 * rVal * bVal) * Math.cos(anglebVal))) * 1000) / 1000 + ' ' + r_unit;
                    } else {
                        rVal = convertToCm(rVal, r_unit);
                        bVal = convertToCm(bVal, b_unit);
                        peri = Math.round((rVal + bVal + Math.sqrt(Math.pow(rVal, 2) + Math.pow(bVal, 2) - (2 * rVal * bVal) * Math.cos(anglebVal))) * 1000) / 1000 + ' cm';
                    }
                    return {
                        tech_peri: peri,
                    };
                } else {
                    return { error: 'Please! Check Your Input' };
                }
            } else if (given == '3') {
                // One side and two angles
                if (r && !isNaN(parseFloat(r)) && angle && !isNaN(parseFloat(angle)) && angleb && !isNaN(parseFloat(angleb))) {
                    let rVal = parseFloat(r);
                    let angleVal = parseFloat(angle);
                    let anglebVal = parseFloat(angleb);
                    
                    if (angleb_unit == 'deg') {
                        anglebVal = deg2rad(anglebVal);
                    }
                    if (angle_unit == 'deg') {
                        angleVal = deg2rad(angleVal);
                    }
                    
                    peri = Math.round((rVal + (rVal / Math.sin(angleVal + anglebVal)) * (Math.sin(angleVal) + Math.sin(anglebVal))) * 1000) / 1000 + ' ' + r_unit;
                    return {
                        tech_peri: peri,
                    };
                } else {
                    return { error: 'Please! Check Your Input' };
                }
            }
        }
        // Shape 4: Circle
        else if (shape == '4') {
            if (r && !isNaN(parseFloat(r))) {
                const rVal = parseFloat(r);
                peri = Math.round((2 * Math.PI * rVal) * 1000) / 1000 + ' ' + r_unit;
                return {
                    tech_peri: peri,
                };
            } else {
                return { error: 'Please! Check Your Input' };
            }
        }
        // Shape 5: Semicircle
        else if (shape == '5') {
            if (r && !isNaN(parseFloat(r))) {
                const rVal = parseFloat(r);
                peri = Math.round((rVal * Math.PI + 2 * rVal) * 1000) / 1000 + ' ' + r_unit;
                return {
                    tech_peri: peri,
                };
            } else {
                return { error: 'Please! Check Your Input' };
            }
        }
        // Shape 6: Sector
        else if (shape == '6') {
            if (r && !isNaN(parseFloat(r)) && angle && !isNaN(parseFloat(angle))) {
                let rVal = parseFloat(r);
                let angleVal = parseFloat(angle);
                
                if (angle_unit == 'deg') {
                    angleVal = deg2rad(angleVal);
                }
                
                peri = Math.round(rVal * (angleVal + 2) * 1000) / 1000 + ' ' + r_unit;
                return {
                    tech_peri: peri,
                };
            } else {
                return { error: 'Please! Check Your Input' };
            }
        }
        // Shape 7: Ellipse
        else if (shape == '7') {
            if (r && !isNaN(parseFloat(r)) && b && !isNaN(parseFloat(b))) {
                let rVal = parseFloat(r);
                let bVal = parseFloat(b);
                
                if (r_unit === b_unit) {
                    peri = Math.round(Math.PI * (3 * (rVal + bVal) - Math.sqrt(((3 * rVal) + bVal) * (rVal + (3 * bVal)))) * 1000) / 1000 + ' ' + r_unit;
                } else {
                    rVal = convertToCm(rVal, r_unit);
                    bVal = convertToCm(bVal, b_unit);
                    peri = Math.round(Math.PI * (3 * (rVal + bVal) - Math.sqrt(((3 * rVal) + bVal) * (rVal + (3 * bVal)))) * 1000) / 1000 + ' cm';
                }
                return {
                    tech_peri: peri,
                };
            } else {
                return { error: 'Please! Check Your Input' };
            }
        }
        // Shape 8: Quadrilateral (4 sides)
        else if (shape == '8') {
            if (r && !isNaN(parseFloat(r)) && b && !isNaN(parseFloat(b)) && 
                c && !isNaN(parseFloat(c)) && d && !isNaN(parseFloat(d))) {
                
                let rVal = convertToCm(parseFloat(r), r_unit);
                let bVal = convertToCm(parseFloat(b), b_unit);
                let cVal = convertToCm(parseFloat(c), c_unit);
                let dVal = convertToCm(parseFloat(d), d_unit);
                
                peri = Math.round((rVal + bVal + cVal + dVal) * 1000) / 1000 + ' cm';
                return {
                    tech_peri: peri,
                };
            } else {
                return { error: 'Please! Check Your Input' };
            }
        }
        // Shape 9: Parallelogram
        else if (shape == '9') {
            if (givena == '1') {
                // Two sides given
                if (r && !isNaN(parseFloat(r)) && b && !isNaN(parseFloat(b))) {
                    let rVal = parseFloat(r);
                    let bVal = parseFloat(b);
                    
                    if (r_unit == b_unit) {
                        peri = Math.round(2 * (rVal + bVal) * 1000) / 1000 + ' ' + r_unit;
                    } else {
                        rVal = convertToCm(rVal, r_unit);
                        bVal = convertToCm(bVal, b_unit);
                        peri = Math.round(2 * (rVal + bVal) * 1000) / 1000 + ' cm';
                    }
                    return {
                        tech_peri: peri,
                    };
                } else {
                    return { error: 'Please! Check Your Input' };
                }
            } else if (givena == '2') {
                // Side and diagonals
                if (r && !isNaN(parseFloat(r)) && b && !isNaN(parseFloat(b)) && c && !isNaN(parseFloat(c))) {
                    let rVal = parseFloat(r);
                    let bVal = parseFloat(b);
                    let cVal = parseFloat(c);
                    
                    if (r_unit == b_unit && r_unit == c_unit) {
                        peri = Math.round((2 * Math.pow(rVal, 2) + Math.sqrt((2 * Math.pow(bVal, 2)) + (2 * Math.pow(cVal, 2)) - (4 * Math.pow(rVal, 2)))) * 1000) / 1000 + ' ' + r_unit;
                    } else {
                        rVal = convertToCm(rVal, r_unit);
                        bVal = convertToCm(bVal, b_unit);
                        cVal = convertToCm(cVal, c_unit);
                        peri = Math.round((Math.pow(rVal, 2) + Math.sqrt((2 * Math.pow(bVal, 2)) + (2 * Math.pow(cVal, 2)) - (4 * Math.pow(rVal, 2)))) * 1000) / 1000 + ' cm';
                    }
                    return {
                        tech_peri: peri,
                    };
                } else {
                    return { error: 'Please! Check Your Input' };
                }
            } else if (givena == '3') {
                // Side, height and angle
                if (r && !isNaN(parseFloat(r)) && b && !isNaN(parseFloat(b)) && angle && !isNaN(parseFloat(angle))) {
                    let rVal = parseFloat(r);
                    let bVal = parseFloat(b);
                    let angleVal = parseFloat(angle);
                    
                    if (angle_unit == 'deg') {
                        angleVal = deg2rad(angleVal);
                    }
                    
                    if (r_unit == b_unit) {
                        peri = Math.round(2 * (rVal + (bVal / Math.sin(angleVal))) * 1000) / 1000 + ' ' + r_unit;
                    } else {
                        rVal = convertToCm(rVal, r_unit);
                        bVal = convertToCm(bVal, b_unit);
                        peri = Math.round(2 * (rVal + (bVal / Math.sin(angleVal))) * 1000) / 1000 + ' cm';
                    }
                    return {
                        tech_peri: peri,
                    };
                } else {
                    return { error: 'Please! Check Your Input' };
                }
            }
        }
        // Shape 10: Rhombus
        else if (shape == '10') {
            if (r && !isNaN(parseFloat(r))) {
                const rVal = parseFloat(r);
                peri = Math.round((rVal * 4) * 1000) / 1000 + ' ' + r_unit;
                return {
                    tech_peri: peri,
                };
            } else {
                return { error: 'Please! Check Your Input' };
            }
        }
        // Shape 11: Trapezoid
        else if (shape == '11') {
            if (r && !isNaN(parseFloat(r)) && b && !isNaN(parseFloat(b))) {
                let rVal = parseFloat(r);
                let bVal = parseFloat(b);
                
                if (r_unit == b_unit) {
                    peri = Math.round(2 * (rVal + bVal) * 1000) / 1000 + ' ' + r_unit;
                } else {
                    rVal = convertToCm(rVal, r_unit);
                    bVal = convertToCm(bVal, b_unit);
                    peri = Math.round(2 * (rVal + bVal) * 1000) / 1000 + ' cm';
                }
                return {
                    tech_peri: peri,
                };
            } else {
                return { error: 'Please! Check Your Input' };
            }
        }
        // Shape 12: Annulus (Ring)
        else if (shape == '12') {
            if (r && !isNaN(parseFloat(r)) && b && !isNaN(parseFloat(b))) {
                let rVal = parseFloat(r);
                let bVal = parseFloat(b);
                
                if (r_unit === b_unit) {
                    peri = Math.round(2 * Math.PI * (rVal + bVal) * 1000) / 1000 + ' ' + r_unit;
                } else {
                    rVal = convertToCm(rVal, r_unit);
                    bVal = convertToCm(bVal, b_unit);
                    peri = Math.round(2 * Math.PI * (rVal + bVal) * 1000) / 1000 + ' cm';
                }
                return {
                    tech_peri: peri,
                };
            } else {
                return { error: 'Please! Check Your Input' };
            }
        }
        // Shape 13: Regular Polygon
        else if (shape == '13') {
            if (r && !isNaN(parseFloat(r)) && nbr && !isNaN(parseFloat(nbr))) {
                const rVal = parseFloat(r);
                const nbrVal = parseFloat(nbr);
                peri = Math.round((rVal * nbrVal) * 1000) / 1000 + ' ' + r_unit;
                return {
                    tech_peri: peri,
                };
            } else {
                return { error: 'Please! Check Your Input' };
            }
        }
        
        return { error: 'Please! Check Your Input' };
    }

      /**
    * getCalculationAxisOfSymmetryCalculator: Service Method
    * POST: /api/calculators-lol/axis-of-symmetry-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async  getCalculationAxisOfSymmetryCalculator(body) {
      try {
        let eq = body.tech_eq;

        let param = {};

        // ✅ Input validation
        if (!eq || /[<>&]/.test(eq)) {
          param.error = "Please! Check Your Input.";
          return param;
        }

        // ✅ GCD function
        function new_gcd(a, b) {
          return b === 0 ? a : new_gcd(b, a % b);
        }

        // ✅ Divide or Factorize function
        function divideOrFactorize(numerator, denominator) {
          const commonDivisor = new_gcd(numerator, denominator);
          if (commonDivisor > 1) {
            numerator /= commonDivisor;
            denominator /= commonDivisor;
          }
          return { numerator, denominator };
        }

        // ✅ Expression cleaning
        let parem = eq
          .replace(/\s+/g, "")
          .replace(/%20/g, "")
          .replace(/\+/g, "plus")
          .replace(/{/g, "(")
          .replace(/}/g, ")")
          .replace(/e\^/g, "exp")
          .replace(/exp\^/g, "exp")
          .replace(/\^/g, "**")
          .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

        // ✅ External API request
        const response = await axios.post(
          "http://167.172.134.148/axis",
          new URLSearchParams({ equ: parem }),
          { timeout: 120000 }
        );

        let buffer = response.data.split("@@@");

        // ✅ Validation check
        if (buffer[5] === "False") {
          param.error =
            "The expression provided needs to be a valid univariate quadratic expression in x.";
          return param;
        }

        // ✅ Extracted values
        let input_eq = buffer[0];
        let coeff_a = parseFloat(buffer[1]);
        let coeff_b = parseFloat(buffer[2]);
        let coeff_c = parseFloat(buffer[3]);
        let expand_eq = buffer[4];

        // ✅ Calculate answer
        let ans = coeff_b / (2 * coeff_a);
        let asal_jawab;

        if (Number.isInteger(ans)) {
          asal_jawab = (coeff_b / (2 * coeff_a)) * -1;
        } else {
          let result = divideOrFactorize(coeff_b, 2 * coeff_a);
          if (result.denominator === 1 || result.denominator === 0) {
            asal_jawab = result.numerator * -1;
          } else {
            if (
              (result.numerator < 0 && result.denominator < 0) ||
              (result.numerator > 0 && result.denominator > 0)
            ) {
              asal_jawab = `- \\frac{${result.numerator}}{${result.denominator}}`;
            } else {
              asal_jawab = `\\frac{${result.numerator}}{${result.denominator}}`;
            }
          }
        }

        // ✅ Final response
        param.tech_input_eq = input_eq;
        param.tech_coeff_a = coeff_a;
        param.tech_coeff_b = coeff_b;
        param.tech_coeff_c = coeff_c;
        param.tech_expand_eq = expand_eq;
        param.tech_asal_jawab = asal_jawab;

        return param;
      } catch (error) {
        return { error: "Please! Check Your Input." };
      }
    }

      /**
    * getCalculationDistributivePropertyCalculator: Service Method
    * POST: /api/calculators-lol/distributive-property-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationDistributivePropertyCalculator(body) {
      try {
        let EnterEq = body.tech_EnterEq;

        let param = {};

        // ✅ Input validation
        if (!EnterEq || EnterEq.trim() === "") {
          param.error = "Please! Check Your Input.";
          return param;
        }

        // ✅ Original input cleanup (for display)
        let input = EnterEq.replace(/\s+/g, "")
          .replace(/\)\(/g, ")*(")
          .replace(/plus/g, "+");

        // ✅ Expression cleanup for backend request
        let parem = EnterEq
          .replace(/\s+/g, "")
          .replace(/\)\(/g, ")*(")
          .replace(/\+/g, "plus")
          .replace(/{/g, "(")
          .replace(/}/g, ")")
          .replace(/e\^/g, "exp")
          .replace(/exp\^/g, "exp")
          .replace(/\^/g, "**")
          .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

        // ✅ External API call
        const response = await axios.get(
          `http://167.172.134.148/distributive?equ=${encodeURIComponent(parem)}`,
          { timeout: 120000 }
        );

        let buffer = response.data?.toString().trim();

        // ✅ Response check
        if (!isNaN(buffer)) {
          param.tech_input = input;
          param.tech_ans = buffer;
          return param;
        } else {
          param.error = "Please! Check Your Input.";
          return param;
        }
      } catch (error) {
        return { error: "Please! Check Your Input." };
      }
    }

         /**
    * getCalculationRationalExpressionCalculator: Service Method
    * POST: /api/calculators-lol/rational-expression-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

  async getCalculationRationalExpressionCalculator(body) {
        
        // Helper function for string replacements
        function processExpression(expr) {
            let processed = expr;
            processed = processed.replace(/ /g, '');
            processed = processed.replace(/\+/g, 'plus');
            processed = processed.replace(/{/g, '(');
            processed = processed.replace(/}/g, ')');
            processed = processed.replace(/xe\^/g, 'x*e^');
            processed = processed.replace(/ye\^/g, 'y*e^');
            processed = processed.replace(/e\^/g, 'exp');
            processed = processed.replace(/exp\^/g, 'exp');
            processed = processed.replace(/\^/g, '**');
            processed = processed.replace(/e\^sqrt\(x\)/g, 'exp(2*x)');
            return processed;
        }

        // Input validation function
        function validateInput(input) {
            if (!input || !/^[^<>&]*$/i.test(input)) {
                return false;
            }
            if (/<|>|&|php|print_r|print|echo|script|=|%|&/i.test(input)) {
                return false;
            }
            return true;
        }

        const to = body.tech_to;
        const to_cal = body.tech_to_cal;

        if (to == '1') {
            const n1 = body.tech_n1;
            const d1 = body.tech_d1;

            // Validation
            if (!validateInput(n1) || !validateInput(d1)) {
                return {
                    status: "success",
                    payload: {
                        error: 'Please! Check Your Input.'
                    }
                };
            }

            const xeq = processExpression(n1);
            const yeq = processExpression(d1);
            const equ = "(" + xeq + ")/(" + yeq + ")";

            try {
                const response = await axios.get('http://167.172.134.148/rational', {
                    params: {
                        xeq: xeq,
                        to: "1",
                        yeq: yeq
                    },
                    timeout: 120000
                });

                const buffer = response.data.split("@@@");
                
                return {
                    status: "success",
                    payload: {
                        tech_enter: buffer[0],
                        tech_up: buffer[1],
                        tech_ress: buffer[2],
                        tech_down: buffer[3],
                    }
                };
            } catch (error) {
                return {
                    status: "success",
                    payload: {
                        error: 'Please! Check Your Input.'
                    }
                };
            }
        } else if (to == '2') {
            if (to_cal == 'two') {
                const n1 = body.tech_n11;
                const d1 = body.tech_d11;
                const n2 = body.tech_n22;
                const d2 = body.tech_d22;
                const action = body.tech_action;

                // Validation
                if (!validateInput(n1) || !validateInput(d1) || !validateInput(n2) || !validateInput(d2)) {
                    return {
                        status: "success",
                        payload: {
                            error: 'Please! Check Your Input.'
                        }
                    };
                }

                const xeq = processExpression(n1);
                const yeq = processExpression(d1);
                const xeq1 = processExpression(n2);
                const yeq1 = processExpression(d2);

                try {
                    const response = await axios.get('http://167.172.134.148/rational', {
                        params: {
                            xeq: xeq,
                            yeq: yeq,
                            xeq1: xeq1,
                            yeq1: yeq1,
                            to: "2",
                            cal: "2",
                            action: action
                        },
                        timeout: 120000
                    });

                    const buffer = response.data.split("@@@");
                    let lcm = null;
                    
                    if (buffer[2]) {
                        const lcmParts = buffer[2].split('}{');
                        if (lcmParts.length === 2) {
                            lcm = lcmParts[1].slice(0, -1);
                        }
                    }

                    const processedAction = action.replace(/plus/g, '+').replace(/div/g, '÷');
                    const result = {
                            tech_up: buffer[0],
                            tech_down: buffer[1],
                            tech_ans: buffer[2],
                            tech_action: processedAction,
                    };

                    if (lcm) {
                        result.tech_lcm = lcm;
                    }

                    if (processedAction == '+' || processedAction == '-') {
                        result.tech_left = buffer[3];
                        result.tech_right = buffer[4];
                        result.tech_top = buffer[5];
                        result.tech_bottom = buffer[6];
                    } else {
                        result.tech_top = buffer[3];
                        result.tech_bottom = buffer[4];
                    }

                    return result;
                } catch (error) {
                    return {
                        status: "success",
                        payload: {
                            error: 'Please! Check Your Input.'
                        }
                    };
                }
            } else {
                const n1 = body.tech_n13;
                const d1 = body.tech_d13;
                const n2 = body.tech_n23;
                const d2 = body.tech_d23;
                const n3 = body.tech_n33;
                const d3 = body.tech_d33;
                const action1 = body.tech_action1;
                const action2 = body.tech_action2;

                // Validation
                if (!validateInput(n1) || !validateInput(d1) || !validateInput(n2) || 
                    !validateInput(d2) || !validateInput(n3) || !validateInput(d3)) {
                    return {
                        status: "success",
                        payload: {
                            error: 'Please! Check Your Input.'
                        }
                    };
                }

                const xeq = processExpression(n1);
                const yeq = processExpression(d1);
                const xeq1 = processExpression(n2);
                const yeq1 = processExpression(d2);
                const xeq2 = processExpression(n3);
                const yeq2 = processExpression(d3);

                try {
                    const response = await axios.get('http://167.172.134.148/rational', {
                        params: {
                            xeq: xeq,
                            yeq: yeq,
                            xeq1: xeq1,
                            yeq1: yeq1,
                            xeq2: xeq2,
                            yeq2: yeq2,
                            to: "2",
                            cal: "3",
                            action: action1,
                            action1: action2
                        },
                        timeout: 120000
                    });

                    const buffer = response.data.split("@@@");
                    let lcm = null;
                    let lcm1 = null;
                    
                    if (buffer[1]) {
                        const lcmParts = buffer[1].split('}{');
                        if (lcmParts.length > 1) {
                            lcm = lcmParts[1].slice(0, -1);
                        }
                    }

                    const processedAction = action1.replace(/plus/g, '+').replace(/div/g, '÷');
                    const processedAction1 = action2.replace(/plus/g, '+').replace(/div/g, '÷');

                    const result = {
                        status: "success",
                        payload: {
                            ans: buffer[1],
                            up: buffer[2],
                            down: buffer[3],
                            thr: buffer[4],
                            action: processedAction,
                            action1: processedAction1,
                            RESULT: 1
                        }
                    };

                    if (lcm) {
                        result.payload.lcm = lcm;
                    }

                    if ((processedAction == '+' || processedAction == '-') && 
                        (processedAction1 == '+' || processedAction1 == '-')) {
                        result.payload.left = buffer[5];
                        result.payload.center = buffer[6];
                        result.payload.right = buffer[7];
                        result.payload.top = buffer[8];
                    } else if ((processedAction == '*' || processedAction == '÷') && 
                              (processedAction1 == '*' || processedAction1 == '÷')) {
                        result.payload.up1 = buffer[5];
                        result.payload.up2 = buffer[6];
                        result.payload.down1 = buffer[7];
                        result.payload.down2 = buffer[8];
                    } else {
                        result.payload.up1 = buffer[5];
                        result.payload.ansl = buffer[6];
                        result.payload.down1 = buffer[7];
                        result.payload.top = buffer[8];
                        result.payload.left = buffer[9];
                        result.payload.right = buffer[10];
                        
                        if (buffer[6]) {
                            const lcm1Parts = buffer[6].split('}{');
                            if (lcm1Parts.length > 1) {
                                lcm1 = lcm1Parts[1].slice(0, -1);
                                result.payload.lcm1 = lcm1;
                            }
                        }
                    }

                    return result;
                } catch (error) {
                    return {
                        status: "success",
                        payload: {
                            error: 'Please! Check Your Input.'
                        }
                    };
                }
            }
        } else if (to == '3') {
            const expr = body.tech_expr;

            if (!validateInput(expr)) {
                return {
                    status: "success",
                    payload: {
                        error: 'Please Enter Valid Input.'
                    }
                };
            }

            const xeq = processExpression(expr);

            try {
                const response = await axios.get('http://167.172.134.148/rational', {
                    params: {
                        xeq: xeq,
                        to: "3"
                    },
                    timeout: 120000
                });

                const buffer = response.data.split("@@@");
                
                return {
                    status: "success",
                    payload: {
                        tech_enter: buffer[0],
                        tech_ans: buffer[1],
                    }
                };
            } catch (error) {
                return {
                    status: "success",
                    payload: {
                        error: 'Please! Check Your Input.'
                    }
                };
            }
        }

        // Default return if no valid 'to' value
        return {
            status: "success",
            payload: {
                error: 'Invalid operation type.'
            }
        };
    }


      /**
    * getCalculationAreaOfASectorCalculator: Service Method
    * POST: /api/calculators-lol/area-of-a-sector-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationAreaOfASectorCalculator(body) {
        // Helper function to convert degrees to radians
        function deg2rad(deg) {
            return deg * (Math.PI / 180);
        }

        // Helper function for unit conversion
        function convertToCm(value, unit) {
            switch(unit) {
                case 'in':
                    return value * 2.54;
                case 'm':
                    return value * 100;
                case 'ft':
                    return value * 30.48;
                case 'yd':
                    return value * 91.44;
                default:
                    return value;
            }
        }

        function convertAreaToCm2(value, unit) {
            switch(unit) {
                case 'in':
                    return value * 6.45;
                case 'm':
                    return value * 10000;
                case 'ft':
                    return value * 929;
                case 'yd':
                    return value * 8361;
                default:
                    return value;
            }
        }
            let angle = body.tech_angle;
            let angle_unit = body.tech_angle_unit;
            let rad = body.tech_rad;
            let rad_unit = body.tech_rad_unit;
            let diameter = body.tech_diameter;
            let diameter_unit = body.tech_diameter_unit;
            let area = body.tech_area;
            let area_unit = body.tech_area_unit;
            let arc = body.tech_arc;
            let arc_unit = body.tech_arc_unit;
            let c = body.tech_c;
            let c_unit = body.tech_c_unit;

        // Convert string values to numbers where applicable
        const numAngle = angle ? parseFloat(angle) : null;
        const numRad = rad ? parseFloat(rad) : null;
        const numDiameter = diameter ? parseFloat(diameter) : null;
        const numArea = area ? parseFloat(area) : null;
        const numArc = arc ? parseFloat(arc) : null;
        const numC = c ? parseFloat(c) : null;

        // Case 1: angle and radius provided
        if (numAngle != null && numRad != null && 
            numDiameter == null && numArea == null && 
            numArc == null && numC == null) {
            
            let processedAngle = numAngle;
            if (angle_unit == 'deg') {
                processedAngle = deg2rad(processedAngle);
            }

            const calculatedArea = (processedAngle * Math.pow(numRad, 2)) / 2;
            const calculatedDia = numRad * 2;
            const calculatedArc = processedAngle * numRad;
            const calculatedC = 2 * numRad * Math.sin(processedAngle / 2);

            return {
                status: "success",
                payload: {
                 mode: 1,
                tech_area: isNaN(calculatedArea) ? "NaN" : calculatedArea,
                tech_unit: rad_unit,
                tech_dia: isNaN(calculatedDia) ? "NaN" : calculatedDia,
                tech_arc: isNaN(calculatedArc) ? "NaN" : calculatedArc,
                tech_c: isNaN(calculatedC) ? "NaN" : calculatedC,

                }
            };
        }
        // Case 2: angle and diameter provided
        else if (numAngle != null && numRad == null && 
                numDiameter != null && numArea == null && 
                numArc == null && numC == null) {
            
            let processedAngle = numAngle;
            if (angle_unit == 'deg') {
                processedAngle = deg2rad(processedAngle);
            }

            const calculatedRad = numDiameter / 2;
            const calculatedArea = (processedAngle * Math.pow(calculatedRad, 2)) / 2;
            const calculatedArc = processedAngle * calculatedRad;
            const calculatedC = 2 * calculatedRad * Math.sin(processedAngle / 2);

            return {
                status: "success",
                payload: {
                  tech_mode: 2,
                  tech_area: isNaN(calculatedArea) ? "NaN" : calculatedArea,
                  tech_unit: diameter_unit,
                  tech_rad: isNaN(calculatedRad) ? "NaN" : calculatedRad,
                  tech_arc: isNaN(calculatedArc) ? "NaN" : calculatedArc,
                  tech_c: isNaN(calculatedC) ? "NaN" : calculatedC,

                }
            };
        }
        // Case 3: radius and area provided
        else if (numAngle == null && numRad != null && 
                numDiameter == null && numArea != null && 
                numArc == null && numC == null) {
            
            const checkUnit = area_unit.replace('²', '');
            let unit = rad_unit;
            let processedRad = numRad;
            let processedArea = numArea;

            if (checkUnit != rad_unit) {
                unit = 'cm';
                processedRad = convertToCm(numRad, rad_unit);
                processedArea = convertAreaToCm2(numArea, checkUnit);
            }

            const calculatedAngle = (processedArea * 2) / Math.pow(processedRad, 2);
            const calculatedArc = calculatedAngle * processedRad;
            const calculatedC = 2 * processedRad * Math.sin(calculatedAngle / 2);
            const calculatedDia = processedRad * 2;

            return {
                status: "success",
                payload: {
                 tech_mode: 3,
                  tech_angle: isNaN(calculatedAngle) ? "NaN" : calculatedAngle,
                  tech_unit: unit,
                  tech_dia: isNaN(calculatedDia) ? "NaN" : calculatedDia,
                  tech_arc: isNaN(calculatedArc) ? "NaN" : calculatedArc,
                  tech_c: isNaN(calculatedC) ? "NaN" : calculatedC,

                }
            };
        }
        // Case 4: angle and area provided
        else if (numAngle != null && numRad == null && 
                numDiameter == null && numArea != null && 
                numArc == null && numC == null) {
            
            const unit = area_unit.replace('²', '');
            let processedAngle = numAngle;
            if (angle_unit == 'deg') {
                processedAngle = deg2rad(processedAngle);
            }

            const calculatedRad = Math.sqrt((2 * numArea) / processedAngle);
            const calculatedArc = processedAngle * calculatedRad;
            const calculatedC = 2 * calculatedRad * Math.sin(processedAngle / 2);
            const calculatedDia = calculatedRad * 2;

            return {
                status: "success",
                payload: {
                 tech_mode: 4,
                  tech_rad: isNaN(calculatedRad) ? "NaN" : calculatedRad,
                  tech_unit: unit,
                  tech_dia: isNaN(calculatedDia) ? "NaN" : calculatedDia,
                  tech_arc: isNaN(calculatedArc) ? "NaN" : calculatedArc,
                  tech_c: isNaN(calculatedC) ? "NaN" : calculatedC,

                }
            };
        }
        // Case 5: angle and arc provided
        else if (numAngle != null && numRad == null && 
                numDiameter == null && numArea == null && 
                numArc != null && numC == null) {
            
            let processedAngle = numAngle;
            if (angle_unit == 'deg') {
                processedAngle = deg2rad(processedAngle);
            }

            const calculatedRad = numArc / processedAngle;
            const calculatedDia = calculatedRad * 2;
            const calculatedArea = (processedAngle * Math.pow(calculatedRad, 2)) / 2;
            const calculatedC = 2 * calculatedRad * Math.sin(processedAngle / 2);

            return {
                status: "success",
                payload: {
                 tech_mode: 5,
                tech_rad: isNaN(calculatedRad) ? "NaN" : calculatedRad,
                utech_nit: arc_unit,
                tech_dia: isNaN(calculatedDia) ? "NaN" : calculatedDia,
                tech_area: isNaN(calculatedArea) ? "NaN" : calculatedArea,
                tech_c: isNaN(calculatedC) ? "NaN" : calculatedC,

                }
            };
        }
        // Case 6: angle and chord length provided
        else if (numAngle != null && numRad == null && 
                numDiameter == null && numArea == null && 
                numArc == null && numC !== null) {
            
            let processedAngle = numAngle;
            if (angle_unit == 'deg') {
                processedAngle = deg2rad(processedAngle);
            }

            const calculatedRad = numC / (2 * Math.sin(processedAngle / 2));
            const calculatedDia = calculatedRad * 2;
            const calculatedArea = (processedAngle * Math.pow(calculatedRad, 2)) / 2;
            const calculatedArc = processedAngle * calculatedRad;

            return {
                status: "success",
                payload: {
                  tech_mode: 6,
                  tech_rad: isNaN(calculatedRad) ? "NaN" : calculatedRad,
                  tech_unit: c_unit,
                  tech_dia: isNaN(calculatedDia) ? "NaN" : calculatedDia,
                  tech_area: isNaN(calculatedArea) ? "NaN" : calculatedArea,
                  tech_arc: isNaN(calculatedArc) ? "NaN" : calculatedArc,

                }
            };
        }
        // Case 7: radius and arc provided
        else if (numAngle == null && numRad != null && 
                numDiameter == null && numArea == null && 
                numArc != null && numC == null) {
            
            let unit = rad_unit;
            let processedRad = numRad;
            let processedArc = numArc;

            if (arc_unit != rad_unit) {
                unit = 'cm';
                processedRad = convertToCm(numRad, rad_unit);
                processedArc = convertToCm(numArc, arc_unit);
            }

            const calculatedAngle = processedArc / processedRad;
            const calculatedArea = (calculatedAngle * Math.pow(processedRad, 2)) / 2;
            const calculatedC = 2 * processedRad * Math.sin(calculatedAngle / 2);
            const calculatedDia = processedRad * 2;

            return {
                status: "success",
                payload: {
                   tech_mode: 7,
                tech_angle: isNaN(calculatedAngle) ? "NaN" : calculatedAngle,
                tech_unit: unit,
                tech_dia: isNaN(calculatedDia) ? "NaN" : calculatedDia,
                tech_area: isNaN(calculatedArea) ? "NaN" : calculatedArea,
                tech_c: isNaN(calculatedC) ? "NaN" : calculatedC,

                }
            };
        }
        // Case 8: radius and chord length provided
        else if (numAngle == null && numRad != null && 
                numDiameter == null && numArea == null && 
                numArc == null && numC != null) {
            
            let unit = rad_unit;
            let processedRad = numRad;
            let processedC = numC;

            if (c_unit != rad_unit) {
                unit = 'cm';
                processedRad = convertToCm(numRad, rad_unit);
                processedC = convertToCm(numC, c_unit);
            }

            const calculatedDia = processedRad * 2;
            const calculatedAngle = 2 * Math.asin(processedC / (2 * processedRad));
            const calculatedArea = (calculatedAngle * Math.pow(processedRad, 2)) / 2;
            const calculatedArc = calculatedAngle * processedRad;
            console.log(calculatedAngle);
            return {
                status: "success",
                payload: {
                    tech_mode: 8,
                    tech_angle: isNaN(calculatedAngle) ? "NaN" : calculatedAngle,
                    tech_unit: unit,
                    tech_dia: isNaN(calculatedDia) ? "NaN" : calculatedDia,
                    tech_area: isNaN(calculatedArea) ? "NaN" : calculatedArea,
                    tech_arc: isNaN(calculatedArc) ? "NaN" : calculatedArc,
                }
            };
        }
        // Case 9: diameter and area provided
        else if (numAngle == null && numRad == null && 
                numDiameter != null && numArea != null && 
                numArc == null && numC == null) {
            
            const checkUnit = area_unit.replace('²', '');
            let unit = diameter_unit;
            let processedDiameter = numDiameter;
            let processedArea = numArea;

            if (checkUnit != diameter_unit) {
                unit = 'cm';
                processedDiameter = convertToCm(numDiameter, diameter_unit);
                processedArea = convertAreaToCm2(numArea, checkUnit);
            }

            const calculatedRad = processedDiameter / 2;
            const calculatedAngle = (processedArea * 2) / Math.pow(calculatedRad, 2);
            const calculatedArc = calculatedAngle * calculatedRad;
            const calculatedC = 2 * calculatedRad * Math.sin(calculatedAngle / 2);

            return {
                status: "success",
                payload: {
                    tech_mode: 9,
                tech_angle: isNaN(calculatedAngle) ? "NaN" : calculatedAngle,
                  tech_unit: unit,
                  tech_rad: isNaN(calculatedRad) ? "NaN" : calculatedRad,
                  tech_arc: isNaN(calculatedArc) ? "NaN" : calculatedArc,
                  tech_x: isNaN(calculatedC) ? "NaN" : calculatedC,
                }
            };
        }
        // Case 10: diameter and arc provided
        else if (numAngle == null && numRad == null && 
                numDiameter != null && numArea == null && 
                numArc != null && numC == null) {
            
            let unit = diameter_unit;
            let processedDiameter = numDiameter;
            let processedArc = numArc;

            if (diameter_unit != arc_unit) {
                unit = 'cm';
                processedDiameter = convertToCm(numDiameter, diameter_unit);
                processedArc = convertToCm(numArc, arc_unit);
            }

            const calculatedRad = processedDiameter / 2;
            const calculatedAngle = processedArc / calculatedRad;
            const calculatedArea = (calculatedAngle * Math.pow(calculatedRad, 2)) / 2;
            const calculatedC = 2 * calculatedRad * Math.sin(calculatedAngle / 2);

            return {
                status: "success",
                payload: {
                    tech_mode: 10,
                  tech_angle: isNaN(calculatedAngle) ? "NaN" : calculatedAngle,
                  tech_unit: unit,
                  tech_rad: isNaN(calculatedRad) ? "NaN" : calculatedRad,
                  tech_area: isNaN(calculatedArea) ? "NaN" : calculatedArea,
                  tech_c: isNaN(calculatedC) ? "NaN" : calculatedC,

                }
            };
        }
        // Case 11: diameter and chord length provided
        else if (numAngle == null && numRad == null && 
                numDiameter != null && numArea == null && 
                numArc == null && numC != null) {
            
            let unit = diameter_unit;
            let processedDiameter = numDiameter;
            let processedC = numC;

            if (c_unit != diameter_unit) {
                unit = 'cm';
                processedDiameter = convertToCm(numDiameter, diameter_unit);
                processedC = convertToCm(numC, c_unit);
            }

            const calculatedRad = processedDiameter / 2;
            const calculatedAngle = 2 * Math.asin(processedC / (2 * calculatedRad));
            const calculatedArea = (calculatedAngle * Math.pow(calculatedRad, 2)) / 2;
            const calculatedArc = calculatedAngle * calculatedRad;

            return {
                status: "success",
                payload: {
                    tech_mode: 11,
                   tech_angle: isNaN(calculatedAngle) ? "NaN" : calculatedAngle,
                  tech_unit: unit,
                  tech_rad: isNaN(calculatedRad) ? "NaN" : calculatedRad,
                  tech_area: isNaN(calculatedArea) ? "NaN" : calculatedArea,
                  tech_arc: isNaN(calculatedArc) ? "NaN" : calculatedArc,

                }
            };
        }
        // Case 12: area and arc provided
        else if (numAngle == null && numRad == null && 
                numDiameter == null && numArea != null && 
                numArc != null && numC == null) {
            
            const checkUnit = area_unit.replace('²', '');
            let unit = arc_unit;
            let processedArea = numArea;
            let processedArc = numArc;

            if (checkUnit != arc_unit) {
                unit = 'cm';
                processedArc = convertToCm(numArc, arc_unit);
                processedArea = convertAreaToCm2(numArea, checkUnit);
            }

            const calculatedAngle = Math.pow(processedArc, 2) / (processedArea * 2);
            const calculatedRad = processedArc / calculatedAngle;
            const calculatedDia = calculatedRad * 2;
            const calculatedC = 2 * calculatedRad * Math.sin(calculatedAngle / 2);

            return {
                status: "success",
                payload: {
                 tech_mode: 12,
                tech_angle: isNaN(calculatedAngle) ? "NaN" : calculatedAngle,
                tech_unit: unit,
                tech_rad: isNaN(calculatedRad) ? "NaN" : calculatedRad,
                tech_dia: isNaN(calculatedDia) ? "NaN" : calculatedDia,
                tech_c: isNaN(calculatedC) ? "NaN" : calculatedC,

                }
            };
        }
        // Case 13: area and chord length provided (not supported)
        else if (numAngle == null && numRad == null && 
                numDiameter == null && numArea != null && 
                numArc == null && numC != null) {
            
            return {
                status: "success",
                payload: {
                    error: 'Please Try with other values.'
                }
            };
        }
        // Case 14: arc and chord length provided (not supported)
        else if (numAngle == null && numRad == null && 
                numDiameter == null && numArea == null && 
                numArc !== null && numC != null) {
            
            return {
                status: "success",
                payload: {
                    error: 'Please Try with other values.'
                }
            };
        }
        // Default case: invalid input
        else {
            return {
                status: "success",
                payload: {
                    error: 'Please! Check Your Input.'
                }
            };
        }
    }

     /**
    * getCalculationParallelogramCalculator: Service Method
    * POST: /api/calculators-lol/parallelogram-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

   async getCalculationParallelogramCalculator(body) {
      const unit = body.tech_unit;
      const rad = body.tech_rad1;
      const side1 = body.tech_side1;
      const side2 = body.tech_side2;
      const pi = body.tech_pi;
      const method = body.tech_slct1;

      const param = {};

      if (method == "1") {
          if (rad > 0 && rad < 90) {
           const c1 = 180;
            const c2 = c1 - rad;
            param.tech_rad = isNaN(rad) ? "NaN" : rad;
            param.tech_c2 = isNaN(c2) ? "NaN" : c2;
              return param;
          } else {
              param.error = "For a Parallelogram 0 < A < 90°";
              return param;
          }
      } else if (method == "2") {
          if (rad >= 91 && rad <= 179) {
             const c1 = 180;
            const c2 = c1 - rad;
            param.tech_rad = isNaN(rad) ? "NaN" : rad;
            param.tech_c1 = isNaN(c1) ? "NaN" : c1;

              return param;
          } else {
              param.error = "For a Parallelogram 90° < B < 180°";
              return param;
          }
      } else if (method == "3") {
          if (rad <= 89 && rad >= 1) {
           const c1 = 180;
            const c2 = c1 - rad;
            const hValue = side1 * Math.sin((rad * Math.PI) / 180);
            const h = (isNaN(hValue) ? "NaN" : hValue) + " " + unit;
            param.tech_h = h;
            param.tech_c2 = isNaN(c2) ? "NaN" : c2;

              return param;
          } else {
              param.error = "For a Parallelogram 0 < A < 90°";
              return param;
          }
      } else if (method == "4") {
          if (rad <= 89 && rad >= 1) {
            const aValue = side1 / Math.sin((rad * Math.PI) / 180);
            const bValue = 180 - rad;
            param.tech_a = isNaN(aValue) ? "NaN" : aValue;
            param.tech_b = isNaN(bValue) ? "NaN" : bValue;
            return param;

          } else {
              param.error = "For a Parallelogram 0 < A < 90°";
              return param;
          }
      } else if (method == "5") {
          if (rad > 0 && side1 > 0) {
              if (side1 <= rad * 2) {
                  param.error = "Perimeter (P) must be at least 2 times side length (a).";
                  return param;
              } else {
                 const bValue = (side1 - 2 * rad) / 2;
                param.tech_b = isNaN(bValue) ? "NaN" : bValue;
                return param;

              }
          } else {
              param.error = "Please Enter Positive Numbers.";
              return param;
          }
      } else if (method == "6") {
          if (side1 <= rad * 2) {
              param.error = "Perimeter (P) must be at least 2 times side length (a).";
              return param;
          } else {
         const aValue = (side1 - 2 * rad) / 2;
          param.tech_a = isNaN(aValue) ? "NaN" : aValue;
          return param;

          }
      } else if (method == "7") {
          if (rad > 0 && side1 > 0) {
             const pValue = 2 * rad + 2 * side1;
            param.tech_p = isNaN(pValue) ? "NaN" : pValue;
            return param;

          } else {
              param.error = "Please Enter Positive Numbers.";
              return param;
          }
      } else if (method == "8") {
          if (rad > 0 && side1 > 0) {
           const hValue = side1 / rad;
          param.tech_h = isNaN(hValue) ? "NaN" : hValue;
          return param;

          } else {
              param.error = "Please Enter Positive Numbers.";
              return param;
          }
      } else if (method == "9") {
          if (rad > 0 && side1 > 0) {
            const bValue = side1 / rad;
            param.tech_b = isNaN(bValue) ? "NaN" : bValue;
            return param;

          } else {
              param.error = "Please Enter Positive Numbers.";
              return param;
          }
      } else if (method == "10") {
          if (rad > 0 && side1 > 0) {
            const kValue = rad * side1;
            param.tech_k = isNaN(kValue) ? "NaN" : kValue;
            return param;

          } else {
              param.error = "Please Enter Positive Numbers.";
              return param;
          }
      } else if (method == "11") {
          if (side1 > 0 && side2 > 0) {
              if (rad <= 89 && rad >= 1) {
                  const val = 180;
                  const calculate = val - rad;
                  const h = side1 * Math.sin((rad * Math.PI) / 180);
                  const k = side2 * h;
                  const p = Math.sqrt(
                      side1 * side1 + side2 * side2 - 
                      2 * side1 * side2 * Math.cos((rad * Math.PI) / 180)
                  );
                  const q = Math.sqrt(
                      side1 * side1 + side2 * side2 + 
                      2 * side1 * side2 * Math.cos((rad * Math.PI) / 180)
                  );
                  const P = 2 * side1 + 2 * side2;
                param.tech_calculate = isNaN(calculate) ? "NaN" : calculate;
                param.tech_h = isNaN(h) ? "NaN" : h;
                param.tech_k = isNaN(k) ? "NaN" : k;
                param.tech_p = isNaN(p) ? "NaN" : p;
                param.tech_q = isNaN(q) ? "NaN" : q;
                param.tech_P = isNaN(P) ? "NaN" : P;
                  return param;
              } else {
                  param.error = "For a Parallelogram 0 < A < 90°";
                  return param;
              }
          } else {
              param.error = "Please Enter Positive Numbers.";
              return param;
          }
      } else if (method == "12") {
          if (rad > 0 && side1 > 0 && side2 > 0) {
              const a = (Math.acos(
                  (side2 * side2 - rad * rad - side1 * side1) / 
                  (-2 * rad * side1)
              ) * 180) / Math.PI;
              const val = 180;
              const calculate = 180 - a;
              const h = rad * Math.sin((a * Math.PI) / 180);
              const q = Math.sqrt(
                  rad * rad + side1 * side1 + 
                  2 * rad * side1 * Math.cos((a * Math.PI) / 180)
              );
              const P = 2 * rad + 2 * side1;
              const pl = Math.sqrt(
                  rad * rad + side1 * side1 - 
                  2 * rad * side1 * Math.cos((a * Math.PI) / 180)
              );
              const pythagoras = Math.sqrt(rad * rad + side1 * side1);
              
              if (side2 <= pythagoras) {
                param.tech_h = isNaN(h) ? "NaN" : h;
                param.tech_calculate = isNaN(calculate) ? "NaN" : calculate;
                param.tech_q = isNaN(q) ? "NaN" : q;
                param.tech_P = isNaN(P) ? "NaN" : P;
                param.tech_pl = isNaN(pl) ? "NaN" : pl;
                param.tech_pythagoras = isNaN(pythagoras) ? "NaN" : pythagoras;
                return param;
              } else {
                  param.error = `The shorter diagonal (p) must be less than ${pythagoras} according to the Pythagorean theorem with (a and b) as the two sides and (p) as the hypotenuse. Try entering a, b and q instead.`;
                  return param;
              }
          } else {
              param.error = "Please Enter Positive Numbers.";
              return param;
          }
      } else if (method == "13") {
          if (rad > 0 && side1 > 0 && side2 > 0) {
              const pythagoras = Math.sqrt(rad * rad + side1 * side1);
              
              if (side2 >= pythagoras) {
                  const a = (Math.acos(
                      (side2 * side2 - rad * rad - side1 * side1) / 
                      (2 * rad * side1)
                  ) * 180) / Math.PI;
                  const b = 180 - a;
                  const P = 2 * rad + 2 * side1;
                  const p = Math.sqrt(
                      rad * rad + side1 * side1 - 
                      2 * rad * side1 * Math.cos((a * Math.PI) / 180)
                  );
                const h = rad * Math.sin((a * Math.PI) / 180);
                param.tech_a = isNaN(a) ? "NaN" : a;
                param.tech_b = isNaN(b) ? "NaN" : b;
                param.tech_P = isNaN(P) ? "NaN" : P;
                param.tech_p = isNaN(p) ? "NaN" : p;
                param.tech_h = isNaN(h) ? "NaN" : h;

                return param;

              } else {
                  param.error = `The longer diagonal (q) must be greater than ${pythagoras} according to the Pythagorean theorem with (a and b) as the two sides and (q) as the hypotenuse. Try entering a, b and p instead.`;
                  return param;
              }
          } else {
              param.error = "Please Enter Positive Numbers.";
              return param;
          }
      } else if (method == "14") {
          if (rad > 0 && side1 > 0 && side2 > 0) {
              if (side2 <= rad) {
                  const a = (Math.asin(side2 / rad) * 180) / Math.PI;
                  const b = 180 - a;
                  const p = Math.sqrt(
                      rad * rad + side1 * side1 - 
                      2 * rad * side1 * Math.cos((a * Math.PI) / 180)
                  );
                  const q = Math.sqrt(
                      rad * rad + side1 * side1 + 
                      2 * rad * side1 * Math.cos((a * Math.PI) / 180)
                  );
                  const P = 2 * rad + 2 * side1;
                  const k = side1 * side2;
                  param.tech_a = isNaN(a) ? "NaN" : a;
                  param.tech_b = isNaN(b) ? "NaN" : b;
                  param.tech_P = isNaN(P) ? "NaN" : P;
                  param.tech_p = isNaN(p) ? "NaN" : p;
                  param.tech_q = isNaN(q) ? "NaN" : q;
                  param.tech_k = isNaN(k) ? "NaN" : k;

                return param;

              } else {
                  param.error = "Height (h) must be less than or equal to the side length (a) to form a parallelogram.";
                  return param;
              }
          } else {
              param.error = "Please Enter Positive Numbers.";
              return param;
          }
      } else if (method == "15") {
          if (rad > 0 && side1 > 0 && side2 > 0) {
              if (side2 > rad * side1) {
                  param.error = "The area K of a rhombus must be less than or equal to side length (a) times side length (b) which is the area of a rectangle with sides a and b. (K ≤ a x b)";
                  return param;
              } else if (side2 <= rad * side1) {
                  const a = (Math.asin(side2 / (rad * side1)) * 180) / Math.PI;
                  const b = 180 - a;
                  const p = Math.sqrt(
                      rad * rad + side1 * side1 - 
                      2 * rad * side1 * Math.cos((a * Math.PI) / 180)
                  );
                  const q = Math.sqrt(
                      rad * rad + side1 * side1 + 
                      2 * rad * side1 * Math.cos((a * Math.PI) / 180)
                  );
                  const k = rad * side1;
                  const h = rad * Math.sin((a * Math.PI) / 180);
                  const P = 2 * rad + 2 * side1;
                  param.tech_a = isNaN(a) ? "NaN" : a;
                  param.tech_b = isNaN(b) ? "NaN" : b;
                  param.tech_p = isNaN(p) ? "NaN" : p;
                  param.tech_q = isNaN(q) ? "NaN" : q;
                  param.tech_k = isNaN(k) ? "NaN" : k;
                  param.tech_h = isNaN(h) ? "NaN" : h;
                  param.tech_P = isNaN(P) ? "NaN" : P;

                return param;

              }
          } else {
              param.error = "Please Enter Positive Numbers.";
              return param;
          }
      } else if (method == "16") {
          if (side1 > 0 && side2 > 0) {
              if (rad <= 89 && rad >= 1) {
                  const b = side2 / (side1 * Math.sin((rad * Math.PI) / 180));
                  const b_angle = 180 - rad;
                  const h = side1 * Math.sin((rad * Math.PI) / 180);
                  const P = 2 * side1 + 2 * b;
                  const p = Math.sqrt(
                      side1 * side1 + b * b - 
                      2 * side1 * b * Math.cos((rad * Math.PI) / 180)
                  );
                  const q = Math.sqrt(
                      side1 * side1 + b * b + 
                      2 * side1 * b * Math.cos((rad * Math.PI) / 180)
                  );
                 param.tech_b = isNaN(b) ? "NaN" : b;
                  param.tech_b_angle = isNaN(b_angle) ? "NaN" : b_angle;
                  param.tech_h = isNaN(h) ? "NaN" : h;
                  param.tech_P = isNaN(P) ? "NaN" : P;
                  param.tech_p = isNaN(p) ? "NaN" : p;
                  param.tech_q = isNaN(q) ? "NaN" : q;

                  return param;

              } else {
                  param.error = "For a Parallelogram 0 < A < 90°";
                  return param;
              }
          } else {
              param.error = "Please Enter Positive Numbers.";
              return param;
          }
      } else if (method == "17") {
          if (side1 > 0 && side2 > 0) {
              if (rad <= 89 && rad >= 1) {
                  const a = side2 / (side1 * Math.sin((rad * Math.PI) / 180));
                  const b_angle = 180 - rad;
                  const P = 2 * a + 2 * side1;
                  const h = a * Math.sin((rad * Math.PI) / 180);
                  const p = Math.sqrt(
                      a * a + side1 * side1 - 
                      2 * a * side1 * Math.cos((rad * Math.PI) / 180)
                  );
                  const q = Math.sqrt(
                      a * a + side1 * side1 + 
                      2 * a * side1 * Math.cos((rad * Math.PI) / 180)
                  );
                 param.tech_a = isNaN(a) ? "NaN" : a;
                  param.tech_b_angle = isNaN(b_angle) ? "NaN" : b_angle;
                  param.tech_P = isNaN(P) ? "NaN" : P;
                  param.tech_h = isNaN(h) ? "NaN" : h;
                  param.tech_p = isNaN(p) ? "NaN" : p;
                  param.tech_q = isNaN(q) ? "NaN" : q;
                  return param;

              } else {
                  param.error = "Please Enter Positive Numbers.";
                  return param;
              }
          } else {
              param.error = "Please Enter Positive Numbers.";
              return param;
          }
      } else if (method == "18") {
          if (rad > 0 && side1 > 0 && side2 > 0) {
              let c1, c2, log, sam;
              
              if (side1 > side2) {
                  c1 = ((side1 - side2) / 2) + side1;
                  c2 = (side2 - side2) / 2;
                  log = 'p';
                  sam = 'q';
              } else {
                  c1 = ((side2 - side1) / 2) + side1;
                  c2 = (side2 - side1) / 2;
                  log = 'q';
                  sam = 'p';
              }
              
              if (rad < c2) {
                  param.error = `Side length (b) must be longer than the difference between the longer diagonal (${log}) and the shorter diagonal (${sam}) divided by 2 plus (p). Side length (b) must be less than ${c2} or a diagonal must be longer. [b > absolute value of (q-p)/2].`;
                  return param;
              } else if (rad > c1) {
                  param.error = `Side length (b) must be shorter than the difference between the longer diagonal (${log}) and the shorter diagonal (${sam}) divided by 2 plus (p). Side length (b) must be less than ${c1} or b diagonal must be longer. [b > absolute value of (q-p)/2].`;
                  return param;
              } else {
                  const b = (side1 * side1 + side2 * side2 - 2 * (rad * rad)) / 2;
                  const sq = Math.sqrt(b);
                  const a = (Math.acos(
                      (side2 * side2 - rad * rad - sq * sq) / 
                      (2 * rad * sq)
                  ) * 180) / Math.PI;
                  const b_angle = 180 - a;
                  const h = rad * Math.sin((a * Math.PI) / 180);
                  const P = 2 * rad + 2 * sq;
                  const k = rad * sq * Math.sin((a * Math.PI) / 180);
                 param.tech_b = isNaN(b) ? "NaN" : b;
                  param.tech_sq = isNaN(sq) ? "NaN" : sq;
                  param.tech_a = isNaN(a) ? "NaN" : a;
                  param.tech_b_angle = isNaN(b_angle) ? "NaN" : b_angle;
                  param.tech_h = isNaN(h) ? "NaN" : h;
                  param.tech_P = isNaN(P) ? "NaN" : P;
                  param.tech_k = isNaN(k) ? "NaN" : k;
                  return param;

              }
          } else {
              param.error = "Please Enter Positive Numbers.";
              return param;
          }
      } else if (method == "19") {
          if (rad > 0 && side1 > 0 && side2 > 0) {
              let c1, c2, log, sam;
              
              if (side1 > side2) {
                  c1 = ((side1 - side2) / 2) + side1;
                  c2 = (side2 - side2) / 2;
                  log = 'p';
                  sam = 'q';
              } else {
                  c1 = ((side2 - side1) / 2) + side1;
                  c2 = (side2 - side1) / 2;
                  log = 'q';
                  sam = 'p';
              }
              
              if (rad < c2) {
                  param.error = `Side length (b) must be longer than the difference between the longer diagonal (${log}) and the shorter diagonal (${sam}) divided by 2 plus (p). Side length (b) must be less than ${c2} or a diagonal must be longer. [b > absolute value of (q-p)/2].`;
                  return param;
              } else if (rad > c1) {
                  param.error = `Side length (b) must be shorter than the difference between the longer diagonal (${log}) and the shorter diagonal (${sam}) divided by 2 plus (p). Side length (b) must be less than ${c1} or b diagonal must be longer. [b > absolute value of (q-p)/2].`;
                  return param;
              } else {
                  const a = (side1 * side1 + side2 * side2 - 2 * (rad * rad)) / 2;
                  const sq = Math.sqrt(a);
                  const an = (Math.acos(
                      (side2 * side2 - sq * sq - rad * rad) / 
                      (2 * sq * rad)
                  ) * 180) / Math.PI;
                  const b_angle = 180 - an;
                  const h = sq * Math.sin((an * Math.PI) / 180);
                  const P = 2 * sq + 2 * rad;
                  const k = sq * rad * Math.sin((an * Math.PI) / 180);
                  param.tech_a = isNaN(a) ? "NaN" : a;
                  param.tech_sq = isNaN(sq) ? "NaN" : sq;
                  param.tech_an = isNaN(an) ? "NaN" : an;
                  param.tech_b_angle = isNaN(b_angle) ? "NaN" : b_angle;
                  param.tech_h = isNaN(h) ? "NaN" : h;
                  param.tech_P = isNaN(P) ? "NaN" : P;
                  param.tech_k = isNaN(k) ? "NaN" : k;

                  return param;

              }
          } else {
              param.error = "Please Enter Positive Numbers.";
              return param;
          }
      }
      
      return param;
  }

   /**
    * getCalculationReferenceAngleCalculator: Service Method
    * POST: /api/calculators-lol/reference-angle-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

 async getCalculationReferenceAngleCalculator(body) {
      const angle = body.tech_angle;
      const angle_unit = body.tech_angle_unit;
      const param = {};

      if (angle_unit == "deg") {
        if (!isNaN(angle) && angle !== null && angle !== '') {
          let angle_convert = angle * 1;
          let ans, src;

          if (angle_convert >= 0 && angle_convert <= 90) {
            ans = angle_convert;
            src = "11.svg";
          } else if (angle_convert > 90 && angle_convert <= 180) {
            ans = 180 - angle_convert;
            src = "22.svg";
          } else if (angle_convert > 180 && angle_convert <= 270) {
            ans = angle_convert - 180;
            src = "33.svg";
          } else if (angle_convert > 270 && angle_convert <= 360) {
            ans = 360 - angle_convert;
            src = "44.svg";
          } else if (angle_convert > 360) {
            while (angle_convert > 360) {
              angle_convert = angle_convert - 360;
            }
            if (angle_convert >= 0 && angle_convert <= 90) {
              ans = angle_convert;
              src = "11.svg";
            } else if (angle_convert > 90 && angle_convert <= 180) {
              ans = 180 - angle_convert;
              src = "22.svg";
            } else if (angle_convert > 180 && angle_convert <= 270) {
              ans = angle_convert - 180;
              src = "33.svg";
            } else if (angle_convert > 270 && angle_convert <= 360) {
              ans = 360 - angle_convert;
              src = "44.svg";
            }
          } else if (angle_convert <= 0 && angle_convert >= -90) {
            const mul = -1;
            ans = angle_convert * mul;
            src = "44.svg";
          } else if (angle_convert < -90 && angle_convert >= -180) {
            const mul = -1;
            const converting = angle_convert * (-1);
            ans = 180 - converting;
            src = "33.svg";
          } else if (angle_convert < -180 && angle_convert >= -270) {
            const mul = -1;
            const converting = angle_convert * (-1);
            ans = converting - 180;
            src = "22.svg";
          } else if (angle_convert < -270 && angle_convert >= -360) {
            const mul = -1;
            const converting = angle_convert * (-1);
            ans = converting - 360;
            src = "11.svg";
          } else if (angle_convert < -360) {
            while (angle_convert < -360) {
              angle_convert = angle_convert + 360;
            }
            if (angle_convert <= 0 && angle_convert >= -90) {
              const mul = -1;
              ans = angle_convert * mul;
              src = "44.svg";
            } else if (angle_convert < -90 && angle_convert >= -180) {
              const mul = -1;
              const converting = angle_convert * mul;
              ans = 180 - converting;
              src = "33.svg";
            } else if (angle_convert < -180 && angle_convert >= -270) {
              const mul = -1;
              const converting = angle_convert * mul;
              ans = angle_convert - converting;
              src = "22.svg";
            } else if (angle_convert < -270 && angle_convert >= -360) {
              const mul = -1;
              const converting = angle_convert * mul;
              ans = angle_convert - converting;
              src = "11.svg";
            }
          }
          param.tech_pi = ans * 0.005556;
          param.tech_ans = ans;
          param.tech_src = src;
        } else {
          param.error = 'Please Check Your Input.';
          return param;
        }
      } else if (angle_unit == "rad") {
        if (!isNaN(angle) && angle !== null && angle !== '') {
          let convert = angle * 57.2958;
          let ans, src;

          if (convert >= 0 && convert <= 90) {
            ans = convert;
            src = "11.svg";
          } else if (convert > 90 && convert <= 180) {
            ans = 180 - convert;
            src = "22.svg";
          } else if (convert > 180 && convert <= 270) {
            ans = convert - 180;
            src = "33.svg";
          } else if (convert > 270 && convert <= 360) {
            ans = 360 - convert;
            src = "44.svg";
          } else if (convert > 360) {
            while (convert > 360) {
              convert = convert - 360;
            }
            if (convert >= 0 && convert <= 90) {
              ans = convert;
              src = "11.svg";
            } else if (convert > 90 && convert <= 180) {
              ans = 180 - convert;
              src = "22.svg";
            } else if (convert > 180 && convert <= 270) {
              ans = convert - 180;
              src = "33.svg";
            } else if (convert > 270 && convert <= 360) {
              ans = 360 - convert;
              src = "44.svg";
            }
          } else if (convert <= 0 && convert >= -90) {
            const mul = -1;
            ans = convert * mul;
            src = "44.svg";
          } else if (convert < -90 && convert >= -180) {
            src = "33.svg";
            const mul = -1;
            const converting = convert * mul;
            ans = 180 - converting;
          } else if (convert < -180 && convert >= -270) {
            const mul = -1;
            src = "22.svg";
            const converting = convert * mul;
            ans = converting - 180;
          } else if (convert < -270 && convert >= -360) {
            src = "11.svg";
            const mul = -1;
            const converting = convert * mul;
            ans = 360 - converting;
          } else if (convert < -360) {
            while (convert < -360) {
              convert = convert + 360;
            }
            if (convert <= 0 && convert >= -90) {
              const mul = -1;
              ans = convert * mul;
              src = "44.svg";
            } else if (convert < -90 && convert >= -180) {
              src = "33.svg";
              const mul = -1;
              const converting = convert * mul;
              ans = 180 - converting;
            } else if (convert < -180 && convert >= -270) {
              const mul = -1;
              const converting = convert * mul;
              src = "22.svg";
              ans = converting - 180;
            } else if (convert < -270 && convert >= -360) {
              src = "11.svg";
              const mul = -1;
              const converting = convert * mul;
              ans = 360 - converting;
            }
          }
          param.tech_pi = (ans * 0.3183) * 0.017453;
          param.tech_ans = ans;
          param.tech_src = src;
        } else {
          param.error = 'Please Check Your Input.';
          return param;
        }
      } else {
        if (!isNaN(angle) && angle !== null && angle !== '') {
          const ans = angle * 0;
          const src = "";
          param.tech_ans = ans;
          param.tech_src = src;
        } else {
          param.error = 'Please Check Your Input.';
          return param;
        }
      }

      return param;
    }


       /**
    * getCalculationRationalOrIrrationalCalculator: Service Method
    * POST: /api/calculators-lol/rational-or-irrational-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

  async getCalculationRationalOrIrrationalCalculator(body) {
      const expression_unit = body.tech_expression_unit;
      const num1 = body.tech_num1;
      const num2 = body.tech_num2;
      const param = {};

      // Helper function to find repeating patterns
      function findRepeat(number) {
        const maxLength = 6;
        const numberStr = number.toString();
        const dotIndex = numberStr.indexOf('.');
        
        if (dotIndex == -1) return false;
        
        let decimal = numberStr.substring(dotIndex + 1);
        
        if (decimal.length >= maxLength) {
          decimal = decimal.substring(0, maxLength);
        }
        
        const checkLength = decimal.length;

        for (let i = 0; i < checkLength - 3; ++i) {
          // Check for single repetition
          if (decimal[i] == decimal[i + 1] && decimal[i + 1] == decimal[i + 2]) {
            return { position: i, patternSize: 1 };
          }
          // Triple repetition
          if (decimal.substring(i, i + 3) == decimal.substring(i + 3, i + 6)) {
            return { position: i, patternSize: 3 };
          }
          // Double repetition
          if (decimal.substring(i, i + 2) == decimal.substring(i + 2, i + 4)) {
            return { position: i, patternSize: 2 };
          }
        }
        return false;
      }

      if (!isNaN(num1) && num1 != null && num1 != '' && 
          !isNaN(num2) && num2 != null && num2 != '') {
        
        let final_ans, exp;

        if (expression_unit == "1") {
          if (num1 > 0 && num2 > 0) {
            const num1_ans = 1 / num1;
            final_ans = Math.pow(num2, num1_ans);
          } else {
            param.error = 'Please Enter value greater than zero.';
            return param;
          }

          if (num2 % num1 == 0) {
            if (num1 == num2) {
              if (num1 == 1 && num2 == 1) {
                exp = "Given Number is Rational";
              } else {
                exp = "Given Number is Irrational";
              }
            } else if (num1 != num2) {
              exp = "Given Number is Rational";
            }
          } else {
            exp = "Given Number is Irrational";
          }
        } else if (expression_unit == "2") {
          if (!isNaN(num1) && num1 != null && num1 != '' && num2 > 0) {
            if (num1 == 22 && num2 == 7) {
              final_ans = num1 / num2;
              exp = "Given Number is Irrational";
            } else {
              final_ans = num1 / num2;
              exp = "Given Number is Rational";
            }

            const repeatResult = findRepeat(final_ans);
            if (repeatResult != false) {
              const finalAnsStr = final_ans.toString();
              const dotIndex = finalAnsStr.indexOf('.');
              const leadingNum = finalAnsStr.substring(0, dotIndex);
              
              let nonRepeat = finalAnsStr.substring(dotIndex + 1, dotIndex + 1 + repeatResult.position);
              if (nonRepeat == '') {
                nonRepeat = '.';
              }

              const repeat = finalAnsStr.substring(
                dotIndex + 1 + repeatResult.position,
                dotIndex + 1 + repeatResult.position + repeatResult.patternSize
              );
              
              const nonRepeatStr = nonRepeat == '.' ? '.' : '.' + nonRepeat;
              final_ans = leadingNum + nonRepeatStr + "<span style='text-decoration:overline'>" + repeat + "</span>";
            } else {
              final_ans = final_ans;
            }
          } else {
            param.error = 'Please Enter value greater than zero.';
            return param;
          }
        }

        if (final_ans != undefined && final_ans != null) {
          param.tech_final_ans = final_ans;
        }
        if (exp != undefined && exp != null && exp != '') {
          param.tech_exp = exp;
        }
        return param;
      } else {
        param.error = 'Please! Check Your Input.';
        return param;
      }
    }

        /**
    * getCalculationSimplifyRadicalsCalculator: Service Method
    * POST: /api/calculators-lol/simplify-radicals-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

 async getCalculationSimplifyRadicalsCalculator(body) {
    let num1 = body.tech_num1;
    let num2 = body.tech_num2;
    let num3 = body.tech_num3;
    let num4 = body.tech_num4;
    let num5 = body.tech_num5;
    let num6 = body.tech_num6;
    const expression_unit = body.tech_expression_unit;
    const param = {};

    if (expression_unit == "1") {
      if (!isNaN(num2) && num2 != null && num2 != '' && 
          !isNaN(num3) && num3 != null && num3 != '') {
        
        if (num2 < 0) {
          param.error = 'b cannot be negative';
          return param;
        }
        if (num3 < 2) {
          param.error = 'n cannot be smaller than 2';
          return param;
        }
        if (num1 != "" && num1 != null && num1 != undefined) {
          // num1 has value
        } else if (num1 == "" || num1 == null || num1 == undefined) {
          num1 = 1;
        } else if (num1 == 0) {
          param.error = 'Number cannot be zero';
          return param;
        }

        param.tech_num1 = num1;
        param.tech_num2 = num2;
        param.tech_num3 = num3;
        param.tech_num4 = 1;
        param.tech_num5 = 1;
        param.tech_num6 = 1;
        param.tech_expression_unit = expression_unit;
        return param;
      } else {
        param.error = 'Please! Check Your Input';
        return param;
      }
    } else if (expression_unit == "2") {
      if (!isNaN(num2) && num2 != null && num2 != '' && 
          !isNaN(num3) && num3 != null && num3 != '' &&
          !isNaN(num5) && num5 != null && num5 != '' &&
          !isNaN(num6) && num6 != null && num6 != '') {
        
        if (num2 < 0) {
          param.error = 'b cannot be negative';
          return param;
        }
        if (num3 < 2) {
          param.error = 'n cannot be smaller than 2';
          return param;
        }
        if (num5 < 0) {
          param.error = 'd cannot be negative';
          return param;
        }
        if (num6 < 2) {
          param.error = 'm cannot be smaller than 2';
          return param;
        }

        if (num1 == "" || num1 == null || num1 == undefined) {
          num1 = 1;
        } else if (num1 != "" && num1 != null && num1 != undefined) {
          param.tech_num1 = num1;
        } else if (num1 == 0) {
          param.error = 'Number cannot be zero';
          return param;
        }

        if (num4 == "" || num4 == null || num4 == undefined) {
          num4 = 1;
        } else if (num4 != "" && num4 != null && num4 != undefined) {
          param.tech_num4 = num4;
        } else if (num4 == 0) {
          param.error = 'Number cannot be zero';
          return param;
        }

        param.tech_num1 = num1;
        param.tech_num4 = num4;
        param.tech_num2 = num2;
        param.tech_num3 = num3;
        param.tech_num5 = num5;
        param.tech_num6 = num6;
        param.tech_expression_unit = expression_unit;
        return param;
      } else {
        param.error = 'Please! Check Your Input';
        return param;
      }
    } else if (expression_unit == "3") {
      if (!isNaN(num2) && num2 != null && num2 != '' && 
          !isNaN(num3) && num3 != null && num3 != '' &&
          !isNaN(num5) && num5 != null && num5 != '' &&
          !isNaN(num6) && num6 != null && num6 != '') {
        
        if (num2 < 0) {
          param.error = 'b cannot be negative';
          return param;
        }
        if (num3 < 2) {
          param.error = 'n cannot be smaller than 2';
          return param;
        }
        if (num5 < 0) {
          param.error = 'd cannot be negative';
          return param;
        }
        if (num6 < 2) {
          param.error = 'm cannot be smaller than 2';
          return param;
        }

        if (num1 == "" || num1 == null || num1 == undefined) {
          num1 = 1;
        } else if (num1 != "" && num1 != null && num1 != undefined) {
          param.tech_num1 = num1;
        } else if (num1 == 0) {
          param.error = 'Number cannot be zero';
          return param;
        }

        if (num4 == "" || num4 == null || num4 == undefined) {
          num4 = 1;
        } else if (num4 != "" && num4 != null && num4 != undefined) {
          param.tech_num4 = num4;
        } else if (num4 == 0) {
          param.error = 'Number cannot be zero';
          return param;
        }

        param.tech_num1 = num1;
        param.tech_num4 = num4;
        param.tech_num2 = num2;
        param.tech_num3 = num3;
        param.tech_num5 = num5;
        param.tech_num6 = num6;
        param.tech_expression_unit = expression_unit;
        param.tech_operation = 4;
        return param;
      } else {
        param.error = 'Please! Check Your Input';
        return param;
      }
    } else if (expression_unit == "4") {
      if (!isNaN(num2) && num2 != null && num2 != '' && 
          !isNaN(num3) && num3 != null && num3 != '' &&
          !isNaN(num5) && num5 != null && num5 != '' &&
          !isNaN(num6) && num6 != null && num6 != '') {
        
        if (num2 < 0) {
          param.error = 'b cannot be negative';
          return param;
        }
        if (num3 < 2) {
          param.error = 'n cannot be smaller than 2';
          return param;
        }
        if (num5 < 0) {
          param.error = 'd cannot be negative';
          return param;
        }
        if (num6 < 2) {
          param.error = 'm cannot be smaller than 2';
          return param;
        }

        if (num1 == "" || num1 == null || num1 == undefined) {
          num1 = 1;
        } else if (num1 != "" && num1 != null && num1 != undefined) {
          param.tech_num1 = num1;
        } else if (num1 == 0) {
          param.error = 'Number cannot be zero';
          return param;
        }

        if (num4 == "" || num4 == null || num4 == undefined) {
          num4 = 1;
        } else if (num4 != "" && num4 != null && num4 != undefined) {
          param.tech_num4 = num4;
        } else if (num4 == 0) {
          param.error = 'Number cannot be zero';
          return param;
        }

        param.tech_num1 = num1;
        param.tech_num4 = num4;
        param.tech_num2 = num2;
        param.tech_num3 = num3;
        param.tech_num5 = num5;
        param.tech_num6 = num6;
        param.tech_expression_unit = expression_unit;
        param.tech_operation = 4;
        return param;
      } else {
        param.error = 'Please! Check Your Input';
        return param;
      }
    }
  }

       /**
    * getCalculationEllipseEquationCalculator: Service Method
    * POST: /api/calculators-lol/ellipse-equation-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationEllipseEquationCalculator(body) {
    const d1 = body.tech_d1;
    const n2 = body.tech_n2;
    const second_value = body.tech_second_value;
    const c1 = body.tech_c1;
    const c2 = body.tech_c2;
    const selection = body.tech_selection;
    const param = {};

    // Helper function to calculate GCD
    function gcd(a23, b23) {
      a23 = Math.abs(a23);
      b23 = Math.abs(b23);

      if (a23 < b23) {
        [b23, a23] = [a23, b23];
      }
      if (b23 == 0) {
        return 1;
      }
      let r = a23 % b23;
      while (r > 0) {
        const a = b23;
        b23 = r;
        r = a % b23;
      }
      return b23;
    }

    // Helper function to reduce fraction
    function reduce(num23, den23) {
      const g = gcd(num23, den23);
      return [num23 / g, den23 / g];
    }

    if (selection == "1") {
      if (!isNaN(d1) && d1 != null && d1 != '' && 
          !isNaN(n2) && n2 != null && n2 != '' && 
          !isNaN(second_value) && second_value !== null && second_value !== '' && 
          d1 > 0 && n2 > 0 && second_value > 0) {
        
        if (!isNaN(n2) && !isNaN(d1)) {
          const totalN = n2;
          const totalD = d1;
          const g = gcd(totalN, totalD);
          const [upr, btm] = reduce(totalN, totalD);
          
          // Return Values
          param.tech_upr = upr;
          param.tech_totalN = totalN;
          param.tech_totalD = totalD;
          param.tech_g = g;
          param.tech_btm = btm;
          param.tech_method = selection;
        }

        if (!isNaN(n2) && !isNaN(second_value)) {
          const totalN1 = n2;
          const totalD1 = second_value;
          const g1 = gcd(totalN1, totalD1);
          const [upr1, btm1] = reduce(totalN1, totalD1);
          
          // Return Values
          param.tech_upr1 = upr1;
          param.tech_totalN1 = totalN1;
          param.tech_totalD1 = totalD1;
          param.tech_g1 = g1;
          param.tech_btm1 = btm1;
          param.tech_method = selection;
          return param;
        }
      } else {
        param.error = 'Please! Check Your Input.';
        return param;
      }
    } else if (selection == "2") {
      if (!isNaN(c1) && c1 != null && c1 != '' && 
          !isNaN(c2) && c2 != null && c2 != '' && 
          !isNaN(d1) && d1 != null && d1 != '' && 
          !isNaN(second_value) && second_value != null && second_value != '' && 
          d1 > 0 && second_value > 0) {
        
        let calculate_eccentricity;
        if (d1 > second_value) {
          calculate_eccentricity = Math.sqrt(((d1 * d1) - (second_value * second_value))) / d1;
        } else if (second_value > d1) {
          calculate_eccentricity = Math.sqrt(((second_value * second_value) - (d1 * d1))) / second_value;
        }

        const area = 3.14 * d1 * second_value;
        
        param.tech_d1 = d1;
        param.tech_c2 = second_value;
        param.tech_center1 = c1;
        param.tech_center2 = c2;
        param.tech_calculate_eccentricity = calculate_eccentricity;
        param.tech_area = area;
        param.tech_method = selection;
        return param;
      } else {
        param.error = 'Please! Check Your Input.';
        return param;
      }
    }
  }


       /**
    * getCalculationRrefCalculator: Service Method
    * POST: /api/calculators-lol/rref-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */
    async getCalculationRrefCalculator(body) {
      const matrix2 = parseInt(body.matrix2);
      const matrix22 = parseInt(body.matrix22);
      const second_matrix = [];

      // Extract matrix data
      for (let i = 1; i <= matrix2; i++) {
          for (let j = 1; j <= matrix22; j++) {
              const key = `matrix3${i}_${j}`;
              if (body[key] !== undefined && !isNaN(parseFloat(body[key]))) {
                  second_matrix.push(parseFloat(body[key]));
              }
          }
      }

      // Helper functions
      const gcd22 = (a, b, f) => {
          if (f) {
              if (b <= 1) return a;
          } else {
              if (!b) return a;
          }
          return gcd22(b, a % b, f);
      };

      const roundresult2 = (x) => {
          const y = parseFloat(x);
          return roundnum2(y, 10);
      };

      const toPrecision2 = (number, precision) => {
          if (number == 0) return 0;
          const exponent = Math.floor(Math.log10(Math.abs(number)) + 1);
          const significand = Math.round((number / Math.pow(10, exponent)) * Math.pow(10, precision)) / Math.pow(10, precision);
          return significand * Math.pow(10, exponent);
      };

      const roundnum2 = (x, p) => {
          const n = parseFloat(x);
          const m = toPrecision2(n, (p + 1));
          const y = m.toString();
          return y;
      };

      const digits_after_period2 = (x) => {
          const f = x.toString();
          const i = f.indexOf('.');
          if (i === -1) return 0;
          return f.length - i - 1;
      };

      const convert2 = (xelem) => {
          let sign = '';
          let sign2 = '+';
          let f = false;
          const x = xelem;
          const x2 = roundresult2(x);
          const absx = Math.abs(x2);
          const y = Math.floor(absx);
          const frac = (absx - y);
          
          if (x2 < 0) {
              sign = sign2 = '-';
          }
          
          const d = digits_after_period2(absx);
          const den = Math.round(Math.pow(10, d));
          const num = Math.round(frac * den);
          const a12 = num.toString();
          const len = a12.length;
          
          if (len > 8) f = true;
          
          const g = gcd22(num, den, f);
          const num2 = Math.round(num / g);
          const den2 = Math.round(den / g);
          
          const top_jawab = sign + (num2 + den2 * y);
          const down_jawab = den2;
          
          return [top_jawab, down_jawab];
      };

      // Function to remove ONLY negative zeros but preserve other negative values
      const cleanMatrixValues = (matrix) => {
          return matrix.map(row => 
              row.map(val => {
                  // Check if it's a negative zero (either -0 or very close to 0 but negative)
                  if (Math.abs(val) < 1e-10 && val < 0) {
                      return 0;
                  }
                  // For very small positive numbers that might be floating point errors
                  if (Math.abs(val) < 1e-10 && val >= 0) {
                      return 0;
                  }
                  return val;
              })
          );
      };

      const rref2 = (matrix) => {
          let lead = 0;
          let pz = matrix.map(row => [...row]); // Create a deep copy
          const swap = [];
          const swap_line = [];
          const rowCount = matrix.length;
          
          if (rowCount == 0) return [matrix, swap, swap_line, pz];
          
          let columnCount = 0;
          if (matrix[0]) {
              columnCount = matrix[0].length;
          }
          
          for (let r = 0; r < rowCount; r++) {
              if (lead >= columnCount) break;
              
              // Find pivot row
              let i = r;
              while (Math.abs(matrix[i][lead]) < 1e-10) { // Use tolerance for zero check
                  i++;
                  if (i == rowCount) {
                      i = r;
                      lead++;
                      if (lead == columnCount) {
                          const finalMatrix = cleanMatrixValues(matrix);
                          const finalPz = cleanMatrixValues(pz);
                          return [finalMatrix, swap, swap_line, finalPz];
                      }
                  }
              }
              
              // Swap rows if needed
              if (i != r) {
                  [matrix[r], matrix[i]] = [matrix[i], matrix[r]];
                  [pz[r], pz[i]] = [pz[i], pz[r]];
                  
                  if (Math.abs(matrix[i][lead]) < 1e-10) {
                      swap_line.push(`Swap the row ${r + 1} with row ${i + 1}`);
                      swap.push(cleanMatrixValues(pz.map(row => [...row])));
                  }
              }
              
              // Normalize pivot row
              const lv = matrix[r][lead];
              if (Math.abs(lv) > 1e-10) {
                  for (let j = 0; j < columnCount; j++) {
                      matrix[r][j] = matrix[r][j] / lv;
                      pz[r][j] = pz[r][j] / lv;
                  }
                  
                  const test1 = convert2(lv);
                  if (test1[1] == 1) {
                      swap_line.push(`Divide row ${r + 1} by ${lv}: R<sub>${r + 1}</sub> = R<sub>${r + 1}</sub>/${lv}`);
                  } else {
                      const lv3 = `${test1[1]}/${test1[0]}`;
                      swap_line.push(`Multiply row ${r + 1} by ${lv3}: R<sub>${r + 1}</sub> = ${lv3} R<sub>${r + 1}</sub>`);
                  }
                  swap.push(cleanMatrixValues(pz.map(row => [...row])));
              }
              
              // Eliminate other rows
              for (let i = 0; i < rowCount; i++) {
                  if (i != r && Math.abs(matrix[i][lead]) > 1e-10) {
                      const lv = matrix[i][lead];
                      const lv2 = pz[i][lead];
                      
                      for (let j = 0; j < columnCount; j++) {
                          matrix[i][j] -= lv * matrix[r][j];
                          pz[i][j] -= lv2 * pz[r][j];
                      }
                      
                      // Clean only negative zeros after each operation
                      matrix[i] = matrix[i].map(val => {
                          if (Math.abs(val) < 1e-10 && val < 0) return 0;
                          if (Math.abs(val) < 1e-10 && val >= 0) return 0;
                          return val;
                      });
                      pz[i] = pz[i].map(val => {
                          if (Math.abs(val) < 1e-10 && val < 0) return 0;
                          if (Math.abs(val) < 1e-10 && val >= 0) return 0;
                          return val;
                      });
                      
                      swap.push(cleanMatrixValues(pz.map(row => [...row])));
                      const test = convert2(lv);
                      let displayLv = lv;
                      if (test[1] != 1) {
                          displayLv = `${test[0]}/${test[1]}`;
                      }
                      swap_line.push(`Subtract row ${i} multiplied by ${displayLv} from row R${i + 1}: R<sub>${i + 1}</sub> = R<sub>${i + 1}</sub> - ${displayLv}R<sub>${i}</sub>`);
                  }
              }
              
              lead++;
          }

          // Final cleanup of ONLY negative zeros
          const finalMatrix = cleanMatrixValues(matrix);
          const finalPz = cleanMatrixValues(pz);
          
          return [finalMatrix, swap, swap_line, finalPz];
      };

      // Main logic
      const mul = matrix22 * matrix2;
      let result = {};

      if (mul == second_matrix.length) {
          // Convert flat array to 2D matrix
          const zain = [];
          for (let i = 0; i < matrix2; i++) {
              const row = second_matrix.slice(i * matrix22, (i + 1) * matrix22);
              zain.push(row);
          }
          
          const fahad2 = rref2(zain);
          result.tech_matrix = fahad2[0];
          result.tech_swap = fahad2[1];
          result.tech_swap_line = fahad2[2];
      } else {
          result.error = 'Please! Check Your Input.';
      }

      return result;
  }

     /**
    * getCalculationGematriaCalculator: Service Method
    * POST: /api/calculators-lol/gematria-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */
  async getCalculationGematriaCalculator(body) {
        const input = body.tech_input;
        const param = {};

        // Gematria mapping arrays
        const English_Ordinal = {
          'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8, 'i': 9,
          'j': 10, 'k': 11, 'l': 12, 'm': 13, 'n': 14, 'o': 15, 'p': 16, 'q': 17,
          'r': 18, 's': 19, 't': 20, 'u': 21, 'v': 22, 'w': 23, 'x': 24, 'y': 25, 'z': 26,
          '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9
        };

        const Full_Reduction = {
          'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8, 'i': 9,
          'j': 1, 'k': 2, 'l': 3, 'm': 4, 'n': 5, 'o': 6, 'p': 7, 'q': 8, 'r': 9,
          's': 1, 't': 2, 'u': 3, 'v': 4, 'w': 5, 'x': 6, 'y': 7, 'z': 8,
          '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9
        };

        const Reverse_Ordinal = {
          'a': 26, 'b': 25, 'c': 24, 'd': 23, 'e': 22, 'f': 21, 'g': 20, 'h': 19, 'i': 18,
          'j': 17, 'k': 16, 'l': 15, 'm': 14, 'n': 13, 'o': 12, 'p': 11, 'q': 10, 'r': 9,
          's': 8, 't': 7, 'u': 6, 'v': 5, 'w': 4, 'x': 3, 'y': 2, 'z': 1,
          '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9
        };

        const Reverse_Full_Reduction = {
          'a': 8, 'b': 7, 'c': 6, 'd': 5, 'e': 4, 'f': 3, 'g': 2, 'h': 1, 'i': 9,
          'j': 8, 'k': 7, 'l': 6, 'm': 5, 'n': 4, 'o': 3, 'p': 2, 'q': 1, 'r': 9,
          's': 8, 't': 7, 'u': 6, 'v': 5, 'w': 4, 'x': 3, 'y': 2, 'z': 1,
          '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9
        };

        const Jewish_Gematria = {
          'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8, 'i': 9,
          'j': 600, 'k': 10, 'l': 20, 'm': 30, 'n': 40, 'o': 50, 'p': 60, 'q': 70,
          'r': 80, 's': 90, 't': 100, 'u': 200, 'v': 700, 'w': 900, 'x': 300, 'y': 400, 'z': 500,
          '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9
        };

        const English_Gematria = {
          'a': 6, 'b': 12, 'c': 18, 'd': 24, 'e': 30, 'f': 36, 'g': 42, 'h': 48, 'i': 54,
          'j': 60, 'k': 66, 'l': 72, 'm': 78, 'n': 84, 'o': 90, 'p': 96, 'q': 102, 'r': 108,
          's': 114, 't': 120, 'u': 126, 'v': 132, 'w': 138, 'x': 144, 'y': 150, 'z': 156,
          '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9
        };

        const Hebrew = {
          'a': 1, 'b': 2, 'c': 8, 'd': 4, 'e': 5, 'f': 80, 'g': 3, 'h': 5, 'i': 10,
          'j': 10, 'k': 20, 'l': 30, 'm': 40, 'n': 50, 'o': 70, 'p': 80, 'q': 100,
          'r': 200, 's': 60, 't': 9, 'u': 6, 'v': 6, 'w': 6, 'x': 60, 'y': 10, 'z': 7,
          '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9
        };

        // Helper functions
        function printDivisors(n) {
          const divi = [];
          for (let i = 1; i <= n; i++) {
            if (n % i == 0) divi.push(i);
          }
          return divi;
        }

        function np(num) {
          let prev = '';
          let next = 0;
          
          // Find next prime
          let i = num;
          let check_n = 0;
          while (i < 10000000 && check_n != 1) {
            i++;
            let mm = 0;
            for (let j = 2; j <= i / 2; j++) {
              if (i % j == 0) {
                mm++;
                break;
              }
            }
            if (mm == 0) {
              next = i;
              check_n = 1;
            }
          }
          
          // Find previous prime
          i = num;
          check_n = 0;
          while (i > 2 && check_n !== 1) {
            i--;
            let mm = 0;
            for (let j = 2; j <= i / 2; j++) {
              if (i % j == 0) {
                mm++;
                break;
              }
            }
            if (mm == 0) {
              prev = i;
              check_n = 1;
            }
          }
          
          return [prev, next];
        }

        function factor(loop_eo) {
          let newtext_eo = "";
          let chk_eo = 2;
          
          while (chk_eo * chk_eo <= loop_eo) {
            if (loop_eo % chk_eo == 0) {
              newtext_eo += chk_eo;
              loop_eo = loop_eo / chk_eo;
              if (loop_eo !== 1) {
                newtext_eo += " × ";
              }
            } else {
              chk_eo++;
            }
          }
          
          if (loop_eo != 1) {
            newtext_eo += loop_eo;
          }
          
          if (newtext_eo == "" + loop_eo) {
            newtext_eo = "1 × " + newtext_eo;
          }
          
          return newtext_eo;
        }

        function total(num) {
          let totalCount = 0;
          for (let i = 2; i <= num; i++) {
            let mm = 0;
            for (let j = 2; j <= i / 2; j++) {
              if (i % j == 0) {
                mm++;
                break;
              }
            }
            if (mm == 0) {
              totalCount++;
            }
          }
          return totalCount;
        }

        function primeCheck(number) {
          if (number == 1) return 0;
          for (let i = 2; i <= number / 2; i++) {
            if (number % i == 0) return 0;
          }
          return 1;
        }

        // Generate triangular numbers
        const triangular = [];
        for (let i = 2, j = 1; i < 10000; i++) {
          triangular.push(j);
          j += i;
        }

        // Generate prime numbers
        const prime_nums = [];
        for (let i = 0; i < 10000; i++) {
          if (i == 1 || i == 0) continue;
          let f = 1;
          for (let j = 2; j < Math.floor(i / 2) + 1; j++) {
            if (i % j == 0) {
              f = 0;
              break;
            }
          }
          if (f == 1) prime_nums.push(i);
        }

        // Generate Fibonacci sequence
        const arr = [];
        let num1 = 0;
        let num2 = 1;
        let counter = 0;
        while (counter < 1000) {
          arr.push(num1);
          let num3 = num2 + num1;
          num1 = num2;
          num2 = num3;
          counter++;
        }

        if (!input) {
          param.error = "Please! Enter Your Input.";
          return param;
        }

        // Process input
        const small = input.toLowerCase();
        const words1 = small.replace(/[^a-zA-Z0-9]+/g, " ");
        const alphabets = small.replace(/[^a-zA-Z]+/g, "");
        const null_space = small.replace(/\s/g, '');
        const numbers = null_space.replace(/[^0-9]+/g, "");
        const count_wrd = words1.split(" ");
        const words_ans = count_wrd.length;
        const count_ans = alphabets.length;
        const num_agye = numbers.split('').map(Number);
        const sum_num = num_agye.reduce((a, b) => a + b, 0);
        const array_agai = alphabets.split('');
        const nawa = small.split(' ');

        // Process words
        const inner_alpha = [];
        const inner_ans_eo = [];
        const inner_ans_fr = [];
        const inner_ans_ro = [];
        const inner_ans_rfd = [];
        const inner_ans_jg = [];
        const inner_ans_eg = [];
        const inner_ans_h = [];
        const inner_sum_eo = [];
        const inner_sum_fr = [];
        const inner_sum_ro = [];
        const inner_sum_rfd = [];
        const inner_sum_jg = [];
        const inner_sum_eg = [];
        const inner_sum_h = [];

        nawa.forEach((value, i) => {
          const chars = value.trim().split('');
          inner_alpha[i] = chars;
          inner_ans_eo[i] = [];
          inner_ans_fr[i] = [];
          inner_ans_ro[i] = [];
          inner_ans_rfd[i] = [];
          inner_ans_jg[i] = [];
          inner_ans_eg[i] = [];
          inner_ans_h[i] = [];

          chars.forEach(char => {
            inner_ans_eo[i].push(English_Ordinal[char] || 0);
            inner_ans_fr[i].push(Full_Reduction[char] || 0);
            inner_ans_ro[i].push(Reverse_Ordinal[char] || 0);
            inner_ans_rfd[i].push(Reverse_Full_Reduction[char] || 0);
            inner_ans_jg[i].push(Jewish_Gematria[char] || 0);
            inner_ans_eg[i].push(English_Gematria[char] || 0);
            inner_ans_h[i].push(Hebrew[char] || 0);
          });

          inner_sum_eo.push(inner_ans_eo[i].reduce((a, b) => a + b, 0));
          inner_sum_fr.push(inner_ans_fr[i].reduce((a, b) => a + b, 0));
          inner_sum_ro.push(inner_ans_ro[i].reduce((a, b) => a + b, 0));
          inner_sum_rfd.push(inner_ans_rfd[i].reduce((a, b) => a + b, 0));
          inner_sum_jg.push(inner_ans_jg[i].reduce((a, b) => a + b, 0));
          inner_sum_eg.push(inner_ans_eg[i].reduce((a, b) => a + b, 0));
          inner_sum_h.push(inner_ans_h[i].reduce((a, b) => a + b, 0));
        });

        // Calculate sums for each system
        const sum_eo = array_agai.map(char => English_Ordinal[char] || 0);
        const sum_fr = array_agai.map(char => Full_Reduction[char] || 0);
        const sum_ro = array_agai.map(char => Reverse_Ordinal[char] || 0);
        const sum_rfd = array_agai.map(char => Reverse_Full_Reduction[char] || 0);
        const sum_jg = array_agai.map(char => Jewish_Gematria[char] || 0);
        const sum_eg = array_agai.map(char => English_Gematria[char] || 0);
        const sum_h = array_agai.map(char => Hebrew[char] || 0);

        let answer_eo, answer_fr, answer_ro, answer_rfd, answer_jg, answer_eg, answer_h;

        if (/\d/.test(input)) {
          answer_eo = sum_num;
          answer_fr = sum_num;
          answer_ro = sum_num;
          answer_rfd = sum_num;
          answer_jg = sum_num;
          answer_eg = sum_num;
          answer_h = sum_num;
        } else if (/[a-zA-Z]+/.test(input)) {
          answer_eo = sum_eo.reduce((a, b) => a + b, 0) + sum_num;
          answer_fr = sum_fr.reduce((a, b) => a + b, 0) + sum_num;
          answer_ro = sum_ro.reduce((a, b) => a + b, 0) + sum_num;
          answer_rfd = sum_rfd.reduce((a, b) => a + b, 0) + sum_num;
          answer_jg = sum_jg.reduce((a, b) => a + b, 0) + sum_num;
          answer_eg = sum_eg.reduce((a, b) => a + b, 0) + sum_num;
          answer_h = sum_h.reduce((a, b) => a + b, 0) + sum_num;
        } else {
          answer_eo = sum_eo.reduce((a, b) => a + b, 0);
          answer_fr = sum_fr.reduce((a, b) => a + b, 0);
          answer_ro = sum_ro.reduce((a, b) => a + b, 0);
          answer_rfd = sum_rfd.reduce((a, b) => a + b, 0);
          answer_jg = sum_jg.reduce((a, b) => a + b, 0);
          answer_eg = sum_eg.reduce((a, b) => a + b, 0);
          answer_h = sum_h.reduce((a, b) => a + b, 0);
        }

        // Factor calculations
        const newtext_eo = factor(answer_eo);
        const newtext_fr = factor(answer_fr);
        const newtext_ro = factor(answer_ro);
        const newtext_rfd = factor(answer_rfd);
        const newtext_jg = factor(answer_jg);
        const newtext_eg = factor(answer_eg);
        const newtext_h = factor(answer_h);

        // Divisor calculations
        const eo_divi = printDivisors(answer_eo);
        const count_eodivi = eo_divi.length;
        const eodivi_sum = eo_divi.reduce((a, b) => a + b, 0);
        
        const fr_divi = printDivisors(answer_fr);
        const count_frdivi = fr_divi.length;
        const frdivi_sum = fr_divi.reduce((a, b) => a + b, 0);
        
        const ro_divi = printDivisors(answer_ro);
        const count_rodivi = ro_divi.length;
        const rodivi_sum = ro_divi.reduce((a, b) => a + b, 0);
        
        const rfd_divi = printDivisors(answer_rfd);
        const count_rfddivi = rfd_divi.length;
        const rfddivi_sum = rfd_divi.reduce((a, b) => a + b, 0);
        
        const jg_divi = printDivisors(answer_jg);
        const count_jgdivi = jg_divi.length;
        const jgdivi_sum = jg_divi.reduce((a, b) => a + b, 0);
        
        const eg_divi = printDivisors(answer_eg);
        const count_egdivi = eg_divi.length;
        const egdivi_sum = eg_divi.reduce((a, b) => a + b, 0);
        
        const h_divi = printDivisors(answer_h);
        const count_hdivi = h_divi.length;
        const hdivi_sum = h_divi.reduce((a, b) => a + b, 0);

        // Fibonacci calculations
        const sq_root = Math.sqrt(5);
        const final_ans = (Math.pow(1.61803, answer_eo) - Math.pow(-0.61803, answer_eo)) / sq_root;
        const final_ans2 = (Math.pow(1.61803, answer_fr) - Math.pow(-0.61803, answer_fr)) / sq_root;
        const final_ans3 = (Math.pow(1.61803, answer_ro) - Math.pow(-0.61803, answer_ro)) / sq_root;
        const final_ans4 = (Math.pow(1.61803, answer_rfd) - Math.pow(-0.61803, answer_rfd)) / sq_root;
        const final_ans5 = (Math.pow(1.61803, answer_jg) - Math.pow(-0.61803, answer_jg)) / sq_root;
        const final_ans6 = (Math.pow(1.61803, answer_eg) - Math.pow(-0.61803, answer_eg)) / sq_root;
        const final_ans7 = (Math.pow(1.61803, answer_h) - Math.pow(-0.61803, answer_h)) / sq_root;

        // Adjacent primes
        const ap_eo = np(answer_eo);
        const [apeo_p, apeo_n] = ap_eo;
        
        const ap_fr = np(answer_fr);
        const [apfr_p, apfr_n] = ap_fr;
        
        const ap_ro = np(answer_ro);
        const [apro_p, apro_n] = ap_ro;
        
        const ap_rfd = np(answer_rfd);
        const [aprfd_p, aprfd_n] = ap_rfd;
        
        const ap_jg = np(answer_jg);
        const [apjg_p, apjg_n] = ap_jg;
        
        const ap_eg = np(answer_eg);
        const [apeg_p, apeg_n] = ap_eg;
        
        const ap_h = np(answer_h);
        const [aph_p, aph_n] = ap_h;

        // Prime count
        const previous_eo = total(answer_eo);
        const next_eo = previous_eo + 1;
        const previous_fr = total(answer_fr);
        const next_fr = previous_fr + 1;
        const previous_ro = total(answer_ro);
        const next_ro = previous_ro + 1;
        const previous_rfd = total(answer_rfd);
        const next_rfd = previous_rfd + 1;
        const previous_jg = total(answer_jg);
        const next_jg = previous_jg + 1;
        const previous_eg = total(answer_eg);
        const next_eg = previous_eg + 1;
        const previous_h = total(answer_h);
        const next_h = previous_h + 1;

        // Prime check
        const check_eo = primeCheck(answer_eo);
        const check_fr = primeCheck(answer_fr);
        const check_ro = primeCheck(answer_ro);
        const check_rfd = primeCheck(answer_rfd);
        const check_jg = primeCheck(answer_jg);
        const check_eg = primeCheck(answer_eg);
        const check_h = primeCheck(answer_h);

        // Triangular number check
        const eo = triangular.indexOf(answer_eo);
        const fr = triangular.indexOf(answer_fr);
        const ro = triangular.indexOf(answer_ro);
        const rfd = triangular.indexOf(answer_rfd);
        const jg = triangular.indexOf(answer_jg);
        const eg = triangular.indexOf(answer_eg);
        const h = triangular.indexOf(answer_h);

        // Process triangular results for each system
        const processTriangular = (answer, index, suffix) => {
          if (index !== -1) {
            param[`tech_index_${suffix}`] = index + 2;
          } else {
            const greater = triangular.filter(v => answer > v);
            const less = triangular.filter(v => answer < v);
            param[`tech_countg_${suffix}`] = greater.length;
            param[`tech_endg_${suffix}`] = greater[greater.length - 1];
            param[`tech_fl_${suffix}`] = less[0];
            param[`tech_countg_${suffix}1`] = greater.length + 1;
          }
        };

        processTriangular(answer_eo, eo, 'eo');
        processTriangular(answer_fr, fr, 'fr');
        processTriangular(answer_ro, ro, 'ro');
        processTriangular(answer_rfd, rfd, 'rfd');
        processTriangular(answer_jg, jg, 'jg');
        processTriangular(answer_eg, eg, 'eg');
        processTriangular(answer_h, h, 'h');

        // Digit sum
        const dosra_eo = answer_eo.toString().split('').map(Number).reduce((a, b) => a + b, 0);
        const dosra_fr = answer_fr.toString().split('').map(Number).reduce((a, b) => a + b, 0);
        const dosra_ro = answer_ro.toString().split('').map(Number).reduce((a, b) => a + b, 0);
        const dosra_rfd = answer_rfd.toString().split('').map(Number).reduce((a, b) => a + b, 0);
        const dosra_jg = answer_jg.toString().split('').map(Number).reduce((a, b) => a + b, 0);
        const dosra_eg = answer_eg.toString().split('').map(Number).reduce((a, b) => a + b, 0);
        const dosra_h = answer_h.toString().split('').map(Number).reduce((a, b) => a + b, 0);

        // Triangular relation
        const trelation_eo = triangular[answer_eo - 1] || 0;
        const trelation_fr = triangular[answer_fr - 1] || 0;
        const trelation_ro = triangular[answer_ro - 1] || 0;
        const trelation_rfd = triangular[answer_rfd - 1] || 0;
        const trelation_jg = triangular[answer_jg - 1] || 0;
        const trelation_eg = triangular[answer_eg - 1] || 0;
        const trelation_h = triangular[answer_h - 1] || 0;

        // Prime relation
        const prelation_eo = prime_nums[answer_eo - 1] || 0;
        const prelation_fr = prime_nums[answer_fr - 1] || 0;
        const prelation_ro = prime_nums[answer_ro - 1] || 0;
        const prelation_rfd = prime_nums[answer_rfd - 1] || 0;
        const prelation_jg = prime_nums[answer_jg - 1] || 0;
        const prelation_eg = prime_nums[answer_eg - 1] || 0;
        const prelation_h = prime_nums[answer_h - 1] || 0;

        // Fibonacci check
        const eo_fib = arr.indexOf(answer_eo);
        const fr_fib = arr.indexOf(answer_fr);
        const ro_fib = arr.indexOf(answer_ro);
        const rfd_fib = arr.indexOf(answer_rfd);
        const jg_fib = arr.indexOf(answer_jg);
        const eg_fib = arr.indexOf(answer_eg);
        const h_fib = arr.indexOf(answer_h);

        // Process Fibonacci results for each system
        const processFibonacci = (answer, index, suffix) => {
          if (index != -1) {
            param[`tech_findex_${suffix}`] = index + 2;
          } else {
            const fgreater = arr.filter(v => answer > v);
            const fless = arr.filter(v => answer < v);
            param[`tech_fcountg_${suffix}`] = fgreater.length;
            param[`tech_fendg_${suffix}`] = fgreater[fgreater.length - 1];
            param[`tech_ffl_${suffix}`] = fless[0];
            param[`tech_fcountg_${suffix}1`] = fgreater.length + 1;
          }
        };

        processFibonacci(answer_eo, eo_fib, 'eo');
        processFibonacci(answer_fr, fr_fib, 'fr');
        processFibonacci(answer_ro, ro_fib, 'ro');
        processFibonacci(answer_rfd, rfd_fib, 'rfd');
        processFibonacci(answer_jg, jg_fib, 'jg');
        processFibonacci(answer_eg, eg_fib, 'eg');
        processFibonacci(answer_h, h_fib, 'h');

        // Assign all results to param
        Object.assign(param, {
         tech_inner_alpha: inner_alpha,
          tech_inner_ans_eo: inner_ans_eo,
          tech_inner_ans_fr: inner_ans_fr,
          tech_inner_ans_ro: inner_ans_ro,
          tech_inner_ans_rfd: inner_ans_rfd,
          tech_inner_ans_jg: inner_ans_jg,
          tech_inner_ans_eg: inner_ans_eg,
          tech_inner_ans_h: inner_ans_h,
          tech_inner_sum_eo: inner_sum_eo,
          tech_inner_sum_fr: inner_sum_fr,
          tech_inner_sum_ro: inner_sum_ro,
          tech_inner_sum_rfd: inner_sum_rfd,
          tech_inner_sum_jg: inner_sum_jg,
          tech_inner_sum_eg: inner_sum_eg,
          tech_inner_sum_h: inner_sum_h,
          tech_answer_eo: answer_eo,
          tech_answer_fr: answer_fr,
          tech_answer_ro: answer_ro,
          tech_answer_rfd: answer_rfd,
          tech_answer_jg: answer_jg,
          tech_answer_eg: answer_eg,
          tech_answer_h: answer_h,
          tech_count_ans: count_ans,
          tech_words_ans: words_ans,
          tech_input: input,
          tech_final_ans: final_ans,
          tech_final_ans2: final_ans2,
          tech_final_ans3: final_ans3,
          tech_final_ans4: final_ans4,
          tech_final_ans5: final_ans5,
          tech_final_ans6: final_ans6,
          tech_final_ans7: final_ans7,
          tech_eo_divi: eo_divi,
          tech_count_eodivi: count_eodivi,
          tech_eodivi_sum: eodivi_sum,
          tech_fr_divi: fr_divi,
          tech_count_frdivi: count_frdivi,
          tech_frdivi_sum: frdivi_sum,
          tech_ro_divi: ro_divi,
          tech_count_rodivi: count_rodivi,
          tech_rodivi_sum: rodivi_sum,
          tech_rfd_divi: rfd_divi,
          tech_count_rfddivi: count_rfddivi,
          tech_rfddivi_sum: rfddivi_sum,
          tech_jg_divi: jg_divi,
          tech_count_jgdivi: count_jgdivi,
          tech_jgdivi_sum: jgdivi_sum,
          tech_eg_divi: eg_divi,
          tech_count_egdivi: count_egdivi,
          tech_egdivi_sum: egdivi_sum,
          tech_h_divi: h_divi,
          tech_count_hdivi: count_hdivi,
          tech_hdivi_sum: hdivi_sum,
          tech_newtext_eo: newtext_eo,
          tech_newtext_fr: newtext_fr,
          tech_newtext_ro: newtext_ro,
          tech_newtext_rfd: newtext_rfd,
          tech_newtext_jg: newtext_jg,
          tech_newtext_eg: newtext_eg,
          tech_newtext_h: newtext_h,
          tech_apeo_p: apeo_p,
          tech_apeo_n: apeo_n,
          tech_apfr_p: apfr_p,
          tech_apfr_n: apfr_n,
          tech_apro_p: apro_p,
          tech_apro_n: apro_n,
          tech_aprfd_p: aprfd_p,
          tech_aprfd_n: aprfd_n,
          tech_apjg_p: apjg_p,
          tech_apjg_n: apjg_n,
          tech_apeg_p: apeg_p,
          tech_apeg_n: apeg_n,
          tech_aph_p: aph_p,
          tech_aph_n: aph_n,
          tech_previous_eo: previous_eo,
          tech_next_eo: next_eo,
          tech_previous_fr: previous_fr,
          tech_next_fr: next_fr,
          tech_previous_ro: previous_ro,
          tech_next_ro: next_ro,
          tech_previous_rfd: previous_rfd,
          tech_next_rfd: next_rfd,
          tech_previous_jg: previous_jg,
          tech_next_jg: next_jg,
          tech_previous_eg: previous_eg,
          tech_next_eg: next_eg,
          tech_previous_h: previous_h,
          tech_next_h: next_h,
          tech_check_eo: check_eo,
          tech_check_fr: check_fr,
          tech_check_ro: check_ro,
          tech_check_rfd: check_rfd,
          tech_check_jg: check_jg,
          tech_check_eg: check_eg,
          tech_check_h: check_h,
          tech_eo: eo,
          tech_fr: fr,
          tech_ro: ro,
          tech_rfd: rfd,
          tech_jg: jg,
          tech_eg: eg,
          tech_h: h,
          tech_dosra_eo: dosra_eo,
          tech_dosra_fr: dosra_fr,
          tech_dosra_ro: dosra_ro,
          tech_dosra_rfd: dosra_rfd,
          tech_dosra_jg: dosra_jg,
          tech_dosra_eg: dosra_eg,
          tech_dosra_h: dosra_h,
          tech_trelation_eo: trelation_eo,
          tech_trelation_fr: trelation_fr,
          tech_trelation_ro: trelation_ro,
          tech_trelation_rfd: trelation_rfd,
          tech_trelation_jg: trelation_jg,
          tech_trelation_eg: trelation_eg,
          tech_trelation_h: trelation_h,
          tech_prelation_eo: prelation_eo,
          tech_prelation_fr: prelation_fr,
          tech_prelation_ro: prelation_ro,
          tech_prelation_rfd: prelation_rfd,
          tech_prelation_jg: prelation_jg,
          tech_prelation_eg: prelation_eg,
          tech_prelation_h: prelation_h,
          tech_eo_fib: eo_fib,
          tech_fr_fib: fr_fib,
          tech_ro_fib: ro_fib,
          tech_rfd_fib: rfd_fib,
          tech_jg_fib: jg_fib,
          tech_eg_fib: eg_fib,
          tech_h_fib: h_fib

        });

        return param;
      }

          /**
    * getCalculationBaseCalculator: Service Method
    * POST: /api/calculators-lol/base-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */
      async getCalculationBaseCalculator(body) {
      const bnr_frs = body.tech_bnr_frs;
      const bnr_sec = body.tech_bnr_sec;
      const select_base = body.tech_select_base;
      const tool = body.tech_tool;
      const bnr_slc = body.tech_bnr_slc;
      const to_number = body.tech_to_number;
      const bnr_third = body.tech_bnr_third;
      const param = {};

      // Helper function to convert from any base to decimal (base 10)
      function bnrType(nn, bnr_tpe) {
        return parseInt(nn, bnr_tpe);
      }

      // Helper function to convert decimal to any base
      function toBase(num, base) {
        return Math.abs(num).toString(base);
      }

      // Binary calculation function
      function bnrCal(fN, sN, bnr_slc, select_base) {
        let rN, dc, bn;

        if (bnr_slc == "add") {
          rN = fN + sN;
          dc = rN;
          bn = toBase(dc, select_base);
          return [bn, dc];
        } else if (bnr_slc == "sub") {
          rN = fN - sN;
          dc = rN;
          if (dc < 0) {
            bn = "-" + toBase(dc, select_base);
          } else {
            bn = toBase(dc, select_base);
          }
          return [bn, dc];
        } else if (bnr_slc == "mult") {
          rN = fN * sN;
          dc = rN;
          bn = toBase(dc, select_base);
          return [bn, dc];
        } else if (bnr_slc == "divd") {
          if (fN == 0 || sN == 0) {
            return { error: 'Please! Check your input' };
          }
          rN = fN / sN;
          dc = Math.round(rN);
          bn = toBase(dc, select_base);
          return [bn, dc];
        }
        
        return ['invalid', null];
      }

      if (tool == "calculator") {
        if (bnr_frs != "" && bnr_frs !== undefined && bnr_sec != "" && bnr_sec != undefined) {
          const fN = bnrType(bnr_frs, select_base);
          const sN = bnrType(bnr_sec, select_base);

          // Set presentation text
          if (bnr_slc == "add") {
            param.tech_pres = "addition";
          } else if (bnr_slc == "sub") {
            param.tech_pres = "subtraction";
          } else if (bnr_slc == "mult") {
            param.tech_pres = "multiplication";
          } else if (bnr_slc == "divd") {
            param.tech_pres = "division";
          }

          // Perform calculation
          const result = bnrCal(fN, sN, bnr_slc, select_base);
          
          if (Array.isArray(result) && result[0] !== undefined) {
            param.tech_bn = result[0];
          } else if (result && result.error) {
            param.error = result.error;
            return param;
          } else {
            param.tech_bn = 'error';
          }

          param.tech_bnr_frs = bnr_frs;
          param.tech_bnr_sec = bnr_sec;
          param.tech_bnr_slc = bnr_slc;
          param.tech_bnr_tpe = select_base;
          return param;
        } else {
          param.error = 'Please! Check your input';
          return param;
        }
      } else if (tool == "converter") {
        // Base converter
        const binary = parseInt(bnr_third, select_base).toString(to_number);
        
        param.tech_bi = binary;
        param.tech_from_base = select_base;
        param.tech_to_base = to_number;
        param.tech_resulting_number = bnr_third;
        
        return param;
      }

      param.error = 'Invalid tool selection';
      return param;
    }

       /**
    * getCalculationRatioToFractionCalculator: Service Method
    * POST: /api/calculators-lol/base-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */
    async getCalculationRatioToFractionCalculator(body) {
      const select_unit = body.tech_select_unit;
      const first_number = body.tech_first_number;
      const second_number = body.tech_second_number;
      const convert = body.tech_convert;
      const param = {};

      // Helper function to calculate GCD (Greatest Common Divisor)
      function gcd(a, b) {
        a = Math.abs(a);
        b = Math.abs(b);

        if (a < b) {
          [a, b] = [b, a];
        }

        if (b == 0) {
          return 1;
        }

        let r = a % b;
        while (r > 0) {
          a = b;
          b = r;
          r = a % b;
        }
        return b;
      }

      // Helper function to reduce fraction
      function reduce(num, den) {
        const g = gcd(num, den);
        return [num / g, den / g];
      }

      // Validate if input is numeric
      function isNumeric(value) {
        return !isNaN(parseFloat(value)) && isFinite(value);
      }

      if (convert == "1") { // Convert Ratio to Fraction
        if (select_unit == "1") {
          if (isNumeric(first_number) && isNumeric(second_number)) {
            const fn = parseFloat(first_number);
            const sn = parseFloat(second_number);

            if (fn >= 0 && sn >= 0) {
              if (fn == 0 && sn == 0) {
                param.error = 'There must be at least one part, A or B, greater than 0.';
                return param;
              } else {
                const addition = fn + sn;
                const totalN = fn;
                const totalD = addition;

                const [upr1, btm1] = reduce(totalN, totalD);

                const totalN1 = sn;
                const totalD1 = addition;

                const [upr2, btm2] = reduce(totalN1, totalD1);

                const method = 1;
                param.tech_upr1 = upr1;
                param.tech_btm1 = btm1;
                param.tech_upr2 = upr2;
                param.tech_btm2 = btm2;
                param.tech_addition = addition;
                param.tech_first_number = first_number;
                param.tech_second_number = second_number;
                param.tech_method = method;
              }
            } else {
              param.error = 'Enter 0 or a whole number';
              return param;
            }
          } else {
            param.error = 'Please Check Your Input!';
            return param;
          }
        } else if (select_unit == "2") {
          if (isNumeric(first_number) && isNumeric(second_number)) {
            const fn = parseFloat(first_number);
            const sn = parseFloat(second_number);

            if (fn >= 0 && sn >= 0) {
              if (fn == 0 && sn == 0) {
                param.error = 'Enter 0 or a whole number';
                return param;
              } else {
                if (fn <= sn) { // Part is less than whole
                  const totalN1 = fn;
                  const totalD1 = sn;

                  const [upr2, btm2] = reduce(totalN1, totalD1);

                  const method2 = 2;
                  param.tech_first_number = first_number;
                  param.tech_second_number = second_number;
                  param.tech_upr2 = upr2;
                  param.tech_btm2 = btm2;
                  param.tech_method = method2;
                } else {
                  param.error = 'The Part must be less than or equal to the Whole.';
                  return param;
                }
              }
            } else {
              param.error = 'There must be at least one part, A or B, greater than 0.';
              return param;
            }
          } else {
            param.error = 'Please Check Your Input!';
            return param;
          }
        }
      } else if (convert == "2") { // Convert Fraction to Ratio
        if (select_unit == "1") {
          if (isNumeric(first_number) && isNumeric(second_number)) {
            const fn = parseFloat(first_number);
            const sn = parseFloat(second_number);

            if (fn >= 0 && sn >= 0) {
              if (fn == 0 && sn == 0) {
                param.error = 'There must be at least one part, A or B, greater than 0.';
                return param;
              } else {
                const totalN = fn;
                const totalD = sn;

                const [upr1, btm1] = reduce(totalN, totalD);

                const method = 3;
                param.tech_upr1 = upr1;
                param.tech_upr2 = btm1;
                param.tech_first_number = first_number;
                param.tech_second_number = second_number;
                param.tech_method = method;
              }
            } else {
              param.error = 'Enter 0 or a whole number';
              return param;
            }
          } else {
            param.error = 'Please Check Your Input!';
            return param;
          }
        } else if (select_unit == "2") {
          if (isNumeric(first_number) && isNumeric(second_number)) {
            const fn = parseFloat(first_number);
            const sn = parseFloat(second_number);

            if (fn >= 0 && sn >= 0) {
              if (fn == 0 && sn == 0) {
                param.error = 'There must be at least one part, A or B, greater than 0.';
                return param;
              } else {
                if (fn <= sn) {
                  const subtraction = sn - fn;
                  const totalN = fn;
                  const totalD = subtraction;

                  const [upr1, btm1] = reduce(totalN, totalD);

                  const totalN1 = sn;
                  const totalD1 = subtraction;

                  const [upr2, btm2] = reduce(totalN1, totalD1);

                  const method = 4;
                  param.tech_upr1 = upr1;
                  param.tech_btm1 = btm1;
                  param.tech_upr2 = upr2;
                  param.tech_btm2 = btm2;
                  param.tech_subtraction = subtraction;
                  param.tech_first_number = first_number;
                  param.tech_second_number = second_number;
                  param.tech_method = method;
                } else {
                  param.error = 'The Part must be less than or equal to the Whole.';
                  return param;
                }
              }
            } else {
              param.error = 'There must be at least one part, A or B, greater than 0.';
              return param;
            }
          } else {
            param.error = 'Please Check Your Input!';
            return param;
          }
        }
      }

      return param;
    }

      /**
    * getCalculationGramSchmidtCalculator: Service Method
    * POST: /api/calculators-lol/gram-schmidt-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */
      async getCalculationGramSchmidtCalculator(body) {
      const matrix2 = parseInt(body.tech_matrix2);
      const matrix22 = parseInt(body.tech_matrix22);
      const second_matrix = [];

      // Extract matrix data
      for (let i = 1; i <= matrix2; i++) {
          for (let j = 1; j <= matrix22; j++) {
              const key = `tech_matrix3${i}_${j}`;
              if (body[key] != undefined && !isNaN(parseFloat(body[key]))) {
                  second_matrix.push(parseFloat(body[key]));
              }
          }
      }

      // Helper functions
      const new_roundNumb = (a) => {
          return Math.round(a * 100) / 100;
      };

      const normalizeVector = (coordinates, vector) => {
          let divisor = 0;
          for (let i = 0; i < coordinates; i++) {
              divisor = divisor + Math.pow(vector[i], 2);
          }
          divisor = Math.sqrt(divisor);
          if (divisor !== 0) {
              for (let i = 0; i < coordinates; i++) {
                  vector[i] = new_roundNumb(vector[i] / divisor);
              }
          }
          return vector;
      };

      const subtractPrevious = (coordinates, vector1, vector2) => {
          let divisor1 = 0;
          let divisor2 = 0;
          let dotProduct = 0;
          for (let i = 0; i < coordinates; i++) {
              divisor1 += vector1[i] * vector1[i];
              divisor2 += vector2[i] * vector2[i];
              dotProduct += vector1[i] * vector2[i];
          }
          if (divisor1 !== 0 && divisor2 !== 0) {
              for (let i = 0; i < coordinates; i++) {
                  vector1[i] = new_roundNumb(vector1[i] - dotProduct * vector2[i] / divisor2);
              }
          }
          return vector1;
      };

      // Main logic
      const mul = matrix22 * matrix2;
      let result = {};

      if (mul === second_matrix.length) {
          // Convert flat array to 2D matrix
          const zain = [];
          for (let i = 0; i < matrix2; i++) {
              const row = second_matrix.slice(i * matrix22, (i + 1) * matrix22);
              zain.push(row);
          }

          // Get column vectors
          const all_vec = [];
          for (let i = 0; i < matrix22; i++) {
              const column = [];
              for (let j = 0; j < matrix2; j++) {
                  column.push(zain[j][i]);
              }
              all_vec.push(column);
          }

          const first_unit = normalizeVector(matrix2, [...all_vec[0]]);
          const fahad = Math.max(matrix22, matrix2);
          const f_vec = [...all_vec[0]];
          
          // Calculate projections for all vectors
          const total = [];
          const vector_unit = [];

          for (let i = 1; i < fahad; i++) {
              if (all_vec[i]) {
                  const s_vec = all_vec[i];
                  const temp = [];
                  for (let key = 0; key < f_vec.length; key++) {
                      temp.push(f_vec[key] * s_vec[key]);
                  }
                  total[i] = temp;
                  vector_unit.push(temp.reduce((sum, val) => sum + val, 0));
              }
          }

          // Calculate vector magnitude
          const itself_mul = [];
          for (const value of f_vec) {
              itself_mul.push(Math.pow(value, 2));
          }
          const vector_u = itself_mul.reduce((sum, val) => sum + val, 0);

          // Calculate combined vectors
          const combined_vector = [];
          for (const value7 of vector_unit) {
              combined_vector.push(value7 / vector_u);
          }

          // Calculate projection answers
          const ans_pro = [];
          for (let l = 0; l < f_vec.length; l++) {
              const temp = [];
              for (const values of combined_vector) {
                  temp.push(values * f_vec[l]);
              }
              ans_pro.push(temp);
          }

          // Transpose ans_pro to get column vectors
          const pros_ans = [];
          for (let m = 0; m < matrix22 - 1; m++) {
              const column = [];
              for (let n = 0; n < ans_pro.length; n++) {
                  if (ans_pro[n][m] !== undefined) {
                      column.push(ans_pro[n][m]);
                  }
              }
              pros_ans.push(column);
          }

          // Remove first element from zaini
          const zaini = [...all_vec];
          zaini.shift();

          // Calculate subtracted vectors
          const subtract = [];
          for (let main = 0; main < pros_ans.length; main++) {
              if (zaini[main]) {
                  subtract.push(subtractPrevious(matrix2, [...zaini[main]], [...pros_ans[main]]));
              }
          }

          // Calculate unit vectors
          const all_vecunit = [];
          for (const value of subtract) {
              all_vecunit.push(normalizeVector(matrix2, [...value]));
          }

          // Set result values - match Laravel structure exactly
          result.tech_all_vec = all_vec;
          result.tech_first_unit = first_unit;
          result.tech_all_vecunit = all_vecunit;
          result.tech_pros_ans = pros_ans;
          result.tech_subtract = subtract;

      } else {
          result.error = 'Please! Check Your Input.';
      }

      return result;
  }

      /**
    * getCalculationVolumeOfTriangularPyramidCalculator: Service Method
    * POST: /api/calculators-lol/volume-of-triangular-pyramid
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */
    async getCalculationVolumeOfTriangularPyramidCalculator(body) {
    const selection = body.tech_selection;
    const triangle_type = body.tech_triangle_type;
    const base = body.tech_base;
    const base_unit = body.tech_base_unit;
    const base_height = body.tech_base_height;
    const base_height_unit = body.tech_base_height_unit;
    const pyramid_height = body.tech_pyramid_height;
    const pyramid_height_unit = body.tech_pyramid_height_unit;
    const pyramid_base_area = body.tech_pyramid_base_area;
    const pyramid_base_area_unit = body.tech_pyramid_base_area_unit;
    const sidea = body.tech_sidea;
    const sidea_length_unit = body.tech_sidea_length_unit;
    const sideb = body.tech_sideb;
    const sideb_length_unit = body.tech_sideb_length_unit;
    const sidec = body.tech_sidec;
    const sidec_length_unit = body.tech_sidec_length_unit;
    const angle_gamma = body.tech_angle_gamma;
    const angle_gamma_unit = body.tech_angle_gamma_unit;
    const angle_beta = body.tech_angle_beta;
    const angle_beta_unit = body.tech_angle_beta_unit;
    
    const param = {};

    // Helper function to convert length units to cm
    function unit_convert(unit, value) {
      const conversions = {
        'mm': 0.1,
        'cm': 1,
        'm': 100,
        'km': 100000,
        'in': 2.54,
        'ft': 30.48,
        'yd': 91.44,
        'mi': 160934
      };
      return value * (conversions[unit] || 1);
    }

    // Helper function to convert angle units to radians
    function angle_convert(unit2, value2) {
      if (unit2 == "deg") {
        return value2 * 0.017453;
      } else if (unit2 == "rad") {
        return value2 * 1;
      }
      return value2;
    }

    // Helper function to convert area units to cm²
    function centi(unit3, value3) {
      const conversions = {
        'mm²': 0.01,
        'cm²': 1,
        'm²': 10000,
        'km²': 10000000000,
        'in²': 6.452,
        'ft²': 929,
        'yd²': 8361,
        'mi²': 25899881103
      };
      return value3 * (conversions[unit3] || 1);
    }

    // Validate if input is numeric
    function isNumeric(value) {
      return !isNaN(parseFloat(value)) && isFinite(value);
    }

    let pba, volume;

    if (selection == "1") {
      // Calculate using triangle dimensions
      if (triangle_type == "1") {
        // Right Triangle: base, height, pyramid height
        if (isNumeric(base) && isNumeric(base_height) && isNumeric(pyramid_height)) {
          const b_value = unit_convert(base_unit, parseFloat(base));
          const bh_value = unit_convert(base_height_unit, parseFloat(base_height));
          const ph_value = unit_convert(pyramid_height_unit, parseFloat(pyramid_height));
          pba = (b_value * bh_value) / 2;
          volume = (pba * ph_value) / 3;
        } else {
          param.error = 'Please! Check your input';
          return param;
        }
      } else if (triangle_type == "2") {
        // Three sides (Heron's formula)
        if (isNumeric(sidea) && isNumeric(sideb) && isNumeric(sidec) && isNumeric(pyramid_height)) {
          const sa = parseFloat(sidea);
          const sb = parseFloat(sideb);
          const sc = parseFloat(sidec);

          // Validate triangle inequality
          if (sa > sb + sc) {
            param.error = 'Side a must be less than the sum of the other two sides (b+c)';
            return param;
          } else if (sb > sa + sc) {
            param.error = 'Side b must be less than the sum of the other two sides (a+c)';
            return param;
          } else if (sc > sa + sb) {
            param.error = 'Side c must be less than the sum of the other two sides (a+b)';
            return param;
          } else {
            const sa_value = unit_convert(sidea_length_unit, sa);
            const sb_value = unit_convert(sideb_length_unit, sb);
            const sc_value = unit_convert(sidec_length_unit, sc);
            const ph_value = unit_convert(pyramid_height_unit, parseFloat(pyramid_height));
            
            const sect_one = (sa_value + sb_value + sc_value);
            const sect_two = (-sa_value + sb_value + sc_value);
            const sect_three = (sa_value - sb_value + sc_value);
            const sect_four = (sa_value + sb_value - sc_value);
            
            pba = 0.25 * Math.sqrt(sect_one * sect_two * sect_three * sect_four);
            volume = (pba * ph_value) / 3;
          }
        } else {
          param.error = 'Please! Check your input';
          return param;
        }
      } else if (triangle_type == "3") {
        // Two sides and included angle
        if (isNumeric(sidea) && isNumeric(sideb) && isNumeric(angle_gamma) && isNumeric(pyramid_height)) {
          const sa_value = unit_convert(sidea_length_unit, parseFloat(sidea));
          const sb_value = unit_convert(sideb_length_unit, parseFloat(sideb));
          const alpha_value = angle_convert(angle_gamma_unit, parseFloat(angle_gamma));

          if (angle_gamma_unit == "deg") {
            if (parseFloat(angle_gamma) < 180) {
              const ph_value = unit_convert(pyramid_height_unit, parseFloat(pyramid_height));
              pba = (sa_value * sb_value * Math.sin(alpha_value)) * 0.5;
              volume = (pba * ph_value) / 3;
            } else {
              param.error = 'Angles should be between 0 and 180 deg';
              return param;
            }
          } else if (angle_gamma_unit == "rad") {
            if (alpha_value < 3.14159) {
              const ph_value = unit_convert(pyramid_height_unit, parseFloat(pyramid_height));
              pba = (sa_value * sb_value * Math.sin(alpha_value)) * 0.5;
              volume = (pba * ph_value) / 3;
            } else {
              param.error = 'Angles should be between 0 and 180 deg';
              return param;
            }
          }
        } else {
          param.error = 'Please! Check your input';
          return param;
        }
      } else if (triangle_type == "4") {
        // One side and two angles
        if (isNumeric(sidea) && isNumeric(angle_beta) && isNumeric(angle_gamma) && isNumeric(pyramid_height)) {
          const sa_value = unit_convert(sidea_length_unit, parseFloat(sidea));
          
          let alpha_value, beta_value;

          // Convert gamma angle
          if (angle_gamma_unit == "rad") {
            alpha_value = parseFloat(angle_gamma);
          } else if (angle_gamma_unit == "deg") {
            alpha_value = parseFloat(angle_gamma) * 0.017453;
          }

          // Convert beta angle
          if (angle_beta_unit == "rad") {
            beta_value = parseFloat(angle_beta);
          } else if (angle_beta_unit == "deg") {
            beta_value = parseFloat(angle_beta) * 0.017453;
          }

          // Convert to degrees for validation
          // const alpha_deg = angle_gamma_unit == "deg" ? parseFloat(angle_gamma) : parseFloat(angle_gamma) * 57.2958;
          // const beta_deg = angle_beta_unit == "deg" ? parseFloat(angle_beta) : parseFloat(angle_beta) * 57.2958;
          	// dd($alpha_value,$angle_gamma,$ang);
          // console.log(alpha_deg,beta_deg);
          if (alpha_value < 180 && beta_value < 180) {
            if (alpha_value + beta_value < 180) {
              const ph_value = unit_convert(pyramid_height_unit, parseFloat(pyramid_height));
              const sect1 = sa_value * sa_value * Math.sin(beta_value) * Math.sin(alpha_value);
              const sect2 = 2 * Math.sin(alpha_value + beta_value);
              pba = sect1 / sect2;
              volume = (pba * ph_value) / 3;
            } else {
              param.error = 'The sum of the two angles cannot exceed 180 deg.';
              return param;
            }
          } else {
            param.error = 'Angles should be between 0 and 180 deg range';
            return param;
          }
        } else {
          param.error = 'Please! Check your input';
          return param;
        }
      }

      param.tech_pba = pba;
      param.tech_volume = volume;
    } else if (selection == "2") {
      // Calculate using base area directly
      if (isNumeric(pyramid_base_area) && isNumeric(pyramid_height)) {
        const pb_value = centi(pyramid_base_area_unit, parseFloat(pyramid_base_area));
        const ph_value = unit_convert(pyramid_height_unit, parseFloat(pyramid_height));
        volume = (pb_value * ph_value) / 3;
        param.tech_volume = volume;
      } else {
        param.error = 'Please! Check your input';
        return param;
      }
    }

    return param;
  }


     /**
    * getCalculationAreaCalculator: Service Method
    * POST: /api/calculators-lol/area-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */
   async getCalculationAreaCalculator(body) {
        const shapes = body.tech_shapes;
        const radius = body.tech_radius;
        const radius_unit = body.tech_radius_unit;
        const area = body.tech_area;
        const area_unit = body.tech_area_unit;
        const box = body.tech_box;
        const box_unit = body.tech_box_unit;
        const angle_alpha = body.tech_angle_alpha;
        const angle_alpha_unit = body.tech_angle_alpha_unit;
        const height = body.tech_height;
        const height_unit = body.tech_height_unit;
        const bara_radius = body.tech_bara_radius;
        const bara_radius_unit = body.tech_bara_radius_unit;
        const e = body.tech_e;
        const e_unit = body.tech_e_unit;
        const f = body.tech_f;
        const f_unit = body.tech_f_unit;
        const number_of_sides = body.tech_number_of_sides;
        const find_triangle = body.tech_find_triangle;
        const find_triangle_two = body.tech_find_triangle_two;
        const find_triangle_three = body.tech_find_triangle_three;
        const find_triangle_four = body.tech_find_triangle_four;
        const c = body.tech_c;
        const c_unit = body.tech_c_unit;
        const angle_gamma = body.tech_angle_gamma;
        const angle_gamma_unit = body.tech_angle_gamma_unit;
        const angle_beta = body.tech_angle_beta;
        const angle_beta_unit = body.tech_angle_beta_unit;
        const angle_theta = body.tech_angle_theta;
        const angle_theta_unit = body.tech_angle_theta_unit;

        const param = {};

        // Helper function to convert length units to cm
        function unit_convert(unit, value) {
          const conversions = {
            'mm': 0.1,
            'cm': 1,
            'm': 100,
            'km': 100000,
            'in': 2.54,
            'ft': 30.48,
            'yd': 91.44,
            'mi': 160934
          };
          return value * (conversions[unit] || 1);
        }

        // Helper function to convert angle units to radians
        function angle_convert(unit2, value2) {
          if (unit2 == "deg") {
            return value2 * 0.017453;
          } else if (unit2 == "rad") {
            return value2 * 1;
          }
          return value2;
        }

        // Helper function to convert area units to cm²
        function centi(unit3, value3) {
          const conversions = {
            'mm²': 0.01,
            'cm²': 1,
            'm²': 10000,
            'km²': 10000000000,
            'in²': 6.452,
            'ft²': 929,
            'yd²': 8361,
            'mi²': 25899881103
          };
          return value3 * (conversions[unit3] || 1);
        }

        // Validate if input is numeric
        function isNumeric(value) {
          return !isNaN(parseFloat(value)) && isFinite(value);
        }

        let answer, method;

        if (shapes == "square") {
          method = 1;
          if (isNumeric(area)) {
            const area_value = unit_convert(area_unit, parseFloat(area));
            answer = area_value * area_value;
          param.tech_area = isNaN(area) ? "NaN" : area;
          } else {
            param.error = 'Please! Check your input';
            return param;
          }
        } else if (shapes == "rectangle") {
          method = 2;
          if (isNumeric(area) && isNumeric(box)) {
            const area_value = unit_convert(area_unit, parseFloat(area));
            const box_value = unit_convert(box_unit, parseFloat(box));
             param.tech_area = isNaN(area_value) ? "NaN" : area_value;
            param.tech_box = isNaN(box_value) ? "NaN" : box_value;
            answer = area_value * box_value;
          } else {
            param.error = 'Please! Check your input';
            return param;
          }
        } else if (shapes == "triangle") {
          if (find_triangle == "1") {
            method = 31;
            if (isNumeric(box) && isNumeric(height)) {
              const box_value = unit_convert(box_unit, parseFloat(box));
              const height_value = unit_convert(height_unit, parseFloat(height));
             param.tech_height = isNaN(height_value) ? "NaN" : height_value;
             param.tech_box = isNaN(box_value) ? "NaN" : box_value;
              answer = box_value * height_value / 2;
            } else {
              param.error = 'Please! Check your input';
              return param;
            }
          } else if (find_triangle == "2") {
            method = 32;
            if (isNumeric(box) && isNumeric(area) && isNumeric(c)) {
              const box_value = unit_convert(box_unit, parseFloat(box));
              const area_value = unit_convert(area_unit, parseFloat(area));
              const c_value = unit_convert(c_unit, parseFloat(c));
              const sect_one = (area_value + box_value + c_value);
              const sect_two = (-area_value + box_value + c_value);
              const sect_three = (area_value - box_value + c_value);
              const sect_four = (area_value + box_value - c_value);
              answer = 0.25 * Math.sqrt(sect_one * sect_two * sect_three * sect_four);
              param.tech_area = isNaN(area_value) ? "NaN" : area_value;
              param.tech_box  = isNaN(box_value)  ? "NaN" : box_value;
              param.tech_c    = isNaN(c_value)    ? "NaN" : c_value;

            } else {
              param.error = 'Please! Check your input';
              return param;
            }
          } else if (find_triangle == "3") {
            method = 33;
            if (isNumeric(area) && isNumeric(box) && isNumeric(angle_gamma)) {
              const box_value = unit_convert(box_unit, parseFloat(box));
              const area_value = unit_convert(area_unit, parseFloat(area));
              const gamma_value = angle_convert(angle_gamma_unit, parseFloat(angle_gamma));
              answer = area_value * box_value * Math.sin(gamma_value) * 0.5;
              param.tech_area  = isNaN(area_value)  ? "NaN" : area_value;
              param.tech_box   = isNaN(box_value)   ? "NaN" : box_value;
              param.tech_gamma = isNaN(gamma_value) ? "NaN" : gamma_value;
            } else {
              param.error = 'Please! Check your input';
              return param;
            }
          } else if (find_triangle == "4") {
            method = 34;
            if (isNumeric(area) && isNumeric(angle_beta) && isNumeric(angle_gamma)) {
              const area_value = unit_convert(area_unit, parseFloat(area));
              const gamma_value = angle_convert(angle_gamma_unit, parseFloat(angle_gamma));
              const beta_value = angle_convert(angle_beta_unit, parseFloat(angle_beta));
              
              const gamma_deg = angle_gamma_unit == "deg" ? parseFloat(angle_gamma) : parseFloat(angle_gamma) * 57.2958;
              const beta_deg = angle_beta_unit == "deg" ? parseFloat(angle_beta) : parseFloat(angle_beta) * 57.2958;
              
              if (gamma_deg < 180 && beta_deg < 180) {
                if (gamma_deg + beta_deg < 180) {
                  const sect1 = area_value * area_value * Math.sin(beta_value) * Math.sin(gamma_value);
                  const sect2 = 2 * Math.sin(gamma_value + beta_value);
                  answer = sect1 / sect2;
                } else {
                  param.error = 'The sum of the two angles cannot exceed 180 deg.';
                  return param;
                }
              } else {
                param.error = 'Angles should be between 0 and 180 deg range';
                return param;
              }
            param.tech_area  = isNaN(area_value)  ? "NaN" : area_value;
            param.tech_beta  = isNaN(beta_value)  ? "NaN" : beta_value;
            param.tech_gamma = isNaN(gamma_value) ? "NaN" : gamma_value;

            } else {
              param.error = 'Please! Check your input';
              return param;
            }
          }
        } else if (shapes === "parallelogram") {
          if (find_triangle_two == "1") {
            method = 15;
            if (isNumeric(box) && isNumeric(height)) {
              const box_value = unit_convert(box_unit, parseFloat(box));
              const height_value = unit_convert(height_unit, parseFloat(height));
            param.tech_height = isNaN(height_value) ? "NaN" : height_value;
            param.tech_box    = isNaN(box_value) ? "NaN" : box_value;

              answer = box_value * height_value;
            } else {
              param.error = 'Please! Check your input';
              return param;
            }
          } else if (find_triangle_two == "2") {
            method = 16;
            if (isNumeric(area) && isNumeric(box) && isNumeric(angle_alpha)) {
              const area_value = unit_convert(area_unit, parseFloat(area));
              const box_value = unit_convert(box_unit, parseFloat(box));
              const alpha_value = angle_convert(angle_alpha_unit, parseFloat(angle_alpha));
              param.tech_area  = isNaN(area_value)  ? "NaN" : area_value;
              param.tech_box   = isNaN(box_value)   ? "NaN" : box_value;
              param.tech_alpha = isNaN(alpha_value) ? "NaN" : alpha_value;
              answer = box_value * area_value * Math.sin(alpha_value);
            } else {
              param.error = 'Please! Check your input';
              return param;
            }
          } else if (find_triangle_two == "3") {
            method = 17;
            if (isNumeric(e) && isNumeric(f) && isNumeric(angle_theta)) {
              const e_value = unit_convert(e_unit, parseFloat(e));
              const f_value = unit_convert(f_unit, parseFloat(f));
              const theta_value = angle_convert(angle_theta_unit, parseFloat(angle_theta));
              param.tech_e = isNaN(e_value) ? "NaN" : e_value;
              param.tech_f  = isNaN(f_value) ? "NaN" : f_value;
              param.tech_theta_value = isNaN(theta_value) ? "NaN" : theta_value;

              answer = e_value * f_value * Math.sin(theta_value);
            } else {
              param.error = 'Please! Check your input';
              return param;
            }
          }
        } else if (shapes == "rhombus") {
          if (find_triangle_three == "1") {
            method = 21;
            if (isNumeric(area) && isNumeric(height)) {
              const area_value = unit_convert(area_unit, parseFloat(area));
              const height_value = unit_convert(height_unit, parseFloat(height));
              param.tech_height = isNaN(height_value) ? "NaN" : height_value;
              param.tech_area   = isNaN(area_value)   ? "NaN" : area_value;
              answer = area_value * height_value;
            } else {
              param.error = 'Please! Check your input';
              return param;
            }
          } else if (find_triangle_three == "2") {
            method = 22;
            if (isNumeric(e) && isNumeric(f)) {
              const e_value = unit_convert(e_unit, parseFloat(e));
              const f_value = unit_convert(f_unit, parseFloat(f));
             param.tech_e = isNaN(e_value) ? "NaN" : e_value;
              param.tech_f = isNaN(f_value) ? "NaN" : f_value;
              answer = e_value * f_value / 2;
            } else {
              param.error = 'Please! Check your input';
              return param;
            }
          } else if (find_triangle_three == "3") {
            method = 23;
            if (isNumeric(area) && isNumeric(angle_alpha)) {
              const area_value = unit_convert(area_unit, parseFloat(area));
              const alpha_value = angle_convert(angle_alpha_unit, parseFloat(angle_alpha));
             param.tech_area = isNaN(area_value) ? "NaN" : area_value;
             param.tech_alpha_value = isNaN(alpha_value) ? "NaN" : alpha_value;

              answer = area_value * area_value * Math.sin(alpha_value);
            } else {
              param.error = 'Please! Check your input';
              return param;
            }
          }
        } else if (shapes == "kite") {
          if (find_triangle_four == "2") {
            method = 24;
            if (isNumeric(area) && isNumeric(box) && isNumeric(angle_alpha)) {
              const area_value = unit_convert(area_unit, parseFloat(area));
              const box_value = unit_convert(box_unit, parseFloat(box));
              const alpha_value = angle_convert(angle_alpha_unit, parseFloat(angle_alpha));
              param.tech_area = isNaN(area_value) ? "NaN" : area_value;
              param.tech_box = isNaN(box_value) ? "NaN" : box_value;
              param.tech_alpha = isNaN(alpha_value) ? "NaN" : alpha_value;
              answer = box_value * area_value * Math.sin(alpha_value);
            } else {
              param.error = 'Please! Check your input';
              return param;
            }
          } else if (find_triangle_four == "1") {
            method = 25;
            if (isNumeric(e) && isNumeric(f)) {
              const e_value = unit_convert(e_unit, parseFloat(e));
              const f_value = unit_convert(f_unit, parseFloat(f));
             param.tech_e = isNaN(e_value) ? "NaN" : e_value;
             param.tech_f = isNaN(f_value) ? "NaN" : f_value;

              answer = e_value * f_value / 2;
            } else {
              param.error = 'Please! Check your input';
              return param;
            }
          }
        } else if (shapes == "circle") {
          method = 4;
          if (isNumeric(radius)) {
            const radius_value = unit_convert(radius_unit, parseFloat(radius));
            answer = radius_value * radius_value * Math.PI;
             param.tech_radius = isNaN(radius_value) ? "NaN" : radius_value;

          } else {
            param.error = 'Please! Check your input';
            return param;
          }
        } else if (shapes == "semicircle") {
          method = 5;
          if (isNumeric(radius)) {
            const radius_value = unit_convert(radius_unit, parseFloat(radius));
            answer = (radius_value * radius_value * Math.PI) * 0.5;
             param.tech_radius = isNaN(radius) ? "NaN" : radius;

          } else {
            param.error = 'Please! Check your input';
            return param;
          }
        } else if (shapes == "sector") {
          method = 6;
          if (isNumeric(angle_alpha) && isNumeric(radius)) {
            const radius_value = unit_convert(radius_unit, parseFloat(radius));
            const angle_value = angle_convert(angle_alpha_unit, parseFloat(angle_alpha));
            answer = (radius_value * radius_value * angle_value) / 2;
           param.tech_angle_value = isNaN(angle_value) ? "NaN" : angle_value;
           param.tech_radius = isNaN(radius) ? "NaN" : radius;

          } else {
            param.error = 'Please! Check your input';
            return param;
          }
        } else if (shapes == "ellipse") {
          method = 7;
          if (isNumeric(area) && isNumeric(box)) {
            const area_value = unit_convert(area_unit, parseFloat(area));
            const box_value = unit_convert(box_unit, parseFloat(box));
            answer = area_value * box_value * Math.PI;
            param.tech_area = isNaN(area_value) ? "NaN" : area_value;
            param.tech_box = isNaN(box_value) ? "NaN" : box_value;

          } else {
            param.error = 'Please! Check your input';
            return param;
          }
        } else if (shapes == "trapezoid") {
          method = 8;
          if (isNumeric(area) && isNumeric(box) && isNumeric(height)) {
            const area_value = unit_convert(area_unit, parseFloat(area));
            const box_value = unit_convert(box_unit, parseFloat(box));
            const height_value = unit_convert(height_unit, parseFloat(height));
            answer = (area_value + box_value) * height_value / 2;
           param.tech_area = isNaN(area_value) ? "NaN" : area_value;
            param.tech_box = isNaN(box_value) ? "NaN" : box_value;
            param.tech_height = isNaN(height_value) ? "NaN" : height_value;

          } else {
            param.error = 'Please! Check your input';
            return param;
          }
        } else if (shapes == "regular pentagon") {
          method = 9;
          if (isNumeric(area)) {
            const area_value = unit_convert(area_unit, parseFloat(area));
            answer = area_value * area_value * Math.sqrt(25 + 10 * Math.sqrt(5)) / 4;
           param.tech_area = isNaN(area_value) ? "NaN" : area_value;

          } else {
            param.error = 'Please! Check your input';
            return param;
          }
        } else if (shapes == "regular hexagon") {
          method = 10;
          if (isNumeric(area)) {
            const area_value = unit_convert(area_unit, parseFloat(area));
            answer = 3 / 2 * Math.sqrt(3) * area_value * area_value;
           param.tech_area = isNaN(area_value) ? "NaN" : area_value;
          } else {
            param.error = 'Please! Check your input';
            return param;
          }
        } else if (shapes == "regular octagon") {
          method = 11;
          if (isNumeric(area)) {
            const area_value = unit_convert(area_unit, parseFloat(area));
            answer = 2 * (1 + Math.sqrt(2)) * area_value * area_value;
            param.tech_area = isNaN(area_value) ? "NaN" : area_value;
          } else {
            param.error = 'Please! Check your input';
            return param;
          }
        } else if (shapes == "annulus (ring)") {
          method = 12;
          if (isNumeric(radius) && isNumeric(bara_radius)) {
            const r_val = parseFloat(radius);
            const br_val = parseFloat(bara_radius);
            
            if (br_val > r_val) {
              const radius_value = unit_convert(radius_unit, r_val);
              const bara_radius_value = unit_convert(bara_radius_unit, br_val);
              answer = Math.PI * (bara_radius_value * bara_radius_value - radius_value * radius_value);
             param.tech_radius = isNaN(radius_value) ? "NaN" : radius_value;
            param.tech_bara_radius = isNaN(bara_radius_value) ? "NaN" : bara_radius_value;

            } else {
              param.error = 'Radius R should be greater than r.';
              return param;
            }
          } else {
            param.error = 'Please! Check your input';
            return param;
          }
        } else if (shapes == "irregular quadrilateral") {
          method = 13;
          if (isNumeric(e) && isNumeric(f) && isNumeric(angle_alpha)) {
            const e_value = unit_convert(e_unit, parseFloat(e));
            const f_value = unit_convert(f_unit, parseFloat(f));
            const angle_value = angle_convert(angle_alpha_unit, parseFloat(angle_alpha));
            answer = e_value * f_value * Math.sin(angle_value);
          param.tech_e = isNaN(e_value) ? "NaN" : e_value;
          param.tech_f = isNaN(f_value) ? "NaN" : f_value;
          param.tech_angle_value = isNaN(angle_value) ? "NaN" : angle_value;

          } else {
            param.error = 'Please! Check your input';
            return param;
          }
        } else if (shapes === "regular polygon") {
          method = 14;
          if (isNumeric(area) && isNumeric(number_of_sides)) {
            const area_value = unit_convert(area_unit, parseFloat(area));
            const n = parseFloat(number_of_sides);
            answer = n * area_value * area_value * 1 / Math.tan(Math.PI / n) / 4;
           param.tech_number_of_sides = isNaN(number_of_sides) ? "NaN" : number_of_sides;
          param.tech_area = isNaN(area_value) ? "NaN" : area_value;

          } else {
            param.error = 'Please! Check your input';
            return param;
          }
        }

        param.tech_answer = answer;
        param.tech_method = method;

        return param;
      }


  /**
    * getCalculationthirtytriangleCalculator: Service Method
    * POST: /api/calculators-lol/30-60-90-triangle-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */
   async getCalculationthirtytriangleCalculator(body) {
        const sides = body.tech_sides;
        const input = body.tech_input;
        const linear_unit = body.tech_linear_unit;
        const square_unit = body.tech_square_unit;
        const param = {};

        // Helper function to convert length units to cm
        function again_unit_convert(unit, value) {
          const conversions = {
            'mm': 0.1,
            'cm': 1,
            'm': 100,
            'km': 100000,
            'in': 2.54,
            'ft': 30.48,
            'yd': 91.44,
            'mi': 160934
          };
          return value * (conversions[unit] || 1);
        }

        // Helper function to convert area units to cm²
        function again_centi(unit3, value3) {
          const conversions = {
            'mm²': 0.01,
            'cm²': 1,
            'm²': 10000,
            'km²': 10000000000,
            'in²': 6.452,
            'ft²': 929,
            'yd²': 8361,
            'mi²': 25899881103
          };
          return value3 * (conversions[unit3] || 1);
        }

        // Validate if input is numeric
        function isNumeric(value) {
          return !isNaN(parseFloat(value)) && isFinite(value);
        }

        if (!isNumeric(input)) {
          param.error = 'Please Check Your Input.';
          return param;
        }

        let method, lena_val, b, c, area, peri, height, in_radius, radius;

        if (sides == "a") {
          // Given side 'a' (shortest side)
          method = 1;
          lena_val = again_unit_convert(linear_unit, parseFloat(input));
          b = Math.sqrt(3) * lena_val;
          c = 2 * lena_val;
          area = (lena_val * b / 2);
          peri = lena_val + b + c;
          height = b / 2;
          in_radius = (lena_val * b) / peri;
          radius = c / 2;
        } else if (sides == "b") {
          // Given side 'b' (middle side)
          method = 2;
          b = again_unit_convert(linear_unit, parseFloat(input));
          lena_val = (b * Math.sqrt(3)) / 3;
          c = 2 * ((b * Math.sqrt(3)) / 3);
          area = (lena_val * b / 2);
          peri = lena_val + b + c;
          height = b / 2;
          in_radius = (lena_val * b) / peri;
          radius = c / 2;
        } else if (sides == "c") {
          // Given side 'c' (hypotenuse)
          method = 3;
          c = again_unit_convert(linear_unit, parseFloat(input));
          b = (c * Math.sqrt(3)) / 2;
          lena_val = c / 2;
          area = (lena_val * b / 2);
          peri = lena_val + b + c;
          height = b / 2;
          in_radius = (lena_val * b) / peri;
          radius = c / 2;
        } else if (sides == "h") {
          // Given height
          method = 4;
          height = again_unit_convert(linear_unit, parseFloat(input));
          b = height * 2;
          lena_val = b / Math.sqrt(3);
          c = 2 * lena_val;
          area = (lena_val * lena_val) * (Math.sqrt(3) / 2);
          peri = lena_val + b + c;
          in_radius = (lena_val * b) / peri;
          radius = c / 2;
        } else if (sides == "A") {
          // Given area
          method = 5;
          area = again_centi(square_unit, parseFloat(input));
          lena_val = Math.sqrt(2 * area / Math.sqrt(3));
          b = lena_val * Math.sqrt(3);
          c = 2 * lena_val;
          height = lena_val * b / c;
          peri = lena_val + b + c;
          in_radius = (lena_val * b) / peri;
          radius = c / 2;
        } else if (sides == "p") {
          // Given perimeter
          method = 6;
          peri = again_unit_convert(linear_unit, parseFloat(input));
          lena_val = peri / (3 + Math.sqrt(3));
          b = lena_val * Math.sqrt(3);
          c = 2 * lena_val;
          height = (lena_val * b) / c;
          area = (lena_val * lena_val) * (Math.sqrt(3) / 2);
          in_radius = (lena_val * b) / peri;
          radius = c / 2;
        }

        // Round to 3 decimal places
        param.tech_method = method;
        param.tech_a = Math.round(lena_val * 1000) / 1000;
        param.tech_a_unit = linear_unit;
        param.tech_b = Math.round(b * 1000) / 1000;
        param.tech_b_unit = linear_unit;
        param.tech_c = Math.round(c * 1000) / 1000;
        param.tech_c_unit = linear_unit;
        param.tech_area_unit = square_unit;
        param.tech_perimeter_unit = linear_unit;
        param.tech_aa = Math.round(area * 1000) / 1000;
        param.tech_peri = Math.round(peri * 1000) / 1000;
        param.tech_height = Math.round(height * 1000) / 1000;
        param.tech_height_unit = linear_unit;
        param.tech_in_radius = Math.round(in_radius * 1000) / 1000;
        param.tech_radius = Math.round(radius * 1000) / 1000;

        return param;
      }




      /**
    * getCalculationTrigonometryCalculator: Service Method
    * POST: /api/calculators-lol/trigonometry-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

     async  getCalculationTrigonometryCalculator(body) {
        const find = body.tech_find;
        const angle = body.tech_angle;
        const angle_unit = body.tech_angle_unit;

        const result = {};

        // Helper function: degrees to radians
        const deg2rad = (degrees) => degrees * (Math.PI / 180);

        // Helper function: radians to degrees
        const rad2deg = (radians) => radians * (180 / Math.PI);

        // Validate angle is numeric
        if (!angle || isNaN(angle)) {
            result.error = 'Please Check Your Input.';
            return result;
        }

        const angleNum = parseFloat(angle);
        let method;

        // Case 1: Single trigonometric function
        if (["sin", "cos", "tan", "cot", "sec", "csc"].includes(find)) {
            method = 1;
            let ans1, ans2;

            if (angle_unit == "deg") {
                const radAngle = deg2rad(angleNum);
                
                switch(find) {
                    case "sin":
                        ans1 = Math.sin(radAngle);
                        break;
                    case "cos":
                        ans1 = Math.cos(radAngle);
                        break;
                    case "tan":
                        ans1 = Math.tan(radAngle);
                        break;
                    case "csc":
                        ans1 = 1 / Math.sin(radAngle);
                        break;
                    case "sec":
                        ans1 = 1 / Math.cos(radAngle);
                        break;
                    case "cot":
                        ans1 = 1 / Math.tan(radAngle);
                        break;
                }
                ans2 = radAngle;

            } else if (angle_unit == "rad") {
                switch(find) {
                    case "sin":
                        ans1 = Math.sin(angleNum);
                        break;
                    case "cos":
                        ans1 = Math.cos(angleNum);
                        break;
                    case "tan":
                        ans1 = Math.tan(angleNum);
                        break;
                    case "cot":
                        ans1 = 1 / Math.tan(angleNum);
                        break;
                    case "csc":
                        ans1 = 1 / Math.sin(angleNum);
                        break;
                    case "sec":
                        ans1 = 1 / Math.cos(angleNum);
                        break;
                }
                ans2 = rad2deg(angleNum);
            }

           result.tech_ans1 = isNaN(ans1) ? "NaN" : ans1;
           result.tech_ans2 = isNaN(ans2) ? "NaN" : ans2;

        }
        // Case 2: All trigonometric functions
        else if (find == "All") {
            method = 2;
            let sin, cos, tan, csc, sec, cot;
            let asin, acos, atan, acsc, asec, acot;
            let fns;

            if (angle_unit == "deg") {
                const radAngle = deg2rad(angleNum);
                
                sin = Math.sin(radAngle);
                cos = Math.cos(radAngle);
                tan = Math.tan(radAngle);
                csc = 1 / Math.sin(radAngle);
                sec = 1 / Math.cos(radAngle);
                cot = 1 / Math.tan(radAngle);
                
                asin = Math.asin(angleNum);
                acos = Math.acos(angleNum);
                atan = Math.atan(angleNum);
                acsc = Math.asin(1 / angleNum);
                asec = Math.acos(1 / angleNum);
                acot = Math.atan(1 / angleNum);
                
                fns = radAngle;

            } else if (angle_unit === "rad") {
                sin = Math.sin(angleNum);
                cos = Math.cos(angleNum);
                tan = Math.tan(angleNum);
                csc = 1 / Math.sin(angleNum);
                sec = 1 / Math.cos(angleNum);
                cot = 1 / Math.tan(angleNum);
                
                asin = Math.asin(angleNum);
                acos = Math.acos(angleNum);
                atan = Math.atan(angleNum);
                acsc = Math.asin(1 / angleNum);
                asec = Math.acos(1 / angleNum);
                acot = Math.atan(1 / angleNum);
                
                fns = rad2deg(angleNum);
            }

          result.tech_sin = isNaN(sin) ? "NaN" : sin;
          result.tech_cos = isNaN(cos) ? "NaN" : cos;
          result.tech_tan = isNaN(tan) ? "NaN" : tan;
          result.tech_csc = isNaN(csc) ? "NaN" : csc;
          result.tech_cot = isNaN(cot) ? "NaN" : cot;
          result.tech_sec = isNaN(sec) ? "NaN" : sec;
          result.tech_asin = isNaN(asin) ? "NaN" : asin;
          result.tech_acos = isNaN(acos) ? "NaN" : acos;
          result.tech_atan = isNaN(atan) ? "NaN" : atan;
          result.tech_acsc = isNaN(acsc) ? "NaN" : acsc;
          result.tech_acot = isNaN(acot) ? "NaN" : acot;
          result.tech_asec = isNaN(asec) ? "NaN" : asec;
          result.tech_fns = isNaN(fns) ? "NaN" : fns;

        }
        // Case 3: Inverse trigonometric functions
        else if (["arcsin", "arccos", "arctan", "arccsc", "arcsec", "arccot"].includes(find)) {
            method = 3;
            
            // Parse degrees, minutes, seconds
            const vars = angle.toString().split(".");
            let deg, min, sec;
            
            if (vars.length < 2) {
                deg = parseInt(vars[0]);
                min = 0;
                sec = 0;
            } else {
                deg = parseInt(vars[0]);
                let tempma = parseFloat("0." + vars[1]);
                tempma = tempma * 3600;
                min = Math.floor(tempma / 60);
                sec = Math.round((tempma - (min * 60)) * 1000) / 1000;
            }

            let rad;
            
            switch(find) {
                case "arcsin":
                    rad = Math.asin(angleNum);
                    break;
                case "arccos":
                    rad = Math.acos(angleNum);
                    break;
                case "arctan":
                    rad = Math.atan(angleNum);
                    break;
                case "arccsc":
                    rad = Math.asin(1 / angleNum);
                    break;
                case "arcsec":
                    rad = Math.acos(1 / angleNum);
                    break;
                case "arccot":
                    rad = Math.atan(1 / angleNum);
                    break;
            }

            deg = rad2deg(rad);
            
            result.rad = rad;
            result.deg = deg;
        }

        // Set group name based on function
        const groupMap = {
            "sin": "Group 4",
            "cos": "Group 3",
            "tan": "Group 2",
            "sec": "Group 6",
            "csc": "Group 5",
            "cot": "Group 1"
        };

        if (groupMap[find]) {
            result.tech_naam = groupMap[find];
        }

        result.tech_find = find;
        result.tech_angle = isNaN(angle) ? "NaN" : angle;
        result.tech_angle_unit = angle_unit;
        result.tech_method = method;

        return result;
    }


       /**
    * getCalculationSohcahtoaCalculator: Service Method
    * POST: /api/calculators-lol/sohcahtoa-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async  getCalculationSohcahtoaCalculator(body) {
        let len_a = body.tech_len_a;
        let len_a_unit = body.tech_len_a_unit;
        let len_b = body.tech_len_b;
        let len_b_unit = body.tech_len_b_unit;
        let len_c = body.tech_len_c;
        let len_c_unit = body.tech_len_c_unit;
        let area = body.tech_area;
        let area_unit = body.tech_area_unit;
        let angle_alpha = body.tech_angle_alpha;
        let angle_alpha_unit = body.tech_angle_alpha_unit;
        let angle_beta = body.tech_angle_beta;
        let angle_beta_unit = body.tech_angle_beta_unit;


      const result = {};

      // Helper function: Convert length units to centimeters
      function newUnitConvert(unit, value) {
          const conversions = {
              'mm': 0.1,
              'cm': 1,
              'm': 100,
              'km': 1000,
              'in': 2.54,
              'ft': 30.48,
              'yd': 91.44,
              'mi': 160934
          };
          return value * (conversions[unit] || 1);
      }

      // Helper function: Convert area units to square centimeters
      function newCenti(unit3, value3) {
          const conversions = {
              'mm²': 0.01,
              'cm²': 1,
              'm²': 10000,
              'km²': 10000000000,
              'in²': 6.452,
              'ft²': 929,
              'yd²': 8361,
              'mi²': 25899881103
          };
          return value3 * (conversions[unit3] || 1);
      }

      // Convert angle units
      if (angle_alpha_unit == "rad") {
          angle_alpha_unit = "57.3";
      } else {
          angle_alpha_unit = "0.017453";
      }

      if (angle_beta_unit == "rad") {
          angle_beta_unit = "57.3";
      } else {
          angle_beta_unit = "0.017453";
      }

      // Helper to check if value is numeric and not empty
      const isNumeric = (val) => val !== null && val !== undefined && val !== '' && !isNaN(val);

      let method;
      let c, anglea, angleb, area_value;

      // Method 1: len_a and len_b provided
      if (isNumeric(len_a) && isNumeric(len_b)) {
          if (!isNumeric(len_c) && !isNumeric(area) && !isNumeric(angle_alpha) && !isNumeric(angle_beta)) {
              method = 1;
              len_a = parseFloat(len_a);
              len_b = parseFloat(len_b);
              c = Math.sqrt((len_a * len_a) + (len_b * len_b));
              anglea = Math.atan(len_a / len_b);
              angleb = Math.atan(len_b / len_a);
              area_value = (len_a * len_b) / 2;
             result.tech_area = isNaN(area_value) ? "NaN" : area_value;

          } else {
              result.error = 'Please! Enter only two values in one of the following fields.';
              return result;
          }
      }
      // Method 2: len_a and len_c provided
      else if (isNumeric(len_a) && isNumeric(len_c)) {
          if (!isNumeric(len_b) && !isNumeric(area) && !isNumeric(angle_alpha) && !isNumeric(angle_beta)) {
              method = 2;
              len_a = parseFloat(len_a);
              c = parseFloat(len_c);
              len_b = Math.sqrt((c * c) - (len_a * len_a));
              anglea = Math.atan(len_a / len_b);
              angleb = Math.atan(len_b / len_a);
              area_value = (len_a * len_b) / 2;
             result.tech_area = isNaN(area_value) ? "NaN" : area_value;

          } else {
              result.error = 'Please! Enter only two values in one of the following fields.';
              return result;
          }
      }
      // Method 3: len_b and len_c provided
      else if (isNumeric(len_b) && isNumeric(len_c)) {
          if (!isNumeric(len_a) && !isNumeric(area) && !isNumeric(angle_alpha) && !isNumeric(angle_beta)) {
              method = 3;
              len_b = parseFloat(len_b);
              c = parseFloat(len_c);
              len_a = Math.sqrt((c * c) - (len_b * len_b));
              anglea = Math.atan(len_a / len_b);
              angleb = Math.atan(len_b / len_a);
              area_value = (len_a * len_b) / 2;
              result.tech_area = isNaN(area_value) ? "NaN" : area_value;
          } else {
              result.error = 'Please! Enter only two values in one of the following fields.';
              return result;
          }
      }
      // Method 4: angle_alpha and len_a provided
      else if (isNumeric(angle_alpha) && isNumeric(len_a)) {
          if (!isNumeric(len_b) && !isNumeric(len_c) && !isNumeric(angle_beta) && !isNumeric(area)) {
              method = 4;
              len_a = parseFloat(len_a);
              anglea = parseFloat(angle_alpha) * parseFloat(angle_alpha_unit);
              len_b = len_a / Math.tan(anglea);
              c = Math.sqrt(len_a * len_a + len_b * len_b);
              angleb = Math.atan(len_b / len_a);
              area_value = (len_a * len_b) / 2;
              result.tech_area = isNaN(area_value) ? "NaN" : area_value;
          } else {
              result.error = 'Please! Enter only two values in one of the following fields.';
              return result;
          }
      }
      // Method 5: angle_alpha and len_b provided
      else if (isNumeric(angle_alpha) && isNumeric(len_b)) {
          if (!isNumeric(len_a) && !isNumeric(len_c) && !isNumeric(angle_beta) && !isNumeric(area)) {
              method = 5;
              len_b = parseFloat(len_b);
              anglea = parseFloat(angle_alpha) * parseFloat(angle_alpha_unit);
              len_a = len_b * Math.tan(anglea);
              c = Math.sqrt(len_a * len_a + len_b * len_b);
              angleb = Math.atan(len_b / len_a);
              area_value = (len_a * len_b) / 2;
             result.tech_area = isNaN(area_value) ? "NaN" : area_value;
          } else {
              result.error = 'Please! Enter only two values in one of the following fields.';
              return result;
          }
      }
      // Method 6: angle_alpha and len_c provided
      else if (isNumeric(angle_alpha) && isNumeric(len_c)) {
          if (!isNumeric(len_a) && !isNumeric(len_b) && !isNumeric(angle_beta) && !isNumeric(area)) {
              method = 6;
              c = parseFloat(len_c);
              anglea = parseFloat(angle_alpha) * parseFloat(angle_alpha_unit);
              len_a = c * Math.sin(anglea);
              len_b = c * Math.cos(anglea);
              angleb = Math.atan(len_b / len_a);
              area_value = (len_a * len_b) / 2;
             result.tech_area = isNaN(area_value) ? "NaN" : area_value;
          } else {
              result.error = 'Please! Enter only two values in one of the following fields.';
              return result;
          }
      }
      // Method 7: angle_beta and len_a provided
      else if (isNumeric(angle_beta) && isNumeric(len_a)) {
          if (!isNumeric(len_b) && !isNumeric(len_c) && !isNumeric(angle_alpha) && !isNumeric(area)) {
              method = 7;
              len_a = parseFloat(len_a);
              const PI = Math.PI;
              
              if (angle_beta_unit === "0.017453") {
                  angleb = (parseFloat(angle_beta) * PI) / 180;
                  anglea = PI / 2 - angleb;
              } else if (angle_beta_unit === "57.3") {
                  anglea = PI / 2 - parseFloat(angle_beta);
              }
              
              len_b = len_a / Math.tan(anglea);
              c = Math.sqrt(len_a * len_a + len_b * len_b);
              anglea = Math.atan(len_a / len_b);
              angleb = Math.atan(len_b / len_a);
              area_value = (len_a * len_b) / 2;
              result.tech_area = isNaN(area_value) ? "NaN" : area_value;
          } else {
              result.error = 'Please! Enter only two values in one of the following fields.';
              return result;
          }
      }
      // Method 8: angle_beta and len_b provided
      else if (isNumeric(angle_beta) && isNumeric(len_b)) {
          if (!isNumeric(len_a) && !isNumeric(len_c) && !isNumeric(angle_alpha) && !isNumeric(area)) {
              method = 8;
              len_b = parseFloat(len_b);
              const PI = Math.PI;
              
              if (angle_beta_unit === "0.017453") {
                  angleb = (parseFloat(angle_beta) * PI) / 180;
                  anglea = PI / 2 - angleb;
              } else if (angle_beta_unit === "57.3") {
                  anglea = PI / 2 - parseFloat(angle_beta);
              }
              
              len_a = len_b * Math.tan(anglea);
              c = Math.sqrt(len_a * len_a + len_b * len_b);
              anglea = Math.atan(len_a / len_b);
              angleb = Math.atan(len_b / len_a);
              area_value = (len_a * len_b) / 2;
              result.tech_area = isNaN(area_value) ? "NaN" : area_value;
          } else {
              result.error = 'Please! Enter only two values in one of the following fields.';
              return result;
          }
      }
      // Method 9: angle_beta and len_c provided
      else if (isNumeric(angle_beta) && isNumeric(len_c)) {
          if (!isNumeric(len_a) && !isNumeric(len_b) && !isNumeric(angle_alpha) && !isNumeric(area)) {
              method = 9;
              c = parseFloat(len_c);
              const PI = Math.PI;
              
              if (angle_beta_unit === "0.017453") {
                  angleb = (parseFloat(angle_beta) * PI) / 180;
                  anglea = PI / 2 - angleb;
              } else if (angle_beta_unit === "57.3") {
                  anglea = PI / 2 - parseFloat(angle_beta);
              }
              
              len_a = c * Math.sin(anglea);
              len_b = c * Math.cos(anglea);
              anglea = Math.atan(len_a / len_b);
              angleb = Math.atan(len_b / len_a);
              area_value = (len_a * len_b) / 2;
              result.tech_area = isNaN(area_value) ? "NaN" : area_value;
          } else {
              result.error = 'Please! Enter only two values in one of the following fields.';
              return result;
          }
      }
      // Method 10: area and len_a provided
      else if (isNumeric(area) && isNumeric(len_a)) {
          if (!isNumeric(len_b) && !isNumeric(len_c) && !isNumeric(angle_alpha) && !isNumeric(angle_beta)) {
              method = 10;
              len_a = parseFloat(len_a);
              area_value = newCenti(area_unit, parseFloat(area));
              len_b = 2 * area_value / len_a;
              c = Math.sqrt((len_a * len_a) + (len_b * len_b));
              anglea = Math.atan(len_a / len_b);
              angleb = Math.atan(len_b / len_a);
              result.tech_area = isNaN(area_value) ? "NaN" : area_value;
          } else {
              result.error = 'Please! Enter only two values in one of the following fields.';
              return result;
          }
      }
      // Method 11: area and len_b provided
      else if (isNumeric(area) && isNumeric(len_b)) {
          if (!isNumeric(len_a) && !isNumeric(len_c) && !isNumeric(angle_alpha) && !isNumeric(angle_beta)) {
              method = 11;
              len_b = parseFloat(len_b);
              area_value = newCenti(area_unit, parseFloat(area));
              len_a = 2 * area_value / len_b;
              c = Math.sqrt((len_a * len_a) + (len_b * len_b));
              anglea = Math.atan(len_a / len_b);
              angleb = Math.atan(len_b / len_a);
              result.tech_area = isNaN(area_value) ? "NaN" : area_value;
          } else {
              result.error = 'Please! Enter only two values in one of the following fields.';
              return result;
          }
      }
      // Method 12: area and len_c provided
      else if (isNumeric(area) && isNumeric(len_c)) {
          if (!isNumeric(len_a) && !isNumeric(len_b) && !isNumeric(angle_alpha) && !isNumeric(angle_beta)) {
              method = 12;
              c = parseFloat(len_c);
              area_value = newCenti(area_unit, parseFloat(area));
              len_a = Math.sqrt((c * c + Math.sqrt(Math.pow(c, 4) - 16 * area_value * area_value)) / 2);
              len_b = Math.sqrt((c * c - Math.sqrt(Math.pow(c, 4) - 16 * area_value * area_value)) / 2);
              anglea = Math.asin(len_a / c);
              angleb = Math.atan(len_b / len_a);
             result.tech_area = isNaN(area_value) ? "NaN" : area_value;
          } else {
              result.error = 'Please! Enter only two values in one of the following fields.';
              return result;
          }
      }
      // Method 13: area and angle_alpha provided
      else if (isNumeric(area) && isNumeric(angle_alpha)) {
          if (!isNumeric(len_a) && !isNumeric(len_b) && !isNumeric(len_c) && !isNumeric(angle_beta)) {
              method = 13;
              area_value = newCenti(area_unit, parseFloat(area));
              anglea = parseFloat(angle_alpha) * parseFloat(angle_alpha_unit);
              len_a = Math.sqrt(2 * area_value * Math.tan(anglea));
              len_b = Math.sqrt(2 * area_value / Math.tan(anglea));
              c = Math.sqrt(len_a * len_a + len_b * len_b);
              anglea = Math.atan(len_a / len_b);
              angleb = Math.atan(len_b / len_a);
              result.tech_area = isNaN(area_value) ? "NaN" : area_value;
          } else {
              result.error = 'Please! Enter only two values in one of the following fields.';
              return result;
          }
      }
      // Method 14: area and angle_beta provided
      else if (isNumeric(area) && isNumeric(angle_beta)) {
          if (!isNumeric(len_a) && !isNumeric(len_b) && !isNumeric(len_c) && !isNumeric(angle_alpha)) {
              method = 14;
              area_value = newCenti(area_unit, parseFloat(area));
              angleb = parseFloat(angle_beta) * parseFloat(angle_beta_unit);
              len_a = Math.sqrt(2 * area_value * Math.tan(angleb));
              len_b = Math.sqrt(2 * area_value / Math.tan(angleb));
              c = Math.sqrt(len_a * len_a + len_b * len_b);
              anglea = Math.atan(len_a / len_b);
              angleb = Math.atan(len_b / len_a);
              result.tech_area = isNaN(area_value) ? "NaN" : area_value;
          } else {
              result.error = 'Please! Enter only two values in one of the following fields.';
              return result;
          }
      }
      // Error: Both angles provided
      else if (isNumeric(angle_alpha) && isNumeric(angle_beta)) {
          if (!isNumeric(len_a) && !isNumeric(len_b) && !isNumeric(len_c) && !isNumeric(area)) {
              result.error = 'Can not calculate based on 2 angles only.';
              return result;
          } else {
              result.error = 'Please! Enter only two values in one of the following fields.';
              return result;
          }
      }

      result.tech_method = method;
      result.tech_a = isNaN(len_a) ? "NaN" : len_a;
      result.tech_b = isNaN(len_b) ? "NaN" : len_b;
      result.tech_c = isNaN(c) ? "NaN" : c;
      result.tech_anglea = isNaN(anglea) ? "NaN" : anglea;
      result.tech_angleb = isNaN(angleb) ? "NaN" : angleb;

      return result;
  }


          /**
    * getCalculationFortyFivetriangleCalculator: Service Method
    * POST: /api/calculators-lol/45-45-90-triangle-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

   async  getCalculationFortyFivetriangleCalculator(body) {
      let sides = body.tech_sides;
      let input = body.tech_input;
      let linear_unit = body.tech_linear_unit;
      let square_unit = body.tech_square_unit;

      const result = {};

      // Helper function: Convert length units to centimeters
      function unitConvert(unit, value) {
          const conversions = {
              'mm': 0.1,
              'cm': 1,
              'm': 100,
              'km': 1000,
              'in': 2.54,
              'ft': 30.48,
              'yd': 91.44,
              'mi': 160934
          };
          return value * (conversions[unit] || 1);
      }

      // Helper function: Convert area units to square centimeters
      function centi(unit3, value3) {
          const conversions = {
              'mm²': 0.01,
              'cm²': 1,
              'm²': 10000,
              'km²': 10000000000,
              'in²': 6.452,
              'ft²': 929,
              'yd²': 8361,
              'mi²': 25899881103
          };
          return value3 * (conversions[unit3] || 1);
      }

      // Validate input is numeric
      if (!input || isNaN(input)) {
          result.error = 'Please! Check Your Input.';
          return result;
      }

      const inputNum = parseFloat(input);
      let a_ans, b_ans, c_ans, area_ans, perimeter_ans;
      let user_input;

      // Calculate based on which side is given
      switch(sides) {
          case "a":
              user_input = unitConvert(linear_unit, inputNum);
              a_ans = user_input;
              b_ans = user_input;
              c_ans = user_input * Math.sqrt(2);
              area_ans = Math.pow(user_input, 2) / 2;
              perimeter_ans = user_input * 3.41421356;
              break;

          case "b":
              user_input = unitConvert(linear_unit, inputNum);
              c_ans = user_input * Math.sqrt(2);
              a_ans = user_input;
              b_ans = user_input;
              area_ans = Math.pow(user_input, 2) / 2;
              perimeter_ans = user_input * 3.41421356;
              break;

          case "c":
              user_input = unitConvert(linear_unit, inputNum);
              c_ans = user_input;
              a_ans = user_input / 1.4142135;
              b_ans = a_ans;
              area_ans = Math.pow(a_ans, 2) / 2;
              perimeter_ans = a_ans * 3.41421356;
              break;

          case "area":
              user_input = centi(square_unit, inputNum);
              area_ans = user_input;
              a_ans = Math.sqrt(user_input * 2);
              b_ans = a_ans;
              c_ans = a_ans * Math.sqrt(2);
              perimeter_ans = a_ans * 3.41421356;
              break;

          case "perimeter":
              user_input = unitConvert(linear_unit, inputNum);
              perimeter_ans = user_input;
              a_ans = user_input / 3.41421356;
              b_ans = a_ans;
              c_ans = a_ans * Math.sqrt(2);
              area_ans = Math.pow(a_ans, 2) / 2;
              break;

          default:
              result.error = 'Please! Check Your Input.';
              return result;
      }

      // Calculate height and radius
      const height = c_ans / 2;
      const radius = a_ans - height;
      result.tech_a_ans = isNaN(a_ans) ? "NaN" : a_ans;
      result.tech_b_ans = isNaN(b_ans) ? "NaN" : b_ans;
      result.tech_c_ans = isNaN(c_ans) ? "NaN" : c_ans;
      result.tech_area_ans = isNaN(area_ans) ? "NaN" : area_ans;
      result.tech_perimeter_ans = isNaN(perimeter_ans) ? "NaN" : perimeter_ans;
      result.tech_height = isNaN(height) ? "NaN" : height;
      result.tech_radius = isNaN(radius) ? "NaN" : radius;


      return result;
  }

     /**
    * getCalculationTwoComplementCalculator: Service Method
    * POST: /api/calculators-lol/twos-complement-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */


  async  getCalculationTwoComplementCalculator(body) {
      let selection = body.tech_selection;
      let cal = body.tech_cal;
      let dec = body.tech_dec;
      let bnry = body.tech_bnry;
      let hex = body.tech_hex;
      let bits = body.tech_bits;
      let no_of_bits = body.tech_no_of_bits;
      let no = body.tech_no;
      let no1 = body.tech_no1;
      let action = body.tech_action;


      const result = {};

      // Helper function: Flip bit
      function flip(c) {
          return (c === '0') ? '1' : '0';
      }

      // Helper function: One's complement
      function onesComplement(str) {
          const n = str.length;
          let ones = '';
          
          // For ones complement, flip every bit
          for (let i = 0; i < n; i++) {
              ones += flip(str[i]);
          }
          
          return ones;
      }

      // Helper function: Two's complement
      function twosComplement(str) {
          const n = str.length;
          let strArr = str.split('');
          
          // Traverse the string to get first '1' from the last of string
          let i;
          for (i = n - 1; i >= 0; i--) {
              if (strArr[i] == '1') break;
          }
          
          // If there exists no '1', concatenate 1 at the starting of string
          if (i == -1) return '1' + str;
          
          // Continue traversal after the position of first '1'
          for (let k = i - 1; k >= 0; k--) {
              // Just flip the values
              strArr[k] = (strArr[k] == '1') ? '0' : '1';
          }
          
          // Return the modified string
          return strArr.join('');
      }

      // Helper function: Add space for readability
      function addspace(binary) {
          const bit_len = binary.length;
          const s1 = Math.floor(bit_len / 4);
          const s2 = s1 * 4;
          const s3 = bit_len - s2;
          let res = '';
          const rem = bit_len % 4;
          const len = (rem != 0) ? s1 + 1 : s1;
          let space = 0;
          
          for (let i = 0; i < len; i++) {
              if (i == 0 && s3 != 0) {
                  for (let j = 0; j <= s3; j++) {
                      if (j !== s3) {
                          res += binary[j];
                      } else {
                          res += ' ';
                          space++;
                      }
                  }
              } else {
                  const s4 = res.length - space;
                  for (let j = 0; j <= 4; j++) {
                      if (j != 4) {
                          res += binary[s4 + j];
                      } else {
                          res += ' ';
                          space++;
                      }
                  }
              }
          }
          
          return res;
      }

      // Helper function: Binary calculation
      function bnry_cal(bnry, bits) {
          // Ensure the input is treated as a binary string
          const binary_input = String(bnry);
          const dec = parseInt(binary_input, 2);  // Convert binary to decimal
          const hex = parseInt(binary_input, 2).toString(16);  // Convert binary to hexadecimal
          const bit_len = binary_input.length;
          const bitsNum = parseInt(bits);
          const n = bitsNum - bit_len;
          
          let binary = binary_input;
          
          // Padding binary to the specified bit length
          if (dec < 0) {
              for (let i = 0; i < n; i++) {
                  if (n < bitsNum) {
                      binary = '1' + binary;
                  }
              }
          } else {
              for (let i = 0; i < n; i++) {
                  if (n < bitsNum) {
                      binary = '0' + binary;
                  }
              }
          }
          
          binary = binary.slice(-bitsNum);
          let _1s = onesComplement(binary);
          _1s = addspace(_1s);
          
          let _2s;
          if (dec === 0) {
              _2s = '0';
              for (let i = 0; i < n; i++) {
                  _2s = '0' + _2s;
              }
              _2s = addspace(_2s);
          } else {
              _2s = twosComplement(binary);
              _2s = addspace(_2s);
          }
          
          binary = addspace(binary);
          
          return {
              bits: bitsNum,
              dec: dec,
              binary: binary,
              hex: hex.toUpperCase(),
              _1s: _1s,
              _2s: _2s
          };
      }

      // Helper function: Decimal calculation
      function dec_cal(dec, bits) {
          // Convert decimal to binary
          const bnry = parseInt(dec).toString(2);
          const bitsNum = parseInt(bits);
          
          // Pad binary to the specified bit length
          const padded_bnry = bnry.padStart(bitsNum, '0');
          
          const hex = parseInt(padded_bnry, 2).toString(16);
          const _1s = onesComplement(padded_bnry);
          const _2s = twosComplement(padded_bnry);
          
          // Add space for readability
          const binary_with_space = addspace(padded_bnry);
          const _1s_with_space = addspace(_1s);
          const _2s_with_space = addspace(_2s);
          
          return {
              bits: bitsNum,
              dec: parseInt(dec),
              binary: binary_with_space,
              hex: hex.toUpperCase(),
              _1s: _1s_with_space,
              _2s: _2s_with_space
          };
      }

      // Helper function: Hexadecimal calculation
      function hex_cal(hex, bits) {
          // Convert hex to binary
          let binary = parseInt(hex, 16).toString(2);
          
          // Calculate the bit length of the binary representation
          const bit_len = binary.length;
          const bitsNum = parseInt(bits);
          const n = bitsNum - bit_len;
          
          // Padding the binary string to the specified bit length
          for (let i = 0; i < n; i++) {
              binary = '0' + binary;
          }
          
          // Ensure the binary string is exactly the specified bit length
          binary = binary.slice(-bitsNum);
          
          // Calculate one's complement
          const _1s = onesComplement(binary);
          
          // Calculate two's complement
          const _2s = twosComplement(binary);
          
          // Add spaces for readability
          const binary_with_space = addspace(binary);
          const _1s_with_space = addspace(_1s);
          const _2s_with_space = addspace(_2s);
          
          // Prepare the result object
          return {
              bits: bitsNum,
              dec: parseInt(binary, 2),  // Convert binary to decimal
              binary: binary_with_space,
              hex: hex.toUpperCase(),
              _1s: _1s_with_space,
              _2s: _2s_with_space
          };
      }

      // Main logic
      if (selection == 'distance') {
          let check = true;
          
          if (cal == 'bnry_cal') {
              if (!bnry || !/^[01]+$/.test(bnry)) {
                  check = false;
              }
          } else if (cal == 'dec_cal') {
              if (!dec || isNaN(dec)) {
                  check = false;
              }
          } else if (cal == 'hex_cal') {
              if (!hex || hex == '') {
                  check = false;
              }
          }

          let finalBits;
          if (bits == "other") {
              if (no_of_bits && !isNaN(no_of_bits)) {
                  finalBits = no_of_bits;
              } else {
                  result.error = 'Please! Check Your Input';
                  return result;
              }
          } else {
              finalBits = bits;
          }

          if (!check) {
              result.error = 'Please! Check Your Input';
              return result;
          }

          let calculationResult;
          if (cal === 'dec_cal') {
              calculationResult = dec_cal(dec, finalBits);
          } else if (cal === 'bnry_cal') {
              calculationResult = bnry_cal(bnry, finalBits);
          } else if (cal === 'hex_cal') {
              calculationResult = hex_cal(hex, finalBits);
          }

          result.tech_bit = calculationResult.bits;
          result.tech_dec = calculationResult.dec;
          result.tech_binary = calculationResult.binary;
          result.tech_hex = calculationResult.hex;
          result.tech_1s = calculationResult._1s;
          result.tech_2s = calculationResult._2s;
          
          return result;
      } else {
          // Addition/Subtraction mode
          if (no && no1 && !isNaN(no) && !isNaN(no1)) {
              let ans;
              
              if (action == '+') {
                  ans = parseInt(no, 2) + parseInt(no1, 2);
              } else {
                  ans = parseInt(no, 2) - parseInt(no1, 2);
              }
              
              if (ans < 0) {
                  ans = '-' + Math.abs(ans).toString(2);
              } else {
                  ans = Math.abs(ans).toString(2);
              }
              
              result.tech_add_sub = ans;
              result.tech_no = no;
              result.tech_no1 = no1;
              result.tech_action = action;
              
              return result;
          } else {
              result.error = 'Please! Check Your Input';
              return result;
          }
      }
  }

       /**
    * getCalculationLawOfSinesCalculator: Service Method
    * POST: /api/calculators-lol/law-of-sines-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */


      async getCalculationLawOfSinesCalculator(body) {

        let cal = body.tech_cal;
        let side_a = body.tech_side_a;
        let side_a_unit = body.tech_side_a_unit;

        let side_b = body.tech_side_b;
        let side_b_unit = body.tech_side_b_unit;

        let side_c = body.tech_side_c;
        let side_c_unit = body.tech_side_c_unit;

        let angle_a = body.tech_angle_a;
        let angle_a_unit = body.tech_angle_a_unit;

        let angle_b = body.tech_angle_b;
        let angle_b_unit = body.tech_angle_b_unit;

        let angle_c = body.tech_angle_c;
        let angle_c_unit = body.tech_angle_c_unit;


        let s_a = parseFloat(side_a);
        let s_b = parseFloat(side_b);
        let s_c = parseFloat(side_c);
        let a_a = parseFloat(angle_a);
        let a_b = parseFloat(angle_b);
        let a_c = parseFloat(angle_c);

        // Convert side units to cm
        if (!isNaN(s_a)) {
            switch (side_a_unit) {
                case 'mm': s_a = s_a / 10; break;
                case 'm': s_a = s_a / 0.01; break;
                case 'km': s_a = s_a / 0.00001; break;
                case 'in': s_a = s_a / 0.393701; break;
                case 'ft': s_a = s_a / 0.0328084; break;
                case 'yd': s_a = s_a / 0.01093613; break;
                case 'mi': s_a = s_a / 0.00000621371; break;
                case 'nmi': s_a = s_a / 0.00000539957; break;
            }
        }

        if (!isNaN(s_b)) {
            switch (side_b_unit) {
                case 'mm': s_b = s_b / 10; break;
                case 'm': s_b = s_b / 0.01; break;
                case 'km': s_b = s_b / 0.00001; break;
                case 'in': s_b = s_b / 0.393701; break;
                case 'ft': s_b = s_b / 0.0328084; break;
                case 'yd': s_b = s_b / 0.01093613; break;
                case 'mi': s_b = s_b / 0.00000621371; break;
                case 'nmi': s_b = s_b / 0.00000539957; break;
            }
        }

        if (!isNaN(s_c)) {
            switch (side_c_unit) {
                case 'mm': s_c = s_c / 10; break;
                case 'm': s_c = s_c / 0.01; break;
                case 'km': s_c = s_c / 0.00001; break;
                case 'in': s_c = s_c / 0.393701; break;
                case 'ft': s_c = s_c / 0.0328084; break;
                case 'yd': s_c = s_c / 0.01093613; break;
                case 'mi': s_c = s_c / 0.00000621371; break;
                case 'nmi': s_c = s_c / 0.00000539957; break;
            }
        }

        // Convert angle units to degrees
        if (!isNaN(a_a)) {
            switch (angle_a_unit) {
                case 'rad': a_a = a_a / 0.017453; break;
                case 'gon': a_a = a_a / 1.111; break;
                case 'tr': a_a = a_a / 0.002778; break;
                case 'arcmin': a_a = a_a / 60; break;
                case 'arcsec': a_a = a_a / 3600; break;
                case 'mrad': a_a = a_a / 17.453; break;
                case 'urad': a_a = a_a / 17453; break;
                case 'pirad': a_a = a_a / 0.005556; break;
            }
        }

        if (!isNaN(a_b)) {
            switch (angle_b_unit) {
                case 'rad': a_b = a_b / 0.017453; break;
                case 'gon': a_b = a_b / 1.111; break;
                case 'tr': a_b = a_b / 0.002778; break;
                case 'arcmin': a_b = a_b / 60; break;
                case 'arcsec': a_b = a_b / 3600; break;
                case 'mrad': a_b = a_b / 17.453; break;
                case 'urad': a_b = a_b / 17453; break;
                case 'pirad': a_b = a_b / 0.005556; break;
            }
        }

        if (!isNaN(a_c)) {
            switch (angle_c_unit) {
                case 'rad': a_c = a_c / 0.017453; break;
                case 'gon': a_c = a_c / 1.111; break;
                case 'tr': a_c = a_c / 0.002778; break;
                case 'arcmin': a_c = a_c / 60; break;
                case 'arcsec': a_c = a_c / 3600; break;
                case 'mrad': a_c = a_c / 17.453; break;
                case 'urad': a_c = a_c / 17453; break;
                case 'pirad': a_c = a_c / 0.005556; break;
            }
        }

        const result = {};

        // Helper function to convert degrees to radians
        const deg2rad = (deg) => deg * Math.PI / 180;
        // Helper function to convert radians to degrees
        const rad2deg = (rad) => rad * 180 / Math.PI;

        if (cal == 'abb' && !isNaN(s_a) && !isNaN(s_b) && !isNaN(a_b)) {
            const s1 = s_a * Math.sin(deg2rad(a_b)) / s_b;
            const angle_a_rad = Math.asin(s1);
            a_c = 180 - (rad2deg(angle_a_rad) + a_b);
            s_c = s_b * Math.sin(deg2rad(a_c)) / Math.sin(deg2rad(a_b));
            const P = s_a + s_b + s_c;
            const s_val = 0.5 * P;
            const K = Math.sqrt(s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c));
            const r = Math.sqrt(((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val);
            const R = (s_a * s_b * s_c) / (4 * K);
            
            result.tech_angle_a = isNaN(rad2deg(angle_a_rad)) ? "NaN" : rad2deg(angle_a_rad);
            result.tech_angle_b = isNaN(a_b) ? "NaN" : a_b;
            result.tech_angle_c = isNaN(a_c) ? "NaN" : a_c;
            result.tech_side_a  = isNaN(s_a) ? "NaN" : s_a;
            result.tech_side_b  = isNaN(s_b) ? "NaN" : s_b;
            result.tech_side_c  = isNaN(s_c) ? "NaN" : s_c;
            result.tech_P       = isNaN(P) ? "NaN" : P;
            result.tech_s       = isNaN(s_val) ? "NaN" : s_val;
            result.tech_K       = isNaN(K) ? "NaN" : K;
            result.tech_r       = isNaN(r) ? "NaN" : r;
            result.tech_R       = isNaN(R) ? "NaN" : R;


        } else if (cal == 'acc' && !isNaN(s_a) && !isNaN(s_c) && !isNaN(a_c)) {
            const s1 = s_a * Math.sin(deg2rad(a_c)) / s_c;
            const angle_a_rad = Math.asin(s1);
            a_b = 180 - (rad2deg(angle_a_rad) + a_c);
            s_b = s_c * Math.sin(deg2rad(a_b)) / Math.sin(deg2rad(a_c));
            const P = s_a + s_b + s_c;
            const s_val = 0.5 * P;
            const K = Math.sqrt(s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c));
            const r = Math.sqrt(((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val);
            const R = (s_a * s_b * s_c) / (4 * K);
            
            result.tech_angle_a = isNaN(rad2deg(angle_a_rad)) ? "NaN" : rad2deg(angle_a_rad);
            result.tech_angle_b = isNaN(a_b) ? "NaN" : a_b;
            result.tech_angle_c = isNaN(a_c) ? "NaN" : a_c;
            result.tech_side_a  = isNaN(s_a) ? "NaN" : s_a;
            result.tech_side_b  = isNaN(s_b) ? "NaN" : s_b;
            result.tech_side_c  = isNaN(s_c) ? "NaN" : s_c;
            result.tech_P       = isNaN(P) ? "NaN" : P;
            result.tech_s       = isNaN(s_val) ? "NaN" : s_val;
            result.tech_K       = isNaN(K) ? "NaN" : K;
            result.tech_r       = isNaN(r) ? "NaN" : r;
            result.tech_R       = isNaN(R) ? "NaN" : R;


        } else if (cal == 'aba' && !isNaN(s_a) && !isNaN(s_b) && !isNaN(a_a)) {
            const s1 = s_b * Math.sin(deg2rad(a_a)) / s_a;
            const angle_b_rad = Math.asin(s1);
            a_c = 180 - (a_a + rad2deg(angle_b_rad));
            s_c = s_a * Math.sin(deg2rad(a_c)) / Math.sin(deg2rad(a_a));
            const P = s_a + s_b + s_c;
            const s_val = 0.5 * P;
            const K = Math.sqrt(s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c));
            const r = Math.sqrt(((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val);
            const R = (s_a * s_b * s_c) / (4 * K);
            
            result.tech_angle_a = isNaN(a_a) ? "NaN" : a_a;
            result.tech_angle_b = isNaN(rad2deg(angle_b_rad)) ? "NaN" : rad2deg(angle_b_rad);
            result.tech_angle_c = isNaN(a_c) ? "NaN" : a_c;
            result.tech_side_a  = isNaN(s_a) ? "NaN" : s_a;
            result.tech_side_b  = isNaN(s_b) ? "NaN" : s_b;
            result.tech_side_c  = isNaN(s_c) ? "NaN" : s_c;
            result.tech_P       = isNaN(P) ? "NaN" : P;
            result.tech_s       = isNaN(s_val) ? "NaN" : s_val;
            result.tech_K       = isNaN(K) ? "NaN" : K;
            result.tech_r       = isNaN(r) ? "NaN" : r;
            result.tech_R       = isNaN(R) ? "NaN" : R;


        } else if (cal == 'bcc' && !isNaN(s_b) && !isNaN(s_c) && !isNaN(a_c)) {
            const s1 = s_b * Math.sin(deg2rad(a_c)) / s_c;
            const angle_b_rad = Math.asin(s1);
            a_a = 180 - (rad2deg(angle_b_rad) + a_c);
            s_a = s_c * Math.sin(deg2rad(a_a)) / Math.sin(deg2rad(a_c));
            const P = s_a + s_b + s_c;
            const s_val = 0.5 * P;
            const K = Math.sqrt(s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c));
            const r = Math.sqrt(((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val);
            const R = (s_a * s_b * s_c) / (4 * K);
            
              result.tech_angle_a = isNaN(a_a) ? "NaN" : a_a;
            result.tech_angle_b = isNaN(rad2deg(angle_b_rad)) ? "NaN" : rad2deg(angle_b_rad);
            result.tech_angle_c = isNaN(a_c) ? "NaN" : a_c;
            result.tech_side_a  = isNaN(s_a) ? "NaN" : s_a;
            result.tech_side_b  = isNaN(s_b) ? "NaN" : s_b;
            result.tech_side_c  = isNaN(s_c) ? "NaN" : s_c;
            result.tech_P       = isNaN(P) ? "NaN" : P;
            result.tech_s       = isNaN(s_val) ? "NaN" : s_val;
            result.tech_K       = isNaN(K) ? "NaN" : K;
            result.tech_r       = isNaN(r) ? "NaN" : r;
            result.tech_R       = isNaN(R) ? "NaN" : R;


        } else if (cal == 'aca' && !isNaN(s_a) && !isNaN(s_c) && !isNaN(a_a)) {
            const s1 = s_c * Math.sin(deg2rad(a_a)) / s_a;
            const angle_c_rad = Math.asin(s1);
            a_b = 180 - (a_a + rad2deg(angle_c_rad));
            s_b = s_a * Math.sin(deg2rad(a_b)) / Math.sin(deg2rad(a_a));
            const P = s_a + s_b + s_c;
            const s_val = 0.5 * P;
            const K = Math.sqrt(s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c));
            const r = Math.sqrt(((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val);
            const R = (s_a * s_b * s_c) / (4 * K);
          result.tech_angle_a = isNaN(a_a) ? "NaN" : a_a;
          result.tech_angle_b = isNaN(a_b) ? "NaN" : a_b;
          result.tech_angle_c = isNaN(rad2deg(angle_c_rad)) ? "NaN" : rad2deg(angle_c_rad);
          result.tech_side_a  = isNaN(s_a) ? "NaN" : s_a;
          result.tech_side_b  = isNaN(s_b) ? "NaN" : s_b;
          result.tech_side_c  = isNaN(s_c) ? "NaN" : s_c;
          result.tech_P       = isNaN(P) ? "NaN" : P;
          result.tech_s       = isNaN(s_val) ? "NaN" : s_val;
          result.tech_K       = isNaN(K) ? "NaN" : K;
          result.tech_r       = isNaN(r) ? "NaN" : r;
          result.tech_R       = isNaN(R) ? "NaN" : R;



        } else if (cal == 'bcb' && !isNaN(s_b) && !isNaN(s_c) && !isNaN(a_b)) {
            const s1 = s_c * Math.sin(deg2rad(a_b)) / s_b;
            const angle_c_rad = Math.asin(s1);
            a_a = 180 - (a_b + rad2deg(angle_c_rad));
            s_a = s_b * Math.sin(deg2rad(a_a)) / Math.sin(deg2rad(a_b));
            const P = s_a + s_b + s_c;
            const s_val = 0.5 * P;
            const K = Math.sqrt(s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c));
            const r = Math.sqrt(((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val);
            const R = (s_a * s_b * s_c) / (4 * K);
            
            result.tech_angle_a = isNaN(a_a) ? "NaN" : a_a;
            result.tech_angle_b = isNaN(a_b) ? "NaN" : a_b;
            result.tech_angle_c = isNaN(rad2deg(angle_c_rad)) ? "NaN" : rad2deg(angle_c_rad);
            result.tech_side_a  = isNaN(s_a) ? "NaN" : s_a;
            result.tech_side_b  = isNaN(s_b) ? "NaN" : s_b;
            result.tech_side_c  = isNaN(s_c) ? "NaN" : s_c;
            result.tech_P       = isNaN(P) ? "NaN" : P;
            result.tech_s       = isNaN(s_val) ? "NaN" : s_val;
            result.tech_K       = isNaN(K) ? "NaN" : K;
            result.tech_r       = isNaN(r) ? "NaN" : r;
            result.tech_R       = isNaN(R) ? "NaN" : R;


        } else if (cal == 'bab' && !isNaN(s_b) && !isNaN(a_a) && !isNaN(a_b)) {
            a_c = 180 - (a_a + a_b);
            s_a = s_b * Math.sin(deg2rad(a_a)) / Math.sin(deg2rad(a_b));
            s_c = s_a * Math.sin(deg2rad(a_c)) / Math.sin(deg2rad(a_a));
            const P = s_a + s_b + s_c;
            const s_val = 0.5 * P;
            const K = Math.sqrt(s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c));
            const r = Math.sqrt(((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val);
            const R = (s_a * s_b * s_c) / (4 * K);
            
            result.tech_angle_a = isNaN(a_a) ? "NaN" : a_a;
            result.tech_angle_b = isNaN(a_b) ? "NaN" : a_b;
            result.tech_angle_c = isNaN(a_c) ? "NaN" : a_c;
            result.tech_side_a  = isNaN(s_a) ? "NaN" : s_a;
            result.tech_side_b  = isNaN(s_b) ? "NaN" : s_b;
            result.tech_side_c  = isNaN(s_c) ? "NaN" : s_c;
            result.tech_P       = isNaN(P) ? "NaN" : P;
            result.tech_s       = isNaN(s_val) ? "NaN" : s_val;
            result.tech_K       = isNaN(K) ? "NaN" : K;
            result.tech_r       = isNaN(r) ? "NaN" : r;
            result.tech_R       = isNaN(R) ? "NaN" : R;


        } else if (cal == 'cac' && !isNaN(s_c) && !isNaN(a_a) && !isNaN(a_c)) {
            a_b = 180 - (a_a + a_c);
            s_a = s_c * Math.sin(deg2rad(a_a)) / Math.sin(deg2rad(a_c));
            s_b = s_a * Math.sin(deg2rad(a_b)) / Math.sin(deg2rad(a_a));
            const P = s_a + s_b + s_c;
            const s_val = 0.5 * P;
            const K = Math.sqrt(s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c));
            const r = Math.sqrt(((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val);
            const R = (s_a * s_b * s_c) / (4 * K);
            
            result.tech_angle_a = isNaN(a_a) ? "NaN" : a_a;
            result.tech_angle_b = isNaN(a_b) ? "NaN" : a_b;
            result.tech_angle_c = isNaN(a_c) ? "NaN" : a_c;
            result.tech_side_a  = isNaN(s_a) ? "NaN" : s_a;
            result.tech_side_b  = isNaN(s_b) ? "NaN" : s_b;
            result.tech_side_c  = isNaN(s_c) ? "NaN" : s_c;
            result.tech_P       = isNaN(P) ? "NaN" : P;
            result.tech_s       = isNaN(s_val) ? "NaN" : s_val;
            result.tech_K       = isNaN(K) ? "NaN" : K;
            result.tech_r       = isNaN(r) ? "NaN" : r;
            result.tech_R       = isNaN(R) ? "NaN" : R;


        } else if (cal == 'aab' && !isNaN(s_a) && !isNaN(a_a) && !isNaN(a_b)) {
            a_c = 180 - (a_a + a_b);
            s_b = s_a * Math.sin(deg2rad(a_b)) / Math.sin(deg2rad(a_a));
            s_c = s_a * Math.sin(deg2rad(a_c)) / Math.sin(deg2rad(a_a));
            const P = s_a + s_b + s_c;
            const s_val = 0.5 * P;
            const K = Math.sqrt(s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c));
            const r = Math.sqrt(((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val);
            const R = (s_a * s_b * s_c) / (4 * K);
            
            result.tech_angle_a = isNaN(a_a) ? "NaN" : a_a;
            result.tech_angle_b = isNaN(a_b) ? "NaN" : a_b;
            result.tech_angle_c = isNaN(a_c) ? "NaN" : a_c;
            result.tech_side_a  = isNaN(s_a) ? "NaN" : s_a;
            result.tech_side_b  = isNaN(s_b) ? "NaN" : s_b;
            result.tech_side_c  = isNaN(s_c) ? "NaN" : s_c;
            result.tech_P       = isNaN(P) ? "NaN" : P;
            result.tech_s       = isNaN(s_val) ? "NaN" : s_val;
            result.tech_K       = isNaN(K) ? "NaN" : K;
            result.tech_r       = isNaN(r) ? "NaN" : r;
            result.tech_R       = isNaN(R) ? "NaN" : R;


        } else if (cal == 'cbc' && !isNaN(s_c) && !isNaN(a_b) && !isNaN(a_c)) {
            a_a = 180 - (a_b + a_c);
            s_a = s_c * Math.sin(deg2rad(a_a)) / Math.sin(deg2rad(a_c));
            s_b = s_a * Math.sin(deg2rad(a_b)) / Math.sin(deg2rad(a_a));
            const P = s_a + s_b + s_c;
            const s_val = 0.5 * P;
            const K = Math.sqrt(s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c));
            const r = Math.sqrt(((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val);
            const R = (s_a * s_b * s_c) / (4 * K);
            
          result.tech_angle_a = isNaN(a_a) ? "NaN" : a_a;
          result.tech_angle_b = isNaN(a_b) ? "NaN" : a_b;
          result.tech_angle_c = isNaN(a_c) ? "NaN" : a_c;
          result.tech_side_a  = isNaN(s_a) ? "NaN" : s_a;
          result.tech_side_b  = isNaN(s_b) ? "NaN" : s_b;
          result.tech_side_c  = isNaN(s_c) ? "NaN" : s_c;
          result.tech_P       = isNaN(P) ? "NaN" : P;
          result.tech_s       = isNaN(s_val) ? "NaN" : s_val;
          result.tech_K       = isNaN(K) ? "NaN" : K;
          result.tech_r       = isNaN(r) ? "NaN" : r;
          result.tech_R       = isNaN(R) ? "NaN" : R;


        } else if (cal == 'aac' && !isNaN(s_a) && !isNaN(a_a) && !isNaN(a_c)) {
            a_b = 180 - (a_a + a_c);
            s_b = s_a * Math.sin(deg2rad(a_b)) / Math.sin(deg2rad(a_a));
            s_c = s_a * Math.sin(deg2rad(a_c)) / Math.sin(deg2rad(a_a));
            const P = s_a + s_b + s_c;
            const s_val = 0.5 * P;
            const K = Math.sqrt(s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c));
            const r = Math.sqrt(((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val);
            const R = (s_a * s_b * s_c) / (4 * K);
            
            result.tech_angle_a = isNaN(a_a) ? "NaN" : a_a;
            result.tech_angle_b = isNaN(a_b) ? "NaN" : a_b;
            result.tech_angle_c = isNaN(a_c) ? "NaN" : a_c;
            result.tech_side_a = isNaN(s_a) ? "NaN" : s_a;
            result.tech_side_b = isNaN(s_b) ? "NaN" : s_b;
            result.tech_side_c = isNaN(s_c) ? "NaN" : s_c;
            result.tech_P = isNaN(P) ? "NaN" : P;
            result.tech_s = isNaN(s_val) ? "NaN" : s_val;
            result.tech_K = isNaN(K) ? "NaN" : K;
            result.tech_r = isNaN(r) ? "NaN" : r;
            result.tech_R = isNaN(R) ? "NaN" : R;


        } else if (cal == 'bbc' && !isNaN(s_b) && !isNaN(a_b) && !isNaN(a_c)) {
            a_a = 180 - (a_b + a_c);
            s_a = s_b * Math.sin(deg2rad(a_a)) / Math.sin(deg2rad(a_b));
            s_c = s_a * Math.sin(deg2rad(a_c)) / Math.sin(deg2rad(a_a));
            const P = s_a + s_b + s_c;
            const s_val = 0.5 * P;
            const K = Math.sqrt(s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c));
            const r = Math.sqrt(((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val);
            const R = (s_a * s_b * s_c) / (4 * K);
            
          result.tech_angle_a = isNaN(a_a) ? "NaN" : a_a;
          result.tech_angle_b = isNaN(a_b) ? "NaN" : a_b;
          result.tech_angle_c = isNaN(a_c) ? "NaN" : a_c;
          result.tech_side_a = isNaN(s_a) ? "NaN" : s_a;
          result.tech_side_b = isNaN(s_b) ? "NaN" : s_b;
          result.tech_side_c = isNaN(s_c) ? "NaN" : s_c;
          result.tech_P = isNaN(P) ? "NaN" : P;
          result.tech_s = isNaN(s_val) ? "NaN" : s_val;
          result.tech_K = isNaN(K) ? "NaN" : K;
          result.tech_r = isNaN(r) ? "NaN" : r;
          result.tech_R = isNaN(R) ? "NaN" : R;


        } else {
            result.error = 'Please Check Your Input.1';
            return result;
        }
        return result;
    }


    /**
    * getCalculationLawOfCosinesCalculator: Service Method
    * POST: /api/calculators-lol/law-of-cosines-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */


  async getCalculationLawOfCosinesCalculator(body) {

     let cal = body.tech_cal;
    let side_a = body.tech_side_a;
    let side_a_unit = body.tech_side_a_unit;
    let side_b = body.tech_side_b;
    let side_b_unit = body.tech_side_b_unit;
    let side_c = body.tech_side_c;
    let side_c_unit = body.tech_side_c_unit;
    let angle_a = body.tech_angle_a;
    let angle_a_unit = body.tech_angle_a_unit;
    let angle_b = body.tech_angle_b;
    let angle_b_unit = body.tech_angle_b_unit;
    let angle_c = body.tech_angle_c;
    let angle_c_unit = body.tech_angle_c_unit;


      let s_a = parseFloat(side_a);
      let s_b = parseFloat(side_b);
      let s_c = parseFloat(side_c);
      let a_a = parseFloat(angle_a);
      let a_b = parseFloat(angle_b);
      let a_c = parseFloat(angle_c);

      // Convert side units to cm
      if (!isNaN(s_a)) {
          switch (side_a_unit) {
              case 'mm': s_a = s_a / 10; break;
              case 'm': s_a = s_a / 0.01; break;
              case 'km': s_a = s_a / 0.00001; break;
              case 'in': s_a = s_a / 0.393701; break;
              case 'ft': s_a = s_a / 0.0328084; break;
              case 'yd': s_a = s_a / 0.01093613; break;
              case 'mi': s_a = s_a / 0.00000621371; break;
              case 'nmi': s_a = s_a / 0.00000539957; break;
          }
      }

      if (!isNaN(s_b)) {
          switch (side_b_unit) {
              case 'mm': s_b = s_b / 10; break;
              case 'm': s_b = s_b / 0.01; break;
              case 'km': s_b = s_b / 0.00001; break;
              case 'in': s_b = s_b / 0.393701; break;
              case 'ft': s_b = s_b / 0.0328084; break;
              case 'yd': s_b = s_b / 0.01093613; break;
              case 'mi': s_b = s_b / 0.00000621371; break;
              case 'nmi': s_b = s_b / 0.00000539957; break;
          }
      }

      if (!isNaN(s_c)) {
          switch (side_c_unit) {
              case 'mm': s_c = s_c / 10; break;
              case 'm': s_c = s_c / 0.01; break;
              case 'km': s_c = s_c / 0.00001; break;
              case 'in': s_c = s_c / 0.393701; break;
              case 'ft': s_c = s_c / 0.0328084; break;
              case 'yd': s_c = s_c / 0.01093613; break;
              case 'mi': s_c = s_c / 0.00000621371; break;
              case 'nmi': s_c = s_c / 0.00000539957; break;
          }
      }

      // Convert angle units to degrees
      if (!isNaN(a_a)) {
          switch (angle_a_unit) {
              case 'rad': a_a = a_a / 0.017453; break;
              case 'gon': a_a = a_a / 1.111; break;
              case 'tr': a_a = a_a / 0.002778; break;
              case 'arcmin': a_a = a_a / 60; break;
              case 'arcsec': a_a = a_a / 3600; break;
              case 'mrad': a_a = a_a / 17.453; break;
              case 'urad': a_a = a_a / 17453; break;
              case 'pirad': a_a = a_a / 0.005556; break;
          }
      }

      if (!isNaN(a_b)) {
          switch (angle_b_unit) {
              case 'rad': a_b = a_b / 0.017453; break;
              case 'gon': a_b = a_b / 1.111; break;
              case 'tr': a_b = a_b / 0.002778; break;
              case 'arcmin': a_b = a_b / 60; break;
              case 'arcsec': a_b = a_b / 3600; break;
              case 'mrad': a_b = a_b / 17.453; break;
              case 'urad': a_b = a_b / 17453; break;
              case 'pirad': a_b = a_b / 0.005556; break;
          }
      }

      if (!isNaN(a_c)) {
          switch (angle_c_unit) {
              case 'rad': a_c = a_c / 0.017453; break;
              case 'gon': a_c = a_c / 1.111; break;
              case 'tr': a_c = a_c / 0.002778; break;
              case 'arcmin': a_c = a_c / 60; break;
              case 'arcsec': a_c = a_c / 3600; break;
              case 'mrad': a_c = a_c / 17.453; break;
              case 'urad': a_c = a_c / 17453; break;
              case 'pirad': a_c = a_c / 0.005556; break;
          }
      }

      const result = {};

      // Helper function to convert degrees to radians
      const deg2rad = (deg) => deg * Math.PI / 180;
      // Helper function to convert radians to degrees
      const rad2deg = (rad) => rad * 180 / Math.PI;

      if ((cal == 'aa' || cal == 'ab' || cal == 'ac') && !isNaN(s_a) && !isNaN(s_b) && !isNaN(s_c)) {
          // All three sides given - calculate all angles
          const s1 = (Math.pow(s_b, 2) + Math.pow(s_c, 2) - Math.pow(s_a, 2)) / (2 * s_b * s_c);
          const angle_a_rad = Math.acos(s1);
          
          const s2 = (Math.pow(s_a, 2) + Math.pow(s_c, 2) - Math.pow(s_b, 2)) / (2 * s_a * s_c);
          const angle_b_rad = Math.acos(s2);
          
          const s3 = (Math.pow(s_a, 2) + Math.pow(s_b, 2) - Math.pow(s_c, 2)) / (2 * s_a * s_b);
          const angle_c_rad = Math.acos(s3);
          
          const P = s_a + s_b + s_c;
          const s_val = 0.5 * P;
          const K = Math.sqrt(s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c));
          const r = Math.sqrt(((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val);
          const R = (s_a * s_b * s_c) / (4 * K);
          
        result.tech_angle_a = isNaN(rad2deg(angle_a_rad)) ? "NaN" : rad2deg(angle_a_rad);
        result.tech_angle_b = isNaN(rad2deg(angle_b_rad)) ? "NaN" : rad2deg(angle_b_rad);
        result.tech_angle_c = isNaN(rad2deg(angle_c_rad)) ? "NaN" : rad2deg(angle_c_rad);
        result.tech_side_a  = isNaN(s_a) ? "NaN" : s_a;
        result.tech_side_b  = isNaN(s_b) ? "NaN" : s_b;
        result.tech_side_c  = isNaN(s_c) ? "NaN" : s_c;
        result.tech_P       = isNaN(P) ? "NaN" : P;
        result.tech_s       = isNaN(s_val) ? "NaN" : s_val;
        result.tech_K       = isNaN(K) ? "NaN" : K;
        result.tech_r       = isNaN(r) ? "NaN" : r;
        result.tech_R       = isNaN(R) ? "NaN" : R;


      } else if (cal == 'sa' && !isNaN(s_b) && !isNaN(s_c) && !isNaN(a_a)) {
          // Two sides and included angle given - calculate third side
          s_a = Math.sqrt(Math.pow(s_b, 2) + Math.pow(s_c, 2) - 2 * s_b * s_c * Math.cos(deg2rad(a_a)));
          
          const s1 = (Math.pow(s_a, 2) + Math.pow(s_c, 2) - Math.pow(s_b, 2)) / (2 * s_a * s_c);
          const angle_b_rad = Math.acos(s1);
          
          const s2 = (Math.pow(s_a, 2) + Math.pow(s_b, 2) - Math.pow(s_c, 2)) / (2 * s_a * s_b);
          const angle_c_rad = Math.acos(s2);
          
          const P = s_a + s_b + s_c;
          const s_val = 0.5 * P;
          const K = Math.sqrt(s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c));
          const r = Math.sqrt(((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val);
          const R = (s_a * s_b * s_c) / (4 * K);
          
          result.tech_angle_a = isNaN(a_a) ? "NaN" : a_a;
          result.tech_angle_b = isNaN(rad2deg(angle_b_rad)) ? "NaN" : rad2deg(angle_b_rad);
          result.tech_angle_c = isNaN(rad2deg(angle_c_rad)) ? "NaN" : rad2deg(angle_c_rad);
          result.tech_side_a  = isNaN(s_a) ? "NaN" : s_a;
          result.tech_side_b  = isNaN(s_b) ? "NaN" : s_b;
          result.tech_side_c  = isNaN(s_c) ? "NaN" : s_c;
          result.tech_P       = isNaN(P) ? "NaN" : P;
          result.tech_s       = isNaN(s_val) ? "NaN" : s_val;
          result.tech_K       = isNaN(K) ? "NaN" : K;
          result.tech_r       = isNaN(r) ? "NaN" : r;
          result.tech_R       = isNaN(R) ? "NaN" : R;


      } else if (cal == 'sb' && !isNaN(s_a) && !isNaN(s_c) && !isNaN(a_b)) {
          // Two sides and included angle given - calculate third side
          s_b = Math.sqrt(Math.pow(s_a, 2) + Math.pow(s_c, 2) - 2 * s_a * s_c * Math.cos(deg2rad(a_b)));
          
          const s1 = (Math.pow(s_b, 2) + Math.pow(s_c, 2) - Math.pow(s_a, 2)) / (2 * s_b * s_c);
          const angle_a_rad = Math.acos(s1);
          
          const s2 = (Math.pow(s_a, 2) + Math.pow(s_b, 2) - Math.pow(s_c, 2)) / (2 * s_a * s_b);
          const angle_c_rad = Math.acos(s2);
          
          const P = s_a + s_b + s_c;
          const s_val = 0.5 * P;
          const K = Math.sqrt(s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c));
          const r = Math.sqrt(((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val);
          const R = (s_a * s_b * s_c) / (4 * K);
          
         result.tech_angle_a = isNaN(rad2deg(angle_a_rad)) ? "NaN" : rad2deg(angle_a_rad);
          result.tech_angle_b = isNaN(a_b) ? "NaN" : a_b;
          result.tech_angle_c = isNaN(rad2deg(angle_c_rad)) ? "NaN" : rad2deg(angle_c_rad);
          result.tech_side_a  = isNaN(s_a) ? "NaN" : s_a;
          result.tech_side_b  = isNaN(s_b) ? "NaN" : s_b;
          result.tech_side_c  = isNaN(s_c) ? "NaN" : s_c;
          result.tech_P       = isNaN(P) ? "NaN" : P;
          result.tech_s       = isNaN(s_val) ? "NaN" : s_val;
          result.tech_K       = isNaN(K) ? "NaN" : K;
          result.tech_r       = isNaN(r) ? "NaN" : r;
          result.tech_R       = isNaN(R) ? "NaN" : R;


      } else if (cal == 'sc' && !isNaN(s_a) && !isNaN(s_b) && !isNaN(a_c)) {
          // Two sides and included angle given - calculate third side
          s_c = Math.sqrt(Math.pow(s_a, 2) + Math.pow(s_b, 2) - 2 * s_a * s_b * Math.cos(deg2rad(a_c)));
          
          const s1 = (Math.pow(s_b, 2) + Math.pow(s_c, 2) - Math.pow(s_a, 2)) / (2 * s_b * s_c);
          const angle_a_rad = Math.acos(s1);
          
          const s2 = (Math.pow(s_a, 2) + Math.pow(s_c, 2) - Math.pow(s_b, 2)) / (2 * s_a * s_c);
          const angle_b_rad = Math.acos(s2);
          
          const P = s_a + s_b + s_c;
          const s_val = 0.5 * P;
          const K = Math.sqrt(s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c));
          const r = Math.sqrt(((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val);
          const R = (s_a * s_b * s_c) / (4 * K);
          
         result.tech_angle_a = isNaN(rad2deg(angle_a_rad)) ? "NaN" : rad2deg(angle_a_rad);
          result.tech_angle_b = isNaN(rad2deg(angle_b_rad)) ? "NaN" : rad2deg(angle_b_rad);
          result.tech_angle_c = isNaN(a_c) ? "NaN" : a_c;
          result.tech_side_a  = isNaN(s_a) ? "NaN" : s_a;
          result.tech_side_b  = isNaN(s_b) ? "NaN" : s_b;
          result.tech_side_c  = isNaN(s_c) ? "NaN" : s_c;
          result.tech_P       = isNaN(P) ? "NaN" : P;
          result.tech_s       = isNaN(s_val) ? "NaN" : s_val;
          result.tech_K       = isNaN(K) ? "NaN" : K;
          result.tech_r       = isNaN(r) ? "NaN" : r;
          result.tech_R       = isNaN(R) ? "NaN" : R;


      } else {
          result.error = 'Please! Check Your Input.';
          return result;
      }

      return result;
  }

    /**
    * getCalculationTangentLineCalculator: Service Method
    * POST: /api/calculators-lol/tangent-line-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */


  async getCalculationTangentLineCalculator(body) {
     const cal = body.tech_cal;
    const func = body.tech_func;
    const func1 = body.tech_func1;
    const point = body.tech_point;

      const result = {};

      // Helper function to sanitize and format the equation
      const sanitizeEquation = (equation) => {
          let sanitized = equation.replace(/\s/g, '');
          sanitized = sanitized.replace(/\+/g, 'plus');
          sanitized = sanitized.replace(/%20/g, '');
          sanitized = sanitized.replace(/{/g, '(');
          sanitized = sanitized.replace(/}/g, ')');
          sanitized = sanitized.replace(/e\^/g, 'exp');
          sanitized = sanitized.replace(/exp\^/g, 'exp');
          sanitized = sanitized.replace(/\^/g, '**');
          sanitized = sanitized.replace(/e\^sqrt\(x\)/g, 'exp(2*x)');
          return sanitized;
      };

      // Security check function
      const hasInvalidCharacters = (input) => {
          const regex = /<|>|&|php|print_r|print|echo|script|=|sin|cos|tan|arcsin|arccos|arctan|&|%/i;
          return regex.test(input);
      };

      try {
          if (cal === 'y' && func && point) {
              if (hasInvalidCharacters(func)) {
                  result.error = 'Please Enter Valid Input.';
                  return result;
              }

              const parem = sanitizeEquation(func);
              const check = 'y';

              // Make API call
              const response = await fetch("http://167.172.134.148/tangent_line", {
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/x-www-form-urlencoded',
                  },
                  body: new URLSearchParams({
                      equ: parem,
                      point: point,
                      check: check,
                  }),
                  timeout: 120000,
              });

              if (!response.ok) {
                  throw new Error('API request failed');
              }

              const buffer = await response.json();
              
              result.tech_point = point;
              result.tech_enter = buffer[0];
              result.tech_s1 = Math.round(buffer[1] * 1000) / 1000; // Round to 3 decimal places
              result.tech_diff = buffer[2];
              result.tech_steps = buffer[3];
              result.tech_s2 = Math.round(buffer[4] * 1000) / 1000;
              result.tech_s3 = buffer[5];
              result.tech_ans = buffer[6];

          } else if (cal === 'x' && func && point) {
              if (hasInvalidCharacters(func)) {
                  result.error = 'Please Enter Valid Input.';
                  return result;
              }

              const parem = sanitizeEquation(func);
              const check = 'x';

              // Make API call
              const response = await fetch("http://167.172.134.148/tangent_line", {
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/x-www-form-urlencoded',
                  },
                  body: new URLSearchParams({
                      equ: parem,
                      point: point,
                      check: check,
                  }),
                  timeout: 120000,
              });

              if (!response.ok) {
                  throw new Error('API request failed');
              }

              const buffer = await response.json();
              
              result.tech_point = point;
              result.tech_enter = buffer[0];
              result.tech_s1 = Math.round(buffer[1] * 1000) / 1000;
              result.tech_diff = buffer[2];
              result.tech_steps = buffer[3];
              result.tech_s2 = Math.round(buffer[4] * 1000) / 1000;
              result.tech_s3 = buffer[5];
              result.tech_ans = buffer[6];

          } else if (cal === 'xy' && func && func1 && point) {
              if (hasInvalidCharacters(func) || hasInvalidCharacters(func1)) {
                  result.error = 'Please Enter Valid Input.';
                  return result;
              }

              const parem = sanitizeEquation(func);
              const parem1 = sanitizeEquation(func1);
              const check = 'xy';

              // Make API call
              const response = await fetch("http://167.172.134.148/tangent_line", {
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/x-www-form-urlencoded',
                  },
                  body: new URLSearchParams({
                      equ: parem,
                      point: point,
                      check: check,
                      equ1: parem1,
                  }),
                  timeout: 120000,
              });

              if (!response.ok) {
                  throw new Error('API request failed');
              }

              const buffer = await response.json();
              
              result.tech_point = point;
              result.tech_enter = buffer[0];
              result.tech_enter1 = buffer[1];
              result.tech_s1 = Math.round(buffer[2] * 1000) / 1000;
              result.tech_diff = buffer[3];
              result.tech_steps = buffer[4];
              result.tech_s11 = Math.round(buffer[5] * 1000) / 1000;
              result.tech_diff1 = buffer[6];
              result.tech_steps1 = buffer[7];
              result.tech_s3 = buffer[8];
              result.tech_s4 = Math.round(buffer[9] * 1000) / 1000;
              result.tech_s5 = buffer[10];
              result.tech_ans = buffer[11];

          } else if (cal === 'r' && func && point) {
              if (hasInvalidCharacters(func)) {
                  result.error = 'Please Enter Valid Input.';
                  return result;
              }

              const parem = sanitizeEquation(func);
              const check = 'r';

              // Make API call
              const response = await fetch("http://167.172.134.148/tangent_line", {
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/x-www-form-urlencoded',
                  },
                  body: new URLSearchParams({
                      equ: parem,
                      point: point,
                      check: check,
                  }),
                  timeout: 120000,
              });

              if (!response.ok) {
                  throw new Error('API request failed');
              }

              const buffer = await response.json();
              
              result.tech_point = point;
              result.tech_enter = buffer[0];
              result.tech_s1 = Math.round(buffer[1] * 1000) / 1000;
              result.tech_diff = buffer[2];
              result.tech_steps = buffer[3];
              result.tech_x0 = buffer[4];
              result.tech_y0 = buffer[5];
              result.tech_s2 = buffer[6];
              result.tech_s3 = buffer[7];
              result.tech_s4 = buffer[8];
              result.tech_s5 = buffer[9];
              result.tech_ans = buffer[10];

          } else {
              result.error = 'Please Check Your Input.';
              return result;
          }

          return result;

      } catch (error) {
          console.error('Error in tangent line calculation:', error);
          result.error = 'Please! Check Your Input.';
          return result;
      }
  }

      /**
    * getCalculationOnesComplementCalculator: Service Method
    * POST: /api/calculators-lol/ones-complement-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */


    async getCalculationOnesComplementCalculator(body) {
      const cal = body.tech_cal;
      const dec = body.tech_dec;
      const bnry = body.tech_bnry;
      const hex = body.tech_hex;
      const bits = body.tech_bits;
      const no_of_bits = body.tech_no_of_bits;

        const result = {};

        // Security check function
        const hasInvalidCharacters = (input) => {
            const regex = /<|>|&|\/|\\\\|-|php|print_r|print|echo|script|=|sin|cos|tan|arcsin|arccos|arctan|&|%/i;
            return regex.test(input);
        };

        // Ones complement function
        const onesComplement = (str) => {
            const flip = (c) => (c == '0' ? '1' : '0');
            let ones = '';
            for (let i = 0; i < str.length; i++) {
                ones += flip(str[i]);
            }
            return ones;
        };

        // Add space function for binary formatting
        const addspace = (binary) => {
            const bit_len = binary.length;
            const s1 = Math.floor(bit_len / 4);
            const s2 = s1 * 4;
            const s3 = bit_len - s2;
            let res = '';
            const rem = bit_len % 4;
            const len = rem !== 0 ? s1 + 1 : s1;
            let space = 0;

            for (let i = 0; i < len; i++) {
                if (i == 0 && s3 != 0) {
                    for (let j = 0; j <= s3; j++) {
                        if (j !== s3) {
                            res += binary[j];
                        } else {
                            res += ' ';
                            space++;
                        }
                    }
                } else {
                    const s4 = res.length - space;
                    for (let j = 0; j <= 4; j++) {
                        if (j != 4) {
                            res += binary[s4 + j];
                        } else {
                            res += ' ';
                            space++;
                        }
                    }
                }
            }
            return res.trim();
        };

        // Binary calculation function
        const bnry_cal = (dec, bits) => {
            let binary = (dec >>> 0).toString(2);
            const hex = parseInt(binary, 2).toString(16);
            const bit_len = binary.length;
            const n = bits - bit_len;

            if (dec < 0) {
                for (let i = 0; i < n; i++) {
                    if (n < bits) {
                        binary = '1' + binary;
                    }
                }
            } else {
                for (let i = 0; i < n; i++) {
                    if (n < bits) {
                        binary = '0' + binary;
                    }
                }
            }

            binary = binary.slice(-bits);
            let _1s = onesComplement(binary);
            _1s = addspace(_1s);
            const formattedBinary = addspace(binary);

            return {
                bits: bits,
                dec: dec,
                binary: formattedBinary,
                hex: hex,
                _1s: _1s
            };
        };

        // Decimal calculation function
        const dec_cal = (bnry, bits) => {
            const dec = parseInt(bnry, 2);
            const hex = dec.toString(16);
            const bit_len = bnry.length;
            const n = bits - bit_len;
            let binary = bnry;

            if (dec < 0) {
                for (let i = 0; i < n; i++) {
                    if (n < bits) {
                        binary = '1' + binary;
                    }
                }
            } else {
                for (let i = 0; i < n; i++) {
                    if (n < bits) {
                        binary = '0' + binary;
                    }
                }
            }

            binary = binary.slice(-bits);
            let _1s = onesComplement(binary);
            _1s = addspace(_1s);
            const formattedBinary = addspace(binary);

            return {
                bits: bits,
                dec: dec,
                binary: formattedBinary,
                hex: hex,
              _1s: _1s
            };
        };

        // Hexadecimal calculation function
        const hex_cal = (hex, bits) => {
            const dec = parseInt(hex, 16);
            let binary = dec.toString(2);
            const bit_len = binary.length;
            const n = bits - bit_len;

            for (let i = 0; i < n; i++) {
                if (n < bits) {
                    binary = '0' + binary;
                }
            }

            binary = binary.slice(-bits);
            let _1s = onesComplement(binary);
            const formattedBinary = addspace(binary);
            _1s = addspace(_1s);

            return {
                bits: bits,
                dec: dec,
                binary: formattedBinary,
                hex: hex,
                _1s: _1s
            };
        };

        // Input validation
        if (hasInvalidCharacters(hex)) {
            result.error = 'Please Enter Valid Input.';
            return result;
        }

        let check = true;

        // Validate inputs based on calculation type
        if (cal == 'bnry_cal') {
            if (!dec || isNaN(parseFloat(dec))) {
                check = false;
            }
        } else if (cal == 'dec_cal') {
            if (!bnry || !/^[01]+$/.test(bnry)) {
                check = false;
            }
        } else if (cal == 'hex_cal') {
            if (!hex) {
                check = false;
            }
        }

        if (!check) {
            result.error = 'Please Check Your Input.';
            return result;
        }

        let calculationResult;

        try {
            if (cal == 'bnry_cal') {
                const decimalValue = parseFloat(dec);
                check = false;

                if (bits == '4') {
                    if (decimalValue >= -8 && decimalValue <= 7) {
                        check = true;
                        calculationResult = bnry_cal(decimalValue, 4);
                    }
                } else if (bits == '8') {
                    if (decimalValue >= -128 && decimalValue <= 127) {
                        check = true;
                        calculationResult = bnry_cal(decimalValue, 8);
                    }
                } else if (bits == '12') {
                    if (decimalValue >= -2048 && decimalValue <= 2047) {
                        check = true;
                        calculationResult = bnry_cal(decimalValue, 12);
                    }
                } else if (bits == '16') {
                    if (decimalValue >= -32768 && decimalValue <= 32767) {
                        check = true;
                        calculationResult = bnry_cal(decimalValue, 16);
                    }
                } else {
                    const customBits = parseInt(no_of_bits);
                    if (customBits > 1 && customBits < 71) {
                        const min = Math.pow(2, customBits - 1) * (-1);
                        const max = Math.pow(2, customBits - 1) - 1;
                        if (decimalValue >= min && decimalValue <= max) {
                            check = true;
                            calculationResult = bnry_cal(decimalValue, customBits);
                        }
                    } else {
                        result.error = 'Please! Enter Number in Range (2-70).';
                        return result;
                    }
                }

            } else if (cal == 'dec_cal') {
                check = false;
                const bnry_len = bnry.length;

                if (bits == '4') {
                    if (bnry_len <= 4) {
                        check = true;
                        calculationResult = dec_cal(bnry, 4);
                    }
                } else if (bits == '8') {
                    if (bnry_len <= 8) {
                        check = true;
                        calculationResult = dec_cal(bnry, 8);
                    }
                } else if (bits == '12') {
                    if (bnry_len <= 12) {
                        check = true;
                        calculationResult = dec_cal(bnry, 12);
                    }
                } else if (bits == '16') {
                    if (bnry_len <= 16) {
                        check = true;
                        calculationResult = dec_cal(bnry, 16);
                    }
                } else {
                    const customBits = parseInt(no_of_bits);
                    if (customBits > 1 && customBits < 71) {
                        if (bnry_len > 0 && bnry_len <= customBits) {
                            check = true;
                            calculationResult = dec_cal(bnry, customBits);
                        }
                    } else {
                        result.error = 'Please! Enter Number in Range (2-70).';
                        return result;
                    }
                }

            } else if (cal == 'hex_cal') {
                if (hex === '0') {
                    result.error = 'Undefined Value!';
                    return result;
                }

                const hex_len = hex.length;
                if (hex_len > 16) {
                    result.error = 'Please! Enter Number in Range.';
                    return result;
                } else {
                    check = true;
                    calculationResult = hex_cal(hex, 16);
                }

            } else {
                result.error = 'Please Check Your Input.';
                return result;
            }

        } catch (error) {
            console.error('Calculation error:', error);
            result.error = 'Please Check Your Input.';
            return result;
        }

        if (check && calculationResult) {
            result.tech_bit = calculationResult.bits;
            result.tech_dec = calculationResult.dec;
            result.tech_binary = calculationResult.binary;
            result.tech_hex = calculationResult.hex;
            result.tech_1s = calculationResult._1s;
        } else {
            result.error = 'Please! Enter Number in Range.';
        }

        return result;
    }


        /**
    * getCalculationHypotenuseCalculator: Service Method
    * POST: /api/calculators-lol/hypotenuse-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */


    async getCalculationHypotenuseCalculator(body) {
        const cal_from = body.tech_cal_from;
        const cal = body.tech_cal;
        const cal_with = body.tech_cal_with;
        const cal_with1 = body.tech_cal_with1;
        const area = body.tech_area;
        const area_unit = body.tech_area_unit;
        const a = body.tech_a;
        const a_unit = body.tech_a_unit;
        const angle_a = body.tech_angle_a;
        const angle_a_unit = body.tech_angle_a_unit;
        const b = body.tech_b;
        const b_unit = body.tech_b_unit;
        const angle_b = body.tech_angle_b;
        const angle_b_unit = body.tech_angle_b_unit;


        const result = {};

        // Helper function to convert degrees to radians
        const deg2rad = (deg) => deg * Math.PI / 180;

        let s_a = parseFloat(a);
        let s_b = parseFloat(b);
        let ang_a = parseFloat(angle_a);
        let ang_b = parseFloat(angle_b);
        let area_val = parseFloat(area);

        // Convert side a units to cm
        if (!isNaN(s_a)) {
            switch (a_unit) {
                case 'mm': s_a = s_a * 0.1; break;
                case 'm': s_a = s_a * 100; break;
                case 'km': s_a = s_a * 100000; break;
                case 'in': s_a = s_a * 2.54; break;
                case 'ft': s_a = s_a * 30.48; break;
                case 'yd': s_a = s_a * 91.44; break;
                case 'mi': s_a = s_a * 160934; break;
                case 'nmi': s_a = s_a * 185200; break;
            }
        }

        // Convert side b units to cm
        if (!isNaN(s_b)) {
            switch (b_unit) {
                case 'mm': s_b = s_b * 0.1; break;
                case 'm': s_b = s_b * 100; break;
                case 'km': s_b = s_b * 100000; break;
                case 'in': s_b = s_b * 2.54; break;
                case 'ft': s_b = s_b * 30.48; break;
                case 'yd': s_b = s_b * 91.44; break;
                case 'mi': s_b = s_b * 160934; break;
                case 'nmi': s_b = s_b * 185200; break;
            }
        }

        // Convert angle a units to degrees
        if (!isNaN(ang_a)) {
            switch (angle_a_unit) {
                case 'rad': ang_a = ang_a / 0.017453; break;
                case 'gon': ang_a = ang_a / 1.111; break;
                case 'tr': ang_a = ang_a / 0.002778; break;
                case 'arcmin': ang_a = ang_a / 60; break;
                case 'arcsec': ang_a = ang_a / 3600; break;
                case 'mrad': ang_a = ang_a / 17.453; break;
                case 'urad': ang_a = ang_a / 17453; break;
                case 'pirad': ang_a = ang_a / 0.005556; break;
            }
        }

        // Convert angle b units to degrees
        if (!isNaN(ang_b)) {
            switch (angle_b_unit) {
                case 'rad': ang_b = ang_b / 0.017453; break;
                case 'gon': ang_b = ang_b / 1.111; break;
                case 'tr': ang_b = ang_b / 0.002778; break;
                case 'arcmin': ang_b = ang_b / 60; break;
                case 'arcsec': ang_b = ang_b / 3600; break;
                case 'mrad': ang_b = ang_b / 17.453; break;
                case 'urad': ang_b = ang_b / 17453; break;
                case 'pirad': ang_b = ang_b / 0.005556; break;
            }
        }

        // Convert area units to cm²
        if (!isNaN(area_val)) {
            switch (area_unit) {
                case 'mm2': area_val = area_val * 0.01; break;
                case 'dm2': area_val = area_val * 100; break;
                case 'm2': area_val = area_val * 10000; break;
                case 'km2': area_val = area_val * 10000000000; break;
                case 'in2': area_val = area_val * 6.452; break;
                case 'ft2': area_val = area_val * 929; break;
                case 'yd2': area_val = area_val * 8361; break;
                case 'mi2': area_val = area_val * 25899881103; break;
                case 'ares': area_val = area_val * 1000000; break;
                case 'da': area_val = area_val * 10000000; break;
                case 'ha': area_val = area_val * 100000000; break;
                case 'ac': area_val = area_val * 40468560; break;
                case 's_f': area_val = area_val * 71400000; break;
            }
        }

        try {
            if (cal_from == 'two_sides' && !isNaN(s_a) && !isNaN(s_b)) {
                const s1 = Math.pow(s_a, 2);
                const s2 = Math.pow(s_b, 2);
                const s3 = s1 + s2;
                const c = Math.sqrt(s3);
                
                result.tech_two_sides = 'two_sides';
                result.tech_c = Math.round(c * 1000) / 1000;
                result.tech_a  = isNaN(s_a) ? "NaN" : s_a;
                result.tech_b  = isNaN(s_b) ? "NaN" : s_b;
                result.tech_s1 = isNaN(s1) ? "NaN" : s1;
                result.tech_s2 = isNaN(s2) ? "NaN" : s2;
                result.tech_s3 = isNaN(s3) ? "NaN" : s3;


            } else if (cal_from == 'angle_side' && cal_with == 'a_angle' && !isNaN(ang_a) && !isNaN(s_a)) {
                const s1 = Math.sin(deg2rad(ang_a));
                const c = s_a / s1;
                
                result.tech_a_angle = 'a_angle';
                result.tech_c = Math.round(c * 1000) / 1000;
                result.tech_angle_a = isNaN(ang_a) ? "NaN" : ang_a;
                result.tech_a       = isNaN(s_a) ? "NaN" : s_a;
                result.tech_s1      = isNaN(s1) ? "NaN" : s1;


            } else if (cal_from == 'angle_side' && cal_with == 'b_angle' && !isNaN(ang_b) && !isNaN(s_b)) {
                const s1 = Math.sin(deg2rad(ang_b));
                const c = s_b / s1;
                
                result.tech_b_angle = 'b_angle';
                result.tech_c = Math.round(c * 1000) / 1000;
                result.tech_angle_b = isNaN(ang_b) ? "NaN" : ang_b;
                result.tech_b       = isNaN(s_b) ? "NaN" : s_b;
                result.tech_s1      = isNaN(s1) ? "NaN" : s1;


            } else if (cal_from == 'area_side' && cal == 'hypo' && cal_with1 == 'area_a' && !isNaN(area_val) && !isNaN(s_a)) {
                const s1 = Math.pow(s_a, 2);
                const s2 = area_val * 2;
                const s3 = s2 / s_a;
                const s4 = Math.pow(s3, 2);
                const s5 = s1 + s4;
                const c = Math.sqrt(s5);
                
                result.tech_hypo_a = 'hypo_a';
                result.tech_c = Math.round(c * 1000) / 1000;
                result.tech_area = isNaN(area_val) ? "NaN" : area_val;
                result.tech_a    = isNaN(s_a) ? "NaN" : s_a;
                result.tech_s1   = isNaN(s1) ? "NaN" : s1;
                result.tech_s2   = isNaN(s2) ? "NaN" : s2;
                result.tech_s3   = isNaN(s3) ? "NaN" : s3;
                result.tech_s4   = isNaN(s4) ? "NaN" : s4;
                result.tech_s5   = isNaN(s5) ? "NaN" : s5;


            } else if (cal_from == 'area_side' && cal == 'hypo' && cal_with1 == 'area_b' && !isNaN(area_val) && !isNaN(s_b)) {
                const s1 = Math.pow(s_b, 2);
                const s2 = area_val * 2;
                const s3 = s2 / s_b;
                const s4 = Math.pow(s3, 2);
                const s5 = s1 + s4;
                const c = Math.sqrt(s5);
                
                result.tech_hypo_b = 'hypo_b';
                result.tech_c = Math.round(c * 1000) / 1000;
                result.tech_area = isNaN(area_val) ? "NaN" : area_val;
                result.tech_b    = isNaN(s_b) ? "NaN" : s_b;
                result.tech_s1   = isNaN(s1) ? "NaN" : s1;
                result.tech_s2   = isNaN(s2) ? "NaN" : s2;
                result.tech_s3   = isNaN(s3) ? "NaN" : s3;
                result.tech_s4   = isNaN(s4) ? "NaN" : s4;
                result.tech_s5   = isNaN(s5) ? "NaN" : s5;


            } else if (cal_from == 'area_side' && cal == 'area' && !isNaN(s_a) && !isNaN(s_b)) {
                const s1 = s_a * s_b;
                const area_result = s1 / 2;
                
                result.tech_area_cal = 'area_cal';
                result.tech_area = Math.round(area_result * 1000) / 1000;
                result.tech_a  = isNaN(s_a) ? "NaN" : s_a;
                result.tech_b  = isNaN(s_b) ? "NaN" : s_b;
                result.tech_s1 = isNaN(s1)  ? "NaN" : s1;


            } else if (cal_from == 'area_side' && cal == 'side_a' && !isNaN(area_val) && !isNaN(s_b)) {
                const s1 = area_val * 2;
                const a_result = s1 / s_b;
                
                result.tech_side_a = 'side_a';
                result.tech_a = Math.round(a_result * 1000) / 1000;
              result.tech_area = isNaN(area_val) ? "NaN" : area_val;
              result.tech_b    = isNaN(s_b) ? "NaN" : s_b;
              result.tech_s1   = isNaN(s1) ? "NaN" : s1;


            } else if (cal_from == 'area_side' && cal == 'side_b' && !isNaN(area_val) && !isNaN(s_a)) {
                const s1 = area_val * 2;
                const b_result = s1 / s_a;
                
                result.tech_side_b = 'side_b';
                result.tech_b = Math.round(b_result * 1000) / 1000;
              result.tech_area = isNaN(area_val) ? "NaN" : area_val;
              result.tech_a    = isNaN(s_a) ? "NaN" : s_a;
              result.tech_s1   = isNaN(s1) ? "NaN" : s1;


            } else {
                result.error = 'Please! Check Your Input.';
                return result;
            }

            return result;

        } catch (error) {
            console.error('Error in hypotenuse calculation:', error);
            result.error = 'Please! Check Your Input.';
            return result;
        }
    }

    /**
    * getCalculationAngleBetweenTwoVectorsCalculator: Service Method
    * POST: /api/calculators-lol/angle-between-two-vectors-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationAngleBetweenTwoVectorsCalculator(body) {
     const dimen = body.tech_dimen;
      const a_rep = body.tech_a_rep;
      const ax = body.tech_ax;
      const ay = body.tech_ay;
      const az = body.tech_az;
      const a1 = body.tech_a1;
      const a2 = body.tech_a2;
      const a3 = body.tech_a3;

      const b_rep = body.tech_b_rep;
      const bx = body.tech_bx;
      const by = body.tech_by;
      const bz = body.tech_bz;
      const b1 = body.tech_b1;
      const b2 = body.tech_b2;
      const b3 = body.tech_b3;

      const aa1 = body.tech_aa1;
      const aa2 = body.tech_aa2;
      const aa3 = body.tech_aa3;

      const bb1 = body.tech_bb1;
      const bb2 = body.tech_bb2;
      const bb3 = body.tech_bb3;

      const submit = body.tech_submit;


      const result = {};

      // Helper function to check if all required fields are numeric
      const areAllNumeric = (...values) => {
          return values.every(value => value != undefined && value != null && value != '' && !isNaN(parseFloat(value)));
      };

      // Helper function to round numbers
      const round = (num, decimals = 5) => {
          return Math.round(num * Math.pow(10, decimals)) / Math.pow(10, decimals);
      };

      if (!submit) {
          result.error = 'Please! Check Your Input';
          return result;
      }

      try {
          if (dimen == '3d') {
              if (a_rep == 'coor' && b_rep == 'coor') {
                  if (areAllNumeric(ax, ay, az, bx, by, bz)) {
                      const i = parseFloat(ax) * parseFloat(bx);
                      const j = parseFloat(ay) * parseFloat(by);
                      const k = parseFloat(az) * parseFloat(bz);
                      const prod = i + j + k;
                      
                      const ax2 = Math.pow(parseFloat(ax), 2);
                      const ay2 = Math.pow(parseFloat(ay), 2);
                      const az2 = Math.pow(parseFloat(az), 2);
                      const bx2 = Math.pow(parseFloat(bx), 2);
                      const by2 = Math.pow(parseFloat(by), 2);
                      const bz2 = Math.pow(parseFloat(bz), 2);
                      
                      const mgntd_a = Math.sqrt(ax2 + ay2 + az2);
                      const mgntd_b = Math.sqrt(bx2 + by2 + bz2);
                      const mgntd = mgntd_a * mgntd_b;
                      
                      const angle = prod / mgntd;
                      const theta = Math.acos(angle);
                      const deg = (theta * 180) / Math.PI;
                      
                      result.tech_i = i;
                      result.tech_j = j;
                      result.tech_k = k;
                      result.tech_ax2 = ax2;
                      result.tech_ay2 = ay2;
                      result.tech_az2 = az2;
                      result.tech_bx2 = bx2;
                      result.tech_by2 = by2;
                      result.tech_bz2 = bz2;
                      result.tech_mgntd = round(mgntd, 5);
                      result.tech_mgntd_a = round(mgntd_a, 5);
                      result.tech_mgntd_b = round(mgntd_b, 5);
                      result.tech_prod = prod;
                      result.tech_angle = round(angle, 7);
                      result.tech_deg = round(deg, 5);

                  } else {
                      result.error = 'Please Fill All The Fields';
                      return result;
                  }

              } else if (a_rep == 'coor' && b_rep == 'point') {
                  if (areAllNumeric(ax, ay, az, aa1, aa2, aa3, bb1, bb2, bb3)) {
                      const bx_val = parseFloat(bb1) - parseFloat(aa1);
                      const by_val = parseFloat(bb2) - parseFloat(aa2);
                      const bz_val = parseFloat(bb3) - parseFloat(aa3);
                      
                      const i = parseFloat(ax) * bx_val;
                      const j = parseFloat(ay) * by_val;
                      const k = parseFloat(az) * bz_val;
                      const prod = i + j + k;
                      
                      const ax2 = Math.pow(parseFloat(ax), 2);
                      const ay2 = Math.pow(parseFloat(ay), 2);
                      const az2 = Math.pow(parseFloat(az), 2);
                      const bx2 = Math.pow(bx_val, 2);
                      const by2 = Math.pow(by_val, 2);
                      const bz2 = Math.pow(bz_val, 2);
                      
                      const mgntd_a = Math.sqrt(ax2 + ay2 + az2);
                      const mgntd_b = Math.sqrt(bx2 + by2 + bz2);
                      const mgntd = mgntd_a * mgntd_b;
                      
                      if (mgntd == 0) {
                          result.error = 'Your input give 0 answer Please Fill Correct Input';
                          return result;
                      }
                      
                      const angle = prod / mgntd;
                      const theta = Math.acos(angle);
                      const deg = (theta * 180) / Math.PI;
                      
                      result.tech_i = i;
                      result.tech_j = j;
                      result.tech_k = k;
                      result.tech_bx = bx_val;
                      result.tech_by = by_val;
                      result.tech_bz = bz_val;
                      result.tech_ax2 = ax2;
                      result.tech_ay2 = ay2;
                      result.tech_az2 = az2;
                      result.tech_bx2 = bx2;
                      result.tech_by2 = by2;
                      result.tech_bz2 = bz2;
                      result.tech_mgntd = round(mgntd, 5);
                      result.tech_mgntd_a = round(mgntd_a, 5);
                      result.tech_mgntd_b = round(mgntd_b, 5);
                      result.tech_prod = prod;
                      result.tech_angle = round(angle, 7);
                      result.tech_deg = round(deg, 5);

                  } else {
                      result.error = 'Please Fill All The Fields';
                      return result;
                  }

              } else if (a_rep == 'point' && b_rep == 'coor') {
                  if (areAllNumeric(a1, a2, a3, b1, b2, b3, bx, by, bz)) {
                      const ax_val = parseFloat(b1) - parseFloat(a1);
                      const ay_val = parseFloat(b2) - parseFloat(a2);
                      const az_val = parseFloat(b3) - parseFloat(a3);
                      
                      const i = ax_val * parseFloat(bx);
                      const j = ay_val * parseFloat(by);
                      const k = az_val * parseFloat(bz);
                      const prod = i + j + k;
                      
                      const ax2 = Math.pow(ax_val, 2);
                      const ay2 = Math.pow(ay_val, 2);
                      const az2 = Math.pow(az_val, 2);
                      const bx2 = Math.pow(parseFloat(bx), 2);
                      const by2 = Math.pow(parseFloat(by), 2);
                      const bz2 = Math.pow(parseFloat(bz), 2);
                      
                      const mgntd_a = Math.sqrt(ax2 + ay2 + az2);
                      const mgntd_b = Math.sqrt(bx2 + by2 + bz2);
                      const mgntd = mgntd_a * mgntd_b;
                      
                      const angle = prod / mgntd;
                      const theta = Math.acos(angle);
                      const deg = (theta * 180) / Math.PI;
                      
                      result.tech_i = i;
                      result.tech_j = j;
                      result.tech_k = k;
                      result.tech_ax = ax_val;
                      result.tech_ay = ay_val;
                      result.tech_az = az_val;
                      result.tech_ax2 = ax2;
                      result.tech_ay2 = ay2;
                      result.tech_az2 = az2;
                      result.tech_bx2 = bx2;
                      result.tech_by2 = by2;
                      result.tech_bz2 = bz2;
                      result.tech_mgntd = round(mgntd, 5);
                      result.tech_mgntd_a = round(mgntd_a, 5);
                      result.tech_mgntd_b = round(mgntd_b, 5);
                      result.tech_prod = prod;
                      result.tech_angle = round(angle, 7);
                      result.tech_deg = round(deg, 5);

                  } else {
                      result.error = 'Please Fill All The Fields';
                      return result;
                  }

              } else if (a_rep == 'point' && b_rep == 'point') {
                  if (areAllNumeric(a1, a2, a3, b1, b2, b3, aa1, aa2, aa3, bb1, bb2, bb3)) {
                      const ax_val = parseFloat(b1) - parseFloat(a1);
                      const ay_val = parseFloat(b2) - parseFloat(a2);
                      const az_val = parseFloat(b3) - parseFloat(a3);
                      const bx_val = parseFloat(bb1) - parseFloat(aa1);
                      const by_val = parseFloat(bb2) - parseFloat(aa2);
                      const bz_val = parseFloat(bb3) - parseFloat(aa3);
                      
                      const i = ax_val * bx_val;
                      const j = ay_val * by_val;
                      const k = az_val * bz_val;
                      const prod = i + j + k;
                      
                      const ax2 = Math.pow(ax_val, 2);
                      const ay2 = Math.pow(ay_val, 2);
                      const az2 = Math.pow(az_val, 2);
                      const bx2 = Math.pow(bx_val, 2);
                      const by2 = Math.pow(by_val, 2);
                      const bz2 = Math.pow(bz_val, 2);
                      
                      const mgntd_a = Math.sqrt(ax2 + ay2 + az2);
                      const mgntd_b = Math.sqrt(bx2 + by2 + bz2);
                      const mgntd = mgntd_a * mgntd_b;
                      
                      if (mgntd == 0) {
                          result.error = 'Your input give 0 answer Please Fill Correct Input';
                          return result;
                      }
                      
                      const angle = prod / mgntd;
                      const theta = Math.acos(angle);
                      const deg = (theta * 180) / Math.PI;
                      
                      result.tech_i = i;
                      result.tech_j = j;
                      result.tech_k = k;
                      result.tech_ax = ax_val;
                      result.tech_ay = ay_val;
                      result.tech_az = az_val;
                      result.tech_bx = bx_val;
                      result.tech_by = by_val;
                      result.tech_bz = bz_val;
                      result.tech_ax2 = ax2;
                      result.tech_ay2 = ay2;
                      result.tech_az2 = az2;
                      result.tech_bx2 = bx2;
                      result.tech_by2 = by2;
                      result.tech_bz2 = bz2;
                      result.tech_mgntd = round(mgntd, 5);
                      result.tech_mgntd_a = round(mgntd_a, 5);
                      result.tech_mgntd_b = round(mgntd_b, 5);
                      result.tech_prod = prod;
                      result.tech_angle = round(angle, 7);
                      result.tech_deg = round(deg, 5);

                  } else {
                      result.error = 'Please Fill All The Fields';
                      return result;
                  }

              } else {
                  result.error = 'Please! Check Your Input';
                  return result;
              }

          } else if (dimen == '2d') {
              if (a_rep == 'coor' && b_rep == 'coor') {
                  if (areAllNumeric(ax, ay, bx, by)) {
                      const i = parseFloat(ax) * parseFloat(bx);
                      const j = parseFloat(ay) * parseFloat(by);
                      const prod = i + j;
                      
                      const ax2 = Math.pow(parseFloat(ax), 2);
                      const ay2 = Math.pow(parseFloat(ay), 2);
                      const bx2 = Math.pow(parseFloat(bx), 2);
                      const by2 = Math.pow(parseFloat(by), 2);
                      
                      const mgntd_a = Math.sqrt(ax2 + ay2);
                      const mgntd_b = Math.sqrt(bx2 + by2);
                      const mgntd = mgntd_a * mgntd_b;
                      
                      const angle = prod / mgntd;
                      const theta = Math.acos(angle);
                      const deg = (theta * 180) / Math.PI;
                      
                      result.tech_i = i;
                      result.tech_j = j;
                      result.tech_ax2 = ax2;
                      result.tech_ay2 = ay2;
                      result.tech_bx2 = bx2;
                      result.tech_by2 = by2;
                      result.tech_mgntd = round(mgntd, 5);
                      result.tech_mgntd_a = round(mgntd_a, 5);
                      result.tech_mgntd_b = round(mgntd_b, 5);
                      result.tech_prod = prod;
                      result.tech_angle = round(angle, 7);
                      result.tech_deg = round(deg, 5);

                  } else {
                      result.error = 'Please Fill All The Fields';
                      return result;
                  }

              } else if (a_rep == 'coor' && b_rep == 'point') {
                  if (areAllNumeric(ax, ay, aa1, aa2, bb1, bb2)) {
                      const bx_val = parseFloat(bb1) - parseFloat(aa1);
                      const by_val = parseFloat(bb2) - parseFloat(aa2);
                      
                      const i = parseFloat(ax) * bx_val;
                      const j = parseFloat(ay) * by_val;
                      const prod = i + j;
                      
                      const ax2 = Math.pow(parseFloat(ax), 2);
                      const ay2 = Math.pow(parseFloat(ay), 2);
                      const bx2 = Math.pow(bx_val, 2);
                      const by2 = Math.pow(by_val, 2);
                      
                      const mgntd_a = Math.sqrt(ax2 + ay2);
                      const mgntd_b = Math.sqrt(bx2 + by2);
                      const mgntd = mgntd_a * mgntd_b;
                      
                      const angle = prod / mgntd;
                      const theta = Math.acos(angle);
                      const deg = (theta * 180) / Math.PI;
                      
                      result.tech_i = i;
                      result.tech_j = j;
                      result.tech_bx = bx_val;
                      result.tech_by = by_val;
                      result.tech_ax2 = ax2;
                      result.tech_ay2 = ay2;
                      result.tech_bx2 = bx2;
                      result.tech_by2 = by2;
                      result.tech_mgntd = round(mgntd, 5);
                      result.tech_mgntd_a = round(mgntd_a, 5);
                      result.tech_mgntd_b = round(mgntd_b, 5);
                      result.tech_prod = prod;
                      result.tech_angle = round(angle, 7);
                      result.tech_deg = round(deg, 5);

                  } else {
                      result.error = 'Please Fill All The Fields';
                      return result;
                  }

              } else if (a_rep == 'point' && b_rep == 'coor') {
                  if (areAllNumeric(a1, a2, b1, b2, bx, by)) {
                      const ax_val = parseFloat(b1) - parseFloat(a1);
                      const ay_val = parseFloat(b2) - parseFloat(a2);
                      
                      const i = ax_val * parseFloat(bx);
                      const j = ay_val * parseFloat(by);
                      const prod = i + j;
                      
                      const ax2 = Math.pow(ax_val, 2);
                      const ay2 = Math.pow(ay_val, 2);
                      const bx2 = Math.pow(parseFloat(bx), 2);
                      const by2 = Math.pow(parseFloat(by), 2);
                      
                      const mgntd_a = Math.sqrt(ax2 + ay2);
                      const mgntd_b = Math.sqrt(bx2 + by2);
                      const mgntd = mgntd_a * mgntd_b;
                      
                      const angle = prod / mgntd;
                      const theta = Math.acos(angle);
                      const deg = (theta * 180) / Math.PI;
                      
                      result.tech_i = i;
                      result.tech_j = j;
                      result.tech_ax = ax_val;
                      result.tech_ay = ay_val;
                      result.tech_ax2 = ax2;
                      result.tech_ay2 = ay2;
                      result.tech_bx2 = bx2;
                      result.tech_by2 = by2;
                      result.tech_mgntd = round(mgntd, 5);
                      result.tech_mgntd_a = round(mgntd_a, 5);
                      result.tech_mgntd_b = round(mgntd_b, 5);
                      result.tech_prod = prod;
                      result.tech_angle = round(angle, 7);
                      result.tech_deg = round(deg, 5);

                  } else {
                      result.error = 'Please Fill All The Fields';
                      return result;
                  }

              } else if (a_rep == 'point' && b_rep == 'point') {
                  if (areAllNumeric(a1, a2, b1, b2, aa1, aa2, bb1, bb2)) {
                      const ax_val = parseFloat(b1) - parseFloat(a1);
                      const ay_val = parseFloat(b2) - parseFloat(a2);
                      const bx_val = parseFloat(bb1) - parseFloat(aa1);
                      const by_val = parseFloat(bb2) - parseFloat(aa2);
                      
                      const i = ax_val * bx_val;
                      const j = ay_val * by_val;
                      const prod = i + j;
                      
                      const ax2 = Math.pow(ax_val, 2);
                      const ay2 = Math.pow(ay_val, 2);
                      const bx2 = Math.pow(bx_val, 2);
                      const by2 = Math.pow(by_val, 2);
                      
                      const mgntd_a = Math.sqrt(ax2 + ay2);
                      const mgntd_b = Math.sqrt(bx2 + by2);
                      const mgntd = mgntd_a * mgntd_b;
                      
                      const angle = prod / mgntd;
                      const theta = Math.acos(angle);
                      const deg = (theta * 180) / Math.PI;
                      
                      result.tech_i = i;
                      result.tech_j = j;
                      result.tech_ax = ax_val;
                      result.tech_ay = ay_val;
                      result.tech_bx = bx_val;
                      result.tech_by = by_val;
                      result.tech_ax2 = ax2;
                      result.tech_ay2 = ay2;
                      result.tech_bx2 = bx2;
                      result.tech_by2 = by2;
                      result.tech_mgntd = round(mgntd, 5);
                      result.tech_mgntd_a = round(mgntd_a, 5);
                      result.tech_mgntd_b = round(mgntd_b, 5);
                      result.tech_prod = prod;
                      result.tech_angle = round(angle, 7);
                      result.tech_deg = round(deg, 5);

                  } else {
                      result.error = 'Please Fill All The Fields';
                      return result;
                  }

              } else {
                  result.error = 'Please! Check Your Input';
                  return result;
              }

          } else {
              result.error = 'Please! Check Your Input';
              return result;
          }

          return result;

      } catch (error) {
          console.error('Error in angle calculation:', error);
          result.error = 'Please! Check Your Input';
          return result;
      }
  }

    /**
    * getCalculationDirectionalDerivativeCalculator: Service Method
    * POST: /api/calculators-lol/directional-derivative-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationDirectionalDerivativeCalculator(body) {
          const EnterEq = body.tech_EnterEq;
        const u1 = body.tech_u1;
        const u2 = body.tech_u2;
        const u3 = body.tech_u3;
        const x = body.tech_x;
        const y = body.tech_y;
        const z = body.tech_z;
        const type = body.tech_type;


        const result = {};

        // Helper function to sanitize and format the equation
        const sanitizeEquation = (equation) => {
            let sanitized = equation.replace(/\s/g, '');
            sanitized = sanitized.replace(/%20/g, '');
            sanitized = sanitized.replace(/\+/g, 'plus');
            sanitized = sanitized.replace(/{/g, '(');
            sanitized = sanitized.replace(/}/g, ')');
            sanitized = sanitized.replace(/e\^x/g, 'exp(x)');
            sanitized = sanitized.replace(/e\^y/g, 'exp(y)');
            sanitized = sanitized.replace(/e\^z/g, 'exp(z)');
            sanitized = sanitized.replace(/e\^/g, 'exp');
            sanitized = sanitized.replace(/exp\^/g, 'exp');
            sanitized = sanitized.replace(/\^/g, '**');
            sanitized = sanitized.replace(/e\^sqrt\(x\)/g, 'exp(2*x)');
            return sanitized;
        };

        // Security check function
        const hasInvalidCharacters = (input) => {
            const regex = /<|>|&|php|print_r|print|echo|script|=|&|%/i;
            return regex.test(input);
        };

        // Helper function to check if all required fields are numeric
        const areAllNumeric = (...values) => {
            return values.every(value => value !== undefined && value !== null && value !== '' && !isNaN(parseFloat(value)));
        };

        // Helper function to round numbers
        const round = (num, decimals = 5) => {
            return Math.round(num * Math.pow(10, decimals)) / Math.pow(10, decimals);
        };

        try {
            if (type == 'two') {
                // Security check
                if (hasInvalidCharacters(EnterEq)) {
                    result.error = 'Please Enter Valid Input.';
                    return result;
                }

                // Input validation
                if (!areAllNumeric(u1, u2, x, y) || !EnterEq) {
                    result.error = 'Please! Check Your Input.';
                    return result;
                }

                const parem = sanitizeEquation(EnterEq);
                const u1_val = parseFloat(u1);
                const u2_val = parseFloat(u2);
                const x_val = parseFloat(x);
                const y_val = parseFloat(y);

                // Calculate magnitude and unit vector
                const mag = Math.sqrt(Math.pow(u1_val, 2) + Math.pow(u2_val, 2));
                const one = u1_val / mag;
                const two = u2_val / mag;

                // Make API call
                const params = new URLSearchParams({
                    equ: parem,
                    x: x_val.toString(),
                    y: y_val.toString(),
                    u1: u1_val.toString(),
                    u2: u2_val.toString(),
                    type: type
                });

                const response = await fetch(`http://167.172.134.148/direct?${params.toString()}`, {
                    method: 'GET',
                    timeout: 120000
                });

                if (!response.ok) {
                    throw new Error('API request failed');
                }

                const buffer = await response.text();
                const bufferArray = buffer.split("@@@");

                if (bufferArray.length < 5) {
                    throw new Error('Invalid response from API');
                }

                const x1 = parseFloat(bufferArray[2]);
                const y1 = parseFloat(bufferArray[3]);
                const ans = (x1 * one) + (y1 * two);

                result.tech_difs1 = bufferArray[0];
                result.tech_difs2 = bufferArray[1];
                result.tech_x1 = round(x1, 5);
                result.tech_y1 = round(y1, 5);
                result.tech_enter = bufferArray[4];
                result.tech_mag = mag;
                result.tech_ans = ans;

            } else if (type == 'three') {
                // Security check
                if (hasInvalidCharacters(EnterEq)) {
                    result.error = 'Please Enter Valid Input.';
                    return result;
                }

                // Input validation
                if (!areAllNumeric(u1, u2, u3, x, y, z) || !EnterEq) {
                    result.error = 'Please! Check Your Input.';
                    return result;
                }

                const parem = sanitizeEquation(EnterEq);
                const u1_val = parseFloat(u1);
                const u2_val = parseFloat(u2);
                const u3_val = parseFloat(u3);
                const x_val = parseFloat(x);
                const y_val = parseFloat(y);
                const z_val = parseFloat(z);

                // Calculate magnitude and unit vector
                const mag = Math.sqrt(Math.pow(u1_val, 2) + Math.pow(u2_val, 2) + Math.pow(u3_val, 2));
                const one = u1_val / mag;
                const two = u2_val / mag;
                const three = u3_val / mag;

                // Make API call
                const params = new URLSearchParams({
                    equ: parem,
                    x: x_val.toString(),
                    y: y_val.toString(),
                    z: z_val.toString(),
                    u1: u1_val.toString(),
                    u2: u2_val.toString(),
                    u3: u3_val.toString(),
                    type: type
                });

                const response = await fetch(`http://167.172.134.148/direct?${params.toString()}`, {
                    method: 'GET',
                    timeout: 120000
                });

                if (!response.ok) {
                    throw new Error('API request failed');
                }

                const buffer = await response.text();
                const bufferArray = buffer.split("@@@");

                if (bufferArray.length < 7) {
                    throw new Error('Invalid response from API');
                }

                const x1 = parseFloat(bufferArray[3]);
                const y1 = parseFloat(bufferArray[4]);
                const z1 = parseFloat(bufferArray[5]);
                const ans = (x1 * one) + (y1 * two) + (z1 * three);

                result.tech_difs1 = bufferArray[0];
                result.tech_difs2 = bufferArray[1];
                result.tech_difs3 = bufferArray[2];
                result.tech_x1 = round(x1, 5);
                result.tech_y1 = round(y1, 5);
                result.tech_z1 = round(z1, 5);
                result.tech_enter = bufferArray[6];
                result.tech_mag = mag;
                result.tech_ans = ans;

            } else {
                result.error = 'Please! Check Your Input.';
                return result;
            }

            return result;

        } catch (error) {
            console.error('Error in directional derivative calculation:', error);
            result.error = 'Please! Check Your Input.';
            return result;
        }
    }


        /**
    * getCalculationEigenvaluesCalculator: Service Method
    * POST: /api/calculators-lol/eigenvalues-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationEigenvaluesCalculator(body) {
         const matrix = body.tech_matrix;

        const matrix_0_0 = body.tech_matrix_0_0;
        const matrix_0_1 = body.tech_matrix_0_1;
        const matrix_0_2 = body.tech_matrix_0_2;
        const matrix_0_3 = body.tech_matrix_0_3;
        const matrix_0_4 = body.tech_matrix_0_4;

        const matrix_1_0 = body.tech_matrix_1_0;
        const matrix_1_1 = body.tech_matrix_1_1;
        const matrix_1_2 = body.tech_matrix_1_2;
        const matrix_1_3 = body.tech_matrix_1_3;
        const matrix_1_4 = body.tech_matrix_1_4;

        const matrix_2_0 = body.tech_matrix_2_0;
        const matrix_2_1 = body.tech_matrix_2_1;
        const matrix_2_2 = body.tech_matrix_2_2;
        const matrix_2_3 = body.tech_matrix_2_3;
        const matrix_2_4 = body.tech_matrix_2_4;

        const matrix_3_0 = body.tech_matrix_3_0;
        const matrix_3_1 = body.tech_matrix_3_1;
        const matrix_3_2 = body.tech_matrix_3_2;
        const matrix_3_3 = body.tech_matrix_3_3;
        const matrix_3_4 = body.tech_matrix_3_4;

        const matrix_4_0 = body.tech_matrix_4_0;
        const matrix_4_1 = body.tech_matrix_4_1;
        const matrix_4_2 = body.tech_matrix_4_2;
        const matrix_4_3 = body.tech_matrix_4_3;
        const matrix_4_4 = body.tech_matrix_4_4;


        const result = {};

        // Helper function to check if all required fields are numeric
        const areAllNumeric = (...values) => {
            return values.every(value => value !== undefined && value !== null && value !== '' && !isNaN(parseFloat(value)));
        };

        try {
            if (matrix == '2' && areAllNumeric(matrix_0_0, matrix_0_1, matrix_1_0, matrix_1_1)) {
                const params = new URLSearchParams({
                    matrix: matrix,
                    matrix_0_0: matrix_0_0.toString(),
                    matrix_0_1: matrix_0_1.toString(),
                    matrix_1_0: matrix_1_0.toString(),
                    matrix_1_1: matrix_1_1.toString()
                });

                const response = await fetch(`http://167.172.134.148/eigenvalues?${params.toString()}`, {
                    method: 'GET',
                    timeout: 120000
                });

                if (!response.ok) {
                    throw new Error('API request failed');
                }

                const buffer = await response.text();
                const bufferArray = buffer.split("@@@");

                if (bufferArray.length < 5) {
                    throw new Error('Invalid response from API');
                }

                result.tech_eigvals = bufferArray[0];
                result.tech_d = bufferArray[1];
                result.tech_dtrmnt = bufferArray[2];
                result.tech_l1 = bufferArray[3];
                result.tech_l2 = bufferArray[4];

            } else if (matrix == '3' && areAllNumeric(
                matrix_0_0, matrix_0_1, matrix_0_2,
                matrix_1_0, matrix_1_1, matrix_1_2,
                matrix_2_0, matrix_2_1, matrix_2_2
            )) {
                const params = new URLSearchParams({
                    matrix: matrix,
                    matrix_0_0: matrix_0_0.toString(),
                    matrix_0_1: matrix_0_1.toString(),
                    matrix_0_2: matrix_0_2.toString(),
                    matrix_1_0: matrix_1_0.toString(),
                    matrix_1_1: matrix_1_1.toString(),
                    matrix_1_2: matrix_1_2.toString(),
                    matrix_2_0: matrix_2_0.toString(),
                    matrix_2_1: matrix_2_1.toString(),
                    matrix_2_2: matrix_2_2.toString()
                });

                const response = await fetch(`http://167.172.134.148/eigenvalues?${params.toString()}`, {
                    method: 'GET',
                    timeout: 120000
                });

                if (!response.ok) {
                    throw new Error('API request failed');
                }

                const buffer = await response.text();
                const bufferArray = buffer.split("@@@");

                if (bufferArray.length < 6) {
                    throw new Error('Invalid response from API');
                }

                result.tech_eigvals = bufferArray[0];
                result.tech_d = bufferArray[1];
                result.tech_dtrmnt = bufferArray[2];
                result.tech_l1 = bufferArray[3];
                result.tech_l2 = bufferArray[4];
                result.tech_l3 = bufferArray[5];

            } else if (matrix == '4' && areAllNumeric(
                matrix_0_0, matrix_0_1, matrix_0_2, matrix_0_3,
                matrix_1_0, matrix_1_1, matrix_1_2, matrix_1_3,
                matrix_2_0, matrix_2_1, matrix_2_2, matrix_2_3,
                matrix_3_0, matrix_3_1, matrix_3_2, matrix_3_3
            )) {
                const params = new URLSearchParams({
                    matrix: matrix,
                    matrix_0_0: matrix_0_0.toString(),
                    matrix_0_1: matrix_0_1.toString(),
                    matrix_0_2: matrix_0_2.toString(),
                    matrix_0_3: matrix_0_3.toString(),
                    matrix_1_0: matrix_1_0.toString(),
                    matrix_1_1: matrix_1_1.toString(),
                    matrix_1_2: matrix_1_2.toString(),
                    matrix_1_3: matrix_1_3.toString(),
                    matrix_2_0: matrix_2_0.toString(),
                    matrix_2_1: matrix_2_1.toString(),
                    matrix_2_2: matrix_2_2.toString(),
                    matrix_2_3: matrix_2_3.toString(),
                    matrix_3_0: matrix_3_0.toString(),
                    matrix_3_1: matrix_3_1.toString(),
                    matrix_3_2: matrix_3_2.toString(),
                    matrix_3_3: matrix_3_3.toString()
                });

                const response = await fetch(`http://167.172.134.148/eigenvalues?${params.toString()}`, {
                    method: 'GET',
                    timeout: 120000
                });

                if (!response.ok) {
                    throw new Error('API request failed');
                }

                const buffer = await response.text();
                const bufferArray = buffer.split("@@@");

                if (bufferArray.length < 7) {
                    throw new Error('Invalid response from API');
                }

                result.tech_eigvals = bufferArray[0];
                result.tech_d = bufferArray[1];
                result.tech_dtrmnt = bufferArray[2];
                result.tech_l1 = bufferArray[3];
                result.tech_l2 = bufferArray[4];
                result.tech_l3 = bufferArray[5];
                result.tech_l4 = bufferArray[6];

            } else if (matrix == '5' && areAllNumeric(
                matrix_0_0, matrix_0_1, matrix_0_2, matrix_0_3, matrix_0_4,
                matrix_1_0, matrix_1_1, matrix_1_2, matrix_1_3, matrix_1_4,
                matrix_2_0, matrix_2_1, matrix_2_2, matrix_2_3, matrix_2_4,
                matrix_3_0, matrix_3_1, matrix_3_2, matrix_3_3, matrix_3_4,
                matrix_4_0, matrix_4_1, matrix_4_2, matrix_4_3, matrix_4_4
            )) {
                const params = new URLSearchParams({
                    matrix: matrix,
                    matrix_0_0: matrix_0_0.toString(),
                    matrix_0_1: matrix_0_1.toString(),
                    matrix_0_2: matrix_0_2.toString(),
                    matrix_0_3: matrix_0_3.toString(),
                    matrix_0_4: matrix_0_4.toString(),
                    matrix_1_0: matrix_1_0.toString(),
                    matrix_1_1: matrix_1_1.toString(),
                    matrix_1_2: matrix_1_2.toString(),
                    matrix_1_3: matrix_1_3.toString(),
                    matrix_1_4: matrix_1_4.toString(),
                    matrix_2_0: matrix_2_0.toString(),
                    matrix_2_1: matrix_2_1.toString(),
                    matrix_2_2: matrix_2_2.toString(),
                    matrix_2_3: matrix_2_3.toString(),
                    matrix_2_4: matrix_2_4.toString(),
                    matrix_3_0: matrix_3_0.toString(),
                    matrix_3_1: matrix_3_1.toString(),
                    matrix_3_2: matrix_3_2.toString(),
                    matrix_3_3: matrix_3_3.toString(),
                    matrix_3_4: matrix_3_4.toString(),
                    matrix_4_0: matrix_4_0.toString(),
                    matrix_4_1: matrix_4_1.toString(),
                    matrix_4_2: matrix_4_2.toString(),
                    matrix_4_3: matrix_4_3.toString(),
                    matrix_4_4: matrix_4_4.toString()
                });

                const response = await fetch(`http://167.172.134.148/eigenvalues?${params.toString()}`, {
                    method: 'GET',
                    timeout: 120000
                });

                if (!response.ok) {
                    throw new Error('API request failed');
                }

                const buffer = await response.text();
                const bufferArray = buffer.split("@@@");

                if (bufferArray.length < 8) {
                    throw new Error('Invalid response from API');
                }

                result.tech_eigvals = bufferArray[0];
                result.tech_d = bufferArray[1];
                result.tech_dtrmnt = bufferArray[2];
                result.tech_l1 = bufferArray[3];
                result.tech_l2 = bufferArray[4];
                result.tech_l3 = bufferArray[5];
                result.tech_l4 = bufferArray[6];
                result.tech_l5 = bufferArray[7];

            } else {
                result.error = 'Please! Check Your Input.';
                return result;
            }

            return result;

        } catch (error) {
            console.error('Error in eigenvalues calculation:', error);
            result.error = 'Please! Check Your Input.';
            return result;
        }
    }

     /**
    * getCalculationEquationOfCircleCalculator: Service Method
    * POST: /api/calculators-lol/equation-of-a-circle
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */
    async getCalculationEquationOfCircleCalculator(body) {
        const from = body.tech_from;
        const a = body.tech_a;
        const b = body.tech_b;
        const c = body.tech_c;

        const x1 = body.tech_x1;
        const y1 = body.tech_y1;
        const r = body.tech_r;

        const h1 = body.tech_h1;
        const k1 = body.tech_k1;


        const result = {};

        // Helper function to check if all required fields are numeric
        const areAllNumeric = (...values) => {
            return values.every(value => value !== undefined && value !== null && value !== '' && !isNaN(parseFloat(value)));
        };

        // Helper function to format numbers to 2 decimal places
        const formatNumber = (num) => {
            return Math.round(num * 100) / 100;
        };

        try {
            let A, B, C, D, E, F, radius, diameter, sq_radius, area, circumference, eccentricity, d1, d2, r1, r2;

            if (from === "1") {
                if (areAllNumeric(a, b, c)) {
                    const c_val = parseFloat(c);
                    if (c_val > 0) {
                        radius = Math.sqrt(c_val);
                        diameter = 2 * radius;
                        sq_radius = Math.pow(radius, 2);
                        area = sq_radius * Math.PI;
                        circumference = diameter * Math.PI;
                        A = parseFloat(a);
                        B = parseFloat(b);
                        C = c_val;
                        D = A * -2;
                        E = B * -2;
                        const F_f1 = Math.pow(A, 2);
                        const F_f2 = Math.pow(B, 2);
                        const F_f3 = F_f1 + F_f2;
                        F = F_f3 - c_val;
                        d1 = A - radius;
                        d2 = A + radius;
                        r1 = B - radius;
                        r2 = B + radius;
                        eccentricity = 0;
                    } else {
                        result.error = 'Such circle (C) does not exist.';
                        return result;
                    }
                } else {
                    result.error = 'Please! Check Your Input.';
                    return result;
                }

            } else if (from === "2") {
                if (areAllNumeric(a, b, c)) {
                    radius = parseFloat(c);
                    diameter = 2 * radius;
                    sq_radius = Math.pow(radius, 2);
                    area = sq_radius * Math.PI;
                    circumference = diameter * Math.PI;
                    eccentricity = 0;
                    A = parseFloat(a);
                    B = parseFloat(b);
                    C = radius;
                    D = A * -2;
                    E = B * -2;
                    const F_f1 = Math.pow(A, 2);
                    const F_f2 = Math.pow(B, 2);
                    const F_f3 = F_f1 + F_f2;
                    F = F_f3 - sq_radius;
                    d1 = A - radius;
                    d2 = A + radius;
                    r1 = B - radius;
                    r2 = B + radius;
                } else {
                    result.error = 'Please check your input.';
                    return result;
                }

            } else if (from === "3") {
                if (areAllNumeric(a, b, c)) {
                    A = parseFloat(a) / -2;
                    B = parseFloat(b) / -2;
                    C = parseFloat(c);
                    D = parseFloat(a);
                    E = parseFloat(b);
                    F = parseFloat(c);
                    const D2 = D / 2;
                    const D2_sq = Math.pow(D2, 2);
                    const E2 = E / 2;
                    const E2_sq = Math.pow(E2, 2);
                    const plus = D2_sq + E2_sq;
                    const sq_root = plus - F;
                    radius = Math.sqrt(sq_root);
                    diameter = 2 * radius;
                    sq_radius = Math.pow(radius, 2);
                    area = sq_radius * Math.PI;
                    circumference = diameter * Math.PI;
                    eccentricity = 0;
                    d1 = A - radius;
                    d2 = A + radius;
                    r1 = B - radius;
                    r2 = B + radius;
                } else {
                    result.error = 'Please check your input.';
                    return result;
                }

            } else if (from === "4") {
                if (areAllNumeric(x1, y1)) {
                    const r_val = parseFloat(r);
                    if (r_val > 0) {
                        A = parseFloat(x1);
                        B = parseFloat(y1);
                        radius = r_val;
                        sq_radius = Math.pow(radius, 2);
                        C = parseFloat(c);
                        D = A * -2;
                        E = B * -2;
                        const F_f1 = Math.pow(x1, 2);
                        const F_f2 = Math.pow(y1, 2);
                        const F_f3 = F_f1 + F_f2;
                        F = F_f3 - sq_radius;
                        diameter = 2 * radius;
                        area = sq_radius * Math.PI;
                        circumference = diameter * Math.PI;
                        eccentricity = 0;
                        d1 = A - radius;
                        d2 = B + radius;
                        r1 = A - radius;
                        r2 = B + radius;
                    } else {
                        result.error = 'Such circle (r) does not exist.';
                        return result;
                    }
                } else {
                    result.error = 'Please check your input.';
                    return result;
                }

            } else if (from === "5") {
                if (areAllNumeric(x1, y1, h1, k1)) {
                    A = parseFloat(x1);
                    B = parseFloat(y1);
                    const ans1 = A - parseFloat(h1);
                    const ans1_sq = Math.pow(ans1, 2);
                    const ans2 = B - parseFloat(k1);
                    const ans2_sq = Math.pow(ans2, 2);
                    const plus = ans1_sq + ans2_sq;
                    radius = Math.sqrt(plus);
                    sq_radius = Math.pow(radius, 2);
                    C = parseFloat(c);
                    D = A * -2;
                    E = B * -2;
                    const F_f1 = Math.pow(A, 2);
                    const F_f2 = Math.pow(B, 2);
                    const F_f3 = F_f1 + F_f2;
                    F = F_f3 - sq_radius;
                    diameter = 2 * radius;
                    area = sq_radius * Math.PI;
                    circumference = diameter * Math.PI;
                    eccentricity = 0;
                    d1 = A - radius;
                    d2 = B + radius;
                    r1 = parseFloat(h1) - radius;
                    r2 = parseFloat(k1) + radius;
                } else {
                    result.error = 'Please check your input.';
                    return result;
                }

            } else {
                result.error = 'Please! Check Your Input.';
                return result;
            }

            // Format numbers to 2 decimal places
            result.tech_A = formatNumber(A);
            result.tech_B = formatNumber(B);
            result.tech_C = formatNumber(C);
            result.tech_E = formatNumber(E);
            result.tech_D = formatNumber(D);
            result.tech_F = formatNumber(F);
            result.tech_d1 = formatNumber(d1);
            result.tech_d2 = formatNumber(d2);
            result.tech_r1 = formatNumber(r1);
            result.tech_r2 = formatNumber(r2);
            result.tech_radius = formatNumber(radius);
            result.tech_area = formatNumber(area);
            result.tech_diameter = formatNumber(diameter);
            result.tech_circumference = formatNumber(circumference);
            result.tech_eccentricity = formatNumber(eccentricity);

            return result;

        } catch (error) {
            console.error('Error in equation of circle calculation:', error);
            result.error = 'Please! Check Your Input.';
            return result;
        }
    }


      /**
    * getCalculationGaussianEliminationCalculator: Service Method
    * POST: /api/calculators-lol/gaussian-elimination-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */


      async getCalculationGaussianEliminationCalculator(body) {
          const { matrix2, matrix22, ...request } = body;
          const result = {};

          // Helper function for GCD calculation
          const gcd22 = (a, b, f) => {
              if (f) {
                  if (b <= 1) return a;
              } else {
                  if (!b) return a;
              }
              return gcd22(b, a % b, f);
          };

          // Helper function to round numbers with precision
          const toPrecision2 = (number, precision) => {
              if (number == 0) return 0;
              const exponent = Math.floor(Math.log10(Math.abs(number))) + 1;
              const significand = Math.round((number / Math.pow(10, exponent)) * Math.pow(10, precision)) / Math.pow(10, precision);
              return significand * Math.pow(10, exponent);
          };

          // Helper function to round numbers
          const roundnum2 = (x, p) => {
              const n = parseFloat(x);
              const m = toPrecision2(n, p + 1);
              const y = m.toString();
              return y;
          };

          // Helper function to round results
          const roundresult2 = (x) => {
              const y = parseFloat(x);
              return roundnum2(y, 10);
          };

          // Helper function to count digits after decimal point
          const digits_after_period2 = (x) => {
              const f = x.toString();
              const i = f.indexOf('.');
              if (i == -1) return 0;
              return f.length - i - 1;
          };

          // Helper function to convert decimal to fraction
          const convert2 = (xelem) => {
              let sign = '';
              let sign2 = '+';
              let f = false;
              const x = xelem;
              const x2 = roundresult2(x);
              const absx = Math.abs(x2);
              const y = Math.floor(absx);
              const frac = absx - y;

              if (x2 < 0) {
                  sign = sign2 = '-';
              }

              const d = digits_after_period2(absx);
              const den = Math.round(Math.pow(10, d));
              const num = Math.round(frac * den);
              const a12 = num.toString();
              const len = a12.length;

              if (len > 8) f = true;

              const g = gcd22(num, den, f);
              const num2 = Math.round(num / g);
              const den2 = Math.round(den / g);

              const top_jawab = sign + (num2 + den2 * y);
              const down_jawab = den2;

              return [top_jawab, down_jawab];
          };

          // Main RREF function - FIXED ROW INDEXING
          const rref2 = (matrix) => {
              let lead = 0;
              let pz = matrix.map(row => [...row]); // Create a deep copy
              const swap = [];
              const swap_line = [];
              const rowCount = matrix.length;

              if (rowCount === 0) return matrix;

              let columnCount = 0;
              if (matrix[0]) {
                  columnCount = matrix[0].length;
              }

              let bus;
              if (rowCount > columnCount) {
                  bus = rowCount - 2;
              } else if (rowCount < columnCount) {
                  bus = rowCount;
              } else if (rowCount == columnCount) {
                  bus = rowCount - 1;
              }

              for (let r = 0; r < bus; r++) {
                  if (lead >= columnCount) break;

                  // Find pivot row
                  let i = r;
                  while (matrix[i][lead] == 0) {
                      i++;
                      if (i == rowCount) {
                          i = r;
                          lead++;
                          if (lead == columnCount) return [matrix, swap, swap_line, pz];
                      }
                  }

                  // Swap rows if needed
                  if (i != r) {
                      [matrix[r], matrix[i]] = [matrix[i], matrix[r]];
                      [pz[r], pz[i]] = [pz[i], pz[r]];
                      
                      // FIXED: Use 0-based indexing for row numbers
                      swap_line.push(`Swap the row ${r} with row ${i}`);
                      swap.push(pz.map(row => [...row]));
                  }

                  // Normalize pivot row
                  const lv = matrix[r][lead];
                  if (lv != 0) {
                      for (let j = 0; j < columnCount; j++) {
                          matrix[r][j] = matrix[r][j] / lv;
                          pz[r][j] = pz[r][j] / lv;
                      }

                      const test1 = convert2(lv);
                      if (test1[1] == 1) {
                          // FIXED: Use 0-based indexing for row numbers
                          swap_line.push(`Divide row ${r} by ${lv}: R<sub>${r}</sub> = R<sub>${r}</sub>/${lv}`);
                      } else if (test1[1] != 1) {
                          const lv3 = `${test1[1]}/${test1[0]}`;
                          // FIXED: Use 0-based indexing for row numbers
                          swap_line.push(`Multiply row ${r} by ${lv3}: R<sub>${r}</sub> = ${lv3} R<sub>${r}</sub>`);
                      }
                      swap.push(pz.map(row => [...row]));
                  }

                  // Eliminate other rows
                  for (let i = 0; i < rowCount; i++) {
                      if (i != r) {
                          const lv = matrix[i][lead];
                          const lv2 = pz[i][lead];
                          
                          for (let j = 0; j < columnCount; j++) {
                              matrix[i][j] -= lv * matrix[r][j];
                              pz[i][j] -= lv2 * pz[r][j];
                          }

                          swap.push(pz.map(row => [...row]));
                          const test = convert2(lv);
                          
                          let displayLv = lv;
                          if (test[1] != 1) {
                              displayLv = `${test[0]}/${test[1]}`;
                          }

                          // FIXED: Use 0-based indexing for row numbers
                          if (lv < 0) {
                              swap_line.push(`Add row ${i} multiplied by ${displayLv} from row R${r}: R<sub>${i}</sub> = R<sub>${i}</sub> + ${displayLv}R<sub>${r}</sub>`);
                          } else if (lv >= 0) {
                              swap_line.push(`Subtract row ${i} multiplied by ${displayLv} from row R${r}: R<sub>${i}</sub> = R<sub>${i}</sub> - ${displayLv}R<sub>${r}</sub>`);
                          }
                      }
                  }
                  lead++;
              }

              return [matrix, swap, swap_line, pz];
          };

          try {
              // Validate matrix dimensions
              const rows = parseInt(matrix2);
              const cols = parseInt(matrix22);

              if (isNaN(rows) || isNaN(cols) || rows <= 0 || cols <= 0) {
                  result.error = 'Please! Check Your Input.';
                  return result;
              }

              // Extract matrix data from request
              const second_matrix = [];
              for (let i = 1; i <= rows; i++) {
                  for (let j = 1; j <= cols; j++) {
                      const key = `matrix3${i}_${j}`;
                      const value = request[key];
                      
                      if (value == undefined || value == null || value == '' || isNaN(parseFloat(value))) {
                          result.error = 'Please! Check Your Input.';
                          return result;
                      }
                      
                      second_matrix.push(parseFloat(value));
                  }
              }

              // Convert flat array to 2D matrix
              const zain = [];
              for (let i = 0; i < rows; i++) {
                  zain.push(second_matrix.slice(i * cols, (i + 1) * cols));
              }

              // Perform Gaussian elimination
              const fahad2 = rref2(zain);

              result.tech_matrix = fahad2[0];
              result.tech_swap = fahad2[1];
              result.tech_swap_line = fahad2[2];
              result.tech_pz = fahad2[3];

              return result;

          } catch (error) {
              console.error('Error in Gaussian elimination calculation:', error);
              result.error = 'Please! Check Your Input.';
              return result;
          }
      }

        /**
    * getCalculationFinalGradeCalculator: Service Method
    * POST: /api/calculators-lol/final-grade-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */


     async getCalculationFinalGradeCalculator(body) {
       const selection = body.tech_selection;

      const current_grade = body.tech_current_grade;
      const final_exam_grade1 = body.tech_final_exam_grade1;
      const final_exam_grade2 = body.tech_final_exam_grade2;
      const final_exam_weight = body.tech_final_exam_weight;

      const grading_system = body.tech_grading_system;

      const current_grade3 = body.tech_current_grade3;
      const target_grade3 = body.tech_target_grade3;

      const current_grade4 = body.tech_current_grade4;
      const target_grade4 = body.tech_target_grade4;

      const current_grade5 = body.tech_current_grade5;
      const target_grade5 = body.tech_target_grade5;

      const current_grade6 = body.tech_current_grade6;
      const target_grade6 = body.tech_target_grade6;

      const current_grade7 = body.tech_current_grade7;
      const target_grade7 = body.tech_target_grade7;

      const current_grade8 = body.tech_current_grade8;
      const target_grade8 = body.tech_target_grade8;

      const current_grade9 = body.tech_current_grade9;
      const target_grade9 = body.tech_target_grade9;

      const current_grade2 = body.tech_current_grade2;
      const final_exam_weight2 = body.tech_final_exam_weight2;
      const target_grade2 = body.tech_target_grade2;
      const total_weight2 = body.tech_total_weight2;
      const final_exam_weight3 = body.tech_final_exam_weight3;

      const type = body.tech_type;
      const pollard = body.tech_pollard;

      const current_letter = body.tech_current_letter;
      const target_letter = body.tech_target_letter;

      const grade_was = body.tech_grade_was;
      const worth = body.tech_worth;
      const you_want = body.tech_you_want;
      const grading_system2 = body.tech_grading_system2;

      const grade_was2 = body.tech_grade_was2;
      const c = body.tech_c;
      const undertaker = body.tech_undertaker;

      const grade_was3 = body.tech_grade_was3;
      const c2 = body.tech_c2;
      const undertaker2 = body.tech_undertaker2;

      const grade_was4 = body.tech_grade_was4;
      const c3 = body.tech_c3;
      const undertaker3 = body.tech_undertaker3;

      const grade_was5 = body.tech_grade_was5;
      const c4 = body.tech_c4;
      const undertaker4 = body.tech_undertaker4;

      const grade_was6 = body.tech_grade_was6;
      const c5 = body.tech_c5;
      const undertaker5 = body.tech_undertaker5;

      const grade_was7 = body.grade_was7;
      const c6 = body.tech_c6;
      const undertaker6 = body.tech_undertaker6;

      const grade_was8 = body.tech_grade_was8;
      const c7 = body.tech_c7;
      const undertaker7 = body.tech_undertaker7;


        const result = {};

        // Helper functions for grade conversion
        const boom1 = (parameter) => {
            const grades = {
                "A+": 9825, "A": 9450, "A-": 9100, "B+": 8800, "B": 8450, "B-": 8100,
                "C+": 7800, "C": 7450, "C-": 7100, "D+": 6800, "D": 6450, "D-": 6100,
                "F": 2975, "No grade (0)": 0
            };
            return grades[parameter] || 0;
        };

        const USAstd = (grade) => {
            if (grade > 10000) {
                return "I am sorry, but with your current grades it is impossible to get the grade you want.";
            } else if (grade >= 9637) {
                return "A+";
            } else if (grade >= 9275) {
                return "A";
            } else if (grade >= 8950) {
                return "A-";
            } else if (grade >= 8625) {
                return "B+";
            } else if (grade >= 8275) {
                return "B";
            } else if (grade >= 7950) {
                return "B-";
            } else if (grade >= 7625) {
                return "C+";
            } else if (grade >= 7275) {
                return "C";
            } else if (grade >= 6950) {
                return "C-";
            } else if (grade >= 6625) {
                return "D+";
            } else if (grade >= 6275) {
                return "D";
            } else if (grade >= 4537) {
                return "D-";
            } else if (grade >= 0) {
                return "F";
            } else {
                return "CONGRATULATIONS!! No matter what you do, you will get your desired grade or higher! Just check the requirements of your particular subject";
            }
        };

        const boom2 = (parameter2) => {
            const grades = {
                "A": 9500, "B": 8450, "C": 7450, "D": 6450, "E/F": 2950, "No grade (0)": 0
            };
            return grades[parameter2] || 0;
        };

        const USAnormal = (grade) => {
            if (grade > 10000) {
                return "I am sorry, but with your current grades it is impossible to get the grade you want.";
            } else if (grade >= 8975) {
                return "A";
            } else if (grade >= 7950) {
                return "B";
            } else if (grade >= 6950) {
                return "C";
            } else if (grade >= 4700) {
                return "D";
            } else if (grade >= 0) {
                return "E/F";
            } else {
                return "CONGRATULATIONS!! No matter what you do, you will get your desired grade or higher! Just check the requirements of your particular subject";
            }
        };

        const boom3 = (parameter3) => {
            const grades = {
                "A+": 9750, "A": 9050, "A-": 8300, "B+": 7800, "B": 7450, "B-": 7100,
                "C+": 6800, "C": 6450, "C-": 6100, "D+": 5800, "D": 5450, "D-": 5100,
                "R": 2450, "No grade (0)": 0
            };
            return grades[parameter3] || 0;
        };

        const canada = (grade) => {
            if (grade > 10000) {
                return "I am sorry, but with your current grades it is impossible to get the grade you want.";
            } else if (grade >= 9400) {
                return "A+";
            } else if (grade >= 8675) {
                return "A";
            } else if (grade >= 8050) {
                return "A-";
            } else if (grade >= 7625) {
                return "B+";
            } else if (grade >= 7275) {
                return "B";
            } else if (grade >= 6950) {
                return "B-";
            } else if (grade >= 6625) {
                return "C+";
            } else if (grade >= 6275) {
                return "C";
            } else if (grade >= 5950) {
                return "C-";
            } else if (grade >= 5625) {
                return "D+";
            } else if (grade >= 5275) {
                return "D";
            } else if (grade >= 3775) {
                return "D-";
            } else if (grade >= 0) {
                return "R";
            } else {
                return "CONGRATULATIONS!! No matter what you do, you will get your desired grade or higher! Just check the requirements of your particular subject";
            }
        };

        const boom4 = (grade) => {
            const grades = {
                "A*": 9500, "A": 8450, "B": 7450, "C": 6450, "D": 5450, "E": 4450,
                "Fail": 1950, "No grade (0)": 0
            };
            return grades[grade] || 0;
        };

        const GCSE = (parameter) => {
            if (parameter > 10000) {
                return "I am sorry, but with your current grades it is impossible to get the grade you want.";
            } else if (parameter >= 8975) {
                return "A*";
            } else if (parameter >= 7950) {
                return "A";
            } else if (parameter >= 6950) {
                return "B";
            } else if (parameter >= 5950) {
                return "C";
            } else if (parameter >= 4950) {
                return "D";
            } else if (parameter >= 3200) {
                return "E";
            } else if (parameter >= 0) {
                return "Fail";
            } else {
                return "0";
            }
        };

        const boom5 = (current_grade) => {
            const grades = {
                "Band6": 9500, "Band5": 8450, "Band4": 7450, "Band3": 6450,
                "Band2": 5450, "Band1": 2450, "No grade (0)": 0
            };
            return grades[current_grade] || 0;
        };

        const AustraliaSchool = (grade) => {
            if (grade > 10000) {
                return "I am sorry, but with your current grades it is impossible to get the grade you want.";
            } else if (grade >= 8975) {
                return "Band6";
            } else if (grade >= 7950) {
                return "Band5";
            } else if (grade >= 6950) {
                return "Band4";
            } else if (grade >= 5950) {
                return "Band3";
            } else if (grade >= 3950) {
                return "Band2";
            } else if (grade >= 0) {
                return "Band1";
            } else {
                return "CONGRATULATIONS!! No matter what you do, you will get your desired grade or higher! Just check the requirements of your particular subject";
            }
        };

        const boom6 = (grade) => {
            const grades = {
                "HD": 9250, "D": 7950, "Cr": 6950, "P": 5700, "F": 2450, "No grade (0)": 0
            };
            return grades[grade] || 0;
        };

        const AustraliaUni = (grade) => {
            if (grade > 10000) {
                return "I am sorry, but with your current grades it is impossible to get the grade you want.";
            } else if (grade >= 8600) {
                return "HD";
            } else if (grade >= 7450) {
                return "D";
            } else if (grade >= 6325) {
                return "Cr";
            } else if (grade >= 4075) {
                return "P";
            } else if (grade >= 0) {
                return "F";
            } else {
                return "0";
            }
        };

        const boom7 = (grade) => {
            const grades = {
                "A1": 9550, "A2": 8550, "B1": 7550, "B2": 6550, "C1": 5550, "C2": 4550,
                "D": 3650, "E1": 2650, "E2": 1000, "No grade (0)": 0
            };
            return grades[grade] || 0;
        };

        const IndiaCCE = (grade) => {
            if (grade > 10000) {
                return "I am sorry, but with your current grades it is impossible to get the grade you want.";
            } else if (grade >= 9050) {
                return "A1";
            } else if (grade >= 8050) {
                return "A2";
            } else if (grade >= 7050) {
                return "B1";
            } else if (grade >= 6050) {
                return "B2";
            } else if (grade >= 5050) {
                return "C1";
            } else if (grade >= 4100) {
                return "C2";
            } else if (grade >= 3150) {
                return "D";
            } else if (grade >= 1825) {
                return "E1";
            } else if (grade >= 0) {
                return "E2";
            } else {
                return "CONGRATULATIONS!! No matter what you do, you will get your desired grade or higher! Just check the requirements of your particular subject";
            }
        };

        // Helper function to convert letter grades to GPA
        const convert_letter = (letter) => {
            const gpaMap = {
                "A+": 4.33, "A": 4.00, "A-": 3.67, "B+": 3.33, "B": 3.00, "B-": 2.67,
                "C+": 2.33, "C": 2.00, "C-": 1.67, "D+": 1.33, "D": 1.00, "D-": 0.67, "F": 0
            };
            return gpaMap[letter] || 0;
        };

        try {
            if (selection == "1") {
                if (grading_system == "1" || grading_system == "2") { // Percentage OR Numbers
                    if (isNumeric(current_grade) && isNumeric(final_exam_grade1) && isNumeric(final_exam_weight) &&
                        current_grade > 0 && final_exam_grade1 > 0 && final_exam_weight > 0 && final_exam_weight < 100) {
                        
                        const final = (final_exam_grade1 - current_grade * (100.0 - final_exam_weight) / 100.0) / (final_exam_weight / 100.0);
                        result.tech_final_result = final;
                        return result;
                    } else {
                        result.error = 'Please! Check Your Input';
                        return result;
                    }
                } else if (grading_system == "3") { // USA Standard
                    if (isNumeric(final_exam_weight) && final_exam_weight > 0 && final_exam_weight < 100) {
                        const ik = boom1(current_grade3);
                        const ik2 = boom1(target_grade3);
                        const final2 = (ik2 - ik * (100.0 - final_exam_weight) / 100.0) / (final_exam_weight / 100.0);
                        result.tech_nawaz = USAstd(final2);
                        return result;
                    } else {
                        result.error = 'Please! Check Your Input';
                        return result;
                    }
                } else if (grading_system == "4") { // USA (Advanced Program)
                    if (isNumeric(final_exam_weight) && final_exam_weight > 0 && final_exam_weight < 100) {
                        const ik = boom2(current_grade4);
                        const ik2 = boom2(target_grade4);
                        const final2 = (ik2 - ik * (100.0 - final_exam_weight) / 100.0) / (final_exam_weight / 100.0);
                        result.tech_nawaz = USAnormal(final2);
                        return result;
                    } else {
                        result.error = 'Please! Check Your Input';
                        return result;
                    }
                } else if (grading_system == "5") { // Canada
                    if (isNumeric(final_exam_weight) && final_exam_weight > 0 && final_exam_weight < 100) {
                        const ik = boom3(current_grade8);
                        const ik2 = boom3(target_grade8);
                        const final2 = (ik2 - ik * (100.0 - final_exam_weight) / 100.0) / (final_exam_weight / 100.0);
                        result.tech_nawaz = canada(final2);
                        return result;
                    } else {
                        result.error = 'Please! Check Your Input';
                        return result;
                    }
                } else if (grading_system == "6") { // GCSE
                    if (isNumeric(final_exam_weight) && final_exam_weight > 0 && final_exam_weight < 100) {
                        const ik = boom4(current_grade9);
                        const ik2 = boom4(target_grade9);
                        const final2 = (ik2 - ik * (100.0 - final_exam_weight) / 100.0) / (final_exam_weight / 100.0);
                        result.tech_nawaz = GCSE(final2);
                        return result;
                    } else {
                        result.error = 'Please! Checking Your Input';
                        return result;
                    }
                } else if (grading_system == "7") { // Australian Schools
                    if (isNumeric(final_exam_weight) && final_exam_weight > 0 && final_exam_weight < 100) {
                        const ik = boom5(current_grade5);
                        const ik2 = boom5(target_grade5);
                        const final2 = (ik2 - ik * (100.0 - final_exam_weight) / 100.0) / (final_exam_weight / 100.0);
                        result.tech_nawaz = AustraliaSchool(final2);
                        return result;
                    } else {
                        result.error = 'Please! Checking Your Input';
                        return result;
                    }
                } else if (grading_system == "8") { // Australian (University)
                    if (isNumeric(final_exam_weight) && final_exam_weight > 0 && final_exam_weight < 100) {
                        const ik = boom6(current_grade6);
                        const ik2 = boom6(target_grade6);
                        const final2 = (ik2 - ik * (100.0 - final_exam_weight) / 100.0) / (final_exam_weight / 100.0);
                        result.tech_nawaz = AustraliaUni(final2);
                        return result;
                    } else {
                        result.error = 'Please! Check Your Input';
                        return result;
                    }
                } else if (grading_system == "9") { // India CCE
                    if (isNumeric(final_exam_weight) && final_exam_weight > 0 && final_exam_weight < 100) {
                        const ik = boom7(current_grade7);
                        const ik2 = boom7(target_grade7);
                        const final2 = (ik2 - ik * (100.0 - final_exam_weight) / 100.0) / (final_exam_weight / 100.0);
                        result.tech_nawaz = IndiaCCE(final2);
                        return result;
                    } else {
                        result.error = 'Please! Check Your Input';
                        return result;
                    }
                }

            } else if (selection == "2") {
                if (isNumeric(current_grade) && isNumeric(final_exam_grade2) && isNumeric(final_exam_weight) &&
                    current_grade > 0 && final_exam_grade2 > 0 && final_exam_weight > 0) {
                    
                    const final = (current_grade * (100.0 - final_exam_weight) + final_exam_grade2 * final_exam_weight) / 100.0;
                    result.tech_final_result = final;
                    return result;
                } else {
                    result.error = 'Please! Check Your Input';
                    return result;
                }

            } else if (selection == "3") {
                if (type == "first") {
                    if (!Array.isArray(current_grade2) || !Array.isArray(final_exam_weight2)) {
                        result.error = 'Please! Check Your Input';
                        return result;
                    }

                    const count_current_grade = current_grade2.length;
                    const count_final_exam_weight2 = final_exam_weight2.length;
                    let sum = 0;
                    let i = 0;
                    let wsum = 0;
                    let sum3 = 0;

                    while (i < count_current_grade && i < count_final_exam_weight2) {
                        if (isNumeric(final_exam_weight2[i]) && isNumeric(current_grade2[i])) {
                            sum = sum + parseFloat(final_exam_weight2[i]);
                            wsum = wsum + parseFloat(current_grade2[i]) * parseFloat(final_exam_weight2[i]);
                        } else {
                            result.error = 'Please! Check Your Input';
                            return result;
                        }
                        i++;
                    }

                    const total_final = parseFloat(final_exam_weight3) + sum;
                    const total_weight_val = total_weight2 ? parseFloat(total_weight2) : 100;

                    if (total_final == total_weight_val) {
                        const cg = wsum / sum;
                        const cgw = sum;
                        const fgw = total_weight_val - cgw;
                        const fg = (total_weight_val * parseFloat(target_grade2) - cgw * cg) / fgw;

                        // Letter grade assignment
                        let assign;
                        if (fg >= 97) {
                            assign = "A+";
                        } else if (fg >= 93) {
                            assign = "A";
                        } else if (fg >= 90) {
                            assign = "A-";
                        } else if (fg >= 87) {
                            assign = "B+";
                        } else if (fg >= 83) {
                            assign = "B";
                        } else if (fg >= 80) {
                            assign = "B-";
                        } else if (fg >= 77) {
                            assign = "C+";
                        } else if (fg >= 73) {
                            assign = "C";
                        } else if (fg >= 70) {
                            assign = "C-";
                        } else if (fg >= 67) {
                            assign = "D+";
                        } else if (fg >= 63) {
                            assign = "D";
                        } else if (fg >= 60) {
                            assign = "D-";
                        } else {
                            assign = "F";
                        }

                        result.tech_cgw = cgw;
                        result.tech_cg = cg;
                        result.tech_fgw = fgw;
                        result.tech_fg = fg;
                        result.tech_method = 3;
                        result.tech_assign = assign;
                        return result;
                    } else {
                        result.error = 'Sum of weights should be equal to total weights!';
                        return result;
                    }

                } else if (type == "second") {
                    if (!Array.isArray(pollard) || !Array.isArray(current_letter)) {
                        result.error = 'Please! Check Your Input';
                        return result;
                    }

                    let sum = 0;
                    let sum2 = 0;
                    let counter = 0;
                    const count_pollard = pollard.length;
                    const count_letter = current_letter.length;

                    while (counter < count_pollard && counter < count_letter) {
                        const cl = convert_letter(current_letter[counter]);
                        sum = sum + (parseFloat(pollard[counter]) * cl);
                        sum2 = sum2 + parseFloat(pollard[counter]);
                        counter++;
                    }

                    const cg = sum / sum2;
                    const cgw = sum2;
                    const rg = convert_letter(target_letter);
                    const total_weight_val = total_weight2 ? parseFloat(total_weight2) : 100;
                    const addition = cgw + parseFloat(final_exam_weight3);

                    if (total_weight_val != addition) {
                        result.error = 'Sum of weights should be equal to total weights';
                        return result;
                    } else {
                        let fg = (total_weight_val * rg - cgw * cg) / parseFloat(final_exam_weight3);
                        if (fg < 0) {
                            fg = 0;
                        }

                        // Letter grade assignment from GPA
                        let assign_grade;
                        if (fg >= 4.33) {
                            assign_grade = "A+";
                        } else if (fg >= 4.00) {
                            assign_grade = "A";
                        } else if (fg >= 3.67) {
                            assign_grade = "A-";
                        } else if (fg >= 3.33) {
                            assign_grade = "B+";
                        } else if (fg >= 3.00) {
                            assign_grade = "B";
                        } else if (fg >= 2.67) {
                            assign_grade = "B-";
                        } else if (fg >= 2.33) {
                            assign_grade = "C+";
                        } else if (fg >= 2.00) {
                            assign_grade = "C";
                        } else if (fg >= 1.67) {
                            assign_grade = "C-";
                        } else if (fg >= 1.33) {
                            assign_grade = "D+";
                        } else if (fg >= 1.00) {
                            assign_grade = "D";
                        } else if (fg >= 0.67) {
                            assign_grade = "D-";
                        } else {
                            assign_grade = "F";
                        }

                        result.tech_assign_grade = assign_grade;
                        result.tech_method4 = 4;
                        result.tech_cg2 = cg;
                        result.tech_cgw2 = cgw;
                        result.tech_fg2 = fg;
                        result.tech_difference = final_exam_weight3;
                        return result;
                    }
                }

            } else if (selection == "4") {
                // Note: Due to complexity, this section handles the basic case
                // The full implementation would require handling all grading_system2 cases
                if (grading_system2 == "1" || grading_system2 == "2") { // Numbers && Percentage
                    if (!Array.isArray(grade_was) || !Array.isArray(worth)) {
                        result.error = 'Please! Check Input';
                        return result;
                    }

                    const count_grade_was = grade_was.length;
                    const count_you_worth = worth.length;
                    let i = 0;
                    let sum = 0;
                    let worthing = 0;

                    while (i < count_grade_was && i < count_you_worth) {
                        if (isNumeric(grade_was[i]) && isNumeric(worth[i]) && grade_was[i] > 0 && worth[i] > 0 && 
                            grade_was[i] < 100 && worth[i] < 100 && isNumeric(you_want)) {
                            
                            const multiplication = parseFloat(grade_was[i]) * parseFloat(worth[i]);
                            sum = sum + multiplication;
                            worthing = worthing + parseFloat(worth[i]);
                            i++;
                        } else {
                            result.error = 'Please! Check Input';
                            return result;
                        }
                    }

                    if (worthing <= 100) {
                        const subtraction = 100 - worthing;
                        let read = ((parseFloat(you_want) * 100) - sum) / subtraction;
                        
                        if (read < 0) {
                            read = "CONGRATULATIONS! No matter what you do, you will get your desired grade or higher! Just check the requirements of your particular subject.";
                        } else if (read > 100) {
                            read = "I'm sorry, but with your current grades it is impossible to get the grade you want.";
                        }

                        result.tech_final10 = subtraction;
                        result.tech_final11 = read;
                        return result;
                    } else {
                        result.error = 'The percentage must be from 0 to 100. The sum of all the weights is larger than 100%. Please Check your given input';
                        return result;
                    }
                } else {
                    result.error = 'This grading system is not yet fully implemented in Node.js version';
                    return result;
                }
            } else {
                result.error = 'Please! Check Your Input';
                return result;
            }

        } catch (error) {
            console.error('Error in final grade calculation:', error);
            result.error = 'Please! Check Your Input';
            return result;
        }

        // Helper function to check if value is numeric
        function isNumeric(value) {
            return value != undefined && value != null && value != '' && !isNaN(parseFloat(value));
        }
    }


     /**
    * getCalculationSubstitutionMethodCalculator: Service Method
    * POST: /api/calculators-lol/substitution-method-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

      async getCalculationSubstitutionMethodCalculator(body) {
      const operations = body.tech_operations;

          const a1_f = body.tech_a1_f;
          const b1_f = body.tech_b1_f;
          const k1_f = body.tech_k1_f;
          const a2_f = body.tech_a2_f;
          const b2_f = body.tech_b2_f;
          const k2_f = body.tech_k2_f;

          const a1_s = body.tech_a1_s;
          const b1_s = body.tech_b1_s;
          const c1_s = body.tech_c1_s;
          const k1_s = body.tech_k1_s;

          const a2_s = body.tech_a2_s;
          const b2_s = body.tech_b2_s;
          const c2_s = body.tech_c2_s;
          const k2_s = body.tech_k2_s;

          const a3_s = body.tech_a3_s;
          const b3_s = body.tech_b3_s;
          const c3_s = body.tech_c3_s;
          const k3_s = body.tech_k3_s;


        const result = {};

        // Helper functions for equation formatting (same as before)
        const writeEq = (a, b, c) => {
            if (a == 0 && b == 0) return `0 = ${c}`;
            else if (a !== 0 && b == 0) {
                if (Math.abs(a) != 1) return `${a}x = ${c}`;
                else if (a == -1) return `-x = ${c}`;
                else return `x = ${c}`;
            }
            else if (a == 0 && b != 0) {
                if (Math.abs(b) !== 1) return `${b}y = ${c}`;
                else if (b === -1) return `-y = ${c}`;
                else return `y = ${c}`;
            }
            else {
                if (b > 0 && b != 1 && Math.abs(a) != 1) return `${a}x + ${b}y = ${c}`;
                else if (b > 0 && b == 1 && Math.abs(a) != 1) return `${a}x + y = ${c}`;
                else if (b > 0 && b != 1 && a == 1) return `x + ${b}y = ${c}`;
                else if (b > 0 && b != 1 && a == -1) return `-x + ${b}y = ${c}`;
                else if (b > 0 && b == 1 && a == 1) return `x + y = ${c}`;
                else if (b > 0 && b == 1 && a == -1) return `-x + y = ${c}`;
                else if (b < 0 && b != -1 && Math.abs(a) != 1) return `${a}x - ${-b}y = ${c}`;
                else if (b < 0 && b != -1 && a == 1) return `x - ${-b}y = ${c}`;
                else if (b < 0 && b != -1 && a == -1) return `-x - ${-b}y = ${c}`;
                else if (b < 0 && b == -1 && Math.abs(a) != 1) return `${a}x - y = ${c}`;
                else if (b < 0 && b == -1 && a == 1) return `x - y = ${c}`;
                else if (b < 0 && b == -1 && a == -1) return `-x - y = ${c}`;
            }
            return '';
        };

        const writeEqMoveB = (a, b, c) => {
            if (a == 0 && b == 0) return `0 = ${c}`;
            else if (a != 0 && b == 0) {
                if (Math.abs(a) != 1) return `${a}x = ${c}`;
                else if (a == -1) return `-x = ${c}`;
                else return `x = ${c}`;
            }
            else if (a == 0 && b != 0) {
                if (Math.abs(b) != 1) return `${b}y = ${c}`;
                else if (b == -1) return `-y = ${c}`;
                else return `y = ${c}`;
            }
            else {
                if (b > 0 && b != 1 && Math.abs(a) != 1) return `${a}x = ${c} - ${b}y`;
                else if (b > 0 && b == 1 && Math.abs(a) != 1) return `${a}x = ${c} - y`;
                else if (b > 0 && b != 1 && a == 1) return `x = ${c} - ${b}y`;
                else if (b > 0 && b != 1 && a == -1) return `-x = ${c} - ${b}y`;
                else if (b > 0 && b == 1 && a == 1) return `x = ${c} - y`;
                else if (b > 0 && b == 1 && a == -1) return `-x = ${c} - y`;
                else if (b < 0 && b != -1 && Math.abs(a) != 1) return `${a}x = ${c} + ${-b}y`;
                else if (b < 0 && b != -1 && a == 1) return `x = ${c} + ${-b}y`;
                else if (b < 0 && b != -1 && a == -1) return `-x = ${c} + ${-b}y`;
                else if (b < 0 && b == -1 && Math.abs(a) != 1) return `${a}x = ${c} + y`;
                else if (b < 0 && b == -1 && a == 1) return `x = ${c} + y`;
                else if (b < 0 && b == -1 && a == -1) return `-x = ${c} + y`;
            }
            return '';
        };

        const writeEqSubX = (a, b, c, d, e) => {
            let x;
            if (e != 0) {
                if (Math.abs(d) != 1) {
                    if (d > 0) x = `${e} + ${d}y`;
                    if (d < 0) x = `${e} - ${-d}y`;
                    if (d == 0) x = `${e}`;
                } else if (d == -1) {
                    x = `${e} - y`;
                } else {
                    x = `${e} + ${d}y`;
                }
            } else {
                if (d == 1) x = 'y';
                else if (d == -1) x = '-y';
                else x = `${d}y`;
            }
            x = `(${x})`;

            if (a == 0 && b == 0) return `0 = ${c}`;
            else if (a != 0 && b == 0) {
                if (Math.abs(a) != 1) return `${a} ⋅ ${x} = ${c}`;
                else if (a == -1) return `-${x} = ${c}`;
                else return `${x} = ${c}`;
            }
            else if (a == 0 && b != 0) {
                if (Math.abs(b) != 1) return `${b}y = ${c}`;
                else if (b == -1) return `-y = ${c}`;
                else return `y = ${c}`;
            }
            else {
                if (b > 0 && b != 1 && Math.abs(a) != 1) return `${a} ⋅ ${x} + ${b}y = ${c}`;
                else if (b > 0 && b == 1 && Math.abs(a) != 1) return `${a} ⋅ ${x} + y = ${c}`;
                else if (b > 0 && b != 1 && a == 1) return `${x} + ${b}y = ${c}`;
                else if (b > 0 && b != 1 && a == -1) return `-${x} + ${b}y = ${c}`;
                else if (b > 0 && b == 1 && a == 1) return `${x} + y = ${c}`;
                else if (b > 0 && b == 1 && a == -1) return `-${x} + y = ${c}`;
                else if (b < 0 && b != -1 && Math.abs(a) != 1) return `${a} ⋅ ${x} - ${-b}y = ${c}`;
                else if (b < 0 && b != -1 && a == 1) return `${x} - ${-b}y = ${c}`;
                else if (b < 0 && b != -1 && a == -1) return `-${x} - ${-b}y = ${c}`;
                else if (b < 0 && b == -1 && Math.abs(a) != 1) return `${a} ⋅ ${x} - y = ${c}`;
                else if (b < 0 && b == -1 && a == 1) return `${x} - y = ${c}`;
                else if (b < 0 && b == -1 && a == -1) return `-${x} - y = ${c}`;
            }
            return '';
        };

        const writeEqX = (a, b, y, c) => {
            if (Math.abs(b) != 1) {
                if (Math.abs(a) != 1) {
                    if (b > 0 && y >= 0) return `${a}x + ${b} ⋅ ${y} = ${c}`;
                    else if (b < 0 && y >= 0) return `${a}x - ${-b} ⋅ ${y} = ${c}`;
                    else if (b > 0 && y < 0) return `${a}x + ${b} ⋅ (${y}) = ${c}`;
                    else if (b < 0 && y < 0) return `${a}x - ${-b} ⋅ (${y}) = ${c}`;
                } else if (a == 1) {
                    if (b > 0 && y >= 0) return `x + ${b} ⋅ ${y} = ${c}`;
                    else if (b < 0 && y >= 0) return `x - ${-b} ⋅ ${y} = ${c}`;
                    else if (b > 0 && y < 0) return `x + ${b} ⋅ (${y}) = ${c}`;
                    else if (b < 0 && y < 0) return `x - ${-b} ⋅ (${y}) = ${c}`;
                } else if (a == -1) {
                    if (b > 0 && y >= 0) return `-x + ${b} ⋅ ${y} = ${c}`;
                    else if (b < 0 && y >= 0) return `-x - ${-b} ⋅ ${y} = ${c}`;
                    else if (b > 0 && y < 0) return `-x + ${b} ⋅ (${y}) = ${c}`;
                    else if (b < 0 && y < 0) return `-x - ${-b} ⋅ (${y}) = ${c}`;
                }
            } else if (b == 1) {
                if (Math.abs(a) != 1) {
                    if (y >= 0) return `${a}x + ${y} = ${c}`;
                    else if (y < 0) return `${a}x - ${-y} = ${c}`;
                } else if (a == 1) {
                    if (y >= 0) return `x + ${y} = ${c}`;
                    else if (y < 0) return `x - ${-y} = ${c}`;
                } else if (a == -1) {
                    if (y >= 0) return `-x + ${y} = ${c}`;
                    else if (y < 0) return `-x - ${-y} = ${c}`;
                }
            } else if (b == -1) {
                if (Math.abs(a) != 1) {
                    if (y >= 0) return `${a}x - ${y} = ${c}`;
                    else if (y < 0) return `${a}x + ${-y} = ${c}`;
                } else if (a == 1) {
                    if (y >= 0) return `x - ${y} = ${c}`;
                    else if (y < 0) return `x + ${-y} = ${c}`;
                } else if (a == -1) {
                    if (y >= 0) return `-x - ${y} = ${c}`;
                    else if (y < 0) return `-x + ${-y} = ${c}`;
                }
            }
            return '';
        };

        const writeEqY = (a, x, b, c) => {
            if (Math.abs(b) != 1) {
                if (Math.abs(a) != 1) {
                    if (b > 0 && x >= 0) return `${a} ⋅ ${x} + ${b}y = ${c}`;
                    else if (b < 0 && x >= 0) return `${a} ⋅ ${x} - ${-b}y = ${c}`;
                    else if (b > 0 && x < 0) return `${a} ⋅ (${x}) + ${b}y = ${c}`;
                    else if (b < 0 && x < 0) return `${a} ⋅ (${x}) - ${-b}y = ${c}`;
                } else if (a == 1) {
                    if (b > 0) return `${x} + ${b}y = ${c}`;
                    else if (b < 0) return `${x} - ${-b}y = ${c}`;
                } else if (a == -1) {
                    if (b > 0) return `${-x} + ${b}y = ${c}`;
                    else if (b < 0) return `${-x} - ${-b}y = ${c}`;
                }
            } else if (b == 1) {
                if (Math.abs(a) != 1) {
                    if (x >= 0) return `${a} ⋅ ${x} + y = ${c}`;
                    else if (x < 0) return `${a} ⋅ (${x}) + y = ${c}`;
                } else if (a == 1) {
                    return `${x} + y = ${c}`;
                } else if (a == -1) {
                    return `${-x} + y = ${c}`;
                }
            } else if (b == -1) {
                if (Math.abs(a) != 1) {
                    if (x >= 0) return `${a} ⋅ ${x} - y = ${c}`;
                    else if (x < 0) return `${a} ⋅ (${x}) - y = ${c}`;
                } else if (a == 1) {
                    return `${x} - y = ${c}`;
                } else if (a == -1) {
                    return `${-x} - y = ${c}`;
                }
            }
            return '';
        };

        // Helper functions for number operations
        const are3NumbersZero = (a, b, c) => a * a + b * b + c * c === 0;
        const are2NumbersZero = (a, b) => a * a + b * b === 0;
        const roundNumb = (a) => Math.round(a * 100000) / 100000;
        const lastRound = (a) => Math.round(a * 1000) / 1000;

        // Helper function to check if value is numeric
        const isNumeric = (value) => {
            return value !== undefined && value !== null && value !== '' && !isNaN(parseFloat(value));
        };

        // Gaussian elimination for 3x3 system (Laravel style)
        const gauss3Equations = (s1, t1, u1, v1, s2, t2, u2, v2, s3, t3, u3, v3) => {
            let matrix = [[s1, t1, u1, v1], [s2, t2, u2, v2], [s3, t3, u3, v3]];
            
            if (!are3NumbersZero(matrix[0][0], matrix[1][0], matrix[2][0])) {
                if (matrix[0][0] === 0 && matrix[1][0] !== 0) {
                    [matrix[0], matrix[1]] = [matrix[1], matrix[0]];
                }
                if (matrix[0][0] === 0 && matrix[2][0] !== 0) {
                    [matrix[0], matrix[2]] = [matrix[2], matrix[0]];
                }
                if (matrix[1][0] === 0 && matrix[2][0] !== 0) {
                    [matrix[1], matrix[2]] = [matrix[2], matrix[1]];
                }
            }

            // Forward elimination
            if (matrix[1][0] !== 0) {
                const factor = matrix[1][0] / matrix[0][0];
                for (let j = 0; j < 4; j++) {
                    matrix[1][j] = roundNumb(matrix[1][j] - factor * matrix[0][j]);
                }
            }
            if (matrix[2][0] !== 0) {
                const factor = matrix[2][0] / matrix[0][0];
                for (let j = 0; j < 4; j++) {
                    matrix[2][j] = roundNumb(matrix[2][j] - factor * matrix[0][j]);
                }
            }

            // Second row elimination
            if (matrix[2][1] !== 0 && matrix[1][1] !== 0) {
                const factor = matrix[2][1] / matrix[1][1];
                for (let j = 1; j < 4; j++) {
                    matrix[2][j] = roundNumb(matrix[2][j] - factor * matrix[1][j]);
                }
            }

            return matrix;
        };

        const solveFor3 = (s1, t1, u1, v1, s2, t2, u2, v2, s3, t3, u3, v3) => {
            const matrix = gauss3Equations(s1, t1, u1, v1, s2, t2, u2, v2, s3, t3, u3, v3);
            
            // Check for no solution
            if (are3NumbersZero(matrix[2][0], matrix[2][1], matrix[2][2]) && matrix[2][3] !== 0) {
                return 0; // No solution
            }
            
            // Check for infinite solutions
            if (are3NumbersZero(matrix[2][0], matrix[2][1], matrix[2][2]) && matrix[2][3] === 0) {
                if (are3NumbersZero(matrix[1][0], matrix[1][1], matrix[1][2]) && matrix[1][3] !== 0) {
                    return 0; // No solution
                }
                if (are3NumbersZero(matrix[1][0], matrix[1][1], matrix[1][2]) && matrix[1][3] === 0) {
                    if (are3NumbersZero(matrix[0][0], matrix[0][1], matrix[0][2]) && matrix[0][3] !== 0) {
                        return 0; // No solution
                    }
                    if (are3NumbersZero(matrix[0][0], matrix[0][1], matrix[0][2]) && matrix[0][3] === 0) {
                        return 1; // Infinite solutions
                    }
                }
            }

            // Back substitution for unique solution
            const z = roundNumb(matrix[2][3] / matrix[2][2]);
            const y = roundNumb((matrix[1][3] - matrix[1][2] * z) / matrix[1][1]);
            const x = roundNumb((matrix[0][3] - matrix[0][2] * z - matrix[0][1] * y) / matrix[0][0]);

            return [
                [0, 0, lastRound(x)],
                [0, 0, lastRound(y)], 
                [0, 0, lastRound(z)]
            ];
        };

        try {
            if (operations == "1") {
                // Two equations system
                if (isNumeric(a1_f) && isNumeric(b1_f) && isNumeric(k1_f) && 
                    isNumeric(a2_f) && isNumeric(b2_f) && isNumeric(k2_f)) {
                    
                    const a1 = parseFloat(a1_f);
                    const b1 = parseFloat(b1_f);
                    const k1 = parseFloat(k1_f);
                    const a2 = parseFloat(a2_f);
                    const b2 = parseFloat(b2_f);
                    const k2 = parseFloat(k2_f);

                    if (a1 != 0 || b1 != 0) {
                        if (a2 != 0 || b2 != 0) {
                            const f1_equation = writeEq(a1, b1, k1);
                            const f2_equation = writeEq(a2, b2, k2);
                            
                            result.tech_f1_equation = f1_equation;
                            result.tech_f2_equation = f2_equation;

                            // Check for special cases with zero coefficients
                            if (a1 * b1 * a2 * b2 === 0) {
                                let x, y;
                                if (a1 === 0 && a2 !== 0 && b1 !== 0 && b2 !== 0) {
                                    y = k1 / b1;
                                    x = (k2 - b2 * y) / a2;
                                    result.tech_first = '‣ From the first equation:';
                                    result.tech_second = `y = ${y}`;
                                    result.tech_third = `‣ Substitute y = ${y} into the second equation:`;
                                    result.tech_four = writeEqX(a2, b2, y, k2);
                                    result.tech_five = `x = ${x}`;
                                    result.tech_six = '‣ Solution:';
                                    result.tech_seven = `x = ${lastRound(x)}, y = ${lastRound(y)}`;
                                    result.tech_main_ans = result.tech_seven;
                                    result.tech_x = lastRound(x);
                                    result.tech_y = lastRound(y);
                                } else if (a2 === 0 && a1 !== 0 && b2 !== 0 && b1 !== 0) {
                                    y = k2 / b2;
                                    x = (k1 - b1 * y) / a1;
                                    result.tech_first = '‣ From the second equation:';
                                    result.tech_second = `y = ${y}`;
                                    result.tech_third = `‣ Substitute y = ${y} into the first equation:`;
                                    result.tech_four = writeEqX(a1, b1, y, k1);
                                    result.tech_five = `x = ${x}`;
                                    result.tech_six = '‣ Solution:';
                                    result.tech_seven = `x = ${lastRound(x)}, y = ${lastRound(y)}`;
                                    result.tech_main_ans = result.tech_seven;
                                    result.tech_x = lastRound(x);
                                    result.tech_y = lastRound(y);
                                } else if (b1 === 0 && b2 !== 0 && a1 !== 0 && a2 !== 0) {
                                    x = k1 / a1;
                                    y = (k2 - a2 * x) / b2;
                                    result.tech_first = '‣ From the first equation:';
                                    result.tech_second = `x = ${x}`;
                                    result.tech_third = `‣ Substitute x = ${x} into the second equation:`;
                                    result.tech_four = writeEqY(a2, x, b2, k2);
                                    result.tech_five = `y = ${y}`;
                                    result.tech_six = '‣ Solution:';
                                    result.tech_seven = `x = ${lastRound(x)}, y = ${lastRound(y)}`;
                                    result.tech_main_ans = result.tech_seven;
                                    result.tech_x = lastRound(x);
                                    result.tech_y = lastRound(y);
                                } else if (b2 === 0 && b1 !== 0 && a2 !== 0 && a1 !== 0) {
                                    x = k2 / a2;
                                    y = (k1 - a1 * x) / b1;
                                    result.tech_first = '‣ From the second equation:';
                                    result.tech_second = `x = ${x}`;
                                    result.tech_third = `‣ Substitute x = ${x} into the first equation:`;
                                    result.tech_four = writeEqY(a1, x, b1, k1);
                                    result.tech_five = `y = ${y}`;
                                    result.tech_six = '‣ Solution:';
                                    result.tech_seven = `x = ${lastRound(x)}, y = ${lastRound(y)}`;
                                    result.tech_main_ans = result.tech_seven;
                                    result.tech_x = lastRound(x);
                                    result.tech_y = lastRound(y);
                                }
                            } else {
                                // General case - use substitution method
                                if (Math.abs(a1) == 1 || Math.abs(a2) == 1 || Math.abs(b1) == 1 || Math.abs(b2) == 1) {
                                    // Handle cases with coefficients of 1 or -1
                                    let a = 0, b = 0, c = 0;
                                    if (Math.abs(a1) == 1) {
                                        result.tech_first = '‣ Calculate x from the first equation:';
                                        result.tech_second = writeEqMoveB(a1, b1, k1);
                                        result.tech_third = '‣ Substitute x into the second equation:';
                                        result.tech_four = writeEqSubX(a2, b2, k2, -b1, k1);
                                        result.tech_five = '‣ Simplify:';
                                        a = 0;
                                        b = -a2 * b1 + b2;
                                        c = k2 - a2 * k1;
                                        result.tech_six = writeEq(a, b, c);
                                    } else if (Math.abs(a2) == 1) {
                                        result.tech_first = '‣ Calculate x from the second equation:';
                                        result.tech_second = writeEqMoveB(a2, b2, k2);
                                        result.tech_third = '‣ Substitute x into the first equation:';
                                        result.tech_four = writeEqSubX(a1, b1, k1, -b2, k2);
                                        result.tech_five = '‣ Simplify:';
                                        a = 0;
                                        b = -a1 * b2 + b1;
                                        c = k1 - a1 * k2;
                                        result.tech_six = writeEq(a, b, c);
                                    } else if (Math.abs(b2) == 1) {
                                        result.tech_first = '‣ Calculate y from the second equation:';
                                        result.tech_second = writeEqMoveB(a2, b2, k2);
                                        result.tech_third = '‣ Substitute y into the first equation:';
                                        result.tech_four = writeEqSubX(a1, b1, k1, -a2, k2);
                                        result.tech_five = '‣ Simplify:';
                                        a = 0;
                                        b = a1 - a2 * b1;
                                        c = k1 - b1 * k2;
                                        result.tech_six = writeEq(a, b, c);
                                    } else if (Math.abs(b1) == 1) {
                                        result.tech_first = '‣ Calculate y from the first equation:';
                                        result.tech_second = writeEqMoveB(a1, b1, k1);
                                        result.tech_third = '‣ Substitute y into the second equation:';
                                        result.tech_four = writeEqSubX(a2, b2, k2, -a1, k1);
                                        result.tech_five = '‣ Simplify:';
                                        a = 0;
                                        b = a2 - a1 * b2;
                                        c = k2 - b2 * k1;
                                        result.tech_six = writeEq(a, b, c);
                                    }

                                    // Solve the simplified equation
                                    if (b == 0 && c != 0) {
                                        result.tech_main_ans = '<b>Contradiction! There is no solution.</b>';
                                    } else if (b == 0 && c == 0) {
                                        result.tech_main_ans = '<b>There are infinitely many solutions.</b>';
                                    } else {
                                        const y_val = c / b;
                                        const x_val = (k1 - b1 * y_val) / a1;
                                        
                                        result.tech_answer1 = '‣ Solve for y:';
                                        result.tech_answer2 = `<b>y = ${y_val}</b>`;
                                        result.tech_answer3 = `‣ Substituting y = ${y_val} into the first equation, we get:`;
                                        result.tech_answer4 = writeEqX(a1, b1, y_val, k1);
                                        result.tech_answer5 = '‣ Solve for x:';
                                        result.tech_answer6 = `<b>x = ${x_val}</b>`;
                                        result.tech_answer7 = '‣ Solution:';
                                        result.tech_answer8 = `x = ${lastRound(x_val)}, y = ${lastRound(y_val)}`;
                                        result.tech_main_ans = result.tech_answer8;
                                        result.tech_x = lastRound(x_val);
                                        result.tech_y = lastRound(y_val);
                                    }
                                } else {
                                    // General substitution method
                                    result.tech_first = `‣ Calculate x from the first equation. First, add ${-b1}y to both sides of the equation:`;
                                    result.tech_second = writeEqMoveB(a1, b1, k1);
                                    result.tech_third = `Next, divide both sides by ${a1}:`;
                                    result.tech_four = writeEqMoveB(1, b1 / a1, k1 / a1);
                                    result.tech_five = '‣ Substitute x into the second equation:';
                                    result.tech_six = writeEqSubX(a2, b2, k2, -(b1 / a1), (k1 / a1));
                                    result.tech_seven = '‣ Simplify:';
                                    const b_val = -a2 * b1 / a1 + b2;
                                    const c_val = k2 - a2 * k1 / a1;
                                    result.tech_eight = writeEq(0, b_val, c_val);
                                    
                                    // Solve for y and x
                                    if (b_val === 0 && c_val !== 0) {
                                        result.main_ans = '<b>Contradiction! There is no solution.</b>';
                                    } else if (b_val === 0 && c_val === 0) {
                                        result.main_ans = '<b>There are infinitely many solutions.</b>';
                                    } else {
                                        const y_val = c_val / b_val;
                                        const x_val = (k1 - b1 * y_val) / a1;
                                        
                                        result.tech_answer1 = '‣ Solve for y:';
                                        result.tech_answer2 = `<b>y = ${y_val}</b>`;
                                        result.tech_answer3 = `‣ Substituting y = ${y_val} into the first equation, we get:`;
                                        result.tech_answer4 = writeEqX(a1, b1, y_val, k1);
                                        result.tech_answer5 = '‣ Solve for x:';
                                        result.tech_answer6 = `<b>x = ${x_val}</b>`;
                                        result.tech_answer7 = '‣ Solution:';
                                        result.tech_answer8 = `x = ${lastRound(x_val)}, y = ${lastRound(y_val)}`;
                                        result.tech_main_ans = result.tech_answer8;
                                        result.tech_x = lastRound(x_val);
                                        result.tech_y = lastRound(y_val);
                                    }
                                }
                            }
                        } else {
                            result.error = 'a2 and b2 cannot both be zeros!';
                            return result;
                        }
                    } else {
                        result.error = 'a1 and b1 cannot both be zeros!';
                        return result;
                    }
                } else {
                    result.error = 'Please! Check Your Input.';
                    return result;
                }

            }  else if (operations == "2") {
                // Three equations system
                if (isNumeric(a1_s) && isNumeric(b1_s) && isNumeric(c1_s) && isNumeric(k1_s) &&
                    isNumeric(a2_s) && isNumeric(b2_s) && isNumeric(c2_s) && isNumeric(k2_s) &&
                    isNumeric(a3_s) && isNumeric(b3_s) && isNumeric(c3_s) && isNumeric(k3_s)) {
                    
                    const a1 = parseFloat(a1_s);
                    const b1 = parseFloat(b1_s);
                    const c1 = parseFloat(c1_s);
                    const k1 = parseFloat(k1_s);
                    const a2 = parseFloat(a2_s);
                    const b2 = parseFloat(b2_s);
                    const c2 = parseFloat(c2_s);
                    const k2 = parseFloat(k2_s);
                    const a3 = parseFloat(a3_s);
                    const b3 = parseFloat(b3_s);
                    const c3 = parseFloat(c3_s);
                    const k3 = parseFloat(k3_s);

                    const solution = solveFor3(a1, b1, c1, k1, a2, b2, c2, k2, a3, b3, c3, k3);

                    if (solution === 0) {
                        result.tech_s_fans = 'Your system of equations has no solutions.';
                    } else if (solution === 1) {
                        result.tech_s_fans = 'Your system of equations has an infinite number of solutions. It is satisfied by any three real numbers.';
                    } else {
                        const x = solution[0];
                        const y = solution[1];
                        const z = solution[2];
                        
                        result.tech_s_fans = `The unique solution to your system is x = ${x[2]}, y = ${y[2]}, z = ${z[2]}.`;
                        result.tech_x = x;
                        result.tech_y = y;
                    }

                } else {
                    result.error = 'Please! Check Your Input for three equation system.';
                    return result;
                }
            } else {
                result.error = 'Invalid operation selected';
                return result;
            }

            result.tech_operations = operations;
            return result;

        } catch (error) {
            console.error('Error in substitution method calculation:', error);
            result.error = 'Please! Check Your Input.';
            return result;
        }
    }

       /**
    * getCalculationSystemOfEquationsCalculator: Service Method
    * POST: /api/calculators-lol/system-of-equations-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */
  async  getCalculationSystemOfEquationsCalculator(body) {
    let operations = body.tech_operations;
    let method = body.tech_method;

    let a1_f = body.tech_a1_f;
    let b1_f = body.tech_b1_f;
    let k1_f = body.tech_k1_f;

    let a2_f = body.tech_a2_f;
    let b2_f = body.tech_b2_f;
    let k2_f = body.tech_k2_f;

    let a1_s = body.tech_a1_s;
    let b1_s = body.tech_b1_s;
    let c1_s = body.tech_c1_s;
    let k1_s = body.tech_k1_s;

    let a2_s = body.tech_a2_s;
    let b2_s = body.tech_b2_s;
    let c2_s = body.tech_c2_s;
    let k2_s = body.tech_k2_s;

    let a3_s = body.tech_a3_s;
    let b3_s = body.tech_b3_s;
    let c3_s = body.tech_c3_s;
    let k3_s = body.tech_k3_s;


      // Helper functions
      function invert(A, debug = false) {
          const n = A.length;

          // Get and append identity matrix
          const I = identity_matrix(n);
          for (let i = 0; i < n; ++i) {
              A[i] = A[i].concat(I[i]);
          }

          if (debug) {
              console.log("\nStarting matrix: ");
              print_matrix(A);
          }

          // Forward run
          for (let j = 0; j < n - 1; ++j) {
              for (let i = j + 1; i < n; ++i) {
                  if (A[i][j] != 0) {
                      const scalar = A[j][j] / A[i][j];
                      for (let jj = j; jj < n * 2; ++jj) {
                          A[i][jj] *= scalar;
                          A[i][jj] -= A[j][jj];
                      }
                  }
              }
              if (debug) {
                  console.log(`\nForward iteration ${j}: `);
                  print_matrix(A);
              }
          }

          // Reverse run
          for (let j = n - 1; j > 0; --j) {
              for (let i = j - 1; i >= 0; --i) {
                  if (A[i][j] != 0) {
                      const scalar = A[j][j] / A[i][j];
                      for (let jj = i; jj < n * 2; ++jj) {
                          A[i][jj] *= scalar;
                          A[i][jj] -= A[j][jj];
                      }
                  }
              }
              if (debug) {
                  console.log(`\nReverse iteration ${j}: `);
                  print_matrix(A);
              }
          }

          // Make all diagonal elements 1
          for (let j = 0; j < n; ++j) {
              if (A[j][j] !== 1) {
                  const scalar = 1 / A[j][j];
                  for (let jj = j; jj < n * 2; ++jj) {
                      A[j][jj] *= scalar;
                  }
              }
              if (debug) {
                  console.log(`\n1-out iteration ${j}: `);
                  print_matrix(A);
              }
          }

          // Extract the inverse matrix
          const Inv = [];
          for (let i = 0; i < n; ++i) {
              Inv[i] = A[i].slice(n);
          }

          return Inv;
      }

      function print_matrix(A, decimals = 6) {
          A.forEach(row => {
              let rowStr = "\n\t[";
              row.forEach(i => {
                  rowStr += `\t${round(i, decimals).toFixed(decimals)}`;
              });
              rowStr += "\t]";
              console.log(rowStr);
          });
      }

      function round(num, decimals) {
          return Math.round(num * Math.pow(10, decimals)) / Math.pow(10, decimals);
      }

      function identity_matrix(n) {
          const I = [];
          for (let i = 0; i < n; ++i) {
              I[i] = [];
              for (let j = 0; j < n; ++j) {
                  I[i][j] = (i == j) ? 1 : 0;
              }
          }
          return I;
      }

      function multiply(mat1, mat2) {
          const res = [];
          const N = mat1.length;
          
          for (let i = 0; i < N; i++) {
              res[i] = [];
              for (let j = 0; j < mat2[0].length; j++) {
                  res[i][j] = 0;
                  for (let k = 0; k < N; k++) {
                      res[i][j] += mat1[i][k] * mat2[k][j];
                  }
              }
          }
          return res;
      }

      function rref2(matrix) {
          let lead = 0;
          const rowCount = matrix.length;
          if (rowCount == 0) return matrix;
          
          const columnCount = matrix[0] ? matrix[0].length : 0;
          
          for (let r = 0; r < rowCount; r++) {
              if (lead >= columnCount) break;
              
              let i = r;
              while (matrix[i][lead] == 0) {
                  i++;
                  if (i == rowCount) {
                      i = r;
                      lead++;
                      if (lead == columnCount) return matrix;
                  }
              }
              
              // Swap rows
              [matrix[r], matrix[i]] = [matrix[i], matrix[r]];
              
              // Normalize the pivot row
              const lv = matrix[r][lead];
              for (let j = 0; j < columnCount; j++) {
                  matrix[r][j] = matrix[r][j] / lv;
              }
              
              // Eliminate other rows
              for (let i = 0; i < rowCount; i++) {
                  if (i != r) {
                      const lv = matrix[i][lead];
                      for (let j = 0; j < columnCount; j++) {
                          matrix[i][j] -= lv * matrix[r][j];
                      }
                  }
              }
              lead++;
          }
          return matrix;
      }

      function deter(arr) {
          const determinant = 
              arr[0][0] * (arr[1][1] * arr[2][2] - arr[1][2] * arr[2][1]) -
              arr[0][1] * (arr[1][0] * arr[2][2] - arr[1][2] * arr[2][0]) +
              arr[0][2] * (arr[1][0] * arr[2][1] - arr[1][1] * arr[2][0]);
          return determinant;
      }

      // Main logic
      const result = {};

      if (operations == 1) {
          if (isNumeric(k1_f) && isNumeric(k2_f)) {
              if ((!a1_f && a1_f != 0) && (!a2_f && a2_f != 0)) {
                  result.error = 'Please! Check Your Input.';
                  return result;
              }
              if ((!b1_f && b1_f != 0) && (!b2_f && b2_f != 0)) {
                  result.error = 'Please! Check Your Input.';
                  return result;
              }

              if (method == 1) {
                  let n1, n2, n3, multiBy;
                  
                  if (a1_f == 1) {
                      multiBy = a2_f;
                      n1 = a2_f - (a1_f * a2_f);
                      n2 = b2_f - (b1_f * a2_f);
                      n3 = k2_f - (k1_f * a2_f);
                  } else if (a1_f > 1) {
                      multiBy = `\\dfrac{${a2_f}}{${a1_f}}`;
                      n1 = a2_f - (a1_f * (a2_f / a1_f));
                      n2 = b2_f - (b1_f * (a2_f / a1_f));
                      n3 = k2_f - (k1_f * (a2_f / a1_f));
                  } else if (a1_f == 0) {
                      multiBy = 'swap';
                      n1 = a1_f;
                      n2 = b1_f;
                      n3 = k1_f;
                      // Note: In original PHP, variables were reassigned but this doesn't affect the result object
                  } else if (a1_f == -1) {
                      multiBy = a2_f;
                      n1 = a2_f + (a1_f * a2_f);
                      n2 = b2_f + (b1_f * a2_f);
                      n3 = k2_f + (k1_f * a2_f);
                  } else if (a1_f < -1) {
                      multiBy = `\\dfrac{${a2_f}}{${a1_f}}`;
                      n1 = a2_f + (a1_f * (a2_f / Math.abs(a1_f)));
                      n2 = b2_f + (b1_f * (a2_f / Math.abs(a1_f)));
                      n3 = k2_f + (k1_f * (a2_f / Math.abs(a1_f)));
                  }

                  const y = n3 / n2;
                  const x = (k1_f - (b1_f * y)) / a1_f;

                  result.tech_x = x;
                  result.tech_y = y;
                  result.tech_n1 = n1;
                  result.tech_n2 = n2;
                  result.tech_n3 = n3;
                  result.tech_a1_f = a1_f;
                  result.tech_b1_f = b1_f;
                  result.tech_k1_f = k1_f;
                  return result;

              } else if (method == 2) {
                  const invers = [[a1_f, b1_f], [a2_f, b2_f]];
                  const inv = invert(invers);
                  const side = [[k1_f], [k2_f]];
                  const multi = multiply(inv, side);

                  result.tech_x = multi[0][0];
                  result.tech_y = multi[1][0];
                  result.tech_inv = inv;
                  result.tech_multi = multi;
                  return result;

              } else if (method == 3) {
                  const det1 = (a1_f * b2_f) - (a2_f * b1_f);
                  const det2 = (k1_f * b2_f) - (k2_f * b1_f);
                  const det3 = (a1_f * k2_f) - (a2_f * k1_f);
                  const x = det2 / det1;
                  const y = det3 / det1;

                  result.tech_x = x;
                  result.tech_y = y;
                  result.tech_det1 = det1;
                  result.tech_det2 = det2;
                  result.tech_det3 = det3;
                  return result;
              }
          } else {
              result.error = 'Please! Check Your Input.';
              return result;
          }
      } else if (operations == 2) {
          if (method == 1) {
              const A = [
                  [a1_s, b1_s, c1_s, k1_s],
                  [a2_s, b2_s, c2_s, k2_s],
                  [a3_s, b3_s, c3_s, k3_s]
              ];
              const rref = rref2(A);
              const x = rref[0][3];
              const y = rref[1][3];
              const z = rref[2][3];

              result.tech_rref = rref;
              result.tech_x = x;
              result.tech_y = y;
              result.tech_z = z;
              return result;

          } else if (method == 2) {
              const A = [
                  [a1_s, b1_s, c1_s],
                  [a2_s, b2_s, c2_s],
                  [a3_s, b3_s, c3_s]
              ];
              const inv = invert(A);
              const side = [[k1_s], [k2_s], [k3_s]];
              const multi = multiply(inv, side);

              result.tech_x = multi[0][0];
              result.tech_y = multi[1][0];
              result.tech_z = multi[2][0];
              result.tech_inv = inv;
              result.tech_multi = multi;
              return result;

          } else if (method == 3) {
              const A = [
                  [a1_s, b1_s, c1_s],
                  [a2_s, b2_s, c2_s],
                  [a3_s, b3_s, c3_s]
              ];
              const B = [
                  [k1_s, b1_s, c1_s],
                  [k2_s, b2_s, c2_s],
                  [k3_s, b3_s, c3_s]
              ];
              const C = [
                  [a1_s, k1_s, c1_s],
                  [a2_s, k2_s, c2_s],
                  [a3_s, k3_s, c3_s]
              ];
              const D = [
                  [a1_s, b1_s, k1_s],
                  [a2_s, b2_s, k2_s],
                  [a3_s, b3_s, k3_s]
              ];
              const det1 = deter(A);
              const det2 = deter(B);
              const det3 = deter(C);
              const det4 = deter(D);

              const x = det2 / det1;
              const y = det3 / det1;
              const z = det4 / det1;

            result.tech_x = isNaN(x) ? "NaN" : x;
            result.tech_y = isNaN(y) ? "NaN" : y;
            result.tech_z = isNaN(z) ? "NaN" : z;

            result.tech_det1 = isNaN(det1) ? "NaN" : det1;
            result.tech_det2 = isNaN(det2) ? "NaN" : det2;
            result.tech_det3 = isNaN(det3) ? "NaN" : det3;
            result.tech_det4 = isNaN(det4) ? "NaN" : det4;

              return result;
          }
      }

      return result;
      
      // Helper function to check if value is numeric
      function isNumeric(value) {
          return !isNaN(parseFloat(value)) && isFinite(value);
      }
  }

      /**
    * getCalculationInverseMatrixCalculator: Service Method
    * POST: /api/calculators-lol/inverse-matrix-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */
     async  getCalculationInverseMatrixCalculator(body) {
    let dtrmn_slct_method = body.tech_dtrmn_slct_method;
    let dtrmn_opts_method = body.tech_dtrmn_opts_method;

    // Convert to numbers
    const matrixSize = parseInt(dtrmn_slct_method);
    
    // Helper functions (keep all the previous helper functions as they are)
    function invert(A, debug = false) {
        const n = A.length;
        const matrixCopy = A.map(row => [...row]);
        const pz = A.map(row => [...row]);

        const I = identity_matrix(n); 
        for (let i = 0; i < n; ++i) {
            matrixCopy[i] = [...matrixCopy[i], ...I[i]];
            pz[i] = [...pz[i], ...I[i]];
        }

        // Forward run
        for (let j = 0; j < n - 1; ++j) {
            for (let i = j + 1; i < n; ++i) {
                if (matrixCopy[i][j] !== 0) {
                    const scalar = matrixCopy[j][j] / matrixCopy[i][j];
                    for (let jj = j; jj < n * 2; ++jj) {
                        matrixCopy[i][jj] *= scalar;
                        matrixCopy[i][jj] -= matrixCopy[j][jj];
                    }
                }
            }
        }

        // Reverse run
        for (let j = n - 1; j > 0; --j) {
            for (let i = j - 1; i >= 0; --i) {
                if (matrixCopy[i][j] !== 0) {
                    const scalar = matrixCopy[j][j] / matrixCopy[i][j];
                    for (let jj = i; jj < n * 2; ++jj) {
                        matrixCopy[i][jj] *= scalar;
                        matrixCopy[i][jj] -= matrixCopy[j][jj];
                    }
                }
            }
        }

        // Make all diagonal elements 1
        for (let j = 0; j < n; ++j) {
            if (matrixCopy[j][j] !== 1) {
                const scalar = 1 / matrixCopy[j][j];
                for (let jj = j; jj < n * 2; ++jj) {
                    matrixCopy[j][jj] *= scalar;
                }
            }
        }

        // Extract the inverse matrix
        const Inv = [];
        for (let i = 0; i < n; ++i) {
            Inv[i] = matrixCopy[i].slice(n);
        }

        return Inv;
    }

    function rref2(matrix) {
        let lead = 0;
        const matrixCopy = matrix.map(row => [...row]);
        const pz = matrix.map(row => [...row]);
        const swap = [];
        const swap_line = [];
        const rowCount = matrixCopy.length;
        
        if (rowCount === 0) return [matrixCopy, swap, swap_line, pz];
        
        const columnCount = matrixCopy[0] ? matrixCopy[0].length : 0;
        
        for (let r = 0; r < rowCount; r++) {
            if (lead >= columnCount) break;
            
            let i = r;
            while (i < rowCount && matrixCopy[i][lead] === 0) {
                i++;
                if (i === rowCount) {
                    i = r;
                    lead++;
                    if (lead === columnCount) return [matrixCopy, swap, swap_line, pz];
                }
            }
            
            if (i >= rowCount) continue;
            
            // Swap rows
            [matrixCopy[r], matrixCopy[i]] = [matrixCopy[i], matrixCopy[r]];
            
            if (i !== r) {
                swap_line.push(`Swap the row ${r + 1} with row ${i + 1}`);
                [pz[r], pz[i]] = [pz[i], pz[r]];
                swap.push(pz.map(row => [...row]));
            }
            
            // Normalize the pivot row
            const lv = matrixCopy[r][lead];
            if (lv !== 0) {
                for (let j = 0; j < columnCount; j++) {
                    matrixCopy[r][j] = matrixCopy[r][j] / lv;
                    pz[r][j] = pz[r][j] / lv;
                }
                
                const test1 = convert2(lv);
                if (test1[1] == 1) {
                    swap_line.push(`Divide row ${r + 1} by ${lv}: R<sub>${r + 1}</sub> = R<sub>${r + 1}</sub>/${lv}`);
                } else {
                    const lv3 = `${test1[1]}/${test1[0]}`;
                    swap_line.push(`Multiply row ${r + 1} by ${lv3}: R<sub>${r + 1}</sub> = ${lv3} R<sub>${r + 1}</sub>`);
                }
                swap.push(pz.map(row => [...row]));
            }
            
            // Eliminate other rows
            for (let i = 0; i < rowCount; i++) {
                if (i !== r && matrixCopy[i][lead] !== 0) {
                    const lv = matrixCopy[i][lead];
                    const lv2 = pz[i][lead];
                    for (let j = 0; j < columnCount; j++) {
                        matrixCopy[i][j] -= lv * matrixCopy[r][j];
                        pz[i][j] -= lv2 * pz[r][j];
                    }
                    
                    swap.push(pz.map(row => [...row]));
                    const test = convert2(lv);
                    let lvDisplay = lv;
                    if (test[1] != 1) {
                        lvDisplay = `${test[0]}/${test[1]}`;
                    }
                    swap_line.push(`Subtract row ${r + 1} multiplied by ${lvDisplay} from row ${i + 1}: R<sub>${i + 1}</sub> = R<sub>${i + 1}</sub> - ${lvDisplay}R<sub>${r + 1}</sub>`);
                }
            }
            lead++;
        }
        return [matrixCopy, swap, swap_line, pz];
    }

    function identity_matrix(n) {
        const I = [];
        for (let i = 0; i < n; ++i) {
            I[i] = [];
            for (let j = 0; j < n; ++j) {
                I[i][j] = (i === j) ? 1 : 0;
            }
        }
        return I;
    }

    function deter(arr, N) {
        // Validate array dimensions
        if (!arr || arr.length !== N) {
            throw new Error(`Invalid matrix dimensions: expected ${N}x${N}`);
        }
        
        for (let i = 0; i < N; i++) {
            if (!arr[i] || arr[i].length !== N) {
                throw new Error(`Invalid matrix row ${i}: expected length ${N}`);
            }
        }

        if (N === 1) {
            return arr[0][0];
        } else if (N === 2) {
            return arr[0][0] * arr[1][1] - arr[0][1] * arr[1][0];
        } else if (N === 3) {
            return arr[0][0] * (arr[1][1] * arr[2][2] - arr[1][2] * arr[2][1]) -
                   arr[0][1] * (arr[1][0] * arr[2][2] - arr[1][2] * arr[2][0]) +
                   arr[0][2] * (arr[1][0] * arr[2][1] - arr[1][1] * arr[2][0]);
        } else {
            // For larger matrices, use recursive determinant
            return determinant(arr, N, N);
        }
    }

    function getCofactor(A, p, q, n) {
        const temp = Array(n - 1).fill(null).map(() => Array(n - 1).fill(0));
        let i = 0;
        let j = 0;
        
        for (let row = 0; row < n; row++) {
            for (let col = 0; col < n; col++) {
                if (row !== p && col !== q) {
                    temp[i][j++] = A[row][col];
                    if (j === n - 1) {
                        j = 0;
                        i++;
                    }
                }
            }
        }
        return temp;
    }

    function determinant(A, n, N) {
        if (n === 1) return A[0][0];
        
        let D = 0;
        let sign = 1;
        
        for (let f = 0; f < n; f++) {
            const cofactorTemp = getCofactor(A, 0, f, n);
            D += sign * A[0][f] * determinant(cofactorTemp, n - 1, N);
            sign = -sign;
        }
        return D;
    }

    function adjoint(A, N) {
        if (N === 1) {
            return [[[1]], [], [], [], []];
        }
        
        const adj = Array(N).fill(null).map(() => Array(N).fill(0));
        const sign22 = [];
        const sign_pow = [];
        const c_sign = [];
        
        for (let i = 0; i < N; i++) {
            for (let j = 0; j < N; j++) {
                const cofactorTemp = getCofactor(A, i, j, N);
                const sign = ((i + j) % 2 === 0) ? 1 : -1;
                sign22.push(sign);
                sign_pow.push(`${i + 1} + ${j + 1}`);
                c_sign.push(`${i + 1}${j + 1}`);
                adj[j][i] = sign * determinant(cofactorTemp, N - 1, N);
            }
        }
        return [adj, sign22, sign_pow, [], c_sign];
    }

    function transpose(A, N) {
        const B = Array(N).fill(null).map(() => Array(N).fill(0));
        for (let i = 0; i < N; i++) {
            for (let j = 0; j < N; j++) {
                B[i][j] = A[j][i];
            }
        }
        return B;
    }

    function convert2(xelem) {
        const x = parseFloat(xelem);
        if (isNaN(x)) return ['0', '1'];
        
        // Simple fraction conversion for display purposes
        const tolerance = 1.0e-6;
        let numerator = 1;
        let denominator = 1;
        
        for (let d = 1; d <= 1000; d++) {
            const n = Math.round(x * d);
            if (Math.abs(x - n/d) < tolerance) {
                numerator = n;
                denominator = d;
                break;
            }
        }
        
        const gcdVal = gcd(numerator, denominator);
        numerator /= gcdVal;
        denominator /= gcdVal;
        
        return [numerator.toString(), denominator.toString()];
    }

    function gcd(a, b) {
        return b === 0 ? a : gcd(b, a % b);
    }

    // Main logic
    const result = {};

    try {
        // console.log('Input matrix size:', matrixSize);
        // console.log('Method:', dtrmn_opts_method);

        // Validate input matrix
        const all = [];
        let totalElements = 0;
        
        for (let i = 0; i < matrixSize; i++) {
            for (let j = 0; j < matrixSize; j++) {
                const key = `tech_dtrmn_${i}_${j}`;
                const value = body[key];
                // console.log(`Reading ${key}: ${value}`);
                
                if (value == undefined || value == null || value == '') {
                    result.error = `Please provide value for position [${i}][${j}].`;
                    return result;
                }
                if (isNumeric(value)) {
                    all.push(parseFloat(value));
                    totalElements++;
                } else {
                    result.error = `Invalid number at position [${i}][${j}]: ${value}`;
                    return result;
                }
            }
        }

        // console.log('Total elements collected:', totalElements);
        // console.log('Expected elements:', matrixSize * matrixSize);

        const zain = chunkArray(all, matrixSize);
        
        // console.log('Matrix created with dimensions:', zain.length, 'x', zain[0] ? zain[0].length : 0);
        // console.log('Matrix content:', JSON.stringify(zain));

        // Validate matrix creation
        if (zain.length != matrixSize) {
            result.error = `Failed to create matrix. Expected ${matrixSize} rows, got ${zain.length}`;
            return result;
        }

        for (let i = 0; i < zain.length; i++) {
            if (zain[i].length != matrixSize) {
                result.error = `Row ${i} has incorrect length. Expected ${matrixSize}, got ${zain[i].length}`;
                return result;
            }
        }

        let det, inverse;

        if (dtrmn_opts_method == "exp_col") {
            // console.log('Using column expansion method');
            det = deter(zain, matrixSize);
            // console.log('Determinant calculated:', det);
            
            if (Math.abs(det) < 1e-10) {
                inverse = "The matrix is not invertible (determinant is zero).";
            } else {
                // console.log('Calculating inverse using RREF...');
                const f_ans = invert(zain);
                // console.log('Inverse calculated via inversion');
                
                const n = zain.length;
                const I = identity_matrix(n);
                const invt = [];
                
                for (let i = 0; i < n; ++i) {
                    invt[i] = [...zain[i], ...I[i]];
                }
                
                const ans = rref2(invt);
                const inverseFlat = [];
                
                f_ans.forEach(value => {
                    value.forEach(value2 => {
                        const numValue = parseFloat(value2);
                        if (!isNaN(numValue)) {
                            if (Number.isInteger(numValue)) {
                                inverseFlat.push(numValue);
                            } else {
                                inverseFlat.push(parseFloat(numValue.toFixed(6)));
                            }
                        } else {
                            inverseFlat.push(value2);
                        }
                    });
                });
                
                inverse = chunkArray(inverseFlat, matrixSize);
                result.tech_matrix = ans[0];
                result.tech_swap = ans[1];
                result.tech_swap_line = ans[2];
            }
        } else if (dtrmn_opts_method == "exp_row") {
            // console.log('Using row expansion method');
            det = deter(zain, matrixSize);
            // console.log('Determinant calculated:', det);
            
            if (Math.abs(det) < 1e-10) {
                // inverse = "The matrix is not invertible (determinant is zero).";
            } else {
                // console.log('Calculating inverse using adjoint method...');
                const cofa = [];
                
                for (let i = 0; i < matrixSize; i++) {
                    for (let j = 0; j < matrixSize; j++) {
                        cofa.push(getCofactor(zain, i, j, matrixSize));
                    }
                }
                
                const all_cofadet = cofa.map(value => determinant(value, matrixSize - 1, matrixSize));
                
                const res = adjoint(zain, matrixSize);
                const allans_det = [];
                
                for (let i = 0; i < all_cofadet.length; i++) {
                    allans_det.push(all_cofadet[i] * res[1][i]);
                }
                
                const adj_ans = res[0];
                const c_down = res[4];
                const minus_pow = res[2];
                const all_cofy = cofa;
                const final_cofa = chunkArray(allans_det, matrixSize);
                const ans_tran = transpose(final_cofa, matrixSize);
                
                inverse = Array(matrixSize).fill(null).map(() => Array(matrixSize).fill(0));
                for (let i = 0; i < matrixSize; i++) {
                    for (let j = 0; j < matrixSize; j++) {
                        const invValue = adj_ans[i][j] / det;
                        const numValue = parseFloat(invValue);
                        if (!isNaN(numValue)) {
                            if (Number.isInteger(numValue)) {
                                inverse[i][j] = numValue;
                            } else {
                                inverse[i][j] = parseFloat(numValue.toFixed(6));
                            }
                        } else {
                            inverse[i][j] = invValue;
                        }
                    }
                }
                
                result.tech_c_down = c_down;
                result.tech_minus_pow = minus_pow;
                result.tech_all_cofy = all_cofy;
                result.tech_allcofy_det = allans_det;
                result.tech_ans_tran = ans_tran;
                result.tech_final_cofa = final_cofa;
            }
        } else {
            result.error = 'Invalid method specified.';
            return result;
        }

        result.tech_zain = zain;
        result.tech_det = det;
        result.tech_inverse = inverse;
        
        // console.log('Calculation completed successfully');
        
    } catch (error) {
        console.error('Calculation error details:', error);
        result.error = `An error occurred during calculation: ${error.message}`;
    }

    return result;
    
    // Helper functions
    function isNumeric(value) {
        if (typeof value == 'number') return true;
        if (typeof value != 'string') return false;
        return !isNaN(value) && !isNaN(parseFloat(value));
    }
    
    function chunkArray(array, size) {
        if (!array || !size || size <= 0) return [];
        const result = [];
        for (let i = 0; i < array.length; i += size) {
            result.push(array.slice(i, i + size));
        }
        return result;
    }
}


    /**
    * getCalculationVectorAdditionCalculator: Service Method
    * POST: /api/calculators-lol/vector-addition-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */
    async  getCalculationVectorAdditionCalculator(body) {
     let calculation = body.tech_calculation;
      let operation = body.tech_operation;
      let alpha = body.tech_alpha;
      let beta = body.tech_beta;

      let vectora_representation = body.tech_vectora_representation;
      let ax = body.tech_ax;
      let ay = body.tech_ay;
      let az = body.tech_az;

      let vectorb_representation = body.tech_vectorb_representation;
      let bx = body.tech_bx;
      let by = body.tech_by;
      let bz = body.tech_bz;

      let magnitude_x = body.tech_magnitude_x;
      let direction_x = body.tech_direction_x;
      let direction_x_unit = body.tech_direction_x_unit;

      let magnitude_y = body.tech_magnitude_y;
      let direction_y = body.tech_direction_y;
      let direction_y_unit = body.tech_direction_y_unit;

     
      // Helper function to convert angles
      function convert_angle(unit, value) {
          const numValue = parseFloat(value);
          if (isNaN(numValue)) return 0;

          switch(unit) {
              case "deg":
                  return numValue * 0.017453;
              case "rad":
                  return numValue * 1;
              case "gon":
                  return numValue * 0.015708;
              case "tr":
                  return numValue * 6.283;
              case "arcmin":
                  return numValue * 0.0002909;
              case "arcsec":
                  return numValue * 0.000004848;
              case "mrad":
                  return numValue * 0.001;
              case "μrad":
                  return numValue * 0.000001;
              case "* π rad":
                  return numValue * 3.1416;
              default:
                  return numValue;
          }
      }

      // Helper function to check if all values are numeric
      function areAllNumeric(...values) {
          return values.every(val => isNumeric(val));
      }

      const result = {};

      try {
          if (calculation === "3D") { // Three Dimensional
              if (operation === "1") { // Addition without multiples
                  if (areAllNumeric(ax, ay, az, bx, by, bz)) {
                      const calculate_x = parseFloat(ax) + parseFloat(bx);
                      const calculate_y = parseFloat(ay) + parseFloat(by);
                      const calculate_z = parseFloat(az) + parseFloat(bz);
                      const calculate_m = Math.sqrt(calculate_x * calculate_x + calculate_y * calculate_y + calculate_z * calculate_z);
                      const q = parseFloat(bx) + parseFloat(ax);
                      const theta = Math.acos(q / calculate_m);
                      
                      result.tech_x = isNaN(calculate_x) ? "NaN" : calculate_x;
                      result.tech_y = isNaN(calculate_y) ? "NaN" : calculate_y;
                      result.tech_z = isNaN(calculate_z) ? "NaN" : calculate_z;
                      result.tech_m = isNaN(calculate_m) ? "NaN" : calculate_m;
                      result.tech_theta = isNaN(theta) ? "NaN" : theta;

                  } else {
                      result.error = 'Please! Check your input';
                      return result;
                  }
              } else if (operation === "2") { // Addition with multiplies
                  if (areAllNumeric(ax, ay, az, bx, by, bz, alpha, beta)) {
                      const calculate_x = (parseFloat(ax) * parseFloat(alpha)) + (parseFloat(bx) * parseFloat(beta));
                      const calculate_y = (parseFloat(ay) * parseFloat(alpha)) + (parseFloat(by) * parseFloat(beta));
                      const calculate_z = (parseFloat(az) * parseFloat(alpha)) + (parseFloat(bz) * parseFloat(beta));
                      
                    result.tech_x = isNaN(calculate_x) ? "NaN" : calculate_x;
                    result.tech_y = isNaN(calculate_y) ? "NaN" : calculate_y;
                    result.tech_z = isNaN(calculate_z) ? "NaN" : calculate_z;

                  } else {
                      result.error = 'Please! Check your input';
                      return result;
                  }
              } else if (operation === "3") { // Subtraction without multiplies
                  if (areAllNumeric(ax, ay, az, bx, by, bz)) {
                      const calculate_x = parseFloat(ax) - parseFloat(bx);
                      const calculate_y = parseFloat(ay) - parseFloat(by);
                      const calculate_z = parseFloat(az) - parseFloat(bz);
                      
                      result.tech_x = isNaN(calculate_x) ? "NaN" : calculate_x;
                    result.tech_y = isNaN(calculate_y) ? "NaN" : calculate_y;
                    result.tech_z = isNaN(calculate_z) ? "NaN" : calculate_z;
                  } else {
                      result.error = 'Please! Check your input';
                      return result;
                  }
              } else if (operation === "4") { // Subtraction with multiplies
                  if (areAllNumeric(ax, ay, az, bx, by, bz, alpha, beta)) {
                      const calculate_x = (parseFloat(ax) * parseFloat(alpha)) - (parseFloat(bx) * parseFloat(beta));
                      const calculate_y = (parseFloat(ay) * parseFloat(alpha)) - (parseFloat(by) * parseFloat(beta));
                      const calculate_z = (parseFloat(az) * parseFloat(alpha)) - (parseFloat(bz) * parseFloat(beta));
                      
                     result.tech_x = isNaN(calculate_x) ? "NaN" : calculate_x;
                    result.tech_y = isNaN(calculate_y) ? "NaN" : calculate_y;
                    result.tech_z = isNaN(calculate_z) ? "NaN" : calculate_z;
                  } else {
                      result.error = 'Please! Check your input';
                      return result;
                  }
              }
              result.tech_operation = operation;
              
          } else if (calculation === "2D") {
              let calculate_x, calculate_y, calculate_m, theta, method;

              if (["1", "2", "3", "4"].includes(operation)) {
                  // When both are cartesian coordinates
                  if (vectora_representation == "1" && vectorb_representation == "1") {
                      if (areAllNumeric(ax, ay, bx, by)) {
                          const num_ax = parseFloat(ax);
                          const num_ay = parseFloat(ay);
                          const num_bx = parseFloat(bx);
                          const num_by = parseFloat(by);

                          if (operation == "1") {
                              calculate_x = num_ax + num_bx;
                              calculate_y = num_ay + num_by;
                              calculate_m = Math.sqrt(calculate_x * calculate_x + calculate_y * calculate_y);
                              const q = num_bx + num_ax;
                              theta = Math.acos(q / calculate_m);
                              method = 1;
                          } else if (operation == "2") {
                              if (areAllNumeric(alpha, beta)) {
                                  calculate_x = (num_ax * parseFloat(alpha)) + (num_bx * parseFloat(beta));
                                  calculate_y = (num_ay * parseFloat(alpha)) + (num_by * parseFloat(beta));
                                  calculate_m = Math.sqrt(calculate_x * calculate_x + calculate_y * calculate_y);
                                  const q = calculate_x;
                                  theta = Math.acos(q / calculate_m);
                                  method = 1;
                              } else {
                                  result.error = 'Please! Check your input';
                                  return result;
                              }
                          } else if (operation == "3") {
                              calculate_x = num_ax - num_bx;
                              calculate_y = num_ay - num_by;
                              calculate_m = Math.sqrt(calculate_x * calculate_x + calculate_y * calculate_y);
                              const q = calculate_x;
                              
                              if (calculate_m == 0.0) {
                                  if (q == 0.0) {
                                      theta = 0;
                                  } else {
                                      theta = Infinity;
                                  }
                              } else {
                                  theta = Math.acos(q / calculate_m);
                              }
                              method = 2;
                              console.log(theta);
                          } else if (operation == "4") {
                              if (areAllNumeric(alpha, beta)) {
                                  calculate_x = (num_ax * parseFloat(alpha)) - (num_bx * parseFloat(beta));
                                  calculate_y = (num_ay * parseFloat(alpha)) - (num_by * parseFloat(beta));
                                  calculate_m = Math.sqrt(calculate_x * calculate_x + calculate_y * calculate_y);
                                  
                                  if (calculate_m != 0) {
                                      theta = Math.acos(calculate_x / calculate_m);
                                  } else {
                                      theta = null;
                                  }
                                  method = 2;
                              } else {
                                  result.error = 'Please! Check your input';
                                  return result;
                              }
                          }
                      } else {
                          result.error = 'Please! Check your input';
                          return result;
                      }
                  }
                  // When x is coordinate and y is magnitude
                  else if (vectora_representation == "1" && vectorb_representation == "2") {
                      if (areAllNumeric(ax, ay, magnitude_y, direction_y)) {
                          const direction_y_value = convert_angle(direction_y_unit, direction_y);
                          const num_ax = parseFloat(ax);
                          const num_ay = parseFloat(ay);
                          const num_magnitude_y = parseFloat(magnitude_y);

                          if (operation == "1") {
                              calculate_x = parseFloat((num_ax + num_magnitude_y * Math.cos(direction_y_value)).toFixed(4));
                              calculate_y = parseFloat((num_ay + num_magnitude_y * Math.sin(direction_y_value)).toFixed(4));
                              calculate_m = Math.sqrt(calculate_x * calculate_x + calculate_y * calculate_y);
                              const q = calculate_x;
                              theta = Math.acos(q / calculate_m);
                              method = 1;
                          } else if (operation == "2") {
                              if (areAllNumeric(alpha, beta)) {
                                  calculate_x = ((num_ax * parseFloat(alpha)) + (num_magnitude_y * parseFloat(beta)) * Math.cos(direction_y_value));
                                  calculate_y = ((num_ay * parseFloat(alpha)) + num_magnitude_y * (Math.sin(direction_y_value) * parseFloat(beta)));
                                  calculate_m = Math.sqrt(calculate_x * calculate_x + calculate_y * calculate_y);
                                  const q = calculate_x;
                                  theta = Math.acos(q / calculate_m);
                                  method = 1;
                              } else {
                                  result.error = 'Please! Check your input';
                                  return result;
                              }
                          } else if (operation == "3") {
                              calculate_x = num_ax - num_magnitude_y * Math.cos(direction_y_value);
                              calculate_y = num_ay - num_magnitude_y * Math.sin(direction_y_value);
                              calculate_m = Math.sqrt(calculate_x * calculate_x + calculate_y * calculate_y);
                              const q = calculate_x;
                              theta = Math.acos(q / calculate_m);
                              method = 2;
                          } else if (operation == "4") {
                              if (areAllNumeric(alpha, beta)) {
                                  calculate_x = (num_ax * parseFloat(alpha)) - (num_magnitude_y * parseFloat(beta)) * Math.cos(direction_y_value);
                                  calculate_y = (num_ay * parseFloat(alpha)) - num_magnitude_y * (Math.sin(direction_y_value) * parseFloat(beta));
                                  calculate_m = Math.sqrt(calculate_x * calculate_x + calculate_y * calculate_y);
                                  const q = calculate_x;
                                  theta = Math.acos(q / calculate_m);
                                  method = 2;
                              } else {
                                  result.error = 'Please! Check your input';
                                  return result;
                              }
                          }
                      } else {
                          result.error = 'Please! Check your input';
                          return result;
                      }
                  }
                  // When x is magnitude and y is coordinate
                  else if (vectorb_representation === "1" && vectora_representation === "2") {
                      if (areAllNumeric(bx, by, magnitude_x, direction_x)) {
                          const direction_x_value = convert_angle(direction_x_unit, direction_x);
                          const num_bx = parseFloat(bx);
                          const num_by = parseFloat(by);
                          const num_magnitude_x = parseFloat(magnitude_x);

                          if (operation == "1") {
                              calculate_x = num_magnitude_x * Math.cos(direction_x_value) + num_bx;
                              calculate_y = num_magnitude_x * Math.sin(direction_x_value) + num_by;
                              calculate_m = Math.sqrt(calculate_x * calculate_x + calculate_y * calculate_y);
                              theta = Math.acos(calculate_x / calculate_m);
                              method = 1;
                          } else if (operation == "2") {
                              if (areAllNumeric(alpha, beta)) {
                                  calculate_x = (num_magnitude_x * Math.cos(direction_x_value) * parseFloat(alpha)) + (num_bx * parseFloat(beta));
                                  calculate_y = (num_magnitude_x * Math.sin(direction_x_value) * parseFloat(alpha)) + (num_by * parseFloat(beta));
                                  calculate_m = Math.sqrt(calculate_x * calculate_x + calculate_y * calculate_y);
                                  theta = Math.acos(calculate_x / calculate_m);
                                  method = 1;
                              } else {
                                  result.error = 'Please! Check your input';
                                  return result;
                              }
                          } else if (operation == "3") {
                              calculate_x = parseFloat((num_bx - num_magnitude_x * Math.cos(direction_x_value)).toFixed(4));
                              calculate_y = parseFloat((num_by - num_magnitude_x * Math.sin(direction_x_value)).toFixed(4));
                              calculate_m = Math.sqrt(calculate_x * calculate_x + calculate_y * calculate_y);
                              const q = calculate_x;
                              theta = Math.acos(q / calculate_m);
                              method = 2;
                          } else if (operation == "4") {
                              if (areAllNumeric(alpha, beta)) {
                                  calculate_x = (num_magnitude_x * Math.cos(direction_x_value) * parseFloat(alpha)) - (num_bx * parseFloat(beta));
                                  calculate_y = (num_magnitude_x * Math.sin(direction_x_value) * parseFloat(alpha)) - (num_by * parseFloat(beta));
                                  calculate_m = Math.sqrt(calculate_x * calculate_x + calculate_y * calculate_y);
                                  theta = Math.acos(calculate_x / calculate_m);
                                  method = 2;
                              } else {
                                  result.error = 'Please! Check your input';
                                  return result;
                              }
                          }
                      } else {
                          result.error = 'Please! Check your input';
                          return result;
                      }
                  }
                  // When both are magnitude representations
                  else if (vectorb_representation == "2" && vectora_representation == "2") {
                      if (areAllNumeric(magnitude_y, direction_y, magnitude_x, direction_x)) {
                          const num_magnitude_x = parseFloat(magnitude_x);
                          const num_magnitude_y = parseFloat(magnitude_y);

                          if (operation == "1") {
                              const direction_x_value = convert_angle(direction_x_unit, direction_x);
                              const direction_y_value = convert_angle(direction_y_unit, direction_y);
                              const x1 = num_magnitude_x * Math.cos(direction_x_value);
                              const x2 = num_magnitude_x * Math.sin(direction_x_value);
                              const y1 = num_magnitude_y * Math.cos(direction_y_value);
                              const y2 = num_magnitude_y * Math.sin(direction_y_value);
                              calculate_x = x1 + y1;
                              calculate_y = x2 + y2;
                              calculate_m = Math.sqrt(calculate_x * calculate_x + calculate_y * calculate_y);
                              theta = Math.acos(calculate_x / calculate_m);
                              method = 1;
                          } else if (operation == "2") {
                              if (areAllNumeric(alpha, beta)) {
                                  const direction_x_value = convert_angle(direction_x_unit, direction_x);
                                  const direction_y_value = convert_angle(direction_y_unit, direction_y);
                                  const x1 = num_magnitude_x * Math.cos(direction_x_value) * parseFloat(alpha);
                                  const x2 = num_magnitude_x * Math.sin(direction_x_value) * parseFloat(alpha);
                                  const y1 = num_magnitude_y * Math.cos(direction_y_value) * parseFloat(beta);
                                  const y2 = num_magnitude_y * Math.sin(direction_y_value) * parseFloat(beta);
                                  calculate_x = x1 + y1;
                                  calculate_y = x2 + y2;
                                  calculate_m = Math.sqrt(calculate_x * calculate_x + calculate_y * calculate_y);
                                  theta = Math.acos(calculate_x / calculate_m);
                                  method = 1;
                              } else {
                                  result.error = 'Please! Check your input';
                                  return result;
                              }
                          } else if (operation == "3") {
                            //  let theta = 0;
                              const direction_x_value = convert_angle(direction_x_unit, direction_x);
                              const direction_y_value = convert_angle(direction_y_unit, direction_y);
                              const x1 = num_magnitude_x * Math.cos(direction_x_value);
                              const x2 = num_magnitude_x * Math.sin(direction_x_value);
                              const y1 = num_magnitude_y * Math.cos(direction_y_value);
                              const y2 = num_magnitude_y * Math.sin(direction_y_value);
                              calculate_x = x1 - y1;
                              calculate_y = x2 - y2;
                              calculate_m = Math.sqrt(calculate_x * calculate_x + calculate_y * calculate_y);
                              theta = Math.acos(calculate_x / calculate_m);
                              method = 2;
                          } else if (operation == "4") {
                              if (areAllNumeric(alpha, beta)) {
                                  const direction_x_value = convert_angle(direction_x_unit, direction_x);
                                  const direction_y_value = convert_angle(direction_y_unit, direction_y);
                                  const x1 = num_magnitude_x * Math.cos(direction_x_value) * parseFloat(alpha);
                                  const x2 = num_magnitude_x * Math.sin(direction_x_value) * parseFloat(alpha);
                                  const y1 = num_magnitude_y * Math.cos(direction_y_value) * parseFloat(beta);
                                  const y2 = num_magnitude_y * Math.sin(direction_y_value) * parseFloat(beta);
                                  calculate_x = x1 - y1;
                                  calculate_y = x2 - y2;
                                  calculate_m = Math.sqrt(calculate_x * calculate_x + calculate_y * calculate_y);
                                  
                                  if (calculate_m == 0.0) {
                                      if (calculate_x == 0.0) {
                                          theta = 0;
                                      } else {
                                          theta = Infinity;
                                      }
                                  } else {
                                      theta = Math.acos(calculate_x / calculate_m);
                                  }
                                  method = 2;
                              } else {
                                  result.error = 'Please! Check your input';
                                  return result;
                              }
                          }
                      } else {
                          result.error = 'Please! Check your input';
                          return result;
                      }
                  } else {
                      result.error = 'Invalid vector representation combination';
                      return result;
                  }

                result.tech_x = isNaN(calculate_x) ? "NaN" : calculate_x;
                result.tech_y = isNaN(calculate_y) ? "NaN" : calculate_y;
                result.tech_m = isNaN(calculate_m) ? "NaN" : calculate_m;
                result.tech_theta = isNaN(theta) ? "NaN" : theta;
                  result.tech_method = method;
              } else {
                  result.error = 'Invalid operation';
                  return result;
              }
          } else {
              result.error = 'Invalid calculation type';
              return result;
          }

          
      } catch (error) {
          console.error('Vector calculation error:', error);
          result.error = `An error occurred during calculation: ${error.message}`;
      }

      return result;
      
      // Helper function to check if value is numeric
      function isNumeric(value) {
          if (typeof value === 'number') return true;
          if (typeof value !== 'string') return false;
          return !isNaN(value) && !isNaN(parseFloat(value));
      }
  }

    /**
    * getCalculationGaussSeidelCalculator: Service Method
    * POST: /api/calculators-lol/gauss-seidel-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */
    async getCalculationGaussSeidelCalculator(body) {
      let number = body.tech_number;
      let value = body.tech_value;

      // Helper function to calculate determinant
      function solve_matrix(m) {
          const size = m.length;
          
          switch (size) {
              case 1:
                  return m[0][0];
              case 2:
                  return (m[0][0] * m[1][1]) - (m[0][1] * m[1][0]);
              case 3:
                  return (m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])) - 
                        (m[1][0] * (m[0][1] * m[2][2] - m[0][2] * m[2][1])) + 
                        (m[2][0] * (m[0][1] * m[1][2] - m[0][2] * m[1][1]));
              default:
                  return 0;
          }
      }

      const result = {};

      try {
          // Validate inputs
          const n = parseInt(number);
          if (isNaN(n) || n < 0) {
              result.error = 'Invalid matrix size';
              return result;
          }

          // Read matrix values
          const matrix = [];
          const r = [];
          
          for (let i = 0; i <= n; i++) {
              matrix[i] = [];
              for (let j = 0; j <= n; j++) {
                  const key = `tech_matrix${i}_${j}`;
                  const val = body[key];
                  
                  if (isNumeric(val)) {
                      matrix[i][j] = parseFloat(val);
                      r.push(parseFloat(val));
                  } else {
                      result.error = `Please! Check Your Input at position [${i}][${j}].`;
                      return result;
                  }
              }
          }

          // Validate value array
          if (!value || !Array.isArray(value) || value.length <= n) {
              result.error = 'Invalid value array';
              return result;
          }

          const numericValue = value.map(v => parseFloat(v)).filter(v => !isNaN(v));
          if (numericValue.length <= n) {
              result.error = 'Please! Check Your Input values.';
              return result;
          }

          // Create upper triangular matrix
          const upper = [];
          for (let k = 0; k <= n; k++) {
              upper[k] = [];
              for (let f = 0; f <= n; f++) {
                  if (k > f) {
                      upper[k][f] = 0;
                  } else {
                      upper[k][f] = matrix[k][f];
                  }
              }
          }

          // Create lower triangular matrix
          const lower = [];
          for (let i = 0; i <= n; i++) {
              lower[i] = [];
              for (let j = 0; j <= n; j++) {
                  if (j > i) {
                      lower[i][j] = 0;
                  } else {
                      lower[i][j] = matrix[i][j];
                  }
              }
          }

          // Calculate determinant of lower matrix
          const I_matrix_I = solve_matrix(lower);
          
          if (Math.abs(I_matrix_I) < 1e-10) {
              result.error = 'Matrix is singular (determinant is zero)';
              return result;
          }

          // Calculate adjoint matrix
          const adjoint = [];
          for (let i = 0; i <= n; i++) {
              adjoint[i] = [];
              for (let j = 0; j <= n; j++) {
                  adjoint[i][j] = 0;
              }
          }

          for (let i = 0; i <= n; i++) {
              for (let j = 0; j <= n; j++) {
                  const cofactor = [];
                  for (let k = 0; k <= n; k++) {
                      if (i !== k) {
                          const temp = [];
                          for (let l = 0; l <= n; l++) {
                              if (j !== l) {
                                  temp.push(lower[k][l]);
                              }
                          }
                          if (temp.length > 0) {
                              cofactor.push(temp);
                          }
                      }
                  }
                  
                  if (cofactor.length > 0) {
                      adjoint[j][i] = solve_matrix(cofactor) * Math.pow(-1, i + j);
                  } else {
                      adjoint[j][i] = 0;
                  }
              }
          }

          // Calculate inverse matrix
          const inverse = [];
          for (let i = 0; i <= n; i++) {
              inverse[i] = [];
              for (let j = 0; j <= n; j++) {
                  inverse[i][j] = adjoint[i][j] / I_matrix_I;
              }
          }

          // Modify upper matrix (set diagonal to zero)
          for (let i = 0; i < upper.length; i++) {
              for (let j = 0; j < upper[i].length; j++) {
                  if (i === j) {
                      upper[i][j] = 0;
                  }
              }
          }

          // Calculate result matrix: -inverse * upper
          const resultMatrix = [];
          for (let i = 0; i < inverse.length; i++) {
              resultMatrix[i] = [];
              for (let j = 0; j < upper[0].length; j++) {
                  resultMatrix[i][j] = 0;
                  for (let k = 0; k < upper.length; k++) {
                      resultMatrix[i][j] += (-inverse[i][k] * upper[k][j]);
                  }
              }
          }

          // Calculate result2 matrix: inverse * value
          const result2 = [];
          for (let i = 0; i < inverse.length; i++) {
              result2[i] = [];
              for (let j = 0; j < 1; j++) {
                  result2[i][j] = 0;
                  for (let k = 0; k <= n; k++) {
                      result2[i][j] += (inverse[i][k] * numericValue[k]);
                  }
              }
          }

          // Gauss-Seidel iteration (19 iterations as in original code)
          let resultt = [];
          const result3 = [];

          for (let h = 0; h < 19; h++) {
              for (let j = 0; j < resultMatrix.length; j++) {
                  result3[j] = [];
                  for (let k = 0; k < 1; k++) {
                      result3[j][k] = 0;
                      for (let m = 0; m < result2.length; m++) {
                          if (h === 0) {
                              result3[j][k] += (resultMatrix[j][m] * result2[m][k]);
                          } else {
                              result3[j][k] += (resultMatrix[j][m] * resultt[m][k]);
                          }
                      }
                  }
              }

              // Initialize resultt array if not exists
              if (!resultt.length) {
                  resultt = Array(result3.length).fill().map(() => Array(1).fill(0));
              }

              for (let n = 0; n < result3.length; n++) {
                  for (let z = 0; z < 1; z++) {
                      resultt[n][z] = result3[n][z] + result2[n][z];
                  }
              }
          }

          // Prepare final result
          result.tech_upper = upper;
          result.tech_lower = lower;
          result.tech_number = n;
          result.tech_inverse = inverse;
          result.tech_value = numericValue;
          result.tech_result = resultMatrix;
          result.tech_result2 = result2;
          result.tech_main_result = resultt;

      } catch (error) {
          console.error('Gauss-Seidel calculation error:', error);
          result.error = `An error occurred during calculation: ${error.message}`;
      }

      return result;
      
      // Helper function to check if value is numeric
      function isNumeric(value) {
          if (value === null || value === undefined || value === '') return false;
          if (typeof value === 'number') return true;
          if (typeof value !== 'string') return false;
          return !isNaN(value) && !isNaN(parseFloat(value));
      }
  }

  /**
    * getCalculationRationalizeTheDenominatorCalculator: Service Method
    * POST: /api/calculators-lol/rationalize-the-denominator-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async  getCalculationRationalizeTheDenominatorCalculator(body) {
        const params = {};
        
        try {
          let type = body.tech_type;
          let operations = body.tech_operations;
          let a = body.tech_a;
          let b = body.tech_b;
          let n = body.tech_n;
          let c = body.tech_c;
          let d = body.tech_d;
          let m = body.tech_m;
          let x = body.tech_x;
          let y = body.tech_y;
          let k = body.tech_k;
          let u = body.tech_u;
          let n1 = body.tech_n1;
          let d1 = body.tech_d1;


            if (type == "first") {
                if (operations == "1") {
                    if ([a, b, n, x, y, k].every(val => !isNaN(val))) {
                        if (a != 0) {
                            if (b > 0) {
                                if (n >= 2) {
                                    if (x != 0) {
                                        if (y > 0) {
                                            if (k != 0) {
                                                params.tech_operations = operations;
                                                params.tech_type = type;
                                                params.tech_a = a;
                                                params.tech_b = b;
                                                params.tech_n = n;
                                                params.tech_x = x;
                                                params.tech_y = y;
                                                params.tech_k = k;
                                                params.tech_z = 0;
                                                params.tech_c = 0;
                                                params.tech_d = 0;
                                                params.tech_m = 0;
                                                params.tech_u = 0;
                                            } else {
                                                params.error = 'k cannot be 0.';
                                                return params;
                                            }
                                        } else {
                                            params.error = 'y cannot be negative.';
                                            return params;
                                        }
                                    } else {
                                        params.error = "Are you sure about x being 0? Why don't we input something different?";
                                        return params;
                                    }
                                } else {
                                    params.error = 'n cannot be smaller than 2.';
                                    return params;
                                }
                            } else {
                                params.error = 'b cannot be negative.';
                                return params;
                            }
                        } else {
                            params.error = "Are you sure about a being 0? Why don't we input something different?";
                            return params;
                        }
                    } else {
                        params.error = 'Please! Check Your Input.';
                        return params;
                    }
                } else if (operations == "2") {
                    if ([a, b, n, c, d, m, x, y, k].every(val => !isNaN(val))) {
                        params.tech_operations = operations;
                        params.tech_type = type;
                        params.tech_a = a;
                        params.tech_b = b;
                        params.tech_n = n;
                        params.tech_x = x;
                        params.tech_y = y;
                        params.tech_k = k;
                        params.tech_z = 0;
                        params.tech_c = c;
                        params.tech_d = d;
                        params.tech_m = m;
                        params.tech_u = 0;
                    } else {
                        params.error = 'Please! Check Your Input.';
                        return params;
                    }
                } else if (operations == "3") {
                    if ([a, b, x, y, k, u].every(val => !isNaN(val))) {
                        params.tech_operations = operations;
                        params.tech_type = type;
                        params.tech_a = a;
                        params.tech_b = b;
                        params.tech_n = 1;
                        params.tech_x = x;
                        params.tech_y = y;
                        params.tech_k = 1;
                        params.tech_z = k;
                        params.tech_c = 1;
                        params.tech_d = 1;
                        params.tech_m = 1;
                        params.tech_u = u;
                    } else {
                        params.error = 'Please! Check Your Input.';
                        return params;
                    }
                } else if (operations == "4") {
                    if ([a, b, d, x, y, k, u, c].every(val => !isNaN(val))) {
                        params.tech_operations = operations;
                        params.tech_type = type;
                        params.tech_a = a;
                        params.tech_b = b;
                        params.tech_n = 1;
                        params.tech_x = x;
                        params.tech_y = y;
                        params.tech_k = 1;
                        params.tech_z = k;
                        params.tech_c = c;
                        params.tech_d = d;
                        params.tech_m = 1;
                        params.tech_u = u;
                    } else {
                        params.error = 'Please! Check Your Input.';
                        return params;
                    }
                }
                } else if (type === "second") {
                  console.log('Processing second type with n1:', n1, 'd1:', d1);
                  
                  // Input validation
                  if (!n1 || !d1 || typeof n1 !== 'string' || typeof d1 !== 'string') {
                      // console.log('n1 or d1 missing or not strings');
                      params.error = 'Please! Check Your Input. n1 and d1 are required.';
                      return params;
                  }

                  // Security validation - modified to allow = sign
                  const dangerousPattern = /<|>|&|php|print_r|print|echo|script|%|eval|exec|system|command/i;
                  
                  // console.log('Security check - n1:', dangerousPattern.test(n1), 'd1:', dangerousPattern.test(d1));
                  
                  if (dangerousPattern.test(n1) || dangerousPattern.test(d1)) {
                      // console.log('Dangerous pattern detected');
                      params.error = 'Please! Check Your Input. Invalid characters detected.';
                      return params;
                  }

                  // Process the equations
                  let xeq = n1.replace(/ /g, '')
                            .replace(/\+/g, 'plus')
                            .replace(/{/g, '(')
                            .replace(/}/g, ')')
                            .replace(/xe\^/g, 'x*e^')
                            .replace(/ye\^/g, 'y*e^')
                            .replace(/e\^/g, 'exp')
                            .replace(/exp\^/g, 'exp')
                            .replace(/\^/g, '**')
                            .replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

                  let yeq = d1.replace(/ /g, '')
                            .replace(/\+/g, 'plus')
                            .replace(/{/g, '(')
                            .replace(/}/g, ')')
                            .replace(/xe\^/g, 'x*e^')
                            .replace(/ye\^/g, 'y*e^')
                            .replace(/e\^/g, 'exp')
                            .replace(/exp\^/g, 'exp')
                            .replace(/\^/g, '**')
                            .replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

                  // console.log('Processed xeq:', xeq);
                  // console.log('Processed yeq:', yeq);

                  try {
                      // console.log('Making API call...');
                      const response = await axios.post('http://167.172.134.148/rationalize', {
                          xeq: xeq,
                          yeq: yeq
                      }, {
                          timeout: 120000,
                          headers: {
                              'Content-Type': 'application/x-www-form-urlencoded'
                          }
                      });

                      // console.log('API response status:', response.status);
                      // console.log('API response data:', response.data);
                      
                      if (response.data && typeof response.data === 'string') {
                          const buffer = response.data.split('@@@');
                          if (buffer.length >= 5) {
                              params.tech_enter = buffer[0];
                              params.tech_up = buffer[1];
                              params.tech_ress = buffer[2];
                              params.tech_down = buffer[3];
                              params.tech_main_ans = buffer[4];
                          } else {
                              params.error = 'Invalid response format from API.';
                              return params;
                          }
                      } else {
                          params.error = 'Invalid response from API.';
                          return params;
                      }
                  } catch (error) {
                      // console.log('API call error:', error.message);
                      if (error.response) {
                          // console.log('API response error:', error.response.status, error.response.data);
                      }
                      params.error = 'Please! Check Your Input. API call failed: ' + error.message;
                      return params;
                  }
              }

            params.tech_type = type;
            return params;

        } catch (error) {
            const errorParams = {};
            errorParams.error = 'Please! Check Your Input.';
            return errorParams;
        }
    }


  /**
    * getCalculationSurfaceAreaCalculator: Service Method
    * POST: /api/calculators-lol/surface-area-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

   async getCalculationSurfaceAreaCalculator(body) {
      const params = {};
      
      try {
          let operations = body.tech_operations;
          let shape = body.tech_shape;
          let first = body.tech_first;
          let second = body.tech_second;
          let third = body.tech_third;
          let four = body.tech_four;
          let pi = body.tech_pi;
          let unit1 = body.tech_unit1;
          let unit2 = body.tech_unit2;
          let unit3 = body.tech_unit3;
          let unit4 = body.tech_unit4;

          // Unit conversion function
          const calculation = (a, b) => {
              if (!a || !b) return 0;
              
              if (b == 'cm') {
                  return parseFloat(a);
              } else if (b == 'mm') {
                  return parseFloat(a) / 10;
              } else if (b == 'm') {
                  return parseFloat(a) * 100;
              } else if (b == 'in') {
                  return parseFloat(a) * 2.54;
              } else if (b == 'ft') {
                  return parseFloat(a) * 30.48;
              } else if (b == 'yd') {
                  return parseFloat(a) * 91.44;
              }
              return parseFloat(a);
          };

          // Convert units
          const firstVal = calculation(first, unit1);
          const secondVal = calculation(second, unit2);
          const thirdVal = calculation(third, unit3);
          const fourVal = calculation(four, unit4);

          // Validate numeric inputs
          const isNumeric = (val) => !isNaN(parseFloat(val)) && isFinite(val);

          if (operations == "1") {
              if (isNumeric(firstVal) && isNumeric(secondVal) && isNumeric(pi)) {
                  const ttsa = 2 * parseFloat(pi) * firstVal * ((2 * firstVal) + secondVal);
                 params.tech_ttsa = isNaN(ttsa) ? "NAN" : ttsa;
              } else {
                  params.error = 'Please check your input';
                  return params;
              }
          } else if (operations == "2") {
              if (isNumeric(firstVal) && isNumeric(secondVal) && isNumeric(pi)) {
                  const s = Math.pow(firstVal, 2) + Math.pow(secondVal, 2);
                  const s_sqrt = Math.sqrt(s);
                  const lsa = parseFloat(pi) * firstVal * s_sqrt;
                  const bsa = parseFloat(pi) * Math.pow(firstVal, 2);
                  const ttsa = parseFloat(pi) * firstVal * (firstVal + s_sqrt);
                 params.tech_lsa  = isNaN(lsa) ? "NAN" : lsa;
                  params.tech_bsa  = isNaN(bsa) ? "NAN" : bsa;
                  params.tech_ttsa = isNaN(ttsa) ? "NAN" : ttsa;

              } else {
                  params.error = 'Please check your input';
                  return params;
              }
          } else if (operations == "3") {
              if (isNumeric(firstVal) && isNumeric(secondVal) && isNumeric(thirdVal) && isNumeric(pi)) {
                  const top = parseFloat(pi) * Math.pow(firstVal, 2);
                  const bsa = parseFloat(pi) * Math.pow(secondVal, 2);
                  const s = Math.pow(firstVal - secondVal, 2) + Math.pow(thirdVal, 2);
                  const s_sqrt = Math.sqrt(s);
                  const ttsa = parseFloat(pi) * (Math.pow(firstVal, 2) + Math.pow(secondVal, 2) + (firstVal * secondVal) * s_sqrt);
                  const lsa = parseFloat(pi) * (firstVal + secondVal) * s_sqrt;
                 params.tech_top  = isNaN(top) ? "NAN" : top;
                  params.tech_bsa  = isNaN(bsa) ? "NAN" : bsa;
                  params.tech_ttsa = isNaN(ttsa) ? "NAN" : ttsa;
                  params.tech_lsa  = isNaN(lsa) ? "NAN" : lsa;

              } else {
                  params.error = 'Please check your input';
                  return params;
              }
          } else if (operations == "4") {
              if (isNumeric(firstVal)) {
                  const bsa = Math.pow(firstVal, 2);
                  const top = Math.pow(firstVal, 2);
                  const lsa = 4 * Math.pow(firstVal, 2);
                  const ttsa = 6 * bsa;
                  params.tech_top  = isNaN(top) ? "NAN" : top;
                  params.tech_bsa  = isNaN(bsa) ? "NAN" : bsa;
                  params.tech_ttsa = isNaN(ttsa) ? "NAN" : ttsa;
                  params.tech_lsa  = isNaN(lsa) ? "NAN" : lsa;

              } else {
                  params.error = 'Please check your input';
                  return params;
              }
          } else if (operations == "5") {
              if (isNumeric(firstVal) && isNumeric(secondVal) && isNumeric(pi)) {
                  const top = parseFloat(pi) * Math.pow(firstVal, 2);
                  const bsa = parseFloat(pi) * Math.pow(firstVal, 2);
                  const ttsa = 2 * parseFloat(pi) * firstVal * (secondVal + firstVal);
                  const lsa = ttsa - (top + bsa);
                  params.tech_top  = isNaN(top) ? "NAN" : top;
                  params.tech_bsa  = isNaN(bsa) ? "NAN" : bsa;
                  params.tech_ttsa = isNaN(ttsa) ? "NAN" : ttsa;
                  params.tech_lsa  = isNaN(lsa) ? "NAN" : lsa;

              } else {
                  params.error = 'Please check your input';
                  return params;
              }
          } else if (operations == "6") {
              if (isNumeric(firstVal) && isNumeric(pi)) {
                  const csa = 2 * parseFloat(pi) * Math.pow(firstVal, 2);
                  const bsa = parseFloat(pi) * Math.pow(firstVal, 2);
                  const ttsa = 3 * parseFloat(pi) * Math.pow(firstVal, 2);
                  params.tech_bsa  = isNaN(bsa) ? "NAN" : bsa;
                  params.tech_ttsa = isNaN(ttsa) ? "NAN" : ttsa;
                  params.tech_csa  = isNaN(csa) ? "NAN" : csa;

              } else {
                  params.error = 'Please check your input';
                  return params;
              }
          } else if (operations == "7") {
              if (isNumeric(firstVal) && isNumeric(secondVal) && isNumeric(thirdVal)) {
                  const bsa = firstVal * secondVal;
                  const top = thirdVal * firstVal;
                  const top2 = thirdVal * secondVal;
                  const ttsa = 2 * (bsa + top + top2);
                  const lsa = ttsa - (bsa + top);
                params.tech_top  = isNaN(top) ? "NAN" : top;
                params.tech_bsa  = isNaN(bsa) ? "NAN" : bsa;
                params.tech_ttsa = isNaN(ttsa) ? "NAN" : ttsa;
                params.tech_lsa  = isNaN(lsa) ? "NAN" : lsa;

              } else {
                  params.error = 'Please check your input';
                  return params;
              }
          } else if (operations == "8") {
              if (isNumeric(firstVal) && isNumeric(pi)) {
                  const ttsa = 4 * parseFloat(pi) * Math.pow(firstVal, 2);
                  params.tech_ttsa = isNaN(ttsa) ? "NAN" : ttsa;

              } else {
                  params.error = 'Please check your input';
                  return params;
              }
          } else if (operations == "9") {
              if (isNumeric(firstVal) && isNumeric(secondVal) && isNumeric(pi)) {
                  const csa = 2 * parseFloat(pi) * firstVal * secondVal;
                  params.tech_csa = isNaN(csa) ? "NAN" : ttsa;

              } else {
                  params.error = 'Please check your input';
                  return params;
              }
          } else if (operations == "10") {
              if (isNumeric(firstVal) && isNumeric(secondVal) && isNumeric(thirdVal) && isNumeric(fourVal)) {
                  const add = secondVal + thirdVal;
                  if (firstVal >= add) {
                      params.error = 'The sum of sides b and c must be greater than side a to form a triangle';
                      return params;
                  }
                  const top_sq = (firstVal + secondVal + thirdVal) * (secondVal + thirdVal - firstVal) * (thirdVal + firstVal - secondVal) * (firstVal + secondVal - thirdVal);
                  const top = (1/4) * Math.sqrt(top_sq);
                  const bsa = top;
                  const lsa = fourVal * (firstVal + secondVal + thirdVal);
                  const ttsa = top + bsa + lsa;
                  params.tech_top = isNaN(top) ? "NAN" : top;
                  params.tech_bsa = isNaN(bsa) ? "NAN" : bsa;
                  params.tech_ttsa = isNaN(ttsa) ? "NAN" : ttsa;
                  params.tech_lsa = isNaN(lsa) ? "NAN" : lsa;

              } else {
                  params.error = 'Please check your input';
                  return params;
              }
          } else if (operations == "11") {
              if (shape == 1) {
                  if (isNumeric(firstVal) && isNumeric(secondVal)) {
                      const height = 0.8660 * firstVal;
                      const bsa = (Math.pow(firstVal, 2) * Math.sqrt(3)) / 4;
                      const lsa = 1.5 * firstVal * secondVal;
                      const ttsa = bsa + lsa;
                      params.tech_height = isNaN(height) ? "NAN" : height;
                      params.tech_bsa = isNaN(bsa) ? "NAN" : bsa;
                      params.tech_lsa = isNaN(lsa) ? "NAN" : lsa;
                      params.tech_ttsa = isNaN(ttsa) ? "NAN" : ttsa;

                  } else {
                      params.error = 'Please check your input';
                      return params;
                  }
              } else if (shape == 2) {
                  if (isNumeric(firstVal) && isNumeric(secondVal)) {
                      const f_sql = 4 * Math.pow(secondVal, 2);
                      const minus_div = (f_sql - Math.pow(firstVal, 2)) / 4;
                      const height = Math.sqrt(minus_div);
                      const bsa = Math.pow(firstVal, 2);
                      const lsa = firstVal * Math.sqrt(Math.pow(firstVal, 2) + 4 * Math.pow(height, 2));
                      const ttsa = bsa + lsa;
                      params.tech_height = isNaN(height) ? "NAN" : height;
                      params.tech_bsa    = isNaN(bsa) ? "NAN" : bsa;
                      params.tech_lsa    = isNaN(lsa) ? "NAN" : lsa;
                      params.tech_ttsa   = isNaN(ttsa) ? "NAN" : ttsa;

                  } else {
                      params.error = 'Please check your input';
                      return params;
                  }
              } else if (shape == 3) {
                  if (isNumeric(firstVal) && isNumeric(secondVal) && isNumeric(thirdVal)) {
                      const la = Math.sqrt(Math.pow(thirdVal, 2) + (Math.pow(secondVal, 2) / 4));
                      const lb = Math.sqrt(Math.pow(thirdVal, 2) + (Math.pow(firstVal, 2) / 4));
                      const bsa = firstVal * secondVal;
                      const lsa = firstVal * la + secondVal * lb;
                      const ttsa = bsa + lsa;
                     params.tech_bsa  = isNaN(bsa) ? "NAN" : bsa;
                      params.tech_lsa  = isNaN(lsa) ? "NAN" : lsa;
                      params.tech_ttsa = isNaN(ttsa) ? "NAN" : ttsa;

                  } else {
                      params.error = 'Please check your input';
                      return params;
                  }
              } else if (shape == 4) {
                  if (isNumeric(firstVal) && isNumeric(secondVal)) {
                      const height = Math.sqrt(Math.pow(secondVal, 2) - ((6.25 * Math.pow(firstVal, 2)) / 13.1769));
                      const bsa = 1.7222 * Math.pow(firstVal, 2);
                      const lsa = 2.5 * firstVal * Math.sqrt((0.474 * Math.pow(firstVal, 2)) + Math.pow(height, 2));
                      const ttsa = bsa + lsa;
                     params.tech_height = isNaN(height) ? "NAN" : height;
                    params.tech_bsa    = isNaN(bsa) ? "NAN" : bsa;
                    params.tech_lsa    = isNaN(lsa) ? "NAN" : lsa;
                    params.tech_ttsa   = isNaN(ttsa) ? "NAN" : ttsa;

                  } else {
                      params.error = 'Please check your input';
                      return params;
                  }
              } else if (shape == 5) {
                  if (isNumeric(firstVal) && isNumeric(secondVal)) {
                      const height = Math.sqrt(Math.pow(secondVal, 2) - ((3 * Math.pow(firstVal, 2)) / 4));
                      const bsa = 2.5981 * Math.pow(firstVal, 2);
                      const lsa = 3 * firstVal * Math.sqrt(Math.pow(height, 2) + ((3 * Math.pow(firstVal, 2)) / 4));
                      const ttsa = bsa + lsa;
                    params.tech_height = isNaN(height) ? "NAN" : height;
                    params.tech_bsa    = isNaN(bsa) ? "NAN" : bsa;
                    params.tech_lsa    = isNaN(lsa) ? "NAN" : lsa;
                    params.tech_ttsa   = isNaN(ttsa) ? "NAN" : ttsa;

                  } else {
                      params.error = 'Please check your input';
                      return params;
                  }
              }
          } else if (operations == "12") {
              if (isNumeric(firstVal)) {
                  const ttsa = 4 * 3.141593 * Math.pow(firstVal, 2);
                  params.tech_ttsa = isNaN(ttsa) ? "NAN" : ttsa;

              } else {
                  params.error = 'Please check your input';
                  return params;
              }
          } else if (operations == "13") {
              if (isNumeric(firstVal) && isNumeric(secondVal) && isNumeric(fourVal)) {
                  const f_mul = Math.pow((firstVal * secondVal), 1.6);
                  const s_mul = Math.pow((firstVal * fourVal), 1.6);
                  const t_mul = Math.pow((secondVal * fourVal), 1.6);
                  const divide = (f_mul + s_mul + t_mul) / 3;
                  const ttsa = 4 * 3.141593 * Math.pow(divide, 0.625);
                  params.tech_ttsa = isNaN(ttsa) ? "NAN" : ttsa;

              } else {
                  params.error = 'Please check your input';
                  return params;
              }
          } else {
              params.error = 'Invalid operation specified';
              return params;
          }

          return params;

      } catch (error) {
          console.log('Surface area calculation error:', error.message);
          const errorParams = {};
          errorParams.error = 'Please check your input. Error: ' + error.message;
          return errorParams;
      }
  }

     /**
    * getCalculationLengthOfCurveCalculator: Service Method
    * POST: /api/calculators-lol/length-of-curve-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */


    async getCalculationLengthOfCurveCalculator(body) {
      let cal = body.tech_cal;
      let func = body.tech_func;
      let func1 = body.tech_func1;
      let func2 = body.tech_func2;
      let lower = body.tech_lower;
      let upper = body.tech_upper;

      if (!lower || !upper) {
          return { error: 'Please! Check Your Input.' };
      }

      // Input validation function
      const validateInput = (input) => {
          const dangerousPatterns = /<|>|&|php|print_r|print|echo|script|=|&|%/i;
          return !dangerousPatterns.test(input);
      };

      // Parameter processing function
      const processParam = (param) => {
          return param
              .replace(/ /g, '')
              .replace(/\+/g, 'plus')
              .replace(/%20/g, '')
              .replace(/{/g, '(')
              .replace(/}/g, ')')
              .replace(/e\^/g, 'exp')
              .replace(/exp\^/g, 'exp')
              .replace(/\^/g, '**')
              .replace(/e\^sqrt\(x\)/g, 'exp(2*x)');
      };

      try {
          if (cal == 'y' && func) {
              if (!validateInput(func)) {
                  return { error: 'Please! Check Your Input.' };
              }

              const parem = processParam(func);
              const check = 'y';

              const response = await fetch("http://167.172.134.148/length", {
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/x-www-form-urlencoded',
                  },
                  body: new URLSearchParams({
                      equ: parem,
                      check: check
                  }),
                  timeout: 120000
              });

              const buffer = await response.text();
              const bufferArray = buffer.split("@@@");
              
              return {
                  tech_enter: bufferArray[0],
                  tech_diff: bufferArray[1],
                  tech_lower: lower,
                  tech_upper: upper,
              };

          } else if (cal == 'x' && func) {
              if (!validateInput(func)) {
                  return { error: 'Please! Check Your Input.' };
              }

              const parem = processParam(func);
              const check = 'x';

              const response = await fetch("http://167.172.134.148/length", {
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/x-www-form-urlencoded',
                  },
                  body: new URLSearchParams({
                      equ: parem,
                      check: check
                  }),
                  timeout: 120000
              });

              const buffer = await response.text();
              const bufferArray = buffer.split("@@@");
              
              return {
                  tech_enter: bufferArray[0],
                  tech_diff: bufferArray[1],
                  tech_lower: lower,
                  tech_upper: upper,
              };

          } else if (cal == 'xy' && func && func1) {
              if (!validateInput(func) || !validateInput(func1)) {
                  return { error: 'Please! Check Your Input.' };
              }

              const parem = processParam(func);
              const parem1 = processParam(func1);
              const check = 'xy';

              const response = await fetch("http://167.172.134.148/length", {
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/x-www-form-urlencoded',
                  },
                  body: new URLSearchParams({
                      equ: parem,
                      check: check,
                      equ1: parem1
                  }),
                  timeout: 120000
              });

              const buffer = await response.text();
              const bufferArray = buffer.split("@@@");
              
              return {
                  tech_enter: bufferArray[0],
                  tech_enter1: bufferArray[1],
                  tech_diff: bufferArray[2],
                  tech_diff1: bufferArray[3],
                  tech_lower: lower,
                  tech_upper: upper,
              };

          } else if (cal == 'r' && func) {
              if (!validateInput(func)) {
                  return { error: 'Please! Check Your Input.' };
              }

              const parem = processParam(func).replace(/plus/g, '+');
              const check = 'r';

              const response = await fetch("http://167.172.134.148/length", {
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/x-www-form-urlencoded',
                  },
                  body: new URLSearchParams({
                      equ: parem,
                      check: check
                  }),
                  timeout: 120000
              });

              const buffer = await response.text();
              const bufferArray = buffer.split("@@@");
              
              return {
                  tech_enter: bufferArray[0],
                  tech_diff: bufferArray[1],
                  tech_lower: lower,
                  tech_upper: upper,
              };

          } else if (cal == 'xyz' && func && func1 && func2) {
              if (!validateInput(func) || !validateInput(func1) || !validateInput(func2)) {
                  return { error: 'Please! Check Your Input.' };
              }

              const parem = processParam(func);
              const parem1 = processParam(func1);
              const parem2 = processParam(func2);
              const check = 'xyz';

              const response = await fetch("http://167.172.134.148/length", {
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/x-www-form-urlencoded',
                  },
                  body: new URLSearchParams({
                      equ: parem,
                      check: check,
                      equ1: parem1,
                      equ2: parem2
                  }),
                  timeout: 120000
              });

              const buffer = await response.text();
              const bufferArray = buffer.split("@@@");
              
              return {
                  tech_enter: bufferArray[0],
                  tech_enter1: bufferArray[1],
                  tech_enter2: bufferArray[2],
                  tech_diff: bufferArray[3],
                  tech_diff1: bufferArray[4],
                  tech_diff2: bufferArray[5],
                  tech_lower: lower,
                  tech_upper: upper,
              };

          } else {
              return { error: 'Please! Check Your Input.' };
          }

      } catch (error) {
          return { error: 'Please! Check Your Input.' };
      }
  }


     /**
    * getCalculationDiagonalCalculator: Service Method
    * POST: /api/calculators-lol/diagonal-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

      async getCalculationDiagonalCalculator(body) {
          let given = body.tech_given;
          let ls = body.tech_ls;
          let ls_unit = body.tech_ls_unit;
          let ss = body.tech_ss;
          let ss_unit = body.tech_ss_unit;
          let perimeter = body.tech_perimeter;
          let perimeter_unit = body.tech_perimeter_unit;
          let area = body.tech_area;
          let area_unit = body.tech_area_unit;
          let angle = body.tech_angle;
          let angle_unit = body.tech_angle_unit;
          let circum = body.tech_circum;
          let circum_unit = body.tech_circum_unit;

        // Unit conversion functions
        const myunitConvert = (unit, value) => {
            const conversions = {
                "mm": value * 0.1,
                "cm": value * 1,
                "m": value * 100,
                "km": value * 1000,
                "in": value * 2.54,
                "ft": value * 30.48,
                "yd": value * 91.44,
                "mi": value * 160934
            };
            return conversions[unit] || value;
        };

        const centimeter = (unit3, value3) => {
            const conversions = {
                "mm²": value3 * 0.01,
                "cm²": value3 * 1,
                "m²": value3 * 10000,
                "km²": value3 * 10000000000,
                "in²": value3 * 6.452,
                "ft²": value3 * 929,
                "yd²": value3 * 8361,
                "mi²": value3 * 25899881103,
                "a": value3 * 1000000,
                "da": value3 * 10000000,
                "ha": value3 * 100000000,
                "ac": value3 * 40468560
            };
            return conversions[unit3] || value3;
        };

        const deg2rad = (degrees) => {
            return degrees * (Math.PI / 180);
        };

        // Initialize variables
        let lsv, ssv, areaResult, perimeterResult, diagonal, angle_α, radius;

        try {
            if (given == "1") { // Longer Side and Shorter Side
                if (isNumeric(ls) && isNumeric(ss)) {
                    lsv = myunitConvert(ls_unit, ls);
                    ssv = myunitConvert(ss_unit, ss);
                    // console.log(lsv,ssv);
                    if (ls > ss) {
                        areaResult = lsv * ssv;
                        perimeterResult = 2 * ss + 2 * lsv;
                        diagonal = Math.sqrt(lsv * lsv + ssv * ssv);
                        radius = diagonal / 2;
                        const δ = Math.atan(ssv / lsv);
                        angle_α = Math.PI - (2 * δ);
                        lsv = "";
                        ssv = "";
                        // console.log(perimeterResult,ssv,lsv);
                    } else {
                        return { error: 'Please! Longer side should be greater than shorter side.' };
                    }
                } else {
                    return { error: 'Please! Check Your Input.' };
                }
            } else if (given == "2") { // Longer Side and Area
                if (isNumeric(ls) && isNumeric(area)) {
                    lsv = myunitConvert(ls_unit, ls);
                    const av = centimeter(area_unit, area);
                    ssv = av / lsv;
                    perimeterResult = 2 * ssv + 2 * lsv;
                    const δ = Math.atan(ssv / lsv);
                    angle_α = Math.PI - (2 * δ);
                    diagonal = Math.sqrt(lsv * lsv + ssv * ssv);
                    radius = diagonal / 2;
                    lsv = "";
                    areaResult = "";
                } else {
                    return { error: 'Please! Check Your Input.' };
                }
            } else if (given == "3") { // Longer Side and Perimeter
                if (isNumeric(ls) && isNumeric(perimeter)) {
                    if ((ls * 2 + 1) <= perimeter) {
                        lsv = myunitConvert(ls_unit, ls);
                        const pv = myunitConvert(perimeter_unit, perimeter);
                        ssv = (pv - (2 * lsv)) / 2;
                        areaResult = lsv * ssv;
                        const δ = Math.atan(ssv / lsv);
                        angle_α = Math.PI - (2 * δ);
                        diagonal = Math.sqrt(lsv * lsv + ssv * ssv);
                        radius = diagonal / 2;
                        lsv = "";
                        perimeterResult = "";
                    } else {
                        return { error: 'Perimeter is too small.' };
                    }
                } else {
                    return { error: 'Please! Check Your Input.' };
                }
            } else if (given == "4") { // Longer Side and Angle alpha
                if (isNumeric(ls) && isNumeric(angle)) {
                    if (angle <= 90) {
                        return { error: 'Angle between diagonals must be greater than 90°.' };
                    } else {
                        lsv = myunitConvert(ls_unit, ls);
                        let angle_α_temp;
                        
                        if (angle_unit == "deg") {
                            angle_α_temp = 1 * angle;
                        } else if (angle_unit == "rad") {
                            angle_α_temp = 57.3 * angle;
                        } else if (angle_unit == "gon") {
                            angle_α_temp = 0.9 * angle;
                        } else {
                            angle_α_temp = 180 * angle;
                        }
                        
                        angle_α_temp = angle_α_temp / 2;
                        ssv = lsv / Math.tan(deg2rad(angle_α_temp));
                        areaResult = lsv * ssv;
                        perimeterResult = 2 * ssv + 2 * lsv;
                        diagonal = Math.sqrt(lsv * lsv + ssv * ssv);
                        radius = diagonal / 2;
                        lsv = "";
                        angle_α = "";
                    }
                } else {
                    return { error: 'Please! Check Your Input.' };
                }
            } else if (given == "5") { // Shorter Side and Area
                if (isNumeric(ss) && isNumeric(area)) {
                    ssv = myunitConvert(ss_unit, ss);
                    const av = centimeter(area_unit, area);
                    lsv = av / ssv;
                    perimeterResult = 2 * ssv + 2 * lsv;
                    const δ = Math.atan(ssv / lsv);
                    angle_α = Math.PI - (2 * δ);
                    diagonal = Math.sqrt(lsv * lsv + ssv * ssv);
                    radius = diagonal / 2;
                    ssv = "";
                    areaResult = "";
                } else {
                    return { error: 'Please! Check Your Input.' };
                }
            } else if (given == "6") { // Shorter Side and Perimeter
                if (isNumeric(ss) && isNumeric(perimeter)) {
                    if (perimeter >= ss * 4) {
                        ssv = myunitConvert(ss_unit, ss);
                        const pv = myunitConvert(perimeter_unit, perimeter);
                        lsv = (pv - 2 * ssv) / 2;
                        areaResult = lsv * ssv;
                        perimeterResult = 2 * ss + 2 * lsv;
                        diagonal = Math.sqrt(lsv * lsv + ssv * ssv);
                        radius = diagonal / 2;
                        const δ = Math.atan(ssv / lsv);
                        angle_α = Math.PI - (2 * δ);
                        ssv = "";
                        perimeterResult = "";
                    } else {
                        return { error: 'Perimeter is too small.' };
                    }
                } else {
                    return { error: 'Please! Check Your Input.' };
                }
            } else if (given == "7") { // Shorter Side and Angle
                if (isNumeric(ss) && isNumeric(angle)) {
                    ssv = myunitConvert(ss_unit, ss);
                    let angle_α_temp;
                    
                    if (angle_unit == "deg") {
                        angle_α_temp = 1 * angle;
                    } else if (angle_unit == "rad") {
                        angle_α_temp = 57.3 * angle;
                    } else if (angle_unit == "gon") {
                        angle_α_temp = 0.9 * angle;
                    } else {
                        angle_α_temp = 180 * angle;
                    }
                    
                    angle_α_temp = angle_α_temp / 2;
                    lsv = ssv * Math.tan(deg2rad(angle_α_temp));
                    areaResult = lsv * ssv;
                    perimeterResult = 2 * ssv + 2 * lsv;
                    diagonal = Math.sqrt(lsv * lsv + ssv * ssv);
                    radius = diagonal / 2;
                    ssv = "";
                    angle_α = "";
                } else {
                    return { error: 'Please! Check Your Input.' };
                }
            } else if (given == "8") { // Circumference
                if (isNumeric(circum)) {
                    const circumValue = myunitConvert(circum_unit, circum);
                    diagonal = circumValue * 2;
                    ssv = "";
                    lsv = "";
                    areaResult = "";
                    radius = "";
                    perimeterResult = "";
                    angle_α = "";
                }
            } else {
                return { error: 'Please! Check Your Input.' };
            }

            return {
                tech_lsv: lsv || '',
                tech_ssv: ssv || '',
                tech_area: areaResult || '',
                tech_perimeter: perimeterResult || '',
                tech_diagonal: diagonal || '',
                tech_angle_α: angle_α || '',
                tech_radius: radius || '',
              };

        } catch (error) {
            return { error: 'Please! Check Your Input.' };
        }
        
        // Helper function to check if value is numeric
        function isNumeric(value) {
            return !isNaN(parseFloat(value)) && isFinite(value);
        }
    }

       /**
    * getCalculationRationalZerosCalculator: Service Method
    * POST: /api/calculators-lol/rational-zeros-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
      */

      async getCalculationRationalZerosCalculator(body) {
          let v1 = body.tech_v1;
          let v2 = body.tech_v2;
          let v3 = body.tech_v3;
          let v4 = body.tech_v4;
          let v5 = body.tech_v5;
          let v6 = body.tech_v6;
          let v7 = body.tech_v7;
          let v8 = body.tech_v8;
          let v9 = body.tech_v9;
          let v10 = body.tech_v10;
          let no_of = body.tech_no_of;


        // Helper function to check if value is numeric
        const isNumeric = (value) => {
            return !isNaN(parseFloat(value)) && isFinite(value);
        };

        // Function to get divisors
        const printDivisors = (n) => {
            const divi = [];
            const absN = Math.abs(n);
            for (let i = 1; i <= absN; i++) {
                if (absN % i == 0) {
                    divi.push(i);
                }
            }
            return divi;
        };

        // Validate all inputs are numeric
        const allNumeric = [v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, no_of].every(isNumeric);
        
        if (!allNumeric) {
            return { error: 'Please! Check Your Input.' };
        }

        try {
            let q = parseFloat(v1);
            let p;

            // Determine p based on no_of
            switch (parseInt(no_of)) {
                case 2:
                    p = parseFloat(v3);
                    break;
                case 3:
                    p = parseFloat(v4);
                    break;
                case 4:
                    p = parseFloat(v5);
                    break;
                case 5:
                    p = parseFloat(v6);
                    break;
                case 6:
                    p = parseFloat(v7);
                    break;
                case 7:
                    p = parseFloat(v8);
                    break;
                case 8:
                    p = parseFloat(v9);
                    break;
                case 9:
                    p = parseFloat(v10);
                    break;
                default:
                    return { error: 'Please! Check Your Input.' };
            }

            // Make p positive for divisor calculation
            const pAbs = Math.abs(p);

            const array_p = printDivisors(pAbs);
            const new_times = array_p.map(value => (-1) * value);
            const array_q = printDivisors(q);
            const new_times2 = array_q.map(value => value * (-1));

            const final_p = [...array_p, ...new_times];
            const final_q = [...array_q, ...new_times2];

            const ans = [];
            const main_ans = [];
            const main_ans2 = [];
            const main_ans3 = [];

            // YAHAN PAR MAIN FIX HAI - PHP logic ke according calculation
            for (let i = 0; i < final_q.length; i++) {
                if (final_q[i] !== 1) {
                    for (const value of final_p) {
                        const calculatedValue = value / final_q[i];
                        
                        if (value % final_q[i] === 0) {
                            ans.push(calculatedValue);
                        } else {
                            ans.push(`\\frac{${value}}{${final_q[i]}}`);
                        }
                        main_ans.push(`\\frac{${value}}{${final_q[i]}}`);
                        main_ans2.push(calculatedValue);
                        main_ans3.push(`${value} / ${final_q[i]}`);
                    }
                }
            }

            // Get unique values - PHP ke jaisa filter karna
            const uq = [...new Set(ans)].filter(val => val !== null && val !== undefined && val !== '');

            // Format polynomial coefficients
            const formatCoefficient = (val, isFirst = false) => {
                const numVal = parseFloat(val);
                if (isFirst) {
                    return (numVal !== 1) ? numVal : '';
                }
                return (numVal >= 0) ? ` +${numVal}` : ` ${numVal}`;
            };

            const s1 = formatCoefficient(v1, true);
            const s2 = formatCoefficient(v2);
            const s3 = formatCoefficient(v3);
            const s4 = formatCoefficient(v4);
            const s5 = formatCoefficient(v5);
            const s6 = formatCoefficient(v6);
            const s7 = formatCoefficient(v7);
            const s8 = formatCoefficient(v8);
            const s9 = formatCoefficient(v9);
            const s10 = formatCoefficient(v10);

            const eq = [];
            const result = [];
            const final_result = [];

            for (let i = 0; i < uq.length; i++) {
                const uqVal = uq[i];
                // YAHAN PAR MAIN FIX HAI - sahi value use karo
                const mainAns2Val = main_ans2[i];

                switch (parseInt(no_of)) {
                    case 2:
                        eq.push(`\\( \\text{P}{\\left(x\\right)}=${s1}x^{2}${s2}x${s3}\\)`);
                        result.push(`\\( \\text{P}{\\left(${uqVal}\\right)}=\\left(${v1}\\right)\\left(${uqVal}\\right)^{2}+\\left(${v2}\\right)\\left(${uqVal}\\right)+${v3}\\)`);
                        // YAHAN PAR CALCULATION FIX KARO
                        const polyValue2 = 
                            parseFloat(v1) * Math.pow(mainAns2Val, 2) + 
                            parseFloat(v2) * mainAns2Val + 
                            parseFloat(v3);
                        final_result.push(polyValue2);
                        break;
                    case 3:
                        eq.push(`\\( \\text{P}{\\left(x\\right)}=${s1}x^{3}${s2}x^{2}${s3}x${s4}\\)`);
                        result.push(`\\( \\text{P}{\\left(${uqVal}\\right)}=\\left(${v1}\\right)\\left(${uqVal}\\right)^{3}+\\left(${v2}\\right)\\left(${uqVal}\\right)^{2}+\\left(${v3}\\right)\\left(${uqVal}\\right)+${v4}\\)`);
                        const polyValue3 = 
                            parseFloat(v1) * Math.pow(mainAns2Val, 3) + 
                            parseFloat(v2) * Math.pow(mainAns2Val, 2) + 
                            parseFloat(v3) * mainAns2Val + 
                            parseFloat(v4);
                        final_result.push(polyValue3);
                        break;
                    case 4:
                        eq.push(`\\( \\text{P}{\\left(x\\right)}=${s1}x^{4}${s2}x^{3}${s3}x^{2}${s4}x${s5}\\)`);
                        result.push(`\\( \\text{P}{\\left(${uqVal}\\right)}=\\left(${v1}\\right)\\left(${uqVal}\\right)^{4}+\\left(${v2}\\right)\\left(${uqVal}\\right)^{3}+\\left(${v3}\\right)\\left(${uqVal}\\right)^{2}+\\left(${v4}\\right)\\left(${uqVal}\\right)+${v5}\\)`);
                        const polyValue4 = 
                            parseFloat(v1) * Math.pow(mainAns2Val, 4) + 
                            parseFloat(v2) * Math.pow(mainAns2Val, 3) + 
                            parseFloat(v3) * Math.pow(mainAns2Val, 2) + 
                            parseFloat(v4) * mainAns2Val + 
                            parseFloat(v5);
                        final_result.push(polyValue4);
                        break;
                    case 5:
                        eq.push(`\\( \\text{P}{\\left(x\\right)}=${s1}x^{5}${s2}x^{4}${s3}x^{3}${s4}x^{2}${s5}x${s6}\\)`);
                        result.push(`\\( \\text{P}{\\left(${uqVal}\\right)}=\\left(${v1}\\right)\\left(${uqVal}\\right)^{5}+\\left(${v2}\\right)\\left(${uqVal}\\right)^{4}+\\left(${v3}\\right)\\left(${uqVal}\\right)^{3}+\\left(${v4}\\right)\\left(${uqVal}\\right)^{2}+\\left(${v5}\\right)\\left(${uqVal}\\right)+${v6}\\)`);
                        const polyValue5 = 
                            parseFloat(v1) * Math.pow(mainAns2Val, 5) + 
                            parseFloat(v2) * Math.pow(mainAns2Val, 4) + 
                            parseFloat(v3) * Math.pow(mainAns2Val, 3) + 
                            parseFloat(v4) * Math.pow(mainAns2Val, 2) + 
                            parseFloat(v5) * mainAns2Val + 
                            parseFloat(v6);
                        final_result.push(polyValue5);
                        break;
                    case 6:
                        eq.push(`\\( \\text{P}{\\left(x\\right)}=${s1}x^{6}${s2}x^{5}${s3}x^{4}${s4}x^{3}${s5}x^{2}${s6}x${s7}\\)`);
                        result.push(`\\( \\text{P}{\\left(${uqVal}\\right)}=\\left(${v1}\\right)\\left(${uqVal}\\right)^{6}+\\left(${v2}\\right)\\left(${uqVal}\\right)^{5}+\\left(${v3}\\right)\\left(${uqVal}\\right)^{4}+\\left(${v4}\\right)\\left(${uqVal}\\right)^{3}+\\left(${v5}\\right)\\left(${uqVal}\\right)^{2}+\\left(${v6}\\right)\\left(${uqVal}\\right)+${v7}\\)`);
                        const polyValue6 = 
                            parseFloat(v1) * Math.pow(mainAns2Val, 6) + 
                            parseFloat(v2) * Math.pow(mainAns2Val, 5) + 
                            parseFloat(v3) * Math.pow(mainAns2Val, 4) + 
                            parseFloat(v4) * Math.pow(mainAns2Val, 3) + 
                            parseFloat(v5) * Math.pow(mainAns2Val, 2) + 
                            parseFloat(v6) * mainAns2Val + 
                            parseFloat(v7);
                        final_result.push(polyValue6);
                        break;
                    case 7:
                        eq.push(`\\( \\text{P}{\\left(x\\right)}=${s1}x^{7}${s2}x^{6}${s3}x^{5}${s4}x^{4}${s5}x^{3}${s6}x^{2}${s7}x${s8}\\)`);
                        result.push(`\\( \\text{P}{\\left(${uqVal}\\right)}=\\left(${v1}\\right)\\left(${uqVal}\\right)^{7}+\\left(${v2}\\right)\\left(${uqVal}\\right)^{6}+\\left(${v3}\\right)\\left(${uqVal}\\right)^{5}+\\left(${v4}\\right)\\left(${uqVal}\\right)^{4}+\\left(${v5}\\right)\\left(${uqVal}\\right)^{3}+\\left(${v6}\\right)\\left(${uqVal}\\right)^{2}+\\left(${v7}\\right)\\left(${uqVal}\\right)+${v8}\\)`);
                        const polyValue7 = 
                            parseFloat(v1) * Math.pow(mainAns2Val, 7) + 
                            parseFloat(v2) * Math.pow(mainAns2Val, 6) + 
                            parseFloat(v3) * Math.pow(mainAns2Val, 5) + 
                            parseFloat(v4) * Math.pow(mainAns2Val, 4) + 
                            parseFloat(v5) * Math.pow(mainAns2Val, 3) + 
                            parseFloat(v6) * Math.pow(mainAns2Val, 2) + 
                            parseFloat(v7) * mainAns2Val + 
                            parseFloat(v8);
                        final_result.push(polyValue7);
                        break;
                    case 8:
                        eq.push(`\\( \\text{P}{\\left(x\\right)}=${s1}x^{8}${s2}x^{7}${s3}x^{6}${s4}x^{5}${s5}x^{4}${s6}x^{2}${s7}x^{2}${s8}x${s9}\\)`);
                        result.push(`\\( \\text{P}{\\left(${uqVal}\\right)}=\\left(${v1}\\right)\\left(${uqVal}\\right)^{}+\\left(${v2}\\right)\\left(${uqVal}\\right)^{7}+\\left(${v3}\\right)\\left(${uqVal}\\right)^{6}+\\left(${v4}\\right)\\left(${uqVal}\\right)^{5}+\\left(${v5}\\right)\\left(${uqVal}\\right)^{4}+\\left(${v6}\\right)\\left(${uqVal}\\right)^{3}+\\left(${v7}\\right)\\left(${uqVal}\\right)^{2}+\\left(${v8}\\right)\\left(${uqVal}\\right)+${v9}\\)`);
                        const polyValue8 = 
                            parseFloat(v1) * Math.pow(mainAns2Val, 8) + 
                            parseFloat(v2) * Math.pow(mainAns2Val, 7) + 
                            parseFloat(v3) * Math.pow(mainAns2Val, 6) + 
                            parseFloat(v4) * Math.pow(mainAns2Val, 5) + 
                            parseFloat(v5) * Math.pow(mainAns2Val, 4) + 
                            parseFloat(v6) * Math.pow(mainAns2Val, 3) + 
                            parseFloat(v7) * Math.pow(mainAns2Val, 2) + 
                            parseFloat(v8) * mainAns2Val + 
                            parseFloat(v9);
                        final_result.push(polyValue8);
                        break;
                    case 9:
                        eq.push(`\\( \\text{P}{\\left(x\\right)}=${s1}x^{9}${s2}x^{8}${s3}x^{7}${s4}x^{6}${s5}x^{5}${s6}x^{4}${s7}x^{3}${s8}x^{2}${s9}x${s10}\\)`);
                        result.push(`\\( \\text{P}{\\left(${uqVal}\\right)}=\\left(${v1}\\right)\\left(${uqVal}\\right)^{9}+\\left(${v2}\\right)\\left(${uqVal}\\right)^{8}+\\left(${v3}\\right)\\left(${uqVal}\\right)^{7}+\\left(${v4}\\right)\\left(${uqVal}\\right)^{6}+\\left(${v5}\\right)\\left(${uqVal}\\right)^{5}+\\left(${v6}\\right)\\left(${uqVal}\\right)^{4}+\\left(${v7}\\right)\\left(${uqVal}\\right)^{3}+\\left(${v8}\\right)\\left(${uqVal}\\right)^{2}+\\left(${v9}\\right)\\left(${uqVal}\\right)+${v10}\\)`);
                        const polyValue9 = 
                            parseFloat(v1) * Math.pow(mainAns2Val, 9) + 
                            parseFloat(v2) * Math.pow(mainAns2Val, 8) + 
                            parseFloat(v3) * Math.pow(mainAns2Val, 7) + 
                            parseFloat(v4) * Math.pow(mainAns2Val, 6) + 
                            parseFloat(v5) * Math.pow(mainAns2Val, 5) + 
                            parseFloat(v6) * Math.pow(mainAns2Val, 4) + 
                            parseFloat(v7) * Math.pow(mainAns2Val, 3) + 
                            parseFloat(v8) * Math.pow(mainAns2Val, 2) + 
                            parseFloat(v9) * mainAns2Val + 
                            parseFloat(v10);
                        final_result.push(polyValue9);
                        break;
                }
            }

            return {
                tech_v1: parseFloat(v1),
                tech_v2: parseFloat(v2),
                tech_v3: parseFloat(v3),
                tech_v4: parseFloat(v4),
                tech_v5: parseFloat(v5),
                tech_v6: parseFloat(v6),
                tech_v7: parseFloat(v7),
                tech_v8: parseFloat(v8),
                tech_v9: parseFloat(v9),
                tech_v10: parseFloat(v10),
                tech_no_of: parseInt(no_of),
                tech_p: p,
                tech_q: q,
                tech_main_ans: main_ans,
                tech_main_ans2: main_ans2,
                tech_main_ans3: main_ans3,
                tech_ans: ans,
                tech_uq: uq,
                tech_final_p: final_p,
                tech_final_q: final_q,
                tech_eq: eq,
                tech_result: result,
                tech_final_result: final_result,
            };

        } catch (error) {
            console.error('Error in rational zeros calculation:', error);
            return { error: 'Please! Check Your Input.' };
        }
    }


        /**
    * getCalculationAugmentedMatrixCalculator: Service Method
    * POST: /api/calculators-lol/augmented-matrix-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
      */

      async getCalculationAugmentedMatrixCalculator(body) {
        const { matrix2, matrix22, ...request } = body;

        // Helper functions
        const gcd22 = (a, b, f) => {
            if (f) {
                if (b <= 1)
                    return a;
            } else {
                if (!b)
                    return a;
            }
            return gcd22(b, a % b, f);
        };

        const roundresult2 = (x) => {
            const y = parseFloat(x);
            return roundnum2(y, 10);
        };

        const toPrecision2 = (number, precision) => {
            if (number == 0) return 0;
            const exponent = Math.floor(Math.log10(Math.abs(number)) + 1);
            const significand =
                Math.round(
                    (number / Math.pow(10, exponent)) *
                    Math.pow(10, precision)
                ) / Math.pow(10, precision);
            return significand * Math.pow(10, exponent);
        };

        const roundnum2 = (x, p) => {
            const n = parseFloat(x);
            const m = toPrecision2(n, (p + 1));
            const y = String(m);
            const i = y.indexOf('e');
            if (i == -1)
                return y;
            return y;
        };

        const digits_after_period2 = (x) => {
            const f = String(x);
            const i = f.indexOf('.');
            if (i == -1) return 0;
            return f.length - i - 1;
        };

        const convert2 = (xelem) => {
            let sign = '';
            let sign2 = '+';
            let f = false;
            const x = xelem;
            const x2 = roundresult2(x);
            const absx = Math.abs(x2);
            const y = Math.floor(absx);
            const frac = (absx - y);
            
            if (x2 < 0) {
                sign = sign2 = '-';
            }
            
            const d = digits_after_period2(absx);
            const den = Math.round(Math.pow(10, d));
            const num = Math.round(frac * den);
            const a12 = String(num);
            const len = a12.length;
            
            if (len > 8) f = true;
            
            const g = gcd22(num, den, f);
            const num2 = Math.round(num / g);
            const den2 = Math.round(den / g);
            
            const top_jawab = sign + (num2 + den2 * y);
            const down_jawab = den2;
            
            return [top_jawab, down_jawab];
        };

        const new_rref2 = (matrix) => {
            let lead = 0;
            let pz = JSON.parse(JSON.stringify(matrix)); // Deep copy
            const swap = [];
            const swap_line = [];
            const rowCount = matrix.length;
            
            if (rowCount === 0)
                return matrix;
                
            let columnCount = 0;
            if (matrix[0]) {
                columnCount = matrix[0].length;
            }
            
            let bus;
            if (rowCount > columnCount) {
                bus = rowCount - 2;
            } else if (rowCount < columnCount) {
                bus = rowCount;
            } else if (rowCount == columnCount) {
                bus = rowCount - 1;
            }

            for (let r = 0; r < bus; r++) {
                if (lead >= columnCount)
                    break;

                // Find pivot row
                let i = r;
                while (i < rowCount && matrix[i][lead] == 0) {
                    i++;
                    if (i == rowCount) {
                        i = r;
                        lead++;
                        if (lead == columnCount)
                            return [matrix, swap, swap_line, pz];
                    }
                }

                // Swap rows if needed
                if (i != r) {
                    const temp = matrix[r];
                    matrix[r] = matrix[i];
                    matrix[i] = temp;
                    
                    const temp2 = pz[r];
                    pz[r] = pz[i];
                    pz[i] = temp2;
                    
                    // FIX: Use 0-based indexing like Laravel
                    swap_line.push("Swap the row " + r + " with row " + i);
                    swap.push(JSON.parse(JSON.stringify(pz)));
                }

                // Normalize pivot row
                const lv = matrix[r][lead];
                if (lv != 0) {
                    for (let j = 0; j < columnCount; j++) {
                        matrix[r][j] = matrix[r][j] / lv;
                        pz[r][j] = pz[r][j] / lv;
                    }

                    const test1 = convert2(lv);
                    // FIX: Use 0-based indexing like Laravel
                    if (test1[1] == 1) {
                        swap_line.push('Divide row ' + r + ' by ' + lv + ": R<sub>" + r + "</sub> = R<sub>" + r + "</sub>/" + lv);
                    } else if (test1[1] != 1) {
                        const lv3 = test1[1] + "/" + test1[0];
                        swap_line.push('Multiply row ' + r + ' by ' + lv3 + ": R<sub>" + r + "</sub> = " + lv3 + " R<sub>" + r + "</sub>");
                    }
                    swap.push(JSON.parse(JSON.stringify(pz)));
                }

                // Eliminate other rows
                for (let i = 0; i < rowCount; i++) {
                    if (i !== r && matrix[i][lead] !== 0) {
                        const lv = matrix[i][lead];
                        const lv2 = pz[i][lead];
                        
                        for (let j = 0; j < columnCount; j++) {
                            matrix[i][j] -= lv * matrix[r][j];
                            pz[i][j] -= lv2 * pz[r][j];
                        }
                        
                        swap.push(JSON.parse(JSON.stringify(pz)));
                        const test = convert2(lv);
                        
                        let displayLv;
                        if (test[1] == 1) {
                            displayLv = lv;
                        } else {
                            displayLv = test[0] + "/" + test[1];
                        }
                        
                        // FIX: Use 0-based indexing like Laravel
                        if (lv < 0) {
                            swap_line.push('Add row ' + i + ' multiplied by ' + displayLv + " from row R" + r + ": R<sub>" + i + "</sub> = R<sub>" + i + "</sub> + " + displayLv + "R<sub>" + r + "</sub>");
                        } else if (lv >= 0) {
                            swap_line.push('Subtract row ' + i + ' multiplied by ' + displayLv + " from row R" + r + ": R<sub>" + i + "</sub> = R<sub>" + i + "</sub> - " + displayLv + "R<sub>" + r + "</sub>");
                        }
                    }
                }
                lead++;
            }

            return [matrix, swap, swap_line, pz];
        };

        try {
            // Extract matrix data from request
            const second_matrix = [];
            const rows = parseInt(matrix2);
            const cols = parseInt(matrix22);

            for (let i = 1; i <= rows; i++) {
                for (let j = 1; j <= cols; j++) {
                    const key = 'matrix3' + i + '_' + j;
                    if (request[key] !== undefined && !isNaN(parseFloat(request[key]))) {
                        second_matrix.push(parseFloat(request[key]));
                    }
                }
            }

            // Create matrix from flat array
            const zain = [];
            for (let i = 0; i < second_matrix.length; i += cols) {
                zain.push(second_matrix.slice(i, i + cols));
            }

            const fahad2 = new_rref2(zain);

            return {
                tech_matrix: fahad2[0],
                tech_swap: fahad2[1],
                tech_swap_line: fahad2[2],
                tech_pz: fahad2[3],
            };

        } catch (error) {
            console.error('Error in augmented matrix calculation:', error);
            return { error: 'Please! Check Your Input.' };
        }
    }

       /**
    * getCalculationElementaryMatrixCalculator: Service Method
    * POST: /api/calculators-lol/elementary-matrix-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
      */

      async getCalculationElementaryMatrixCalculator(body) {
       let matrix_size = body.tech_matrix_size;
        let pth_matrix = body.tech_pth_matrix;
        let a = body.tech_a;
        let b = body.tech_b;
        let type = body.tech_type;
        let result_q = body.tech_result_q;


        // Helper function to check if value is numeric
        const isNumeric = (value) => {
            return !isNaN(parseFloat(value)) && isFinite(value);
        };

        // Validate all inputs are numeric
        if (!isNumeric(matrix_size) || !isNumeric(pth_matrix) || !isNumeric(a) || !isNumeric(b) || !isNumeric(result_q)) {
            return { error: 'Please! Check Your Input.' };
        }

        try {
            const size = parseInt(matrix_size);
            const p = parseInt(pth_matrix);
            const q = parseInt(result_q);
            const scalarA = parseFloat(a);
            const scalarB = parseFloat(b);

            if (type == "row") {
                if ((q <= size && p <= size) && (q > 0 && p > 0)) {
                    if (p != q) {
                        // Create identity matrix
                        const identity_matrix = [];
                        const array = [];
                        
                        for (let row = 0; row < size; row++) {
                            identity_matrix[row] = [];
                            array[row] = [];
                            for (let col = 0; col < size; col++) {
                                // Checking if row is equal to column
                                if (row == col) {
                                    identity_matrix[row][col] = 1;
                                    array[row][col] = 1;
                                } else {
                                    identity_matrix[row][col] = 0;
                                    array[row][col] = 0;
                                }
                            }
                        }

                        // Create multiply matrix (copy of identity)
                        const multiply_matrix = JSON.parse(JSON.stringify(identity_matrix));

                        // Apply scalar multiplication to rows
                        for (let i = 0; i < size; i++) {
                            multiply_matrix[p - 1][i] = scalarA * identity_matrix[p - 1][i];
                            multiply_matrix[q - 1][i] = scalarB * identity_matrix[q - 1][i];
                        }

                        // Create addition matrix (copy of multiply_matrix)
                        const addition_matrix = JSON.parse(JSON.stringify(multiply_matrix));

                        // Perform row addition
                        for (let i = 0; i < size; i++) {
                            addition_matrix[q - 1][i] = addition_matrix[q - 1][i] + addition_matrix[p - 1][i];
                        }

                        // Create final result array
                        const array1 = [];
                        const array2 = [];
                        
                        for (let i = 0; i < size; i++) {
                            array1[0] = array1[0] || [];
                            array2[0] = array2[0] || [];
                            array1[0][i] = scalarA * identity_matrix[p - 1][i];
                            array2[0][i] = scalarB * identity_matrix[q - 1][i];
                        }

                        // Build final result
                        for (let i = 0; i < size; i++) {
                            array[q - 1][i] = array1[0][i] + array2[0][i];
                        }

                        return {
                            tech_array: array,
                            tech_identity_matrix: identity_matrix,
                            tech_multiply_matrix: multiply_matrix,
                            tech_addition_matrix: addition_matrix,
                        };
                    } else {
                        return { error: 'The row p and q cannot be equal.' };
                    }
                } else {
                    return { error: 'The row p and q cannot be greater then n or less then 1.' };
                }
            } else if (type == "col") {
                if ((q <= size && p <= size) && (q > 0 && p > 0)) {
                    if (p != q) {
                        // Create identity matrix
                        const identity_matrix = [];
                        const array = [];
                        
                        for (let row = 0; row < size; row++) {
                            identity_matrix[row] = [];
                            array[row] = [];
                            for (let col = 0; col < size; col++) {
                                // Checking if row is equal to column
                                if (row === col) {
                                    identity_matrix[row][col] = 1;
                                    array[row][col] = 1;
                                } else {
                                    identity_matrix[row][col] = 0;
                                    array[row][col] = 0;
                                }
                            }
                        }

                        // Create multiply matrix (copy of identity)
                        const multiply_matrix = JSON.parse(JSON.stringify(identity_matrix));

                        // Apply scalar multiplication to columns
                        for (let i = 0; i < size; i++) {
                            multiply_matrix[i][p - 1] = scalarA * identity_matrix[i][p - 1];
                            multiply_matrix[i][q - 1] = scalarB * identity_matrix[i][q - 1];
                        }

                        // Create addition matrix (copy of multiply_matrix)
                        const addition_matrix = JSON.parse(JSON.stringify(multiply_matrix));

                        // Perform column addition
                        for (let i = 0; i < size; i++) {
                            addition_matrix[i][q - 1] = addition_matrix[i][q - 1] + addition_matrix[i][p - 1];
                        }

                        // Create final result arrays
                        const array1 = [];
                        const array2 = [];
                        
                        for (let i = 0; i < size; i++) {
                            array1[i] = array1[i] || [];
                            array2[i] = array2[i] || [];
                            array1[i][0] = scalarA * identity_matrix[i][p - 1];
                            array2[i][0] = scalarB * identity_matrix[i][q - 1];
                        }

                        // Build final result
                        for (let i = 0; i < size; i++) {
                            array[i][q - 1] = array1[i][0] + array2[i][0];
                        }

                        return {
                            tech_array: array,
                            tech_identity_matrix: identity_matrix,
                            tech_multiply_matrix: multiply_matrix,
                            tech_addition_matrix: addition_matrix,
                        };
                    } else {
                        return { error: 'The column p and q cannot be equal.' };
                    }
                } else {
                    return { error: 'The column p and q cannot be greater then n or less then 1.' };
                }
            } else {
                return { error: 'Please! Check Your Input.' };
            }

        } catch (error) {
            console.error('Error in elementary matrix calculation:', error);
            return { error: 'Please! Check Your Input.' };
        }
    }


         /**
    * getCalculationDistanceFormulaCalculator: Service Method
    * POST: /api/calculators-lol/distance-formula-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
      */

      async getCalculationDistanceFormulaCalculator(body) {
       let type = body.tech_type;
        let dimen = body.tech_dimen;
        let px2 = body['tech_2px2'];
        let px1 = body['tech_2px1'];
        let x1 = body.tech_x1;
        let x2 = body.tech_x2;
        let x3 = body.tech_x3;
        let y1 = body.tech_y1;
        let y2 = body.tech_y2;
        let y3 = body.tech_y3;
        let m = body.tech_m;
        let m2 = body.tech_m2;
        let b = body.tech_b;
        let b2 = body.tech_b2;
        let x31 = body['tech_3x1'];
        let x32 = body['tech_3x2'];
        let x33 = body['tech_3x3'];
        let y31 = body['tech_3y1'];
        let y32 = body['tech_3y2'];
        let y33 = body['tech_3y3'];
        let z31 = body['tech_3z1'];
        let z32 = body['tech_3z2'];
        let z33 = body['tech_3z3'];
        let x41 = body['tech_4x1'];
        let x42 = body['tech_4x2'];
        let x43 = body['tech_4x3'];
        let y41 = body['tech_4y1'];
        let y42 = body['tech_4y2'];
        let y43 = body['tech_4y3'];
        let z41 = body['tech_4z1'];
        let z42 = body['tech_4z2'];
        let z43 = body['tech_4z3'];
        let k41 = body['tech_4k1'];
        let k42 = body['tech_4k2'];
        let k43 = body['tech_4k3'];
        let px31 = body['tech_3px1'];
        let px32 = body['tech_3px2'];
        let px33 = body['tech_3px3'];


        // Helper function to check if value is numeric
        const isNumeric = (value) => {
            return !isNaN(parseFloat(value)) && isFinite(value);
        };

        try {
            if (type == '2P' && dimen == '1D') {
                if (isNumeric(px1) && isNumeric(px2)) {
                    const ans = Math.sqrt(Math.pow((px2 - px1), 2));
                     return {
                      tech_ans: isNaN(ans) ? "NaN" : ans,
                  };
                } else {
                    return { error: 'Please fill all fields' };
                }
            }

            if (type === '2P' && dimen === '2D') {
                if (isNumeric(x1) && isNumeric(x2) && isNumeric(y1) && isNumeric(y2)) {
                    const ans = Math.round(Math.sqrt(Math.pow((x2 - x1), 2) + Math.pow((y2 - y1), 2)) * 10000) / 10000;
                    return {
                      tech_ans: isNaN(ans) ? "NaN" : ans,
                  };
                } else {
                    return { error: 'Please fill all fields' };
                }
            }

            if (type == '2P' && dimen == '3D') {
                if (isNumeric(x31) && isNumeric(y31) && isNumeric(z31) && isNumeric(x32) && isNumeric(y32) && isNumeric(z32)) {
                    const ans = Math.round(Math.sqrt(Math.pow((x32 - x31), 2) + Math.pow((y32 - y31), 2) + Math.pow((z32 - z31), 2)) * 10000) / 10000;
                     return {
                      tech_ans: isNaN(ans) ? "NaN" : ans,
                  };
                } else {
                    return { error: 'Please fill all fields' };
                }
            }

            if (type == '2P' && dimen == '4D') {
                if (isNumeric(x41) && isNumeric(y41) && isNumeric(z41) && isNumeric(k41) && isNumeric(x42) && isNumeric(y42) && isNumeric(z42) && isNumeric(k42)) {
                    const ans = Math.round(Math.sqrt(Math.pow((x42 - x41), 2) + Math.pow((y42 - y41), 2) + Math.pow((z42 - z41), 2) + Math.pow((k42 - k41), 2)) * 10000) / 10000;
                   return {
                      tech_ans: isNaN(ans) ? "NaN" : ans,
                  };

                } else {
                    return { error: 'Please fill all fields' };
                }
            }

            if (type == '3P' && dimen == '1D') {
                if (isNumeric(px31) && isNumeric(px32) && isNumeric(px33)) {
                    const ans1 = Math.sqrt(Math.pow((px32 - px31), 2));
                    const ans2 = Math.sqrt(Math.pow((px33 - px32), 2));
                    const ans3 = Math.sqrt(Math.pow((px33 - px31), 2));
                    return {
                      tech_ans1: isNaN(ans1) ? "NaN" : ans1,
                      tech_ans2: isNaN(ans2) ? "NaN" : ans2,
                      tech_ans3: isNaN(ans3) ? "NaN" : ans3,
                  };
                } else {
                    return { error: 'Please fill all fields' };
                }
            }

            if (type == '3P' && dimen == '2D') {
                if (isNumeric(x1) && isNumeric(x2) && isNumeric(x3) && isNumeric(y1) && isNumeric(y2) && isNumeric(y3)) {
                    const ans1 = Math.round(Math.sqrt(Math.pow((x2 - x1), 2) + Math.pow((y2 - y1), 2)) * 10000) / 10000;
                    const ans2 = Math.round(Math.sqrt(Math.pow((x3 - x2), 2) + Math.pow((y3 - y2), 2)) * 10000) / 10000;
                    const ans3 = Math.round(Math.sqrt(Math.pow((x3 - x1), 2) + Math.pow((y3 - y1), 2)) * 10000) / 10000;
                  return {
                      tech_ans1: isNaN(ans1) ? "NaN" : ans1,
                      tech_ans2: isNaN(ans2) ? "NaN" : ans2,
                      tech_ans3: isNaN(ans3) ? "NaN" : ans3,
                  };

                } else {
                    return { error: 'Please fill all fields' };
                }
            }

            if (type == '3P' && dimen == '3D') {
                if (isNumeric(x31) && isNumeric(y31) && isNumeric(z31) && isNumeric(x32) && isNumeric(y32) && isNumeric(z32) && isNumeric(x33) && isNumeric(y33) && isNumeric(z33)) {
                    const ans1 = Math.round(Math.sqrt(Math.pow((x32 - x31), 2) + Math.pow((y32 - y31), 2) + Math.pow((z32 - z31), 2)) * 10000) / 10000;
                    const ans2 = Math.round(Math.sqrt(Math.pow((x33 - x32), 2) + Math.pow((y33 - y32), 2) + Math.pow((z33 - z32), 2)) * 10000) / 10000;
                    const ans3 = Math.round(Math.sqrt(Math.pow((x33 - x31), 2) + Math.pow((y33 - y31), 2) + Math.pow((z33 - z31), 2)) * 10000) / 10000;
                   return {
                      tech_ans1: isNaN(ans1) ? "NaN" : ans1,
                      tech_ans2: isNaN(ans2) ? "NaN" : ans2,
                      tech_ans3: isNaN(ans3) ? "NaN" : ans3,
                  };

                } else {
                    return { error: 'Please fill all fields' };
                }
            }

            if (type == '3P' && dimen == '4D') {
                if (isNumeric(x41) && isNumeric(y41) && isNumeric(z41) && isNumeric(k41) && isNumeric(x42) && isNumeric(y42) && isNumeric(z42) && isNumeric(k42) && isNumeric(x43) && isNumeric(y43) && isNumeric(z43) && isNumeric(k43)) {
                    const ans1 = Math.round(Math.sqrt(Math.pow((x42 - x41), 2) + Math.pow((y42 - y41), 2) + Math.pow((z42 - z41), 2) + Math.pow((k42 - k41), 2)) * 10000) / 10000;
                    const ans2 = Math.round(Math.sqrt(Math.pow((x43 - x42), 2) + Math.pow((y43 - y42), 2) + Math.pow((z43 - z42), 2) + Math.pow((k43 - k42), 2)) * 10000) / 10000;
                    const ans3 = Math.round(Math.sqrt(Math.pow((x43 - x41), 2) + Math.pow((y43 - y41), 2) + Math.pow((z43 - z41), 2) + Math.pow((k43 - k41), 2)) * 10000) / 10000;
                   return {
                    tech_ans1: isNaN(ans1) ? "NaN" : ans1,
                    tech_ans2: isNaN(ans2) ? "NaN" : ans2,
                    tech_ans3: isNaN(ans3) ? "NaN" : ans3,
                };

                } else {
                    return { error: 'Please fill all fields' };
                }
            }

            if (type == 'PS') {
                if (isNumeric(x1) && isNumeric(y1) && isNumeric(m) && isNumeric(b)) {
                    const ans = Math.round(Math.abs(m * x1 - y1 + b) / Math.sqrt((Math.pow(m, 2) + 1)) * 10000) / 10000;
                    return {
                      tech_ans: isNaN(ans) ? "NaN" : ans,
                  };
                } else {
                    return { error: 'Please fill all fields' };
                }
            }

            if (type == 'PL') {
                if (isNumeric(m2) && isNumeric(b2) && isNumeric(m) && isNumeric(b)) {
                    if (m2 != m) {
                        return { error: 'Make sure that lines are parallel (m = m₂)' };
                    }
                    const ans = Math.round((b2 - b) / Math.sqrt((Math.pow(m, 2) + 1)) * 10000) / 10000;
                     return {
                      tech_ans: isNaN(ans) ? "NaN" : ans,
                  };
                } else {
                    return { error: 'Please fill all fields' };
                }
            }

            // If no matching type found
            return { error: 'Please! Check Your Input.' };

        } catch (error) {
            console.error('Error in distance formula calculation:', error);
            return { error: 'Please! Check Your Input.' };
        }
    }


          /**
    * getCalculationVolumeOfCapsuleCalculator: Service Method
    * POST: /api/calculators-lol/volume-of-capsule
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
      */

      async getCalculationVolumeOfCapsuleCalculator(body) {
      let choose = body.tech_choose;
      let first = body.tech_first;
      let first_unit = body.tech_first_unit;
      let second = body.tech_second;
      let second_unit = body.tech_second_unit;
      let pi_val = body.tech_pi_val;
      let units = body.tech_units;


        // Helper function to check if value is numeric
        const isNumeric = (value) => {
            return !isNaN(parseFloat(value)) && isFinite(value);
        };

        // Unit conversion function
        const newconvert_into_cm = (unit, value) => {
            const conversions = {
                "mm": value * 0.1,
                "cm": value * 1,
                "m": value * 100,
                "km": value * 1000,
                "in": value * 2.54,
                "ft": value * 30.48,
                "yd": value * 91.44,
                "mi": value * 160934
            };
            return conversions[unit] || value;
        };

        // Validate inputs
        if (!isNumeric(first) || !isNumeric(second) || !isNumeric(pi_val)) {
            return { error: 'Please Check Your Input.' };
        }

        try {
            // Convert inputs to cm
            const first_cm = newconvert_into_cm(first_unit, parseFloat(first));
            const second_cm = newconvert_into_cm(second_unit, parseFloat(second));
            const pi = parseFloat(pi_val);

            let radius, side, volume, surface, circumference;
        
            // Calculate based on chosen option
            switch (choose) {
                case "a_r": // radius and side
                    radius = first_cm;
                    side = second_cm;
                    volume = pi * Math.pow(radius, 2) * ((4/3) * radius + side);
                    surface = 2 * pi * radius * (2 * radius + side);
                    circumference = 2 * pi * radius;
                        console.log(volume,surface,circumference)
                    break;

                case "v_r": // radius and volume
                    radius = first_cm;
                    volume = second_cm;
                    side = ((volume / (pi * Math.pow(radius, 2))) - ((4/3) * radius));
                    surface = 2 * pi * radius * (2 * radius + side);
                    circumference = 2 * pi * radius;
                    break;

                case "s_r": // radius and surface
                    radius = first_cm;
                    surface = second_cm;
                    side = surface / (2 * pi * radius) - 2 * radius;
                    volume = pi * Math.pow(radius, 2) * ((4/3) * radius + side);
                    circumference = 2 * pi * radius;
                    break;

                default: // side and circumference
                    side = first_cm;
                    circumference = second_cm;
                    radius = circumference / (2 * pi);
                    volume = pi * Math.pow(radius, 2) * ((4/3) * radius + side);
                    surface = 2 * pi * radius * (2 * radius + side);
                    break;
            }

            // Unit conversion factors
            const conversionFactors = {
                "mm": { single_val: 10, square_val: 100, cube_val: 1000 },
                "cm": { single_val: 1, square_val: 1, cube_val: 1 },
                "m": { single_val: 0.01, square_val: 0.0001, cube_val: 0.000001 },
                "km": { single_val: 0.00001, square_val: 0.0000000001, cube_val: 0.000000000000001 },
                "in": { single_val: 0.393701, square_val: 0.155, cube_val: 0.0610237 },
                "ft": { single_val: 0.0328084, square_val: 0.0010763888889, cube_val: 0.000035315 },
                "yd": { single_val: 0.0109361, square_val: 0.00011959876543333333655, cube_val: 0.00000130795 },
                "mi": { single_val: 0.0000062137, square_val: 0.00000000003861013863421143294, cube_val: 0.000000000000000239913 }
            };

            const factors = conversionFactors[units] || conversionFactors.cm;

            // Convert results to desired units
            const result = {
              tech_radius: isNaN(radius) ? "NaN" : Math.round((radius * factors.single_val) * 100) / 100,
              tech_side: isNaN(side) ? "NaN" : Math.round((side * factors.single_val) * 100) / 100,
              tech_volume: isNaN(volume) ? "NaN" : Math.round((volume * factors.cube_val) * 100) / 100,
              tech_surface: isNaN(surface) ? "NaN" : Math.round((surface * factors.square_val) * 100) / 100,
              tech_circumference: isNaN(circumference) ? "NaN" : Math.round((circumference * factors.single_val) * 100) / 100,

            };

            return result;

        } catch (error) {
            console.error('Error in capsule volume calculation:', error);
            return { error: 'Please Check Your Input.' };
        }
    }


        /**
    * getCalculationConicalFrustumVolumeCalculator: Service Method
    * POST: /api/calculators-lol/conical-frustum-volume-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
      */

     async getCalculationConicalFrustumVolumeCalculator(body) {
       let choose = body.tech_choose;
      let first = body.tech_first;
      let first_unit = body.tech_first_unit;
      let second = body.tech_second;
      let second_unit = body.tech_second_unit;
      let third = body.tech_third;
      let third_unit = body.tech_third_unit;
      let pi_val = body.tech_pi_val;
      let units = body.tech_units;

        // Helper function to check if value is numeric
        const isNumeric = (value) => {
            return !isNaN(parseFloat(value)) && isFinite(value);
        };

        // Unit conversion function
        const new_convert_into_cm = (unit, value) => {
            const conversions = {
                "mm": value * 0.1,
                "cm": value * 1,
                "m": value * 100,
                "km": value * 1000,
                "in": value * 2.54,
                "ft": value * 30.48,
                "yd": value * 91.44,
                "mi": value * 160934
            };
            return conversions[unit] || value;
        };

        // Validate inputs
        if (!isNumeric(first) || !isNumeric(second) || !isNumeric(third) || !isNumeric(pi_val)) {
            return { error: 'Please Check Your Input.' };
        }

        try {
            // Convert inputs to cm
            const first_cm = new_convert_into_cm(first_unit, parseFloat(first));
            const second_cm = new_convert_into_cm(second_unit, parseFloat(second));
            const third_cm = new_convert_into_cm(third_unit, parseFloat(third));
            const pi = parseFloat(pi_val);

            let radius_1, radius_2, height, slant_height, volume, lsa, tsa, bsa, ttsa;

            // Calculate based on chosen option
            switch (choose) {
                case "r_h": // radius and height
                    radius_1 = first_cm;
                    radius_2 = second_cm;
                    height = third_cm;
                    slant_height = Math.sqrt(Math.pow(radius_1 - radius_2, 2) + Math.pow(height, 2));
                    lsa = pi * (radius_1 + radius_2) * Math.sqrt(Math.pow(radius_1 - radius_2, 2) + Math.pow(height, 2));
                    tsa = pi * Math.pow(radius_1, 2);
                    bsa = pi * Math.pow(radius_2, 2);
                    ttsa = pi * (Math.pow(radius_1, 2) + Math.pow(radius_2, 2) + (radius_1 + radius_2) * Math.sqrt(Math.pow(radius_1 - radius_2, 2) + Math.pow(height, 2)));
                    volume = (1/3) * pi * height * (radius_1 * radius_1 + radius_2 * radius_2 + (radius_1 * radius_2));
                    break;

                case "r_sh": // radius and slant height
                    radius_1 = first_cm;
                    radius_2 = second_cm;
                    slant_height = third_cm;
                    height = Math.sqrt(Math.pow(slant_height, 2) - Math.pow(radius_1 - radius_2, 2));
                    volume = (1/3) * pi * height * (radius_1 * radius_1 + radius_2 * radius_2 + (radius_1 * radius_2));
                    lsa = pi * (radius_1 + radius_2) * Math.sqrt(Math.pow(radius_1 - radius_2, 2) + Math.pow(height, 2));
                    tsa = pi * Math.pow(radius_1, 2);
                    bsa = pi * Math.pow(radius_2, 2);
                    ttsa = pi * (Math.pow(radius_1, 2) + Math.pow(radius_2, 2) + (radius_1 + radius_2) * Math.sqrt(Math.pow(radius_1 - radius_2, 2) + Math.pow(height, 2)));
                    break;

                case "r_v": // radius and volume
                    radius_1 = first_cm;
                    radius_2 = second_cm;
                    volume = third_cm;
                    height = (volume * 3) / (pi * (radius_1 * radius_1 + radius_2 * radius_2 + (radius_1 * radius_2)));
                    slant_height = Math.sqrt(Math.pow(radius_1 - radius_2, 2) + Math.pow(height, 2));
                    lsa = pi * (radius_1 + radius_2) * Math.sqrt(Math.pow(radius_1 - radius_2, 2) + Math.pow(height, 2));
                    tsa = pi * Math.pow(radius_1, 2);
                    bsa = pi * Math.pow(radius_2, 2);
                    ttsa = pi * (Math.pow(radius_1, 2) + Math.pow(radius_2, 2) + (radius_1 + radius_2) * Math.sqrt(Math.pow(radius_1 - radius_2, 2) + Math.pow(height, 2)));
                    break;

                case "r_l": // radius and lateral surface area
                    radius_1 = first_cm;
                    radius_2 = second_cm;
                    lsa = third_cm;
                    height = Math.sqrt(Math.pow(lsa / (pi * (radius_1 + radius_2)), 2) - Math.pow(radius_1 - radius_2, 2));
                    slant_height = Math.sqrt(Math.pow(radius_1 - radius_2, 2) + Math.pow(height, 2));
                    tsa = pi * Math.pow(radius_1, 2);
                    bsa = pi * Math.pow(radius_2, 2);
                    ttsa = pi * (radius_1 + radius_2) * Math.sqrt(Math.pow(radius_1 - radius_2, 2) + Math.pow(height, 2));
                    volume = (1/3) * pi * height * (radius_1 * radius_1 + radius_2 * radius_2 + (radius_1 * radius_2));
                    break;

                default: // radius and total surface area
                    radius_1 = first_cm;
                    radius_2 = second_cm;
                    ttsa = third_cm;
                    height = Math.sqrt(Math.pow(radius_1 + radius_2, 2) - Math.pow(radius_1 - radius_2, 2) - Math.pow(ttsa / pi, 2));
                    volume = (1/3) * pi * height * (radius_1 * radius_1 + radius_2 * radius_2 + (radius_1 * radius_2));
                    lsa = pi * (radius_1 + radius_2) * Math.sqrt(Math.pow(radius_1 - radius_2, 2) + Math.pow(height, 2));
                    slant_height = Math.sqrt(Math.pow(radius_1 - radius_2, 2) + Math.pow(height, 2));
                    tsa = pi * Math.pow(radius_1, 2);
                    bsa = pi * Math.pow(radius_2, 2);
                    break;
            }

            // Unit conversion factors
            const conversionFactors = {
                "mm": { single_val: 10, square_val: 100, cube_val: 1000 },
                "cm": { single_val: 1, square_val: 1, cube_val: 1 },
                "m": { single_val: 0.01, square_val: 0.0001, cube_val: 0.000001 },
                "km": { single_val: 0.00001, square_val: 0.0000000001, cube_val: 0.000000000000001 },
                "in": { single_val: 0.393701, square_val: 0.155, cube_val: 0.0610237 },
                "ft": { single_val: 0.0328084, square_val: 0.0010763888889, cube_val: 0.000035315 },
                "yd": { single_val: 0.0109361, square_val: 0.00011959876543333333655, cube_val: 0.00000130795 },
                "mi": { single_val: 0.0000062137, square_val: 0.00000000003861013863421143294, cube_val: 0.000000000000000239913 }
            };

            const factors = conversionFactors[units] || conversionFactors.cm;

            // Convert results to desired units and round to 2 decimal places
            const result = {
              tech_radius_1: isNaN(radius_1) ? "NaN" : Math.round((radius_1 * factors.single_val) * 100) / 100,
              tech_radius_2: isNaN(radius_2) ? "NaN" : Math.round((radius_2 * factors.single_val) * 100) / 100,
              tech_height: isNaN(height) ? "NaN" : Math.round((height * factors.single_val) * 100) / 100,
              tech_slant_height: isNaN(slant_height) ? "NaN" : Math.round((slant_height * factors.single_val) * 100) / 100,
              tech_volume: isNaN(volume) ? "NaN" : Math.round((volume * factors.cube_val) * 100) / 100,
              tech_lsa: isNaN(lsa) ? "NaN" : Math.round((lsa * factors.square_val) * 100) / 100,
              tech_tsa: isNaN(tsa) ? "NaN" : Math.round((tsa * factors.square_val) * 100) / 100,
              tech_bsa: isNaN(bsa) ? "NaN" : Math.round((bsa * factors.square_val) * 100) / 100,
              tech_ttsa: isNaN(ttsa) ? "NaN" : Math.round((ttsa * factors.square_val) * 100) / 100,

            };

            return result;

        } catch (error) {
            console.error('Error in conical frustum calculation:', error);
            return { error: 'Please Check Your Input.' };
        }
    }

         /**
    * getCalculationVolumeOfRectangleCalculator: Service Method
    * POST: /api/calculators-lol/volume-of-a-rectangle
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
      */

        async getCalculationVolumeOfRectangleCalculator(body) {
            let choose = body.tech_choose;
            let first = body.tech_first;
            let first_unit = body.tech_first_unit;
            let second = body.tech_second;
            let second_unit = body.tech_second_unit;
            let third = body.tech_third;
            let third_unit = body.tech_third_unit;
            let units = body.tech_units;

        // Helper function to check if value is numeric
        const isNumeric = (value) => {
            return !isNaN(parseFloat(value)) && isFinite(value);
        };

        // Unit conversion function
        const convert_into_cm = (unit, value) => {
            const conversions = {
                "mm": value * 0.1,
                "cm": value * 1,
                "m": value * 100,
                "km": value * 1000,
                "in": value * 2.54,
                "ft": value * 30.48,
                "yd": value * 91.44,
                "mi": value * 160934
            };
            return conversions[unit] || value;
        };

        // Validate inputs
        if (!isNumeric(first) || !isNumeric(second) || !isNumeric(third)) {
            return { error: 'Please Enter Valid Input.' };
        }

        try {
            // Convert inputs to cm
            const first_cm = convert_into_cm(first_unit, parseFloat(first));
            const second_cm = convert_into_cm(second_unit, parseFloat(second));
            const third_cm = convert_into_cm(third_unit, parseFloat(third));

            let length, width, height, diagonal, s_tot, s_lat, s_top, s_btm, volume_ans;

            // Calculate based on chosen option
            switch (choose) {
                case "hlw": // height, length, width
                    length = first_cm;
                    width = second_cm;
                    height = third_cm;
                    diagonal = Math.sqrt((Math.pow(length, 2)) + (Math.pow(width, 2)) + (Math.pow(height, 2)));
                    s_tot = 2 * ((length * width) + (length * height) + (width * height));
                    s_lat = 2 * height * (length + width);
                    s_top = length * width;
                    s_btm = length * width;
                    volume_ans = length * width * height;
                    break;

                case "slw": // surface area, length, width
                    length = first_cm;
                    width = second_cm;
                    s_tot = third_cm;
                    height = ((s_tot / 2) - (length * width)) / (length + width);
                    diagonal = Math.sqrt((Math.pow(length, 2)) + (Math.pow(width, 2)) + (Math.pow(height, 2)));
                    s_lat = 2 * height * (length + width);
                    s_top = length * width;
                    s_btm = length * width;
                    volume_ans = length * width * height;
                    break;

                case "vlw": // volume, length, width
                    length = first_cm;
                    width = second_cm;
                    volume_ans = third_cm;
                    height = volume_ans / (length * width);
                    diagonal = Math.sqrt((Math.pow(length, 2)) + (Math.pow(width, 2)) + (Math.pow(height, 2)));
                    s_tot = 2 * ((length * width) + (length * height) + (width * height));
                    s_lat = 2 * height * (length + width);
                    s_top = length * width;
                    s_btm = length * width;
                    break;

                default: // diagonal, length, width
                    length = first_cm;
                    width = second_cm;
                    diagonal = third_cm;
                    height = Math.sqrt((Math.pow(diagonal, 2)) - (Math.pow(length, 2)) - (Math.pow(width, 2)));
                    s_tot = 2 * ((length * width) + (length * height) + (width * height));
                    s_lat = 2 * height * (length + width);
                    s_top = length * width;
                    s_btm = length * width;
                    volume_ans = length * width * height;
                    break;
            }

            // Unit conversion factors
            const conversionFactors = {
                "mm": { single_val: 10, square_val: 100, cube_val: 1000 },
                "cm": { single_val: 1, square_val: 1, cube_val: 1 },
                "m": { single_val: 0.01, square_val: 0.0001, cube_val: 0.000001 },
                "km": { single_val: 0.00001, square_val: 0.0000000001, cube_val: 0.000000000000001 },
                "in": { single_val: 0.393701, square_val: 0.155, cube_val: 0.0610237 },
                "ft": { single_val: 0.0328084, square_val: 0.0010763888889, cube_val: 0.000035315 },
                "yd": { single_val: 0.0109361, square_val: 0.00011959876543333333655, cube_val: 0.00000130795 },
                "mi": { single_val: 0.0000062137, square_val: 0.00000000003861013863421143294, cube_val: 0.000000000000000239913 }
            };

            const factors = conversionFactors[units] || conversionFactors.cm;

            // Convert results to desired units and round to 2 decimal places
            const result = {
              tech_length: isNaN(length) ? "NaN" : Math.round((length * factors.single_val) * 100) / 100,
              tech_width: isNaN(width) ? "NaN" : Math.round((width * factors.single_val) * 100) / 100,
              tech_height: isNaN(height) ? "NaN" : Math.round((height * factors.single_val) * 100) / 100,
              tech_diagonal: isNaN(diagonal) ? "NaN" : Math.round((diagonal * factors.single_val) * 100) / 100,
              tech_s_tot: isNaN(s_tot) ? "NaN" : Math.round((s_tot * factors.square_val) * 100) / 100,
              tech_s_lat: isNaN(s_lat) ? "NaN" : Math.round((s_lat * factors.square_val) * 100) / 100,
              tech_s_top: isNaN(s_top) ? "NaN" : Math.round((s_top * factors.square_val) * 100) / 100,
              tech_s_btm: isNaN(s_btm) ? "NaN" : Math.round((s_btm * factors.square_val) * 100) / 100,
              tech_volume_ans: isNaN(volume_ans) ? "NaN" : Math.round((volume_ans * factors.cube_val) * 100) / 100,

            };

            return result;

        } catch (error) {
            console.error('Error in rectangular volume calculation:', error);
            return { error: 'Please Enter Valid Input.' };
        }
    }

       /**
    * getCalculationSimilarTrianglesCalculator: Service Method
    * POST: /api/calculators-lol/similar-triangles-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
      */

      async getCalculationSimilarTrianglesCalculator(body) {
              let type = body.tech_type;
            let similarity = body.tech_similarity;

            let ABC_f = body.tech_ABC_f;
            let ABC_f_unit = body.tech_ABC_f_unit;
            let ABC_f_deg_rad = body.tech_ABC_f_deg_rad;

            let ABC_s = body.tech_ABC_s;
            let ABC_s_unit = body.tech_ABC_s_unit;
            let ABC_s_deg_rad = body.tech_ABC_s_deg_rad;

            let ABC_t = body.tech_ABC_t;
            let ABC_t_unit = body.tech_ABC_t_unit;
            let ABC_t_deg_rad = body.tech_ABC_t_deg_rad;

            let ABC_corresponding = body.tech_ABC_corresponding;
            let ABC_corresponding_unit = body.tech_ABC_corresponding_unit;

            let scale_factor = body.tech_scale_factor;

            let DEF_f = body.tech_DEF_f;
            let DEF_f_unit = body.tech_DEF_f_unit;
            let DEF_f_deg_rad = body.tech_DEF_f_deg_rad;

            let DEF_s = body.tech_DEF_s;
            let DEF_s_unit = body.tech_DEF_s_unit;
            let DEF_s_deg_rad = body.tech_DEF_s_deg_rad;

            let DEF_t = body.tech_DEF_t;
            let DEF_t_unit = body.tech_DEF_t_unit;
            let DEF_t_deg_rad = body.tech_DEF_t_deg_rad;

            let DEF_corresponding = body.tech_DEF_corresponding;
            let DEF_corresponding_unit = body.tech_DEF_corresponding_unit;


        // Helper function to check if value is numeric
        const isNumeric = (value) => {
            return !isNaN(parseFloat(value)) && isFinite(value);
        };

        // Unit conversion function for length
        const imp_unit = (a, b) => {
            const conversions = {
                "mm": a / 10,
                "cm": a * 1,
                "m": a * 100,
                "km": a * 100000,
                "in": a * 2.54,
                "ft": a * 30.48,
                "yd": a * 91.44,
                "mi": a * 160900
            };
            return conversions[b] || a;
        };

        // Angle unit conversion function
        const ang_unit = (a, b) => {
            if (b == "rad") {
                return a * 114.592; // Convert radians to degrees (180/π ≈ 57.296, but using 114.592 as in original)
            } else {
                return a * 1; // Degrees remain as is
            }
        };

        try {
            if (type == "1") {
                // Similarity check
                if (similarity == "SSS") {
                    if (isNumeric(ABC_f) && isNumeric(ABC_s) && isNumeric(ABC_t) && 
                        isNumeric(DEF_f) && isNumeric(DEF_s) && isNumeric(DEF_t)) {
                        
                        const abc_f = imp_unit(parseFloat(ABC_f), ABC_f_unit);
                        const abc_s = imp_unit(parseFloat(ABC_s), ABC_s_unit);
                        const abc_t = imp_unit(parseFloat(ABC_t), ABC_t_unit);
                        const def_f = imp_unit(parseFloat(DEF_f), DEF_f_unit);
                        const def_s = imp_unit(parseFloat(DEF_s), DEF_s_unit);
                        const def_t = imp_unit(parseFloat(DEF_t), DEF_t_unit);

                        let jawab, symbol;
                        if ((abc_f == def_f) && (abc_s == def_s) && (abc_t == def_t)) {
                            symbol = "∼";
                            jawab = "equal";
                        } else {
                            jawab = "notequal";
                            symbol = "≁";
                        }

                        return {
                            tech_jawab: jawab,
                            tech_symbol: symbol,
                        };
                    } else {
                        return { error: 'Please Check Your Input.' };
                    }

                } else if (similarity == "SAS") {
                    if (isNumeric(ABC_f) && isNumeric(ABC_s) && isNumeric(ABC_t) && 
                        isNumeric(DEF_f) && isNumeric(DEF_s) && isNumeric(DEF_t)) {
                        
                        const abc_f = imp_unit(parseFloat(ABC_f), ABC_f_unit);
                        const abc_s = imp_unit(parseFloat(ABC_s), ABC_s_unit);
                        const abc_t = ang_unit(parseFloat(ABC_t), ABC_t_deg_rad);
                        const def_f = imp_unit(parseFloat(DEF_f), DEF_f_unit);
                        const def_s = imp_unit(parseFloat(DEF_s), DEF_s_unit);
                        const def_t = ang_unit(parseFloat(DEF_t), DEF_t_deg_rad);

                        let jawab, symbol;
                        if ((abc_f == def_f) && (abc_s == def_s) && (abc_t == def_t)) {
                            symbol = "∼";
                            jawab = "equal";
                        } else {
                            jawab = "notequal";
                            symbol = "≁";
                        }

                        return {
                            tech_jawab: jawab,
                            tech_symbol: symbol,
                        };
                    } else {
                        return { error: 'Please Check Your Input.' };
                    }

                } else {
                    // AA similarity
                    if (isNumeric(ABC_f) && isNumeric(ABC_s) && isNumeric(ABC_corresponding) && 
                        isNumeric(DEF_f) && isNumeric(DEF_s) && isNumeric(DEF_corresponding)) {
                        
                        const abc_f = ang_unit(parseFloat(ABC_f), ABC_f_deg_rad);
                        const abc_s = ang_unit(parseFloat(ABC_s), ABC_s_deg_rad);
                        const abc_corresponding = imp_unit(parseFloat(ABC_corresponding), ABC_corresponding_unit);
                        const def_f = ang_unit(parseFloat(DEF_f), DEF_f_deg_rad);
                        const def_s = ang_unit(parseFloat(DEF_s), DEF_s_deg_rad);
                        const def_corresponding = imp_unit(parseFloat(DEF_corresponding), DEF_corresponding_unit);

                        const ACB_jawab = 180 - (abc_f + abc_s);
                        const DEF_jawab = 180 - (def_f + def_s);
                        const scale_ans = def_corresponding / abc_corresponding;
                        let jawab, symbol;
                        if ((abc_f == def_f) && (abc_s == def_s)) {
                            symbol = "∼";
                            jawab = "equal";
                        } else {
                            jawab = "notequal";
                            symbol = "≁";
                        }

                        return {
                            tech_jawab: jawab,
                            tech_symbol: symbol,
                            tech_ACB_jawab: isNaN(ACB_jawab) ? "NaN" : ACB_jawab,
                            tech_DEF_jawab: isNaN(DEF_jawab) ? "NaN" : DEF_jawab,
                            tech_scale_ans: isNaN(scale_ans) ? "NaN" : scale_ans,

                        };
                    } else {
                        return { error: 'Please Check Your Input.' };
                    }
                }

            } else {
                // Scale factor calculation
                if (isNumeric(ABC_f) && isNumeric(ABC_s) && isNumeric(ABC_t) && isNumeric(scale_factor)) {
                    
                    const abc_f = imp_unit(parseFloat(ABC_f), ABC_f_unit);
                    const abc_s = imp_unit(parseFloat(ABC_s), ABC_s_unit);
                    const abc_t = imp_unit(parseFloat(ABC_t), ABC_t_unit);
                    const scale = parseFloat(scale_factor);

                    // Calculate ABC triangle properties
                    const ABC_perimeter_ans = abc_f + abc_s + abc_t;
                    const ABC_semi = ABC_perimeter_ans / 2;
                    const ABC_area_ans = Math.sqrt(ABC_semi * ((ABC_semi - abc_f) * (ABC_semi - abc_s) * (ABC_semi - abc_t)));

                    // Calculate DEF triangle properties using scale factor
                    const DEF_f_ans = abc_f * scale;
                    const DEF_s_ans = abc_s * scale;
                    const DEF_t_ans = abc_t * scale;
                    const DEF_perimeter_ans = DEF_f_ans + DEF_s_ans + DEF_t_ans;
                    const DEF_semi = DEF_perimeter_ans / 2;
                    const DEF_area_ans = Math.sqrt(DEF_semi * ((DEF_semi - DEF_f_ans) * (DEF_semi - DEF_s_ans) * (DEF_semi - DEF_t_ans)));

                    return {
                      tech_ABC_perimeter_ans: isNaN(ABC_perimeter_ans) ? "NaN" : Math.round(ABC_perimeter_ans * 100) / 100,
                      tech_ABC_semi: isNaN(ABC_semi) ? "NaN" : ABC_semi,
                      tech_ABC_area_ans: isNaN(ABC_area_ans) ? "NaN" : Math.round(ABC_area_ans * 100) / 100,
                      tech_DEF_f_ans: isNaN(DEF_f_ans) ? "NaN" : DEF_f_ans,
                      tech_DEF_s_ans: isNaN(DEF_s_ans) ? "NaN" : DEF_s_ans,
                      tech_DEF_t_ans: isNaN(DEF_t_ans) ? "NaN" : DEF_t_ans,
                      tech_DEF_perimeter_ans: isNaN(DEF_perimeter_ans) ? "NaN" : Math.round(DEF_perimeter_ans * 100) / 100,
                      tech_DEF_semi: isNaN(DEF_semi) ? "NaN" : DEF_semi,
                      tech_DEF_area_ans: isNaN(DEF_area_ans) ? "NaN" : Math.round(DEF_area_ans * 100) / 100,

                    };
                } else {
                    return { error: 'Please Check Your Input.' };
                }
            }

        } catch (error) {
            console.error('Error in similar triangles calculation:', error);
            return { error: 'Please Check Your Input.' };
        }
    }


    /**
    * getCalculationVolumeCalculator: Service Method
    * POST: /api/calculators-lol/volume-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
      */

  async getCalculationVolumeCalculator(body) {
     let volume_select = body.tech_volume_select;
      let rec_width = body.tech_rec_width;
      let rec_length = body.tech_rec_length;
      let rec_height = body.tech_rec_height;
      let rec_width_units = body.tech_rec_width_units;
      let rec_length_units = body.tech_rec_length_units;
      let rec_height_units = body.tech_rec_height_units;

      let cub_side = body.tech_cub_side;
      let cub_side_units = body.tech_cub_side_units;

      let cyl_height = body.tech_cyl_height;
      let cyl_height_units = body.tech_cyl_height_units;
      let cyl_diameter = body.tech_cyl_diameter;
      let cyl_diameter_units = body.tech_cyl_diameter_units;

      let con_height = body.tech_con_height;
      let con_height_units = body.tech_con_height_units;
      let con_diameter = body.tech_con_diameter;
      let con_diameter_units = body.tech_con_diameter_units;

      let sph_diameter = body.tech_sph_diameter;
      let sph_diameter_units = body.tech_sph_diameter_units;

      let tri_base = body.tech_tri_base;
      let tri_h = body.tech_tri_h;
      let tri_h_units = body.tech_tri_h_units;
      let tri_base_units = body.tech_tri_base_units;
      let tri_length = body.tech_tri_length;
      let tri_length_units = body.tech_tri_length_units;
      let tri_height = body.tech_tri_height;
      let tri_height_units = body.tech_tri_height_units;

      let pyr_height = body.tech_pyr_height;
      let pyr_height_units = body.tech_pyr_height_units;
      let pyr_side = body.tech_pyr_side;
      let pyr_side_units = body.tech_pyr_side_units;

      let cap_radius = body.tech_cap_radius;
      let cap_radius_units = body.tech_cap_radius_units;
      let cap_height = body.tech_cap_height;
      let cap_height_units = body.tech_cap_height_units;

      let hem_radius = body.tech_hem_radius;
      let hem_radius_units = body.tech_hem_radius_units;

      let hol_height = body.tech_hol_height;
      let hol_height_units = body.tech_hol_height_units;
      let hol_outer_dia = body.tech_hol_outer_dia;
      let hol_outer_dia_units = body.tech_hol_outer_dia_units;
      let hol_inner_dia = body.tech_hol_inner_dia;
      let hol_inner_dia_units = body.tech_hol_inner_dia_units;

      let coni_height = body.tech_coni_height;
      let coni_height_units = body.tech_coni_height_units;
      let coni_bottom_r = body.tech_coni_bottom_r;
      let coni_bottom_r_units = body.tech_coni_bottom_r_units;
      let coni_top_r = body.tech_coni_top_r;
      let coni_top_r_units = body.tech_coni_top_r_units;

      let tru_height = body.tech_tru_height;
      let tru_height_units = body.tech_tru_height_units;
      let tru_top_side = body.tech_tru_top_side;
      let tru_top_side_units = body.tech_tru_top_side_units;
      let tru_base_side = body.tech_tru_base_side;
      let tru_base_side_units = body.tech_tru_base_side_units;

      let ell_sem_a = body.tech_ell_sem_a;
      let ell_sem_a_units = body.tech_ell_sem_a_units;
      let ell_sem_b = body.tech_ell_sem_b;
      let ell_sem_b_units = body.tech_ell_sem_b_units;
      let ell_sem_c = body.tech_ell_sem_c;
      let ell_sem_c_units = body.tech_ell_sem_c_units;

      let square = body.tech_square;
      let square_units = body.tech_square_units;

      let col_height = body.tech_col_height;
      let col_height_units = body.tech_col_height_units;
      let col_radi = body.tech_col_radi;
      let col_radi_units = body.tech_col_radi_units;


      // Helper function to check if value is numeric
      const isNumeric = (value) => {
          return !isNaN(parseFloat(value)) && isFinite(value);
      };

      // Unit conversion function
      const convert_unit = (unit, value) => {
          if (!unit || !isNumeric(value)) return value;
          
          const conversions = {
              'cm': value * 1,
              'm': value / 100,
              'in': value / 2.54,
              'ft': value / 30.48,
              'yd': value / 91.44
          };
          return conversions[unit] || value;
      };

      try {
          const result = { };

          switch (volume_select) {
              case 'Rectangular':
                  if (isNumeric(rec_height) && isNumeric(rec_width) && isNumeric(rec_length)) {
                      const height = convert_unit(rec_height_units, parseFloat(rec_height));
                      const width = convert_unit(rec_width_units, parseFloat(rec_width));
                      const length = convert_unit(rec_length_units, parseFloat(rec_length));
                     result.tech_rectangular = isNaN(height * width * length) ? "NaN" : height * width * length;

                  } else {
                      return { error: 'Please! Check Your Input' };
                  }
                  break;

              case 'Cube':
                  if (isNumeric(cub_side)) {
                      const side = convert_unit(cub_side_units, parseFloat(cub_side));
                 result.tech_cube = isNaN(side * side * side) ? "NaN" : side * side * side;

                  } else {
                      return { error: 'Please! Check Your Input' };
                  }
                  break;

              case 'Cylinder':
                  if (isNumeric(cyl_height) && isNumeric(cyl_diameter)) {
                      const height = convert_unit(cyl_height_units, parseFloat(cyl_height));
                      const diameter = convert_unit(cyl_diameter_units, parseFloat(cyl_diameter));
                      const radius = diameter / 2;
                   result.tech_cylinder = isNaN(Math.PI * Math.pow(radius, 2) * height) ? "NaN" : Math.PI * Math.pow(radius, 2) * height;
                    result.tech_radius = isNaN(radius) ? "NaN" : radius;

                  } else {
                      return { error: 'Please! Check Your Input' };
                  }
                  break;

              case 'Cone':
                  if (isNumeric(con_height) && isNumeric(con_diameter)) {
                      const height = convert_unit(con_height_units, parseFloat(con_height));
                      const diameter = convert_unit(con_diameter_units, parseFloat(con_diameter));
                      const radius = diameter / 2;
                      result.tech_cone = isNaN((1/3) * Math.PI * Math.pow(radius, 2) * height) ? "NaN" : (1/3) * Math.PI * Math.pow(radius, 2) * height;
                      result.tech_radius = isNaN(radius) ? "NaN" : radius;

                  } else {
                      return { error: 'Please! Check Your Input' };
                  }
                  break;

              case 'Sphere':
                  if (isNumeric(sph_diameter)) {
                      const diameter = convert_unit(sph_diameter_units, parseFloat(sph_diameter));
                      const radius = diameter / 2;
                       result.tech_sphere = isNaN((4/3) * Math.PI * Math.pow(radius, 3)) ? "NaN" : (4/3) * Math.PI * Math.pow(radius, 3);
                         result.tech_radius = isNaN(radius) ? "NaN" : radius;

                  } else {
                      return { error: 'Please! Check Your Input' };
                  }
                  break;

              case 'Triangular':
                  if (isNumeric(tri_height) && isNumeric(tri_base) && isNumeric(tri_length) && isNumeric(tri_h)) {
                      const tri_a = convert_unit(tri_base_units, parseFloat(tri_base));
                      const tri_b = convert_unit(tri_length_units, parseFloat(tri_length));
                      const tri_c = convert_unit(tri_height_units, parseFloat(tri_height));
                      const tri_d = convert_unit(tri_h_units, parseFloat(tri_h));

                      const baseArea = (tri_a + tri_b + tri_c) * (tri_b + tri_c - tri_a) *
                                    (tri_c + tri_a - tri_b) * (tri_a + tri_b - tri_c);
                      
                  result.tech_triangular = isNaN((1/4) * tri_d * Math.sqrt(baseArea)) ? "NaN" : (1/4) * tri_d * Math.sqrt(baseArea);
                  result.tech_baseArea = isNaN(baseArea) ? "NaN" : baseArea;

                  } else {
                      return { error: 'Please! Check Your Input' };
                  }
                  break;

              case 'Capsule':
                  if (isNumeric(cap_radius) && isNumeric(cap_height)) {
                      const radius = convert_unit(cap_radius_units, parseFloat(cap_radius));
                      const height = convert_unit(cap_height_units, parseFloat(cap_height));
                     result.tech_capsule = isNaN(Math.PI * Math.pow(radius, 2) * (radius * 4/3 + height)) ? "NaN" : Math.PI * Math.pow(radius, 2) * (radius * 4/3 + height);

                  } else {
                      return { error: 'Please! Check Your Input' };
                  }
                  break;

              case 'Hemisphere':
                  if (isNumeric(hem_radius)) {
                      const radius = convert_unit(hem_radius_units, parseFloat(hem_radius));
                     result.tech_hemisphere = isNaN((2/3) * Math.PI * Math.pow(radius, 3)) ? "NaN" : (2/3) * Math.PI * Math.pow(radius, 3);

                  } else {
                      return { error: 'Please! Check Your Input' };
                  }
                  break;

              case 'Hollow':
                  if (isNumeric(hol_height) && isNumeric(hol_outer_dia) && isNumeric(hol_inner_dia)) {
                      const height = convert_unit(hol_height_units, parseFloat(hol_height));
                      const outerDia = convert_unit(hol_outer_dia_units, parseFloat(hol_outer_dia));
                      const innerDia = convert_unit(hol_inner_dia_units, parseFloat(hol_inner_dia));
                      
                      if (outerDia <= innerDia) {
                          return { error: 'Outer diameter should be greater than inner diameter.' };
                      }
                      
                      const rad = Math.pow(outerDia, 2) - Math.pow(innerDia, 2);
                     result.tech_hollow = isNaN(Math.PI * height * rad / 4) ? "NaN" : Math.PI * height * rad / 4;

                  } else {
                      return { error: 'Please! Check Your Input' };
                  }
                  break;

              case 'Conical':
                  if (isNumeric(coni_height) && isNumeric(coni_bottom_r) && isNumeric(coni_top_r)) {
                      const height = convert_unit(coni_height_units, parseFloat(coni_height));
                      const bottomR = convert_unit(coni_bottom_r_units, parseFloat(coni_bottom_r));
                      const topR = convert_unit(coni_top_r_units, parseFloat(coni_top_r));
                      
                      const At = Math.PI * Math.pow(topR, 2);
                      const Ab = Math.PI * Math.pow(bottomR, 2);
                     result.tech_conical = isNaN((height / 3) * (At + Ab + Math.sqrt(At * Ab))) ? "NaN" : (height / 3) * (At + Ab + Math.sqrt(At * Ab));

                  } else {
                      return { error: 'Please! Check Your Input' };
                  }
                  break;

              case 'Truncated':
                  if (isNumeric(tru_height) && isNumeric(tru_top_side) && isNumeric(tru_base_side)) {
                      const height = convert_unit(tru_height_units, parseFloat(tru_height));
                      const topSide = convert_unit(tru_top_side_units, parseFloat(tru_top_side));
                      const baseSide = convert_unit(tru_base_side_units, parseFloat(tru_base_side));
                      
                      const A1 = topSide * topSide;
                      const A2 = baseSide * baseSide;
                    result.tech_truncated = isNaN((1/3) * height * (A1 + A2 + Math.sqrt(A1 * A2))) ? "NaN" : (1/3) * height * (A1 + A2 + Math.sqrt(A1 * A2));

                  } else {
                      return { error: 'Please! Check Your Input' };
                  }
                  break;

              case 'Ellipsoid':
                  if (isNumeric(ell_sem_a) && isNumeric(ell_sem_b) && isNumeric(ell_sem_c)) {
                      const semA = convert_unit(ell_sem_a_units, parseFloat(ell_sem_a));
                      const semB = convert_unit(ell_sem_b_units, parseFloat(ell_sem_b));
                      const semC = convert_unit(ell_sem_c_units, parseFloat(ell_sem_c));
                     result.tech_ellipsoid = isNaN((4/3) * Math.PI * semA * semB * semC) ? "NaN" : (4/3) * Math.PI * semA * semB * semC;

                  } else {
                      return { error: 'Please! Check Your Input' };
                  }
                  break;

              case 'Pyramid':
                  if (isNumeric(pyr_height) && isNumeric(pyr_side)) {
                      const height = convert_unit(pyr_height_units, parseFloat(pyr_height));
                      const side = convert_unit(pyr_side_units, parseFloat(pyr_side));
                      const baseArea = side * side;
                      result.tech_pyramid = isNaN((1/3) * baseArea * height) ? "NaN" : (1/3) * baseArea * height;
                      result.tech_baseArea = isNaN(baseArea) ? "NaN" : baseArea;

                  } else {
                      return { error: 'Please! Check Your Input' };
                  }
                  break;

              case 'Square':
                  if (isNumeric(square)) {
                      const side = convert_unit(square_units, parseFloat(square));
                     result.tech_square = isNaN(side * side * side) ? "NaN" : side * side * side;

                  } else {
                      return { error: 'Please! Check Your Input' };
                  }
                  break;

              case 'Column':
                  if (isNumeric(col_height) && isNumeric(col_radi)) {
                      const height = convert_unit(col_height_units, parseFloat(col_height));
                      const radius = convert_unit(col_radi_units, parseFloat(col_radi));
                     result.tech_column = isNaN(Math.PI * Math.pow(radius, 2) * height) ? "NaN" : Math.PI * Math.pow(radius, 2) * height;

                  } else {
                      return { error: 'Please! Check Your Input' };
                  }
                  break;

              default:
                  return { error: 'Please! Check Your Input' };
          }

          return result;

      } catch (error) {
          console.error('Error in volume calculation:', error);
          return { error: 'Please! Check Your Input' };
      }
  }


      /**
    * getCalculationParabolaCalculator: Service Method
    * POST: /api/calculators-lol/parabola-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
      */

    async getCalculationParabolaCalculator(body) {
      const param = {};
      const from = body.tech_from;

      // GCD helper function
      function gcd(a, b) {
        a = Math.abs(a);
        b = Math.abs(b);
        if (b == 0) return a;
        return gcd(b, a % b);
      }

      // Numeric check helper
      function isNumeric(value) {
        return !isNaN(parseFloat(value)) && isFinite(value);
      }

      // Common calculations function
      function performCalculations(a, b, c, from, axis = null) {
        // Calculate h (vertex x-coordinate)
        let h1 = (-1) * b;
        let h2 = 2 * a;
        let gcdVal = gcd(h1, h2);
        h1 = h1 / gcdVal;
        h2 = h2 / gcdVal;
        let hf = 'ni';
        if (h1 % h2 == 0) {
          hf = h1 / h2;
        }
        const hf_ = h1 / h2;

        // Calculate k (vertex y-coordinate)
        let k1 = Math.pow(b, 2);
        let k2 = 4 * a;
        gcdVal = gcd(k1, k2);
        k1 = k1 / gcdVal;
        k2 = k2 / gcdVal;
        k1 = (c * k2) - k1;
        let kf = 'ni';
        if (k1 % k2 == 0) {
          kf = k1 / k2;
        }
        const kf_ = k1 / k2;

        // Calculate focus
        let fu1 = Math.pow(b, 2) - 1;
        let fu2 = 4 * a;
        gcdVal = gcd(fu1, fu2);
        fu1 = fu1 / gcdVal;
        fu2 = fu2 / gcdVal;
        fu1 = (c * fu2) - fu1;
        let fuf = 'ni';
        if (fu1 % fu2 == 0) {
          fuf = fu1 / fu2;
        }

        // Calculate directrix
        let dir1 = Math.pow(b, 2) + 1;
        let dir2 = 4 * a;
        gcdVal = gcd(dir1, dir2);
        dir1 = dir1 / gcdVal;
        dir2 = dir2 / gcdVal;
        let dirf = 'ni';
        if (dir1 % dir2 == 0) {
          dirf = dir1 / dir2;
        }
        dir1 = (c * dir2) - dir1;

        // Calculate x-intercepts
        const x_inter = (-1) * (k1 / k2);
        if (x_inter >= 0) {
          const x_inter_sqrt = Math.sqrt(x_inter / a);
          const rith = (h1 / h2);
          const x_inter1 = Math.round((rith + x_inter_sqrt) * 100000000) / 100000000;
          const x_inter2 = Math.round((rith - x_inter_sqrt) * 100000000) / 100000000;
          param['tech_x_inter1'] = x_inter1;
          param['tech_x_inter2'] = x_inter2;
        }

        // Calculate y-intercept
        const y_inter = ((a * Math.pow(h1 / h2, 2)) * k2 + k1) / k2;

        // Set all parameters
        if (axis) param['tech_axis'] = axis;
        param['tech_a'] = a;
        param['tech_b'] = b;
        param['tech_c'] = c;
        param['tech_h1'] = h1;
        param['tech_hf'] = hf;
        param['tech_hf_'] = hf_;
        param['tech_kf'] = kf;
        param['tech_kf_'] = kf_;
        param['tech_h2'] = h2;
        param['tech_k1'] = k1;
        param['tech_k2'] = k2;
        param['tech_fu1'] = fu1;
        param['tech_fu2'] = fu2;
        param['tech_fuf'] = fuf;
        param['tech_y_inter'] = y_inter;
        param['tech_dir1'] = dir1;
        param['tech_dir2'] = dir2;
        param['tech_dirf'] = dirf;
        param['tech_from'] = from;
        param['RESULT'] = 1;

        return param;
      }

      try {
        // Form 1: Standard form (ax² + bx + c)
        if (from == '1') {
          const a = parseFloat(body.tech_a);
          const b = parseFloat(body.tech_b);
          const c = parseFloat(body.tech_c);

          if (!isNumeric(a) || !isNumeric(b) || !isNumeric(c)) {
            param['error'] = 'Please! Check Your Input.';
            return param;
          }

          if (a == 0) {
            param['error'] = 'a can never equal zero for a parabola!';
            return param;
          }

          return performCalculations(a, b, c, from);
        }
        
        // Form 2: Vertex form (a(x-h)² + k)
        else if (from == '2') {
          const a = parseFloat(body.tech_a);
          const h = parseFloat(body.tech_b);
          const k = parseFloat(body.tech_c);

          if (!isNumeric(a) || !isNumeric(h) || !isNumeric(k)) {
            param['error'] = 'Please! Check Your Input.';
            return param;
          }

          if (a == 0) {
            param['error'] = 'a can never equal zero for a parabola!';
            return param;
          }

          // Convert vertex form to standard form
          const b = -2 * a * h;
          const c = k + (Math.pow(b, 2) / (4 * a));

          return performCalculations(a, b, c, from);
        }
        
        // Form 3: Vertex + Point
        else if (from == '3') {
          const h = parseFloat(body.tech_h1);
          const k = parseFloat(body.tech_k1);
          const x11 = parseFloat(body.tech_x11);
          const y11 = parseFloat(body.tech_y11);
          const axis = body.tech_axis;

          // Sirf required fields check karo
          if (!isNumeric(h) || !isNumeric(k) || !isNumeric(x11) || !isNumeric(y11)) {
            param['error'] = 'Please! Check Your Input.';
            return param;
          }

          let equ;
          let tempH = h, tempK = k;

          if (axis == 'x') {
            equ = `(a(${x11}-(${h}))**2plus${k})-(${y11})`;
          } else {
            equ = `(a(${y11}-(${k}))**2plus${h})-(${x11})`;
            tempH = k;
            tempK = h;
          }

          try {
            const response = await axios.get('http://167.172.134.148/parabolaa', {
              params: { equ },
              timeout: 120000
            });

            // Response data ko safely handle karo
            let aValue;
            if (typeof response.data == 'string') {
              aValue = response.data.trim();
            } else if (typeof response.data == 'number') {
              aValue = response.data.toString();
            } else {
              // Agar object hai to stringify karo
              aValue = JSON.stringify(response.data);
            }

            const a = parseFloat(aValue);

            if (isNaN(a)) {
              param['error'] = "Could not calculate 'a' value from the given points";
              return param;
            }

            if (a == 0) {
              param['error'] = "You can't build a parabola with these points";
              return param;
            }

            const b = -2 * a * tempH;
            const c = tempK + (Math.pow(b, 2) / (4 * a));

            return performCalculations(a, b, c, from, axis);
          } catch (error) {
            console.error('Error in form 3 calculation:', error);
            console.error('Error response:', error.response?.data);
            param['error'] = 'Please! Check Your Input.';
            return param;
          }
        }
        
        // Form 7: Three points
        else if (from == '7') {
          const x1 = parseFloat(body.tech_x1);
          const y1 = parseFloat(body.tech_y1);
          const x2 = parseFloat(body.tech_x2);
          const y2 = parseFloat(body.tech_y2);
          const x3 = parseFloat(body.tech_x3);
          const y3 = parseFloat(body.tech_y3);
          const axis = body.tech_axis;

          if (!isNumeric(x1) || !isNumeric(y1) || 
              !isNumeric(x2) || !isNumeric(y2) || 
              !isNumeric(x3) || !isNumeric(y3)) {
            param['error'] = 'Please! Check Your Input.';
            return param;
          }

          let eq1, eq1c, eq2, eq2c, eq3, eq3c;

          if (axis == 'x') {
            eq1 = `${Math.pow(x1, 2)}aplus${x1}bplusc`;
            eq1c = y1;
            eq2 = `${Math.pow(x2, 2)}aplus${x2}bplusc`;
            eq2c = y2;
            eq3 = `${Math.pow(x3, 2)}aplus${x3}bplusc`;
            eq3c = y3;
          } else {
            eq1 = `${Math.pow(y1, 2)}aplus${y1}bplusc`;
            eq1c = x1;
            eq2 = `${Math.pow(y2, 2)}aplus${y2}bplusc`;
            eq2c = x2;
            eq3 = `${Math.pow(y3, 2)}aplus${y3}bplusc`;
            eq3c = x3;
          }

          try {
            const response = await axios.get('http://167.172.134.148/parabola', {
              params: { eq1, eq1c, eq2, eq2c, eq3, eq3c },
              timeout: 120000
            });

            let buffer = response.data;
            
            // Safely handle buffer data
            if (typeof buffer != 'string') {
              buffer = buffer.toString();
            }
            
            buffer = buffer.replace(/\(/g, '').replace(/\)/g, '');
            const bufferArray = buffer.split(',');

            if (bufferArray.length != 3) {
              param['error'] = "Parabola can't be built with these points.";
              return param;
            }

            // Evaluate each expression
            let a, b, c;
            try {
              a = new Function('return ' + bufferArray[0])();
              b = new Function('return ' + bufferArray[1])();
              c = new Function('return ' + bufferArray[2])();
            } catch (e) {
              a = parseFloat(bufferArray[0]);
              b = parseFloat(bufferArray[1]);
              c = parseFloat(bufferArray[2]);
            }

            if (isNaN(a) || a == 0) {
              param['error'] = "You can't build a parabola with these points";
              return param;
            }

            return performCalculations(a, b, c, from, axis);
          } catch (error) {
            console.error('Error in form 7 calculation:', error);
            param['error'] = 'Please! Check Your Input.';
            return param;
          }
        } else {
          param['error'] = 'Invalid form type';
          return param;
        }

      } catch (error) {
        console.error('General error in parabola calculator:', error);
        param['error'] = 'An error occurred during calculation.';
        return param;
      }
    }


      /**
    * getCalculationLiteralEquationsCalculator: Service Method
    * POST: /api/calculators-lol/literal-equations-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    //     async getCalculationLiteralEquationsCalculator(body) {
    //     const equ = body.equ;
    //     const find = body.find;

    //     // Helper function to solve literal equations
    //     const solveLiteralEquation = (equation, solveFor) => {
    //         const steps = [];
    //         const explanations = [];
    //         const finalSteps = [];
            
    //         // Remove spaces and convert to lowercase
    //         equation = equation.replace(/\s/g, '').toLowerCase();
    //         solveFor = solveFor.toLowerCase();
            
    //         // Split into left and right sides
    //         const sides = equation.split('=');
    //         if (sides.length !== 2) {
    //             throw new Error('Invalid equation format');
    //         }
            
    //         let left = sides[0];
    //         let right = sides[1];
            
    //         // Store original equations for display
    //         const left_equ = left;
    //         const right_equ = right;
            
    //         // Step 1: Move all terms containing the variable to one side
    //         const moveVariableTerms = (side, targetSide) => {
    //             const terms = side.split(/(?=[+-])/).filter(term => term !== '');
    //             let newSide = '';
    //             let movedTerms = [];
                
    //             terms.forEach(term => {
    //                 if (term.includes(solveFor)) {
    //                     // Move to target side with opposite sign
    //                     let movedTerm = term.startsWith('+') ? '-' + term.slice(1) : 
    //                                   term.startsWith('-') ? '+' + term.slice(1) : '-' + term;
    //                     movedTerms.push(movedTerm);
    //                 } else {
    //                     newSide += term;
    //                 }
    //             });
                
    //             // Remove leading + if present
    //             if (newSide.startsWith('+')) {
    //                 newSide = newSide.slice(1);
    //             }
                
    //             return { newSide, movedTerms };
    //         };
            
    //         // Move variable terms from right to left
    //         const rightResult = moveVariableTerms(right, 'left');
    //         right = rightResult.newSide;
    //         left += rightResult.movedTerms.join('');
            
    //         if (rightResult.movedTerms.length > 0) {
    //             const explanation = `Move all ${solveFor} terms to the left side.`;
    //             const step = `${left} = ${right}`;
    //             explanations.push(explanation);
    //             steps.push(step);
    //             finalSteps.push(step);
    //         }
            
    //         // Move variable terms from left to right (if any non-variable terms on left)
    //         const leftResult = moveVariableTerms(left, 'right');
    //         left = leftResult.newSide;
    //         right += leftResult.movedTerms.join('');
            
    //         if (leftResult.movedTerms.length > 0) {
    //             const explanation = `Move constant terms to the right side.`;
    //             const step = `${left} = ${right}`;
    //             explanations.push(explanation);
    //             steps.push(step);
    //             finalSteps.push(step);
    //         }
            
    //         // Step 2: Combine like terms
    //         const combineLikeTerms = (expression) => {
    //             const terms = expression.split(/(?=[+-])/).filter(term => term !== '');
    //             const variableTerms = [];
    //             const constantTerms = [];
                
    //             terms.forEach(term => {
    //                 if (term.includes(solveFor)) {
    //                     variableTerms.push(term);
    //                 } else {
    //                     constantTerms.push(term);
    //                 }
    //             });
                
    //             // Combine variable terms
    //             let combinedVariable = '0';
    //             if (variableTerms.length > 0) {
    //                 const coefficients = variableTerms.map(term => {
    //                     const coeffMatch = term.match(/(-?\d*\.?\d*)/)[0];
    //                     let coeff = coeffMatch === '-' ? -1 : 
    //                               coeffMatch === '' ? 1 : 
    //                               parseFloat(coeffMatch);
    //                     return coeff;
    //                 });
                    
    //                 const totalCoeff = coefficients.reduce((sum, coeff) => sum + coeff, 0);
    //                 combinedVariable = totalCoeff === 1 ? solveFor : 
    //                                 totalCoeff === -1 ? '-' + solveFor : 
    //                                 totalCoeff + solveFor;
    //             }
                
    //             // Combine constant terms
    //             const totalConstant = constantTerms.reduce((sum, term) => {
    //                 let value = term === '+' ? 1 : 
    //                           term === '-' ? -1 : 
    //                           parseFloat(term);
    //                 return sum + value;
    //             }, 0);
                
    //             let result = '';
    //             if (combinedVariable !== '0') {
    //                 result += combinedVariable;
    //             }
    //             if (totalConstant !== 0) {
    //                 if (result && totalConstant > 0) result += '+';
    //                 result += totalConstant;
    //             }
                
    //             return result || '0';
    //         };
            
    //         left = combineLikeTerms(left);
    //         right = combineLikeTerms(right);
            
    //         if (steps.length > 0) { // Only add if there were previous steps
    //             const explanation = 'Combine like terms on both sides.';
    //             const step = `${left} = ${right}`;
    //             explanations.push(explanation);
    //             steps.push(step);
    //             finalSteps.push(step);
    //         }
            
    //         // Step 3: Isolate the variable
    //         let finalAnswer = '';
            
    //         if (left.includes(solveFor)) {
    //             // Variable is on left side
    //             const coeffMatch = left.match(/(-?\d*\.?\d*)/)[0];
    //             const coefficient = coeffMatch === '-' ? -1 : 
    //                               coeffMatch === '' ? 1 : 
    //                               parseFloat(coeffMatch);
                
    //             if (coefficient !== 1) {
    //                 // Divide both sides by coefficient
    //                 const explanation = `Divide both sides by ${coefficient}.`;
    //                 let step = '';
                    
    //                 if (coefficient === -1) {
    //                     step = `-${left} = -${right}`;
    //                     left = left.slice(1); // Remove negative
    //                     right = `-(${right})`;
    //                 } else {
    //                     step = `\\dfrac{${left}}{${coefficient}} = \\dfrac{${right}}{${coefficient}}`;
    //                     left = solveFor;
    //                     right = `\\dfrac{${right}}{${coefficient}}`;
    //                 }
                    
    //                 explanations.push(explanation);
    //                 steps.push(step);
    //                 finalSteps.push(`${left} = ${right}`);
                    
    //                 finalAnswer = right;
    //             } else {
    //                 finalAnswer = right;
    //             }
    //         } else {
    //             // Variable is on right side
    //             const coeffMatch = right.match(/(-?\d*\.?\d*)/)[0];
    //             const coefficient = coeffMatch === '-' ? -1 : 
    //                               coeffMatch === '' ? 1 : 
    //                               parseFloat(coeffMatch);
                
    //             if (coefficient !== 1) {
    //                 const explanation = `Divide both sides by ${coefficient}.`;
    //                 let step = '';
                    
    //                 if (coefficient === -1) {
    //                     step = `-${left} = -${right}`;
    //                     left = `-${left}`;
    //                     right = right.slice(1);
    //                 } else {
    //                     step = `\\dfrac{${left}}{${coefficient}} = \\dfrac{${right}}{${coefficient}}`;
    //                     left = `\\dfrac{${left}}{${coefficient}}`;
    //                     right = solveFor;
    //                 }
                    
    //                 explanations.push(explanation);
    //                 steps.push(step);
    //                 finalSteps.push(`${left} = ${right}`);
                    
    //                 finalAnswer = left;
    //             } else {
    //                 finalAnswer = left;
    //             }
    //         }
            
    //         // Final simplification
    //         finalAnswer = finalAnswer.replace(/\+\-/g, '-')
    //                                 .replace(/\-\-/g, '+')
    //                                 .replace(/\\dfrac\{(\d+)\}\{(\d+)\}/g, (match, num, den) => {
    //                                     const numerator = parseInt(num);
    //                                     const denominator = parseInt(den);
    //                                     if (numerator % denominator === 0) {
    //                                         return (numerator / denominator).toString();
    //                                     }
    //                                     return match;
    //                                 });
            
    //         return {
    //             explain: explanations,
    //             steps: steps,
    //             final_steps: finalSteps,
    //             final: `${solveFor} = ${finalAnswer}`,
    //             jawab: finalAnswer,
    //             one: '=',
    //             left_equ: left_equ,
    //             right_equ: right_equ
    //         };
    //     };

    //     const result = {};

    //     // Input validation
    //     if (!equ || !find) {
    //         result.error = 'Please Check Your Input.';
    //         return result;
    //     }

    //     if (/<|>|&|php|print_r|print|echo|script|%|&/i.test(equ)) {
    //         result.error = 'Please Enter Valid Equation.';
    //         return result;
    //     }

    //     const findLower = find.toLowerCase();
    //     const equLower = equ.toLowerCase();

    //     if (!equLower.includes(findLower)) {
    //         result.error = 'Character you entered does not seem to be exist on your equation.';
    //         return result;
    //     }

    //     if (!equLower.includes('=')) {
    //         result.error = 'Please Enter Valid Equation.';
    //         return result;
    //     }

    //     try {
    //         const solution = solveLiteralEquation(equ, find);
            
    //         result.explain = solution.explain;
    //         result.jawab = solution.jawab;
    //         result.one = solution.one;
    //         result.steps = solution.steps;
    //         result.final_steps = solution.final_steps;
    //         result.left_equ = solution.left_equ;
    //         result.right_equ = solution.right_equ;
    //         result.final = solution.final;
    //         result.RESULT = 1;
            
    //     } catch (error) {
    //         console.error('Calculation Error:', error.message);
    //         result.error = 'Unable to solve the equation. Please check your input.';
    //     }

    //     return result;
    // }


       /**
    * getCalculationVelocityCalculator: Service Method
    * POST: /api/calculators-lol/velocity-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationVelocityCalculator(body) {
        const request = body;
        const result = {};
        
        const velo_value = request.tech_velo_value;
        const dem = request.tech_dem;
        const collection = request.tech_collection;
        const dis1_unit = request.tech_dis_unit;
        const time_unit = request.tech_time_unit;
        const val_unit = request.tech_val_unit;
        const val_units = request.tech_val_units;
        
        const iv_unit = request.tech_iv_unit;
        const acc_unit = request.tech_acc_unit;
        const atime_unit = request.tech_atime_unit;
        const fv_unit = request.tech_fv_unit;

        // Helper function for velocity conversion (single value)
        function velocityfun(velocity, units) {
            if (units == 'km/h') {
                return velocity / 3.6;
            } else if (units == 'ft/s') {
                return velocity / 3.28084;
            } else if (units == 'mph') {
                return velocity / 2.23694;
            } else if (units == 'kn') {
                return velocity / 1.94384;
            } else if (units == 'ft/m') {
                return velocity / 196.8504;
            } else if (units == 'cm/s') {
                return velocity / 100;
            } else if (units == 'm/min') {
                return velocity / 60;
            } else {
                return velocity;
            }
        }

        // Helper function for time conversion (single value)
        function convertTime(time, units) {
            if (units == 'min') {
                return time * 60;
            } else if (units == 'hrs') {
                return time * 3600;
            } else if (units == 'days') {
                return time * 86400;
            } else if (units == 'wks') {
                return time * 604800;
            } else if (units == 'mon') {
                return time * 2.628e+6;
            } else if (units == 'yrs') {
                return time * 3.154e+7;
            } else {
                return time;
            }
        }

        // Helper function for distance conversion
        function distancefun(a, b) {
            if (b == "cm") {
                return parseInt(a / 100);
            } else if (b == "km") {
                return parseInt(a * 1000);
            } else if (b == "in") {
                return parseInt(a * 0.0254);
            } else if (b == "ft") {
                return parseInt(a * 0.3048);
            } else if (b == "yd") {
                return parseInt(a * 0.9144);
            } else if (b == "mi") {
                return parseInt(a * 1609.34);
            } else {
                return parseInt(a);
            }
        }

        // Helper function for velocity array conversion
        function velocity(velocities, units) {
            const converted_velocities = [];
            velocities.forEach((value, index) => {
                const numValue = parseFloat(value);
                const unit = units[index] || '';
                if (unit == 'km/h') {
                    converted_velocities.push(numValue / 3.6);
                } else if (unit == 'ft/s') {
                    converted_velocities.push(numValue / 3.28084);
                } else if (unit == 'mph') {
                    converted_velocities.push(numValue / 2.23694);
                } else if (unit == 'kn') {
                    converted_velocities.push(numValue / 1.94384);
                } else if (unit == 'ft/m') {
                    converted_velocities.push(numValue / 196.8504);
                } else if (unit == 'cm/s') {
                    converted_velocities.push(numValue / 100);
                } else if (unit == 'm/min') {
                    converted_velocities.push(numValue / 60);
                } else {
                    converted_velocities.push(numValue);
                }
            });
            return converted_velocities;
        }

        // Helper function for time array conversion
        function convertTimeArray(times, units) {
            const converted_times = [];
            times.forEach((value, index) => {
                const numValue = parseFloat(value);
                const unit = units[index] || '';
                if (unit == 'min') {
                    converted_times.push(numValue * 60);
                } else if (unit == 'hrs') {
                    converted_times.push(numValue * 3600);
                } else if (unit == 'days') {
                    converted_times.push(numValue * 86400);
                } else if (unit == 'wks') {
                    converted_times.push(numValue * 604800);
                } else if (unit == 'mon') {
                    converted_times.push(numValue * 2.628e+6);
                } else if (unit == 'yrs') {
                    converted_times.push(numValue * 3.154e+7);
                } else {
                    converted_times.push(numValue);
                }
            });
            return converted_times;
        }

        if (velo_value == '1') {
            // Basic velocity, distance, time calculation
            const distance = parseFloat(request.tech_x);
            const time = parseFloat(request.tech_y);
            const velocity_val = parseFloat(request.tech_vel);

            const distances = distancefun(distance, dis1_unit);
            const velocitys = velocityfun(velocity_val, val_units);
            const times = convertTime(time, time_unit);

            let ans;
            if (dem === 'dc') {
                // Distance Calculation
                ans = Math.round(velocitys * times * 10000) / 10000;
                result.tech_ans_t = "Distance";
            } else if (dem == 'av') {
                // Velocity Calculation
                if (times == 0) {
                    ans = 0;
                } else {
                    ans = Math.round((distances / times) * 10000) / 10000;
                }
                result.tech_ans_t = "Velocity";
            } else {
                // Time Calculation
                if (velocitys == 0) {
                    ans = "Infinity";
                } else {
                    ans = Math.round((distances / velocitys) * 10000) / 10000;
                }
                result.tech_ans_t = "Time";
            }
            
            result.tech_ans = ans;
            return result;

        } else if (velo_value == '3') {
            // Average velocity calculation
            let vs = request.tech_z;
            const vs_unit = request.tech_val_unit;
            let avt = request.tech_aty;
            const avt_unit = request.tech_ytime_unit;

            vs = velocity(vs, vs_unit);
            avt = convertTimeArray(avt, avt_unit);

            if (Array.isArray(vs) && Array.isArray(avt)) {
                const total_time = avt.reduce((sum, val) => sum + parseFloat(val), 0);
                let weighted_sum = 0;

                for (let key = 0; key < vs.length; key++) {
                    const vel = parseInt(vs[key]);
                    const time_val = parseInt(avt[key]);
                    
                    if (!isNaN(vel) && !isNaN(time_val)) {
                        weighted_sum += vs[key] * avt[key];
                    } else {
                        result.error = 'Please! Check Your Input';
                        return result;
                    }
                }

                if (total_time > 0) {
                    const average_velocity = weighted_sum / total_time;
                    result.tech_ans = Math.round(average_velocity * 10000) / 10000;
                    result.tech_unit = "m/s";
                } else {
                    result.error = 'Total time must be greater than zero';
                    return result;
                }
                result.tech_ans_t = "Avrage Velocity";
            }

            return result;

        } else if (velo_value == '2') {
            // Acceleration-based calculations
            let ans, unit;

            if (collection == '1') {
                // Calculate initial velocity from acceleration, time, and final velocity
                let a = parseFloat(request.tech_acc);
                
                if (acc_unit == "ft/s²") a *= 0.3048;
                if (acc_unit == "in/s²") a *= 0.0254;
                if (acc_unit == "cm/s²") a *= 0.01;
                if (acc_unit == "mi/s²") a *= 1609.344;
                if (acc_unit == "km/s²") a *= 100;
                if (acc_unit == "g") a *= 0.10197162129779;

                let time = parseFloat(request.tech_y1);
                if (atime_unit == 'min') time *= 60;
                if (atime_unit == 'hrs') time *= 3600;
                if (atime_unit == 'days') time *= 86400;
                if (atime_unit == 'wks') time *= 604800;
                if (atime_unit == 'mos') time *= 2.628e+6;
                if (atime_unit == 'yrs') time *= 3.154e+7;

                let fv = parseFloat(request.tech_z1);
                if (fv_unit == 'm/s') fv = fv;
                if (fv_unit == 'km/h') fv /= 3.6;
                if (fv_unit == 'ft/s') fv /= 3.28084;
                if (fv_unit == 'mph') fv /= 2.23694;
                if (fv_unit == 'kn') fv /= 1.94384;
                if (fv_unit == 'ft/m') fv /= 196.8504;
                if (fv_unit == 'cm/s') fv /= 100;
                if (fv_unit == 'm/min') fv /= 60;

                result.tech_ans_t = "Velocity";
                ans = Math.round((fv - (a * time)) * 10000) / 10000;
                unit = "m/s";
            } else if (collection == '2') {
                // Calculate final velocity from initial velocity, acceleration, and time
                let time = parseFloat(request.tech_y1);
                if (atime_unit == 'min') time *= 60;
                if (atime_unit == 'hrs') time *= 3600;
                if (atime_unit == 'days') time *= 86400;
                if (atime_unit == 'wks') time *= 604800;
                if (atime_unit == 'mos') time *= 2.628e+6;
                if (atime_unit == 'yrs') time *= 3.154e+7;

                let iv = parseFloat(request.tech_x1);
                if (iv_unit == 'km/h') iv /= 3.6;
                if (iv_unit == 'ft/s') iv /= 3.28084;
                if (iv_unit == 'mph') iv /= 2.23694;
                if (iv_unit == 'kn') iv /= 1.94384;
                if (iv_unit == 'ft/m') iv /= 196.8504;
                if (iv_unit == 'cm/s') iv /= 100;
                if (iv_unit == 'm/min') iv /= 60;

                let a = parseFloat(request.tech_acc);
                if (acc_unit == "ft/s²") a *= 0.3048;
                if (acc_unit == "in/s²") a *= 0.0254;
                if (acc_unit == "cm/s²") a *= 0.01;
                if (acc_unit == "mi/s²") a *= 1609.344;
                if (acc_unit == "km/s²") a *= 100;

                result.tech_ans_t = "Velocity";
                ans = Math.round((iv + (a * time)) * 10000) / 10000;
                unit = "m/s";

            } else if (collection == '3') {
                // Calculate acceleration from initial velocity, final velocity, and time
                let time = parseFloat(request.tech_y1);
                if (atime_unit == 'min') time *= 60;
                if (atime_unit == 'hrs') time *= 3600;
                if (atime_unit == 'days') time *= 86400;
                if (atime_unit == 'wks') time *= 604800;
                if (atime_unit == 'mos') time *= 2.628e+6;
                if (atime_unit == 'yrs') time *= 3.154e+7;

                let iv = parseFloat(request.tech_x1);
                if (iv_unit == 'km/h') iv /= 3.6;
                if (iv_unit == 'ft/s') iv /= 3.28084;
                if (iv_unit == 'mph') iv /= 2.23694;
                if (iv_unit == 'kn') iv /= 1.94384;
                if (iv_unit == 'ft/m') iv /= 196.8504;
                if (iv_unit == 'cm/s') iv /= 100;
                if (iv_unit == 'm/min') iv /= 60;

                let fv = parseFloat(request.tech_z1);
                if (fv_unit == 'km/h') fv /= 3.6;
                if (fv_unit == 'ft/s') fv /= 3.28084;
                if (fv_unit == 'mph') fv /= 2.23694;
                if (fv_unit == 'kn') fv /= 1.94384;
                if (fv_unit == 'ft/m') fv /= 196.8504;
                if (fv_unit == 'cm/s') fv /= 100;
                if (fv_unit == 'm/min') fv /= 60;

                result.tech_ans_t = "Acceleration";
                ans = Math.round(((fv - iv) / time) * 10000) / 10000;
                unit = 'm/s²';

            } else {
                // Calculate time from initial velocity, final velocity, and acceleration
                let a = parseFloat(request.tech_acc);
                if (acc_unit == "ft/s²") a *= 0.3048;
                if (acc_unit == "in/s²") a *= 0.0254;
                if (acc_unit == "cm/s²") a *= 0.01;
                if (acc_unit == "mi/s²") a *= 1609.344;
                if (acc_unit == "km/s²") a *= 100;
                if (acc_unit == "g") a *= 0.10197162129779;

                let iv = parseFloat(request.tech_x1);
                if (iv_unit == 'km/h') iv /= 3.6;
                if (iv_unit == 'ft/s') iv /= 3.28084;
                if (iv_unit == 'mph') iv /= 2.23694;
                if (iv_unit == 'kn') iv /= 1.94384;
                if (iv_unit == 'ft/m') iv /= 196.8504;
                if (iv_unit == 'cm/s') iv /= 100;
                if (iv_unit == 'm/min') iv /= 60;

                let fv = parseFloat(request.tech_z1);
                if (fv_unit == 'km/h') fv /= 3.6;
                if (fv_unit == 'ft/s') fv /= 3.28084;
                if (fv_unit == 'mph') fv /= 2.23694;
                if (fv_unit == 'kn') fv /= 1.94384;
                if (fv_unit == 'ft/m') fv /= 196.8504;
                if (fv_unit == 'cm/s') fv /= 100;
                if (fv_unit == 'm/min') fv /= 60;

                result.tech_ans_t = "Time";
                ans = Math.round(((fv - iv) / a) * 10000) / 10000;
                unit = "s";
            }

            result.tech_ans = ans;
            return result;
        }

        return result;
    }

       /**
    * getCalculationDisplacementCalculator: Service Method
    * POST: /api/calculators-lol/displacement-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationDisplacementCalculator(body) {
        const request = body;
        const param = {};
        
        const dispKnown = request.tech_known;
        let check = false;
        
        if (dispKnown) {
            if (dispKnown === "1") {
                // Formula: displacement = average velocity × time
                const sldsp = request.tech_sldsp;
                let avg = parseFloat(request.tech_av);
                const slav = request.tech_slav;
                let tme = parseFloat(request.tech_tm);
                const sltm = request.tech_sltm;
                check = true;

                param.tech_avg = `${request.tech_av} ${slav}`;

                // Convert average velocity to m/s
                if (slav === "ft/s") {
                    avg = avg * 0.3048;
                }
                if (slav === "km/h") {
                    avg = avg * 0.277778;
                }
                if (slav === "km/s") {
                    avg = avg * 1000;
                }
                if (slav === "mi/s") {
                    avg = avg * 1609.34;
                }
                if (slav === "mph") {
                    avg = avg / 2.237;
                }

                param.tech_tme = `${request.tech_tm} ${sltm}`;

                // Convert time to seconds
                if (sltm === "min") {
                    tme = tme * 60;
                }
                if (sltm === "h") {
                    tme = tme * 60 * 60;
                }

                // Calculate displacement in meters
                let dsp = avg * tme;

                // Convert to desired unit
                if (sldsp === "cm") {
                    dsp = dsp * 100;
                }
                if (sldsp === "in") {
                    dsp = dsp * 39.37;
                }
                if (sldsp === "ft") {
                    dsp = dsp * 3.281;
                }
                if (sldsp === "km") {
                    dsp = dsp / 1000;
                }
                if (sldsp === "mi") {
                    dsp = dsp / 1609.35;
                }

                param.tech_dsp = `${Math.round(dsp * 10000) / 10000} ${sldsp}`;
                
            } else if (dispKnown === "2") {
                // Formula: displacement = (initial velocity × time) + (0.5 × acceleration × time²)
                const sldsp = request.tech_sldsp;
                let tme = parseFloat(request.tech_tm);
                const sltm = request.tech_sltm;
                let iv = parseFloat(request.tech_iv);
                const sliv = request.tech_sliv;
                let acce = parseFloat(request.tech_acc);
                const slacc = request.tech_slacc;

                check = true;

                param.tech_ivs = `${request.tech_iv} ${sliv}`;
                
                // Convert initial velocity to m/s
                if (sliv === "ft/s") {
                    iv = iv * 0.3048;
                }
                if (sliv === "km/h") {
                    iv = iv * 0.277778;
                }
                if (sliv === "km/s") {
                    iv = iv * 1000;
                }
                if (sliv === "mi/s") {
                    iv = iv * 1609.34;
                }
                if (sliv === "mph") {
                    iv = iv / 2.237;
                }

                param.tech_tme = `${request.tech_tm} ${sltm}`;

                // Convert time to seconds
                if (sltm === "min") {
                    tme = tme * 60;
                }
                if (sltm === "h") {
                    tme = tme * 60 * 60;
                }

                param.tech_acce = `${request.tech_acc} ${slacc}`;
                
                // Convert acceleration to m/s²
                if (slacc === "ft/s²") {
                    acce = acce * 0.3048;
                }

                // Calculate displacement in meters
                let dsp = (iv * tme) + (0.5 * (acce * Math.pow(tme, 2)));
                
                // Convert to desired unit
                if (sldsp === "cm") {
                    dsp = dsp * 100;
                }
                if (sldsp === "in") {
                    dsp = dsp * 39.37;
                }
                if (sldsp === "ft") {
                    dsp = dsp * 3.281;
                }
                if (sldsp === "km") {
                    dsp = dsp / 1000;
                }
                if (sldsp === "mi") {
                    dsp = dsp / 1609.35;
                }

                param.tech_dsp = `${Math.round(dsp * 10000) / 10000} ${sldsp}`;
                
            } else if (dispKnown === "3") {
                // Formula: displacement = 0.5 × (initial velocity + final velocity) × time
                const sldsp = request.tech_sldsp;
                let tme = parseFloat(request.tech_tm);
                const sltm = request.tech_sltm;
                let iv = parseFloat(request.tech_iv);
                const sliv = request.tech_sliv;
                let fv = parseFloat(request.tech_fv);
                const slfv = request.tech_slfv;
                check = true;

                param.tech_ivs = `${request.tech_iv} ${sliv}`;
                
                // Convert initial velocity to m/s
                if (sliv === "ft/s") {
                    iv = iv * 0.3048;
                }
                if (sliv === "km/h") {
                    iv = iv * 0.277778;
                }
                if (sliv === "km/s") {
                    iv = iv * 1000;
                }
                if (sliv === "mi/s") {
                    iv = iv * 1609.34;
                }
                if (sliv === "mph") {
                    iv = iv / 2.237;
                }

                param.tech_tme = `${request.tech_tm} ${sltm}`;
                
                // Convert time to seconds
                if (sltm === "min") {
                    tme = tme * 60;
                }
                if (sltm === "h") {
                    tme = tme * 60 * 60;
                }

                param.tech_fvs = `${request.tech_fv} ${slfv}`;
                
                // Convert final velocity to m/s
                if (slfv === "ft/s") {
                    fv = fv * 0.3048;
                }
                if (slfv === "km/h") {
                    fv = fv * 0.277778;
                }
                if (slfv === "km/s") {
                    fv = fv * 1000;
                }
                if (slfv === "mi/s") {
                    fv = fv * 1609.34;
                }
                if (slfv === "mph") {
                    fv = fv / 2.237;
                }

                // Calculate displacement in meters
                let dsp = 0.5 * (fv + iv) * tme;
                
                // Convert to desired unit
                if (sldsp === "cm") {
                    dsp = dsp * 100;
                }
                if (sldsp === "in") {
                    dsp = dsp * 39.37;
                }
                if (sldsp === "ft") {
                    dsp = dsp * 3.281;
                }
                if (sldsp === "km") {
                    dsp = dsp / 1000;
                }
                if (sldsp === "mi") {
                    dsp = dsp / 1609.35;
                }

                param.tech_dsp = `${Math.round(dsp * 10000) / 10000} ${sldsp}`;
                
            } else if (dispKnown === "4") {
                // Multiple velocity-time pairs
                check = true;

                const vlocInpAr = [];
                const vlocSlcAr = [];
                const timiInpAr = [];
                const timiSlcAr = [];
                const vloReslt = [];

                for (let i = 0; i < 10; i++) {
                    const vloInRaw = request[`tech_vloc_${i}`];
                    const vloSl = request[`tech_slvloc_${i}`];
                    const timInRaw = request[`tech_timi_${i}`];
                    const timSl = request[`tech_sltimi_${i}`];
                    
                    // Skip if values don't exist or are empty
                    if (!vloInRaw || !timInRaw || vloInRaw === '' || timInRaw === '') {
                        continue;
                    }
                    
                    let vloIn = parseFloat(vloInRaw);
                    
                    // Convert velocity to m/s
                    if (vloSl === "ft/s") {
                        vloIn = vloIn * 0.3048;
                    }
                    if (vloSl === "km/h") {
                        vloIn = vloIn * 0.277778;
                    }
                    if (vloSl === "km/s") {
                        vloIn = vloIn * 1000;
                    }
                    if (vloSl === "mi/s") {
                        vloIn = vloIn * 1609.34;
                    }
                    if (vloSl === "mph") {
                        vloIn = vloIn / 2.237;
                    }
                    vlocInpAr.push(vloIn);
                    vlocSlcAr.push(vloSl);

                    let timIn = parseFloat(timInRaw);
                    
                    // Convert time to seconds
                    if (timSl === "min") {
                        timIn = timIn * 60;
                    }
                    if (timSl === "h") {
                        timIn = timIn * 60 * 60;
                    }
                    timiInpAr.push(timIn);
                    timiSlcAr.push(timSl);

                    vloReslt.push(vloIn * timIn);
                }

                const sldsp = request.tech_sldsp;
                
                // Sum all displacements (in meters)
                const sumInMeters = vloReslt.reduce((a, b) => a + b, 0);
                let dsp = sumInMeters;
                
                // Convert to desired unit
                if (sldsp === "cm") {
                    dsp = dsp * 100;
                }
                if (sldsp === "in") {
                    dsp = dsp * 39.37;
                }
                if (sldsp === "ft") {
                    dsp = dsp * 3.281;
                }
                if (sldsp === "km") {
                    dsp = dsp / 1000;
                }
                if (sldsp === "mi") {
                    dsp = dsp / 1609.35;
                }

                param.tech_dsp = `${Math.round(dsp * 10000) / 10000} ${sldsp}`;
                param.tech_dspft = Math.round(sumInMeters * 3.281 * 10000) / 10000;
                param.tech_dspkm = Math.round(sumInMeters / 1000 * 10000) / 10000;
                param.tech_dspmi = Math.round(sumInMeters / 1609.35 * 10000) / 10000;
            }
        }

        if (check === true) {
            return param;
        } else {
            param.error = 'Please fill all fields.';
            return param;
        }
    }


     /**
    * getCalculationOhmsLawCalculator: Service Method
    * POST: /api/calculators-lol/ohms-law-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

        async getCalculationOhmsLawCalculator(body) {
        const param = {};
        const request = body;

        // Helper function to check if value is numeric and not empty
        const isNumeric = (value) => {
            return value !== null && value !== undefined && value !== '' && !isNaN(value);
        };

        // Voltage and Current given
        if (isNumeric(request.tech_voltage) && isNumeric(request.tech_current)) {
            if (!isNumeric(request.resistance) && !isNumeric(request.tech_power)) {
                let voltage = parseFloat(request.tech_voltage);
                let current = parseFloat(request.tech_current);
                
                // Convert to base units
                if (request.tech_unit_v == "KV") voltage = voltage * 1000;
                if (request.tech_unit_v == "mV") voltage = voltage * 0.001;
                if (request.tech_unit_i == 'mA') current = current / 1000;
                
                // Calculate
                let resistance = Math.round((voltage / current) * 100000) / 100000;
                let power = Math.round((voltage * current) * 100000) / 100000;
                
                // Convert back to display units
                if (request.tech_unit_r == 'kΩ') resistance = resistance * 0.001;
                if (request.tech_unit_p == 'kW') power = power / 1000;
                if (request.tech_unit_v == "KV") voltage = voltage / 1000;
                if (request.tech_unit_v == "mV") voltage = voltage / 0.001;
                if (request.tech_unit_i == 'mA') current = current * 1000;
                
                param.tech_voltage = `${voltage} ${request.tech_unit_v}`;
                param.tech_current = `${current} ${request.tech_unit_i}`;
                param.tech_resistance = `${resistance} ${request.tech_unit_r}`;
                param.tech_power = `${power} ${request.tech_unit_p}`;
                
                return param;
            } else {
                param.error = 'Please enter two values.';
                return param;
            }
        }
        
        // Voltage and Resistance given
        else if (isNumeric(request.tech_voltage) && isNumeric(request.tech_resistance)) {
            if (!isNumeric(request.tech_current) && !isNumeric(request.tech_power)) {
                let voltage = parseFloat(request.tech_voltage);
                let resistance = parseFloat(request.tech_resistance);
                
                if (request.tech_unit_r == "kΩ") resistance = resistance * 1000;
                if (request.tech_unit_v == "KV") voltage = voltage * 1000;
                if (request.tech_unit_v == "mV") voltage = voltage * 0.001;
                
                let current = Math.round((voltage / resistance) * 100000) / 100000;
                let power = Math.round((Math.pow(voltage, 2) / resistance) * 100000) / 100000;
                
                if (request.tech_unit_r == 'kΩ') resistance = resistance * 0.001;
                if (request.tech_unit_p == 'kW') power = power / 1000;
                if (request.tech_unit_v == "KV") voltage = voltage / 1000;
                if (request.tech_unit_v == "mV") voltage = voltage / 0.001;
                if (request.tech_unit_i == 'mA') current = current * 1000;
                
                param.tech_voltage = `${voltage} ${request.tech_unit_v}`;
                param.tech_current = `${current} ${request.tech_unit_i}`;
                param.tech_resistance = `${resistance} ${request.tech_unit_r}`;
                param.tech_power = `${power} ${request.tech_unit_p}`;
                
                return param;
            } else {
                param.error = 'Please enter two values.';
                return param;
            }
        }
        
        // Voltage and Power given
        else if (isNumeric(request.tech_voltage) && isNumeric(request.tech_power)) {
            if (!isNumeric(request.tech_current) && !isNumeric(request.tech_resistance)) {
                let voltage = parseFloat(request.tech_voltage);
                let power = parseFloat(request.tech_power);
                
                if (request.tech_unit_v == "KV") voltage = voltage * 1000;
                if (request.tech_unit_v == "mV") voltage = voltage * 0.001;
                if (request.tech_unit_p == 'kW') power = power * 1000;
                
                let current = Math.round((power / voltage) * 100000) / 100000;
                let resistance = Math.round((voltage / current) * 100000) / 100000;
                
                if (request.tech_unit_r == 'kΩ') resistance = resistance * 0.001;
                if (request.tech_unit_p == 'kW') power = power / 1000;
                if (request.tech_unit_v == "KV") voltage = voltage / 1000;
                if (request.tech_unit_v == "mV") voltage = voltage / 0.001;
                if (request.tech_unit_i == 'mA') current = current * 1000;
                
                param.tech_voltage = `${voltage} ${request.tech_unit_v}`;
                param.tech_current = `${current} ${request.tech_unit_i}`;
                param.tech_resistance = `${resistance} ${request.tech_unit_r}`;
                param.tech_power = `${power} ${request.tech_unit_p}`;
                
                return param;
            } else {
                param.error = 'Please enter two values.';
                return param;
            }
        }
        
        // Current and Resistance given
        else if (isNumeric(request.tech_current) && isNumeric(request.tech_resistance)) {
            if (!isNumeric(request.tech_voltage) && !isNumeric(request.tech_power)) {
                let resistance = parseFloat(request.tech_resistance);
                let current = parseFloat(request.tech_current);
                
                if (request.tech_unit_r == "kΩ") resistance = resistance * 1000;
                if (request.tech_unit_i == 'mA') current = current / 1000;
                
                let voltage = Math.round((resistance * current) * 100000) / 100000;
                let power = Math.round((Math.pow(current, 2) * resistance) * 100000) / 100000;
                
                if (request.tech_unit_r == 'kΩ') resistance = resistance * 0.001;
                if (request.tech_unit_p == 'kW') power = power / 1000;
                if (request.tech_unit_v == "KV") voltage = voltage / 1000;
                if (request.tech_unit_v == "mV") voltage = voltage / 0.001;
                if (request.tech_unit_i == 'mA') current = current * 1000;
                
                param.tech_voltage = `${voltage} ${request.tech_unit_v}`;
                param.tech_current = `${current} ${request.tech_unit_i}`;
                param.tech_resistance = `${resistance} ${request.tech_unit_r}`;
                param.tech_power = `${power} ${request.tech_unit_p}`;
                
                return param;
            } else {
                param.error = 'Please enter two values.';
                return param;
            }
        }
        
        // Current and Power given
        else if (isNumeric(request.tech_current) && isNumeric(request.tech_power)) {
            if (!isNumeric(request.tech_voltage) && !isNumeric(request.tech_resistance)) {
                let power = parseFloat(request.tech_power);
                let current = parseFloat(request.tech_current);
                
                if (request.tech_unit_i == 'mA') current = current / 1000;
                if (request.tech_unit_p == 'kW') power = power * 1000;
                
                let voltage = Math.round((power / current) * 100000) / 100000;
                let resistance = Math.round((voltage / current) * 100000) / 100000;
                
                if (request.tech_unit_r == 'kΩ') resistance = resistance * 0.001;
                if (request.tech_unit_p == 'kW') power = power / 1000;
                if (request.tech_unit_v == "KV") voltage = voltage / 1000;
                if (request.tech_unit_v == "mV") voltage = voltage / 0.001;
                if (request.tech_unit_i == 'mA') current = current * 1000;
                
                param.tech_voltage = `${voltage} ${request.tech_unit_v}`;
                param.tech_current = `${current} ${request.tech_unit_i}`;
                param.tech_resistance = `${resistance} ${request.tech_unit_r}`;
                param.tech_power = `${power} ${request.tech_unit_p}`;
                
                return param;
            } else {
                param.error = 'Please enter two values.';
                return param;
            }
        }
        
        // Power and Resistance given
        else if (isNumeric(request.tech_power) && isNumeric(request.tech_resistance)) {
            if (!isNumeric(request.voltage) && !isNumeric(request.tech_current)) {
                let resistance = parseFloat(request.tech_resistance);
                let power = parseFloat(request.tech_power);
                
                if (request.tech_unit_r == "kΩ") resistance = resistance * 1000;
                if (request.tech_unit_p == 'kW') power = power * 1000;
                
                let voltage = Math.round(Math.sqrt(resistance * power) * 100000) / 100000;
                let current = Math.round((voltage / resistance) * 100000) / 100000;
                
                if (request.tech_unit_r == 'kΩ') resistance = resistance * 0.001;
                if (request.tech_unit_p == 'kW') power = power / 1000;
                if (request.tech_unit_v == "KV") voltage = voltage / 1000;
                if (request.tech_unit_v == "mV") voltage = voltage / 0.001;
                if (request.tech_unit_i == 'mA') current = current * 1000;
                
                param.tech_voltage = `${voltage} ${request.tech_unit_v}`;
                param.tech_current = `${current} ${request.tech_unit_i}`;
                param.tech_resistance = `${resistance} ${request.tech_unit_r}`;
                param.tech_power = `${power} ${request.tech_unit_p}`;
                
                return param;
            } else {
                param.error = 'Please enter two values.';
                return param;
            }
        }
        
        // Invalid input
        else {
            param.error = 'Please enter two values.';
            return param;
        }
    }


       /**
    * getCalculationTorqueCalculator: Service Method
    * POST: /api/calculators-lol/torque-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async  getCalculationTorqueCalculator(body) {
        const param = {};
        
        // Helper function to convert angle units to radians
        function convertToRadians(angle, unit) {
            switch (unit) {
                case 'deg': return angle * (Math.PI / 180);
                case 'gon': return angle * 0.01570796;
                case 'tr': return angle * 6.28319;
                case 'arcmin': return angle * 0.000290888;
                case 'arcsec': return angle * 0.00000484814;
                case 'mrad': return angle * 0.001;
                case 'μrad': return angle * 0.000001;
                default: return angle;
            }
        }

        // Helper function to convert from radians to other angle units
        function convertFromRadians(angle, unit) {
            switch (unit) {
                case 'deg': return angle * (180 / Math.PI);
                case 'gon': return angle * 63.662;
                case 'tr': return angle * 0.159155;
                case 'arcmin': return angle * 3437.75;
                case 'arcsec': return angle * 206265;
                case 'mrad': return angle / 0.001;
                case 'μrad': return angle * 1000000;
                default: return angle;
            }
        }

        if (body.tech_to == 1) {
            // Mechanical Torque Calculation
            if (!isNaN(body.tech_distance) && !isNaN(body.tech_force) && !isNaN(body.tech_angle) && (!body.tech_torque || body.tech_torque == '')) {
                // Calculate torque from distance, force, angle
                let dis = parseFloat(body.tech_distance);
                switch (body.tech_dis_u) {
                    case 'mm': dis /= 1000; break;
                    case 'cm': dis /= 100; break;
                    case 'km': dis *= 1000; break;
                    case 'ft': dis *= 0.3048; break;
                    case 'yd': dis *= 0.9144; break;
                    case 'in': dis /= 39.37; break;
                }

                let force = parseFloat(body.tech_force);
                switch (body.tech_for_u) {
                    case 'kN': force *= 1000; break;
                    case 'MN': force *= 1000000; break;
                    case 'GN': force *= 1000000000; break;
                    case 'TN': force *= 1000000000000; break;
                }

                let angle = convertToRadians(parseFloat(body.tech_angle), body.tech_ang_u);
                let tor = dis * force * Math.sin(angle);

                switch (body.tech_tor_u) {
                    case 'kg-cm': tor = Math.round(tor * 10.19716 * 100000) / 100000; break;
                    case 'ft-lb': tor = Math.round(tor * 0.737562 * 100000) / 100000; break;
                    default: tor = Math.round(tor * 100000) / 100000;
                }

                param.tech_dis = (isNaN(body.tech_distance) ? NaN : body.tech_distance) + ' ' + (body.tech_dis_u ?? '');
                param.tech_force = (isNaN(body.tech_force) ? NaN : body.tech_force) + ' ' + (body.tech_for_u ?? '');
                param.tech_angle = (isNaN(body.tech_angle) ? NaN : body.tech_angle) + ' ' + (body.tech_ang_u ?? '');
                param.tech_tor = (isNaN(tor) ? NaN : tor) + ' ' + (body.tech_tor_u ?? '');

                return param;

            } else if (!isNaN(body.tech_torque) && !isNaN(body.tech_force) && !isNaN(body.tech_angle) && (!body.tech_distance || body.tech_distance == '')) {
                // Calculate distance from torque, force, angle
                let tor = parseFloat(body.tech_torque);
                switch (body.tech_tor_u) {
                    case 'kg-cm': tor /= 10.19716; break;
                    case 'ft-lb': tor /= 0.737562; break;
                }

                let force = parseFloat(body.tech_force);
                switch (body.tech_for_u) {
                    case 'kN': force *= 1000; break;
                    case 'MN': force *= 1000000; break;
                    case 'GN': force *= 1000000000; break;
                    case 'TN': force *= 1000000000000; break;
                }

                let angle = convertToRadians(parseFloat(body.tech_angle), body.tech_ang_u);
                let dis = tor / (force * Math.sin(angle));

                switch (body.tech_dis_u) {
                    case 'mm': dis = Math.round(dis * 1000 * 100000) / 100000; break;
                    case 'cm': dis = Math.round(dis * 100 * 100000) / 100000; break;
                    case 'km': dis = Math.round(dis / 1000 * 100000) / 100000; break;
                    case 'ft': dis = Math.round(dis / 0.3048 * 100000) / 100000; break;
                    case 'yd': dis = Math.round(dis / 0.9144 * 100000) / 100000; break;
                    case 'in': dis = Math.round(dis * 39.37 * 100000) / 100000; break;
                    default: dis = Math.round(dis * 100000) / 100000;
                }

              param.tech_tor = (isNaN(body.tech_torque) ? NaN : body.tech_torque) + ' ' + (body.tech_tor_u ?? '');
              param.tech_force = (isNaN(body.tech_force) ? NaN : body.tech_force) + ' ' + (body.tech_for_u ?? '');
              param.tech_angle = (isNaN(body.tech_angle) ? NaN : body.tech_angle) + ' ' + (body.tech_ang_u ?? '');
              param.tech_dis = (isNaN(dis) ? NaN : dis) + ' ' + (body.tech_dis_u ?? '');

                return param;

            } else if (!isNaN(body.tech_distance) && !isNaN(body.tech_torque) && !isNaN(body.tech_angle) && (!body.tech_force || body.tech_force == '')) {
                // Calculate force from distance, torque, angle
                let dis = parseFloat(body.tech_distance);
                switch (body.dis_u) {
                    case 'mm': dis /= 1000; break;
                    case 'cm': dis /= 100; break;
                    case 'km': dis *= 1000; break;
                    case 'ft': dis *= 0.3048; break;
                    case 'yd': dis *= 0.9144; break;
                    case 'in': dis /= 39.37; break;
                }

                let tor = parseFloat(body.tech_torque);
                switch (body.tech_tor_u) {
                    case 'kg-cm': tor /= 10.19716; break;
                    case 'ft-lb': tor /= 0.737562; break;
                }

                let angle = convertToRadians(parseFloat(body.tech_angle), body.tech_ang_u);
                let force = tor / (dis * Math.sin(angle));

                switch (body.tech_for_u) {
                    case 'kN': force = Math.round(force / 1000 * 100000) / 100000; break;
                    case 'MN': force = Math.round(force / 1000000 * 10000000) / 10000000; break;
                    case 'GN': force = Math.round(force / 1000000000 * 10000000000) / 10000000000; break;
                    case 'TN': force = Math.round(force / 1000000000000 * 100000000000000) / 100000000000000; break;
                    default: force = Math.round(force * 100000) / 100000;
                }

              param.tech_dis = (isNaN(body.tech_distance) ? "NaN" : body.tech_distance) + ' ' + (body.tech_dis_u ?? '');
              param.tech_force = (isNaN(force) ? "NaN" : force) + ' ' + (body.tech_for_u ?? '');
              param.tech_angle = (isNaN(body.tech_angle) ? "NaN" : body.tech_angle) + ' ' + (body.tech_ang_u ?? '');
              param.tech_tor = (isNaN(body.tech_torque) ? "NaN" : body.tech_torque) + ' ' + (body.tech_tor_u ?? '');

                return param;

            } else if (!isNaN(body.tech_distance) && !isNaN(body.tech_torque) && !isNaN(body.tech_force) && (!body.tech_angle || body.tech_angle == '')) {
                // Calculate angle from distance, torque, force
                let dis = parseFloat(body.tech_distance);
                switch (body.tech_dis_u) {
                    case 'mm': dis /= 1000; break;
                    case 'cm': dis /= 100; break;
                    case 'km': dis *= 1000; break;
                    case 'ft': dis *= 0.3048; break;
                    case 'yd': dis *= 0.9144; break;
                    case 'in': dis /= 39.37; break;
                }

                let tor = parseFloat(body.tech_torque);
                switch (body.tech_tor_u) {
                    case 'kg-cm': tor /= 10.19716; break;
                    case 'ft-lb': tor /= 0.737562; break;
                }

                let force = parseFloat(body.tech_force);
                switch (body.tech_for_u) {
                    case 'kN': force *= 1000; break;
                    case 'MN': force *= 1000000; break;
                    case 'GN': force *= 1000000000; break;
                    case 'TN': force *= 1000000000000; break;
                }

                let angle = Math.asin(tor / (dis * force));
                angle = convertFromRadians(angle, body.tech_ang_u);
                angle = Math.round(angle * 100000) / 100000;

             param.tech_dis = (isNaN(body.tech_distance) ? "NaN" : body.tech_distance) + ' ' + (body.tech_dis_u ?? '');
              param.tech_force = (isNaN(body.tech_force) ? "NaN" : body.tech_force) + ' ' + (body.tech_for_u ?? '');
              param.tech_angle = (isNaN(angle) ? "NaN" : angle) + ' ' + (body.tech_ang_u ?? '');
              param.tech_tor = (isNaN(body.tech_torque) ? "NaN" : body.tech_torque) + ' ' + (body.tech_tor_u ?? '');

                return param;

            } else {
                param.error = 'Please! enter any three values';
                return param;
            }
        } else if (body.tech_to == 2) {
            // Magnetic Torque Calculation
            const getCurrentMultiplier = (unit) => {
                switch (unit) {
                    case 'A': return { multiplier: 1, unit: 'A' };
                    case 'mA': return { multiplier: 0.001, unit: 'mA' };
                    case 'kA': return { multiplier: 1000, unit: 'kA' };
                    case 'μA': return { multiplier: 0.000001, unit: 'μA' };
                    case 'boit': return { multiplier: 10, unit: 'boi' };
                    default: return { multiplier: 1, unit: 'A' };
                }
            };

            const getAreaMultiplier = (unit) => {
                switch (unit) {
                    case 'm²': return { multiplier: 1, unit: 'm²' };
                    case 'km²': return { multiplier: 1000000, unit: 'km²' };
                    case 'Mile²': return { multiplier: 2589988.1103, unit: 'Mile²' };
                    case 'ac': return { multiplier: 4046.8564224, unit: 'ac' };
                    case 'yd²': return { multiplier: 0.83612735998838, unit: 'yd²' };
                    case 'ft²': return { multiplier: 0.0929030399987, unit: 'ft²' };
                    case 'in²': return { multiplier: 0.000645156, unit: 'in²' };
                    case 'cm²': return { multiplier: 0.0001, unit: 'cm²' };
                    case 'mm²': return { multiplier: 0.000001, unit: 'mm²' };
                    default: return { multiplier: 1, unit: 'm²' };
                }
            };

            const getMagneticMultiplier = (unit) => {
                switch (unit) {
                    case 'T': return { multiplier: 1, unit: 'T' };
                    case 'mT': return { multiplier: 0.001, unit: 'mT' };
                    case 'μT': return { multiplier: 0.000001, unit: 'μT' };
                    default: return { multiplier: 1, unit: 'T' };
                }
            };

            // Calculate torque from loop, angle, current, area, mag
            if (!isNaN(body.tech_loop) && !isNaN(body.tech_angle_c) && !isNaN(body.tech_current) && !isNaN(body.tech_area) && !isNaN(body.tech_mag) && (!body.tech_tor || body.tech_tor == '')) {
                const angle = convertToRadians(parseFloat(body.tech_angle_c), body.tech_angc_u);
                const currentInfo = getCurrentMultiplier(body.tech_cur_u);
                const areaInfo = getAreaMultiplier(body.tech_area_u);
                const magInfo = getMagneticMultiplier(body.tech_mag_u);

                const loop = parseFloat(body.tech_loop);
                const current = parseFloat(body.tech_current) * currentInfo.multiplier;
                const area = parseFloat(body.tech_area) * areaInfo.multiplier;
                const mag = parseFloat(body.tech_mag) * magInfo.multiplier;

                let tor = loop * current * mag * area * Math.sin(angle);
                // console.log(loop)
                switch (body.tech_torc_u) {
                    case 'kg-cm': tor = Math.round(tor * 10.19716 * 100000) / 100000; break;
                    case 'ft-lb': tor = Math.round(tor * 0.737562 * 100000) / 100000; break;
                    default: tor = Math.round(tor * 100000) / 100000;
                }

                param.tech_tor = (isNaN(tor) ? "NaN" : tor) + ' ' + (body.tech_torc_u ?? '');
                param.tech_loop = (isNaN(loop) ? "NaN" : loop);
                param.tech_angle = (isNaN(body.tech_angle_c) ? "NaN" : body.tech_angle_c) + ' ' + (body.tech_angc_u ?? '');
                param.tech_area = (isNaN(body.tech_area) ? "NaN" : body.tech_area) + ' ' + (areaInfo.unit ?? '');
                param.tech_mag = (isNaN(body.mag) ? "NaN" : body.mag) + ' ' + (magInfo.unit ?? '');
                param.tech_current = (isNaN(body.tech_current) ? "NaN" : body.tech_current) + ' ' + (currentInfo.unit ?? '');

                return param;

            } else if (!isNaN(body.tech_tor) && !isNaN(body.tech_angle_c) && !isNaN(body.tech_current) && !isNaN(body.tech_area) && !isNaN(body.tech_mag) && (!body.tech_loop || body.tech_loop == '')) {
                // Calculate loop from torque, angle, current, area, mag
                const angle = convertToRadians(parseFloat(body.tech_angle_c), body.tech_angc_u);
                let tor = parseFloat(body.tech_tor);
                switch (body.tech_torc_u) {
                    case 'kg-cm': tor /= 10.19716; break;
                    case 'ft-lb': tor /= 0.737562; break;
                }

                const currentInfo = getCurrentMultiplier(body.tech_cur_u);
                const areaInfo = getAreaMultiplier(body.tech_area_u);
                const magInfo = getMagneticMultiplier(body.tech_mag_u);

                const current = parseFloat(body.tech_current) * currentInfo.multiplier;
                const area = parseFloat(body.tech_area) * areaInfo.multiplier;
                const mag = parseFloat(body.tech_mag) * magInfo.multiplier;

                const loop = tor / (current * mag * area * Math.sin(angle));
                const roundedLoop = Math.round(loop * 1000000) / 1000000;

                param.tech_tor = (isNaN(body.tech_tor) ? "NaN" : body.tech_tor) + ' ' + (body.tech_torc_u ?? '');
                param.tech_loop = (isNaN(roundedLoop) ? "NaN" : roundedLoop);
                param.tech_angle = (isNaN(body.tech_angle_c) ? "NaN" : body.tech_angle_c) + ' ' + (body.tech_angc_u ?? '');
                param.tech_area = (isNaN(body.tech_area) ? "NaN" : body.tech_area) + ' ' + (areaInfo.unit ?? '');
                param.tech_mag = (isNaN(body.tech_mag) ? "NaN" : body.tech_mag) + ' ' + (magInfo.unit ?? '');
                param.tech_current = (isNaN(body.tech_current) ? "NaN" : body.tech_current) + ' ' + (currentInfo.unit ?? '');

                return param;

            } else if (!isNaN(body.tech_loop) && !isNaN(body.tech_angle_c) && !isNaN(body.tech_tor) && !isNaN(body.tech_area) && !isNaN(body.tech_mag) && (!body.tech_current || body.tech_current == '')) {
                // Calculate current from loop, angle, torque, area, mag
                const angle = convertToRadians(parseFloat(body.tech_angle_c), body.tech_angc_u);
                const loop = parseFloat(body.tech_loop);
                let tor = parseFloat(body.tech_tor);
                switch (body.tech_torc_u) {
                    case 'kg-cm': tor /= 10.19716; break;
                    case 'ft-lb': tor /= 0.737562; break;
                }

                const areaInfo = getAreaMultiplier(body.tech_area_u);
                const magInfo = getMagneticMultiplier(body.tech_mag_u);
                const currentInfo = getCurrentMultiplier(body.tech_cur_u);

                const area = parseFloat(body.tech_area) * areaInfo.multiplier;
                const mag = parseFloat(body.tech_mag) * magInfo.multiplier;

                let current = tor / (loop * mag * area * Math.sin(angle));
                current = current / currentInfo.multiplier;
                current = Math.round(current * 10000000) / 10000000;

                param.tech_tor = (isNaN(body.tech_tor) ? "NaN" : body.tech_tor) + ' ' + (body.tech_torc_u ?? '');
                param.tech_loop = (isNaN(loop) ? "NaN" : loop);
                param.tech_angle = (isNaN(body.tech_angle_c) ? "NaN" : body.tech_angle_c) + ' ' + (body.tech_angc_u ?? '');
                param.tech_area = (isNaN(body.tech_area) ? "NaN" : body.tech_area) + ' ' + (areaInfo.unit ?? '');
                param.tech_mag = (isNaN(body.tech_mag) ? "NaN" : body.tech_mag) + ' ' + (magInfo.unit ?? '');
                param.tech_current = (isNaN(current) ? "NaN" : current) + ' ' + (currentInfo.unit ?? '');

                return param;

            } else if (!isNaN(body.tech_loop) && !isNaN(body.tech_angle_c) && !isNaN(body.tech_current) && !isNaN(body.tech_tor) && !isNaN(body.tech_mag) && (!body.tech_area || body.tech_area == '')) {
                // Calculate area from loop, angle, current, torque, mag
                const angle = convertToRadians(parseFloat(body.tech_angle_c), body.tech_angc_u);
                const loop = parseFloat(body.tech_loop);
                const currentInfo = getCurrentMultiplier(body.tech_cur_u);
                let tor = parseFloat(body.tech_tor);
                switch (body.tech_torc_u) {
                    case 'kg-cm': tor /= 10.19716; break;
                    case 'ft-lb': tor /= 0.737562; break;
                }

                const magInfo = getMagneticMultiplier(body.tech_mag_u);
                const areaInfo = getAreaMultiplier(body.tech_area_u);

                const current = parseFloat(body.tech_current) * currentInfo.multiplier;
                const mag = parseFloat(body.tech_mag) * magInfo.multiplier;

                let area = tor / (loop * current * mag * Math.sin(angle));
                area = area / areaInfo.multiplier;
                area = Math.round(area * 10000000) / 10000000;

                param.tech_tor = (isNaN(body.tech_tor) ? "NaN" : body.tech_tor) + ' ' + (body.tech_torc_u ?? '');
                param.tech_loop = (isNaN(loop) ? "NaN" : loop);
                param.tech_angle = (isNaN(body.tech_angle_c) ? "NaN" : body.tech_angle_c) + ' ' + (body.tech_angc_u ?? '');
                param.tech_area = (isNaN(area) ? "NaN" : area) + ' ' + (areaInfo.unit ?? '');
                param.tech_mag = (isNaN(body.tech_mag) ? "NaN" : body.tech_mag) + ' ' + (magInfo.unit ?? '');
                param.tech_current = (isNaN(body.tech_current) ? "NaN" : body.tech_current) + ' ' + (currentInfo.unit ?? '');

                return param;

            } else if (!isNaN(body.tech_loop) && !isNaN(body.tech_angle_c) && !isNaN(body.tech_current) && !isNaN(body.tech_area) && !isNaN(body.tech_tor) && (!body.tech_mag || body.tech_mag == '')) {
                // Calculate mag from loop, angle, current, area, torque
                const angle = convertToRadians(parseFloat(body.tech_angle_c), body.tech_angc_u);
                const loop = parseFloat(body.tech_loop);
                let tor = parseFloat(body.tech_tor);
                switch (body.tech_torc_u) {
                    case 'kg-cm': tor /= 10.19716; break;
                    case 'ft-lb': tor /= 0.737562; break;
                }

                const currentInfo = getCurrentMultiplier(body.tech_cur_u);
                const areaInfo = getAreaMultiplier(body.tech_area_u);
                const magInfo = getMagneticMultiplier(body.tech_mag_u);
                const current = parseFloat(body.tech_current) * currentInfo.multiplier;
                const area = parseFloat(body.tech_area) * areaInfo.multiplier;

                let mag = tor / (loop * current * area * Math.sin(angle));
                mag = mag / magInfo.multiplier;
              param.tech_tor = (isNaN(body.tech_tor) ? "NaN" : body.tech_tor) + ' ' + (body.tech_torc_u ?? '');
                param.tech_loop = (isNaN(loop) ? "NaN" : loop);
                param.tech_angle = (isNaN(body.tech_angle_c) ? "NaN" : body.tech_angle_c) + ' ' + (body.tech_angc_u ?? '');
                param.tech_area = (isNaN(body.tech_area) ? "NaN" : body.tech_area) + ' ' + (areaInfo.unit ?? '');
                param.tech_mag = (isNaN(mag) ? "NaN" : mag) + ' ' + (magInfo.unit ?? '');
                param.tech_current = (isNaN(body.tech_current) ? "NaN" : body.tech_current) + ' ' + (currentInfo.unit ?? '');

                return param;

            } else if (!isNaN(body.tech_loop) && !isNaN(body.tech_tor) && !isNaN(body.tech_current) && !isNaN(body.tech_area) && !isNaN(body.tech_mag) && (!body.tech_angle_c || body.tech_angle_c == '')) {
                // Calculate angle from loop, torque, current, area, mag
                let tor = parseFloat(body.tech_tor);
                switch (body.tech_torc_u) {
                    case 'kg-cm': tor /= 10.19716; break;
                    case 'ft-lb': tor /= 0.737562; break;
                }

                const loop = parseFloat(body.tech_loop);
                const currentInfo = getCurrentMultiplier(body.tech_cur_u);
                const areaInfo = getAreaMultiplier(body.tech_area_u);
                const magInfo = getMagneticMultiplier(body.tech_mag_u);

                const current = parseFloat(body.tech_current) * currentInfo.multiplier;
                const area = parseFloat(body.tech_area) * areaInfo.multiplier;
                const mag = parseFloat(body.tech_mag) * magInfo.multiplier;

                let angle = Math.asin(tor / (loop * current * mag * area));
                angle = convertFromRadians(angle, body.tech_angc_u);
                angle = Math.round(angle * 100000) / 100000;

                param.tech_tor = (isNaN(body.tech_tor) ? "NaN" : body.tech_tor) + ' ' + (body.tech_torc_u ?? '');
                param.tech_loop = (isNaN(loop) ? "NaN" : loop);
                param.tech_angle = (isNaN(angle) ? "NaN" : angle) + ' ' + (body.tech_angc_u ?? '');
                param.tech_area = (isNaN(body.tech_area) ? "NaN" : body.tech_area) + ' ' + (areaInfo.unit ?? '');
                param.tech_mag = (isNaN(body.tech_mag) ? "NaN" : body.tech_mag) + ' ' + (magInfo.unit ?? '');
                param.tech_current = (isNaN(body.tech_current) ? "NaN" : body.tech_current) + ' ' + (currentInfo.unit ?? '');

                return param;

            } else {
                param.error = 'Please! enter any five values';
                return param;
            }
        } else if (body.tech_to == 3) {
            // Vector Cross Product Calculation
            if (!isNaN(body.tech_ax) && !isNaN(body.tech_ay) && !isNaN(body.tech_az) && !isNaN(body.tech_bx) && !isNaN(body.tech_by) && !isNaN(body.tech_bz)) {
                const ax = parseFloat(body.tech_ax);
                const ay = parseFloat(body.tech_ay);
                const az = parseFloat(body.tech_az);
                const bx = parseFloat(body.tech_bx);
                const by = parseFloat(body.tech_by);
                const bz = parseFloat(body.tech_bz);

                const ans_a1 = (ay * bz) - (by * az);
                const ans_a2 = ((ax * bz) - (bx * az)) * (-1);
                const ans_a3 = (ax * by) - (bx * ay);

                const ans = ans_a1 + 'i ' + (ans_a2 < 0 ? ans_a2 : '+' + ans_a2) + 'j ' + (ans_a3 < 0 ? ans_a3 : '+' + ans_a3) + 'k';
                
                param.tech_ans = ans;
                return param;
            } else {
                param.error = 'Please! enter Distance Vector & Force Vector';
                return param;
            }
        } else {
            param.error = 'Invalid calculation type';
            return param;
        }
    }


        /**
    * getCalculationHorsepowerCalculator: Service Method
    * POST: /api/calculators-lol/horsepower-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

   async getCalculationHorsepowerCalculator(body) {
    const param = {};
    
        if (body.tech_method == 1) {
            if (!isNaN(body.tech_weight) && !isNaN(body.tech_time)) {
                let weight = parseFloat(body.tech_weight);
                if (body.tech_unit_w == 'kg') {
                    weight = weight * 2.2046;
                }
                
                let time = parseFloat(body.tech_time);
                if (body.tech_unit_t == 'min') {
                    time = time * 60;
                } else if (body.tech_unit_t == 'h') {
                    time = time * 60 * 60;
                }
                
                const hp = weight / Math.pow((time / 5.825), 3);
                const value_exp = hp.toString().split(".");
                const hpm = parseFloat(value_exp[0] + '.' + (value_exp[1] ? value_exp[1].substring(0, 1) : '0'));
                const hpmet = Math.round(hpm * 1.01387 * 10) / 10;
                const hpkw = Math.round(hpm * 0.746 * 10) / 10;
                const hpw = Math.round(hpm * 746 * 10) / 10;
                
                 param.tech_hpm = isNaN(hpm) ? "NaN" : hpm;
                param.tech_hpmet = isNaN(hpmet) ? "NaN" : hpmet;
                param.tech_hpkw = isNaN(hpkw) ? "NaN" : hpkw;
                param.tech_hpw = isNaN(hpw) ? "NaN" : hpw;

                return param;
            } else {
                param.error = 'Please! fill all fields';
                return param;
            }
        } else if (body.tech_method == 2) {
            if (!isNaN(body.tech_weight) && !isNaN(body.tech_speed)) {
                let weight = parseFloat(body.tech_weight);
                if (body.tech_unit_w == 'kg') {
                    weight = weight * 2.2046;
                }
                
                let speed = parseFloat(body.tech_speed);
                if (body.tech_unit_s == 'km/h') {
                    speed = speed / 0.621371;
                } else if (body.tech_unit_s == 'km/s') {
                    speed = speed * 2236.94;
                } else if (body.tech_unit_s == 'm/s') {
                    speed = speed * 2.237;
                }
                
                const hp = weight * Math.pow((speed / 234), 3);
                const value_exp = hp.toString().split(".");
                const hpm = parseFloat(value_exp[0] + '.' + (value_exp[1] ? value_exp[1].substring(0, 1) : '0'));
                const hpmet = Math.round(hpm * 1.01387 * 10) / 10;
                const hpkw = Math.round(hpm * 0.746 * 10) / 10;
                const hpw = Math.round(hpm * 746 * 10) / 10;
                
                param.tech_hpm = isNaN(hpm) ? "NaN" : hpm;
                param.tech_hpmet = isNaN(hpmet) ? "NaN" : hpmet;
                param.tech_hpkw = isNaN(hpkw) ? "NaN" : hpkw;
                param.tech_hpw = isNaN(hpw) ? "NaN" : hpw;

                return param;
            } else {
                param.error = 'Please! fill all fields';
                return param;
            }
        } else if (body.tech_method == 4) {
            if (!isNaN(body.tech_force) && !isNaN(body.tech_distance) && !isNaN(body.tech_btime)) {
                let force = parseFloat(body.tech_force);
                let dis = parseFloat(body.tech_distance);
                const time = parseFloat(body.tech_btime);
                
                if (body.tech_dis_u == 'mm') {
                    dis = dis / 1000;
                } else if (body.tech_dis_u == 'cm') {
                    dis = dis / 100;
                } else if (body.tech_dis_u == 'km') {
                    dis = dis * 1000;
                } else if (body.tech_dis_u == 'ft') {
                    dis = dis * 0.3048;
                } else if (body.tech_dis_u == 'yd') {
                    dis = dis * 0.9144;
                }
                
                if (body.tech_for_u == 'kN') {
                    force = force * 1000;
                } else if (body.tech_for_u == 'MN') {
                    force = force * 1000000;
                } else if (body.tech_for_u == 'GN') {
                    force = force * 1000000000;
                } else if (body.tech_for_u == 'TN') {
                    force = force * 1000000000000;
                }
                
                const hp = force * (dis / time);
                param.tech_hp = isNaN(hp) ? "NaN" : hp;
                return param;
            } else {
                param.error = 'Please! fill all fields';
                return param;
            }
        } else if (body.tech_method == 3) {
            if (body.tech_to == 1) {
                if (!isNaN(body.tech_rpm) && !isNaN(body.tech_tor)) {
                    const rpm = parseFloat(body.tech_rpm);
                    const tor = parseFloat(body.tech_tor);
                    const hp = (rpm * tor) / 5252;
                    const value_exp = hp.toString().split(".");

                    let hpm;
                    if (value_exp[1]) {
                        hpm = parseFloat(value_exp[0] + '.' + value_exp[1].substring(0, 2));
                    } else {
                        hpm = parseFloat(value_exp[0]);
                    }

                    const hpmet = Math.round(hpm * 1.01387 * 10) / 10;
                    const hpkw = Math.round(hpm * 0.746 * 10) / 10;
                    const hpw = Math.round(hpm * 746 * 10) / 10;
                    
                    param.tech_hpm = isNaN(hpm) ? "NaN" : hpm;
                    param.tech_hpmet = isNaN(hpmet) ? "NaN" : hpmet;
                    param.tech_hpkw = isNaN(hpkw) ? "NaN" : hpkw;
                    param.tech_hpw = isNaN(hpw) ? "NaN" : hpw;

                    return param;
                } else {
                    param.error = 'Please! fill all fields';
                    return param;
                }
            } else if (body.tech_to == 2) {
                if (!isNaN(body.rpm) && !isNaN(body.tech_hors)) {
                    const rpm = parseFloat(body.tech_rpm);
                    const hp = parseFloat(body.tech_hors);
                    const tor = Math.round((hp * 5252) / rpm * 10000) / 10000;
                   param.tech_tor = isNaN(tor) ? "NaN" : tor.toFixed(4);
                    return param;
                } else {
                    param.error = 'Please! fill all fields';
                    return param;
                }
            }
        }
    }

         /**
    * getCalculationKinematicsCalculator: Service Method
    * POST: /api/calculators-lol/kinematics-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

   async getCalculationKinematicsCalculator(body) {
        const param = {};
        let check = false;
        let iv, fv, time, a, dis;
        let ivDisplay, fvDisplay, timeDisplay, aDisplay, disDisplay;

        // Helper functions
        const isNumeric = (value) => !isNaN(parseFloat(value)) && isFinite(value);
        const isEmpty = (value) => value == undefined || value == null || value == '';
        const round = (value, decimals) => Number(Math.round(value + 'e' + decimals) + 'e-' + decimals);

        // Convert velocity to m/s
        const convertVelocityToMs = (value, unit) => {
            let result = parseFloat(value);
            switch(unit) {
                case 'ft/s': return result / 3.281;
                case 'km/h': return result / 3.6;
                case 'km/s': return result * 1000;
                case 'mi/s': return result * 1609.35;
                case 'mph': return result / 2.237;
                default: return result;
            }
        };

        // Convert acceleration to m/s²
        const convertAccelerationToMs2 = (value, unit) => {
            let result = parseFloat(value);
            if (unit == 'ft/s²') return result / 3.2808399;
            return result;
        };

        // Convert time to seconds
        const convertTimeToSeconds = (value, unit) => {
            let result = parseFloat(value);
            switch(unit) {
                case 'min': return result * 60;
                case 'h': return result * 60 * 60;
                default: return result;
            }
        };

        // Convert distance to meters
        const convertDistanceToMeters = (value, unit) => {
            let result = parseFloat(value);
            switch(unit) {
                case 'cm': return result / 100;
                case 'in': return result / 39.37;
                case 'ft': return result / 3.281;
                case 'km': return result / 1000;
                case 'mi': return result * 1609.35;
                case 'yd': return result / 1.094;
                default: return result;
            }
        };

        // Format velocity for display
        const formatVelocity = (value, unit) => {
            let result = parseFloat(value);
            switch(unit) {
                case 'ft/s': return round(result * 3.281, 4);
                case 'km/h': return round(result * 3.6, 4);
                case 'km/s': return round(result / 1000, 4);
                case 'mi/s': return round(result / 1609.35, 4);
                case 'mph': return round(result * 2.237, 4);
                default: return round(result, 4);
            }
        };

        // Format acceleration for display
        const formatAcceleration = (value, unit) => {
            let result = parseFloat(value);
            if (unit == 'ft/s²') return round(result * 3.2808399, 4);
            return round(result, 4);
        };

        // Format distance for display
        const formatDistance = (value, unit) => {
            let result = parseFloat(value);
            switch(unit) {
                case 'cm': return round(result * 100, 4);
                case 'in': return round(result * 39.37, 4);
                case 'ft': return round(result * 3.281, 4);
                case 'km': return round(result * 1000, 4);
                case 'mi': return round(result / 1609.35, 4);
                case 'yd': return round(result * 1.094, 4);
                default: return round(result, 4);
            }
        };

        // Format time for display
        const formatTime = (value, unit) => {
            let result = parseFloat(value);
            switch(unit) {
                case 'min': return round(result / 60, 4);
                case 'h': return round(result / 60 / 60, 4);
                default: return round(result, 4);
            }
        };

        // Case 1: iv, fv, ct provided
        if (isNumeric(body.tech_iv) && isNumeric(body.tech_fv) && isNumeric(body.tech_ct)) {
            if (!isEmpty(body.tech_cac) || body.tech_cac == '0' || !isEmpty(body.tech_cdis) || body.tech_cdis == '0') {
                param.error = 'Please enter any three values';
                return param;
            } else {
                check = true;
                iv = convertVelocityToMs(body.tech_iv, body.tech_ivU);
                fv = convertVelocityToMs(body.tech_fv, body.tech_fvU);
                time = convertTimeToSeconds(body.tech_ct, body.tech_ctU);
                
                a = (fv - iv) / time;
                dis = (iv * time) + (0.5 * a * Math.pow(time, 2));
                
                ivDisplay = body.tech_iv + ' ' + body.tech_ivU;
                fvDisplay = body.tech_fv + ' ' + body.tech_fvU;
                timeDisplay = body.tech_ct + ' ' + body.tech_ctU;
                aDisplay = formatAcceleration(a, body.tech_cacU) + ' ' + body.tech_cacU;
                disDisplay = formatDistance(dis, body.tech_cdisU) + ' ' + body.tech_cdisU;
            }
        } 
        // Case 2: iv, fv, cac provided
        else if (isNumeric(body.tech_iv) && isNumeric(body.tech_fv) && isNumeric(body.tech_cac)) {
            if (!isEmpty(body.tech_ct) || body.tech_ct == '0' || !isEmpty(body.tech_cdis) || body.tech_cdis == '0') {
                param.error = 'Please fill all fields.';
                return param;
            } else {
                check = true;
                iv = convertVelocityToMs(body.tech_iv, body.tech_ivU);
                fv = convertVelocityToMs(body.tech_fv, body.tech_fvU);
                a = convertAccelerationToMs2(body.tech_cac, body.tech_cacU);
                
                time = (fv - iv) / a;
                dis = (iv * time) + (0.5 * a * Math.pow(time, 2));
                
                ivDisplay = body.tech_iv + ' ' + body.tech_ivU;
                fvDisplay = body.tech_fv + ' ' + body.tech_fvU;
                aDisplay = body.tech_cac + ' ' + body.tech_cacU;
                timeDisplay = formatTime(time, body.tech_ctU) + ' ' + body.tech_ctU;
                disDisplay = formatDistance(dis, body.tech_cdisU) + ' ' + body.tech_cdisU;
            }
        }
        // Case 3: ct, fv, cac provided
        else if (isNumeric(body.tech_ct) && isNumeric(body.tech_fv) && isNumeric(body.tech_cac)) {
            if (!isEmpty(body.tech_iv) || body.tech_iv == '0' || !isEmpty(body.tech_cdis) || body.tech_cdis == '0') {
                param.error = 'Please fill all fields.';
                return param;
            } else {
                check = true;
                time = convertTimeToSeconds(body.tech_ct, body.tech_ctU);
                fv = convertVelocityToMs(body.tech_fv, body.tech_fvU);
                a = convertAccelerationToMs2(body.tech_cac, body.tech_cacU);
                
                iv = fv - (a * time);
                dis = (iv * time) + (0.5 * a * Math.pow(time, 2));
                
                timeDisplay = body.tech_ct + ' ' + body.tech_ctU;
                fvDisplay = body.tech_fv + ' ' + body.tech_fvU;
                aDisplay = body.tech_cac + ' ' + body.tech_cacU;
                ivDisplay = formatVelocity(iv, body.tech_ivU) + ' ' + body.tech_ivU;
                disDisplay = formatDistance(dis, body.tech_cdisU) + ' ' + body.tech_cdisU;
            }
        }
        // Case 4: ct, iv, cac provided
        else if (isNumeric(body.tech_ct) && isNumeric(body.tech_iv) && isNumeric(body.tech_cac)) {
            if (!isEmpty(body.tech_fv) || body.tech_fv == '0' || !isEmpty(body.tech_cdis) || body.tech_cdis == '0') {
                param.error = 'Please fill all fields.';
                return param;
            } else {
                check = true;
                time = convertTimeToSeconds(body.tech_ct, body.tech_ctU);
                iv = convertVelocityToMs(body.tech_iv, body.tech_ivU);
                a = convertAccelerationToMs2(body.tech_cac, body.tech_cacU);
                
                fv = (a * time) + iv;
                dis = (iv * time) + (0.5 * a * Math.pow(time, 2));
                
                ivDisplay = body.tech_iv + ' ' + body.tech_ivU;
                timeDisplay = body.tech_ct + ' ' + body.tech_ctU;
                aDisplay = body.tech_cac + ' ' + body.tech_cacU;
                fvDisplay = formatVelocity(fv, body.tech_fvU) + ' ' + body.tech_fvU;
                disDisplay = formatDistance(dis, body.tech_cdisU) + ' ' + body.tech_cdisU;
            }
        }
        // Case 5: cdis, iv, ct provided
        else if (isNumeric(body.tech_cdis) && isNumeric(body.tech_iv) && isNumeric(body.tech_ct)) {
            if (!isEmpty(body.tech_fv) || body.tech_fv == '0' || !isEmpty(body.tech_cac) || body.tech_cac == '0') {
                param.error = 'Please fill all fields.';
                return param;
            } else {
                check = true;
                dis = convertDistanceToMeters(body.tech_cdis, body.tech_cdisU);
                time = convertTimeToSeconds(body.tech_ct, body.tech_ctU);
                iv = convertVelocityToMs(body.tech_iv, body.tech_ivU);
                
                a = 2 * (dis - (iv * time)) / Math.pow(time, 2);
                fv = (a * time) + iv;
                
                ivDisplay = body.tech_iv + ' ' + body.tech_ivU;
                timeDisplay = body.tech_ct + ' ' + body.tech_ctU;
                disDisplay = body.tech_cdis + ' ' + body.tech_cdisU;
                aDisplay = formatAcceleration(a, body.tech_cacU) + ' ' + body.tech_cacU;
                fvDisplay = formatVelocity(fv, body.tech_fvU) + ' ' + body.tech_fvU;
            }
        }
        // Case 6: cdis, fv, ct provided
        else if (isNumeric(body.tech_cdis) && isNumeric(body.tech_fv) && isNumeric(body.tech_ct)) {
            if (!isEmpty(body.tech_iv) || body.tech_iv == '0' || !isEmpty(body.tech_cac) || body.tech_cac == '0') {
                param.error = 'Please fill all fields.';
                return param;
            } else {
                check = true;
                dis = convertDistanceToMeters(body.tech_cdis, body.tech_cdisU);
                time = convertTimeToSeconds(body.tech_ct, body.tech_ctU);
                fv = convertVelocityToMs(body.tech_fv, body.tech_fvU);
                
                iv = ((2 * dis) / time) - fv;
                a = 2 * (dis - (iv * time)) / Math.pow(time, 2);
                
                fvDisplay = body.tech_fv + ' ' + body.tech_fvU;
                timeDisplay = body.tech_ct + ' ' + body.tech_ctU;
                disDisplay = body.tech_cdis + ' ' + body.tech_cdisU;
                aDisplay = formatAcceleration(a, body.tech_cacU) + ' ' + body.tech_cacU;
                ivDisplay = formatVelocity(iv, body.tech_ivU) + ' ' + body.tech_ivU;
            }
        }
        // Case 7: cdis, iv, cac provided
        else if (isNumeric(body.tech_cdis) && isNumeric(body.tech_iv) && isNumeric(body.tech_cac)) {
            if (!isEmpty(body.tech_fv) || body.tech_fv == '0' || !isEmpty(body.tech_ct) || body.tech_ct == '0') {
                param.error = 'Please fill all fields.';
                return param;
            } else {
                check = true;
                dis = convertDistanceToMeters(body.tech_cdis, body.tech_cdisU);
                iv = convertVelocityToMs(body.tech_iv, body.tech_ivU);
                a = convertAccelerationToMs2(body.tech_cac, body.tech_cacU);
                
                time = Math.sqrt(2 * dis / a);
                fv = Math.sqrt(Math.pow(iv, 2) + (2 * a * dis));
                
                ivDisplay = body.tech_iv + ' ' + body.tech_ivU;
                disDisplay = body.tech_cdis + ' ' + body.tech_cdisU;
                aDisplay = body.tech_cac + ' ' + body.tech_cacU;
                fvDisplay = formatVelocity(fv, body.tech_fvU) + ' ' + body.tech_fvU;
                timeDisplay = formatTime(time, body.tech_ctU) + ' ' + body.tech_ctU;
            }
        }
        // Case 8: cdis, fv, cac provided
        else if (isNumeric(body.tech_cdis) && isNumeric(body.tech_fv) && isNumeric(body.tech_cac)) {
            if (!isEmpty(body.tech_iv) || body.tech_iv == '0' || !isEmpty(body.tech_ct) || body.tech_ct == '0') {
                param.error = 'Please fill all fields.';
                return param;
            } else {
                check = true;
                dis = convertDistanceToMeters(body.tech_cdis, body.tech_cdisU);
                fv = convertVelocityToMs(body.tech_fv, body.tech_fvU);
                a = convertAccelerationToMs2(body.tech_cac, body.tech_cacU);
                
                iv = Math.sqrt(Math.pow(fv, 2) - (2 * a * dis));
                time = (fv - iv) / a;
                
                fvDisplay = body.tech_fv + ' ' + body.tech_fvU;
                disDisplay = body.tech_cdis + ' ' + body.tech_cdisU;
                aDisplay = body.tech_cac + ' ' + body.tech_cacU;
                ivDisplay = formatVelocity(iv, body.tech_ivU) + ' ' + body.tech_ivU;
                timeDisplay = formatTime(time, body.tech_ctU) + ' ' + body.tech_ctU;
            }
        }
        // Case 9: cdis, iv, fv provided
        else if (isNumeric(body.tech_cdis) && isNumeric(body.tech_iv) && isNumeric(body.tech_fv)) {
            if (!isEmpty(body.tech_cac) || body.tech_cac == '0' || !isEmpty(body.tech_ct) || body.tech_ct == '0') {
                param.error = 'Please fill all fields.';
                return param;
            } else {
                check = true;
                dis = convertDistanceToMeters(body.tech_cdis, body.tech_cdisU);
                iv = convertVelocityToMs(body.tech_iv, body.tech_ivU);
                fv = convertVelocityToMs(body.tech_fv, body.tech_fvU);
                
                a = (Math.pow(fv, 2) - Math.pow(iv, 2)) / (2 * dis);
                time = (fv - iv) / a;
                
                timeDisplay = formatTime(time, body.tech_ctU) + ' ' + body.tech_ctU;
                aDisplay = formatAcceleration(a, body.tech_cacU) + ' ' + body.tech_cacU;
                ivDisplay = body.tech_iv + ' ' + body.tech_ivU;
                fvDisplay = body.tech_fv + ' ' + body.tech_fvU;
                disDisplay = body.tech_cdis + ' ' + body.tech_cdisU;
            }
        }
        // Case 10: cdis, ct, cac provided
        else if (isNumeric(body.tech_cdis) && isNumeric(body.tech_ct) && isNumeric(body.tech_cac)) {
            if (!isEmpty(body.tech_iv) || body.tech_iv == '0' || !isEmpty(body.tech_fv) || body.tech_fv == '0') {
                param.error = 'Please fill all fields.';
                return param;
            } else {
                check = true;
                dis = convertDistanceToMeters(body.tech_cdis, body.tech_cdisU);
                time = convertTimeToSeconds(body.tech_ct, body.tech_ctU);
                a = convertAccelerationToMs2(body.tech_cac, body.tech_cacU);
                
                iv = (dis - (0.5 * a * Math.pow(time, 2))) / time;
                fv = iv + (a * time);
                
                fvDisplay = formatVelocity(fv, body.tech_fvU) + ' ' + body.tech_fvU;
                ivDisplay = formatVelocity(iv, body.tech_ivU) + ' ' + body.tech_ivU;
                disDisplay = body.tech_cdis + ' ' + body.tech_cdisU;
                aDisplay = body.tech_cac + ' ' + body.tech_cacU;
                timeDisplay = body.tech_ct + ' ' + body.tech_ctU;
            }
        }

        if (check === true) {
            param.tech_iv = ivDisplay;
            param.tech_fv = fvDisplay;
            param.tech_time = timeDisplay;
            param.tech_dis = disDisplay;
            param.tech_a = aDisplay;
            return param;
        } else {
            param.error = 'Please fill all fields.';
            return param;
        }
    }

        /**
    * getCalculationInstantaneousRateOfChangeCalculator: Service Method
    * POST: /api/calculators-lol/instantaneous-rate-of-change-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationInstantaneousRateOfChangeCalculator(body) {
      const param = {};
      const EnterEq = body.tech_EnterEq;
      const x = body.tech_x;
      // Helper functions
      const isNumeric = (value) => {
          return !isNaN(parseFloat(value)) && isFinite(value);
      };

      const isEmpty = (value) => {
          return value == undefined || value == null || value == '';
      };

      const parseScientificNotation = (value) => {
          if (typeof value == 'number') return value;
          if (typeof value == 'string') {
              // Handle scientific notation like '1.32e+23'
              if (value.includes('e')) {
                  const [coefficient, exponent] = value.split('e');
                  return parseFloat(coefficient) * Math.pow(10, parseFloat(exponent));
              }
              return parseFloat(value);
          }
          return value;
      };

      const formatLargeNumber = (value) => {
          if (value == null || value == undefined) return value;
          
          const numValue = parseScientificNotation(value);
          
          // For very large numbers, return as string to avoid precision issues
          if (Math.abs(numValue) > 1e15) {
              return numValue.toString();
          }
          
          // For normal numbers, round to 7 decimal places
          try {
              return Number(parseFloat(numValue).toFixed(7));
          } catch (error) {
              console.log('Rounding failed, returning original value:', numValue);
              return numValue;
          }
      };

      // Security check
      if (!EnterEq || /(<|>|&|php|print_r|print|echo|script|&|%)/i.test(EnterEq)) {
          param.error = 'Please fill all fields.';
          return param;
      }

      if (isNumeric(x) && !isEmpty(EnterEq)) {
          let parem = EnterEq;
          // Apply transformations
          parem = parem.replace(/M\(x\) =/g, '');
          parem = parem.replace(/f\(x\) =/g, '');
          parem = parem.replace(/Square root/g, 'sqrt');
          parem = parem.replace(/√/g, 'sqrt');
          parem = parem.replace(/ /g, '');
          parem = parem.replace(/y=/g, '');
          parem = parem.replace(/\+/g, 'plus');
          parem = parem.replace(/%20/g, '');
          parem = parem.replace(/{/g, '(');
          parem = parem.replace(/}/g, ')');
          parem = parem.replace(/e\^/g, 'exp');
          parem = parem.replace(/exp\^/g, 'exp');
          parem = parem.replace(/\^/g, '**');
          parem = parem.replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

          try {
              const axios = require('axios');
              
              const response = await axios.post('http://167.172.134.148/new-i_r_o_c', {
                  equ: parem,
                  x: parseFloat(x)
              }, {
                  timeout: 120000,
                  headers: {
                      'Content-Type': 'application/x-www-form-urlencoded',
                  }
              });

              const buffer = response.data;
              
              if (Array.isArray(buffer) && buffer.length >= 3) {
                  param.tech_equation = buffer[2];
                  
                  // Handle the derivative value
                  let derivValue = buffer[0];
                  
                  // Convert and format the number
                  param.tech_deriv = formatLargeNumber(derivValue);
                  
                  param.stech_teps = buffer[1];
              } else {
                  param.error = 'Invalid response from calculation service';
              }
              return param;

          } catch (error) {
              console.error('Error calling Python service:', error.message);
              param.error = 'Calculation service unavailable. Please try again.';
              return param;
          }
      } else {
          param.error = 'Please provide valid equation and x value.';
          return param;
      }
  }


     /**
    * getCalculationSpecificHeatCalculator: Service Method
    * POST: /api/calculators-lol/specific-heat-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

   async getCalculationSpecificHeatCalculator(body) {
    let param = {};
        
        // Extract parameters (same as PHP)
        let find = body.tech_find;
        let by = body.tech_by;
        let q = body.tech_q;
        let q_unit = body.tech_q_unit;
        let it = body.tech_it;
        let it_unit = body.tech_it_unit;
        let ft = body.tech_ft;
        let ft_unit = body.tech_ft_unit;
        let dt = body.tech_dt;
        let dt_unit = body.tech_dt_unit;
        let m = body.tech_m;
        let m_unit = body.tech_m_unit;
        let c = body.tech_c;
        let c_unit = body.tech_c_unit;
        let sub = body.tech_sub;

        // Same condition check
        if ((by == 'change' && dt == '0') || (by == 'i_f_t' && (ft - it) == 0)) {
            param.error = 'Change of temperature cannot be zero!';
            return param;
        }

        // Unit Conversion (exact same logic)
        if (!isNaN(q)) {
            q = parseFloat(q);
            if (q_unit == 'kJ') {
                q = q / 0.001;
            } else if (q_unit == 'mJ') {
                q = q / 0.000001;
            } else if (q_unit == 'Wh') {
                q = q / 0.000277778;
            } else if (q_unit == 'kWh') {
                q = q / 0.000000277778;
            } else if (q_unit == 'ft-lbs') {
                q = q / 0.737562;
            } else if (q_unit == 'kcal') {
                q = q / 0.0002390057;
            } else if (q_unit == 'eV') {
                q = q / 6241534918267100245;
            }
        }

        if (!isNaN(it)) {
            it = parseFloat(it);
            if (it_unit == '°F') {
                it = it / 1.8;
            }
        }

        if (!isNaN(ft)) {
            ft = parseFloat(ft);
            if (ft_unit == '°F') {
                ft = ft / 1.8;
            }
        }

        if (!isNaN(dt)) {
            dt = parseFloat(dt);
            if (dt_unit == '°F') {
                dt = dt / 1.8;
            }
        }

        if (!isNaN(m)) {
            m = parseFloat(m);
            if (m_unit == 'µg') {
                m = m / 1000000000;
            } else if (m_unit == 'mg') {
                m = m / 1000000;
            } else if (m_unit == 'g') {
                m = m / 1000;
            } else if (m_unit == 't') {
                m = m / 0.001;
            } else if (m_unit == 'oz') {
                m = m / 35.27396;
            } else if (m_unit == 'lb') {
                m = m / 2.204623;
            } else if (m_unit == 'stone') {
                m = m / 0.157473;
            } else if (m_unit == 'US ton') {
                m = m / 0.001102311;
            } else if (m_unit == 'Long ton') {
                m = m / 0.000984207;
            } else if (m_unit == 'Earths') {
                m = m * 5972000000000000000000000;
            } else if (m_unit == 'me') {
                m = m / 1097769122809886380500592292548;
            } else if (m_unit == 'u') {
                m = m / 602214000000000000000000000;
            } else if (m_unit == 'oz t') {
                m = m / 32.15075;
            }
        }

        if (!isNaN(c)) {
            c = parseFloat(c);
            if (c_unit == 'J/(g·K)' || c_unit == 'J/(g·°C)') {
                c = c / 0.001;
            } else if (c_unit == 'cal/(kg·K)' || c_unit == 'cal/(kg·°C)') {
                c = c / 0.2388915;
            } else if (c_unit == 'cal/(g·K)' || c_unit == 'kcal/(kg·K)' || c_unit == 'cal/(g·°C)' || c_unit == 'kcal/(kg·°C)') {
                c = c / 0.0002388915;
            }
        }

        // Same calculation logic
        if (find == 'energy' && by == 'change' && !isNaN(dt) && !isNaN(m) && !isNaN(c)) {
            let s = m * c;
            q = s * dt;
             param.tech_s = isNaN(s) ? 'NaN' : s;
            param.tech_q = Math.round(q * 1000) / 1000;
        } else if (find == 'energy' && by == 'i_f_t' && !isNaN(it) && !isNaN(ft) && !isNaN(m) && !isNaN(c)) {
            dt = ft - it;
            let s = m * c;
            q = s * dt;
            param.check = 'q_i_f';
             param.tech_s = isNaN(s) ? 'NaN' : s;
            param.tech_q = Math.round(q * 1000) / 1000;
        } else if (find == 'specific_heat' && by == 'change' && !isNaN(q) && !isNaN(dt) && !isNaN(m)) {
            let s = m * dt;
            c = q / s;
             param.tech_s = isNaN(s) ? 'NaN' : s;
            param.tech_c = Math.round(c * 1000) / 1000;
        } else if (find == 'specific_heat' && by == 'i_f_t' && !isNaN(q) && !isNaN(it) && !isNaN(ft) && !isNaN(m)) {
            dt = ft - it;
            let s = m * dt;
            c = q / s;
            param.check = 'c_i_f';
             param.tech_s = isNaN(s) ? 'NaN' : s;
            param.tech_c = Math.round(c * 1000) / 1000;
        } else if (find == 'mass' && by == 'change' && !isNaN(q) && !isNaN(dt) && !isNaN(c)) {
            let s = c * dt;
            m = q / s;
             param.tech_s = isNaN(s) ? 'NaN' : s;
            param.tech_m = Math.round(m * 1000) / 1000;
        } else if (find == 'mass' && by == 'i_f_t' && !isNaN(q) && !isNaN(it) && !isNaN(ft) && !isNaN(c)) {
            dt = ft - it;
            let s = c * dt;
            m = q / s;
            param.check = 'm_i_f';
             param.tech_s = isNaN(s) ? 'NaN' : s;
            param.tech_m = Math.round(m * 1000) / 1000;
        } else if (find == 'itemp' && !isNaN(q) && !isNaN(ft) && !isNaN(m) && !isNaN(c)) {
            let s = m * c;
            let s1 = q / s;
            it = s1 - ft;
           param.tech_s = isNaN(s) ? 'NaN' : s;
            param.tech_s1 = isNaN(s1) ? 'NaN' : s1;
            param.tech_it = Math.round(it * 1000) / 1000;
        } else if (find == 'ftemp' && !isNaN(q) && !isNaN(it) && !isNaN(m) && !isNaN(c)) {
            let s = m * c;
            let s1 = q / s;
            ft = s1 + it;
          param.tech_s = isNaN(s) ? "NaN" : s;
          param.tech_s1 = isNaN(s1) ? "NaN" : s1;
            param.tech_ft = Math.round(ft * 1000) / 1000;
        } else {
            param.error = 'Please! Fill All The Fields!';
            return param;
        }

        // Same substance handling
        if (sub != 'select') {
            let subs = sub.split('@');
            let sub_val = subs[0];
            let sub_name = subs[1];
            
            if (sub_val !== undefined) {
                param.tech_sub = isNaN(sub_val) ? "NaN" : sub_val;
                 param.tech_sub1 = sub_name;
            }
        }

        // Store converted values
        param.tech_q1 = isNaN(q) ? "NaN" : q;
        param.tech_it1 = isNaN(it) ? "NaN" : it;
        param.tech_ft1 = isNaN(ft) ? "NaN" : ft;
        param.tech_dt1 = isNaN(dt) ? "NaN" : dt;
        param.tech_m1 = isNaN(m) ? "NaN" : m;
        param.tech_c1 = isNaN(c) ? "NaN" : c;

        return param;
    }

       /**
    * getCalculationWorkCalculator: Service Method
    * POST: /api/calculators-lol/work-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

        async getCalculationWorkCalculator(body) {
        const param = {};
        
        // Extract all parameters from request body using let
        let method = body.tech_method;
        let method1 = body.tech_method1;
        let find = body.tech_find;
        let find1 = body.tech_find1;
        let find2 = body.tech_find2;
        let f = parseFloat(body.tech_f);
        let f_unit = body.tech_f_unit;
        let d = parseFloat(body.tech_d);
        let d_unit = body.tech_d_unit;
        let w = parseFloat(body.tech_w);
        let w_unit = body.tech_w_unit;
        let p = parseFloat(body.tech_p);
        let p_unit = body.tech_p_unit;
        let t = parseFloat(body.tech_t);
        let t_unit = body.tech_t_unit;
        let m = parseFloat(body.tech_m);
        let m_unit = body.tech_m_unit;
        let v0 = parseFloat(body.tech_v0);
        let v0_unit = body.tech_v0_unit;
        let v1 = parseFloat(body.tech_v1);
        let v1_unit = body.tech_v1_unit;

        // Temporary variables for calculations
        let s1, s2, s3, s4;

        if(!isNaN(f) && isFinite(f)){
            if(f_unit=='kn'){
                f = f/0.001;
            }else if(f_unit=='mn'){
                f = f/0.000001;
            }else if(f_unit=='gn'){
                f = f/0.000000001;
            }else if(f_unit=='tn'){
                f = f/0.000000000001;
            }
        }
        
        if(!isNaN(d) && isFinite(d)){
            if(d_unit=='mm'){
                d = d/1000;
            }else if(d_unit=='cm'){
                d = d/100;
            }else if(d_unit=='km'){
                d = d/0.001;
            }else if(d_unit=='in'){
                d = d/39.37;
            }else if(d_unit=='ft'){
                d = d/3.281;
            }else if(d_unit=='yd'){
                d = d/1.0936;
            }else if(d_unit=='mi'){
                d = d/0.0006214;
            }else if(d_unit=='nmi'){
                d = d/0.00054;
            }
        }
        
        if(!isNaN(v0) && isFinite(v0)){
            if(v0_unit=='kmh'){
                v0 = v0/3.6;
            }else if(v0_unit=='fts'){
                v0 = v0/3.281;
            }else if(v0_unit=='mph'){
                v0 = v0/2.237;
            }else if(v0_unit=='knots'){
                v0 = v0/1.944;
            }else if(v0_unit=='ftmin'){
                v0 = v0/196.85;
            }
        }
        
        if(!isNaN(v1) && isFinite(v1)){
            if(v1_unit=='kmh'){
                v1 = v1/3.6;
            }else if(v1_unit=='fts'){
                v1 = v1/3.281;
            }else if(v1_unit=='mph'){
                v1 = v1/2.237;
            }else if(v1_unit=='knots'){
                v1 = v1/1.944;
            }else if(v1_unit=='ftmin'){
                v1 = v1/196.85;
            }
        }
        
        if(!isNaN(w) && isFinite(w)){
            if(w_unit=='kj'){
                w = w/0.001;
            }else if(w_unit=='mj'){
                w = w/0.000001;
            }else if(w_unit=='wh'){
                w = w/0.0002778;
            }else if(w_unit=='kwh'){
                w = w/0.0000002778;
            }else if(w_unit=='ft_lbs'){
                w = w/0.7376;
            }else if(w_unit=='kcal'){
                w = w/0.000239;
            }else if(w_unit=='ev'){
                w = w/6241534918267100245;
            }
        }
        
        if(!isNaN(m) && isFinite(m)){
            if(m_unit=='mg'){
                m = m/1000000;
            }else if(m_unit=='g'){
                m = m/1000;
            }else if(m_unit=='t'){
                m = m/0.001;
            }else if(m_unit=='oz'){
                m = m/35.274;
            }else if(m_unit=='lb'){
                m = m/2.2046;
            }else if(m_unit=='stone'){
                m = m/0.15747;
            }else if(m_unit=='us_ton'){
                m = m/0.0011023;
            }else if(m_unit=='long_ton'){
                m = m/0.0009842;
            }
        }
        
        if(!isNaN(p) && isFinite(p)){
            if(p_unit=='mW'){
                p = p/1000;
            }else if(p_unit=='kw'){
                p = p/0.001;
            }else if(p_unit=='MW'){
                p = p/0.000001;
            }else if(p_unit=='gw'){
                p = p/0.000000001;
            }else if(p_unit=='btu_h'){
                p = p/3.412;
            }else if(p_unit=='hp_l'){
                p = p/0.001341;
            }
        }
        
        if(!isNaN(t) && isFinite(t)){
            if(t_unit=='min'){
                t = t/0.016667;
            }else if(t_unit=='hrs'){
                t = t/0.0002778;
            }else if(t_unit=='days'){
                t = t/0.000011574;
            }else if(t_unit=='wks'){
                t = t/0.0000016534;
            }else if(t_unit=='mos'){
                t = t/0.00000038026;
            }else if(t_unit=='yrs'){
                t = t/0.00000003169;
            }
        }
        
        if(method=='work' && method1=='fnd' && find=='work' && !isNaN(f) && !isNaN(d)){
            w = f*d;
            param['tech_work']='work';
            param['tech_w'] = isNaN(w) ? 'NaN' : Math.round(w * 10000) / 10000;
            param['tech_f'] = isNaN(f) ? 'NaN' : f;
            param['tech_d'] = isNaN(d) ? 'NaN' : d;
        }else if(method=='work' && method1=='fnd' && find=='force' && !isNaN(w) && !isNaN(d)){
            f = w/d;
            param['tech_force']='force';
            param['tech_f'] = isNaN(f) ? 'NaN' : Math.round(f * 10000) / 10000;
            param['tech_w'] = isNaN(w) ? 'NaN' : w;
            param['tech_d'] = isNaN(d) ? 'NaN' : d;
        }else if(method=='work' && method1=='fnd' && find=='dsplcmnt' && !isNaN(w) && !isNaN(f)){
            d = w/f;
          param['tech_dsplcmnt'] = 'dsplcmnt';
          param['tech_d'] = isNaN(d) ? 'NaN' : Math.round(d * 10000) / 10000;
          param['tech_w'] = isNaN(w) ? 'NaN' : w;
          param['tech_f'] = isNaN(f) ? 'NaN' : f;

        }else if(method=='work' && method1=='velocity' && find2=='work2' && !isNaN(m) && !isNaN(v0) && !isNaN(v1)){
            s1 = m/2;
            s2 = Math.pow(v1,2);
            s3 = Math.pow(v0,2);
            s4 = s2-s3;
            w = s1*s4;
          param['tech_work1'] = 'work1';
          param['tech_w']  = isNaN(w)  ? 'NaN' : Math.round(w * 10000) / 10000;
          param['tech_m']  = isNaN(m)  ? 'NaN' : m;
          param['tech_v0'] = isNaN(v0) ? 'NaN' : v0;
          param['tech_v1'] = isNaN(v1) ? 'NaN' : v1;
          param['tech_s1'] = isNaN(s1) ? 'NaN' : s1;
          param['tech_s2'] = isNaN(s2) ? 'NaN' : s2;
          param['tech_s3'] = isNaN(s3) ? 'NaN' : s3;
          param['tech_s4'] = isNaN(s4) ? 'NaN' : s4;
        }else if(method=='work' && method1=='velocity' && find2=='v0' && !isNaN(m) && !isNaN(w) && !isNaN(v1)){
            s1 = Math.pow(v1,2);
            s2 = 2/m;
            s3 = s2*w;
            s4 = s1-s3;
            v0 = Math.sqrt(s4);
          param['tech_i_v'] = 'i_v';
          param['tech_v0'] = isNaN(v0) ? 'NaN' : Math.round(v0 * 10000) / 10000;
            param['tech_w']  = isNaN(w)  ? 'NaN' : w;
            param['tech_m']  = isNaN(m)  ? 'NaN' : m;
            param['tech_v1'] = isNaN(v1) ? 'NaN' : v1;
            param['tech_s1'] = isNaN(s1) ? 'NaN' : s1;
            param['tech_s2'] = isNaN(s2) ? 'NaN' : s2;
            param['tech_s3'] = isNaN(s3) ? 'NaN' : s3;
            param['tech_s4'] = isNaN(s4) ? 'NaN' : s4;

        }else if(method=='work' && method1=='velocity' && find2=='v1' && !isNaN(m) && !isNaN(w) && !isNaN(v0)){
            s1 = Math.pow(v0,2);
            s2 = 2/m;
            s3 = s2*w;
            s4 = s1+s3;
            v1 = Math.sqrt(s4);
            param['tech_f_v'] = 'f_v';
            param['tech_v1'] = isNaN(v1) ? 'NaN' : Math.round(v1 * 10000) / 10000;
            param['tech_w']  = isNaN(w)  ? 'NaN' : w;
            param['tech_m']  = isNaN(m)  ? 'NaN' : m;
            param['tech_v0'] = isNaN(v0) ? 'NaN' : v0;
            param['tech_s1'] = isNaN(s1) ? 'NaN' : s1;
            param['tech_s2'] = isNaN(s2) ? 'NaN' : s2;
            param['tech_s3'] = isNaN(s3) ? 'NaN' : s3;
            param['tech_s4'] = isNaN(s4) ? 'NaN' : s4;

        }else if(method=='work' && method1=='velocity' && find2=='mass' && !isNaN(w) && !isNaN(v0) && !isNaN(v1)){
            s1 = 2*w;
            s2 = Math.pow(v1,2);
            s3 = Math.pow(v0,2);
            s4 = s2-s3;
            if(s4 === 0){
                m = 0;
            }else{
                m = s1/s4;
            }
          param['tech_mass'] = 'mass';
          param['tech_m']  = isNaN(m)  ? 'NaN' : Math.round(m * 10000) / 10000;
          param['tech_w']  = isNaN(w)  ? 'NaN' : w;
          param['tech_v0'] = isNaN(v0) ? 'NaN' : v0;
          param['tech_v1'] = isNaN(v1) ? 'NaN' : v1;
          param['tech_s1'] = isNaN(s1) ? 'NaN' : s1;
          param['tech_s2'] = isNaN(s2) ? 'NaN' : s2;
          param['tech_s3'] = isNaN(s3) ? 'NaN' : s3;
          param['tech_s4'] = isNaN(s4) ? 'NaN' : s4;

        }else if(method=='power' && find1=='power' && !isNaN(w) && !isNaN(t)){
            p = w/t;
            param['tech_power']='power';
          param['tech_p'] = isNaN(p) ? 'NaN' : Math.round(p * 10000) / 10000;
            param['tech_w'] = isNaN(w) ? 'NaN' : w;
            param['tech_t'] = isNaN(t) ? 'NaN' : t;

        }else if(method=='power' && find1=='work1' && !isNaN(p) && !isNaN(t)){
            w = p*t;
            param['tech_work2']='work2';
            param['tech_w'] = isNaN(w) ? 'NaN' : Math.round(w * 10000) / 10000;
            param['tech_p'] = isNaN(p) ? 'NaN' : p;
            param['tech_t'] = isNaN(t) ? 'NaN' : t;

        }else if(method=='power' && find1=='time' && !isNaN(w) && !isNaN(p)){
            t = w/p;
            param['time']='time';
            param['tech_t'] = isNaN(t) ? 'NaN' : Math.round(t * 10000) / 10000;
            param['tech_p'] = isNaN(p) ? 'NaN' : p;
            param['tech_w'] = isNaN(w) ? 'NaN' : w;

        }else{
            param['error'] = 'Please fill all fields.';
            return param;
        }
        
        param['tech_f'] = f;

        return param;
    }

      /**
    * getCalculationWaterViscosityCalculator: Service Method
    * POST: /api/calculators-lol/water-viscosity-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

      async getCalculationWaterViscosityCalculator(body) {
        const param = {};
        
        let temp = parseFloat(body.tech_temp);
        const unit = body.tech_unit;

        if (!isNaN(temp)) {
            if (unit == 'f') {
                temp = (temp - 32) * 5 / 9;
            } else if (unit == 'k') {
                temp = temp - 273.15;
            }
            
            if (temp < 0 || temp > 370) {
                param['error'] = 'This calculator only works up to 698°F or 370°C.';
                return param;
            }

            let ans, ans1, ans3;

            // First calculation block for ans
            if (temp >= 0 && temp <= 2) {
                ans = (1.7880 + (temp - 0) * -0.05725);
            } else if (temp > 2 && temp <= 3) {
                ans = (1.6735 + (temp - 2) * -0.05450);
            } else if (temp > 3 && temp <= 4) {
                ans = (1.6190 + (temp - 3) * -0.05170);
            } else if (temp > 4 && temp <= 5) {
                ans = (1.5673 + (temp - 4) * -0.04909);
            } else if (temp > 5 && temp <= 6) {
                ans = (1.5182 + (temp - 5) * -0.04670);
            } else if (temp > 6 && temp <= 7) {
                ans = (1.4715 + (temp - 6) * -0.04440);
            } else if (temp > 7 && temp <= 8) {
                ans = (1.4271 + (temp - 7) * -0.04240);
            } else if (temp > 8 && temp <= 9) {
                ans = (1.3847 + (temp - 8) * -0.04030);
            } else if (temp > 9 && temp <= 10) {
                ans = (1.3444 + (temp - 9) * -0.03850);
            } else if (temp > 10 && temp <= 11) {
                ans = (1.3059 + (temp - 10) * -0.03670);
            } else if (temp > 11 && temp <= 12) {
                ans = (1.2692 + (temp - 11) * -0.03520);
            } else if (temp > 12 && temp <= 13) {
                ans = (1.2340 + (temp - 12) * -0.03350);
            } else if (temp > 13 && temp <= 14) {
                ans = (1.2005 + (temp - 13) * -0.03220);
            } else if (temp > 14 && temp <= 15) {
                ans = (1.1683 + (temp - 14) * -0.03080);
            } else if (temp > 15 && temp <= 16) {
                ans = (1.1375 + (temp - 15) * -0.02940);
            } else if (temp > 16 && temp <= 17) {
                ans = (1.1081 + (temp - 16) * -0.02830);
            } else if (temp > 17 && temp <= 18) {
                ans = (1.0798 + (temp - 17) * -0.02720);
            } else if (temp > 18 && temp <= 19) {
                ans = (1.0526 + (temp - 18) * -0.02600);
            } else if (temp > 19 && temp <= 20) {
                ans = (1.0266 + (temp - 19) * -0.02500);
            } else if (temp > 20 && temp <= 21) {
                ans = (1.0016 + (temp - 20) * -0.02410);
            } else if (temp > 21 && temp <= 22) {
                ans = (0.9775 + (temp - 21) * -0.02310);
            } else if (temp > 22 && temp <= 23) {
                ans = (0.9544 + (temp - 22) * -0.02230);
            } else if (temp > 23 && temp <= 24) {
                ans = (0.9321 + (temp - 23) * -0.02140);
            } else if (temp > 24 && temp <= 25) {
                ans = (0.9107 + (temp - 24) * -0.02070);
            } else if (temp > 25 && temp <= 26) {
                ans = (0.8900 + (temp - 25) * -0.01990);
            } else if (temp > 26 && temp <= 27) {
                ans = (0.8701 + (temp - 26) * -0.01920);
            } else if (temp > 27 && temp <= 28) {
                ans = (0.8509 + (temp - 27) * -0.01850);
            } else if (temp > 28 && temp <= 29) {
                ans = (0.8324 + (temp - 28) * -0.01790);
            } else if (temp > 29 && temp <= 30) {
                ans = (0.8145 + (temp - 29) * -0.01730);
            } else if (temp > 30 && temp <= 31) {
                ans = (0.7972 + (temp - 30) * -0.01670);
            } else if (temp > 31 && temp <= 32) {
                ans = (0.7805 + (temp - 31) * -0.01610);
            } else if (temp > 32 && temp <= 33) {
                ans = (0.7644 + (temp - 32) * -0.01560);
            } else if (temp > 33 && temp <= 34) {
                ans = (0.7488 + (temp - 33) * -0.01510);
            } else if (temp > 34 && temp <= 35) {
                ans = (0.7337 + (temp - 34) * -0.01460);
            } else if (temp > 35 && temp <= 36) {
                ans = (0.7191 + (temp - 35) * -0.01410);
            } else if (temp > 36 && temp <= 37) {
                ans = (0.7050 + (temp - 36) * -0.01370);
            } else if (temp > 37 && temp <= 38) {
                ans = (0.6913 + (temp - 37) * -0.01330);
            } else if (temp > 38 && temp <= 39) {
                ans = (0.6780 + (temp - 38) * -0.01280);
            } else if (temp > 39 && temp <= 40) {
                ans = (0.6652 + (temp - 39) * -0.01250);
            } else if (temp > 40 && temp <= 45) {
                ans = (0.6527 + (temp - 40) * -0.01138);
            } else if (temp > 45 && temp <= 50) {
                ans = (0.5958 + (temp - 45) * -0.00986);
            } else if (temp > 50 && temp <= 55) {
                ans = (0.5465 + (temp - 50) * -0.00858);
            } else if (temp > 55 && temp <= 60) {
                ans = (0.5036 + (temp - 55) * -0.00752);
            } else if (temp > 60 && temp <= 65) {
                ans = (0.4660 + (temp - 60) * -0.00662);
            } else if (temp > 65 && temp <= 70) {
                ans = (0.4329 + (temp - 65) * -0.00558);
            } else if (temp > 70 && temp <= 75) {
                ans = (0.4035 + (temp - 70) * -0.00522);
            } else if (temp > 75 && temp <= 80) {
                ans = (0.3774 + (temp - 75) * -0.00468);
            } else if (temp > 80 && temp <= 90) {
                ans = (0.3540 + (temp - 80) * -0.00391);
            } else if (temp > 90 && temp <= 100) {
                ans = (0.3149 + (temp - 90) * -0.00324);
            } else if (temp > 100 && temp <= 110) {
                ans = (0.2825 + (temp - 100) * -0.00235);
            } else if (temp > 110 && temp <= 120) {
                ans = (0.2590 + (temp - 110) * -0.00216);
            } else if (temp > 120 && temp <= 130) {
                ans = (0.2374 + (temp - 120) * -0.00196);
            } else if (temp > 130 && temp <= 140) {
                ans = (0.2178 + (temp - 130) * -0.00167);
            } else if (temp > 140 && temp <= 150) {
                ans = (0.2011 + (temp - 140) * -0.00147);
            } else if (temp > 150 && temp <= 160) {
                ans = (0.1864 + (temp - 150) * -0.00128);
            } else if (temp > 160 && temp <= 170) {
                ans = (0.1736 + (temp - 160) * -0.00108);
            } else if (temp > 170 && temp <= 180) {
                ans = (0.1628 + (temp - 170) * -0.00098);
            } else if (temp > 180 && temp <= 190) {
                ans = (0.1530 + (temp - 180) * -0.00088);
            } else if (temp > 190 && temp <= 200) {
                ans = (0.1442 + (temp - 190) * -0.00078);
            } else if (temp > 200 && temp <= 210) {
                ans = (0.1364 + (temp - 200) * -0.00059);
            } else if (temp > 210 && temp <= 220) {
                ans = (0.1305 + (temp - 210) * -0.00059);
            } else if (temp > 220 && temp <= 230) {
                ans = (0.1246 + (temp - 220) * -0.00049);
            } else if (temp > 230 && temp <= 240) {
                ans = (0.1197 + (temp - 230) * -0.00049);
            } else if (temp > 240 && temp <= 250) {
                ans = (0.1148 + (temp - 240) * -0.00049);
            } else if (temp > 250 && temp <= 260) {
                ans = (0.1099 + (temp - 250) * -0.00040);
            } else if (temp > 260 && temp <= 270) {
                ans = (0.1059 + (temp - 260) * -0.00039);
            } else if (temp > 270 && temp <= 280) {
                ans = (0.1020 + (temp - 270) * -0.00039);
            } else if (temp > 280 && temp <= 290) {
                ans = (0.0981 + (temp - 280) * -0.00039);
            } else if (temp > 290 && temp <= 300) {
                ans = (0.0942 + (temp - 290) * -0.00030);
            } else if (temp > 300 && temp <= 310) {
                ans = (0.0912 + (temp - 300) * -0.00029);
            } else if (temp > 310 && temp <= 320) {
                ans = (0.0883 + (temp - 310) * -0.00030);
            } else if (temp > 320 && temp <= 330) {
                ans = (0.0853 + (temp - 320) * -0.00039);
            } else if (temp > 330 && temp <= 340) {
                ans = (0.0814 + (temp - 330) * -0.00039);
            } else if (temp > 340 && temp <= 350) {
                ans = (0.0775 + (temp - 340) * -0.00049);
            } else if (temp > 350 && temp <= 360) {
                ans = (0.0726 + (temp - 350) * -0.00059);
            } else if (temp > 360 && temp <= 370) {
                ans = (0.0667 + (temp - 360) * -0.00098);
            }

            // Second calculation block for ans1
            if (temp >= 0 && temp <= 2) {
                ans1 = ((1.7880 + (temp - 0) * -0.05725) / (0.9999 + (temp - 0) * -0.0000));
            } else if (temp > 2 && temp <= 3) {
                ans1 = ((1.6735 + (temp - 2) * -0.05450) / (0.9999 + (temp - 2) * -0.0001));
            } else if (temp > 3 && temp <= 4) {
                ans1 = ((1.6190 + (temp - 3) * -0.05170) / (1.0000 + (temp - 3) * -0.0000));
            } else if (temp > 4 && temp <= 5) {
                ans1 = ((1.5673 + (temp - 4) * -0.04909) / (1.0000 + (temp - 4) * -0.0000));
            } else if (temp > 5 && temp <= 6) {
                ans1 = ((1.5182 + (temp - 5) * -0.04670) / (1.0000 + (temp - 5) * -0.0001));
            } else if (temp > 6 && temp <= 7) {
                ans1 = ((1.4715 + (temp - 6) * -0.04440) / (0.9999 + (temp - 6) * -0.0000));
            } else if (temp > 7 && temp <= 8) {
                ans1 = ((1.4271 + (temp - 7) * -0.04240) / (0.9999 + (temp - 7) * -0.0000));
            } else if (temp > 8 && temp <= 9) {
                ans1 = ((1.3847 + (temp - 8) * -0.04030) / (0.9999 + (temp - 8) * -0.0001));
            } else if (temp > 9 && temp <= 10) {
                ans1 = ((1.3444 + (temp - 9) * -0.03850) / (0.9998 + (temp - 9) * -0.0001));
            } else if (temp > 10 && temp <= 11) {
                ans1 = ((1.3059 + (temp - 10) * -0.03670) / (0.9997 + (temp - 10) * -0.0001));
            } else if (temp > 11 && temp <= 12) {
                ans1 = ((1.2692 + (temp - 11) * -0.03520) / (0.9996 + (temp - 11) * -0.0001));
            } else if (temp > 12 && temp <= 13) {
                ans1 = ((1.2340 + (temp - 12) * -0.03350) / (0.9995 + (temp - 12) * -0.0001));
            } else if (temp > 13 && temp <= 14) {
                ans1 = ((1.2005 + (temp - 13) * -0.03220) / (0.9994 + (temp - 13) * -0.0002));
            } else if (temp > 14 && temp <= 15) {
                ans1 = ((1.1683 + (temp - 14) * -0.03080) / (0.9992 + (temp - 14) * -0.0001));
            } else if (temp > 15 && temp <= 16) {
                ans1 = ((1.1375 + (temp - 15) * -0.02940) / (0.9991 + (temp - 15) * -0.0002));
            } else if (temp > 16 && temp <= 17) {
                ans1 = ((1.1081 + (temp - 16) * -0.02830) / (0.9989 + (temp - 16) * -0.0001));
            } else if (temp > 17 && temp <= 18) {
                ans1 = ((1.0798 + (temp - 17) * -0.02720) / (0.9988 + (temp - 17) * -0.0002));
            } else if (temp > 18 && temp <= 19) {
                ans1 = ((1.0526 + (temp - 18) * -0.02600) / (0.9986 + (temp - 18) * -0.0002));
            } else if (temp > 19 && temp <= 20) {
                ans1 = ((1.0266 + (temp - 19) * -0.02500) / (0.9984 + (temp - 19) * -0.0002));
            } else if (temp > 20 && temp <= 21) {
                ans1 = ((1.0016 + (temp - 20) * -0.02410) / (0.9982 + (temp - 20) * -0.0002));
            } else if (temp > 21 && temp <= 22) {
                ans1 = ((0.9775 + (temp - 21) * -0.02310) / (0.9980 + (temp - 21) * -0.0002));
            } else if (temp > 22 && temp <= 23) {
                ans1 = ((0.9544 + (temp - 22) * -0.02230) / (0.9978 + (temp - 22) * -0.0003));
            } else if (temp > 23 && temp <= 24) {
                ans1 = ((0.9321 + (temp - 23) * -0.02140) / (0.9975 + (temp - 23) * -0.0002));
            } else if (temp > 24 && temp <= 25) {
                ans1 = ((0.9107 + (temp - 24) * -0.02070) / (0.9973 + (temp - 24) * -0.0003));
            } else if (temp > 25 && temp <= 26) {
                ans1 = ((0.8900 + (temp - 25) * -0.01990) / (0.9970 + (temp - 25) * -0.0002));
            } else if (temp > 26 && temp <= 27) {
                ans1 = ((0.8701 + (temp - 26) * -0.01920) / (0.9968 + (temp - 26) * -0.0003));
            } else if (temp > 27 && temp <= 28) {
                ans1 = ((0.8509 + (temp - 27) * -0.01850) / (0.9965 + (temp - 27) * -0.0003));
            } else if (temp > 28 && temp <= 29) {
                ans1 = ((0.8324 + (temp - 28) * -0.01790) / (0.9962 + (temp - 28) * -0.0003));
            } else if (temp > 29 && temp <= 30) {
                ans1 = ((0.8145 + (temp - 29) * -0.01730) / (0.9959 + (temp - 29) * -0.0003));
            } else if (temp > 30 && temp <= 31) {
                ans1 = ((0.7972 + (temp - 30) * -0.01670) / (0.9956 + (temp - 30) * -0.0003));
            } else if (temp > 31 && temp <= 32) {
                ans1 = ((0.7805 + (temp - 31) * -0.01610) / (0.9953 + (temp - 31) * -0.0003));
            } else if (temp > 32 && temp <= 33) {
                ans1 = ((0.7644 + (temp - 32) * -0.01560) / (0.9950 + (temp - 32) * -0.0003));
            } else if (temp > 33 && temp <= 34) {
                ans1 = ((0.7488 + (temp - 33) * -0.01510) / (0.9947 + (temp - 33) * -0.0003));
            } else if (temp > 34 && temp <= 35) {
                ans1 = ((0.7337 + (temp - 34) * -0.01460) / (0.9944 + (temp - 34) * -0.0004));
            } else if (temp > 35 && temp <= 36) {
                ans1 = ((0.7191 + (temp - 35) * -0.01410) / (0.9940 + (temp - 35) * -0.0003));
            } else if (temp > 36 && temp <= 37) {
                ans1 = ((0.7050 + (temp - 36) * -0.01370) / (0.9937 + (temp - 36) * -0.0004));
            } else if (temp > 37 && temp <= 38) {
                ans1 = ((0.6913 + (temp - 37) * -0.01330) / (0.9933 + (temp - 37) * -0.0003));
            } else if (temp > 38 && temp <= 39) {
                ans1 = ((0.6780 + (temp - 38) * -0.01280) / (0.9930 + (temp - 38) * -0.0004));
            } else if (temp > 39 && temp <= 40) {
                ans1 = ((0.6652 + (temp - 39) * -0.01250) / (0.9926 + (temp - 39) * -0.0004));
            } else if (temp > 40 && temp <= 45) {
                ans1 = ((0.6527 + (temp - 40) * -0.01138) / (0.9922 + (temp - 40) * -0.0004));
            } else if (temp > 45 && temp <= 50) {
                ans1 = ((0.5958 + (temp - 45) * -0.00986) / (0.9902 + (temp - 45) * -0.00044));
            } else if (temp > 50 && temp <= 55) {
                ans1 = ((0.5465 + (temp - 50) * -0.00858) / (0.9880 + (temp - 50) * -0.00046));
            } else if (temp > 55 && temp <= 60) {
                ans1 = ((0.5036 + (temp - 55) * -0.00752) / (0.9857 + (temp - 55) * -0.00050));
            } else if (temp > 60 && temp <= 65) {
                ans1 = ((0.4660 + (temp - 60) * -0.00662) / (0.9832 + (temp - 60) * -0.00052));
            } else if (temp > 65 && temp <= 70) {
                ans1 = ((0.4329 + (temp - 65) * -0.00558) / (0.9806 + (temp - 65) * -0.00056));
            } else if (temp > 70 && temp <= 75) {
                ans1 = ((0.4035 + (temp - 70) * -0.00522) / (0.9778 + (temp - 70) * -0.00060));
            } else if (temp > 75 && temp <= 80) {
                ans1 = ((0.3774 + (temp - 75) * -0.00468) / (0.9748 + (temp - 75) * -0.00060));
            } else if (temp > 80 && temp <= 90) {
                ans1 = ((0.3540 + (temp - 80) * -0.00391) / (0.9718 + (temp - 80) * -0.00065));
            } else if (temp > 90 && temp <= 100) {
                ans1 = ((0.3149 + (temp - 90) * -0.00324) / (0.9653 + (temp - 90) * -0.00069));
            } else if (temp > 100 && temp <= 110) {
                ans1 = ((0.2825 + (temp - 100) * -0.00235) / (0.9584 + (temp - 100) * -0.00074));
            } else if (temp > 110 && temp <= 120) {
                ans1 = ((0.2590 + (temp - 110) * -0.00216) / (0.9510 + (temp - 110) * -0.00079));
            } else if (temp > 120 && temp <= 130) {
                ans1 = ((0.2374 + (temp - 120) * -0.00196) / (0.9431 + (temp - 120) * -0.00083));
            } else if (temp > 130 && temp <= 140) {
                ans1 = ((0.2178 + (temp - 130) * -0.00167) / (0.9348 + (temp - 130) * -0.00087));
            } else if (temp > 140 && temp <= 150) {
                ans1 = ((0.2011 + (temp - 140) * -0.00147) / (0.9261 + (temp - 140) * -0.00091));
            } else if (temp > 150 && temp <= 160) {
                ans1 = ((0.1864 + (temp - 150) * -0.00128) / (0.9170 + (temp - 150) * -0.00096));
            } else if (temp > 160 && temp <= 170) {
                ans1 = ((0.1736 + (temp - 160) * -0.00108) / (0.9074 + (temp - 160) * -0.00101));
            } else if (temp > 170 && temp <= 180) {
                ans1 = ((0.1628 + (temp - 170) * -0.00098) / (0.8973 + (temp - 170) * -0.00104));
            } else if (temp > 180 && temp <= 190) {
                ans1 = ((0.1530 + (temp - 180) * -0.00088) / (0.8869 + (temp - 180) * -0.00109));
            } else if (temp > 190 && temp <= 200) {
                ans1 = ((0.1442 + (temp - 190) * -0.00078) / (0.8760 + (temp - 190) * -0.00130));
            } else if (temp > 200 && temp <= 210) {
                ans1 = ((0.1364 + (temp - 200) * -0.00059) / (0.8630 + (temp - 200) * -0.00102));
            } else if (temp > 210 && temp <= 220) {
                ans1 = ((0.1305 + (temp - 210) * -0.00059) / (0.8528 + (temp - 210) * -0.00125));
            } else if (temp > 220 && temp <= 230) {
                ans1 = ((0.1246 + (temp - 220) * -0.00049) / (0.8403 + (temp - 220) * -0.00130));
            } else if (temp > 230 && temp <= 240) {
                ans1 = ((0.1197 + (temp - 230) * -0.00049) / (0.8273 + (temp - 230) * -0.00137));
            } else if (temp > 240 && temp <= 250) {
                ans1 = ((0.1148 + (temp - 240) * -0.00049) / (0.8136 + (temp - 240) * -0.00146));
            } else if (temp > 250 && temp <= 260) {
                ans1 = ((0.1099 + (temp - 250) * -0.00040) / (0.7990 + (temp - 250) * -0.00150));
            } else if (temp > 260 && temp <= 270) {
                ans1 = ((0.1059 + (temp - 260) * -0.00039) / (0.7840 + (temp - 260) * -0.00161));
            } else if (temp > 270 && temp <= 280) {
                ans1 = ((0.1020 + (temp - 270) * -0.00039) / (0.7679 + (temp - 270) * -0.00172));
            } else if (temp > 280 && temp <= 290) {
                ans1 = ((0.0981 + (temp - 280) * -0.00039) / (0.7507 + (temp - 280) * -0.00184));
            } else if (temp > 290 && temp <= 300) {
                ans1 = ((0.0942 + (temp - 290) * -0.00030) / (0.7323 + (temp - 290) * -0.00198));
            } else if (temp > 300 && temp <= 310) {
                ans1 = ((0.0912 + (temp - 300) * -0.00029) / (0.7125 + (temp - 300) * -0.00214));
            } else if (temp > 310 && temp <= 320) {
                ans1 = ((0.0883 + (temp - 310) * -0.00030) / (0.6911 + (temp - 310) * -0.00240));
            } else if (temp > 320 && temp <= 330) {
                ans1 = ((0.0853 + (temp - 320) * -0.00039) / (0.6671 + (temp - 320) * -0.00269));
            } else if (temp > 330 && temp <= 340) {
                ans1 = ((0.0814 + (temp - 330) * -0.00039) / (0.6402 + (temp - 330) * -0.00301));
            } else if (temp > 340 && temp <= 350) {
                ans1 = ((0.0775 + (temp - 340) * -0.00049) / (0.6101 + (temp - 340) * -0.00357));
            } else if (temp > 350 && temp <= 360) {
                ans1 = ((0.0726 + (temp - 350) * -0.00059) / (0.5744 + (temp - 350) * -0.00464));
            } else if (temp > 360 && temp <= 370) {
                ans1 = ((0.0667 + (temp - 360) * -0.00098) / (0.4505 + (temp - 360) * -0.00775));
            }

            // Third calculation block for ans3
            if (temp >= 0 && temp <= 2) {
                ans3 = (0.9999 + (temp - 0) * -0.0000);
            } else if (temp > 2 && temp <= 3) {
                ans3 = (0.9999 + (temp - 2) * -0.0001);
            } else if (temp > 3 && temp <= 4) {
                ans3 = (1.0000 + (temp - 3) * -0.0000);
            } else if (temp > 4 && temp <= 5) {
                ans3 = (1.0000 + (temp - 4) * -0.0000);
            } else if (temp > 5 && temp <= 6) {
                ans3 = (1.0000 + (temp - 5) * -0.0001);
            } else if (temp > 6 && temp <= 7) {
                ans3 = (0.9999 + (temp - 6) * -0.0000);
            } else if (temp > 7 && temp <= 8) {
                ans3 = (0.9999 + (temp - 7) * -0.0000);
            } else if (temp > 8 && temp <= 9) {
                ans3 = (0.9999 + (temp - 8) * -0.0001);
            } else if (temp > 9 && temp <= 10) {
                ans3 = (0.9998 + (temp - 9) * -0.0001);
            } else if (temp > 10 && temp <= 11) {
                ans3 = (0.9997 + (temp - 10) * -0.0001);
            } else if (temp > 11 && temp <= 12) {
                ans3 = (0.9996 + (temp - 11) * -0.0001);
            } else if (temp > 12 && temp <= 13) {
                ans3 = (0.9995 + (temp - 12) * -0.0001);
            } else if (temp > 13 && temp <= 14) {
                ans3 = (0.9994 + (temp - 13) * -0.0002);
            } else if (temp > 14 && temp <= 15) {
                ans3 = (0.9992 + (temp - 14) * -0.0001);
            } else if (temp > 15 && temp <= 16) {
                ans3 = (0.9991 + (temp - 15) * -0.0002);
            } else if (temp > 16 && temp <= 17) {
                ans3 = (0.9989 + (temp - 16) * -0.0001);
            } else if (temp > 17 && temp <= 18) {
                ans3 = (0.9988 + (temp - 17) * -0.0002);
            } else if (temp > 18 && temp <= 19) {
                ans3 = (0.9986 + (temp - 18) * -0.0002);
            } else if (temp > 19 && temp <= 20) {
                ans3 = (0.9984 + (temp - 19) * -0.0002);
            } else if (temp > 20 && temp <= 21) {
                ans3 = (0.9982 + (temp - 20) * -0.0002);
            } else if (temp > 21 && temp <= 22) {
                ans3 = (0.9980 + (temp - 21) * -0.0002);
            } else if (temp > 22 && temp <= 23) {
                ans3 = (0.9978 + (temp - 22) * -0.0003);
            } else if (temp > 23 && temp <= 24) {
                ans3 = (0.9975 + (temp - 23) * -0.0002);
            } else if (temp > 24 && temp <= 25) {
                ans3 = (0.9973 + (temp - 24) * -0.0003);
            } else if (temp > 25 && temp <= 26) {
                ans3 = (0.9970 + (temp - 25) * -0.0002);
            } else if (temp > 26 && temp <= 27) {
                ans3 = (0.9968 + (temp - 26) * -0.0003);
            } else if (temp > 27 && temp <= 28) {
                ans3 = (0.9965 + (temp - 27) * -0.0003);
            } else if (temp > 28 && temp <= 29) {
                ans3 = (0.9962 + (temp - 28) * -0.0003);
            } else if (temp > 29 && temp <= 30) {
                ans3 = (0.9959 + (temp - 29) * -0.0003);
            } else if (temp > 30 && temp <= 31) {
                ans3 = (0.9956 + (temp - 30) * -0.0003);
            } else if (temp > 31 && temp <= 32) {
                ans3 = (0.9953 + (temp - 31) * -0.0003);
            } else if (temp > 32 && temp <= 33) {
                ans3 = (0.9950 + (temp - 32) * -0.0003);
            } else if (temp > 33 && temp <= 34) {
                ans3 = (0.9947 + (temp - 33) * -0.0003);
            } else if (temp > 34 && temp <= 35) {
                ans3 = (0.9944 + (temp - 34) * -0.0004);
            } else if (temp > 35 && temp <= 36) {
                ans3 = (0.9940 + (temp - 35) * -0.0003);
            } else if (temp > 36 && temp <= 37) {
                ans3 = (0.9937 + (temp - 36) * -0.0004);
            } else if (temp > 37 && temp <= 38) {
                ans3 = (0.9933 + (temp - 37) * -0.0003);
            } else if (temp > 38 && temp <= 39) {
                ans3 = (0.9930 + (temp - 38) * -0.0004);
            } else if (temp > 39 && temp <= 40) {
                ans3 = (0.9926 + (temp - 39) * -0.0004);
            } else if (temp > 40 && temp <= 45) {
                ans3 = (0.9922 + (temp - 40) * -0.0004);
            } else if (temp > 45 && temp <= 50) {
                ans3 = (0.9902 + (temp - 45) * -0.00044);
            } else if (temp > 50 && temp <= 55) {
                ans3 = (0.9880 + (temp - 50) * -0.00046);
            } else if (temp > 55 && temp <= 60) {
                ans3 = (0.9857 + (temp - 55) * -0.00050);
            } else if (temp > 60 && temp <= 65) {
                ans3 = (0.9832 + (temp - 60) * -0.00052);
            } else if (temp > 65 && temp <= 70) {
                ans3 = (0.9806 + (temp - 65) * -0.00056);
            } else if (temp > 70 && temp <= 75) {
                ans3 = (0.9778 + (temp - 70) * -0.00060);
            } else if (temp > 75 && temp <= 80) {
                ans3 = (0.9748 + (temp - 75) * -0.00060);
            } else if (temp > 80 && temp <= 90) {
                ans3 = (0.9718 + (temp - 80) * -0.00065);
            } else if (temp > 90 && temp <= 100) {
                ans3 = (0.9653 + (temp - 90) * -0.00069);
            } else if (temp > 100 && temp <= 110) {
                ans3 = (0.9584 + (temp - 100) * -0.00074);
            } else if (temp > 110 && temp <= 120) {
                ans3 = (0.9510 + (temp - 110) * -0.00079);
            } else if (temp > 120 && temp <= 130) {
                ans3 = (0.9431 + (temp - 120) * -0.00083);
            } else if (temp > 130 && temp <= 140) {
                ans3 = (0.9348 + (temp - 130) * -0.00087);
            } else if (temp > 140 && temp <= 150) {
                ans3 = (0.9261 + (temp - 140) * -0.00091);
            } else if (temp > 150 && temp <= 160) {
                ans3 = (0.9170 + (temp - 150) * -0.00096);
            } else if (temp > 160 && temp <= 170) {
                ans3 = (0.9074 + (temp - 160) * -0.00101);
            } else if (temp > 170 && temp <= 180) {
                ans3 = (0.8973 + (temp - 170) * -0.00104);
            } else if (temp > 180 && temp <= 190) {
                ans3 = (0.8869 + (temp - 180) * -0.00109);
            } else if (temp > 190 && temp <= 200) {
                ans3 = (0.8760 + (temp - 190) * -0.00130);
            } else if (temp > 200 && temp <= 210) {
                ans3 = (0.8630 + (temp - 200) * -0.00102);
            } else if (temp > 210 && temp <= 220) {
                ans3 = (0.8528 + (temp - 210) * -0.00125);
            } else if (temp > 220 && temp <= 230) {
                ans3 = (0.8403 + (temp - 220) * -0.00130);
            } else if (temp > 230 && temp <= 240) {
                ans3 = (0.8273 + (temp - 230) * -0.00137);
            } else if (temp > 240 && temp <= 250) {
                ans3 = (0.8136 + (temp - 240) * -0.00146);
            } else if (temp > 250 && temp <= 260) {
                ans3 = (0.7990 + (temp - 250) * -0.00150);
            } else if (temp > 260 && temp <= 270) {
                ans3 = (0.7840 + (temp - 260) * -0.00161);
            } else if (temp > 270 && temp <= 280) {
                ans3 = (0.7679 + (temp - 270) * -0.00172);
            } else if (temp > 280 && temp <= 290) {
                ans3 = (0.7507 + (temp - 280) * -0.00184);
            } else if (temp > 290 && temp <= 300) {
                ans3 = (0.7323 + (temp - 290) * -0.00198);
            } else if (temp > 300 && temp <= 310) {
                ans3 = (0.7125 + (temp - 300) * -0.00214);
            } else if (temp > 310 && temp <= 320) {
                ans3 = (0.6911 + (temp - 310) * -0.00240);
            } else if (temp > 320 && temp <= 330) {
                ans3 = (0.6671 + (temp - 320) * -0.00269);
            } else if (temp > 330 && temp <= 340) {
                ans3 = (0.6402 + (temp - 330) * -0.00301);
            } else if (temp > 340 && temp <= 350) {
                ans3 = (0.6101 + (temp - 340) * -0.00357);
            } else if (temp > 350 && temp <= 360) {
                ans3 = (0.5744 + (temp - 350) * -0.00464);
            } else if (temp > 360 && temp <= 370) {
                ans3 = (0.4505 + (temp - 360) * -0.00775);
            }

            param['tech_ans']  = isNaN(ans)  ? 'NaN' : ans;
            param['tech_ans1'] = isNaN(ans1) ? 'NaN' : ans1;
            param['tech_ans2'] = isNaN(ans3) ? 'NaN' : ans3;

            return param;
        } else {
            param['error'] = 'Please! Enter Water temperature';
            return param;
        }
    }

       /**
    * getCalculationUnitVectorCalculator: Service Method
    * POST: /api/calculators-lol/unit-vector-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationUnitVectorCalculator(body) {
        const param = {};
        
        const method = body.tech_method ? body.tech_method.trim() : '';
        const dimen = body.tech_dimen ? body.tech_dimen.trim() : '';
        const find = body.tech_find ? body.tech_find.trim() : '';
        const find1 = body.tech_find1 ? body.tech_find1.trim() : '';
        let x = parseFloat(body.tech_x);
        let y = parseFloat(body.tech_y);
        let z = parseFloat(body.tech_z);
        let fx = parseFloat(body.tech_fx);
        let fy = parseFloat(body.tech_fy);
        let fz = parseFloat(body.tech_fz);

        if (!isNaN(x) && !isNaN(y) && !isNaN(z) && method && dimen) {

            if (method == 'normalize') {
                if (dimen == '2d') {
                    if (!isNaN(x) && !isNaN(y)) {
                        const magnitude = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
                        const vx = x / magnitude;
                        const vy = y / magnitude;
                       param['tech_vx'] = isNaN(vx) ? 'NaN' : vx;
                      param['tech_vy'] = isNaN(vy) ? 'NaN' : vy;
                      param['tech_magnitude'] = isNaN(magnitude) ? 'NaN' : magnitude;
                    } else {
                        param['error'] = 'Please fill all fields.';
                        return param;
                    }
                } else if (dimen == '3d') {
                    if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                        const magnitude = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2));
                        const vx = x / magnitude;
                        const vy = y / magnitude;
                        const vz = z / magnitude;
                      param['tech_vx'] = isNaN(vx) ? 'NaN' : vx;
                      param['tech_vy'] = isNaN(vy) ? 'NaN' : vy;
                      param['tech_vz'] = isNaN(vz) ? 'NaN' : vz;
                      param['tech_magnitude'] = isNaN(magnitude) ? 'NaN' : magnitude;

                    } else {
                        param['error'] = 'Please fill all fields.';
                        return param;
                    }
                }
            } else if (method == 'find') {
                if (dimen == '2d') {
                    if (find == 'x') {
                        if (!isNaN(fy)) {
                            fx = Math.sqrt(1 - Math.pow(fy, 2));
                            const check = Math.round(Math.pow(fx, 2) + (Math.pow(fy, 2)));
                            if (fy > 1) {
                                param['error'] = 'Unit vector components must be less than or equal to 1';
                                return param;
                            }
                            if (check != 1) {
                                param['error'] = 'It is not possible to create unit vector';
                                return param;
                            }
                            param['tech_fx'] = isNaN(fx) ? 'NaN' : fx;
                        } else {
                            param['error'] = 'Please! Check Your Input';
                            return param;
                        }
                    } else if (find == 'y') {
                        if (!isNaN(fx)) {
                            fy = Math.sqrt(1 - Math.pow(fx, 2));
                            const check = Math.round(Math.pow(fx, 2) + (Math.pow(fy, 2)));
                            if (fx > 1) {
                                param['error'] = 'Unit vector components must be less than or equal to 1';
                                return param;
                            }
                            if (check != 1) {
                                param['error'] = 'It is not possible to create unit vector';
                                return param;
                            }
                            param['tech_fy'] = isNaN(fy) ? 'NaN' : fy;
                        } else {
                            param['error'] = 'Please! Check Your Input';
                            return param;
                        }
                    }
                } else if (dimen == '3d') {
                    if (find1 == 'x') {
                        if (!isNaN(fy) && !isNaN(fz)) {
                            fx = Math.sqrt(1 - (Math.pow(fy, 2) + Math.pow(fz, 2)));
                            const check = Math.round(Math.pow(fx, 2) + Math.pow(fy, 2) + (Math.pow(fz, 2)));
                            if (fy > 1 || fz > 1) {
                                param['error'] = 'Unit vector components must be less than or equal to 1';
                                return param;
                            }
                            if (check != 1) {
                                param['error'] = 'It is not possible to create unit vector';
                                return param;
                            }
                               param['tech_fx'] = isNaN(fx) ? 'NaN' : fx;
                        } else {
                            param['error'] = 'Please! Check Your Input';
                            return param;
                        }
                    } else if (find1 == 'y') {
                        if (!isNaN(fx) && !isNaN(fz)) {
                            fy = Math.sqrt(1 - (Math.pow(fx, 2) + Math.pow(fz, 2)));
                            const check = Math.round(Math.pow(fx, 2) + Math.pow(fy, 2) + (Math.pow(fz, 2)));
                            if (fx > 1 || fz > 1) {
                                param['error'] = 'Unit vector components must be less than or equal to 1';
                                return param;
                            }
                            if (check != 1) {
                                param['error'] = 'It is not possible to create unit vector';
                                return param;
                            }
                            param['tech_fy'] = isNaN(fy) ? 'NaN' : fy;

                        } else {
                            param['error'] = 'Please! Check Your Input';
                            return param;
                        }
                    } else if (find1 == 'z') {
                        if (!isNaN(fx) && !isNaN(fy)) {
                            fz = Math.sqrt(1 - (Math.pow(fx, 2) + Math.pow(fy, 2)));
                            const check = Math.round(Math.pow(fx, 2) + Math.pow(fy, 2) + (Math.pow(fz, 2)));
                            if (fx > 1 || fy > 1) {
                                param['error'] = 'Unit vector components must be less than or equal to 1';
                                return param;
                            }
                            if (check != 1) {
                                param['error'] = 'It is not possible to create unit vector';
                                return param;
                            }
                            param['tech_fz'] = fz;
                        } else {
                            param['error'] = 'Please fill all fields.';
                            return param;
                        }
                    }
                }
            } else {
                param['error'] = 'Please fill all fields.';
                return param;
            }
            
            if (dimen == '2d') {
                let deg;
                if (method == 'normalize') {
                    if (x >= 0 && y >= 0) {
                        deg = Math.atan(y / x);
                    } else if (x >= 0 && y < 0) {
                        deg = Math.PI * 2 + Math.atan(y / x);
                    } else if (x < 0 && y >= 0) {
                        deg = Math.PI + Math.atan(y / x);
                    } else if (x < 0 && y < 0) {
                        deg = Math.PI + Math.atan(y / x);
                    }
                } else if (method == 'find') {
                    if (fx >= 0 && fy >= 0) {
                        deg = Math.atan(fy / fx);
                    } else if (fx >= 0 && fy < 0) {
                        deg = Math.PI * 2 + Math.atan(fy / fx);
                    } else if (fx < 0 && fy >= 0) {
                        deg = Math.PI + Math.atan(fy / fx);
                    } else if (fx < 0 && fy < 0) {
                        deg = Math.PI + Math.atan(fy / fx);
                    }
                }
                param['tech_deg'] = deg * (180 / Math.PI); // rad2deg conversion
            }
            
            param['tech_x'] = body.tech_x;
            param['tech_y'] = body.tech_y;
            param['tech_z'] = body.tech_z;
            param['tech_fx'] = body.tech_fx;
            param['tech_fy'] = body.tech_fy;
            param['tech_fz'] = body.tech_fz;
            return param;
        } else {
            param['error'] = 'Please fill all fields.';
            return param;
        }
    }


     /**
    * getCalculationCenterOfMassCalculator: Service Method
    * POST: /api/calculators-lol/center-of-mass-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

  async getCalculationCenterOfMassCalculator(body) {
        const param = {};
        
        let i = 1;
        const how = parseInt(body.tech_how);
        const dem = parseInt(body.tech_dem);
        const mass = [];
        const xs = [];
        const ys = [];
        const zs = [];
        let check = true;

        for (i = 1; i <= how; i++) {
            const m = parseFloat(body['tech_m' + i]);
            const x = parseFloat(body['tech_x' + i]);

            if (!isNaN(m) && !isNaN(x)) {
                // Convert mass units
                const mUnit = body['tech_m' + i + '_unit'];
                let convertedM = m;
                if (mUnit == 'lbs') {
                    convertedM *= 0.4536;
                } else if (mUnit == 'g') {
                    convertedM *= 0.001;
                }
                mass.push(convertedM);
                
                // Convert x units
                const xUnit = body['tech_x' + i + '_unit'];
                let convertedX = x;
                if (xUnit == 'm') {
                    convertedX *= 100;
                } else if (xUnit == 'in') {
                    convertedX *= 2.54;
                } else if (xUnit == 'ft') {
                    convertedX *= 30.48;
                } else if (xUnit == 'yd') {
                    convertedX *= 91.44;
                }
                xs.push(convertedX);
            } else {
                check = false;
                break;
            }

            if (dem == 2 || dem == 3) {
                const y = parseFloat(body['tech_y' + i]);

                if (!isNaN(y)) {
                    // Convert y units
                    const yUnit = body['tech_y' + i + '_unit'];
                    let convertedY = y;
                    if (yUnit == 'm') {
                        convertedY *= 100;
                    } else if (yUnit == 'in') {
                        convertedY *= 2.54;
                    } else if (yUnit == 'ft') {
                        convertedY *= 30.48;
                    } else if (yUnit == 'yd') {
                        convertedY *= 91.44;
                    }
                    ys.push(convertedY);
                } else {
                    check = false;
                    break;
                }
            }

            if (dem == 3) {
                const z = parseFloat(body['tech_z' + i]);

                if (!isNaN(z)) {
                    // Convert z units
                    const zUnit = body['tech_z' + i + '_unit'];
                    let convertedZ = z;
                    if (zUnit == 'm') {
                        convertedZ *= 100;
                    } else if (zUnit == 'in') {
                        convertedZ *= 2.54;
                    } else if (zUnit == 'ft') {
                        convertedZ *= 30.48;
                    } else if (zUnit == 'yd') {
                        convertedZ *= 91.44;
                    }
                    zs.push(convertedZ);
                } else {
                    check = false;
                    break;
                }
            }
        }

        if (check == true) {
            // Calculate x center of mass
            let xcm = 0;
            mass.forEach((value, key) => {
                xcm = xcm + (value * xs[key]);
            });
            
            const totalMass = mass.reduce((sum, current) => sum + current, 0);
            let ansx = xcm / totalMass;
            
            // Convert result units for x
            const resUnit = body.tech_res_unit;
            if (resUnit == 'm') {
                ansx = ansx * 0.01;
            } else if (resUnit == 'in') {
                ansx = ansx * 0.3937;
            } else if (resUnit == 'ft') {
                ansx = ansx * 0.03281;
            } else if (resUnit == 'yd') {
                ansx = ansx * 0.010936;
            }

            if (dem == 2 || dem == 3) {
                // Calculate y center of mass
                let ycm = 0;
                mass.forEach((value, key) => {
                    ycm = ycm + (value * ys[key]);
                });
                let ansy = ycm / totalMass;
                
                // Convert result units for y
                if (resUnit == 'm') {
                    ansy = ansy * 0.01;
                } else if (resUnit == 'in') {
                    ansy = ansy * 0.3937;
                } else if (resUnit == 'ft') {
                    ansy = ansy * 0.03281;
                } else if (resUnit == 'yd') {
                    ansy = ansy * 0.010936;
                }
                param['tech_ansy'] = ansy;
            }

            if (dem == 3) {
                // Calculate z center of mass
                let zcm = 0;
                mass.forEach((value, key) => {
                    zcm = zcm + (value * zs[key]);
                });
                let ansz = zcm / totalMass;
                
                // Convert result units for z
                if (resUnit == 'm') {
                    ansz = ansz * 0.01;
                } else if (resUnit == 'in') {
                    ansz = ansz * 0.3937;
                } else if (resUnit == 'ft') {
                    ansz = ansz * 0.03281;
                } else if (resUnit == 'yd') {
                    ansz = ansz * 0.010936;
                }
                param['tech_ansz'] = ansz;
            }

            param['tech_ansx'] = ansx;
            param['tech_unit'] = resUnit;
            return param;
        } else {
            param['error'] = 'Please fill all fields.';
            return param;
        }
    }


       /**
    * getCalculationelEctricFieldCalculator: Service Method
    * POST: /api/calculators-lol/electric-field-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

    async getCalculationelEctricFieldCalculator(body) {
        const param = {};
        
        const charge = parseFloat(body.tech_charge);
        const c_unit = body.tech_c_unit ? body.tech_c_unit.trim() : '';
        const distance = parseFloat(body.tech_distance);
        const d_unit = body.tech_d_unit ? body.tech_d_unit.trim() : '';
        const selection = body.tech_selection;
        const per = parseFloat(body.tech_per);
        const distance1 = body.tech_distance1 || [];
        const charge1 = body.tech_charge1 || [];
        const selection3 = body.tech_selection3;
        const field = parseFloat(body.tech_electric_field);
        const charge_unit = body.tech_charge_unit || [];
        const distance_unit = body.tech_distance_unit || [];
        
        const d_unit_name = ["nm", "μm", "mm", "cm", "m", "km", "in", "ft", "yd", "mi"];
        const c_unit_name = ["PC", "NC", "μC", "mC", "C", "e"];
        
        const d_unit_index = d_unit_name.indexOf(d_unit) + 1;
        const c_unit_index = c_unit_name.indexOf(c_unit) + 1;

        let convert;  
        let convert2;

        if (!isNaN(charge) && !isNaN(distance) && !isNaN(per) && charge != 0 && distance > 0 && per != 0) {
            if (selection == "1") {
                if (selection3 == "1") {
                    if (c_unit_index == 1) {
                        convert = charge * 0.000001;
                    } else if (c_unit_index == 2) {
                        convert = charge * 0.000000001;
                    } else if (c_unit_index == 3) {
                        convert = charge * 0.000001;
                    } else if (c_unit_index == 4) {
                        convert = charge * 0.001;
                    } else if (c_unit_index == 5) {
                        convert = charge * 1;
                    } else if (c_unit_index == 6) {
                        convert = charge * 1.60218e-19;
                    } else {
                        param['error'] = 'Invalid charge unit';
                        return param;
                    }
                    
                    if (d_unit_index == 1) {
                        convert2 = distance * 0.000000001;
                    } else if (d_unit_index == 2) {
                        convert2 = distance * 0.000001;
                    } else if (d_unit_index == 3) {
                        convert2 = distance * 0.001;
                    } else if (d_unit_index == 4) {
                        convert2 = distance * 0.01;
                    } else if (d_unit_index == 5) {
                        convert2 = distance * 1;
                    } else if (d_unit_index == 6) {
                        convert2 = distance * 1000;
                    } else if (d_unit_index == 7) {
                        convert2 = distance * 0.0254;
                    } else if (d_unit_index == 8) {
                        convert2 = distance * 0.3048;
                    } else if (d_unit_index == 9) {
                        convert2 = distance * 0.9144;
                    } else if (d_unit_index == 10) {
                        convert2 = distance * 1609.3;
                    } else {
                        param['error'] = 'Invalid distance unit';
                        return param;
                    }
                    
                    const field3 = (8.9875517923e9 * convert) / (convert2 * convert2) / (per);
                    param['tech_answer'] = field3;
                    return param;
                } else if (selection3 == "2") {
                    if (c_unit_index == 1) {
                        convert = charge * 0.000001;
                    } else if (c_unit_index == 2) {
                        convert = charge * 0.000000001;
                    } else if (c_unit_index == 3) {
                        convert = charge * 0.000001;
                    } else if (c_unit_index == 4) {
                        convert = charge * 0.001;
                    } else if (c_unit_index == 5) {
                        convert = charge * 1;
                    } else if (c_unit_index == 6) {
                        convert = charge * 1.60218e-19;
                    } else {
                        param['error'] = 'Invalid charge unit';
                        return param;
                    }
                    
                    const distance_formula = (((8.9875517923e9 * convert) / (field)) / (per));
                    const sqrt = Math.sqrt(distance_formula);
                    param['tech_answer1'] = sqrt;
                    return param;
                } else if (selection3 == "3") {
                    if (d_unit_index == 1) {
                        convert2 = distance * 0.000000001;
                    } else if (d_unit_index == 2) {
                        convert2 = distance * 0.000001;
                    } else if (d_unit_index == 3) {
                        convert2 = distance * 0.001;
                    } else if (d_unit_index == 4) {
                        convert2 = distance * 0.01;
                    } else if (d_unit_index == 5) {
                        convert2 = distance * 1;
                    } else if (d_unit_index == 6) {
                        convert2 = distance * 1000;
                    } else if (d_unit_index == 7) {
                        convert2 = distance * 0.0254;
                    } else if (d_unit_index == 8) {
                        convert2 = distance * 0.3048;
                    } else if (d_unit_index == 9) {
                        convert2 = distance * 0.9144;
                    } else if (d_unit_index == 10) {
                        convert2 = distance * 1609.3;
                    } else {
                        param['error'] = 'Invalid distance unit';
                        return param;
                    }
                    
                    const charge_formula = (((field) * (convert2 * convert2) / (8.9875517923e9)) / (per));
                    param['tech_answer2'] = charge_formula;
                    return param;
                }
            }
        } else {
            param['error'] = 'Please! Check Your Input';
            return param;
        }

        if (selection == "2") {
            let formula2 = 0;
            let i = 0;
            const c1 = charge1.length;
            const d1 = distance1.length;
            

            // Calculate formula2 from arrays
            while (i < c1 && i < d1) {
                const chargeVal = parseFloat(charge1[i]);
                const distanceVal = parseFloat(distance1[i]);
                
                console.log(`Processing index ${i}: charge=${chargeVal}, distance=${distanceVal}`);
                
                if (!isNaN(chargeVal) && !isNaN(distanceVal) && chargeVal > 0 && distanceVal > 0) {
                    const value1 = chargeVal;
                    const value2 = charge_unit[i];
                    const value2_index = c_unit_name.indexOf(value2) + 1;
                    
                    
                    let con;
                    if (value2_index == 1) {
                        con = value1 * 0.000001;
                    } else if (value2_index == 2) {
                        con = value1 * 0.000000001;
                    } else if (value2_index == 3) {
                        con = value1 * 0.000001;
                    } else if (value2_index == 4) {
                        con = value1 * 0.001;
                    } else if (value2_index == 5) {
                        con = value1 * 1;
                    } else if (value2_index == 6) {
                        con = value1 * 1.60218e-19;
                    } else {
                        console.log(`Invalid charge unit: ${value2}`);
                        param['error'] = `Invalid charge unit: ${value2}`;
                        return param;
                    }
                    
                    const value3 = distanceVal;
                    const value4 = distance_unit[i];
                    const value4_index = d_unit_name.indexOf(value4) + 1;
                    
                    
                    let con2;
                    if (value4_index == 1) {
                        con2 = value3 * 0.000000001;
                    } else if (value4_index == 2) {
                        con2 = value3 * 0.000001;
                    } else if (value4_index == 3) {
                        con2 = value3 * 0.001;
                    } else if (value4_index == 4) {
                        con2 = value3 * 0.01;
                    } else if (value4_index == 5) {
                        con2 = value3 * 1;
                    } else if (value4_index == 6) {
                        con2 = value3 * 1000;
                    } else if (value4_index == 7) {
                        con2 = value3 * 0.0254;
                    } else if (value4_index == 8) {
                        con2 = value3 * 0.3048;
                    } else if (value4_index == 9) {
                        con2 = value3 * 0.9144;
                    } else if (value4_index == 10) {
                        con2 = value3 * 1609.3;
                    } else {
                        console.log(`Invalid distance unit: ${value4}`);
                        param['error'] = `Invalid distance unit: ${value4}`;
                        return param;
                    }
                    
                    
                    const partial = (8.9875517923e9 * con) / (con2 * con2);
                    
                    formula2 = formula2 + partial;
                    i++;
                } else {
                    param['error'] = 'Please! Check Your Input in array values';
                    return param;
                }
            }
            

            // Calculate main charge and distance
            if (!isNaN(charge) && !isNaN(distance) && !isNaN(per) && charge > 0 && distance > 0 && per > 0) {
                if (c_unit_index == 1) {
                    convert = charge * 0.000001;
                } else if (c_unit_index == 2) {
                    convert = charge * 0.000000001;
                } else if (c_unit_index == 3) {
                    convert = charge * 0.000001;
                } else if (c_unit_index == 4) {
                    convert = charge * 0.001;
                } else if (c_unit_index == 5) {
                    convert = charge * 1;
                } else if (c_unit_index == 6) {
                    convert = charge * 1.60218e-19;
                } else {
                    param['error'] = 'Invalid main charge unit';
                    return param;
                }
                
                if (d_unit_index == 1) {
                    convert2 = distance * 0.000000001;
                } else if (d_unit_index == 2) {
                    convert2 = distance * 0.000001;
                } else if (d_unit_index == 3) {
                    convert2 = distance * 0.001;
                } else if (d_unit_index == 4) {
                    convert2 = distance * 0.01;
                } else if (d_unit_index == 5) {
                    convert2 = distance * 1;
                } else if (d_unit_index == 6) {
                    convert2 = distance * 1000;
                } else if (d_unit_index == 7) {
                    convert2 = distance * 0.0254;
                } else if (d_unit_index == 8) {
                    convert2 = distance * 0.3048;
                } else if (d_unit_index == 9) {
                    convert2 = distance * 0.9144;
                } else if (d_unit_index == 10) {
                    convert2 = distance * 1609.3;
                } else {
                    param['error'] = 'Invalid main distance unit';
                    return param;
                }
            } else {
                param['error'] = 'Please! Check Your main Input';
                return param;
            }
            
            
            const mainField = (8.9875517923e9 * convert) / (convert2 * convert2) / (per);
            const field2 = mainField + formula2;
            param['tech_answer3'] = field2;
            return param;
        }
        
        param['error'] = 'Please! Check Your Input';
        return param;
    }

        /**
    * getCalculationelMomentOfInertiaCalculator: Service Method
    * POST: /api/calculators-lol/moment-of-inertia-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

      async getCalculationelMomentOfInertiaCalculator(body) {
        const param = {};
        
        const selection = body.tech_selection;
        const b_width = parseFloat(body.tech_b_width);
        const height = parseFloat(body.tech_height);
        const dis_to_height = parseFloat(body.tech_dis_to_height);
        const rad = parseFloat(body.tech_radius);
        const tfw = parseFloat(body.tech_tfw);
        const tft = parseFloat(body.tech_tft);
        const bfw = parseFloat(body.tech_bfw);
        const bft = parseFloat(body.tech_bft);
        const wh = parseFloat(body.tech_wh);
        const wt = parseFloat(body.tech_wt);
        const r = parseFloat(body.tech_r);
        const h1 = parseFloat(body.tech_h1);
        const b1 = parseFloat(body.tech_b1);
        const lft = parseFloat(body.tech_lft);
        const lfh = parseFloat(body.tech_lfh);
        const rad2 = parseFloat(body.tech_radius2);
        const unit = body.tech_unit;

        param['m2'] = `${unit}<sup>2</sup>`;
        param['m4'] = `${unit}<sup>4</sup>`;
        param['m'] = `${unit}`;
        param['m3'] = `${unit}<sup>3</sup>`;

        if (!isNaN(b_width) && !isNaN(height) && !isNaN(dis_to_height) && (b_width > 0) && (height > 0) && (dis_to_height > 0)) {
            if (selection == "1") {
                //Triangle
                const calculate_ix = ((b_width) * (height * height * height) / (36));
                const calculate_iy = ((height) * (b_width * b_width * b_width) - (height * dis_to_height * (b_width * b_width)) + (b_width * height * (dis_to_height * dis_to_height)) / (36));
                const calculate_area = (b_width * height) / 2;
                const elastic_section_modulus1 = (b_width * height * height) / 24;
                const elastic_section_modulus2 = (b_width * b_width * b_width) / 24;
                const calculate_cy = (height) / 3;
                const calculate_cx = (height) / 2;
                 
                param['tech_answer1'] = isNaN(calculate_ix) ? 'NaN' : calculate_ix;
                param['tech_answer2'] = isNaN(calculate_iy) ? 'NaN' : calculate_iy;
                param['tech_answer3'] = isNaN(calculate_cy) ? 'NaN' : calculate_cy;
                param['tech_answer4'] = isNaN(calculate_cx) ? 'NaN' : calculate_cx;
                param['tech_answer5'] = isNaN(calculate_area) ? 'NaN' : calculate_area;
                param['tech_answer6'] = isNaN(elastic_section_modulus1) ? 'NaN' : elastic_section_modulus1;
                param['tech_answer7'] = isNaN(elastic_section_modulus1) ? 'NaN' : elastic_section_modulus1;
                return param;
            }
        } else {
            param['error'] = 'Please fill all fields.';
            return param;
        }

        if (!isNaN(b_width) && !isNaN(height) && (b_width > 0) && (height > 0)) {
            if (selection == "2") {
                //Rectangle
                const calculate_ix = (b_width * height * height * height) / 12;
                const calculate_iy = (height * b_width * b_width * b_width) / 12;
                const calculate_cy = (height) / 2;
                const calculate_cx = (b_width) / 2;
                const calculate_area = (b_width * height);
                const elastic_section_modulus1 = calculate_ix / calculate_cy;
                const elastic_section_modulus2 = calculate_iy / calculate_cx;
                const jc = (1 / 12 * (b_width * height)) * (b_width * b_width) + (height * height);
                
                param['tech_answer1'] = isNaN(calculate_ix) ? 'NaN' : calculate_ix;
                param['tech_answer2'] = isNaN(calculate_iy) ? 'NaN' : calculate_iy;
                param['tech_answer3'] = isNaN(calculate_cy) ? 'NaN' : calculate_cy;
                param['tech_answer4'] = isNaN(calculate_cx) ? 'NaN' : calculate_cx;
                param['tech_answer5'] = isNaN(calculate_area) ? 'NaN' : calculate_area;
                param['tech_answer6'] = isNaN(elastic_section_modulus1) ? 'NaN' : elastic_section_modulus1;
                param['tech_answer7'] = isNaN(elastic_section_modulus2) ? 'NaN' : elastic_section_modulus2;
                
                return param;
            }
        } else {
            param['error'] = 'Please fill all fields.';
            return param;
        }

        if (!isNaN(rad) && !isNaN(rad2) && (rad > 0) && (rad2 > 0)) {
            if (selection == "3") {
                if (rad > rad2) {
                    const calculate_ix = ((Math.PI / 64) * (rad * rad * rad * rad)) - ((Math.PI / 64) * (rad2 * rad2 * rad2 * rad2));
                    const calculate_iy = ((Math.PI / 64) * (rad * rad * rad * rad)) - ((Math.PI / 64) * (rad2 * rad2 * rad2 * rad2));
                    const d1 = rad / 2;
                    const d2 = rad2 / 2;
                    const calculate_area = ((d1 * d1) - (d2 * d2)) * Math.PI;
                    const calculate_cy = (rad / 2);
                    const calculate_cx = (rad / 2);
                    const elastic_section_modulus1 = (calculate_ix / calculate_cy);
                    const elastic_section_modulus2 = (calculate_iy / calculate_cx);
                    param['tech_answer1'] = isNaN(calculate_ix) ? 'NaN' : calculate_ix;
                    param['tech_answer2'] = isNaN(calculate_iy) ? 'NaN' : calculate_iy;
                    param['tech_answer3'] = isNaN(calculate_cy) ? 'NaN' : calculate_cy;
                    param['tech_answer4'] = isNaN(calculate_cx) ? 'NaN' : calculate_cx;
                    param['tech_answer5'] = isNaN(calculate_area) ? 'NaN' : calculate_area;
                    param['tech_answer6'] = isNaN(elastic_section_modulus1) ? 'NaN' : elastic_section_modulus1;
                    param['tech_answer7'] = isNaN(elastic_section_modulus2) ? 'NaN' : elastic_section_modulus2;
                    return param;
                } else {
                    param['error'] = 'D must be larger than d';
                    return param;
                }
            }
        } else {
            param['error'] = 'Please fill all fields.';
            return param;
        }

        if (!isNaN(rad)) {
            if (selection == "4") {
                //Circle
                const calculate_ix = (Math.PI / 64) * rad * rad * rad * rad;
                const calculate_iy = (Math.PI / 64) * rad * rad * rad * rad;
                const calculate_area = (Math.PI * rad * rad) / 4;
                const calculate_cy = (rad) / 2;
                const calculate_cx = (rad) / 2;
                const elastic_section_modulus1 = (calculate_ix / calculate_cy);
                const elastic_section_modulus2 = (calculate_iy / calculate_cx);
                
                  param['tech_answer1'] = isNaN(calculate_ix) ? 'NaN' : calculate_ix;
                param['tech_answer2'] = isNaN(calculate_iy) ? 'NaN' : calculate_iy;
                param['tech_answer3'] = isNaN(calculate_cy) ? 'NaN' : calculate_cy;
                param['tech_answer4'] = isNaN(calculate_cx) ? 'NaN' : calculate_cx;
                param['tech_answer5'] = isNaN(calculate_area) ? 'NaN' : calculate_area;
                param['tech_answer6'] = isNaN(elastic_section_modulus1) ? 'NaN' : elastic_section_modulus1;
                param['tech_answer7'] = isNaN(elastic_section_modulus2) ? 'NaN' : elastic_section_modulus2;
                return param;
            }
        } else {
            param['error'] = 'Please fill all fields.';
            return param;
        }

        if (!isNaN(b_width) && !isNaN(height) && !isNaN(h1) && !isNaN(b1) && (b_width) > 0 && (height) > 0 && (h1) > 0 && b1 > 0) {
            if (selection == "7") {
                if (b_width > h1 && height > b1) {
                    //Hollow Rectangular
                    const calculate_area = (b_width * height) - (h1 * b1);
                    const calculate_ix = ((b_width * height * height * height) / 12) - ((b1 * h1 * h1 * h1) / 12);
                    const calculate_iy = ((b_width * b_width * b_width * height) / 12) - ((b1 * b1 * b1 * h1) / 12);
                    const calculate_cy = (b_width) / 2;
                    const calculate_cx = (height) / 2;
                    const section_modulus1 = (calculate_ix / calculate_cx);
                    const section_modulus2 = (calculate_iy / calculate_cy);
                    
                    param['tech_answer1'] = isNaN(calculate_ix) ? 'NaN' : calculate_ix;
                    param['tech_answer2'] = isNaN(calculate_iy) ? 'NaN' : calculate_iy;
                    param['tech_answer3'] = isNaN(calculate_cy) ? 'NaN' : calculate_cy;
                    param['tech_answer4'] = isNaN(calculate_cx) ? 'NaN' : calculate_cx;
                    param['tech_answer5'] = isNaN(calculate_area) ? 'NaN' : calculate_area;
                    param['tech_answer6'] = isNaN(section_modulus1) ? 'NaN' : section_modulus1;
                    param['tech_answer7'] = isNaN(section_modulus2) ? 'NaN' : section_modulus2;
                    
                    return param;
                } else {
                    param['error'] = 'h1 must be larger than h and b must be larger than b1';
                    return param;
                }
            }
        } else {
            param['error'] = 'Please fill all fields.';
            return param;
        }

        if (!isNaN(bfw) && !isNaN(bft) && !isNaN(tft) && !isNaN(tfw) && !isNaN(wt) && !isNaN(wh) && bfw > 0 && bft > 0 && tft > 0 && tfw > 0 && wh > 0 && wt > 0) {
            if (selection == "8") {  
                //I-Beam
                let x3,x2;
                const a1 = (bfw * bft);
                const a2 = (wt * wh);
                const a3 = (tfw * tft);
                const total_area = a1 + a2 + a3;
                const x1 = x2 = x3 = tfw;
                const y1 = (bft / 2);
                const y2 = bft + (wh / 2);
                const y3 = bft + wh + (tft / 2);
                const y_dash = ((a1 * y1) + (a2 * y2) + (a3 * y3)) / (a1 + a2 + a3);
                const x_dash = tfw;
                const hy1 = y_dash - y1;
                const xx1 = (((bfw * bft * bft * bft) / 12)) + ((a1) * (hy1 * hy1));
                const hy2 = y_dash - y2;
                const xx2 = (((wt * wh * wh * wh) / 12)) + ((a2) * (hy2 * hy2));
                const hy3 = y_dash - y3;
                const xx3 = (((tfw * tft * tft * tft) / 12)) + ((a3) * (hy3 * hy3));
                const total_x = xx1 + xx2 + xx3;
                const hx1 = x_dash - x1;
                const hx2 = x_dash - x2;
                const hx3 = x_dash - x3;
                const ans1 = (bfw * bfw * bfw * bft) / 12;
                const ans2 = (wt * wt * wt * wh) / 12;
                const ans3 = (tfw * tfw * tfw * tft) / 12;
                const ans_y = ans1 + ans2 + ans3;
                const section_modulus1 = (total_x / y_dash);
                const section_modulus2 = (ans_y / x_dash);
                
                 param['tech_answer1'] = isNaN(total_x) ? 'NaN' : total_x;
                param['tech_answer2'] = isNaN(ans_y) ? 'NaN' : ans_y;
                param['tech_answer3'] = isNaN(y_dash) ? 'NaN' : y_dash;
                param['tech_answer4'] = isNaN(x_dash) ? 'NaN' : x_dash;
                param['tech_answer5'] = isNaN(total_area) ? 'NaN' : total_area;
                param['tech_answer6'] = isNaN(section_modulus1) ? 'NaN' : section_modulus1;
                param['tech_answer7'] = isNaN(section_modulus2) ? 'NaN' : section_modulus2;
                return param;
            }
        } else {
            param['error'] = 'Please fill all fields.';
            return param;
        }

        if (!isNaN(bfw) && !isNaN(bft) && !isNaN(lfh) && !isNaN(lft) && bfw > 0 && bft > 0 && lfh > 0 && lft > 0) {
            if (selection == "9") {
                //L-Beam
                const a1 = (bfw * bft);
                const a2 = (lfh * lft);
                const total_area = a1 + a2;
                const x1 = (bfw / 2);
                const x2 = (bft / 2);
                const y1 = (lft / 2);
                const y2 = (lft + (lfh / 2));
                const x_dash = ((a1 * x1) + (a2 * x2)) / (a1 + a2);
                const y_dash = ((a1 * y1) + (a2 * y2)) / (a1 + a2);
                const hy1 = y_dash - y1;
                const xx1 = ((bfw * bft * bft * bft) / 12) + (a1) * (hy1 * hy1);
                const hy2 = y_dash - y2;
                const xx2 = ((lft * lfh * lfh * lfh) / 12) + (a2) * (hy2 * hy2);
                const xxx = xx1 + xx2;
                const hx1 = x_dash - x1;
                const yy1 = ((bft * bfw * bfw * bfw) / 12) + (a1) * (hx1 * hx1);
                const hx2 = x_dash - x2;
                const yy2 = ((lfh * lft * lft * lft) / 12) + ((a2) * (hx2 * hx2));
                const yyy = yy1 + yy2;
                const section_modulus1 = xxx / y_dash;
                const section_modulus2 = yyy / x_dash;
                
                 param['tech_answer1'] = isNaN(xxx) ? 'NaN' : xxx;
                param['tech_answer2'] = isNaN(yyy) ? 'NaN' : yyy;
                param['tech_answer3'] = isNaN(y_dash) ? 'NaN' : y_dash;
                param['tech_answer4'] = isNaN(x_dash) ? 'NaN' : x_dash;
                param['tech_answer5'] = isNaN(total_area) ? 'NaN' : total_area;
                param['tech_answer6'] = isNaN(section_modulus1) ? 'NaN' : section_modulus1;
                param['tech_answer7'] = isNaN(section_modulus2) ? 'NaN' : section_modulus2;
                return param;
            }
        } else {
            param['error'] = 'Please fill all fields.';
            return param;
        }

        if (!isNaN(tfw) && !isNaN(tft) && !isNaN(wh) && !isNaN(wt) && tfw > 0 && tft > 0 && wh > 0 && wh > 0) {
            if (selection == "10") {
                //T-Beam
                const a1 = tft * tfw;
                const a2 = wh * wt;
                const area = a1 + a2;
                const y1 = tfw + (tft / 2);
                const y2 = (wh / 2);
                var x_bar = (wh / 2);
                const x1 = (tfw / 2);
                const x2 = (tfw / 2);
                var x_bar = ((a1 * x1) + (a2 * x2)) / (a1 + a2);
                const y_bar = ((a1 * y1) + (a2 * y2)) / (a1 + a2);
                const xx1 = ((tfw * tft * tft * tft) / 12) + a1 * ((y_bar - y1) * (y_bar - y1));
                const h2 = y_bar - y2;
                const xx2 = ((wh * wh * wh * wt) / 12) + a2 * (h2 * h2);
                const xxx = xx1 + xx2;
                const hx1 = x_bar - x1;
                const yy1 = ((wh * wh * wh * wt) / 12) + a1 * (hx1 - hx1);
                const hx2 = x_bar - x2;
                const yy2 = ((wh * wt * wt * wt) / 12) + a2 * (hx2 - hx2);
                const yyy = yy1 + yy2;
                
                param['tech_answer1'] = isNaN(xxx) ? 'NaN' : xxx;
                param['tech_answer2'] = isNaN(yyy) ? 'NaN' : yyy;
                param['tech_answer3'] = isNaN(y_bar) ? 'NaN' : y_bar;
                param['tech_answer4'] = isNaN(x_bar) ? 'NaN' : x_bar;
                param['tech_answer5'] = isNaN(area) ? 'NaN' : area;
                param['tech_answer6'] = isNaN(xxx / y_bar) ? 'NaN' : xxx / y_bar;
                param['tech_answer7'] = isNaN(yyy / x_bar) ? 'NaN' : yyy / x_bar;
                
                return param;
            }
        } else {
            param['error'] = 'Please fill all fields.';
            return param;
        }

        if (!isNaN(bfw) && !isNaN(bft) && !isNaN(tfw) && !isNaN(tft) && !isNaN(wt) && !isNaN(h1) && bfw > 0 && bft > 0 && tfw > 0 && tft > 0 && tfw > 0 && wt > 0 && h1 > 0) {
            if (selection == "11") {
                //Channel
                const a1 = (bfw * bft);
                const a2 = (wt * h1);
                const a3 = (tfw * tft);
                const total_area = a1 + a2 + a3;
                const x1 = (bfw / 2);
                const x2 = (wt / 2);
                const x3 = (tfw) / 2;
                const x_dash = ((a1 * x1) + (a2 * x2) + (a3 * x3)) / ((a1 + a2 + a3));
                const y1 = (bft / 2);
                const y2 = (bft + (h1 / 2));
                const y3 = (bft + h1 + (wt / 2));
                const y_dash = ((a1 * y1) + (a2 * y2) + (a3 * y3)) / ((a1 + a2 + a3));
                const hy1 = y_dash - y1;
                const xx1 = ((bfw * bft * bft * bft) / 12) + (a1 * (hy1 * hy1));
                const hy2 = y_dash - y2;
                const xx2 = ((wt * h1 * h1 * h1) / 12) + (a2 * (hy2 * hy2));
                const hy3 = y_dash - y3;
                const xx3 = ((tfw * tft * tft * tft) / 12) + (a3 * (hy3 * hy3));
                const calculate_ix = xx1 + xx2 + xx3;
                const hx1 = x_dash - x1;
                const yy1 = ((bft * bfw * bfw * bfw) / 12) + (a1 * (hx1 * hx1));
                const hx2 = x_dash - x2;
                const yy2 = ((wt * wt * wt * h1) / 12) + (a2 * (hx2 * hx2));
                const hx3 = x_dash - x3;
                const yy3 = ((tfw * tfw * tfw * tft) / 12) + (a3 * (hx3 * hx3));
                const yyy = yy1 + yy2 + yy3;
                
                param['tech_answer1'] = isNaN(calculate_ix) ? 'NaN' : calculate_ix;
                param['tech_answer2'] = isNaN(yyy) ? 'NaN' : yyy;
                param['tech_answer3'] = isNaN(y_dash) ? 'NaN' : y_dash;
                param['tech_answer4'] = isNaN(x_dash) ? 'NaN' : x_dash;
                param['tech_answer5'] = isNaN(total_area) ? 'NaN' : total_area;
                param['tech_answer6'] = isNaN(calculate_ix / y_dash) ? 'NaN' : calculate_ix / y_dash;
                param['tech_answer7'] = isNaN(yyy / x_dash) ? 'NaN' : yyy / x_dash;
                
                return param;
            }
        } else {
            param['error'] = 'Please fill all fields.';
            return param;
        }

        param['error'] = 'Please fill all fields.';
        return param;
    }

       /**
    * getCalculationelFreeFallCalculator: Service Method
    * POST: /api/calculators-lol/free-fall-calculator
    * @param {Object} body Having Properties for Creating New Roles
    * @returns Object with message property having success method
    */

      async getCalculationelFreeFallCalculator(body) {
      }




}

module.exports = new CalculatorsServices();

const { Op, col } = require("sequelize");
const db = require("../../models");
const HttpCodes = require("http-codes");
const { ApiError } = require("../../middlewares/ApiError");
const dayjs = require("dayjs");
const isoWeek = require("dayjs/plugin/isoWeek");
const dayOfYear = require("dayjs/plugin/dayOfYear");
const isLeapYear = require("dayjs/plugin/isLeapYear");

dayjs.extend(isoWeek);
dayjs.extend(dayOfYear);
dayjs.extend(isLeapYear);

const moment = require("moment");
const customParseFormat = require("dayjs/plugin/customParseFormat");
const duration = require("dayjs/plugin/duration");
dayjs.extend(customParseFormat);
dayjs.extend(duration);
const sprintf = require("sprintf-js").sprintf;

const isSameOrBefore = require("dayjs/plugin/isSameOrBefore");
dayjs.extend(isSameOrBefore);

const weekday = require("dayjs/plugin/weekday");
dayjs.extend(weekday);

const weekOfYear = require("dayjs/plugin/weekOfYear");
dayjs.extend(weekOfYear);

const advancedFormat = require("dayjs/plugin/advancedFormat");
dayjs.extend(advancedFormat);

require("moment-duration-format");

require("moment-precise-range-plugin");
const math = require('mathjs');
const momentBase = require("moment");
const axios = require("axios");
const qs = require("qs");
const { factorial } = require('mathjs'); // Ensure mathjs is installed
const { DateTime } = require("luxon"); // use luxon or native Date for date handling
// class AgeCalculator {
//   constructor() {
//     this.age = 0;
//   }
//     calculateAge(timestamp) {
//       const birthDate = new Date(timestamp);
//       const today = new Date();

//       let age = today.getFullYear() - birthDate.getFullYear();
//       const monthDiff = today.getMonth() - birthDate.getMonth();
//       const dayDiff = today.getDate() - birthDate.getDate();

//       if (monthDiff < 0 || (monthDiff === 0 && dayDiff < 0)) {
//         age--;
//       }

//       this.age = age;
//     }

//     getAge() {
//       return this.age;
//     }

//     getRank(age) {
//       return age + 1; // Simulating the get_rank logic
//     }

//   }

class AgeCalculator {
  constructor() {
    this.age = 0;
  }

  calculateAge(timestamp) {
    const birthDate = new Date(timestamp);
    const today = new Date();

    let age = today.getFullYear() - birthDate.getFullYear();
    const monthDiff = today.getMonth() - birthDate.getMonth();
    const dayDiff = today.getDate() - birthDate.getDate();

    if (monthDiff < 0 || (monthDiff === 0 && dayDiff < 0)) {
      age--;
    }

    this.age = age;
  }

  getAge() {
    return this.age;
  }

  getRank(age) {
    return age + 1; // Example rank logic
  }
}

class CalculatorsServices {
  /**
   * getCalulationOfDaysAgoCalculator: Service Method
   * POST: /api/calculators-lol/days-ago-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationOfDaysAgoCalculator(body) {
    const elapsedNumber = parseInt(body.elapsedNumber);
    const referenceDate = body.referenceDate;

    if (isNaN(elapsedNumber)) {
      return { error: "Please add Number of Weeks" };
    }

    let date = dayjs(referenceDate);
    let targetDate;

    if (elapsedNumber <= -1 || elapsedNumber === 0) {
      targetDate = date.add(Math.abs(elapsedNumber), "day");
    } else if (elapsedNumber >= 1) {
      targetDate = date.subtract(elapsedNumber, "day");
    }

    const isLeap = targetDate.isLeapYear();
    const daysInYear = isLeap ? 366 : 365;
    const weeksInYear = 52;
    const currentWeekOfYear = targetDate.isoWeek();
    const currentDayOfYear = targetDate.dayOfYear();

    return {
      dayName: targetDate.format("dddd"),
      formattedDate: targetDate.format("MMMM D, YYYY"),
      totalDaysInYear: daysInYear,
      totalWeeksInYear: weeksInYear,
      weekOfYear: currentWeekOfYear,
      dayOfYear: currentDayOfYear,
    };
  }

  /**
   * getCalculationCatAgeCalculator: Service Method
   * POST: /api/calculators-lol/cat-age-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCatAgeCalculator(body) {
    const petYear = parseFloat(body.tech_Year);
    const petMonth = parseFloat(body.tech_Month);
    const conversionMethod = parseInt(body.tech_Method);
    // return [petYear , petMonth];
    let response = {};

    if (!isNaN(petYear) || !isNaN(petMonth)) {
      let age = 0;

      if (!isNaN(petYear)) {
        age = petYear;
      }

      if (!isNaN(petMonth) && petMonth !== 0) {
        age += petMonth / 12;
      }

      let ans;

      if (conversionMethod === 1) {
        // Human → Cat age conversion
        if (age >= 6) {
          ans = Math.round(40 + 4 * (age - 6));
        } else {
          ans = Math.round(6.6666 * age + 0.066666667);
        }
      } else if (conversionMethod === 2) {
        // Cat → Human age conversion
        if (age >= 40) {
          ans = Math.round(0.25 * age - 4);
        } else {
          ans = Math.round((age - 0.066666667) / 6.6666);
        }
      }

      response = {
        success: true,
        tech_ans: ans,
      };
    } else {
      response = {
        error: "Please! Check Your Inputs",
      };
    }

    return response;
  }

  /**
   * getCalculationSquareInchesCalculator: Service Method
   * POST: /api/calculators-lol/square-inches-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSquareInchesCalculator(body) {
    const dimensionLength = parseFloat(body.dimensionLength) || 0;
    const dimensionLengthUnit = body.dimensionLengthUnit?.trim() || "in";
    const dimensionWidth = parseFloat(body.dimensionWidth) || 0;
    const dimensionWidthUnit = body.dimensionWidthUnit?.trim() || "in";
    const costPerUnit = parseFloat(body.costPerUnit) || 0;

    const convertToInches = (value, unit) => {
      switch (unit) {
        case "ft":
          return value * 12;
        case "in":
          return value;
        case "yd":
          return value * 36;
        case "cm":
          return value / 2.54;
        case "m":
          return value * 39.37;
        case "mi":
          return value * 63360; // corrected!
        case "km":
          return value * 39370;
        default:
          return 0;
      }
    };

    const convertedLength = convertToInches(
      dimensionLength,
      dimensionLengthUnit
    );
    const convertedWidth = convertToInches(dimensionWidth, dimensionWidthUnit);
    const squareInches = convertedLength * convertedWidth;

    const response = {
      status: 1,
      areaInSquareInches: squareInches,
      calculatedCost: squareInches * costPerUnit,
    };

    return response;
  }

  /**
   * getCalculationClassWidthCalculator: Service Method
   * POST: /api/calculators-lol/class-width-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationClassWidthCalculator(body) {
    const lowerBound = parseFloat(body.tech_lowerBound?.toString().trim()); // Changed from "minimum"
    const upperBound = parseFloat(body.tech_upperBound?.toString().trim()); // Changed from "maximum"
    const totalParts = parseFloat(body.tech_totalParts?.toString().trim()); // Changed from "number"

    const response = {};

    if (!isNaN(lowerBound) && !isNaN(upperBound) && !isNaN(totalParts)) {
      if (lowerBound < upperBound) {
        const width = (upperBound - lowerBound) / totalParts;
        const answer = Math.abs(width);

        response.tech_answer = answer;
        response.tech_lowerBound = lowerBound;
        response.tech_upperBound = upperBound;
        response.tech_totalParts = totalParts;
      } else {
        response.error =
          "The upper bound value must be greater than the lower bound value.";
      }
    } else {
      response.error = "Please! Check Your Input";
    }

    return response;
  }

  /**
   * getCalculationBondOrderCalculator: Service Method
   * POST: /api/calculators-lol/bond-order-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationBondOrderCalculator(body) {
    const calculationType = body.tech_calculationType;
    const firstInput = parseFloat(body.tech_firstInput);
    const secondInput = parseFloat(body.tech_secondInput);

    let response = {};

    if (!isNaN(firstInput) && !isNaN(secondInput)) {
      let result;

      if (calculationType === "1") {
        result = 0.5 * (firstInput - secondInput);
      } else if (calculationType === "2") {
        result = 2 * firstInput + secondInput;
      } else {
        result = (firstInput * 2 - secondInput) * -1;
      }

      response = {
        tech_calculatedAnswer: result,
        tech_firstInput: firstInput,
        tech_secondInput: secondInput,
      };
    } else {
      response = {
        error: "Please! Check Your Input.",
      };
    }

    return response;
  }

  /**
   * getCalculationWavePeriodCalculator: Service Method
   * POST: /api/calculators-lol/wave-period-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationWavePeriodCalculator(body) {
    const calculationType = body.calculationType; // sim_adv
    const frequencyValue = parseFloat(body.frequency); // frequency
    const frequencyInSeconds = parseFloat(body.frequencyInSeconds); // frequency_sec
    const waveLength = parseFloat(body.waveLength); // wavelength
    const waveSpeed = parseFloat(body.waveSpeed); // wave_speed

    let response = {};

    if (calculationType === "simple") {
      if (!isNaN(frequencyValue)) {
        if (frequencyValue > 0) {
          const wavePeriod = 1 / frequencyValue;
          response.wavePeriod = wavePeriod;
          response.calculationType = calculationType;
        } else {
          response.error = "Frequency must be greater than zero.";
        }
      } else {
        response.error = "Please! Check Your Input.";
      }
    } else if (calculationType === "advanced") {
      if (!isNaN(waveLength) && !isNaN(waveSpeed)) {
        const wavePeriod = waveLength / waveSpeed;
        response.wavePeriod = wavePeriod;
        response.calculationType = calculationType;
      } else {
        response.error = "Please! Check Your Input.";
      }
    }

    return response;
  }

  /**
   * getCalculationwaterBillCalculator: Service Method
   * POST: /api/calculators-lol/water-bill-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationwaterBillCalculator(body) {
    // Extract water rate and gallon usage from the body
    const waterRate = parseFloat(body.waterRate); // Renaming $water to waterRate
    const gallonUsage = parseFloat(body.gallonUsage); // Renaming $gallon to gallonUsage

    // Initialize an object to hold the response
    let result = {};

    // Check if both water rate and gallon usage are valid numbers
    if (!isNaN(waterRate) && !isNaN(gallonUsage)) {
      // Calculate the bill
      const billAmount = waterRate * gallonUsage;
      // Prepare the response with the calculated bill

      result.totalBill = billAmount; // Renamed 'bill' to 'totalBill'

      result.status = 1; // Renamed 'RESULT' to 'status'
    } else {
      // If inputs are not valid, add an error message to the response
      result.error = "Please! Check Your Input";
    }

    // Return the result object
    return result;
  }

  /**
   * getCalculationLoveCalculator: Service Method
   * POST: /api/calculators-lol/love-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationLoveCalculator(body) {
    // Extracting names from the body
    const yourName = body.yourName; // Renaming 'you' to 'yourName'
    const partnerName = body.partnerName; // Renaming 'lover' to 'partnerName'

    // Initialize an object to store the response
    let result = {};

    // Check if both names are provided
    if (!yourName || !partnerName) {
      // Handle missing names with appropriate messages
      if (!yourName && !partnerName) {
        result.error =
          "Both your name and your partner's name are required to proceed.";
      } else if (!yourName) {
        result.error = "Your name is necessary to calculate the love score.";
      } else {
        result.error =
          "Your partner's name is required to calculate the love score.";
      }
      return result;
    }

    // Generate a random love score between 20 and 100
    const loveScore = Math.floor(Math.random() * (100 - 20 + 1)) + 20; // Changed from 'rand' to 'Math.random()'

    // Add the result to the response object
    result.loveScore = loveScore; // Changed 'RESULT' to 'loveScore'
    return result;
  }

  /**
   * getCalculationPercentErrorCalculator: Service Method
   * POST: /api/calculators-lol/percent-error-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPercentErrorCalculator(body) {
    // Extract values from the body
    const actualValue = parseFloat(body.actualValue); // Renaming 'av' to 'actualValue'
    const originalValue = parseFloat(body.originalValue); // Renaming 'ov' to 'originalValue'

    // Initialize an object to hold the response
    let result = {};

    // Check if both values are valid numbers
    if (!isNaN(originalValue) && !isNaN(actualValue)) {
      // Calculate the percent error
      const percentError = ((originalValue - actualValue) / actualValue) * 100;
      console.log(percentError);
      // Round the result to two decimal places
      result.errorPercentage = percentError.toFixed(2); // Renaming 'own_error' to match the original logic
      result.status = 1;
    } else {
      // If either value is not a valid number, set an error message
      result.error = "Please Check Your Input.";
    }

    // Return the result object
    return result;
  }

  /**
   * getCalculationBenchPressCalculator: Service Method
   * POST: /api/calculators-lol/bench-press-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBenchPressCalculator(body) {
    // Extract and sanitize inputs from body
    const inputWeight = parseFloat(body.inputWeight?.toString().trim());
    const unitType = body.unitType?.toString().trim();
    const repetitions = parseInt(body.repetitions?.toString().trim(), 10);
    const conversionTable = body.conversionTable?.toString().trim(); // If needed later

    let response = {};

    let weightInPounds = inputWeight;

    // Convert input weight to pounds if necessary
    if (unitType === "kg") {
      weightInPounds = inputWeight * 2.20462;
    } else if (unitType === "stone") {
      weightInPounds = inputWeight * 14;
    }

    // Calculate the one-rep max using standard formula
    let estimatedMax = weightInPounds * (1 + repetitions / 30);

    // Convert the result back to original unit
    if (unitType === "kg") {
      estimatedMax = estimatedMax / 2.20462;
    } else if (unitType === "stone") {
      estimatedMax = estimatedMax / 14;
    }

    // Build response
    response.maxLiftEstimate = estimatedMax;
    response.status = 1;

    return response;
  }

  /**
   * getCalculationDogPregnancyCalculator: Service Method
   * POST: /api/calculators-lol/dog-pregnancy-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDogPregnancyCalculator(body) {
    const e_date = body.tech_e_date; // format: YYYY-MM-DD

    const din = 63;
    const startDate = new Date(e_date);

    // Step 1: Main due date after 63 days
    const dueDate = new Date(startDate);
    dueDate.setDate(dueDate.getDate() + din);

    const formattedDueDate = dueDate.toLocaleDateString("en-US", {
      weekday: "long",
      month: "short",
      day: "2-digit",
      year: "numeric",
    });

    // Step 2: Weekly Ranges
    let e_date2 = new Date(startDate);
    e_date2.setDate(e_date2.getDate() + 1);

    let e_date3 = new Date(e_date2);
    e_date3.setDate(e_date3.getDate() + 6);

    let firstDates = [];
    let secondDates = [];

    for (let i = 0; i < 8; i++) {
      e_date2.setDate(e_date2.getDate() + 7);
      firstDates.push(new Date(e_date2));

      e_date3.setDate(e_date3.getDate() + 7);
      secondDates.push(new Date(e_date3));
    }

    const last1 = new Date(firstDates[7]);
    last1.setDate(last1.getDate() + 7);

    const last2 = new Date(secondDates[7]);
    last2.setDate(last2.getDate() + 7);

    const formatDate = (date) =>
      date.toLocaleDateString("en-US", {
        month: "short",
        day: "2-digit",
        year: "numeric",
      });

    const formatRange = (d1, d2) => `${formatDate(d1)} - ${formatDate(d2)}`;

    return {
      tech_date: formattedDueDate,
      tech_line: formatRange(firstDates[7], secondDates[7]),
      tech_line0: formatRange(firstDates[0], secondDates[0]),
      tech_line1: formatRange(firstDates[1], secondDates[1]),
      tech_line2: formatRange(firstDates[2], secondDates[2]),
      tech_line3: formatRange(firstDates[3], secondDates[3]),
      tech_line4: formatRange(firstDates[4], secondDates[4]),
      tech_line5: formatRange(firstDates[5], secondDates[5]),
      tech_line6: formatRange(firstDates[6], secondDates[6]),
      tech_line7: formatRange(firstDates[7], secondDates[7]),
      tech_line_l: formatRange(last1, last2),
    };
  }

  /**
   * getCalculationBenadrylForDogsCalculator: Service Method
   * POST: /api/calculators-lol/benadryl-for-dogs-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBenadrylForDogsCalculator(body) {
    const dogWeight = body.dog_weight;
    let weightUnitMultiplier = body.weight_unit;

    // Convert weight unit to appropriate multiplier
    if (weightUnitMultiplier === "g") {
      weightUnitMultiplier = 0.0022046;
    } else if (weightUnitMultiplier === "dag") {
      weightUnitMultiplier = 0.022046;
    } else if (weightUnitMultiplier === "kg") {
      weightUnitMultiplier = 2.2046;
    } else if (weightUnitMultiplier === "oz") {
      weightUnitMultiplier = 0.0625;
    } else if (weightUnitMultiplier === "lbs") {
      weightUnitMultiplier = 1;
    } else if (weightUnitMultiplier === "stone") {
      weightUnitMultiplier = 14;
    }

    if (isNaN(dogWeight)) {
      return {
        errorMessage: "Please check your input.",
        resultCode: 0,
      };
    }

    if (dogWeight < 0) {
      return {
        errorMessage: "The dog's weight should be more than 0",
        resultCode: 0,
      };
    }

    // Calculate the dosage values
    const weightInPounds = dogWeight * weightUnitMultiplier;
    const benadrylDose = weightInPounds * 1;
    const liquidDose = weightInPounds / 2.5;

    return {
      benadrylDosage: benadrylDose,
      liquidDosage: liquidDose,
    };
  }

  /**
   * getCalculationCatCaloieCalculator: Service Method
   * POST: /api/calculators-lol/cat-calorie-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCatCaloieCalculator(body) {
    let catWeight = body.tech_cat_weight;
    let catWeightUnit = body.tech_unit;
    let catCondition = body.tech_cat_condition;
    // Convert weight into kilograms
    if (catWeightUnit) {
      if (catWeightUnit === "kg") {
        catWeight = catWeight;
      } else if (catWeightUnit === "oz") {
        catWeight = catWeight / 35.274;
      } else if (catWeightUnit === "lbs") {
        catWeight = catWeight / 2.2046;
      }
    }

    let energyFactor = 0;

    if (catCondition) {
      switch (catCondition) {
        case "Neutered adult":
          energyFactor = 1.6;
          break;
        case "Non-neutered adult":
          energyFactor = 1.8;
          break;
        case "Weight loss":
          energyFactor = 1;
          break;
        case "Weight gain":
          energyFactor = 1.7;
          break;
        case "0-4 months old kitten":
          energyFactor = 3;
          break;
        case "4 months to adult cat":
          energyFactor = 2;
          break;
      }
    }
    if (!isNaN(catWeight)) {
      const weightInKg = catWeight;
      const restingCalories = Math.pow(weightInKg, 0.75) * 70;
      const totalMaintenanceCalories = restingCalories * energyFactor;
      return {
        tech_resting_energy: restingCalories,
        tech_maintenance_energy: totalMaintenanceCalories,
      };
    } else {
      return {
        error_message: "Please! Check your input.",
        result_code: 0,
      };
    }
  }

  /**
   * getCalculationPuppyWeigthCalculator: Service Method
   * POST: /api/calculators-lol/puppy-weight-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPuppyWeigthCalculator(body) {
    const {
      dogWeight,
      weightChoice,
      dogAge,
      ageChoice,
      dogType,
      breedSelection,
    } = body;

    function get_value(breed) {
      let assign_one = "";
      let assign_two = "";

      if (breed == "Affenpinscher") {
        assign_one = "7-10 pounds";
        assign_two = "1";
      } else if (breed == "Afghan Hound") {
        assign_one = "50-60 pounds";
        assign_two = "1";
      } else if (breed == "Airedale Terrier") {
        assign_one = "50-70 pounds";
        assign_two = "1";
      } else if (breed == "Akita") {
        assign_one = "100-130 pounds";
        assign_two = "70-100 pounds";
      } else if (breed == "Alaskan Malamute") {
        assign_one = "85 pounds";
        assign_two = "75 pounds";
      } else if (breed == "American Cocker Spaniel") {
        assign_one = "45-65 pounds";
        assign_two = "1";
      } else if (breed == "American Eskimo Dog (toy)") {
        assign_one = "6-10 pounds";
        assign_two = "1";
      } else if (breed == "American Esmiko Dog (miniature)") {
        assign_one = "10-20 pounds";
        assign_two = "1";
      } else if (breed == "American Esmiko Dog") {
        assign_one = "25-35 pounds";
        assign_two = "1";
      } else if (breed == "American Foxhound") {
        assign_one = "65-70 pounds";
        assign_two = "60-65 pounds";
      } else if (breed == "American Hairless Terrier") {
        assign_one = "12-16 pounds";
        assign_two = "1";
      } else if (breed == "American Staffordshire Terrier") {
        assign_one = "50-70 pounds";
        assign_two = "40-55";
      } else if (breed == "Anatolian Shepherd Dog") {
        assign_one = "110-150 pounds";
        assign_two = "80-120 pounds";
      } else if (breed == "Australian Cattle Dog") {
        assign_one = "35-50 pounds";
        assign_two = "1";
      } else if (breed == "Australian Shepherd") {
        assign_one = "50-65 pounds";
        assign_two = "40-55 pounds";
      } else if (breed == "Basenji") {
        assign_one = "24 pounds";
        assign_two = "22 pounds";
      } else if (breed == "Basset Hound") {
        assign_one = "40-65 pounds";
        assign_two = "1";
      } else if (breed == "Beagle") {
        assign_one = "20-30 pounds";
        assign_two = "1";
      } else if (breed == "Bearded Collie") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Beauceron") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Belgian Shepherd") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Bedlington Terrier") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Belgian Shepherd Malinois") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Bernese Mountain Dog") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Bichon Frise") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Black and Tan Coonhound") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Black Russian Terrier") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Bloodhound") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Bluetick Coonhound") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Border Collie") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Border Terrier") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Borzoi") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Boston Terrier") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Briard") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Bouvier des Flandres") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Boxer") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Boykin Spaniel") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Brittany") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Bull Terrier") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Bulldog") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Bullmastiff") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Cairn Terrier") {
        assign_one = "14 pounds";
        assign_two = "13 pounds";
      } else if (breed == "Canaan Dog") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Cane Corso") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Cavalier King Charles Spaniel") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Cesky Terrier") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Chesapeake Bay Retriever") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Chihuahua") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Chinese Crested Dog") {
        assign_one = "8-12 pounds";
        assign_two = "1";
      } else if (breed == "Chinese Shar-Pei") {
        assign_one = "45-60 pounds";
        assign_two = "1";
      } else if (breed == "Chinook") {
        assign_one = "55-90 pounds";
        assign_two = "50-65";
      } else if (breed == "Chow Chow") {
        assign_one = "45-70 pounds";
        assign_two = "1";
      } else if (breed == "Collie") {
        assign_one = "60-75 pounds";
        assign_two = "50-65 pounds";
      } else if (breed == "Coton de Tulear") {
        assign_one = "9-15 pounds";
        assign_two = "8-13 pounds";
      } else if (breed == "Dachshund (miniature)") {
        assign_one = "up to 11 pounds";
        assign_two = "1";
      } else if (breed == "Dachshund") {
        assign_one = "16-32 pounds";
        assign_two = "1";
      } else if (breed == "Dalmatian") {
        assign_one = "45-70 pounds";
        assign_two = "1";
      } else if (breed == "Dandie Dinmont Terrier") {
        assign_one = "18-24 pounds";
        assign_two = "1";
      } else if (breed == "Doberman Pinscher") {
        assign_one = "16-32 pounds";
        assign_two = "1";
      } else if (breed == "Dogue de Bordeaux") {
        assign_one = "75-100 pounds";
        assign_two = "60-90";
      } else if (breed == "English Foxhound") {
        assign_one = "60-75 pounds";
        assign_two = "1";
      } else if (breed == "English Toy Spaniel") {
        assign_one = "8-14 pounds";
        assign_two = "1";
      } else if (breed == "Entlebucher Mountain Dog") {
        assign_one = "55-65 pounds";
        assign_two = "1";
      } else if (breed == "Finnish Lapphund") {
        assign_one = "33-53 pounds";
        assign_two = "1";
      } else if (breed == "Finnish Spitz") {
        assign_one = "25-33 pounds";
        assign_two = "20-28";
      } else if (breed == "French Bulldog") {
        assign_one = "under 28 pounds";
        assign_two = "1";
      } else if (breed == "German Pinscher") {
        assign_one = "25-45 pounds";
        assign_two = "1";
      } else if (breed == "German Shepherd Dog") {
        assign_one = "65-90 pounds";
        assign_two = "50-70 pounds";
      } else if (breed == "Giant Schnauzer") {
        assign_one = "60-85 pounds";
        assign_two = "55-75 pounds";
      } else if (breed == "Glen of Imaal Terrier") {
        assign_one = "32-40 pounds";
        assign_two = "1";
      } else if (breed == "Great Dane") {
        assign_one = "140-175 pounds";
        assign_two = "110-140 pounds";
      } else if (breed == "Great Pyrenee") {
        assign_one = "100 pounds or more";
        assign_two = "85 pounds or more";
      } else if (breed == "Greater Swiss Mountain Dog") {
        assign_one = "115-140 pounds";
        assign_two = "85-110 pounds";
      } else if (breed == "Greyhound") {
        assign_one = "65-70 pounds";
        assign_two = "60-65 pounds";
      } else if (breed == "Harrier") {
        assign_one = "45-60 pounds";
        assign_two = "1";
      } else if (breed == "Havanese") {
        assign_one = "7-13 pounds";
        assign_two = "1";
      } else if (breed == "Ibizan Hound") {
        assign_one = "50 pounds";
        assign_two = "45 pounds";
      } else if (breed == "Icelandic Sheepdog") {
        assign_one = "30 pounds";
        assign_two = "25 pounds";
      } else if (breed == "Irish Terrier") {
        assign_one = "27 pounds";
        assign_two = "25 pounds";
      } else if (breed == "Irish Wolfhound") {
        assign_one = "120 pounds";
        assign_two = "105 pounds";
      } else if (breed == "Italian Greyhound") {
        assign_one = "7-14 pounds";
        assign_two = "1";
      } else if (breed == "Japanese Chin") {
        assign_one = "7-11 pounds";
        assign_two = "1";
      } else if (breed == "Keeshonden") {
        assign_one = "34-45 pounds";
        assign_two = "1";
      } else if (breed == "Kerry Blue Terrier") {
        assign_one = "33-40 pounds";
        assign_two = "30-37 pounds";
      } else if (breed == "Komondorok") {
        assign_one = "100 pounds or more";
        assign_two = "30-37 pounds";
      } else if (breed == "Kuvaszok") {
        assign_one = "100-115 pounds";
        assign_two = "70-90 pounds";
      } else if (breed == "Lagottto Romagnoli") {
        assign_one = "28.5-35 pounds";
        assign_two = "24-31 pounds";
      } else if (breed == "Lakeland Terrier") {
        assign_one = "17 pounds";
        assign_two = "16 pounds";
      } else if (breed == "Leonberger") {
        assign_one = "110-170 pounds";
        assign_two = "90-140 pounds";
      } else if (breed == "Lhasa Apso") {
        assign_one = "12-18 pounds";
        assign_two = "1";
      } else if (breed == "Lowchen") {
        assign_one = "15 pounds";
        assign_two = "1";
      } else if (breed == "Maltese") {
        assign_one = "under 7 pounds";
        assign_two = "1";
      } else if (breed == "Manchester Terrier (Toy)") {
        assign_one = "under 7 pounds";
        assign_two = "1";
      } else if (breed == "Manchester Terrier") {
        assign_one = "12-22 pounds";
        assign_two = "1";
      } else if (breed == "Mastiff") {
        assign_one = "160-230 pounds";
        assign_two = "120-170 pounds";
      } else if (breed == "Miniature Pinscher") {
        assign_one = "8-10 pounds";
        assign_two = "1";
      } else if (breed == "Miniature Bull Terrier") {
        assign_one = "18-28 pounds";
        assign_two = "1";
      } else if (breed == "Miniature Schnauzer") {
        assign_one = "11-20 pounds";
        assign_two = "1";
      } else if (breed == "Neapolitan Mastiff") {
        assign_one = "150 pounds";
        assign_two = "110 pounds";
      } else if (breed == "Newfoundland") {
        assign_one = "130-150 pounds";
        assign_two = "100-120 pounds";
      } else if (breed == "Norfolk Terrier") {
        assign_one = "11-12 pounds";
        assign_two = "1";
      } else if (breed == "Norwegian Buhund") {
        assign_one = "31-40 pounds";
        assign_two = "26-35 pounds";
      } else if (breed == "Norwegian Elkhound") {
        assign_one = "55 pounds";
        assign_two = "48 pounds";
      } else if (breed == "Norwegian Lundehund") {
        assign_one = "20-30 pounds";
        assign_two = "1";
      } else if (breed == "Norwich Terrier") {
        assign_one = "12 pounds";
        assign_two = "1";
      } else if (breed == "Old English Sheepdog") {
        assign_one = "60-100 pounds";
        assign_two = "1";
      } else if (breed == "Otterhound") {
        assign_one = "115 pounds";
        assign_two = "80 pounds";
      } else if (breed == "Papillon") {
        assign_one = "5-10 pounds";
        assign_two = "1";
      } else if (breed == "Parson Russell Terrier") {
        assign_one = "13-17 pounds";
        assign_two = "1";
      } else if (breed == "Pekingese") {
        assign_one = "up to 14 pounds";
        assign_two = "1";
      } else if (breed == "Pembroke Welsh Corgi") {
        assign_one = "up to 30 pounds";
        assign_two = "up to 28 pounds";
      } else if (breed == "Petit Basset Griffon Vendeen") {
        assign_one = "25-40 pounds";
        assign_two = "1";
      } else if (breed == "Pharaoh Hound") {
        assign_one = "45-55 pounds";
        assign_two = "1";
      } else if (breed == "Plott") {
        assign_one = "50-60 pounds";
        assign_two = "40-55 pounds";
      } else if (breed == "Polish Lowland Sheepdog") {
        assign_one = "30-50 pounds";
        assign_two = "1";
      } else if (breed == "Pomeranian") {
        assign_one = "3-7 pounds";
        $assign_two = "1";
      } else if (breed == "Poodle") {
        assign_one = "60-70 pounds";
        $assign_two = "40-50";
      } else if (breed == "Portuguese Water Dog") {
        assign_one = "60-70 pounds";
        $assign_two = "40-50";
      } else if (breed == "Pug") {
        assign_one = "42-60 pounds";
        $assign_two = "35-50 pounds";
      } else if (breed == "Pulik") {
        assign_one = "25-35 pounds";
        assign_two = "1";
      } else if (breed == "Redbone Coonhound") {
        assign_one = "25-35 pounds";
        assign_two = "1";
      } else if (breed == "Retreiver (Chesapeake Bay)") {
        assign_one = "65-80 pounds";
        assign_two = "55-70 pounds";
      } else if (breed == "Retreiver (Curly Coated)") {
        assign_one = "60-95 pounds";
        assign_two = "1 pounds";
      } else if (breed == "Retreiver (Flat Coated)") {
        assign_one = "60-70 pounds";
        assign_two = "1";
      } else if (breed == "Retreiver (Golden)") {
        assign_one = "65-75 pounds";
        assign_two = "55-65 pounds";
      } else if (breed == "Retreiver (Labrador)") {
        assign_one = "65-80 pounds";
        assign_two = "55-70 pounds";
      } else if (breed == "Rhodesian Ridgeback") {
        assign_one = "85 pounds";
        assign_two = "70 pounds";
      } else if (breed == "Rottweiler") {
        assign_one = "95-135 pounds";
        assign_two = "80-100 pounds";
      } else if (breed == "Russel Terrier") {
        assign_one = "9-15 pounds";
        assign_two = "1";
      } else if (breed == "Saluki") {
        assign_one = "40-65 pounds";
        assign_two = "1";
      } else if (breed == "Samoyed") {
        assign_one = "45-65 pounds";
        assign_two = "35-50 pounds";
      } else if (breed == "Schipperke") {
        assign_one = "10-16 pounds";
        assign_two = "1";
      } else if (breed == "Scottish Deerhound") {
        assign_one = "85-110 pounds";
        assign_two = "75-95";
      } else if (breed == "Scottish Terrier") {
        assign_one = "19-22 pounds";
        assign_two = "18-21 pounds";
      } else if (breed == "Sealyham Terrier") {
        assign_one = "23-24 pounds";
        assign_two = "20-23 pounds";
      } else if (breed == "Setter (English)") {
        assign_one = "65-80 pounds";
        assign_two = "45-55 pounds";
      } else if (breed == "Setter (Gordon)") {
        assign_one = "55-80 pounds";
        assign_two = "45-70 pounds";
      } else if (breed == "Setter (Irish Red and White)") {
        assign_one = "42-60 pounds";
        assign_two = "35-50 pounds";
      } else if (breed == "Setter (Irish)") {
        assign_one = "70 pounds";
        assign_two = "60 pounds";
      } else if (breed == "Shedland Sheepdog") {
        assign_one = "15-25 pounds";
        assign_two = "1";
      } else if (breed == "Shiba Inu") {
        assign_one = "23 pounds";
        assign_two = "17 pounds";
      } else if (breed == "Shih Tzu") {
        assign_one = "9-16 pounds";
        assign_two = "1";
      } else if (breed == "Siberian Huskie") {
        assign_one = "45-60 pounds";
        assign_two = "35-50 pounds";
      } else if (breed == "Silky Terrier") {
        assign_one = "8-10 pounds";
        assign_two = "1";
      } else if (breed == "Syke Terrier") {
        assign_one = "35-45 pounds";
        assign_two = "30-40 pounds";
      } else if (breed == "Sloughi") {
        assign_one = "35-50 pounds";
        assign_two = "1";
      } else if (breed == "Soft Coated Wheaten Terrier") {
        assign_one = "35-50 pounds";
        assign_two = "1";
      } else if (breed == "Spaniel (American Water)") {
        assign_one = "35-40 pounds";
        assign_two = "30-35 pounds";
      } else if (breed == "Spaniel (Boykin)") {
        assign_one = "30-40 pounds";
        assign_two = "25-35 pounds";
      } else if (breed == "Spaniel (Clumber)") {
        assign_one = "70-85 pounds";
        assign_two = "55-70 pounds";
      } else if (breed == "Spaniel (English Cocker)") {
        assign_one = "28-34 pounds";
        assign_two = "26-32 pounds";
      } else if (breed == "Spaniel (English Springer)") {
        assign_one = "50 pounds";
        assign_two = "40 pounds";
      } else if (breed == "Spaniel (Field)") {
        assign_one = "35-50 pounds";
        assign_two = "1";
      } else if (breed == "Spaniel (Irish Water)") {
        assign_one = "55-68 pounds";
        assign_two = "45-58";
      } else if (breed == "Spaniel (Sussex)") {
        assign_one = "35-50 pounds";
        assign_two = "1";
      } else if (breed == "Spaniel (Welsh Springer)") {
        assign_one = "35-45 pounds";
        assign_two = "1";
      } else if (breed == "Spaniel Water Dog") {
        assign_one = "35-45 pounds";
        assign_two = "1";
      } else if (breed == "Spinoni Italiani") {
        assign_one = "40-49 pounds";
        assign_two = "31-40 pounds";
      } else if (breed == "St. Bernard") {
        assign_one = "140-180 pounds";
        assign_two = "120-140 pounds";
      } else if (breed == "Staffordshire Bull Terrier") {
        assign_one = "28-38 pounds";
        assign_two = "24-34 pounds";
      } else if (breed == "Spinoni Italiani") {
        assign_one = "55-60 pounds";
        assign_two = "1";
      } else if (breed == "Standard Schnauzer") {
        assign_one = "35-50 pounds";
        assign_two = "30-45 pounds";
      } else if (breed == "Swedish Vallhund") {
        assign_one = "20-35 pounds";
        assign_two = "1";
      } else if (breed == "Tibetan Mastiff") {
        assign_one = "90-150 pounds";
        assign_two = "70-120 pounds";
      } else if (breed == "Tibetan Terrier") {
        assign_one = "18-30 pounds";
        assign_two = "15-25 pounds";
      } else if (breed == "Tibetan Spaniel") {
        assign_one = "18-30 pounds";
        assign_two = "15-25 pounds";
      } else if (breed == "Toy Fox Terrier") {
        assign_one = "9-15 pounds";
        assign_two = "1";
      } else if (breed == "Treeing Walker Coonhound") {
        assign_one = "50-70 pounds";
        assign_two = "1";
      } else if (breed == "Vizsla") {
        assign_one = "55-60 pounds";
        assign_two = "44-55 pounds";
      } else if (breed == "Weimaraner") {
        assign_one = "70-90 pounds";
        assign_two = "55-75 pounds";
      } else if (breed == "Welsh Terrier") {
        assign_one = "20 pounds";
        assign_two = "18-20 pounds";
      } else if (breed == "West Highland White Terrier") {
        assign_one = "15-20 pounds";
        assign_two = "1";
      } else if (breed == "Whippet") {
        assign_one = "25-40 pounds";
        assign_two = "1";
      } else if (breed == "Wirehaired Pointing Griffon") {
        assign_one = "50-70 pounds";
        assign_two = "35-50 pounds";
      } else if (breed == "Wirehaired Vizsla") {
        assign_one = "55-65 pounds";
        assign_two = "1";
      } else if (breed == "Xoloitzcuintli") {
        assign_one = "30-55 pounds";
        assign_two = "1";
      } else if (breed == "Yorkshire Terrier") {
        assign_one = "7 pounds";
        assign_two = "1";
      }
      return [assign_one, assign_two];
    }

    const names = get_value(breedSelection);

    if (dogType === "first" || dogType === "second") {
      if (isNaN(dogWeight) || isNaN(dogAge)) {
        return { error: "Please! Check Your Input" };
      }

      let age_calculation;
      if (ageChoice === "wks") {
        if (dogAge > 52) {
          return {
            error: "Dogs above 12 months of age are considered adults!",
          };
        } else if (dogAge < 0) {
          return { error: "Age must be greater than zero" };
        } else {
          age_calculation = dogAge * 1;
        }
      } else if (ageChoice === "days") {
        if (dogAge > 365) {
          return {
            error: "Dogs above 12 months of age are considered adults!",
          };
        } else if (dogAge < 0) {
          return { error: "Age must be greater than zero" };
        } else {
          age_calculation = dogAge * 0.14286;
        }
      } else if (ageChoice === "mon") {
        if (dogAge > 13) {
          return {
            error: "Dogs above 12 months of age are considered adults!",
          };
        } else if (dogAge < 0) {
          return { error: "Age must be greater than zero" };
        } else {
          age_calculation = dogAge * 4.348;
        }
      }

      let convert;
      if (dogWeight > 0) {
        switch (weightChoice) {
          case "g":
            convert = dogWeight / 1000;
            break;
          case "dag":
            convert = dogWeight / 100;
            break;
          case "kg":
            convert = dogWeight;
            break;
          case "oz":
            convert = dogWeight / 35.274;
            break;
          case "lb":
            convert = dogWeight / 2.205;
            break;
          case "stone":
            convert = dogWeight * 6.35;
            break;
          default:
            return { error: "Invalid weight selection" };
        }
      } else {
        return { error: "Weight must be greater than zero" };
      }

      const calculation = (convert / age_calculation) * 52;
      const calculate2 = calculation / 10;
      const cal3 = calculation + calculate2;
      const cal4 = calculation - calculate2;

      if (calculation >= 156.5) {
        return {
          error:
            "The heaviest dog ever weighed exactly 345 lb (156.5 kg). Try not to exceed it!",
        };
      }

      let h1 = "",
        h2 = "",
        h3 = "",
        h4 = "",
        h5 = "";
      if (calculation < 5.4) {
        h1 = "bg-gradient text-white";
      } else if (calculation >= 5.4 && calculation <= 10) {
        h2 = "bg-gradient text-white";
      } else if (calculation > 10 && calculation <= 25.9) {
        h3 = "bg-gradient text-white";
      } else if (calculation > 25.9 && calculation <= 44.9) {
        h4 = "bg-gradient text-white";
      } else if (calculation >= 44.9) {
        h5 = "bg-gradient text-white";
      }

      const calculation2 = calculation;
      const calculation3 = calculation * 2.20462;

      return {
        tech_h1: h1,
        tech_h2: h2,
        tech_h3: h3,
        tech_h4: h4,
        tech_h5: h5,
        tech_puppy1: calculation2,
        tech_puppy2: calculation3,
        tech_cal3: cal3,
        tech_cal4: cal4,
        tech_type: dogType,
        tech_select_breed: breedSelection,
        tech_names_zero: names[0],
        tech_names_one: names[1],
      };
    }

    return { error: "Invalid type selection" };
  }

  /**
   * getCalculationPearsonAgeCalculator: Service Method
   * POST: /api/calculators-lol/pearson-age-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPearsonAgeCalculator(body) {
    const dob = body.tech_date1;
    const date = body.tech_date;

    if (!dob || !date) {
      return { error: "Please Select Your Date of Birth." };
    }

    const dobParts = dob.split("-");
    const dateParts = date.split("-");

    const bday = moment(
      `${dobParts[2]}.${dobParts[1]}.${dobParts[0]}`,
      "DD.MM.YYYY"
    );
    const today = moment(
      `${dateParts[2]}.${dateParts[1]}.${dateParts[0]}`,
      "DD.MM.YYYY"
    );
    const diff = moment.duration(today.diff(bday));

    const age_years = today.diff(bday, "years");
    bday.add(age_years, "years");
    const age_months = today.diff(bday, "months");
    bday.add(age_months, "months");
    const age_days = today.diff(bday, "days");

    const now = moment();
    const dobMoment = moment(dob, "YYYY-MM-DD");

    const d1 = dobMoment.unix();
    const d2 = now.unix();

    if (d2 - d1 <= 0) {
      return { error: "Invalid Date of Birth." };
    }

    const obj = new AgeCalculator();
    obj.calculateAge(d1 * 1000);
    const age = obj.getAge();
    const rank = obj.getRank(age);

    const Totalyears = Math.floor((d2 - d1) / 31536000);
    const Total_months = Math.floor((d2 - d1) / 2628000);
    const Total_weeks = Math.floor((d2 - d1) / 604800);
    const Total_days = Math.floor((d2 - d1) / 86400);
    const Total_hours = Math.floor((d2 - d1) / 3600);
    const Total_minuts = Math.floor((d2 - d1) / 60);
    const Total_seconds = d2 - d1;

    // ✅ Correct Next Birthday Calculation
    const birthDay = parseInt(dobParts[2], 10);
    const birthMonth = parseInt(dobParts[1], 10);

    let nextBirthdayYear = now.year();
    if (
      now.month() + 1 > birthMonth ||
      (now.month() + 1 === birthMonth && now.date() > birthDay)
    ) {
      nextBirthdayYear++;
    }

    const nextBirthday = moment(
      `${nextBirthdayYear}-${dobParts[1]}-${dobParts[2]}`,
      "YYYY-MM-DD"
    );
    const remaining = moment.duration(nextBirthday.diff(now));
    const N_r_months = Math.floor(remaining.asMonths());
    const N_r_days = nextBirthday.diff(
      now.clone().add(N_r_months, "months"),
      "days"
    );

    return {
      tech_Age: age,
      tech_Age_years: age_years,
      tech_Age_months: age_months,
      tech_Age_days: age_days,
      tech_birth_month: dobParts[1],
      tech_N_r_months: N_r_months,
      tech_N_r_days: N_r_days,
      tech_Years: Totalyears,
      tech_Months: Total_months,
      tech_Weeks: Total_weeks,
      tech_Days: Total_days,
      tech_Hours: Total_hours,
      tech_Min: Total_minuts,
      tech_Sec: Total_seconds,
    };
  }

  /**
   * getCalculationDogAgeCalculator: Service Method
   * POST: /api/calculators-lol/dog-age-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDogAgeCalculator(body) {
    const tech_operations = body.tech_operations;
    const tech_brd = body.tech_brd;
    const tech_size = body.tech_size;
    const tech_age = parseFloat(body.tech_age);
    const tech_dogAge = parseFloat(body.tech_dogAge);
    const tech_dogBreed = body.tech_dogBreed;
    const tech_a = parseFloat(body.tech_a);
    const tech_b = parseFloat(body.tech_b);
    const tech_c = parseFloat(body.tech_c);

    let param = {};

    if (tech_operations === "1") {
      if (tech_brd === "1") {
        if (tech_age > 0 && tech_age < 20) {
          const f_ans = 16 * Math.log(tech_age);
          var answer = f_ans + 31;
        } else {
          param.error = "Please enter age between 1 and 20.";
          return param;
        }
      } else if (tech_brd === "2") {
        const kuty = [
          [0, 0, 0],
          [15, 15, 15],
          [24, 24, 24],
          [28, 28, 28],
          [32, 32, 32],
          [36, 36, 36],
          [40, 42, 45],
          [44, 47, 50],
          [48, 51, 55],
          [52, 56, 61],
          [56, 60, 66],
          [60, 65, 72],
          [64, 69, 77],
          [68, 74, 82],
          [72, 78, 88],
          [76, 83, 93],
          [80, 87, 120],
          [84, 92, 120],
          [88, 96, 120],
          [92, 101, 120],
        ];

        if (tech_age > 0 && tech_age < 20) {
          const parts = tech_age.toString().split(".");
          const index = parseInt(parts[0]);

          const calculateAge = (idx) => {
            const dogi_age1 = kuty[idx];
            const dogi_age2 = kuty[idx + 1];
            const show_baz1 = dogi_age1[tech_size - 1];
            const show_baz2 = dogi_age2[tech_size - 1];
            const percent = parseFloat("0." + parts[1]) * 100;
            const diff = show_baz2 - show_baz1;
            return show_baz1 + (diff / 100) * percent;
          };

          if (parts.length === 1) {
            answer = kuty[index][tech_size - 1];
          } else {
            answer = calculateAge(index);
          }
        } else {
          param.error = "Please enter age between 1 and 20.";
          return param;
        }
      }

      if (answer) {
        param.tech_answer = Number(answer).toFixed(answer % 1 === 0 ? 0 : 3);
      }
    } else if (tech_operations === "2") {
      if (!tech_dogAge || tech_dogAge <= 0) {
        param.error = "Please select Dog Age.";
        return param;
      }

      if (!tech_dogBreed || tech_dogBreed === "0") {
        param.error = "Please select Dog Breed.";
        return param;
      }

      if (!(tech_a >= 1)) {
        param.error = "Please enter First Year Aging greater than 0.";
        return param;
      }

      if (!(tech_b >= 1)) {
        param.error = "Please enter Second Year Aging greater than 0.";
        return param;
      }

      if (!(tech_c >= 1)) {
        param.error = "Please enter Human Life Expectancy greater than 0.";
        return param;
      }

      const [dogBreed1, dogBreed2] = tech_dogBreed.split("&&");
      const breeds = [
        [
          "Affenpinscher",
          12,
          14,
          "affenpinscher",
          "Small rodent hunting",
          "Families",
          "Moderate",
          "12-14 years",
          "25-27 cm",
          "3-4 kg",
          "Curious, Playful, Active",
          "Yes",
          "Black, gray, silver, Black and Tan",
        ],
        [
          "Afghan Hound",
          12,
          14,
          "afghan_hound",
          "Coursing and hunting",
          "Singles & Families",
          "High",
          "12-14 years",
          "63-68 cm",
          "25-29 kg",
          "Aloof, Happy, Independent",
          "Yes",
          "Black, Red, Cream",
        ],
        [
          "Airedale Terrier",
          10,
          12,
          "airedale_terrier",
          "Terrier Dogs",
          "Small Families",
          "High",
          "10-14 years",
          "58-61 cm",
          "23-29 kg",
          "Active, Intelligent, Loyal, Hard-Working, Athletic, Confident, Proud",
          "No",
          "Black, Grey, White, Tan",
        ],
        [
          "Akita",
          11,
          15,
          "akita",
          "Working Dogs",
          "Small Families, singles",
          "High",
          "11-15 years",
          "61-70 cm",
          "38-54 kg",
          "Active, loyal, willful, bold, courageous, intelligent, alert",
          "No",
          "Red, brindle, black, black brindle, blue brindle, brown, brown brindle, fawn, fawn brindle",
        ],
        [
          "Alaskan Malamute",
          13,
          16,
          "alaskan_malamute",
          "Working Dogs",
          "Families",
          "Medium",
          "12-16 years",
          "58-63 cm",
          "36-43 kg",
          "Intelligent, Active, Affectionate, Gentle, Independent",
          "No",
          "Black, white",
        ],
        [
          "American Cocker Spaniel",
          12,
          15,
          "american_cocker_spaniel",
          "Sporting Group",
          "Families, children",
          "Medium",
          "12-15 years",
          "37-39 cm",
          "11-14 kg",
          "Merry, Outgoing, Joyful, Trusing",
          "No",
          "Black, Red, Brown, Silver and Tan",
        ],
        [
          "American Eskimo Dog",
          13,
          15,
          "american_eskimo",
          "Circus performer",
          "Families & Friends",
          "High",
          "13-15 years",
          "38-48 cm",
          "8.2-16 kg",
          "Intelligent, Protective, Reserved, Alert",
          "No",
          "White, Biscuit",
        ],
        [
          "American Foxhound",
          10,
          12,
          "american_foxhound",
          "Hound Group",
          "Families",
          "Low",
          "10-12 years",
          "56-64 cm",
          "29-34 kg",
          "Kind, Loyal, Loving, Independent",
          "No",
          "White, White & cream, Red, Tri-color",
        ],
        [
          "American Staffordshire Terrier",
          10,
          12,
          "american_staffordshire_terrier",
          "Terrier Group",
          "Families and children",
          "Low",
          "12-16 years",
          "46-48 cm",
          "23-32 kg",
          "Attentive, Devoted, Courageous, Loyal",
          "No",
          "Sable, Black, Blue, Brown",
        ],
        [
          "American Water Spaniel",
          13,
          15,
          "default",
          "Bird flushing and retrieving",
          "Waterfowl hunters",
          "Low",
          "13-15 years",
          "38-46 cm",
          "14-20 kg",
          "Energetic, Intelligent, Protective",
          "No",
          "Solid liver, brown, dark chocolate",
        ],
        [
          "Anatolian Shepherd Dog",
          13,
          15,
          "default",
          "Working Group",
          "Families and Small children",
          "Low",
          "10-13 years",
          "74-81 cm",
          "41-68 kg",
          "Steady, Bold, Confident, Proud",
          "No",
          "Blue Fawn, Red Fawn, White, Brindle",
        ],
        [
          "Australian Cattle Dog",
          13,
          15,
          "australian_cattle_dog",
          "Herding Dogs",
          "Families with older children",
          "High",
          "12-15 years",
          "43-51 cm",
          "18-22 kg",
          "Loyal, Active",
          "No",
          "Red, Black, Chocolate, Blue, Grey",
        ],
        [
          "Australian Shepherd",
          13,
          15,
          "australian_shepherd",
          "Herding Dogs",
          "Families",
          "Medium",
          "13-15 years",
          "50 – 58 cm",
          "20 to 29kg",
          "Affectionate, Intelligent, Protective, Good-natured, Active",
          "No",
          "Red merles,Black Tricolor",
        ],
        [
          "Australian Silky Terrier",
          12,
          15,
          "australian_silky_terrier",
          "Terrier Group",
          "Person who wants adventure on a small scale",
          "Moderate Maintenance",
          "14 – 16 years",
          "23 – 26cm",
          "3 – 5kg",
          "Active, Lively, Stubborn, Mischievous",
          "Yes",
          "Black, Black and Tan, Blue, Blue and Tan, Blue Silver and tan, Cream, Grey, Fawn, Grey and Tan, Silver black and Tan, Silver and Platinum",
        ],
        [
          "Australian Terrier",
          12,
          15,
          "australian_terrier",
          "Terrier Dogs",
          "Singles, families",
          "Medium",
          "Up to 15 years",
          "23 – 28 cm",
          "5.5 to 7 kg",
          "Alert, Loyal, Spirited",
          "Yes",
          "Blue & Tan, Red, Sand",
        ],
        [
          "Basenji",
          12,
          16,
          "basenji",
          "Hound Dogs",
          "Couples and singles",
          "Low",
          "10-12 years",
          "Up to 45cm",
          "12 kg",
          "Alert, Playful, Energetic, Quiet",
          "Yes",
          "Black, Sand, Red, Tan",
        ],
        [
          "Basset Hound",
          10,
          12,
          "basset_hound",
          "Hound Dogs",
          "Families, singles",
          "Medium",
          "11-12 years",
          "30-38 cm",
          "18-27 kg",
          "Intelligent, independent, social, sharp-tempered, excited",
          "No",
          "Black, white, brown, red",
        ],
        [
          "Beagle",
          12,
          15,
          "beagle",
          "Hound Dogs",
          "Families",
          "Medium",
          "12-15 years",
          "33-41 cm",
          "8-14 kg",
          "Loyal, Gentle",
          "Yes",
          "White/brown",
        ],
        [
          "Bearded Collie",
          14,
          15,
          "bearded_collie",
          "Working Dog",
          "Families",
          "High Maintenance",
          "12 – 14 years",
          "50 – 56 cm",
          "20 – 25 kg",
          "Self-confidence, Hardy, Lively, Alert, Intelligent, Active",
          "No",
          "Black, Blue, Brown, Fawn",
        ],
        [
          "Beauceron",
          10,
          12,
          "default",
          "Boar herding, hunting, guarding",
          "Families and strangers",
          "Low",
          "10-12 years",
          "63-66 cm",
          "32-45 kg",
          "Calm, Protective, Fearless",
          "No",
          "Harlequin, Black with tan. Black, black and white",
        ],
        [
          "Belgian Shepherd",
          10,
          14,
          "belgian_shepherd",
          "Herding Group",
          "Families",
          "High",
          "10-14 years",
          "61-66 cm",
          "25-30 kg",
          "Powerful, Intelligent, Affectionate",
          "No",
          "Fawn or grey with black overlay and a black mask",
        ],
        [
          "Bedlington Terrier",
          12,
          14,
          "bedlington_terrier",
          "Killing rat, badger, other vermin",
          "Families",
          "High",
          " 12-14 years",
          "41-44 cm",
          "7.7-10 kg",
          "Loyal, energetic, friendly, headstrong",
          "Yes",
          "Sandy, Sandy & Tan, liver",
        ],
        [
          "Belgian Shepherd Malinois",
          12,
          14,
          "default",
          "Herding Group",
          "Families and Strangers",
          "High",
          "10-14 years",
          "61-66 cm",
          "25-30 kg",
          "Watchful, Hard-Working, Confident, Active",
          "No",
          "Mathogany, Tan, Black-tipped Fawn",
        ],
        [
          "Bernese Mountain Dog",
          7,
          8,
          "bernese_mountain_dog",
          "Working Dogs",
          "Families, singles",
          "Medium",
          "6-8 years",
          "61-70 cm",
          "45-53 kg",
          "Friendly, Easy-going, loving, alert, affectionate",
          "No",
          "Black, white",
        ],
        [
          "Bichon Frise",
          12,
          15,
          "bichon_frise",
          "Companion Dogs",
          "Singles, small families",
          "High",
          "12 to 15 years",
          "23 – 30 cm",
          "3 – 6 kg",
          "Playful, Gentle, Cheerful, Sensitive",
          "Yes",
          "White, White & Apricot, White & Buff",
        ],
        [
          "Black and Tan Coonhound",
          10,
          12,
          "default",
          "Hunting raccoons, night hunting",
          "Families and friendly",
          "Low",
          "10 – 12 years",
          "64–69 cm",
          "29 – 34 kg",
          "Even Tempered, Adaptable, Trusting, Easygoing",
          "No",
          "Black and tan",
        ],
        [
          "Black Russian Terrier",
          10,
          11,
          "black_russian_terrier",
          "Working Group",
          "Families and Singles",
          "Low",
          "10-11 years",
          "66-72 cm",
          "50-60 kg",
          "Stable, Confident, Energetic, Brave",
          "No",
          "Black, Salt & Pepper",
        ],
        [
          "Bloodhound",
          10,
          12,
          "bloodhound",
          "Trailing",
          "Children",
          "High",
          "10-12 years",
          "64-69 cm",
          "33-50 kg",
          "Stubborn, Affectionate, Even Tempered",
          "No",
          "Black and Tan, Liver and Tan, Red",
        ],
        [
          "Bluetick Coonhound",
          11,
          12,
          "default",
          "Hound",
          "Children",
          "Low",
          "11-12 years",
          "56-69 cm",
          "25-36 kg",
          "Intelligent, Active, Friendly",
          "No",
          "Bluetick",
        ],
        [
          "Border Collie",
          13,
          16,
          "border_collie",
          "Herding Dogs",
          "Families",
          "Medium-High",
          "13-16 years",
          "48-56 cm",
          "17-20 kg",
          "Intelligent, Obedient, Active",
          "No",
          "Red, Black, Chocolate, White, Merle",
        ],
        [
          "Border Terrier",
          12,
          15,
          "border_terrier",
          "Terrier Dogs",
          "Families, excellent with young kids",
          "Medium",
          "12-15 years",
          "33 – 41 cm",
          "5 -7 kg",
          "Intelligent, Alert, Fearless, Obedient",
          "Yes",
          "Blue & Tan, Red, Wheaten",
        ],
        [
          "Borzoi",
          7,
          10,
          "borzoi",
          "Hound Group",
          "Families",
          "Moderate",
          "7-10 years",
          "81-86 cm",
          "34-47 kg",
          "Quiet, Intelligent, Athletic, Respectful",
          "No",
          "Any color permissible",
        ],
        [
          "Boston Terrier",
          13,
          15,
          "boston_terrier",
          "Companion Dogs",
          "Families",
          "Medium-Low",
          "13-15 years",
          "40 – 45 cm",
          "6 to 11 kg",
          "Friendly, Intelligent, Lively",
          "No",
          "Seal & White, Black & White",
        ],
        [
          "Briard",
          10,
          12,
          "briard",
          "Herding, guarding sheep",
          "Families and Children",
          "High",
          "10-12 years",
          "58-69 cm",
          "27-41 kg",
          "Faithful, Intelligent, Obedient",
          "No",
          "Tawny, Grey, Black & grey",
        ],
        [
          "Bouvier des Flandres",
          10,
          12,
          "default",
          "Cattle herding",
          "Families",
          "High",
          "10-12 years",
          "62-68 cm",
          "35-40 kg",
          "Rational, Familial, Protective",
          "Yes",
          "Fawn, Black, Gray, Brindle",
        ],
        [
          "Boxer",
          10,
          12,
          "boxer",
          "Working Dogs",
          "Families",
          "Medium",
          "10-12 years",
          "53-60 cm",
          "30-32 kg",
          "Affectionate, active, watchful, alert, self-assured",
          "No",
          "Brown, red, white, black",
        ],
        [
          "Boykin Spaniel",
          14,
          16,
          "default",
          "Miscellaneous Class",
          "Families and hunters",
          "Moderate",
          "14-16 years",
          "39-46 cm",
          "14-18 kg",
          "Eager, Trainable, Companionable",
          "No",
          "Liver, Brown, Chocolate",
        ],
        [
          "Brittany",
          14,
          15,
          "brittany_spaniel",
          "Sporting Group",
          "Families",
          "Moderate",
          "12-15 years",
          "47-52 cm",
          "16-19 kg",
          "Attentive, Agile, Quick",
          "No",
          "Tri-color, Orange & White, Liver & White",
        ],
        [
          "Bull Terrier",
          11,
          14,
          "bull_terrier",
          "Terrier Dogs",
          "Families with older children",
          "Medium",
          "10-14 years",
          "51-60 cm",
          "20-33 kg",
          "Affectionate, active, loyal, stubborn",
          "No",
          "Brown, white, black, red",
        ],
        [
          "Bulldog",
          8,
          12,
          "default",
          "Non-Sporting Group",
          "Families and Children",
          "Low",
          "8-10 years",
          "31-40 cm",
          "18-23 kg",
          "Docile, Willful, Friendly",
          "No",
          "Piebald, White, Fawn and White",
        ],
        [
          "Bullmastiff",
          8,
          10,
          "bullmastiff",
          "Working Dogs",
          "Families with older children",
          "Medium",
          "8-10 years",
          "63-69 cm",
          "50-60 kg",
          "Loyal, stubborn, fearless, confident, independent",
          "Yes",
          "Fawn, brindle with markings on head",
        ],
        [
          "Cairn Terrier",
          12,
          15,
          "cairn_terrier",
          "Terrier Dogs",
          "Families",
          "Low – medium",
          "13-14 years",
          "25 to 33 cm",
          "6 to 8 kg",
          "Active, Hardy, Fearless, Gay, Intelligent",
          "Yes",
          "Black, Grey, Wheaten, Red",
        ],
        [
          "Canaan Dog",
          12,
          15,
          "canaan_dog",
          "Herding Group",
          "Children",
          "Low",
          "12-15 years",
          "51-61 cm",
          "18-25 kg",
          "Quick, Devoted, Alert, Intelligent",
          "No",
          "Black, Tan, Golden, Liver",
        ],
        [
          "Cane Corso",
          10,
          11,
          "cane_corso",
          "Working Dogs",
          "Families with young children",
          "High",
          "10-11 years",
          "64-68 cm",
          "45-50 kg",
          "Loyal, independent, Well-rounded, agile, energetic",
          "No",
          "black, grey and black, brindle",
        ],
        [
          "Cavalier King Charles Spaniel",
          9,
          14,
          "cavalier_king_charles_spaniel",
          "Companion Dogs",
          "Families",
          "Low – medium",
          "9-14 years",
          "30 to 33 cm",
          "5 to 8 kgs",
          "Playful, Gentle, Fearless, Patient, Adaptable",
          "No",
          "Black & Tan, Ruby, Tri-color",
        ],
        [
          "Cesky Terrier",
          12,
          15,
          "default",
          "Miscellaneous Class",
          "Families & Children",
          "High",
          "12-15 years",
          "10 to 13 in",
          "5.9 – 10 kg",
          "Cheerful, Calm, Reserved, Quiet",
          "Yes",
          "Grey blue, Light Cofee brown",
        ],
        [
          "Chesapeake Bay Retriever",
          10,
          12,
          "default",
          "Sporting Group",
          "Families and Children",
          "Moderate",
          "10-12 years",
          "58-66 cm",
          "29-36 kg",
          "Dominant, Happy, Affectionate, Quiet",
          "No",
          "Light Brown, Dark Brown, Deadgrass, Tan, Sedge",
        ],
        [
          "Chihuahua",
          10,
          18,
          "chihuahua",
          "Companion Dogs",
          "Singles, families with older Kids",
          "Medium",
          "10-18 years",
          "15 – 23 cm",
          "1.5 – 3 kg",
          "Devoted, Lively, Quick, Alert",
          "No",
          "Black, White, Fawn, Cream, Gold",
        ],
        [
          "Chinese Crested Dog",
          13,
          15,
          "chinese_crested_dog",
          "Toy dog",
          "Children",
          "High",
          "13-15 years",
          "28-33 cm",
          "3.2-5.4 kg",
          "Sweet-Tempered, Lively, Happy, Playful",
          "Yes",
          "Tri-color, Chocolate, Apricot",
        ],
        [
          "Chow Chow",
          9,
          12,
          "chow_chow",
          "Working Dogs",
          "Singles, small families",
          "Medium",
          "9-12 years",
          "43-50 cm",
          "25-32 kg",
          "Loyal, protective, reserved, aloof, dignified, stubborn, intelligent",
          "No",
          "black, blue, red faun, white coats",
        ],
        [
          "Clumber Spaniel",
          10,
          12,
          "default",
          "Sporting Group",
          "Families",
          "Moderate",
          "10-12 years",
          "46-51 cm",
          "25-39 kg",
          "Dignified, Great-hearted, Affectionate",
          "No",
          "White, Lemon & White",
        ],
        [
          "Curly Coated Retriever",
          9,
          14,
          "default",
          "Sporting Group",
          "Families, Children",
          "High",
          "9-14 years",
          "64-69 cm",
          "32-41 kg",
          "Clever, Intelligent, Sensitive, Trainable",
          "No",
          "Black, Liver",
        ],
        [
          "Dachshund",
          14,
          17,
          "dachshund",
          "Hound Dogs",
          "Singles, families",
          "Medium",
          "14-16 years",
          "20 – 27 cm",
          "4 – 5 kg",
          "Clever, Devoted, Active, Playful",
          "No",
          "Black, Black & Tan, Blue & Tan, Chocolate & Tan",
        ],
        [
          "Dalmatian",
          10,
          13,
          "dalmatian",
          "Companion Dogs",
          "Families with older children, Singles",
          "Medium-high",
          "10-13 years",
          "50-55 cm",
          "23-25 kg",
          "Energetic, Playful, Loyal",
          "Yes",
          "White with black spotted coat, brindle, mosaic, orange/lemon",
        ],
        [
          "Dandie Dinmont Terrier",
          12,
          15,
          "dandie_dinmont_terrier",
          "Terrier Group",
          "Children",
          "Moderate",
          "12-15 years",
          "8-11 ins",
          "8.2-11 kg",
          "Fun-loving, Determined, Independent, Lively",
          "Yes",
          "Pepper, Mustard",
        ],
        [
          "Doberman Pinscher",
          10,
          11,
          "doberman_pinscher",
          "Working Dogs",
          "Families",
          "Low",
          "10 – 13 years",
          "60 – 70 cm",
          "35 – 42kg",
          "Intelligent, Obedient, Fearless, Alert, Energetic, Loyal, Confident",
          "No",
          "White, Fawn, Black, Blue, Red, Black & Rust, Fawn",
        ],
        [
          "Dogue de Bordeaux",
          10,
          12,
          "default",
          "Working Dogs",
          "Families",
          "Medium",
          "10-12 years",
          "65-70 cm",
          "60-68 kg",
          "Intelligent, loyal, Sensitive, Active",
          "No",
          "Dark red, Fawn, mahogany, golden fawn",
        ],
        [
          "English Bulldog",
          8,
          12,
          "english_bulldog",
          "Companion Dogs",
          "Families",
          "Medium",
          "8 to 12 years",
          "31 – 40cm",
          "0–25 kg",
          "Gentle, affectionate, stubborn , Friendly. Docile. Devoted.",
          "No",
          "White, Fawn, Piebald, Brindle & White, Fawn & White, Red, Red Brindle, Red & White",
        ],
        [
          "English Cocker Spaniel",
          12,
          15,
          "english_cocker_spaniel",
          "Sporting Group",
          "Families",
          "High",
          "12-15 years",
          "38-43 cm",
          "13-14 kg",
          "Affectionate, Friendly, Quiet, Faithful",
          "No",
          "Orange Roan, Liver Roan, Blue Roan, Black",
        ],
        [
          "English Coonhound",
          11,
          12,
          "default",
          "Scenthound",
          "Families",
          "Low",
          "11-12 years",
          "56-69 cm",
          "18-30 kg",
          "High-Strung, Loyal, Energetic, Intelligent",
          "No",
          "Redtick, Red & White, Bluetick, Tricolor Ticked",
        ],
        [
          "English Foxhound",
          10,
          13,
          "default",
          "Hound Group",
          "Hunters and Families",
          "Low",
          "10-13 years",
          "56-63 cm",
          "29-34 kg",
          "Tolerant, Sociable, Gentle, Friendly",
          "No",
          "Tricolor, Lemon & White, White",
        ],
        [
          "English Mastiff",
          10,
          12,
          "english_mastiff",
          "Working Group",
          "Children",
          "Moderate",
          "6-12 years",
          "70-91 cm",
          "73-100 kg",
          "Good-natured, Dignified, Courageous, Calm",
          "No",
          "Fawn, Brindle, Apricot",
        ],
        [
          "English Setter",
          10,
          12,
          "english_setter",
          "Sporting Group",
          "Children",
          "High",
          "10-12 years",
          "25 to 27 in",
          "65 to 80 pounds",
          "Strong Willed, Eager, Hard-Working, Gentle",
          "No",
          "Blue Belton, Tricolor, Orange Belton, Liver Belton",
        ],
        [
          "English Springer Spaniel",
          12,
          14,
          "english_springer_spaniel",
          "Spaniel group",
          "Families",
          "Moderate",
          "12-14 years",
          "48-56 cm",
          "20-25 kg",
          "Affectionate, Attentive, Alert",
          "No",
          "Liver & White, Tricolor",
        ],
        [
          "Entlebucher Mountain Dog",
          11,
          15,
          "default",
          "Foundation Stock Service Program",
          "Children",
          "High",
          "11-15 years",
          "44-52 cm",
          "20-30 kg",
          "Self-confidence, Agile, Independent, Loyal",
          "No",
          "Tri-color",
        ],
        [
          "Field Spaniel",
          10,
          12,
          "default",
          "Sporting Group, Bird flushing, retrieving",
          "Families",
          "Moderate",
          "10-12 years",
          "17-18 in",
          "16-20 kg",
          "Adaptable, Sensitive, Sociable, Familial",
          "No",
          "Black, Blue Roan, Liver Roan, Liver",
        ],
        [
          "Finnish Lapphund",
          12,
          14,
          "default",
          "Foundation Stock Service Program",
          "Families",
          "Low",
          "12-14 years",
          "46-52 cm",
          "15-24 kg",
          "Keen, Courageous, Faithful, Calm",
          "No",
          "Black, White, Wolf-Sable, Sable, Brown",
        ],
        [
          "Finnish Spitz",
          12,
          14,
          "default",
          "Non-Sporting Group, Hunting birds, small mammals",
          "Families and Children",
          "Moderate",
          "12-14 years",
          "44-50 cm",
          "12-14 kg",
          "Vocal, Independent, Playful, Happy",
          "No",
          "Gold, Red Gold, Red",
        ],
        [
          "Flat-Coated Retriever",
          8,
          10,
          "default",
          "Sporting Group, Water retrieving",
          "Families",
          "Low",
          "8-14 years",
          "59-62 cm",
          "27-36 kg",
          "Outgoing, Optimistic, Confident, Friendly",
          "No",
          "Black, Liver",
        ],
        [
          "French Bulldog",
          10,
          12,
          "french_bulldog",
          "Companion Dogs",
          "Singles, families",
          "Medium",
          "10-15 years",
          "28-30 cm",
          "10 – 13kgs",
          "Playful, Lively, Affectionate, Bright, Keen, Athletic, Alert, Sociable, Patient, Easygoing",
          "No",
          "Brindle, Fawn, Pied",
        ],
        [
          "German Pinscher",
          12,
          14,
          "default",
          "Working Group",
          "Children",
          "High",
          "12-14 years",
          "25-30 cm",
          "11-20 kg",
          "Spirited, Intelligent, Even Tempered",
          "No",
          "Black, Brown, Red, Blue",
        ],
        [
          "German Shepherd",
          9,
          13,
          "german_shepherd",
          "Herding Dogs",
          "Families",
          "Medium",
          "12-14 years",
          "60-65 cm",
          "30-40 kg",
          "Intelligent, loyal, patient, active, aloof, reserved, protective",
          "No",
          "Mixture of gold and black",
        ],
        [
          "German Shorthaired Pointer",
          12,
          14,
          "german_shorthaired_pointer",
          "General hunting, Sporting Group",
          "Hunters",
          "Low",
          "12-14 years",
          "58-64 cm",
          "25-32 kg",
          "Boisterous, Affectionate, Bold, Cooperative",
          "No",
          "Liver Roan, Liver, Black & White, White & Chocolate",
        ],
        [
          "German Wirehaired Pointer",
          12,
          14,
          "german_wirehaired_pointer",
          "Sporting Group, General hunting, watch dog",
          "Gun Dog",
          "Moderate",
          "12-14 years",
          "61-68 cm",
          "27-32 kg",
          "Willful, Intelligent, Loyal, Active",
          "No",
          "Liver, Black & White, Roan, Liver & White",
        ],
        [
          "Giant Schnauzer",
          12,
          15,
          "giant_schnauzer",
          "Working Group, Herding, guarding",
          "Herding Dog",
          "Moderate",
          "12-15 years",
          "65-70 cm",
          "27-48 kg",
          "King, Dominant, Loyal, Powerful, Strong Willed",
          "Yes",
          "Salt & Pepper, Black",
        ],
        [
          "Glen of Imaal Terrier",
          13,
          14,
          "default",
          "Terrier Group",
          "Children",
          "High",
          "10-14 years",
          "13-i4 in",
          "15-16 kg",
          "Agile, Spirited, Loyal, Active",
          "No",
          "Blue Brindle, Wheaten",
        ],
        [
          "Golden Retriever",
          10,
          12,
          "golden_retriever",
          "Sporting Dogs",
          "Families",
          "Medium",
          "11-12 years",
          "58-61 cm",
          "29-34 kg",
          "Intelligent, Gentle, Friendly",
          "No",
          "Gold, cream",
        ],
        [
          "Gordon Setter",
          10,
          12,
          "gordon_setter",
          "Sporting Group",
          "Families and Children",
          "Low",
          "10-12 years",
          "61-69 cm",
          "25-36 kg",
          "Gay. Fearless, Confident, Active",
          "No",
          "Black & Tan",
        ],
        [
          "Great Dane",
          6,
          8,
          "great_dane",
          "Working Dogs",
          "Families",
          "Medium",
          "6-8 years",
          "76-86 cm",
          "54-91 kg",
          "Devoted, Reserved, Loving, Gentle, Friendly, Confident",
          "No",
          "Brindle, Fawn, Black, Mantle, Blue, Harlequin",
        ],
        [
          "Great Pyrenees",
          10,
          12,
          "great_pyrenees",
          "Sheep guardian, Working Group",
          "Families and Childrens",
          "Moderate",
          "10-12 years",
          "70-82 cm",
          "45-73 kg",
          "Gentle, Strong Willed, Patient, Fearless",
          "No",
          "Tan, White, Bedger, White",
        ],
        [
          "Greater Swiss Mountain Dog",
          10,
          11,
          "greater_swiss",
          "Working Group",
          "Childrens",
          "Low",
          "10-11 years",
          "65-72 cm",
          "55-65 kg",
          "Self-confidence, Loyal, Devoted, Fearless",
          "No",
          "Tri-color",
        ],
        [
          "Greyhound",
          10,
          12,
          "greyhound",
          "Lapdog, Hound Group",
          "Families",
          "Low",
          "10-14 years",
          "71-76 cm",
          "27-40 kg",
          "Even Tempered, Affectionate, Quiet, Intelligent",
          "No",
          "Brindle, Black, White, Fawn, Blue, Red",
        ],
        [
          "Griffon Bruxellois",
          12,
          15,
          "griffon_bruxellois",
          "Toy Dog",
          "Kids",
          "Low",
          "10-15 years",
          "9-11 inches",
          "8-10 pounds",
          "Sensitive, Companionable, Watchful, Alert",
          "Yes",
          "Black, Black & Tan, Blue, Blege, Brown",
        ],
        [
          "Harrier",
          10,
          12,
          "default",
          "Hound Group",
          "Childrens, Families",
          "Low",
          "10-12 years",
          "19-21 inches",
          "20-30 kg",
          "Outgoing, Cheerful, Active, Friendly",
          "No",
          "Lemon & white, Tri-color, White, Black & Tan",
        ],
        [
          "Havanese",
          13,
          15,
          "havanese",
          "Companion Dogs",
          "Families",
          "Low-medium",
          "13 – 15 years",
          "23 – 27 cm",
          "4.5 – 7.3 kg",
          "Playful, Gentle, Intelligent, Responsive, Affectionate, Companionable",
          "Yes",
          "Black, White, Tobacco, Fawn",
        ],
        [
          "Ibizan Hound",
          10,
          12,
          "ibizan_hound",
          "Coursing rabbits, Hound Group",
          "Families",
          "Low",
          "10-12 years",
          "66-72 cm",
          "20-30 kg",
          "Clownish, Stubborn, Independent, Active",
          "No",
          "White, Fawn, White & Red, Red",
        ],
        [
          "Icelandic Sheepdog",
          12,
          15,
          "icelandic_sheepdog",
          "Miscellaneous Class",
          "Childrens",
          "High",
          "12-15 years",
          "16.5-18 inches",
          "9.1-14 kg",
          "Cheerful, Hardy, Agile, Alert",
          "No",
          "White & black, White & Cream, Gold & White, Grey & White",
        ],
        [
          "Irish Red and White Setter",
          10,
          13,
          "default",
          "Sporting Group",
          "Small Kids",
          "High",
          "10-13 years",
          "62-66 cm",
          "25-34 kg",
          "Affectionate, Devoted, Loyal, Reliable",
          "No",
          "Red & White",
        ],
        [
          "Irish Setter",
          12,
          15,
          "irish_setter",
          "Sporting Dogs",
          "Families",
          "High",
          "10-14 years",
          "63-70 cm",
          "29-34 kg",
          "Fun, Playful, Outgoing, Loving, Sporty",
          "No",
          "Mahogany and chestnut",
        ],
        [
          "Irish Soft-coated Wheaten Terrier",
          12,
          15,
          "default",
          "Terrier Group",
          "Families",
          "High",
          "12-15 years",
          "46-48 cm",
          "16-20 kg",
          "Intelligent, Affectionate, Playful, Energetic, Spirited",
          "Yes",
          "Wheaten",
        ],
        [
          "Irish Terrier",
          13,
          15,
          "irish_terrier",
          "Terrier Dogs",
          "Families, Singles",
          "Low-Medium",
          "12-15 years",
          "40-46 cm",
          "10-12 kg",
          "Lively, Gentle",
          "Yes",
          "Bright red, golden red, red wheaten, solid wheaten",
        ],
        [
          "Irish Water Spaniel",
          10,
          12,
          "default",
          "Water retrieving, Sporting Group",
          "Families and Childrens",
          "high",
          "10-12 years",
          "56-61 cm",
          "25-30 kg",
          "Clownish, Quick, Intelligent, Alert, Active",
          "Yes",
          "Liver",
        ],
        [
          "Irish Wolfhound",
          6,
          10,
          "irish_wolfhound",
          "Coursing wolves, elk, Hound Group",
          "Childrens",
          "Moderate",
          "6-10 years",
          "30-32 inches",
          "120-155 lbs",
          "Sweet-Tempered, Thoughtful, Loyal, Dignified, Genrous",
          "No",
          "Black, White, Brindle, Fawn, Grey",
        ],
        [
          "Italian Greyhound",
          12,
          15,
          "italian_greyhound",
          "Companion Dogs",
          "Families with older kids",
          "Medium – low",
          "12-15 years",
          "30 to 40 cm",
          "3 – 5 kg",
          "Intelligent, Agile, Affectionate, Companionable, Athletic, Mischievous",
          "Yes",
          "Black, Fawn, Chocolate, Blue Fawn, Slate Grey, Red Fawn, Red, Blue, Tan, Sable, Yellow, Grey",
        ],
        [
          "Jack Russell Terrier",
          13,
          16,
          "jack_russell_terrier",
          "Terrier Dogs",
          "Families with older children",
          "Medium",
          "13-16 years",
          "25 to 38cm",
          "6 to 8kgs",
          "Stubborn, Fearless, Intelligent, Athletic, Energetic, Vocal",
          "No",
          "White, Black & White, White & Tan",
        ],
        [
          "Japanese Chin",
          12,
          14,
          "japanese_chin",
          "Lapdog, Toy Dog",
          "Childrens",
          "Moderate",
          "12-14 years",
          "8-11 inches",
          "1.4-8.6 kg",
          "Cat-like, Alert, Loyal, Intelligent, Independent",
          "No",
          "Tri-color, Black & White, Lemon & White, Sable & White",
        ],
        [
          "Keeshond",
          13,
          15,
          "keeshounds",
          "Barge watchdog, Non-Sporting Group",
          "Families & Childrens",
          "High",
          "13-15 years",
          "17-18 inches",
          "14-18 kg",
          "Bright, Agile, Playful, Obedient",
          "No",
          "Black, Grey, Black & Silver, Silver",
        ],
        [
          "Kerry Blue Terrier",
          13,
          15,
          "kerry_blue_terriers",
          "Kerry Blue Terrier",
          "Childrens",
          "High",
          "13-15 years",
          "46-51 cm",
          "15-18 kg",
          "Strong Willed, Alert, Loyal, Spirited",
          "Yes",
          "Black, Blue, Silver, Grey",
        ],
        [
          "King Charles Spaniel",
          12,
          14,
          "king_charles_spaniel",
          "Flushing small birds, companion, Toy Dog",
          "Childrens, Families and Strangers",
          "High",
          "9-14 years",
          "12-13 inches",
          "5.9-9.2 kg",
          "Playful, Sociable, Gentle, Affectionate, Patient",
          "No",
          "Black & Tan, Tri-color, Ruby",
        ],
        [
          "Komondor",
          10,
          12,
          "default",
          "Sheep guardian, Working Group",
          "Families",
          "High",
          "10-12 years",
          "71-76 cm",
          "50-60 kg",
          "Steady, Affectionate, fearless, Gentle",
          "No",
          "White, Black, Red, Green",
        ],
        [
          "Kuvasz",
          10,
          12,
          "default",
          "Guardian, hunting large game, Working Group",
          "Families",
          "Moderate",
          "10-12 years",
          "70-76 cm",
          "45-52 kg",
          "Protective, Intelligent, Patient, Loyal",
          "No",
          "White, Black, Blue, Brown, Pink",
        ],
        [
          "Labrador Retriever",
          12,
          13,
          "labrador_retriever",
          "Water retrieving, Sporting Group",
          "Kids and Families",
          "Low",
          "10-12 years",
          "57-62 cm",
          "29-36 kg",
          "Outgoing, Kind, Even Tempered, Agile",
          "No",
          "Black, Yellow, Chocolate",
        ],
        [
          "Lakeland Terrier",
          12,
          16,
          "lakeland_terrier",
          "Terrier Group",
          "Kids & Families",
          "Moderate",
          "12-16 years",
          "13.5-15 inches",
          "7-8 kg",
          "Intelligent, Friendly, Independent, Bold",
          "Yes",
          "Black, Grizzle & Tan, Black & Tan, Wheaten",
        ],
        [
          "Leonberger",
          8,
          9,
          "leonberger",
          "Guardian, appearance, Miscellaneous Class",
          "Kids",
          "High",
          "8-9 years",
          "72-80 cm",
          "48-75 kg",
          "Fearless, Loyal, Loving, Obedient",
          "No",
          "Red, Sandy, Yellow",
        ],
        [
          "Lhasa Apso",
          12,
          14,
          "lhasa_apso",
          "Companion Dogs",
          "Singles, families",
          "High",
          "13-15 years",
          "25 – 28 cm",
          "6 – 7 kg",
          "Playful, Lively, Obedient, Devoted, Fearless, Intelligent, Spirited, Alert, Assertive, Energetic, Friendly, Steady",
          "Yes",
          "black, white, black and tan",
        ],
        [
          "Lowchen",
          12,
          14,
          "default",
          "Non-Sporting Group",
          "Families and Childrens",
          "Low",
          "12-14 years",
          "33-36 cm",
          "5-8 kg",
          "Playful, Happy, Active, Intelligent",
          "Yes",
          "Black, Silver & Black, Cream, Black & Tan",
        ],
        [
          "Maltese",
          12,
          15,
          "maltese_dog",
          "Companion Dogs",
          "Singles, families with older children",
          "Low – medium",
          "12-15 years",
          "21 – 25 cm",
          "3 – 4 kg",
          "Playful, Lively, Affectionate, Docile, Fearless",
          "Yes",
          "White, Black, Blue, Red, Green, Yellow",
        ],
        [
          "Manchester Terrier",
          14,
          16,
          "default",
          "Terrier Group",
          "Families",
          "Low",
          "14-16 years",
          "15-16 inches",
          "5.4-10 kg",
          "Discerming, Keen, Active, Devoted",
          "No",
          "Black, Black & Tan, Tan, Blue",
        ],
        [
          "Mexican Hairless Dog",
          12,
          15,
          "mexican_hairless",
          " hairless Chinese, Foundation Stock Service Program",
          "Families, Old Childrens",
          "Low",
          "12-15 years",
          "28-33 cm",
          "4-25 kg",
          "Cheerful, Calm, Alert, Intelligent, Protective",
          "Yes",
          "Black, Brindle, Brown, Fawn",
        ],
        [
          "Miniature Pinscher",
          14,
          15,
          "miniature_pinscher",
          "Companion Dogs",
          "Families",
          "Medium-high",
          "10 to 14 years",
          "25–30 cm",
          "4–5 kg",
          "Playful, Outgoing, Responsive, Energetic, Friendly, Clever",
          "No",
          "Stag Red, Chocolate & Rust, Black & Tan, Red, Black & Rust, Chocolate & Tan",
        ],
        [
          "Miniature Schnauzer",
          12,
          15,
          "mininature_schnauzer",
          "Ratting, Terrier Group",
          "Childrens",
          "Moderate",
          "12-15 years",
          "30-36 cm",
          "5.4-9.1 kg",
          "Intelligent, Fearless, Obedient, Friendly",
          "Yes",
          "Black, Salt & Pepper, White",
        ],
        [
          "Neapolitan Mastiff",
          8,
          10,
          "default",
          "Working Group",
          "Old Childrens",
          "Low",
          "8-10 years",
          "63-77 cm",
          "60-70 kg",
          "Stubborn, Obedient, Dominant, Protective, Fearless",
          "No",
          "Black, Brindle, Tawny, Blue",
        ],
        [
          "Newfoundland",
          8,
          12,
          "newfoundland",
          "Working Dogs",
          "Families",
          "Medium",
          "8-10 years",
          "69 to 74cm",
          "65 to 69kgs",
          "Trainable, Sweet-Tempered, Gentle",
          "No",
          "Black, Black & White, Brown, Grey",
        ],
        [
          "Norfolk Terrier",
          12,
          15,
          "default",
          "Ratting, fox bolting, Terrier Group",
          "Childrens",
          "Moderate",
          "12-15 years",
          "9-10 inches",
          "5-5.4 kg",
          "Lovable, Fearless, Spirited, Happy",
          "Yes",
          "Grizzle, Black & Tan, Wheaten, Red",
        ],
        [
          "Norwegian Buhund",
          13,
          15,
          "default",
          "Miscellaneous Class",
          "Families",
          "Low",
          "13-15 years",
          "43-47 cm",
          "14-18 kg",
          "Fun-loving, Friendly, Courageous, Energetic, Agile",
          "No",
          "Black, Red Wheaten, Wheaten",
        ],
        [
          "Norwegian Elkhound",
          12,
          15,
          "default",
          "Hunting elk, Hound Group",
          "Kids",
          "Moderate",
          "12-15 years",
          "19-21 inches",
          "22-25 kg",
          "Hardy, Bold, Loyal, Alert, Strong Willed",
          "No",
          "Grey, Silver",
        ],
        [
          "Norwegian Lundehund",
          12,
          14,
          "default",
          "Northern Breed Group",
          "Kids",
          "Low",
          "12-14 years",
          "33-38 cm",
          "6-9 kg",
          "Energetic, loyal, Protective, Alert",
          "No",
          "Black, White, Sable & White, Grey, Red",
        ],
        [
          "Norwich Terrier",
          12,
          14,
          "norwich_terrier",
          "Ratting, fox bolting",
          "Families and Childrens",
          "Moderate",
          "12-14 years",
          "8-10 inches",
          "5-5.4 kg",
          "Hardy, Intelligent, Sensitive, Affectionate",
          "Yes",
          "Grizzle, Black & Tan, Red, Tan",
        ],
        [
          "Nova Scotia Duck Tolling Retriever",
          12,
          14,
          "nova_scotia_duck_tolling_retriever",
          "Sporting Group",
          "Childrens",
          "Low",
          "10-14 years",
          "45-54 cm",
          "20-23 kg",
          "Intelligent, Alert, Loving",
          "No",
          "Copper, Red, Red Golden",
        ],
        [
          "Old English Sheepdog",
          10,
          12,
          "old_english_sheepdog",
          "Herding Group",
          "Families",
          "Medium – high",
          "10-12 years",
          "56 – 61cm",
          "38 – 45kg",
          "Active, Intelligent, Loyal, Hard-Working, Athletic, Confident, Proud",
          "No",
          "Blue Merle, Blue, Grey, Grizzle",
        ],
        [
          "Otterhound",
          10,
          13,
          "default",
          "Hound Group",
          "Small Childrens and Families",
          "High",
          "10-13 years",
          "24-27 inches",
          "41-50 kg",
          "Amiable, Even Tempered, Boisterous",
          "No",
          "Black, Liver & Tan, Wheaten, Grey",
        ],
        [
          "Papillon",
          13,
          15,
          "papillon",
          "Companion Dogs",
          "Families",
          "Medium",
          "13-15 Years",
          "Up to 28 cm",
          "Up to 5 kg",
          "Intelligent, active",
          "No",
          "White and Brown",
        ],
        [
          "Parson Russell Terrier",
          13,
          15,
          "default",
          "Terrier Group",
          "Childrens",
          "Low",
          "13-15 years",
          "34-38 cm",
          "5.9-7.7 kg",
          "Energetic, Bold, Obedient, Intelligent",
          "No",
          "White & Tan, Tri-color, Black & White",
        ],
        [
          "Pekingese",
          12,
          15,
          "pekingese",
          "Companion Dogs",
          "Couples and singles",
          "High",
          "13-15 Years",
          "Up to 25 cm",
          "Up to 6 kg",
          "Confident, stubborn, Tough, Affectionate",
          "No",
          "Gold, sable, red, cream, tan, white",
        ],
        [
          "Pembroke Welsh Corgi",
          12,
          14,
          "pembroke_welsh_corgi",
          "Herding Group, Cattle drover",
          "children",
          "Low",
          "12-15 Years",
          "25-30 cm",
          "10-14 kg",
          "Tanacious, Friendly, Playful, Outgoing, Bold",
          "No",
          "Fawn, Black & White, Red, Black & Tan",
        ],
        [
          "Petit Basset Griffon Vendeen",
          12,
          14,
          "default",
          "Hound Group",
          "Childrens and families",
          "High",
          "12-14 years",
          "13.5-15 inches",
          "15-20 kg",
          "Extroverted, Lively, Independent, Friendly",
          "No",
          "Tri-color, Black & Tan, Fawn & White",
        ],
        [
          "Pharaoh Hound",
          11,
          14,
          "default",
          "Hunting rabbits, Hound Group",
          "Childrens",
          "Low",
          "11-14 years",
          "55-63 cm",
          "18-27 kg",
          "Affectionate, Sociable, Playful, Intelligent",
          "No",
          "Rich Tan, Tan, Red Golden",
        ],
        [
          "Plott Hound",
          12,
          14,
          "default",
          "Hound Group",
          "Childrens And Families",
          "High",
          "12-14 years",
          "50-71 cm",
          "23-27 kg",
          "Intelligent, Alert, Bold, Loyal",
          "No",
          "Black, Brown Brindle, Tan Brindle",
        ],
        [
          "Pointer",
          12,
          14,
          "default",
          "Sporting Group, General hunting, watch dog General hunting, watch dog",
          "Childrens",
          "Moderate",
          "12-17 years",
          "56-70 cm",
          "25-34 kg",
          "Even Tempered, Affectionate, Loyal, Amiable",
          "No",
          "Black, Orange & White, Black & White, Liver",
        ],
        [
          "Polish Lowland Sheepdog",
          12,
          15,
          "polish_lowland_sheepdog",
          "Herding Group",
          "Families",
          "High",
          "12-15 years",
          "45-50 cm",
          "18-23 kg",
          "Even Tempered, Lively, Self-confidence",
          "Yes",
          "Black, Tri-color, Black & White, Beige",
        ],
        [
          "Pomeranian",
          12,
          16,
          "pomeranian",
          "Companion Dogs",
          "Families and singles",
          "Medium",
          "12 – 16 Years",
          "13-28 cm",
          "Up to 4 kg",
          "Independent, Friendly",
          "No",
          "white, orange",
        ],
        [
          "Poodle",
          12,
          15,
          "poodle",
          "Companion Dogs",
          "Families",
          "Medium-high",
          "12-15 Years",
          "45-60 cm",
          "20-32 kg",
          "Trainable, Intelligent, Faithful, Alert, Instinctual, Active",
          "Yes",
          "Apricot, Black, White, Black & Tan, Cream, Black & White, Red, Silver, Blue, Brown, Sable, Grey",
        ],
        [
          "Portuguese Water Dog",
          12,
          15,
          "portuguese_water_dog",
          "Fishing aid, Working Group",
          "Families, Childrens",
          "High",
          "12-15 years",
          "50-57 cm",
          "18-27 kg",
          "Intelligent, Docile, Obedient, Brave, Impetuous",
          "Yes",
          "Black, White, White and Chocolate",
        ],
        [
          "Pug",
          12,
          15,
          "pug",
          "Companion Dogs",
          "Families and singles",
          "Low",
          "10-12 years",
          "30-36 cm",
          "6-9 kg",
          "Playful, Loyal",
          "Yes",
          "Black, Apricot, Fawn",
        ],
        [
          "Puli",
          12,
          16,
          "default",
          "Herding",
          "Childrens",
          "High",
          "12-16 years",
          "39-45 cm",
          "10-11 kg",
          "Intelligent, Loyal, Agile, Obedient",
          "Yes",
          "Black, White, Brindle, Cream",
        ],
        [
          "Pyrenean Shepherd",
          15,
          17,
          "default",
          "Miscellaneous Class",
          "Childrens",
          "High",
          "15-17 years",
          "40-50 cm",
          "20-25 kg",
          "Dedicated, Watchful, Bossy, Clever",
          "No",
          "Black, White, Merle, Brindle, Fawn",
        ],
        [
          "Redbone Coonhound",
          11,
          12,
          "default",
          "Miscellaneous Class",
          "Families",
          "High",
          "11-12 years",
          "56-68 cm",
          "20-32 kg",
          "Unflappable, Energetic, Companionable, Affectionate, Independent",
          "No",
          "Red & White, Red",
        ],
        [
          "Rhodesian Ridgeback",
          10,
          12,
          "rhodesian_ridgeback",
          "Hound Dogs",
          "Families with older children",
          "Medium – high",
          "10 – 12 years",
          "63–69 cm",
          "36–41 kg",
          "Strong Willed, Intelligent, Mischievous, Loyal, Dignified, Sensitive",
          "No",
          "Red Wheaten, Wheaten, Light Wheaten",
        ],
        [
          "Rottweiler",
          9,
          10,
          "rottweiler",
          "Working Dogs",
          "Families",
          "Medium",
          "8 – 10 years",
          "61 – 69 cm",
          "42 and 50 kg",
          "Obedient, Devoted, Fearless, Courageous, Alert, Self-assured, Good-natured, Calm, Steady, Confident",
          "No",
          "Black, Tan, Mahogany",
        ],
        [
          "Rough Collie",
          14,
          16,
          "default",
          "Herding, agility training, Herding Group",
          "Childrens",
          "Minimal—brushing once a week, bathing once a month, and twice a year they will blow their coat and need a little extra brushing during this time",
          "14-16 years",
          "56-61 cm",
          "20-34 kg",
          "Intelligent, Loyal, Active, Gentle, Friendly",
          "No",
          "White, Blue Merle, Tri0-color, Sable Merle",
        ],
        [
          "Saluki",
          12,
          14,
          "saluki",
          "Coursing gazelle and hare, Hound Group",
          "Childrens",
          "Moderate",
          "12-14 years",
          "23-28 inches",
          "18-27 kg",
          "Aloof, Intelligent, Quiet, Reserved",
          "No",
          "White, Cream, Gold, Tan, Red",
        ],
        [
          "Samoyed",
          12,
          14,
          "samoyed_huskey",
          "Working Dogs",
          "Families",
          "Medium",
          "12 – 13 years",
          "48 – 60 cm",
          "20–30 kg",
          "Playful, Stubborn, Lively, Alert, Friendly, Sociable",
          "Yes",
          "White, Cream",
        ],
        [
          "Schipperke",
          13,
          15,
          "default",
          "Coursing deer, Non-Sporting Group",
          "Childrens and Families",
          "Low",
          "13-15 years",
          "28-33 cm",
          "3-9 kg",
          "Curious, Fearless, Agile, Confident",
          "No",
          "Black, Apricot, Chocolate, Cream",
        ],
        [
          "Scottish Deerhound",
          8,
          11,
          "default",
          "Coursing deer, Hound Group",
          "Older Childrens",
          "Low",
          "8-11 years",
          "30-32 inches",
          "40-50 kg",
          "Dignified, Docile, Gentle, Friendly",
          "No",
          "Brindle, Fawn, Red Fawn, Grey",
        ],
        [
          "Scottish Terrier",
          12,
          15,
          "scottish_terrier",
          "Terrier Dogs",
          "Families with older children, singles",
          "Medium",
          "11-13 years",
          "up to 25 cm",
          "8-10 kg",
          "Independent, Intelligent",
          "No",
          "Dark grey, bringle, black, brown, near-white, blonde",
        ],
        [
          "Sealyham Terrier",
          12,
          14,
          "sealyham_terrier",
          "Terrier Group",
          "Families, older Childrens",
          "Low",
          "12-14 years",
          "28-30 cm",
          "8-9 kg",
          "Even Tempered, Fearless, Alert, Friendly",
          "Yes",
          "White, White & Chocolate, Badger & White",
        ],
        [
          "Shar Pei",
          9,
          11,
          "shar_pei",
          "Working Dogs",
          "Families with older children",
          "Medium",
          "9-11 years",
          "45-51 cm",
          "25-29 kg",
          "Active, independent, happy",
          "No",
          "Black, red, Red-fawn, fawn, black-pointed cream, blue, sable",
        ],
        [
          "Shetland Sheepdog",
          12,
          13,
          "shetland_sheepdog",
          "Herding Dogs",
          "Families",
          "Medium-High",
          "12-14 years",
          "33-41 cm",
          "8-12 kg",
          "Active, Loyal, Independent, Happy",
          "No",
          "Blue Merle, Sable, Tri-colour",
        ],
        [
          "Shiba Inu",
          12,
          15,
          "shiba_inu",
          "Non-Sporting Group",
          "Families",
          "Low",
          "12-15 years",
          "35-43 cm",
          "8-10 kg",
          "Charming, Keen, Confident, Fearless",
          "No",
          "Red Sesame, Black Sesame, Black & Tan",
        ],
        [
          "Shih Tzu",
          10,
          16,
          "shih_tzu",
          "Companion Dogs",
          "Families",
          "Medium-High",
          "10-16 years",
          "20.3-27.9 cm",
          "4-7.5 kg",
          "Intelligent",
          "No",
          "Black, Brown, Gold, Grey and Mixture",
        ],
        [
          "Siberian Huskie",
          12,
          15,
          "siberian_husky",
          "Working Dogs",
          "Singles, families with older children",
          "Medium",
          "12 to 15 years",
          "54–60 cm",
          "18–25 kg",
          "Intelligent, Alert,Outgoing, Gentle, Friendly",
          "No",
          "Black, Agouti, Sable, Piebald, Black & Tan, Grey, Black & White, Splash, Brown, Red, Silver, Copper",
        ],
        [
          "Skye Terrier",
          12,
          15,
          "skye_terrier",
          "Vermin hunting, Terrier group",
          "Families, Childrens and Strangers",
          "Moderate",
          "12-15 years",
          "24-25 cm",
          "16-18 kg",
          "Good-Tempered, Friendly, Loyal, Intelligent",
          "No",
          "Black, Fawn, Blue, Light Grey",
        ],
        [
          "Smooth Fox Terrier",
          12,
          15,
          "smooth_fox_terrier",
          "Fox bolting, Terrier Group",
          "Families",
          "High",
          "12-15 years",
          "36-41 cm",
          "6.8-8.6 kg",
          "Playful, Fearless, Affectionate, Active",
          "No",
          "White, White & Tan, Black & White, Tri-color",
        ],
        [
          "Spinone Italiano",
          12,
          14,
          "default",
          "Sporting Group",
          "Families and Childrens",
          "Low",
          "12-14 years",
          "60-70 cm",
          "34-39 kg",
          "Patient, Docile, Friendly, Gentle",
          "No",
          "Orange & White, Orange Roan, Brown Roan",
        ],
        [
          "St. Bernard",
          8,
          10,
          "saint_bernard",
          "Working Group",
          "Families",
          "High",
          "8-10 years",
          "70-90 cm",
          "64-82 kg",
          "Friendly, Gentle, Loyal, Calm",
          "No",
          "Red & White, Brownish-yellow, Reddish-brown-Mantle",
        ],
        [
          "Staffordshire Bull Terrier",
          12,
          14,
          "default",
          "Bull Terrier",
          "Childrens and Families",
          "Low",
          "12-14 years",
          "36-41 cm",
          "12-17 kg",
          "Fearless, Reliable, Courageous, Loyal, Bold",
          "No",
          "Black, White, Brindle, Fawn & White",
        ],
        [
          "Standard Schnauzer",
          12,
          14,
          "standard_schnnauzer",
          "Working Group, Ratting, guarding",
          "Childrens",
          "High",
          "13-16 years",
          "47-50 cm",
          "14-20 kg",
          "Trainable, Devoted, Good-natured, Lively",
          "Yes",
          "Black, Salt & Pepper",
        ],
        [
          "Sussex Spaniel",
          12,
          15,
          "default",
          "Sporting Group",
          "Families",
          "High",
          "12-15 years",
          "38-41 cm",
          "16-20 kg",
          "Cheerful, Devoted, Calm, Friendly",
          "No",
          "Golden Liver",
        ],
        [
          "Swedish Vallhund",
          12,
          14,
          "swedish_vallhund",
          "Herding Group",
          "Kids, Families and Strangers",
          "Low",
          "12-15 years",
          "32-34 cm",
          "9-14 kg",
          "Intelligent, Watchful, Fearless, Alert",
          "No",
          "Greyish Brown, Mahogany, Blue, Greyish Yellow",
        ],
        [
          "Tibetan Mastiff",
          10,
          12,
          "tibetian_mastiff",
          "Working Group",
          "Childrens",
          "Moderate",
          "12-15 years",
          "66-76 cm",
          "41-68 kg",
          "Stubborn, Active, Strong Willed, Intelligent",
          "No",
          "Black, Brown & Tan, Blue Grey",
        ],
        [
          "Tibetan Spaniel",
          12,
          15,
          "tibetan_spaniel",
          "Non-Sporting Group, Watchdog",
          "Childrens",
          "Moderate",
          "12-15 years",
          "9-10 inches",
          "4.1-6.8 kg",
          "Assertive, Willful, Intelligent, Playful",
          "No",
          "Sable, Black, White, Red, Black & Tan",
        ],
        [
          "Tibetan Terrier",
          12,
          15,
          "tibetan_terrier",
          "Non-Sporting Group",
          "Families",
          "Moderate",
          "12-15 years",
          "14-16 inches",
          "8-14 kg",
          "Amiable, Energetic, Reserved, Sensitive, Gentle",
          "Yes",
          "Piebald, Black, White, Brindle, Tri-color",
        ],
        [
          "Toy Fox Terrier",
          13,
          14,
          "toy_fox_terrier",
          "Terrier Group, Toy Dog",
          "Small Childrens",
          "Low",
          "13-14 years",
          "8.5-11.5 inches",
          "3.5-7 pounds",
          "Intelligent, Spirited, Loyal, Friendly, Playful",
          "No",
          "White & chocolate, White & Tan, Tri-color",
        ],
        [
          "Treeing Walker Coonhound",
          12,
          13,
          "default",
          "Foundation Stock Service Program, Hunters",
          "Childrens",
          "Low",
          "12-13 years",
          "56-69 cm",
          "23-32 kg",
          "Trainable, Confident, Affectionate, Clever",
          "No",
          "Black, White, Tri-color",
        ],
        [
          "Tervuren",
          12,
          14,
          "default",
          "Herding Group",
          "Childrens",
          "Low",
          "12-14 years",
          "60-66 cm",
          "25-29 kg",
          "Attentive, Loyal, Active, Protective",
          "No",
          "Black, Black & Cream, Fawn & Black, Brindle",
        ],
        [
          "Vizsla",
          12,
          15,
          "vizsla",
          "Sporting Group, Pointing and trailing",
          "Families and small Children",
          "High",
          "12-15 years",
          "56-64 cm",
          "20-30 kg",
          "Quiet, Energetic, Loyal, Affectionate",
          "No",
          "Golden Rust, Red Golden, Golden",
        ],
        [
          "Weimaraner",
          10,
          12,
          "weimaraner",
          "Sporting Dogs",
          "Families",
          "Medium",
          "10 – 12 years",
          "64 – 69 cm",
          "32 – 36 kgs",
          "Stubborn, Intelligent, Aloof, Alert, Energetic, Steady, Fast, Powerful",
          "No",
          "Mouse-gray, Silver, Silver-gray",
        ],
        [
          "Welsh Springer Spaniel",
          12,
          15,
          "default",
          "Flushing and retrieving birds, Sporting Group",
          "Families and strangers",
          "Moderate",
          "12-15 years",
          "46-48 cm",
          "16-20 kg",
          "Active, Stubborn, Playful, Loyal",
          "No",
          "White & Red",
        ],
        [
          "Welsh Terrier",
          12,
          15,
          "welsh_terrier",
          "Terrier Dogs",
          "Families & Singles",
          "Low",
          "10 to 14 years",
          "30 – 40 cm",
          "upto 9kg",
          "Intelligent, Alert, Friendly, Spirited",
          "Yes",
          "Black & Tan, Grizzle & Tan",
        ],
        [
          "West Highland White Terrier",
          12,
          16,
          "west_highland_white_terrier",
          "Terrier Group",
          "Families and Children",
          "Low",
          "12-16 years",
          "25-30 cm",
          "6.8-9.1 kg",
          "Intelligent, Courageous, Active, Alert, Loyal",
          "Yes",
          "Pink, Red, Blue, Black, White",
        ],
        [
          "Whippet",
          12,
          15,
          "whippet",
          "Hound Dogs",
          "Families",
          "Medium",
          "12-15 years",
          "47 – 56 cm",
          "10 to 13 kgs",
          "Lively, Quiet, Friendly",
          "No",
          "Black, Brindle, White, Fawn",
        ],
        [
          "Wire Hair Fox Terrier",
          13,
          14,
          "default",
          "Terrier Group",
          "Families and young Children",
          "High",
          "13-14 years",
          "36-41 cm",
          "7-9.5 kg",
          "Keen, Fearless, Active, Bold",
          "Yes",
          "White, White & Tan, Black & White, Tricolor",
        ],
        [
          "Wirehaired Pointing Griffon",
          10,
          12,
          "default",
          "Sporting Group",
          "Children",
          "High",
          "10-12 years",
          "55-60 cm",
          "23-27 kg",
          "Proud, Trainable, Vigilant, Loyal",
          "Yes",
          ";Grey & Tan, White & Chocolate, Chestnut, Liver",
        ],
        [
          "Xoloitzcuintle ",
          12,
          15,
          "xoloitzcuintli",
          "Non-Sporting Group",
          "Families",
          "Moderate",
          "12-15 years",
          "10-14 inches",
          "4-25 kg",
          "Aloof, Cheerful, Active, Calm",
          "Yes",
          "Black, Dark Brown, Brindle, Cooper & White",
        ],
        [
          "Yorkshire Terrier",
          13,
          16,
          "yorkshire_terrier",
          "Companion Dogs",
          "Families, Singles",
          "Low-Medium",
          "12-15 years",
          "15-17.5 cm",
          "Up to 3.2 kg",
          "Loyal, Active",
          "Yes, medium shedding",
          "Blue and tan",
        ],
      ];

      const data = breeds[parseInt(dogBreed1) - 1];

      const firstYearAge = tech_a;
      const secondYearAge = tech_b;
      const restHumanAge = tech_c;
      const dogAverageAge = (data[1] + data[2]) / 2;

      let dogHumanAge = 0;
      if (tech_dogAge > 2) {
        dogHumanAge =
          firstYearAge +
          secondYearAge +
          (tech_dogAge - 2) * (restHumanAge / (dogAverageAge - 2));
      } else if (tech_dogAge > 1) {
        dogHumanAge = firstYearAge + (tech_dogAge - 1) * secondYearAge;
      } else {
        dogHumanAge = tech_dogAge * firstYearAge;
      }

      let type = "";
      if (dogHumanAge > 44) {
        type = " a Senior dog";
      } else if (dogHumanAge > 18) {
        type = " an Adult dog";
      } else {
        type = " a Puppy dog";
      }

      param = {
        tech_dogHumanAge: dogHumanAge,
        tech_type: type,
        tech_data: data,
        tech_name: data[0],
        tech_dogAge: tech_dogAge,
        tech_a: tech_a,
        tech_b: tech_b,
        tech_c: tech_c,
        tech_images: data[3],
        tech_f1: data[4],
        tech_f2: data[5],
        tech_f3: data[6],
        tech_f4: data[7],
        tech_f5: data[8],
        tech_f6: data[9],
        tech_f7: data[10],
        tech_f8: data[11],
        tech_f9: data[12],
      };
    }

    param.tech_operations = tech_operations;
    return param;
  }

  /**
   * getCalculationDogCreateSizeCalculator: Service Method
   * POST: /api/calculators-lol/dog-crate-size-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDogCreateSizeCalculator(body) {
    const extraLength = parseFloat(body.tech_extra_lenght?.toString().trim());
    let dogHeight = parseFloat(body.tech_height?.toString().trim());
    let dogHeightUnit = body.tech_h_units?.toString().trim();
    let dogLength = parseFloat(body.tech_length?.toString().trim());
    let dogLengthUnit = body.tech_l_units?.toString().trim();

    const result = {};

    function convertToCm(value, unit) {
      if (unit === "m") {
        return value * 100;
      } else if (unit === "in") {
        return value * 2.54;
      } else if (unit === "ft") {
        return value * 30.48;
      }
      return value;
    }

    if (!isNaN(dogHeight) && !isNaN(dogLength)) {
      if (dogLengthUnit) {
        dogLength = convertToCm(dogLength, dogLengthUnit);
      }
      if (dogHeightUnit) {
        dogHeight = convertToCm(dogHeight, dogHeightUnit);
      }

      const crateHeight = dogHeight + extraLength;
      const crateLength = dogLength + extraLength;

      result.tech_c_height = crateHeight;
      result.tech_c_lenght = crateLength;
      result.success = true;
    } else {
      result.error = "Please! Check your inputs.";
      result.success = false;
    }

    return result;
  }

  /**
   * getCalculationDogFoodCalculator: Service Method
   * POST: /api/calculators-lol/dog-food-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDogFoodCalculator(body) {
    const result = {};
    const dogType = body.tech_type_unit?.trim();
    let dogWeight = parseFloat(body.tech_weight);
    const weightUnit = body.tech_weight_unit?.trim();

    if (isNaN(dogWeight) || dogWeight <= 0) {
      result.error =
        "The 's weight must be a numeric value greater than zero. 🐕‍🦺";
      return result;
    }

    // Convert weight to kilograms
    switch (weightUnit) {
      case "g":
        dogWeight = dogWeight / 1000;
        break;
      case "dag":
        dogWeight = dogWeight / 100;
        break;
      case "kg":
        break; // already in kg
      case "lb":
        dogWeight = dogWeight / 2.20462;
        break;
      default:
        result.error = "Invalid weight unit";
        return result;
    }

    // Calculate Resting Energy Requirement
    const RER = 70 * Math.pow(dogWeight, 0.75);

    // Map dog type to multiplication factor
    const factorMap = {
      "Puppy - 0 to 4 months": 3.0,
      "Puppy - 4 months to adult": 2.0,
      "Dog - inactive or obese prone": 1.2,
      "Dog (neutered/spayed) - average activity": 1.6,
      "Dog (intact) - average activity": 1.8,
      "Dog - weight loss needed": 1.0,
      "Dog - weight gain needed": 1.7,
      "Working dog - light work": 2.0,
      "Working dog - moderate work": 3.0,
      "Working dog - heavy work": 5.0,
      "Senior dog": 1.1,
    };

    // Check if dogType exists in the map
    const factor = factorMap[dogType];
    if (typeof factor === "undefined") {
      result.error = "Unsupported dog type. Kindly select a valid option.🐶";
      return result;
    }

    const answer = RER * factor;

    result.payload = {
      tech_answer: parseFloat(answer.toFixed(2)),
    };

    return result;
  }

  /**
   * getCalculationDateCalculator: Service Method
   * POST: /api/calculators-lol/date-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDateCalculator(body) {
    console.log(body);
    const result = {};
    let ans = [];
    if (body.locale && body.locale !== "en") {
      const { dateTypes, s_date_duration, e_date_duration, checkbox_duration } =
        body;
    } else {
      // If language is English
      const {
        add_date,
        method,
        years = 0,
        months = 0,
        weeks = 0,
        days = 0,
        repeat = 1,
        add_hrs_f = 0,
        add_min_f = 0,
        add_sec_f = 0,
        add_hrs_s = 0,
        add_min_s = 0,
        add_sec_s = 0,
      } = body;

      if (!add_date || !method) {
        return { error: "Please! Check Your Input." };
      }

      // Create initial moment date object with time if available
      let date = moment(
        `${add_date} ${String(add_hrs_f).padStart(2, "0")}:${String(
          add_min_f
        ).padStart(2, "0")}:${String(add_sec_f).padStart(2, "0")}`,
        "YYYY-MM-DD HH:mm:ss"
      );

      const isTimeIncluded = [
        add_hrs_f,
        add_min_f,
        add_sec_f,
        add_hrs_s,
        add_min_s,
        add_sec_s,
      ].some((val) => parseInt(val) > 0);

      result.from = isTimeIncluded
        ? date.format("dddd, MMM DD, YYYY hh:mm:ss A")
        : date.format("dddd, MMM DD, YYYY");

      for (let i = 0; i < repeat; i++) {
        if (method === "add") {
          date = date
            .add(parseInt(years), "years")
            .add(parseInt(months), "months")
            .add(parseInt(weeks), "weeks")
            .add(parseInt(days), "days");

          if (isTimeIncluded) {
            date = date
              .add(parseInt(add_hrs_s), "hours")
              .add(parseInt(add_min_s), "minutes")
              .add(parseInt(add_sec_s), "seconds");
          }
        } else {
          date = date
            .subtract(parseInt(years), "years")
            .subtract(parseInt(months), "months")
            .subtract(parseInt(weeks), "weeks")
            .subtract(parseInt(days), "days");

          if (isTimeIncluded) {
            date = date
              .subtract(parseInt(add_hrs_s), "hours")
              .subtract(parseInt(add_min_s), "minutes")
              .subtract(parseInt(add_sec_s), "seconds");
          }
        }

        ans.push(
          isTimeIncluded
            ? date.format("dddd, MMM DD, YYYY hh:mm:ss A")
            : date.format("dddd, MMM DD, YYYY")
        );
      }

      result.method = method;
      result.years = String(years).padStart(2, "0");
      result.months = String(months).padStart(2, "0");
      result.weeks = String(weeks).padStart(2, "0");
      result.days = String(days).padStart(2, "0");
      result.add_hrs_f = String(add_hrs_f).padStart(2, "0");
      result.add_min_f = String(add_min_f).padStart(2, "0");
      result.add_sec_f = String(add_sec_f).padStart(2, "0");
      result.add_hrs_s = String(add_hrs_s).padStart(2, "0");
      result.add_min_s = String(add_min_s).padStart(2, "0");
      result.add_sec_s = String(add_sec_s).padStart(2, "0");
      result.ans = ans;
      result.repeat = repeat;
      result.RESULT = 1;

      return result;
    }
  }

  /**
   * getCalculationLeadTimeCalculator: Service Method
   * POST: /api/calculators-lol/date-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLeadTimeCalculator(requestData) {
    try {
      // Ensure the values are treated as numbers before performing calculations
      let calculationType = (requestData.calculationType || "")
        .toString()
        .trim();
      let prepTime = parseFloat(requestData.prepTime) || 0; // Ensure it's a number
      let procTime = parseFloat(requestData.procTime) || 0; // Ensure it's a number
      let postProcTime = parseFloat(requestData.postProcTime) || 0; // Ensure it's a number
      let prepUnits = (requestData.prepUnits || "").toString().trim();
      let procUnits = (requestData.procUnits || "").toString().trim();
      let postProcUnits = (requestData.postProcUnits || "").toString().trim();
      let orderPlaceTime = (requestData.orderPlaceTime || "").toString().trim();
      let orderReceiveTime = (requestData.orderReceiveTime || "")
        .toString()
        .trim();
      let supplyDelay = parseFloat(requestData.supplyDelay) || 0; // Ensure it's a number
      let supplyUnits = (requestData.supplyUnits || "").toString().trim();
      let reqDelay = parseFloat(requestData.reqDelay) || 0; // Ensure it's a number
      let reqUnits = (requestData.reqUnits || "").toString().trim();

      // Function to convert time to hours and minutes
      function convertToHoursMins(time, format = "%02d Hours %02d Minutes") {
        if (time < 1) {
          return;
        }
        let hours = Math.floor(time / 60);
        let minutes = time % 60;
        return sprintf(format, hours, minutes);
      }

      // Function to convert units to a consistent format
      function convert(value, units) {
        if (units === "sec") {
          value = value / 86400;
        } else if (units === "min") {
          value = value / 1440;
        } else if (units === "hrs") {
          value = value / 24;
        } else if (units === "wks") {
          value = value * 7;
        } else if (units === "mos") {
          value = value * 30.417;
        } else if (units === "yrs") {
          value = value * 365;
        }
        return value;
      }

      // Check for valid 'calculationType' and calculate accordingly
      if (calculationType && calculationType !== "") {
        let result = {};
        if (calculationType === "manufac") {
          if (isNaN(prepTime) || isNaN(procTime) || isNaN(postProcTime)) {
            throw new Error("Please! Check Your Input");
          }

          // Apply conversion if units are provided
          if (prepUnits) {
            prepTime = convert(prepTime, prepUnits);
          }
          if (procUnits) {
            procTime = convert(procTime, procUnits);
          }
          if (postProcUnits) {
            postProcTime = convert(postProcTime, postProcUnits);
          }

          // Now add the times correctly as numbers
          let manufacTime = prepTime + procTime + postProcTime; // Ensure it's numerical addition
          result = { prepTime, procTime, postProcTime, manufacTime };
        } else if (calculationType === "order") {
          if (!orderPlaceTime || !orderReceiveTime) {
            throw new Error("Please! Check Your Input");
          }
          let fromTime = Date.parse(orderPlaceTime);
          let toTime = Date.parse(orderReceiveTime);
          let diffMinutes = Math.round(Math.abs(fromTime - toTime) / 60000);
          let timeDiff = convertToHoursMins(diffMinutes);
          result = { timeDiff, diffMinutes };
        } else if (calculationType === "supply") {
          if (isNaN(supplyDelay) || isNaN(reqDelay)) {
            throw new Error("Please! Check Your Input");
          }

          // Apply the correct conversion to supplyDelay and reqDelay
          if (supplyUnits) {
            supplyDelay = convert(supplyDelay, supplyUnits);
          }
          if (reqUnits) {
            reqDelay = convert(reqDelay, reqUnits);
          }

          // Now calculate the correct supply time
          let totalSupplyTime = supplyDelay + reqDelay;
          result = { supplyDelay, reqDelay, totalSupplyTime };
        } else {
          throw new Error("Please! Check Your Input");
        }

        result.calculationType = calculationType;
        result.RESULT = 1;

        return result;
      } else {
        throw new Error("Please! Check Your Input");
      }
    } catch (error) {
      return { error: error.message };
    }
  }

  /**
   * getCalculationReadingTimeCalculator: Service Method
   * POST: /api/calculators-lol/reading-time-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationReadingTimeCalculator(requestData) {
    const readingSpeed = requestData.readingSpeed?.trim();
    let pagesRead = parseFloat(requestData.pagesRead?.trim());
    const unitOfBook = requestData.unitOfBook?.trim();
    const totalLengthOfBook = parseFloat(requestData.totalLengthOfBook?.trim());
    const dailyReadingAmount = parseFloat(
      requestData.dailyReadingAmount?.trim()
    );
    const outputUnit = requestData.outputUnit?.trim();
    const timeUnit = requestData.timeUnit?.trim(); // not used
    const readingOutputUnit = requestData.readingOutputUnit?.trim();
    const periodOutputUnit = requestData.periodOutputUnit?.trim();

    const result = {};

    if (!isNaN(pagesRead) && !isNaN(totalLengthOfBook)) {
      if (unitOfBook === "hr") {
        pagesRead = pagesRead / 60;
      }

      let timeRequired = totalLengthOfBook / pagesRead;
      let formattedTimeRequired;

      if (outputUnit === "min") {
        formattedTimeRequired = `${timeRequired} min`;
      } else if (outputUnit === "hr") {
        timeRequired = timeRequired / 60;
        timeRequired = parseFloat(timeRequired.toFixed(3));
        formattedTimeRequired = `${timeRequired} hrs`;
      } else if (outputUnit === "min/hr") {
        const hours = Math.floor(timeRequired / 60);
        const minutes = timeRequired % 60;
        formattedTimeRequired = `${hours} hrs ${minutes} min`;
      }

      if (!isNaN(dailyReadingAmount)) {
        const readingPerUnit = timeRequired / totalLengthOfBook;
        const readingMinutesPerDay = readingPerUnit * 1440;
        let totalReadingAmount = dailyReadingAmount / readingMinutesPerDay;
        let timeSpent = (timeRequired / dailyReadingAmount) * 1440;

        // Convert totalReadingAmount to required unit
        switch (readingOutputUnit) {
          case "min":
            totalReadingAmount = `${totalReadingAmount.toFixed(3)} min`;
            break;
          case "hr":
            totalReadingAmount = `${totalReadingAmount * 60} hrs`;
            break;
          case "day":
            totalReadingAmount = `${totalReadingAmount * 1440} days`;
            break;
          case "week":
            totalReadingAmount = `${totalReadingAmount * 10080} wks`;
            break;
          case "month":
            totalReadingAmount = `${totalReadingAmount * 43800} mons`;
            break;
          case "year":
            totalReadingAmount = `${totalReadingAmount * 525600} yrs`;
            break;
        }

        // Convert timeSpent to required unit
        switch (periodOutputUnit) {
          case "min":
            timeSpent = `${timeSpent} min`;
            break;
          case "hr":
            timeSpent = `${(timeSpent / 60).toFixed(1)} hrs`;
            break;
          case "day":
            timeSpent = `${(timeSpent / 1440).toFixed(1)} day`;
            break;
          case "week":
            timeSpent = `${(timeSpent / 10080).toFixed(1)} wks`;
            break;
          case "month":
            timeSpent = `${(timeSpent / 43800).toFixed(1)} mons`;
            break;
          case "year":
            timeSpent = `${(timeSpent / 525600).toFixed(1)} yrs`;
            break;
          case "minutes/hour": {
            const hours = Math.floor(timeSpent / 60);
            const minutes = timeSpent % 60;
            timeSpent = `${hours}hr ${minutes}min`;
            break;
          }
          case "year/month/day": {
            const minutesPerYear = 365 * 24 * 60;
            const minutesPerMonth = 30 * 24 * 60;
            const minutesPerDay = 24 * 60;
            const years = Math.floor(timeSpent / minutesPerYear);
            let remainingMinutes = timeSpent % minutesPerYear;
            const months = Math.floor(remainingMinutes / minutesPerMonth);
            remainingMinutes %= minutesPerMonth;
            const days = Math.floor(remainingMinutes / minutesPerDay);
            timeSpent = `${years}year ${months}mon ${days}day`;
            break;
          }
          case "week/day": {
            const minutesPerWeek = 7 * 24 * 60;
            const minutesPerDay = 24 * 60;
            const week = Math.floor(timeSpent / minutesPerWeek);
            const days = Math.floor(
              (timeSpent % minutesPerWeek) / minutesPerDay
            );
            timeSpent = `${week}week ${days}day`;
            break;
          }
          case "day/hour/minutes": {
            const minutesPerDay = 24 * 60;
            const minutesPerHour = 60;
            const days = Math.floor(timeSpent / minutesPerDay);
            const remainingMinutes = timeSpent % minutesPerDay;
            const hours = Math.floor(remainingMinutes / minutesPerHour);
            const minutes = remainingMinutes % minutesPerHour;
            timeSpent = `${days} day, ${hours} hr, ${minutes} min`;
            break;
          }
        }

        result.totalReadingAmount = totalReadingAmount;
        result.timeSpent = timeSpent;
      }

      result.answer = formattedTimeRequired;
      result.RESULT = 1;
    } else {
      result.error = "Please! Check Your Input";
    }

    return result;
  }

  /**
   * getCalculationWorkingDaysCalculator: Service Method
   * POST: /api/calculators-lol/working-days-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationWorkingDaysCalculator(body) {
    const initial_date = body.initial_date?.trim();
    const final_date = body.final_date?.trim();
    const work_days = body.work_days?.trim();
    const include_final_day = body.include_final_day?.trim();

    function calculateWorkDays(start_timestamp, end_timestamp, work_days) {
      let total_days = 0;
      while (start_timestamp <= end_timestamp) {
        const current_day = new Date(start_timestamp).getDay() + 1; // Get day of the week (1 = Monday, 7 = Sunday)

        if (
          work_days === "Exclude weekends" &&
          current_day !== 6 &&
          current_day !== 7
        ) {
          total_days++;
        } else if (work_days === "Exclude only Sunday" && current_day !== 7) {
          total_days++;
        } else if (work_days === "Include all days") {
          total_days++;
        }

        start_timestamp += 24 * 60 * 60 * 1000; // Add 1 day in milliseconds
      }
      return total_days;
    }

    if (initial_date && final_date) {
      const start_timestamp = new Date(initial_date).getTime();
      const end_timestamp = new Date(final_date).getTime();

      if (isNaN(start_timestamp) || isNaN(end_timestamp)) {
        return {
          error: "Invalid date format",
        };
      }

      let total_days = 0;

      if (work_days === "Exclude weekends") {
        total_days = calculateWorkDays(
          start_timestamp,
          end_timestamp,
          "Exclude weekends"
        );
      } else if (work_days === "Exclude only Sunday") {
        total_days = calculateWorkDays(
          start_timestamp,
          end_timestamp,
          "Exclude only Sunday"
        );
      } else {
        total_days = Math.ceil(
          (end_timestamp - start_timestamp) / (1000 * 60 * 60 * 24)
        ); // Days between dates
      }

      if (include_final_day === "No") {
        total_days--;
      }

      return {
        total_working_days: total_days,
        RESULT: 1,
      };
    } else {
      return {
        error: "Please provide both the starting and ending dates",
      };
    }
  }

  /**
   * getCalculationAddTimeCalculator: Service Method
   * POST: /api/calculators-lol/add-time-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAddTimeCalculator(data) {
    const {
      totalEntries,
      hoursArray,
      minutesArray,
      secondsArray,
      millisecondsArray,
      includeHours,
      includeMinutes,
      includeSeconds,
      includeMilliseconds,
    } = data;

    let totalHours = 0;
    let totalMinutes = 0;
    let totalSeconds = 0;
    let totalMilliseconds = 0;

    let hoursList = [];
    let minutesList = [];
    let secondsList = [];
    let millisecondsList = [];

    function normalizeMilliseconds(ms) {
      let secs = 0;
      let mins = 0;
      let hrs = 0;

      if (ms >= 1000) {
        secs += Math.floor(ms / 1000);
        ms %= 1000;
      }

      if (secs >= 60) {
        mins += Math.floor(secs / 60);
        secs %= 60;
      }

      if (mins >= 60) {
        hrs += Math.floor(mins / 60);
        mins %= 60;
      }

      return [hrs, mins, secs, ms];
    }

    for (let i = 0; i < totalEntries; i++) {
      if (!includeHours) hoursArray[i] = 0;
      if (!includeMinutes) minutesArray[i] = 0;
      if (!includeSeconds) secondsArray[i] = 0;
      if (!includeMilliseconds) millisecondsArray[i] = 0;

      if (
        isNaN(hoursArray[i]) ||
        isNaN(minutesArray[i]) ||
        isNaN(secondsArray[i]) ||
        isNaN(millisecondsArray[i])
      ) {
        return { error: "Please! Check Your Input" };
      }

      totalHours += parseInt(hoursArray[i]);
      hoursList.push(hoursArray[i]);

      totalMinutes += parseInt(minutesArray[i]);
      minutesList.push(minutesArray[i]);

      totalSeconds += parseInt(secondsArray[i]);
      secondsList.push(secondsArray[i]);

      totalMilliseconds += parseInt(millisecondsArray[i]);
      millisecondsList.push(millisecondsArray[i]);
    }

    let [h, m, s, ms] = normalizeMilliseconds(totalMilliseconds);
    totalHours += h;
    totalMinutes += m;
    totalSeconds += s;
    totalMilliseconds = ms;

    if (totalMinutes >= 60) {
      totalHours += Math.floor(totalMinutes / 60);
      totalMinutes %= 60;
    }

    if (totalSeconds >= 60) {
      totalMinutes += Math.floor(totalSeconds / 60);
      totalSeconds %= 60;
      if (totalMinutes >= 60) {
        totalHours += Math.floor(totalMinutes / 60);
        totalMinutes %= 60;
      }
    }

    return {
      hoursList,
      minutesList,
      secondsList,
      millisecondsList,
      totalHours,
      totalMinutes,
      totalSeconds,
      totalMilliseconds,
      RESULT: 1,
    };
  }

  /**
   * getCalculationWeekCalculator: Service Method
   * POST: /api/calculators-lol/week-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationWeekCalculator(data) {
    const startDate = data.startDate; // previously: current
    const endDate = data.endDate; // previously: next
    const weekCount = data.weekCount; // previously: number
    const selectionType = data.selectionType; // previously: stype

    let result = {};

    if (selectionType === "s_date") {
      if (isNaN(weekCount)) {
        return { error: "Please input Number of weeks" };
      }
      const date = dayjs(startDate);
      const updatedDate = date.add(Number(weekCount), "week");
      result.addedDate = updatedDate.format("MMMM D, YYYY");
      return result;
    } else if (selectionType === "e_date") {
      if (isNaN(weekCount)) {
        return { error: "Please input Number of weeks" };
      }
      const date = dayjs(startDate);
      const updatedDate = date.subtract(Number(weekCount), "week");
      result.subtractedDate = updatedDate.format("MMMM D, YYYY");
      return result;
    } else {
      const date1 = dayjs(startDate);
      const date2 = dayjs(endDate);
      const diffDays = Math.abs(date1.diff(date2, "day"));
      const totalWeeks = Math.floor(diffDays / 7);
      result.totalWeeks = totalWeeks;
      return result;
    }
  }

  /**
   * getCalculationyearFromTodayCalculator: Service Method
   * POST: /api/calculators-lol/years-from-today
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationyearFromTodayCalculator(body) {
    const yearCount = body.yearCount; // old: number
    const referenceDate = body.referenceDate; // old: current

    let result = {};

    if (isNaN(yearCount)) {
      return { error: "Please add Number of Years" };
    }

    const startDate = dayjs(referenceDate);

    if (yearCount >= 1 || yearCount === 0) {
      const futureDate = startDate.add(Number(yearCount), "year");
      const totalDays = futureDate.diff(startDate, "day");
      const totalWeeks = Math.floor(totalDays / 7);

      result.totalWeeks = totalWeeks;
      result.totalDays = totalDays;
      result.dayName = futureDate.format("dddd");
      result.formattedDate = futureDate.format("MMMM D, YYYY");
      return result;
    } else if (yearCount <= -1) {
      const pastDate = startDate.subtract(Math.abs(yearCount), "year");
      const totalDays = pastDate.diff(startDate, "day");
      const totalWeeks = Math.floor(totalDays / 7);

      result.totalWeeks = totalWeeks.toString(); // will be negative
      result.totalDays = totalDays.toString(); // will be negative
      result.dayName = pastDate.format("dddd");
      result.formattedDate = pastDate.format("MMMM D, YYYY");
      return result;
    }
  }
  /**
   * getCalculationHoursAgoCalculator: Service Method
   * POST: /api/calculators-lol/hours-ago-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationHoursAgoCalculator(body) {
    const inputHour = parseInt(body.inputHour);
    const inputMinute = parseInt(body.inputMinute);
    const inputSecond = parseInt(body.inputSecond);
    const subtractHour = parseInt(body.subtractHour);
    const subtractMinute = parseInt(body.subtractMinute);

    // Create base time using today's date + time
    let currentTime = dayjs()
      .hour(inputHour)
      .minute(inputMinute)
      .second(inputSecond);

    let result = {};

    if (inputHour >= 1 || inputMinute >= 1 || inputSecond >= 1) {
      // Subtract time
      const adjustedTime = currentTime
        .subtract(subtractHour, "hour")
        .subtract(subtractMinute, "minute");
      result.t_date = adjustedTime.format("MMMM D, YYYY");
      result.days = currentTime.diff(adjustedTime, "day");
      result.time = adjustedTime.format("hh:mm A");
      return result;
    } else {
      // Add time
      const adjustedTime = currentTime
        .add(Math.abs(subtractHour), "hour")
        .add(Math.abs(subtractMinute), "minute");
      result.t_date = adjustedTime.format("MMMM D, YYYY");
      result.days = currentTime.diff(adjustedTime, "day"); // still 0 unless cross-day
      result.time = adjustedTime.format("hh:mm A");
      return result;
    }
  }

  /**
   * getCalculationWeeksBetweenDatesCalculator: Service Method
   * POST: /api/calculators-lol/weeks-between-dates-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationWeeksBetweenDatesCalculator(input) {
    const { startDay, startMonth, startYear, endDay, endMonth, endYear } =
      input;

    // Create moment objects for both start and end dates
    const startDate = moment({
      year: startYear,
      month: startMonth - 1,
      day: startDay,
    });
    const endDate = moment({ year: endYear, month: endMonth - 1, day: endDay });

    // Calculate the difference in days
    const totalDaysDifference = endDate.diff(startDate, "days");
    const weeksDifference = Math.floor(totalDaysDifference / 7);
    const remainingDays = totalDaysDifference % 7;

    const result = {
      startDate: startDate.format("YYYY-MM-DD"),
      endDate: endDate.format("YYYY-MM-DD"),
      remainingDays,
      weeksDifference,
    };

    return result;
  }

  /**
   * getCalculationMonthsLeftInTheYearCalculator: Service Method
   * POST: /api/calculators-lol/months-left-in-the-year
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMonthsLeftInTheYearCalculator(input) {
    const { day, month, year } = input;
    const now = moment(`${year}-${month}-${day}`, "YYYY-MM-DD");

    if (Number.isInteger(day)) {
      const isLeapYear = now.isLeapYear();
      const daysInYear = isLeapYear ? 366 : 365;
      const weeksInYear = 52;

      // End of the year
      const endOfYear = moment(`${year}-12-31 23:59:59`, "YYYY-MM-DD HH:mm:ss");

      // Calculate remaining days
      const daysRemaining = endOfYear.diff(now, "days");

      // Calculate remaining weeks and days
      const weeksRemaining = endOfYear.diff(now, "weeks");
      const remainingDaysAfterWeeks = daysRemaining - weeksRemaining * 7;

      // Calculate remaining months and days
      const monthsRemaining = endOfYear.diff(now, "months");
      const remainingDaysAfterMonths = daysRemaining - monthsRemaining * 30; // Approximation

      // Calculate remaining hours
      const hoursRemaining = endOfYear.diff(now, "hours");

      const result = {
        now: now.format("MM-DD-YYYY"),
        daysRemaining: daysRemaining,
        weeksRemaining: weeksRemaining,
        remainingDaysAfterWeeks: remainingDaysAfterWeeks,
        monthsRemaining: monthsRemaining,
        remainingDaysAfterMonths: remainingDaysAfterMonths,
        hoursRemaining: hoursRemaining,
      };

      return result;
    }
  }

  /**
   * getCalculationHowManyDaysUntilBirthdayCalculator: Service Method
   * POST: /api/calculators-lol/how-many-days-until-my-birthday
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationHowManyDaysUntilBirthdayCalculator(input) {
    const { birthdayDay, birthdayMonth, birthdayYear } = input;

    // Parse the provided date of birth
    const dob = moment(
      `${birthdayYear}-${birthdayMonth}-${birthdayDay}`,
      "YYYY-MM-DD"
    );

    // Calculate the age
    const age = moment().diff(dob, "years");

    // Calculate the next birthday
    let nextBirthday = moment(
      `${moment().year()}-${birthdayMonth}-${birthdayDay}`,
      "YYYY-MM-DD"
    );

    if (nextBirthday.isBefore(moment())) {
      nextBirthday = nextBirthday.add(1, "year");
    }

    const daysUntilNextBirthday = nextBirthday.diff(moment(), "days");
    const diffInHours = nextBirthday.diff(moment(), "hours");
    const diffInMinutes = nextBirthday.diff(moment(), "minutes");
    const diffInMonths = nextBirthday.diff(moment(), "months");

    // New Variables
    const nextBirthdayYear = nextBirthday.year(); // The year of the next birthday
    const remainingWeeks = nextBirthday.diff(moment(), "weeks"); // Weeks remaining until next birthday
    const remainingDaysAfterWeeks = daysUntilNextBirthday - remainingWeeks * 7; // Remaining days after full weeks

    const result = {
      dob: dob.format("MM-DD-YYYY"),
      age: age,
      nextBirthday: nextBirthday.format("MM-DD-YYYY"),
      nextBirthdayYear: nextBirthdayYear, // New variable
      daysUntilNextBirthday: daysUntilNextBirthday,
      diffInHours: diffInHours,
      diffInMinutes: diffInMinutes,
      diffInMonths: diffInMonths,
      remainingWeeks: remainingWeeks, // New variable
      remainingDaysAfterWeeks: remainingDaysAfterWeeks, // New variable
    };

    return result;
  }

  /**
   * getCalculationMonthsFromNowCalculator: Service Method
   * POST: /api/calculators-lol/months-from-now
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMonthsFromNowCalculator(input) {
    let { monthnumber, presencedate } = input;

    // Check if the 'number' is a valid number
    if (!isNaN(monthnumber)) {
      monthnumber = parseInt(monthnumber);
      let response = {};

      // Handling months addition
      if (monthnumber >= 1 || monthnumber === 0) {
        const date1 = moment(presencedate);
        const dateAfterAddingMonths = date1.add(monthnumber, "months");
        const isLeapYear = dateAfterAddingMonths.isLeapYear();
        const daysInYear = isLeapYear ? 366 : 365;
        const weeksInYear = 52;
        const currentWeekOfYear = dateAfterAddingMonths.week();
        const currentDayOfYear = dateAfterAddingMonths.dayOfYear();

        response.date_name = dateAfterAddingMonths.format("dddd");
        response.t_date = dateAfterAddingMonths.format("MMMM D, YYYY");
        response.daysInYear = daysInYear;
        response.weeksInYear = weeksInYear;
        response.currentWeekOfYear = currentWeekOfYear;
        response.currentDayOfYear = currentDayOfYear;

        return response;
      }
      // Handling months subtraction
      else if (monthnumber <= -1) {
        const date2 = moment(presencedate);
        const dateAfterSubtractingMonths = date2.subtract(
          Math.abs(monthnumber),
          "months"
        );
        const isLeapYear = dateAfterSubtractingMonths.isLeapYear();
        const daysInYear = isLeapYear ? 366 : 365;
        const weeksInYear = 52;
        const currentWeekOfYear = dateAfterSubtractingMonths.week();
        const currentDayOfYear = dateAfterSubtractingMonths.dayOfYear();

        response.daysInYear = daysInYear;
        response.weeksInYear = weeksInYear;
        response.currentWeekOfYear = currentWeekOfYear;
        response.currentDayOfYear = currentDayOfYear;
        response.date_name = dateAfterSubtractingMonths.format("dddd");
        response.t_date = dateAfterSubtractingMonths.format("MMMM D, YYYY");

        return response;
      }
    } else {
      return { error: "Please add number of Months" };
    }
  }

  /**
   * getCalculationDaysLeftInTheYearCalculator: Service Method
   * POST: /api/calculators-lol/days-left-in-the-year
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDaysLeftInTheYearCalculator(data) {
    const { inputDay, inputMonth, inputYear } = data;

    if (!isNaN(inputDay) && !isNaN(inputMonth) && !isNaN(inputYear)) {
      const formattedDay = String(inputDay).padStart(2, "0");
      const formattedMonth = String(inputMonth).padStart(2, "0");

      const selectedDate = dayjs(
        `${inputYear}-${formattedMonth}-${formattedDay}`,
        "YYYY-MM-DD"
      );

      if (!selectedDate.isValid()) {
        return {
          status: "error",
          message: "Invalid date format.",
        };
      }

      const finalDayOfYear = dayjs(`${inputYear}-12-31T23:59:59`);
      const leapYear = selectedDate.isLeapYear();
      const totalDaysInYear = leapYear ? 366 : 365;

      const totalDaysLeft = finalDayOfYear.diff(selectedDate, "day");
      const fullWeeksLeft = Math.floor(totalDaysLeft / 7);
      const leftoverDaysAfterWeeks = totalDaysLeft % 7;

      const monthsLeft = finalDayOfYear.diff(selectedDate, "month");
      const leftoverDaysAfterMonths = totalDaysLeft - monthsLeft * 30; // Approximation

      const hoursLeft = finalDayOfYear.diff(selectedDate, "hour");

      return {
        status: "success",
        payload: {
          currentDate: selectedDate.format("MM-DD-YYYY"),
          totalDaysLeft,
          fullWeeksLeft,
          leftoverDaysAfterWeeks,
          monthsLeft,
          leftoverDaysAfterMonths,
          hoursLeft,
        },
      };
    }

    return {
      status: "error",
      message: "Invalid input: day, month, and year must be numeric.",
    };
  }
  /**
   * getCalculationYearAgoCalculator: Service Method
   * POST: /api/calculators-lol/years-ago-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationYearAgoCalculator(inputData) {
    const { yearCount, currentDate } = inputData;

    if (!isNaN(yearCount)) {
      const current = dayjs(currentDate, "YYYY-MM-DD");

      if (!current.isValid()) {
        return {
          status: "error",
          message: "Invalid current date format. Use YYYY-MM-DD",
        };
      }

      let resultDate;
      if (yearCount >= 1) {
        resultDate = current.subtract(yearCount, "year");
      } else {
        resultDate = current.add(Math.abs(yearCount), "year");
      }

      const dayDifference = current.diff(resultDate, "day");
      const weekDifference = Math.floor(dayDifference / 7);
      const monthDifference = current.diff(resultDate, "month");

      return {
        status: "success",
        payload: {
          totalDays: dayDifference,
          totalWeeks: weekDifference,
          totalMonths: monthDifference,
          resultDayName: resultDate.format("dddd"),
          formattedDate: resultDate.format("MMMM D, YYYY"),
        },
      };
    } else {
      return {
        status: "error",
        message: "Please provide a valid number of years.",
      };
    }
  }

  /**
   * getCalculationHoursFromNowCalculator: Service Method
   * POST: /api/calculators-lol/hours-from-now
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationHoursFromNowCalculator(inputData) {
    const {
      hourValue, // Original: hours
      minuteValue, // Original: minuts
      secondValue, // Original: sec
      addHours, // Original: hrs
      addMinutes, // Original: min
    } = inputData;

    if (
      [hourValue, minuteValue, secondValue, addHours, addMinutes].some((val) =>
        isNaN(val)
      )
    ) {
      return {
        status: "error",
        message: "All inputs must be numeric.",
      };
    }

    const initialTime = dayjs()
      .hour(Number(hourValue))
      .minute(Number(minuteValue))
      .second(Number(secondValue));

    const newTime = initialTime
      .add(Number(addHours), "hour")
      .add(Number(addMinutes), "minute");

    return {
      status: "success",
      originalTime: initialTime.format("hh:mm:ss A"), // 12-hour format
      updatedTime: newTime.format("hh:mm:ss A"), // 12-hour format
    };
  }

  /**
   * getCalculationDaysFromTodayCalculator: Service Method
   * POST: /api/calculators-lol/days-from-today
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDaysFromTodayCalculator(body) {
    const {
      dateValue, // original: current
      daysOffset, // original: number
    } = body;

    if (isNaN(daysOffset)) {
      return { status: "error", message: "Please add a valid number of days" };
    }

    const parsedDate = dayjs(dateValue, [
      "YYYY-MM-DD",
      "MM/DD/YYYY",
      "DD-MM-YYYY",
    ]);
    if (!parsedDate.isValid()) {
      return { status: "error", message: "Invalid date format" };
    }

    let newDate;
    if (daysOffset >= 1 || daysOffset == 0) {
      newDate = parsedDate.add(Number(daysOffset), "day");
    } else {
      newDate = parsedDate.subtract(Math.abs(daysOffset), "day");
    }

    return {
      status: "success",
      daysdateName: newDate.format("dddd"),
      daysfullDate: newDate.format("MMMM D, YYYY"),
      daysukDate: newDate.format("D MMMM, YYYY"),
      daysdmy: newDate.format("DD/MM/YY"),
      daysmdy: newDate.format("MM/DD/YY"),
      daysiso: newDate.format("YYYY-MM-DD"),
    };
  }

  /**
   * getCalculationDaysElapsedTimeCalculator: Service Method
   * POST: /api/calculators-lol/elapsed-time-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDaysElapsedTimeCalculator(body) {
    let result = {};
    let {
      time_units,
      start_time,
      start_time_one,
      start_time_sec,
      start_time_three,
      start_time_unit,
      end_time,
      end_time_one,
      end_time_sec,
      end_time_three,
      end_time_unit,
      time_format,
      start_hour,
      start_minute,
      start_second,
      start_unit,
      end_hour,
      end_minute,
      end_second,
      end_unit,
    } = body;

    function timeUnit(start_time, start_time_unit) {
      if (start_time_unit === "sec") {
        return start_time;
      } else if (start_time_unit === "mins") {
        return start_time * 60;
      } else if (start_time_unit === "hrs") {
        return start_time * 3600;
      }
      return start_time;
    }

    function otherTime(start_time_one, start_time_sec, start_time_unit) {
      let interval;
      if (start_time_unit === "mins/sec") {
        interval = start_time_one * 60 + start_time_sec;
      } else if (start_time_unit === "hrs/mins") {
        interval = start_time_one * 3600 + start_time_sec * 60;
      }
      return interval;
    }

    function otherTimeSec(
      start_time_one,
      start_time_sec,
      start_time_three,
      start_time_unit
    ) {
      let interval;
      if (start_time_unit === "hrs/mins/sec") {
        interval =
          start_time_one * 3600 + start_time_sec * 60 + start_time_three;
      }
      return interval;
    }

    if (time_units === "elapsed") {
      if (
        !isNaN(start_time) &&
        !isNaN(start_time_one) &&
        !isNaN(start_time_sec) &&
        !isNaN(start_time_three) &&
        !isNaN(end_time) &&
        !isNaN(end_time_one) &&
        !isNaN(end_time_sec) &&
        !isNaN(end_time_three)
      ) {
        if (["sec", "mins", "hrs"].includes(start_time_unit)) {
          start_time = timeUnit(start_time, start_time_unit);
        } else if (start_time_unit === "hrs/mins/sec") {
          start_time = otherTimeSec(
            start_time_one,
            start_time_sec,
            start_time_three,
            start_time_unit
          );
        } else {
          start_time = otherTime(
            start_time_one,
            start_time_sec,
            start_time_unit
          );
        }

        if (["sec", "mins", "hrs"].includes(end_time_unit)) {
          end_time = timeUnit(end_time, end_time_unit);
        } else if (end_time_unit === "hrs/mins/sec") {
          end_time = otherTimeSec(
            end_time_one,
            end_time_sec,
            end_time_three,
            end_time_unit
          );
        } else {
          end_time = otherTime(end_time_one, end_time_sec, end_time_unit);
        }

        if (end_time < start_time) {
          result.error = "The end time should be greater than the start time";
          return result;
        }

        let timeElapsedStart = moment.duration(start_time, "seconds");
        let timeElapsedEnd = moment.duration(end_time, "seconds");
        let diff = moment.duration(end_time - start_time, "seconds");

        let hours = diff.hours();
        let minutes = diff.minutes();
        let seconds = diff.seconds();

        result.Elapsedanswer = end_time - start_time;
        result.Elapsedhours = hours;
        result.Elapsedminutes = minutes;
        result.Elapsedseconds = seconds;
      } else {
        result.error = "Please! Check Your Input";
        return result;
      }
    } else {
      if (time_format === "24") {
        if (
          !isNaN(start_hour) &&
          !isNaN(start_minute) &&
          !isNaN(start_second) &&
          !isNaN(end_hour) &&
          !isNaN(end_minute) &&
          !isNaN(end_second)
        ) {
          // Validation to ensure the hour, minute, and second are within acceptable ranges
          // Validate start time hours, minutes, and seconds
          if (start_hour >= 24) {
            result.error = "Start clock time hour should be less than 24";
            return result;
          }
          if (start_minute >= 60) {
            result.error = "Start clock time minute should be less than 60";
            return result;
          }
          if (start_second >= 60) {
            result.error = "Start clock time second should be less than 60";
            return result;
          }

          // Validate end time hours, minutes, and seconds
          if (end_hour >= 24) {
            result.error = "End clock time hour should be less than 24";
            return result;
          }
          if (end_minute >= 60) {
            result.error = "End clock time minute should be less than 60";
            return result;
          }
          if (end_second >= 60) {
            result.error = "End clock time second should be less than 60";
            return result;
          }
          let startClock = start_hour * 3600 + start_minute * 60 + start_second;
          let endClock = end_hour * 3600 + end_minute * 60 + end_second;
          let answer = endClock - startClock;

          let diff = moment.duration(answer, "seconds");
          result.Elapsedhours = diff.hours();
          result.Elapsedminutes = diff.minutes();
          result.Elapsedseconds = diff.seconds();

          // Add the answer field here
          result.Elapsedanswer = answer;
        } else {
          result.error = "Please! Check Your Input";
          return result;
        }
      } else {
        if (
          !isNaN(start_hour) &&
          !isNaN(start_minute) &&
          !isNaN(start_second) &&
          !isNaN(end_hour) &&
          !isNaN(end_minute) &&
          !isNaN(end_second)
        ) {
          if (start_hour >= 12) {
            result.error = "Start time hour must be less than 12.";
            return result;
          }
          if (start_minute >= 60) {
            result.error = "Start time minute must be less than 60.";
            return result;
          }
          if (start_second >= 60) {
            result.error = "Start time second must be less than 60.";
            return result;
          }

          // Validate end time hours, minutes, and seconds for 12-hour format
          if (end_hour >= 12) {
            result.error = "End time hour must be less than 12.";
            return result;
          }
          if (end_minute >= 60) {
            result.error = "End time minute must be less than 60.";
            return result;
          }
          if (end_second >= 60) {
            result.error = "End time second must be less than 60.";
            return result;
          }

          // Convert 12-hour format to 24-hour format
          if (start_unit === "PM" && start_hour !== 12) {
            start_hour += 12;
          }

          if (end_unit === "PM" && end_hour !== 12) {
            end_hour += 12;
          }

          let startTime = start_hour * 3600 + start_minute * 60 + start_second;
          let endTime = end_hour * 3600 + end_minute * 60 + end_second;
          let answer = endTime - startTime;
          console.log(answer);
          let diff = moment.duration(answer, "seconds");
          result.Elapsedhours = -diff.hours();
          result.Elapsedminutes = -diff.minutes();
          result.Elapsedseconds = -diff.seconds();

          // Handle negative answer (PM to AM)
          if (answer < 0) {
            answer += 24 * 60 * 60; // Add 24 hours in seconds
          }

          result.Elapsedanswer = answer;
        } else {
          result.error = "Please! Check Your Input";
          return result;
        }
      }
    }

    result.RESULT = 1;
    return result;
  }

  /**
   * getCalculationMonthCalculator: Service Method
   * POST: /api/calculators-lol/month-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMonthCalculator(body) {
    let result = {};

    let { first_date, last_date } = body;

    if (first_date && last_date) {
      let datetime1 = moment(first_date);
      let datetime2 = moment(last_date);
      let diff = datetime2.diff(datetime1, "months"); // Get the difference in months
      let months = diff;
      let days = datetime2.diff(datetime1.add(diff, "months"), "days"); // Get remaining days after months

      result.Finalmonths = months;
      result.Finaldays = days;
      result.RESULT = 1;
    } else {
      result.error = "Check your input, please";
    }

    return result;
  }

  /**
   * getCalculationDateDurationCalculator: Service Method
   * POST: /api/calculators-lol/date-duration-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  // dateDurationCalculator.js
  async getCalculationDateDurationCalculator(body) {
    const { s_date, e_date, checkbox } = body;
    const result = {};

    if (!s_date || !e_date) {
      result.error = "Please! Check Your Input.";
      return result;
    }

    let start = dayjs(s_date, "YYYY-MM-DD");
    let end = dayjs(e_date, "YYYY-MM-DD");

    // ✅ Include end date if checkbox is true
    let displayEnd = end;
    if (checkbox) {
      end = end.add(1, "day"); // Include end date in calculation
      displayEnd = end.subtract(1, "day"); // But display original end date
    }

    // Swap if start is after end
    if (start.isAfter(end)) {
      [start, end] = [end, start];
    }

    const fromFormatted = start.format("MMM DD, YYYY");
    const toFormatted = displayEnd.format("MMM DD, YYYY");

    // Calculate year, month, day difference manually
    let tempStart = start.clone();
    let years = 0,
      months = 0,
      days = 0;

    while (tempStart.add(1, "year").isSameOrBefore(end)) {
      tempStart = tempStart.add(1, "year");
      years++;
    }

    while (tempStart.add(1, "month").isSameOrBefore(end)) {
      tempStart = tempStart.add(1, "month");
      months++;
    }

    while (tempStart.add(1, "day").isSameOrBefore(end)) {
      tempStart = tempStart.add(1, "day");
      days++;
    }

    // Total seconds between
    const diffInSeconds = Math.abs(end.unix() - start.unix());

    // Remove seconds from Y/M/D
    const totalUsedSec =
      years * 365 * 24 * 60 * 60 +
      months * 30 * 24 * 60 * 60 +
      days * 24 * 60 * 60;
    const remaining = diffInSeconds - totalUsedSec;

    const hrs = Math.floor(remaining / 3600);
    const mins = Math.floor((remaining % 3600) / 60);
    const secs = remaining % 60;

    return {
      from: fromFormatted,
      to: toFormatted,
      years,
      months,
      days,
      hours: hrs,
      minutes: mins,
      seconds: secs,
      RESULT: 1,
    };
  }

  /**
   * getCalculationDaysSinceDateCalculator: Service Method
   * POST: /api/calculators-lol/days-since-date-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDaysSinceDateCalculator(body) {
    // Destructuring inputs from the request body
    const { day, month, year, day1, month1, year1 } = body;

    // Creating two date objects using moment.js
    const date1 = moment([year, month - 1, day]); // month in moment.js is 0-based
    const date2 = moment([year1, month1 - 1, day1]);

    // Getting the total difference in days
    const totalDays = date2.diff(date1, "days");

    let workingDays = 0;
    let holidays = 0;
    let currentDate = date1.clone(); // Clone the date to avoid modifying the original

    // Looping through each date from date1 to date2
    while (currentDate.isBefore(date2) || currentDate.isSame(date2)) {
      if (currentDate.isoWeekday() === 6 || currentDate.isoWeekday() === 7) {
        // If the day is Saturday (6) or Sunday (7), it's a holiday
        holidays++;
      } else {
        // Otherwise, it's a working day
        workingDays++;
      }
      currentDate.add(1, "days");
    }

    holidays = totalDays - workingDays;

    // Returning the result
    return {
      workingDays,
      holidays,
      totalDays,
    };
  }

  /**
   * getCalculationDaysSinceDateCalculator: Service Method
   * POST: /api/calculators-lol/weeks-left-in-the-year
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationWeekLeftInTheYearCalculator(body) {
    // Destructuring the input from the request body
    const { day, month, year } = body;

    // Create a moment object for the given date
    const now = moment([year, month - 1, day]); // Month is 0-based in moment.js

    if (isNaN(day)) {
      return { error: "Invalid day input" };
    }

    // Check if it's a leap year
    const isLeapYear = now.isLeapYear();
    const daysInYear = isLeapYear ? 366 : 365;
    const weeksInYear = 52;

    // Get the last day of the year
    const endOfYear = moment([year, 11, 31, 23, 59, 59]); // December 31st, 23:59:59

    // Calculate remaining days in the year
    const daysRemaining = endOfYear.diff(now, "days");

    // Calculate remaining weeks
    const weeksRemaining = endOfYear.diff(now, "weeks");

    // Calculate remaining days after full weeks
    const remainingDaysAfterWeeks = daysRemaining - weeksRemaining * 7;

    // Calculate remaining months and approximate days
    const monthsRemaining = endOfYear.diff(now, "months");
    const remainingDaysAfterMonths = daysRemaining - monthsRemaining * 30; // Approximation of days in month

    // Calculate remaining hours
    const hoursRemaining = endOfYear.diff(now, "hours");

    // Returning the result in the response
    return {
      now: now.format("MM-DD-YYYY"),
      daysRemaining,
      weeksRemaining,
      remainingDaysAfterWeeks,
      monthsRemaining,
      remainingDaysAfterMonths,
      hoursRemaining,
    };
  }

  /**
   * getCalculationJuliansDateCalculator: Service Method
   * POST: /api/calculators-lol/julians-date-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationJuliansDateCalculator(body) {
    let { day, month, year, timecheck, julian } = body;

    const dob = `${year}-${month.toString().padStart(2, "0")}-${day
      .toString()
      .padStart(2, "0")}`;
    const date1 = new Date(dob).toLocaleDateString("en-US", {
      weekday: "long",
      year: "numeric",
      month: "long",
      day: "numeric",
    });

    if (timecheck === "stat") {
      // Handling Julian date calculation (Gregorian to Julian conversion)
      if (month <= 2) {
        year -= 1;
        month += 12;
      }
      const A = Math.floor(year / 100);
      const B = 2 - A + Math.floor(A / 4);
      const julianDate =
        Math.floor(365.25 * (year + 4716)) +
        Math.floor(30.6001 * (month + 1)) +
        day +
        B -
        1524.5;
      return { julianDate, date1 };
    } else {
      if (!julian) {
        return { error: "Please Enter Julian Date" };
      }

      julian += 0.5; // Adding 0.5 for fractional days

      let Z = Math.floor(julian);
      let F = julian - Z;

      let A;
      if (Z < 2299161) {
        A = Z;
      } else {
        const alpha = Math.floor((Z - 1867216.25) / 36524.25);
        A = Z + 1 + alpha - Math.floor(alpha / 4);
      }

      const B = A + 1524;
      const C = Math.floor((B - 122.1) / 365.25);
      const D = Math.floor(365.25 * C);
      const E = Math.floor((B - D) / 30.6001);

      day = B - D - Math.floor(30.6001 * E) + F;
      if (E < 14) {
        month = E - 1;
      } else {
        month = E - 13;
      }

      if (month > 2) {
        year = C - 4716;
      } else {
        year = C - 4715;
      }

      year = Math.floor(year);
      month = Math.floor(month);
      day = Math.floor(day);

      // Formatting the year as negative if it is below 1 (Before Christ)
      if (year < 1) {
        year = -Math.abs(year); // Ensure that the year is negative (e.g., -4712)
      }

      // Format the Julian date output
      const julDate = `${new Date(year, month - 1, day).toLocaleDateString(
        "en-US",
        { weekday: "long", month: "long", day: "numeric" }
      )}, ${year}`;

      return { jul_date: julDate, date1 };
    }
  }

  /**
   * getCalculationWeekAgoCalculator: Service Method
   * POST: /api/calculators-lol/weeks-ago-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationWeekAgoCalculator(body) {
    let { number, current } = body;

    // Ensure number is a valid number and not a string like '0'
    if (typeof number === "number" && !isNaN(number)) {
      if (number <= -1 || number === 0) {
        // Adding weeks in the past
        const date1 = dayjs(current);
        const dateAfterAddingWeeks = date1.add(Math.abs(number), "week"); // Add weeks in absolute value

        // Determine leap year and days in year
        const isLeapYear = dateAfterAddingWeeks.isLeapYear();
        const daysInYear = isLeapYear ? 366 : 365;
        const weeksInYear = 52;

        // Get ISO week of the year and day of the year
        const currentWeekOfYear = dateAfterAddingWeeks.isoWeek(); // ISO 8601 week
        const currentDayOfYear = dateAfterAddingWeeks.dayOfYear();

        // Prepare response
        const result = {
          date_name: dateAfterAddingWeeks.format("dddd"),
          t_date: dateAfterAddingWeeks.format("MMMM D, YYYY"),
          daysInYear: daysInYear,
          weeksInYear: weeksInYear,
          currentWeekOfYear: currentWeekOfYear,
          currentDayOfYear: currentDayOfYear,
        };

        return result;
      } else if (number >= 1) {
        // Subtracting weeks in the future
        const date2 = dayjs(current);
        const dateAfterSubtractingWeeks = date2.subtract(number, "week");

        // Determine leap year and days in year
        const isLeapYear = dateAfterSubtractingWeeks.isLeapYear();
        const daysInYear = isLeapYear ? 366 : 365;
        const weeksInYear = 52;

        // Get ISO week of the year and day of the year
        const currentWeekOfYear = dateAfterSubtractingWeeks.isoWeek(); // ISO 8601 week
        const currentDayOfYear = dateAfterSubtractingWeeks.dayOfYear();

        // Prepare response
        const result = {
          date_name: dateAfterSubtractingWeeks.format("dddd"),
          t_date: dateAfterSubtractingWeeks.format("MMMM D, YYYY"),
          daysInYear: daysInYear,
          weeksInYear: weeksInYear,
          currentWeekOfYear: currentWeekOfYear,
          currentDayOfYear: currentDayOfYear,
        };

        return result;
      }
    } else {
      return { error: "Please add Number of Weeks" };
    }
  }

  /**
   * getCalculationtimeUntilCalculator: Service Method
   * POST: /api/calculators-lol/time-until-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationtimeUntilCalculator(body) {
    let { current, next } = body;

    // Parse the input dates
    const currentTime = dayjs(current);
    const nextTime = dayjs(next);
    const today = dayjs();

    // Validate the dates
    if (!currentTime.isValid() || !nextTime.isValid()) {
      return { error: "Please enter valid dates" };
    }

    // Check if next date is in the past
    if (nextTime.isBefore(today)) {
      return { error: "Next date cannot be less than today's date." };
    }

    // Calculate total difference in seconds
    const totalSeconds = nextTime.diff(currentTime, "second");

    // Convert seconds into years, months, days, hours, minutes, seconds
    const years = Math.floor(totalSeconds / (365 * 24 * 60 * 60));
    const months = Math.floor(
      (totalSeconds % (365 * 24 * 60 * 60)) / (30 * 24 * 60 * 60)
    );
    const days = Math.floor(
      (totalSeconds % (30 * 24 * 60 * 60)) / (24 * 60 * 60)
    );
    const hours = Math.floor((totalSeconds % (24 * 60 * 60)) / (60 * 60));
    const minutes = Math.floor((totalSeconds % (60 * 60)) / 60);
    const seconds = totalSeconds % 60;

    // Prepare the response
    const result = {
      years: years,
      months: months,
      days: days,
      hours: hours,
      minutes: minutes,
      seconds: seconds,
    };

    return result;
  }

  /**
   * getCalculationWeekFromTodayCalculator: Service Method
   * POST: /api/calculators-lol/time-until-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationWeekFromTodayCalculator(body) {
    let { number, current } = body;

    // Ensure 'number' is a valid number
    if (typeof number === "number" && !isNaN(number)) {
      let date1 = dayjs(current); // Parse the current date input

      let dateAfterAddingDays;
      let daysInYear, weeksInYear, currentWeekOfYear, currentDayOfYear;

      if (number >= 1 || number === 0) {
        // Adding weeks
        dateAfterAddingDays = date1.add(Math.abs(number), "week");
      } else if (number <= -1) {
        // Subtracting weeks
        dateAfterAddingDays = date1.subtract(Math.abs(number), "week");
      }

      // Determine if the year is a leap year
      const isLeapYear = dateAfterAddingDays.isLeapYear();
      daysInYear = isLeapYear ? 366 : 365;
      weeksInYear = 52;

      // Get week of the year and day of the year
      currentWeekOfYear = dateAfterAddingDays.isoWeek(); // ISO 8601 week number
      currentDayOfYear = dateAfterAddingDays.dayOfYear();

      // Prepare response
      const result = {
        date_name: dateAfterAddingDays.format("dddd"), // Day name
        t_date: dateAfterAddingDays.format("MMMM D, YYYY"), // Formatted date
        daysInYear: daysInYear,
        weeksInYear: weeksInYear,
        currentWeekOfYear: currentWeekOfYear,
        currentDayOfYear: currentDayOfYear,
      };

      return result;
    } else {
      return { error: "Please add Number of Weeks" };
    }
  }

  /**
   * getCalculationDaysUntilCalculator: Service Method
   * POST: /api/calculators-lol/birth-year-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBirthYearCalculator(body) {
    const { date, age, age_unit, choose, submit } = body;

    // Validate inputs
    if (date && !isNaN(age) && choose && age_unit) {
      let newYear;

      // Parse the date
      let parsedDate = dayjs(date);

      if (!parsedDate.isValid()) {
        return { status: "error", message: "Invalid date input" };
      }

      // Subtract age based on the age unit
      switch (age_unit) {
        case "years":
          newYear = parsedDate.subtract(age, "year").year();
          break;
        case "months":
          newYear = parsedDate.subtract(age, "month").year();
          break;
        case "weeks":
          newYear = parsedDate.subtract(age, "week").year();
          break;
        case "days":
          newYear = parsedDate.subtract(age, "day").year();
          break;
        case "hours":
          newYear = parsedDate.subtract(age, "hour").year();
          break;
        case "minutes":
          newYear = parsedDate.subtract(age, "minute").year();
          break;
        case "seconds":
          newYear = parsedDate.subtract(age, "second").year();
          break;
        default:
          return { status: "error", message: "Invalid age unit" };
      }

      // If 'choose' is 'before', subtract 1 from the year
      if (choose === "before") {
        newYear -= 1;
      }

      // Return the result
      return {
        status: "success",
        payload: {
          newYear: newYear,
        },
      };
    } else {
      return { status: "error", message: "Please! Check Your Input" };
    }
  }

  /**
   * getCalculationDeadlineCalculator: Service Method
   * POST: /api/calculators-lol/deadline-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDeadlineCalculator(body) {
    const { date, period, Number, before_after } = body;

    // Validate the inputs
    if (!date || isNaN(Number)) {
      return { status: "error", message: "Please check your input." };
    }

    // Validate the date format
    const parsedDate = dayjs(date);
    if (!parsedDate.isValid()) {
      return {
        status: "error",
        message: "Invalid date format. Please use YYYY-MM-DD.",
      };
    }

    let interval;

    // Handle the period (Days, Weeks, Years)
    if (period === "Days") {
      interval = "day";
    } else if (period === "Weeks") {
      interval = "week";
    } else if (period === "Years") {
      interval = "year";
    } else {
      return {
        status: "error",
        message: "Invalid period. Please select Days, Weeks, or Years.",
      };
    }

    // Perform the calculation based on before_after
    let result;
    if (before_after === "Before") {
      result = parsedDate.subtract(Number, interval);
    } else {
      result = parsedDate.add(Number, interval);
    }

    // Format the result in "M dd, YYYY" format
    const formattedResult = result.format("MMM DD, YYYY");

    return {
      status: "success",
      payload: {
        answer: formattedResult,
        RESULT: 1,
      },
    };
  }

  /**
   * getCalculationMilitaryTimeConverterCalculator: Service Method
   * POST: /api/calculators-lol/military-time-converter
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMilitaryTimeConverterCalculator(body) {
    const { conversion, military_time } = body;

    function eng_time(num) {
      const reading = [
        "zero ",
        "one ",
        "two ",
        "three ",
        "four ",
        "five ",
        "six ",
        "seven ",
        "eight ",
        "nine ",
        "ten ",
        "eleven ",
        "twelve ",
        "thirteen ",
        "fourteen ",
        "fifteen ",
        "sixteen ",
        "seventeen ",
        "eighteen ",
        "nineteen ",
        "twenty ",
        "twenty-one ",
        "twenty-two ",
        "twenty-three ",
        "twenty-four ",
        "twenty-five ",
        "twenty-six ",
        "twenty-seven ",
        "twenty-eight ",
        "twenty-nine ",
        "thirty ",
        "thirty-one ",
        "thirty-two ",
        "thirty-three ",
        "thirty-four ",
        "thirty-five ",
        "thirty-six ",
        "thirty-seven ",
        "thirty-eight ",
        "thirty-nine ",
        "forty ",
        "forty-one ",
        "forty-two ",
        "forty-three ",
        "forty-four ",
        "forty-five ",
        "forty-six ",
        "forty-seven ",
        "forty-eight ",
        "forty-nine ",
        "fifty ",
        "fifty-one ",
        "fifty-two ",
        "fifty-three ",
        "fifty-four ",
        "fifty-five ",
        "fifty-six ",
        "fifty-seven ",
        "fifty-eight ",
        "fifty-nine ",
      ];

      let f_two = num.substring(0, 2); // hour
      let l_two = num.substring(2, 4); // minute
      let hr = reading[parseInt(f_two)];
      let minText = reading[parseInt(l_two)];

      return hr + minText;
    }

    if (conversion === "1") {
      if (isNaN(military_time)) {
        return { status: "error", message: "Please! Check Your Input" };
      }

      const originalInput = military_time.toString(); // "136"
      const padded = originalInput.padStart(4, "0"); // "0136"
      const hourStr = padded.slice(0, padded.length - 2); // "13"
      const minuteStr = padded.slice(-2); // "36"
      const hour = parseInt(hourStr);
      const minute = parseInt(minuteStr);

      if (hour < 0 || hour >= 24 || minute < 0 || minute >= 60) {
        return { status: "error", message: "Please! Check Your Input" };
      }

      const chubees_ghante = `${hourStr}:${minuteStr}`; // ✅ FIXED HERE
      const bara_ghante = dayjs(chubees_ghante, "HH:mm").format("h:mm a");
      const eng_word = eng_time(`${hourStr}${minuteStr}`);

      return {
        status: "success",
        payload: {
          military_time: originalInput,
          eng_word: eng_word.trim(),
          bara_ghante: bara_ghante,
          chubees_ghante: chubees_ghante,
        },
      };
    }

    // Convert 12-hour or 24-hour time to military
    else if (conversion === "2") {
      if (isNaN(hur) || isNaN(min)) {
        return { status: "error", message: "Please! Check Your Input" };
      }

      if (hours === "24h") {
        const hrStr = hur.toString().padStart(2, "0");
        const minStr = min.toString().padStart(2, "0");
        const time = hrStr + minStr;
        const chubees_ghante = `${hrStr}:${minStr}`;
        const eng_word = eng_time(time);

        return {
          status: "success",
          payload: {
            bara_ghante: chubees_ghante,
            chubees_ghante: chubees_ghante,
            military_time: time,
            eng_word: eng_word,
            RESULT: 1,
          },
        };
      } else if (hours === "12h") {
        const hrStr = hur.toString().padStart(2, "0");
        const minStr = min.toString().padStart(2, "0");
        const time = `${hrStr}:${minStr} ${am_pm}`;
        const hrs_ans = dayjs(time, "hh:mm a").format("HH");
        const min_ans = dayjs(time, "hh:mm a").format("mm");
        const chubees_ghante = `${hrs_ans}:${min_ans}`;
        const military_time = hrs_ans + min_ans;
        const eng_word = eng_time(military_time);

        return {
          status: "success",
          payload: {
            military_time: military_time,
            eng_word: eng_word,
            bara_ghante: time,
            chubees_ghante: chubees_ghante,
            RESULT: 1,
          },
        };
      }
    }

    return { status: "error", message: "Invalid conversion type" };
  }

  /**
   * getCalculationRoundtoTheNearestCentCalculator: Service Method
   * POST: /api/calculators-lol/round-to-the-nearest-cent
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRoundtoTheNearestCentCalculator(body) {
    const value = body.tech_round;

    if (typeof value === "number" && !isNaN(value)) {
      const result = Math.round(value * 100) / 100; // Round to 2 decimal places
      return {
        tech_result: result,
      };
    } else {
      return {
        error: "Please Check Your Input.",
      };
    }
  }

  /**
   * getCalculationSquereRootCurveCalculator: Service Method
   * POST: /api/calculators-lol/square-root-curve-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSquereRootCurveCalculator(body) {
    const percentage = body.tech_percentage;

    if (typeof percentage === "number" && !isNaN(percentage)) {
      if (percentage <= 0) {
        return {
          error:
            "Number of percentage grade value cannot be equal to or less than zero.",
        };
      }

      const answer = Math.sqrt(percentage) * 10;

      return {
        tech_answer: answer,
        tech_percentage: percentage,
      };
    } else {
      return {
        error: "Please Check Your Input.",
      };
    }
  }

  /**
   * getCalculationAbsoluteChangeCalculator: Service Method
   * POST: /api/calculators-lol/absolute-change-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAbsoluteChangeCalculator(body) {
    const initial = body.tech_initial;
    const final = body.tech_final;

    if (typeof initial === "number" && typeof final === "number") {
      const answer = final - initial;

      return {
        tech_answer: answer,
        tech_initial: initial,
        tech_final: final,
      };
    } else {
      return {
        error: "Please Check Your Input.",
      };
    }
  }

  /**
   * getCalculationLogBase2Calculator: Service Method
   * POST: /api/calculators-lol/log-base-2-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLogBase2Calculator(body) {
    const input = body.tech_input;

    if (typeof input === "number") {
      const answer = Math.log2(input);

      return {
        tech_answer: answer,
      };
    } else {
      return {
        error: "Please Check Your Input.",
      };
    }
  }

  /**
   * getCalculationComparingDecimalCalculator: Service Method
   * POST: /api/calculators-lol/comparing-decimals-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationComparingDecimalCalculator(body) {
    const first = body.tech_first;
    const second = body.tech_second;

    // Check if both values are numeric
    if (!isNaN(first) && !isNaN(second)) {
      return {
        tech_first: first,
        tech_second: second,
      };
    } else {
      return {
        error: "Please Check Your Input.",
      };
    }
  }

  /**
   * getCalculationDoublingtimeCalculator: Service Method
   * POST: /api/calculators-lol/doubling-time-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDoublingtimeCalculator(body) {
    const x = parseFloat(body.tech_x); // The percentage value
    const want = parseInt(body.tech_want); // The want value (1 or other)

    // Check if both x and want are numeric
    if (!isNaN(x) && !isNaN(want)) {
      let ans;

      if (want === 1) {
        // Doubling time formula for want = 1
        ans = Math.log(2) / Math.log(1 + x / 100);
      } else {
        // Doubling time formula for other values of want
        ans = Math.log(2) / x;
        ans = Math.pow(Math.E, ans) - 1;
        ans = ans * 100;
      }
      return {
        tech_ans: ans,
      };
    } else {
      return {
        error: "Please Check Your Input.",
      };
    }
  }

  /**
   * getCalculationVariationCalculator: Service Method
   * POST: /api/calculators-lol/variation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationVariationCalculator(body) {
    const x = parseFloat(body.tech_x); // The first numeric value
    const y = parseFloat(body.tech_y); // The second numeric value
    const select = body.tech_select; // The selection for the operation

    // Check if both x and y are numeric
    if (!isNaN(x) && !isNaN(y)) {
      let ans;

      switch (select) {
        case "1":
          ans = y / x;
          break;
        case "2":
          ans = y * x;
          break;
        case "3":
          ans = y / Math.pow(x, 2);
          break;
        case "4":
          ans = y / Math.pow(x, 3);
          break;
        case "5":
          ans = y / Math.sqrt(x);
          break;
        case "6":
          ans = y * Math.pow(x, 2);
          break;
        case "7":
          ans = y * Math.pow(x, 3);
          break;
        case "8":
          ans = y * Math.sqrt(x);
          break;
        default:
          return { error: "Invalid selection option." };
      }

      return {
        tech_ans: ans,
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /**
   * getCalculationFibonacciCalculator: Service Method
   * POST: /api/calculators-lol/variation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationFibonacciCalculator(body) {
    const n = parseFloat(body.tech_n);
    const units = body.tech_units;
    const first_term = parseInt(body.tech_first_term);
    const second_term = parseInt(body.tech_second_term);

    // Helper function to generate Fibonacci sequence
    function generateFibonacci(start, end) {
      const fibonacci = [0, 1];
      for (let i = 2; i <= end; i++) {
        fibonacci[i] = fibonacci[i - 1] + fibonacci[i - 2];
      }
      return fibonacci.slice(start, end + 1);
    }

    let result = {};

    if (units === "A Sequence") {
      if (isNaN(first_term) || isNaN(second_term) || first_term > second_term) {
        result.error = "Please Check Your Input.";
        return result;
      }

      const fibonacci_sequence = generateFibonacci(first_term, second_term);
      result.tech_fibonacci_sequence = fibonacci_sequence;
      return result;
    } else {
      if (!isNaN(n)) {
        if (n < -250) {
          return { error: "n Value is less than -250" };
        }
        if (n >= 251) {
          return { error: "n Value is greater than or equal to 250" };
        }

        const phi = (1 + Math.sqrt(5)) / 2;
        const psi = 1 - phi;
        const answer = (Math.pow(phi, n) - Math.pow(psi, n)) / Math.sqrt(5);
        result.tech_answer = answer;
        return result;
      } else {
        return { error: "Please Check Your Input." };
      }
    }
  }

  /**
   * getCalculationCircumferenceToDiameterCalculator: Service Method
   * POST: /api/calculators-lol/circumference-to-diameter-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCircumferenceToDiameterCalculator(body) {
    const conversionType = body.tech_conversionType;
    let value = parseFloat(body.tech_value);
    const unit = body.tech_unit;

    function convert_unit(unit, value) {
      if (unit === "cm") {
        return value;
      } else if (unit === "mm") {
        return value * 10;
      } else if (unit === "m") {
        return value * 0.01;
      } else if (unit === "km") {
        return value * 0.00001;
      } else if (unit === "in") {
        return value * 0.3937;
      } else if (unit === "ft") {
        return value * 0.0328084;
      } else if (unit === "yd") {
        return value * 0.0109361;
      } else if (unit === "mi") {
        return value * 0.0000062137;
      } else {
        return value;
      }
    }

    if (!isNaN(value)) {
      value = convert_unit(unit, value);
      let result;

      if (conversionType === "circumferenceToDiameter") {
        result = value / Math.PI;
      } else {
        result = value * Math.PI;
      }

      return {
        tech_result: result,
        tech_unit: unit,
      };
    } else {
      return {
        error: "Please Check Your Input.",
      };
    }
  }

  /**
   * getCalculationVolumeOfSquareCalculator: Service Method
   * POST: /api/calculators-lol/volume-of-square
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationVolumeOfSquareCalculator(body) {
    let {
      tech_length,
      tech_length_unit,
      tech_height,
      tech_height_unit,
      tech_width,
      tech_width_unit,
    } = body;

    tech_length = parseFloat(tech_length);
    tech_height = parseFloat(tech_height);
    tech_width = parseFloat(tech_width);

    function convertToInches(unit, value) {
      switch (unit) {
        case "mm":
          return value / 25.4;
        case "cm":
          return value / 2.54;
        case "m":
          return value * 39.37;
        case "km":
          return value * 39370;
        case "in":
          return value;
        case "ft":
          return value * 12;
        case "yd":
          return value * 36;
        case "mi":
          return value * 63360;
        default:
          return value;
      }
    }

    if (!isNaN(tech_length) && !isNaN(tech_height) && !isNaN(tech_width)) {
      const convertedLength = convertToInches(tech_length_unit, tech_length);
      const convertedHeight = convertToInches(tech_height_unit, tech_height);
      const convertedWidth = convertToInches(tech_width_unit, tech_width);

      const answer = convertedLength * convertedHeight * convertedWidth;

      return {
        tech_answer: answer,
      };
    } else {
      return {
        error: "Please Check Your Input.",
      };
    }
  }

  /**
   * getCalculationBinCreatinineRatioCalculator: Service Method
   * POST: /api/calculators-lol/bun-creatinine-ratio-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationBinCreatinineRatioCalculator(body) {
    let { tech_bun, tech_bun_unit, tech_serum, tech_serum_unit } = body;

    tech_bun = parseFloat(tech_bun);
    tech_serum = parseFloat(tech_serum);

    // Convert BUN unit to mg/dL
    let bunMultiplier = tech_bun_unit === "mmol/L" ? 2.778 : 1;

    // Convert Serum Creatinine unit to mg/dL
    let serumMultiplier = tech_serum_unit === "μmol/L" ? 0.011312 : 1;

    if (!isNaN(tech_bun) && !isNaN(tech_serum)) {
      if (tech_bun > 0 && tech_serum > 0) {
        const bv = tech_bun * bunMultiplier;
        const sv = tech_serum * serumMultiplier;
        const ans = bv / sv;

        return {
          tech_ans: ans,
        };
      } else {
        return {
          error: "Please! Enter Positive Value.",
        };
      }
    } else {
      return {
        error: "Please! Check your input.",
      };
    }
  }

  /**
   * getCalculationGramsTocaloriesCalculator: Service Method
   * POST: /api/calculators-lol/grams-to-calories-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationGramsTocaloriesCalculator(body) {
    let {
      tech_carbohydrate,
      tech_carbo_unit,
      tech_protein,
      tech_protein_unit,
      tech_fat,
      tech_fat_unit,
    } = body;

    tech_carbohydrate = parseFloat(tech_carbohydrate);
    tech_protein = parseFloat(tech_protein);
    tech_fat = parseFloat(tech_fat);

    const unitConversion = (unit) => {
      switch (unit) {
        case "dag":
          return 10;
        case "oz":
          return 28.35;
        default:
          return 1; // 'g' or fallback
      }
    };

    const carboMultiplier = unitConversion(tech_carbo_unit);
    const proteinMultiplier = unitConversion(tech_protein_unit);
    const fatMultiplier = unitConversion(tech_fat_unit);

    if (!isNaN(tech_carbohydrate) && !isNaN(tech_protein) && !isNaN(tech_fat)) {
      const tech_cv = tech_carbohydrate * carboMultiplier;
      const tech_pv = tech_protein * proteinMultiplier;
      const tech_fv = tech_fat * fatMultiplier;

      const tech_carbs = tech_cv * 4;
      const tech_pr = tech_pv * 4;
      const tech_cf = tech_fv * 9;
      const tech_tc = tech_carbs + tech_pr + tech_cf;

      return {
        tech_cv,
        tech_pv,
        tech_fv,
        tech_carbs,
        tech_pr,
        tech_cf,
        tech_tc,
      };
    } else {
      return {
        error: "Please! Check your input.",
      };
    }
  }

  /**
   * getCalculationMapCalculator: Service Method
   * POST: /api/calculators-lol/map-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMapCalculator(body) {
    const tech_sbp = parseFloat(body.tech_sbp);
    const tech_dbp = parseFloat(body.tech_dbp);

    if (!isNaN(tech_sbp) && !isNaN(tech_dbp)) {
      if (tech_sbp < 70) {
        return {
          tech_error:
            "Systolic Blood Pressure > 70 for normal person. Contact your doctor for further description.",
        };
      } else if (tech_dbp < 40) {
        return {
          tech_error:
            "Diastolic blood pressure > 40 for normal persons. Contact your doctor for further description.",
        };
      } else if (tech_dbp >= tech_sbp) {
        return {
          tech_error:
            "Diastolic blood pressure cannot be higher than systolic blood pressure.",
        };
      } else {
        const tech_map = (1 / 3) * tech_sbp + (2 / 3) * tech_dbp;
        const tech_pr = tech_sbp - tech_dbp;

        return {
          tech_sbp,
          tech_dbp,
          tech_map,
          tech_pr,
          tech_RESULT: 1,
        };
      }
    } else {
      return {
        error: "Please! Check your input.",
      };
    }
  }

  /**
   * getCalculationMapCalculator: Service Method
   * POST: /api/calculators-lol/one-rep-max-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationOneRepMaxCalculator(body) {
    let tech_weight = parseFloat(body.tech_weight);
    let tech_weight_unit = (body.tech_weight_unit || "").trim().toLowerCase();
    let tech_rep = parseFloat(body.tech_rep);

    if (!isNaN(tech_weight) && !isNaN(tech_rep)) {
      // Convert weight from lbs to kg
      if (tech_weight_unit === "lbs") {
        tech_weight = tech_weight * 0.4536;
      }

      // Calculate 1RM
      let tech_ans = tech_weight * tech_rep * 0.0333 + tech_weight;

      // Convert back to lbs if original input was in lbs
      if (tech_weight_unit === "lbs") {
        tech_ans = tech_ans * 2.2046;
      }

      return {
        tech_ans,
        tech_request: body,
      };
    } else {
      return {
        error: "Please! Check your input.",
      };
    }
  }

  /**
   * getCalculationSVRCalculator: Service Method
   * POST: /api/calculators-lol/svr-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSVRCalculator(body) {
    let tech_map = parseFloat(body.tech_map);
    let tech_map_unit = (body.tech_map_unit || "").trim();
    let tech_cvp = parseFloat(body.tech_cvp);
    let tech_cvp_unit = (body.tech_cvp_unit || "").trim();
    let tech_co = parseFloat(body.tech_co);
    let tech_co_unit = (body.tech_co_unit || "").trim();

    const convertUnit = (unit, type) => {
      if (type === "pressure") {
        switch (unit) {
          case "cmH2O":
            return 0.735559;
          case "kPa":
            return 7.50062;
          case "atm":
            return 760;
          case "psi":
            return 51.7149;
          default:
            return 1; // mmHg
        }
      }
      if (type === "flow") {
        return unit === "mL/min" ? 1000 : 1; // L/min default
      }
      return 1;
    };

    let tech_map_unit_val = convertUnit(tech_map_unit, "pressure");
    let tech_cvp_unit_val = convertUnit(tech_cvp_unit, "pressure");
    let tech_co_unit_val = convertUnit(tech_co_unit, "flow");

    if (
      !isNaN(tech_map) &&
      !isNaN(tech_cvp) &&
      !isNaN(tech_co) &&
      tech_map > 0 &&
      tech_cvp > 0 &&
      tech_co > 0
    ) {
      const tech_map_value = tech_map * tech_map_unit_val;
      const tech_cvp_value = tech_cvp * tech_cvp_unit_val;
      const tech_co_value = tech_co * tech_co_unit_val;

      const tech_cal1 = tech_map_value - tech_cvp_value;
      const tech_cal2 = tech_cal1 / tech_co_value;
      const tech_svr = 80 * tech_cal2;

      return {
        tech_svr,
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /**
   * getCalculationTacoBarCalculator: Service Method
   * POST: /api/calculators-lol/taco-bar-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTacoBarCalculator(body) {
    const first = parseFloat(body.tech_first);
    const second = parseFloat(body.tech_second);

    if (!isNaN(first)) {
      if (first > 0) {
        const result = {
          tech_meat_mass: first * second,
          tech_cheddar_cheese: 35.44 * first,
          tech_monterey_cheese: 21.262 * first,
          tech_sour_cream: 56.7 * first,
          tech_guacamole: 51.03 * first,
          tech_taco_sauce: 65.02 * first,
          tech_pico_de_gallo: 45.36 * first,
          tech_lettuce: 36.854 * first,
          tech_onions: 25.515 * first,
          tech_beans: 31.184 * first,
          tech_refried_beans: 62.37 * first,
          tech_tomatoes: 51.03 * first,
          tech_olives: 22.62 * first,
          tech_bell_pepper: 56.7 * first,
          tech_taco_shells: 2 * first,
          tech_tortillas: first,
          tech_rice: 70.87 * first,
        };
        return result;
      } else {
        return { error: "Number of people must be greater than 0." };
      }
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /**
   * getCalculationWaterIntakeCalculator: Service Method
   * POST: /api/calculators-lol/water-intake-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationWaterIntakeCalculator(body) {
    let { tech_gender, tech_weight, tech_weather, tech_unit, tech_activity } =
      body;

    tech_weight = parseFloat(tech_weight);
    tech_weather = parseFloat(tech_weather);
    tech_activity = parseFloat(tech_activity);

    if (!isNaN(tech_weight)) {
      if (tech_unit === "kg") {
        tech_weight = tech_weight * 2.205;
      }

      let tdee = 0;
      if (tech_gender === "Female") {
        tdee = Math.round(tech_weight * 0.45 * 10) / 10;
      } else if (tech_gender === "Male") {
        tdee = Math.round(tech_weight * 0.5 * 10) / 10;
      }

      let add = 0;
      if (tech_activity !== 0) {
        const plus = Math.round(tdee * tech_activity * 10) / 10;
        add += plus;
      }

      if (tech_weather !== 0) {
        const plus = Math.round(tdee * tech_weather * 10) / 10;
        add += plus;
      }

      tdee = Math.round((tdee + add) * 10) / 10;

      const im_ounce = Math.round(tdee * 1.04084 * 10) / 10;
      const us_ounce = tdee;
      const tdee_ml = Math.round(tdee * 29.5735 * 10) / 10;
      const cups = Math.round((tdee_ml / 237) * 10) / 10;
      const liter = Math.round((tdee_ml / 1000) * 10) / 10;

      return {
        tech_water: tdee_ml,
        tech_us_ounce: us_ounce + 1,
        tech_im_ounce: im_ounce,
        tech_cups: cups + 1,
        tech_liter: liter,
      };
    } else {
      return { error: "Please Fill All The Fields." };
    }
  }

  /**
   * getCalculationIdiCalculator: Service Method
   * POST: /api/calculators-lol/ldl-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationIdiCalculator(body) {
    const {
      tech_total,
      tech_total_unit,
      tech_high,
      tech_high_unit,
      tech_triglycerides,
      tech_triglycerides_unit,
    } = body;

    function unitConvert(unit, value) {
      value = parseFloat(value);
      if (unit === "mg/dL") {
        return value * 0.02586;
      } else if (unit === "mmol/L") {
        return value;
      }
      return null;
    }

    const totalConverted = unitConvert(tech_total_unit, tech_total);
    const highConverted = unitConvert(tech_high_unit, tech_high);
    const triglyceridesConverted = unitConvert(
      tech_triglycerides_unit,
      tech_triglycerides
    );

    if (
      !isNaN(totalConverted) &&
      !isNaN(highConverted) &&
      !isNaN(triglyceridesConverted)
    ) {
      const ldl_mmoll =
        totalConverted - highConverted - 0.2 * triglyceridesConverted;
      const ldl_mgdL = ldl_mmoll * 38.7;

      return {
        tech_ldl_mmoll: parseFloat(ldl_mmoll.toFixed(2)),
        tech_ldl_mgdL: parseFloat(ldl_mgdL.toFixed(2)),
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /**
   * getCalculationA1cCalculator: Service Method
   * POST: /api/calculators-lol/a1c-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationA1cCalculator(body) {
    const { tech_solve, tech_input, tech_unit1, tech_unit2 } = body;

    let unit1Mapped =
      tech_unit1 === "%" ? "1" : tech_unit1 === "mmol/mol" ? "2" : null;
    let unit2Mapped =
      tech_unit2 === "mmol/L" ? "1" : tech_unit2 === "mg/dL" ? "2" : null;

    function acUnit(unit, value) {
      if (unit === "1") {
        return value;
      } else {
        return value * 0.09148 + 2.152;
      }
    }

    function bloodUnit(unit, value) {
      if (unit === "1") {
        return value * 18.016;
      } else {
        return value;
      }
    }

    if (!isNaN(tech_input)) {
      let jawab, percent;

      if (tech_solve === "1") {
        const adjustedInput = acUnit(unit1Mapped, parseFloat(tech_input));
        jawab = 28.7 * adjustedInput - 46.7;
        percent = adjustedInput;
      } else {
        const adjustedInput = bloodUnit(unit2Mapped, parseFloat(tech_input));
        jawab = (adjustedInput + 46.7) / 28.7;
        percent = jawab;
      }

      return {
        tech_percent: parseFloat(percent.toFixed(2)),
        tech_jawab: parseFloat(jawab.toFixed(2)),
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /**
   * getCalculationIncidenceRateCalculator: Service Method
   * POST: /api/calculators-lol/incidence-rate-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationIncidenceRateCalculator(body) {
    const cases = body.tech_cases?.toString().trim();
    const risk = body.tech_risk?.toString().trim();
    const different_unit = body.tech_different_unit?.toString().trim();
    const population = body.tech_population?.toString().trim();
    const per = body.tech_per?.toString().trim();

    let result = {};

    const isNumeric = (val) => !isNaN(parseFloat(val)) && isFinite(val);

    if (different_unit === "Yes") {
      if (isNumeric(cases) && isNumeric(risk) && isNumeric(population)) {
        const answer =
          (parseFloat(cases) / parseFloat(risk)) * parseFloat(population);
        result.tech_answer = answer;
        result.tech_cases = cases;
        result.tech_risk = risk;
      } else {
        result.error = "Please! Check Your Input.";
      }
    } else if (different_unit === "No") {
      if (isNumeric(cases) && isNumeric(risk) && isNumeric(per)) {
        const answer = (parseFloat(cases) / parseFloat(risk)) * parseFloat(per);
        result.tech_answer = answer;
        result.tech_cases = cases;
        result.tech_risk = risk;
      } else {
        result.error = "Please! Check Your Input.";
      }
    } else {
      result.error = "Invalid 'different_unit' value.";
    }

    return result;
  }

  /**
   * getCalculationItRatioCalculator: Service Method
   * POST: /api/calculators-lol/it-ratio
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationItRatioCalculator(body) {
    const f_input = body.tech_f_input;
    const s_input = body.tech_s_input;

    const isNumeric = (val) => !isNaN(parseFloat(val)) && isFinite(val);

    let results = {};

    if (isNumeric(f_input) && isNumeric(s_input)) {
      const answer = parseFloat(f_input) / parseFloat(s_input);

      // Store the answer in the results object
      results.tech_answer = answer;
    } else {
      results.error = "Please! Check Your Input.";
    }

    return results;
  }

  /**
   * getCalculationMaxHeartRateCalculator: Service Method
   * POST: /api/calculators-lol/max-heart-rate-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMaxHeartRateCalculator(body) {
    const formula = body.formula;
    const age = body.age;

    const isNumeric = (val) => !isNaN(parseFloat(val)) && isFinite(val);

    let results = {};

    if (isNumeric(age)) {
      let answer;

      // Calculate answer based on the formula selected
      if (formula === "1") {
        answer = 205.8 - 0.685 * age;
      } else if (formula === "2") {
        answer = 220 - age;
      } else if (formula === "3") {
        answer = 211 - 0.64 * age;
      } else if (formula === "4") {
        answer = 192 - 0.007 * Math.pow(age, 2);
      } else if (formula === "5") {
        answer = 208 - 0.07 * age;
      }

      // Store the answer in the results object
      results.answer = answer;
    } else {
      results.error = "Please! Check Your Input.";
    }

    return results;
  }

  /**
   * getCalculationPackYearCalculator: Service Method
   * POST: /api/calculators-lol/pack-year-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPackYearCalculator(body) {
    const cigarettes = body.tech_cigarettes;
    const size = body.tech_size;
    const years = body.tech_years;

    const isNumeric = (val) => !isNaN(parseFloat(val)) && isFinite(val);

    let results = {};

    if (isNumeric(cigarettes) && isNumeric(size) && isNumeric(years)) {
      // Calculate the values for PY, PL, and CL
      const PY = (cigarettes / size) * years;
      const PL = cigarettes * 365.24 * years;
      const CL = (cigarettes / size) * 365.24 * years;

      // Store the results in the response object
      results.tech_PY = PY;
      results.tech_PL = PL;
      results.tech_CL = CL;
    } else {
      results.error = "Please! Check Your Input.";
    }

    return results;
  }

  /**
   * getCalculationRuckingCaloriesCalculator: Service Method
   * POST: /api/calculators-lol/rucking-calorie-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRuckingCaloriesCalculator(body) {
    const activities = body.tech_activities;
    const weight = body.tech_weight;
    const time = body.tech_time;

    const isNumeric = (val) => !isNaN(parseFloat(val)) && isFinite(val);

    let results = {};

    if (isNumeric(activities) && isNumeric(weight) && isNumeric(time)) {
      // Convert weight from pounds to kilograms
      const weightInKg = weight / 2.205;

      // Calculate the calories
      const calories = activities * weightInKg * time;

      // Store the results
      results.tech_calories = Math.round(calories);
    } else {
      results.error = "Please! Check Your Input.";
    }

    return results;
  }

  /**
   * getCalculationEbitCalculator: Service Method
   * POST: /api/calculators-lol/ebit-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationEbitCalculator(body) {
    const x = body.tech_x;
    const y = body.tech_y;

    const isNumeric = (val) => !isNaN(parseFloat(val)) && isFinite(val);

    let results = {};

    if (isNumeric(x) && isNumeric(y)) {
      // Calculate EBIT
      const ebit = x - y;

      // Store the results
      results.tech_ebit = ebit;
    } else {
      results.error = "Please fill all fields.";
    }

    return results;
  }

  /**
   * getCalculationStampDutyCalculator: Service Method
   * POST: /api/calculators-lol/stamp-duty-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationStampDutyCalculator(body) {
    let param = {};
    let { tech_unit_type, value, tech_uk_method } = body;

    const ausval = Number(body.tech_ausval);
    let aus_a;
    let aus_b;
    let aus_c;
    let aus_d;
    let v;
    if (tech_unit_type === "uk") {
      value = parseFloat(value);
      if (!isNaN(value)) {
        let a = 0,
          b = 0,
          c = 0,
          d = 0,
          e = 0;
        let as = 0,
          bs = 0,
          cs = 0,
          ds = 0,
          es = 0;
        let stamp_duty = 0;

        if (tech_uk_method === "single") {
          if (value < 125000) {
            param.error = "You don't need to pay stamp duty.";
            return param;
          }
          if (value <= 250000 && value > 125000) {
            bs = value - 125000;
            b = bs * 0.02;
            stamp_duty = b;
          }
          if (value > 250000) {
            b = 2500;
            bs = 125000;
          }
          if (value <= 925000 && value > 250000) {
            cs = value - 250000;
            c = cs * 0.05;
            stamp_duty = c + b;
          }
          if (value > 925000) {
            c = 33750;
            cs = 675000;
          }
          if (value <= 1500000 && value > 925000) {
            ds = value - 925000;
            d = ds * 0.1;
            stamp_duty = d + c + b;
          }
          if (value > 1500000) {
            d = 57500;
            ds = 575000;
            es = value - 1500000;
            e = es * 0.12;
            stamp_duty = e + d + c + b;
          }
        }

        if (tech_uk_method === "add") {
          if (value <= 125000) {
            as = value;
            a = as * 0.03;
            stamp_duty = a;
          }
          if (value > 125000) {
            a = 3750;
            as = 125000;
          }
          if (value <= 250000 && value > 125000) {
            bs = value - 125000;
            b = bs * 0.05;
            stamp_duty = b + a;
          }
          if (value > 250000) {
            b = 6250;
            bs = 125000;
          }
          if (value <= 925000 && value > 250000) {
            cs = value - 250000;
            c = cs * 0.08;
            stamp_duty = c + b + a;
          }
          if (value > 925000) {
            c = 54000;
            cs = 675000;
          }
          if (value <= 1500000 && value > 925000) {
            ds = value - 925000;
            d = ds * 0.13;
            stamp_duty = d + c + b + a;
          }
          if (value > 1500000) {
            d = 74750;
            ds = 575000;
            es = value - 1500000;
            e = es * 0.15;
            stamp_duty = e + d + c + b + a;
          }
        }

        if (tech_uk_method === "first") {
          if (value <= 300000) {
            param.error = "You don't need to pay stamp duty.";
            return param;
          }
          if (value > 500000) {
            a = 5000;
            as = 175000;
          }
          if (value <= 500000 && value > 300000) {
            bs = value - 300000;
            b = bs * 0.05;
            stamp_duty = b + a;
          }
          if (value > 500000) {
            b = 10000;
            bs = 200000;
          }
          if (value <= 925000 && value > 500000) {
            cs = value - 500000;
            c = cs * 0.05;
            stamp_duty = c + b + a;
          }
          if (value > 925000) {
            c = 21250;
            cs = 425000;
          }
          if (value <= 1500000 && value > 925000) {
            ds = value - 925000;
            d = ds * 0.1;
            stamp_duty = d + c + b + a;
          }
          if (value > 1500000) {
            d = 57500;
            ds = 575000;
            es = value - 1500000;
            e = es * 0.12;
            stamp_duty = e + d + c + b + a;
          }
        }

        const percent = ((stamp_duty / value) * 100).toFixed(2);

        param = {
          a: a.toFixed(2),
          as: as.toFixed(2),
          b: b.toFixed(2),
          bs: bs.toFixed(2),
          c: c.toFixed(2),
          cs: cs.toFixed(2),
          d: d.toFixed(2),
          ds: ds.toFixed(2),
          e: e.toFixed(2),
          es: es.toFixed(2),
          percent,
          stamp_duty: stamp_duty.toFixed(2),
          Add: "active",
        };
        return param;
      } else {
        return { error: "Please Fill the Field." };
      }
    }
    if (tech_unit_type === "aus") {
      // Leave this block empty for now as requested
      if (ausval != "") {
        if (body.tech_aus_method === "nsw") {
          let value = ausval;

          if (
            body.tech_first === "no" ||
            body.tech_property === "invest" ||
            body.tech_property === "land" ||
            value > 800000 ||
            body.tech_property === "live"
          ) {
            if (value <= 14000) {
              aus_a = (value / 100) * 1.25;
            } else if (value <= 30000) {
              aus_a = ((value - 14000) / 100) * 1.5 + 175;
            } else if (value <= 81000) {
              aus_a = ((value - 30000) / 100) * 1.75 + 415;
            } else if (value <= 304000) {
              aus_a = ((value - 81000) / 100) * 3.5 + 1307;
            } else if (value <= 1013000) {
              aus_a = ((value - 304000) / 100) * 4.5 + 9112;
            } else if (value < 3040000) {
              aus_a = ((value - 1013000) / 100) * 5.5 + 41017;
            } else {
              aus_a = ((value - 3040000) / 100) * 7.0 + 152502;
            }
          }

          if (
            body.tech_first === "yes" &&
            body.tech_property === "live" &&
            ausval < 800000
          ) {
            if (ausval <= 650000) {
              aus_a = 0;
            } else if (ausval < 800000) {
              aus_a = ausval * (21 / 100) - 136510;
            }
          }

          const aus_b = 219;
          const aus_c = 109.5;
          const aus_d = aus_a + aus_b + aus_c;

          param["tech_aus_a"] = aus_a.toFixed(2);
          param["tech_aus_b"] = aus_b.toFixed(2);
          param["tech_aus_c"] = aus_c.toFixed(2);
          param["tech_aus_d"] = aus_d.toFixed(2);
          param["RESULT"] = 1;
          param["tech_sub"] = "active";
          return param;
        }
        if (body.tech_aus_method === "vic") {
          value = body.tech_ausval;
          if (
            body.tech_first === "no" ||
            body.tech_property === "invest" ||
            body.tech_property === "land" ||
            value > 750000
          ) {
            if (value <= 25000) {
              aus_a = (value / 100) * 1.4;
            }
            if (value <= 130000 && value > 25000) {
              value = value - 25000;
              aus_a = (value / 100) * 2.4;
              aus_a = aus_a + 350;
            }
            if (value <= 960000 && value > 130000) {
              value = value - 130000;
              aus_a = (value / 100) * 6;
              aus_a = aus_a + 2870;
            }
            if (value > 960000) {
              aus_a = (value / 100) * 5.5;
            }
          }
          if (body.tech_property === "live" && body.tech_first === "no") {
            if (value <= 25000) {
              aus_a = (value / 100) * 1.4;
            }
            if (value <= 130000 && value > 25000) {
              value = value - 25000;
              aus_a = (value / 100) * 2.4;
              aus_a = aus_a + 350;
            }
            if (value <= 440000 && value > 130000) {
              value = value - 130000;
              aus_a = (value / 100) * 5;
              aus_a = aus_a + 2870;
            }
            if (value <= 550000 && value > 440000) {
              value = value - 440000;
              aus_a = (value / 100) * 6;
              aus_a = aus_a + 18370;
            }
            if (value <= 960000 && value > 550000) {
              value = value - 550000;
              aus_a = (value / 100) * 6;
              aus_a = aus_a + 28070;
            }
            if (value > 960000) {
              aus_a = (value / 100) * 5.5;
            }
          }
          if (body.tech_first === "yes" && body.tech_property === "live") {
            if (value <= 600000) {
              aus_a = 0;
            }
            if (value > 600000 && value < 605000) {
              aus_a = (value - 600000) * 0.209;
            }
            if (value === 605000) {
              aus_a = 1045;
            }
            if (value > 605000 && value < 610000) {
              value = value - 605000;
              aus_a = value * 0.2129 + 1045;
            }
            if (value === 610000) {
              aus_a = (value - 600000) * 0.2111;
            }
            if (value > 610000 && value < 615000) {
              value = value - 610000;
              aus_a = value * 0.2129 + 2111.33;
            }
            if (value === 615000) {
              aus_a = (value - 600000) * 0.2131;
            }
            if (value > 615000 && value < 620000) {
              value = value - 615000;
              aus_a = value * 0.2195 + 3197.0;
            }
            if (value === 620000) {
              aus_a = 4302.67;
            }
            if (value > 620000 && value < 625000) {
              value = value - 620000;
              aus_a = value * 0.2195 + 4302.67;
            }
            if (value === 625000) {
              aus_a = 5428;
            }
            if (value > 625000 && value < 630000) {
              value = value - 625000;
              aus_a = value * 0.228 + 5428;
            }
            if (value === 630000) {
              aus_a = 6574.0;
            }
            if (value > 630000 && value < 635000) {
              value = value - 630000;
              aus_a = value * 0.232 + 6574;
            }
            if (value === 635000) {
              aus_a = 7739.67;
            }
            if (value > 635000 && value < 640000) {
              value = value - 635000;
              aus_a = value * 0.236 + 7739.67;
            }
            if (value === 640000) {
              aus_a = 8925.33;
            }
            if (value > 640000 && value < 645000) {
              value = value - 640000;
              aus_a = value * 0.2403 + 8925.33;
            }
            if (value === 645000) {
              aus_a = 10131;
            }
            if (value > 645000 && value < 650000) {
              value = value - 645000;
              aus_a = value * 0.2443 + 10131;
            }
            if (value === 650000) {
              aus_a = 11357;
            }
            if (value > 650000 && value < 655000) {
              value = value - 650000;
              aus_a = value * 0.2482 + 11357;
            }
            if (value === 655000) {
              aus_a = 12602.33;
            }
            if (value > 655000 && value < 660000) {
              value = value - 655000;
              aus_a = value * 0.2523 + 12602.33;
            }
            if (value === 660000) {
              aus_a = 13868.0;
            }
            if (value > 660000 && value < 665000) {
              value = value - 660000;
              aus_a = value * 0.2563 + 13868.0;
            }
            if (value === 665000) {
              aus_a = 15153.67;
            }
            if (value > 665000 && value < 670000) {
              value = value - 665000;
              aus_a = value * 0.2603 + 15153.67;
            }
            if (value === 670000) {
              aus_a = 16459.33;
            }
            if (value > 670000 && value < 675000) {
              value = value - 670000;
              aus_a = value * 0.2643 + 16459.33;
            }
            if (value === 675000) {
              aus_a = 17785.0;
            }
            if (value > 675000 && value < 680000) {
              value = value - 675000;
              aus_a = value * 0.2683 + 17785.0;
            }
            if (value === 680000) {
              aus_a = 19130.67;
            }
            if (value > 680000 && value < 685000) {
              value = value - 680000;
              aus_a = value * 0.2723 + 19130.67;
            }
            if (value === 685000) {
              aus_a = 20496.33;
            }
            if (value > 685000 && value < 690000) {
              value = value - 685000;
              aus_a = value * 0.2763 + 20496.33;
            }
            if (value === 690000) {
              aus_a = 21882.0;
            }
            if (value > 690000 && value < 695000) {
              value = value - 690000;
              aus_a = value * 0.2803 + 21882.0;
            }
            if (value === 695000) {
              aus_a = 23287.67;
            }
            if (value > 695000 && value < 700000) {
              value = value - 695000;
              aus_a = value * 0.2843 + 23287.67;
            }
            if (value === 700000) {
              aus_a = 24713.33;
            }
            if (value > 700000 && value < 705000) {
              value = value - 700000;
              aus_a = value * 0.2883 + 24713.33;
            }
            if (value === 705000) {
              aus_a = 26159.0;
            }
            if (value > 705000 && value < 710000) {
              value = value - 705000;
              aus_a = value * 0.2923 + 26159.0;
            }
            if (value === 710000) {
              aus_a = 27624.67;
            }
            if (value > 710000 && value < 715000) {
              value = value - 710000;
              aus_a = value * 0.2963 + 27624.67;
            }
            if (value === 715000) {
              aus_a = 29110.33;
            }
            if (value > 715000 && value < 720000) {
              value = value - 715000;
              aus_a = value * 0.3003 + 29110.33;
            }
            if (value === 720000) {
              aus_a = 30616.0;
            }
            if (value > 720000 && value < 725000) {
              value = value - 720000;
              aus_a = value * 0.3043 + 30616.0;
            }
            if (value === 725000) {
              aus_a = 32141.67;
            }
            if (value > 725000 && value < 730000) {
              value = value - 725000;
              aus_a = value * 0.3083 + 32141.67;
            }
            if (value === 730000) {
              aus_a = 33687.33;
            }
            if (value > 730000 && value < 735000) {
              value = value - 730000;
              aus_a = value * 0.3123 + 33687.33;
            }
            if (value === 735000) {
              aus_a = 35253.0;
            }
            if (value > 735000 && value < 740000) {
              value = value - 735000;
              aus_a = value * 0.3163 + 35253.0;
            }
            if (value === 740000) {
              aus_a = 36838.67;
            }
            if (value > 740000 && value < 745000) {
              value = value - 740000;
              aus_a = value * 0.3203 + 36838.67;
            }
            if (value === 745000) {
              aus_a = 38444.33;
            }
            if (value > 745000 && value < 750000) {
              value = value - 745000;
              aus_a = value * 0.3243 + 38444.33;
            }
            if (value === 750000) {
              aus_a = 40070;
            }
          }
          aus_b = (body.tech_ausval / 1000) * 2.34 + 96.1;
          if (aus_b > 3606) {
            aus_b = 3606;
          }
          aus_c = 116.8;
          aus_d = aus_a + aus_b + aus_c;

          param["tech_aus_a"] = aus_a.toFixed(2);
          param["tech_aus_b"] = aus_b.toFixed(2);
          param["tech_aus_c"] = aus_c.toFixed(2);
          param["tech_aus_d"] = aus_d.toFixed(2);
          param["RESULT"] = 1;
          param["tech_sub"] = "active";
          return param;
        }
        if (body.tech_aus_method === "qld") {
          aus_b = 192;
          if (body.tech_ausval > 180000) {
            aus_b = aus_b + (body.tech_ausval - 180000) * 0.0036;
          }
          aus_c = 192;
          value = body.tech_ausval;
          if (body.tech_property === "live") {
            if (value <= 350000) {
              aus_a = (value / 100) * 1;
            }
            if (value > 350000 && value <= 540000) {
              value = value - 350000;
              aus_a = (value / 100) * 3.5 + 3500;
            }
            if (value > 540000 && value <= 1000000) {
              value = value - 540000;
              aus_a = (value / 100) * 4.5 + 10150;
            }
            if (value > 1000000) {
              value = value - 1000000;
              aus_a = (value / 100) * 5.75 + 30850;
            }
          }
          if (
            body.tech_property === "invest" ||
            body.tech_property === "land"
          ) {
            if (value <= 5000) {
              aus_a = 0;
            }
            if (value > 5000 && value <= 75000) {
              value = value - 5000;
              aus_a = (value / 100) * 1.5;
            }
            if (value > 75000 && value <= 540000) {
              value = value - 75000;
              aus_a = (value / 100) * 3.5 + 1050;
            }
            if (value > 540000 && value <= 1000000) {
              value = value - 540000;
              aus_a = (value / 100) * 4.5 + 17325;
            }
            if (value > 1000000) {
              value = value - 1000000;
              aus_a = (value / 100) * 5.75 + 38025;
            }
          }
          if (body.tech_first === "yes" && body.tech_property === "live") {
            if (aus_a < 8925) {
              aus_a = 0;
            }
            if (aus_a >= 8925 && aus_a < 9100) {
              aus_a = aus_a - 7875;
            }
            if (aus_a >= 9100 && aus_a < 9275) {
              aus_a = aus_a - 7000;
            }
            if (aus_a >= 9275 && aus_a < 9450) {
              aus_a = aus_a - 6125;
            }
            if (aus_a >= 9450 && aus_a < 9625) {
              aus_a = aus_a - 5250;
            }
            if (aus_a >= 9625 && aus_a < 9800) {
              aus_a = aus_a - 4375;
            }
            if (aus_a >= 9800 && aus_a < 9975) {
              aus_a = aus_a - 3500;
            }
            if (aus_a >= 9975 && aus_a < 10150) {
              aus_a = aus_a - 2625;
            }
            if (aus_a >= 10150 && aus_a < 10375) {
              aus_a = aus_a - 1750;
            }
            if (aus_a >= 10375 && aus_a < 10600) {
              aus_a = aus_a - 875;
            }
            if (aus_a >= 10600) {
              aus_a = aus_a - 0;
            }
          }
          aus_d = aus_a + aus_b + aus_c;
          param["tech_aus_a"] = aus_a.toFixed(2);
          param["tech_aus_b"] = aus_b.toFixed(2);
          param["tech_aus_c"] = aus_c.toFixed(2);
          param["tech_aus_d"] = aus_d.toFixed(2);
          param["RESULT"] = 1;
          param["tech_sub"] = "active";
          return param;
        }
        if (body.tech_aus_method === "wa") {
          value = body.tech_ausval;
          if (body.tech_property === "land") {
            if (value <= 80000) {
              aus_a = (value / 100) * 1.9;
            }
            if (value > 80000 && value <= 100000) {
              value = value - 80000;
              aus_a = (value / 100) * 2.85 + 1520;
            }
            if (value > 100000 && value <= 250000) {
              value = value - 100000;
              aus_a = (value / 100) * 3.8 + 2090;
            }
            if (value > 250000 && value <= 500000) {
              value = value - 250000;
              aus_a = (value / 100) * 4.75 + 7790;
            }
            if (value > 500000) {
              value = value - 500000;
              aus_a = (value / 100) * 5.15 + 19665;
            }
          }
          if (
            body.tech_property === "live" ||
            body.tech_property === "invest"
          ) {
            if (value <= 120000) {
              aus_a = (value / 100) * 1.9;
            }
            if (value > 120000 && value <= 150000) {
              value = value - 120000;
              aus_a = (value / 100) * 2.85 + 2280;
            }
            if (value > 150000 && value <= 360000) {
              aus_a = ((value - 150000) / 100) * 3.8 + 3135;
            }
            if (value > 360000 && value <= 725000) {
              aus_a = ((value - 360000) / 100) * 4.75 + 11115;
            }
            if (value > 725000) {
              aus_a = ((value - 725000) / 100) * 5.15 + 28453;
            }
          }
          if (body.tech_first === "yes" && body.tech_property === "live") {
            value = body.tech_ausval;
            if (value <= 430000) {
              aus_a = 0;
            }
            if (value > 430000 && value <= 530000) {
              aus_a = ((value - 430000) / 100) * 19.19;
            }
          }
          if (body.tech_first === "yes" && body.tech_property === "land") {
            value = body.tech_ausval;
            if (value <= 300000) {
              aus_a = 0;
            }
            if (value > 300000 && value <= 400000) {
              aus_a = ((value - 300000) / 100) * 13.01;
            }
          }
          if (body.tech_ausval <= 85000) {
            aus_b = 174.7;
          }
          if (body.tech_ausval > 85000 && body.tech_ausval <= 120000) {
            aus_b = 184.7;
          }
          if (body.tech_ausval > 120000 && body.tech_ausval <= 200000) {
            aus_b = 204.7;
          }
          if (body.tech_ausval > 200000) {
            aus_b = ((body.tech_ausval - 200000) / 100000) * 20 + 204.7;
          }
          aus_c = 174.7;
          aus_d = aus_a + aus_b + aus_c;
          param["tech_aus_a"] = aus_a.toFixed(2);
          param["tech_aus_b"] = aus_b.toFixed(2);
          param["tech_aus_c"] = aus_c.toFixed(2);
          param["tech_aus_d"] = aus_d.toFixed(2);

          param["RESULT"] = 1;
          param["tech_sub"] = "active";
          return param;
        }
        if (body.tech_aus_method === "sa") {
          value = body.tech_ausval;
          if (value <= 12000) {
            aus_a = (value / 100) * 1.0;
          }
          if (value > 12000 && value <= 30000) {
            aus_a = ((value - 12000) / 100) * 2.0 + 120;
          }
          if (value > 30000 && value <= 50000) {
            aus_a = ((value - 30000) / 100) * 3.0 + 480;
          }
          if (value > 50000 && value <= 100000) {
            aus_a = ((value - 50000) / 100) * 3.5 + 1080;
          }
          if (value > 100000 && value <= 200000) {
            aus_a = ((value - 100000) / 100) * 4.0 + 2830;
          }
          if (value > 200000 && value <= 250000) {
            aus_a = ((value - 200000) / 100) * 4.25 + 6830;
          }
          if (value > 250000 && value <= 300000) {
            aus_a = ((value - 250000) / 100) * 4.75 + 8955;
          }
          if (value > 300000 && value <= 500000) {
            aus_a = ((value - 300000) / 100) * 5.0 + 11330;
          }
          if (value > 500000) {
            aus_a = ((value - 500000) / 100) * 5.5 + 21330;
          }
          if (body.tech_first === "yes" && body.tech_property === "live") {
            if (value <= 430000) {
              aus_a = 0;
            }
            if (value > 430000 && value <= 530000) {
              aus_a = ((value - 430000) / 100) * 19.19;
            }
          }
          if (body.tech_first === "yes" && body.tech_property === "land") {
            if (value <= 300000) {
              aus_a = 0;
            }
            if (value > 300000 && value <= 400000) {
              aus_a = ((value - 300000) / 100) * 13.01;
            }
          }
          if (body.tech_ausval <= 5000) {
            aus_b = 163;
          }
          if (body.tech_ausval > 5000 && body.tech_ausval <= 20000) {
            aus_b = 182;
          }
          if (body.tech_ausval > 20000 && body.tech_ausval <= 40000) {
            aus_b = 199;
          }
          if (body.tech_ausval > 40000) {
            val = body.tech_ausval - 500000;
            if (val >= 0) {
              aus_b = (val / 1000) * 82.5 + 280;
            } else {
              aus_b = 280;
            }
          }
          aus_c = 163;
          aus_d = aus_a + aus_b + aus_c;
          param["tech_aus_a"] = aus_a.toFixed(2);
          param["tech_aus_b"] = aus_b.toFixed(2);
          param["tech_aus_c"] = aus_c.toFixed(2);
          param["tech_aus_d"] = aus_d.toFixed(2);
          param["RESULT"] = 1;
          param["tech_sub"] = "active";
          return param;
        }
        if (body.tech_aus_method === "nt") {
          value = body.tech_ausval;
          if (value <= 525000) {
            v = value / 1000;
            aus_a = 0.06571441 * v * v + 15 * v;
          }
          if (value > 525000 && value <= 2999999) {
            aus_a = (value / 100) * 4.95;
          }
          if (value >= 3000000 && value < 5000000) {
            aus_a = (value / 100) * 5.75;
          }
          if (value >= 5000000) {
            aus_a = (value / 100) * 5.95;
          }
          aus_b = aus_c = 149;
          aus_d = aus_a + aus_b + aus_c;
          param["tech_aus_a"] = aus_a.toFixed(2);
          param["tech_aus_b"] = aus_b.toFixed(2);
          param["tech_aus_c"] = aus_c.toFixed(2);
          param["tech_aus_d"] = aus_d.toFixed(2);
          param["RESULT"] = 1;
          param["tech_sub"] = "active";
          return param;
        }
        if (body.tech_aus_method === "act") {
          value = body.tech_ausval;
          if (value <= 200000) {
            aus_a = (value / 100) * 1.3;
          }
          if (value > 200000 && value <= 300000) {
            aus_a = ((value - 200000) / 100) * 2.3 + 2600;
          }
          if (value > 300000 && value <= 500000) {
            aus_a = ((value - 300000) / 100) * 3.6 + 4900;
          }
          if (value > 500000 && value <= 750000) {
            aus_a = ((value - 500000) / 100) * 4.56 + 12100;
          }
          if (value > 750000 && value <= 1000000) {
            aus_a = ((value - 750000) / 100) * 6.1 + 23500;
          }
          if (value > 1000000 && value <= 1455000) {
            aus_a = ((value - 1000000) / 100) * 6.6 + 38750;
          }
          if (value > 1455000) {
            aus_a = (value / 100) * 4.73;
          }
          if (body.tech_first === "yes" && body.tech_property === "live") {
            if (value <= 470000) {
              aus_a = 0;
            }
            if (value > 470000 && value <= 607000) {
              aus_a = ((value - 470000) / 100) * 12.35;
            }
          }
          if (body.tech_first === "yes" && body.tech_property === "land") {
            if (value <= 281200) {
              aus_a = 0;
            }
            if (value > 281200 && value <= 329500) {
              aus_a = ((value - 281200) / 100) * 12.3;
            }
          }
          aus_b = 409.0;
          aus_c = 153.0;
          aus_d = aus_a + aus_b + aus_c;
          param["tech_aus_a"] = aus_a.toFixed(2);
          param["tech_aus_b"] = aus_b.toFixed(2);
          param["tech_aus_c"] = aus_c.toFixed(2);
          param["tech_aus_d"] = aus_d.toFixed(2);
          param["RESULT"] = 1;
          param["tech_sub"] = "active";
          return param;
        }
        if (body.tech_aus_method === "tas") {
          value = body.tech_ausval;
          if (value <= 3000) {
            aus_a = 50;
          }
          if (value > 3000 && value <= 25000) {
            aus_a = ((value - 3000) / 100) * 1.75 + 50;
          }
          if (value > 25000 && value <= 75000) {
            aus_a = ((value - 25000) / 100) * 2.25 + 435;
          }
          if (value > 75000 && value <= 200000) {
            aus_a = ((value - 75000) / 100) * 3.5 + 1560;
          }
          if (value > 200000 && value <= 375000) {
            aus_a = ((value - 200000) / 100) * 4 + 5935;
          }
          if (value > 375000 && value <= 725000) {
            aus_a = ((value - 375000) / 100) * 4.25 + 12935;
          }
          if (value > 725000) {
            aus_a = ((value - 725000) / 100) * 4.5 + 27810;
          }
          aus_b = 212.22;
          aus_c = 138.51;
          aus_d = aus_a + aus_b + aus_c;
          param["tech_aus_a"] = aus_a.toFixed(2);
          param["tech_aus_b"] = aus_b.toFixed(2);
          param["tech_aus_c"] = aus_c.toFixed(2);
          param["tech_aus_d"] = aus_d.toFixed(2);
          param["tech_sub"] = "active";
          return param;
        }
      } else {
        return { error: "Please Enter Purchase Price." };
      }
    }
  }

  /**
   * getCalculationCTRCalculator: Service Method
   * POST: /api/calculators-lol/ctr-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCTRCalculator(body) {
    const impression = body.tech_impression;
    const clicks = body.tech_clicks;
    const param = {};

    if (!isNaN(impression) && !isNaN(clicks)) {
      const ctr = clicks / impression;
      param.tech_ctr = ctr;
      param.tech_impression = impression;
      param.tech_clicks = clicks;
    } else {
      param.error = "Please check your input.";
    }

    return param;
  }

  /**
   * getCalculationContributionMarginCalculator: Service Method
   * POST: /api/calculators-lol/contribution-margin-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationContributionMarginCalculator(body) {
    const selling_price = parseFloat(body.tech_selling_price);
    const variable_cost = parseFloat(body.tech_variable_cost);
    const number_units = parseFloat(body.tech_number_units);
    const fixed_cost = parseFloat(body.tech_fixed_cost);

    const param = {};

    // Validate numeric input
    if (
      !isNaN(selling_price) &&
      !isNaN(variable_cost) &&
      !isNaN(number_units) &&
      !isNaN(fixed_cost)
    ) {
      const contribution_margin =
        selling_price * number_units - variable_cost * number_units;
      const contribution_margin_ratio =
        contribution_margin / (selling_price * number_units);
      const profit = contribution_margin - fixed_cost;

      param.tech_contribution_margin = contribution_margin;
      param.tech_contribution_margin_ratio = contribution_margin_ratio * 100; // in percentage
      param.tech_profit = profit;
    } else {
      param.error = "Please check your input.";
    }

    return param;
  }

  /**
   * getCalculationYoutubeRevenueCalculator: Service Method
   * POST: /api/calculators-lol/youtube-revenue-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationYoutubeRevenueCalculator(body) {
    const video = parseFloat(body.tech_video);
    const average = parseFloat(body.tech_average);
    const click = parseFloat(body.tech_click);

    const param = {};

    if (!isNaN(video) && !isNaN(average) && !isNaN(click)) {
      const averageClicks = video * (click / 100);
      const averageRevenue = averageClicks * average;

      param.tech_averageClicks = averageClicks;
      param.tech_averageRevenue = averageRevenue;
    } else {
      param.error = "Please check your input.";
    }

    return param;
  }

  /**
   * getCalculationBookValueCalculator: Service Method
   * POST: /api/calculators-lol/book-value-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationBookValueCalculator(body) {
    const acquisition = parseFloat(body.tech_acquisition);
    const depreciation = parseFloat(body.tech_depreciation);

    const param = {};

    if (!isNaN(acquisition) && !isNaN(depreciation)) {
      const book = acquisition - depreciation;

      param.tech_book = book;
      param.tech_acquisition = acquisition;
      param.tech_depreciation = depreciation;
    } else {
      param.error = "Please check your input.";
    }

    return param;
  }

  /**
   * getCalculationCostOfGoodsSoldCalculator: Service Method
   * POST: /api/calculators-lol/cost-of-goods-sold-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCostOfGoodsSoldCalculator(body) {
    const inventory = parseFloat(body.tech_inventory);
    const purchases = parseFloat(body.tech_purchases);
    const e_inventory = parseFloat(body.tech_e_inventory);

    const param = {};

    if (!isNaN(inventory) && !isNaN(purchases) && !isNaN(e_inventory)) {
      const COGS = inventory + purchases - e_inventory;
      param.tech_COGS = COGS;
      param.tech_inventory = inventory;
      param.tech_purchases = purchases;
      param.tech_e_inventory = e_inventory;
    } else {
      param.error = "Please check your input.";
    }

    return param;
  }

  /**
   * getCalculationRentIncreaseCalculator: Service Method
   * POST: /api/calculators-lol/rent-increase-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationRentIncreaseCalculator(body) {
    const rent = parseFloat(body.tech_rent);
    const year = parseFloat(body.tech_year);
    let numbers = parseFloat(body.tech_numbers);
    const numbers_unit = (body.tech_numbers_unit || "").trim();

    const param = {};

    // Convert time units to years
    if (numbers_unit === "wks") {
      numbers = numbers / 52.143;
    } else if (numbers_unit === "mos") {
      numbers = numbers / 12;
    }

    if (!isNaN(rent) && !isNaN(year) && !isNaN(numbers)) {
      if (rent === 0) {
        param.error = "Current Annual Rent value cannot be equal to zero.";
        return param;
      }
      if (year === 0) {
        param.error =
          "Average Rent Change Per Year value cannot be equal to zero.";
        return param;
      }
      if (numbers === 0) {
        param.error = "Number Of Years value cannot be equal to zero.";
        return param;
      }

      const years = year / 100;
      const answer = rent * Math.pow(1 + years, numbers);

      param.tech_answer = answer;
      param.tech_rent = rent;
      param.tech_year = year;
      param.tech_numbers = body.tech_numbers;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationPercentOfSaleCalculator: Service Method
   * POST: /api/calculators-lol/percent-of-sales-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPercentOfSaleCalculator(body) {
    const item = parseFloat((body.tech_item || "").toString().trim());
    const sale = parseFloat((body.tech_sale || "").toString().trim());

    const param = {};

    if (!isNaN(item) && !isNaN(sale)) {
      if (sale === 0) {
        param.error = "Total Sales value cannot be equal to zero.";
        return param;
      }

      const answer = (item / sale) * 100;

      param.tech_answer = answer;
      param.tech_item = item;
      param.tech_sale = sale;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationSalvageValueCalculator: Service Method
   * POST: /api/calculators-lol/salvage-value-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationSalvageValueCalculator(body) {
    const original = parseFloat((body.tech_original || "").toString().trim());
    const rate = parseFloat((body.tech_rate || "").toString().trim());
    const year = parseFloat((body.tech_year || "").toString().trim());

    const param = {};

    if (!isNaN(original) && !isNaN(rate) && !isNaN(year)) {
      const rates = rate / 100;
      const answer = original * Math.pow(1 - rates, year);

      param.tech_answer = answer;
      param.tech_original = original;
      param.tech_rate = rate;
      param.tech_year = year;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationRealEstateCommissionCalculator: Service Method
   * POST: /api/calculators-lol/real-estate-commission-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationRealEstateCommissionCalculator(body) {
    const housePrice = parseFloat(
      (body.tech_housePrice || "").toString().trim()
    );
    const commissionRate = parseFloat(
      (body.tech_commissionRate || "").toString().trim()
    );

    const param = {};

    if (!isNaN(housePrice) && !isNaN(commissionRate)) {
      const commissionAmount = (commissionRate / 100) * housePrice;
      const ownerReceives = housePrice - commissionAmount;

      param.tech_commissionAmount = commissionAmount;
      param.tech_ownerReceives = ownerReceives;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationGdpPerCapitaCalculator: Service Method
   * POST: /api/calculators-lol/gdp-per-capita-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationGdpPerCapitaCalculator(body) {
    const real = parseFloat((body.tech_real || "").toString().trim());
    const real_unit = (body.tech_real_unit || "")
      .toString()
      .trim()
      .toLowerCase();
    const population = parseFloat(
      (body.tech_population || "").toString().trim()
    );
    const population_unit = (body.tech_population_unit || "")
      .toString()
      .trim()
      .toLowerCase();

    const param = {};

    function capital(value, unit) {
      switch (unit) {
        case "thousand":
          return value * 1;
        case "million":
          return value * 1000;
        case "billion":
          return value * 1000000;
        default:
          return value;
      }
    }

    if (!isNaN(real) && !isNaN(population)) {
      if (population === 0) {
        param.error = "Please! Check Your Input";
        return param;
      }

      const convertedReal = capital(real, real_unit);
      const convertedPopulation = capital(population, population_unit);

      const answer = convertedReal / convertedPopulation;

      param.tech_answer = answer;
      param.tech_real = real;
      param.tech_real_unit = real_unit;
      param.tech_population = population;
      param.tech_population_unit = population_unit;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationPriceCalculator: Service Method
   * POST: /api/calculators-lol/price-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPriceCalculator(body) {
    const price = parseFloat(body.tech_price);
    const gross = parseFloat(body.tech_gross);
    const param = {};

    if (!isNaN(price) && !isNaN(gross)) {
      if (gross < 0 || gross > 100) {
        param.error = "Enter Margin 0% to 100%";
        return param;
      }

      const grossDecimal = gross / 100;
      const revenue = price / (1 - grossDecimal);
      const gross_profit = revenue * grossDecimal;
      const mark_up = (gross_profit / price) * 100;

      param.tech_revenue = parseFloat(revenue.toFixed(2));
      param.tech_gross_profit = parseFloat(gross_profit.toFixed(2));
      param.tech_mark_up = parseFloat(mark_up.toFixed(2));
      param.tech_price = price;
      param.tech_gross = gross;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationBuyingPowereCalculator: Service Method
   * POST: /api/calculators-lol/buying-power-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBuyingPowereCalculator(body) {
    const amount = parseFloat(body.tech_amount);
    const reference = parseInt(body.tech_reference);
    const target = parseInt(body.tech_target);
    const param = {};

    const data = {
      1913: 9.9,
      1914: 10,
      1915: 10.1,
      1916: 10.9,
      1917: 12.8,
      1918: 15.1,
      1919: 17.3,
      1920: 20,
      1921: 17.9,
      1922: 16.8,
      1923: 17.1,
      1924: 17.1,
      1925: 17.5,
      1926: 17.7,
      1927: 17.4,
      1928: 17.1,
      1929: 17.1,
      1930: 16.7,
      1931: 15.2,
      1932: 13.7,
      1933: 13,
      1934: 13.4,
      1935: 13.7,
      1936: 13.9,
      1937: 14.4,
      1938: 14.1,
      1939: 13.9,
      1940: 14,
      1941: 14.7,
      1942: 16.3,
      1943: 17.3,
      1944: 17.6,
      1945: 18,
      1946: 19.5,
      1947: 22.3,
      1948: 24.1,
      1949: 23.8,
      1950: 24.1,
      1951: 26,
      1952: 26.5,
      1953: 26.7,
      1954: 26.9,
      1955: 26.8,
      1956: 27.2,
      1957: 28.1,
      1958: 28.9,
      1959: 29.1,
      1960: 29.6,
      1961: 29.9,
      1962: 30.2,
      1963: 30.6,
      1964: 31,
      1965: 31.5,
      1966: 32.4,
      1967: 33.4,
      1968: 34.8,
      1969: 36.7,
      1970: 38.8,
      1971: 40.5,
      1972: 41.8,
      1973: 44.4,
      1974: 49.3,
      1975: 53.8,
      1976: 56.9,
      1977: 60.6,
      1978: 65.2,
      1979: 72.6,
      1980: 82.4,
      1981: 90.9,
      1982: 96.5,
      1983: 99.6,
      1984: 103.9,
      1985: 107.6,
      1986: 109.6,
      1987: 113.6,
      1988: 118.3,
      1989: 124,
      1990: 130.7,
      1991: 136.2,
      1992: 140.3,
      1993: 144.5,
      1994: 148.2,
      1995: 152.4,
      1996: 156.9,
      1997: 160.5,
      1998: 163,
      1999: 166.6,
      2000: 172.2,
      2001: 177.1,
      2002: 179.9,
      2003: 184,
      2004: 188.9,
      2005: 195.3,
      2006: 201.6,
      2007: 207.3,
      2008: 215.303,
      2009: 214.537,
      2010: 218.056,
      2011: 224.939,
      2012: 229.594,
      2013: 232.957,
      2014: 236.736,
      2015: 237.017,
      2016: 240.007,
      2017: 245.12,
      2018: 251.107,
      2019: 255.657,
      2020: 258.811,
      2021: 270.97,
    };

    if (!isNaN(amount) && !isNaN(reference) && !isNaN(target)) {
      if (reference < 1913 || reference > 2021) {
        param.error = "The reference year should be between 1913 and 2021.";
        return param;
      }
      if (target < 1913 || target > 2021) {
        param.error = "The target year should be between 1913 and 2021.";
        return param;
      }

      const result = amount * (data[target] / data[reference]);
      param.tech_result = parseFloat(result.toFixed(2));
    } else {
      param.error = "Please! Check Your Input.";
    }

    return param;
  }

  /**
   * getCalculationCrossPriceElasticityCalculator: Service Method
   * POST: /api/calculators-lol/cross-price-elasticity-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCrossPriceElasticityCalculator(body) {
    const { tech_first, tech_second, tech_third, tech_four } = body;

    if (
      !isNaN(tech_first) &&
      isFinite(tech_first) &&
      !isNaN(tech_second) &&
      isFinite(tech_second) &&
      !isNaN(tech_third) &&
      isFinite(tech_third) &&
      !isNaN(tech_four) &&
      isFinite(tech_four)
    ) {
      const lamda_a = tech_first - tech_third;
      const lamda_b = tech_second - tech_four;

      const elasticity =
        ((tech_first + tech_third) / (tech_second + tech_four)) *
        (lamda_b / lamda_a);

      return {
        tech_elasticity: parseFloat(elasticity.toFixed(2)),
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /**
   * getCalculationActualCashValueCalculator: Service Method
   * POST: /api/calculators-lol/cross-price-elasticity-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationActualCashValueCalculator(body) {
    const { tech_price, tech_expected, tech_current } = body;

    if (
      !isNaN(tech_price) &&
      isFinite(tech_price) &&
      !isNaN(tech_expected) &&
      isFinite(tech_expected) &&
      !isNaN(tech_current) &&
      isFinite(tech_current)
    ) {
      if (tech_current > tech_expected) {
        return {
          error:
            "Current life of the item cannot be larger than the expected life of the item.",
        };
      }

      const acv = (tech_price * (tech_expected - tech_current)) / tech_expected;

      return {
        tech_acv: parseFloat(acv.toFixed(2)),
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /**
   * getCalculationNetWorthCalculator: Service Method
   * POST: /api/calculators-lol/net-worth-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationNetWorthCalculator(body) {
    const {
      tech_as_real,
      tech_as_check,
      tech_as_saving,
      tech_as_retire,
      tech_as_car,
      tech_as_other,
      tech_li_real,
      tech_li_card,
      tech_li_loan,
      tech_li_stload,
      tech_li_car,
      tech_li_other,
      res_link,
    } = body;

    // Validate all inputs are numeric
    const allValues = [
      tech_as_real,
      tech_as_check,
      tech_as_saving,
      tech_as_retire,
      tech_as_car,
      tech_as_other,
      tech_li_real,
      tech_li_card,
      tech_li_loan,
      tech_li_stload,
      tech_li_car,
      tech_li_other,
    ];

    const allAreNumeric = allValues.every(
      (value) => !isNaN(value) && isFinite(value)
    );

    if (allAreNumeric) {
      const assets =
        +tech_as_real +
        +tech_as_check +
        +tech_as_saving +
        +tech_as_retire +
        +tech_as_car +
        +tech_as_other;
      const liabilities =
        +tech_li_real +
        +tech_li_card +
        +tech_li_loan +
        +tech_li_stload +
        +tech_li_car +
        +tech_li_other;
      const net_worth = assets - liabilities;

      return {
        tech_assets: parseFloat(assets.toFixed(2)),
        tech_liabilities: parseFloat(liabilities.toFixed(2)),
        tech_net_worth: parseFloat(net_worth.toFixed(2)),
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /**
   * getCalculationCostBasisCalculator: Service Method
   * POST: /api/calculators-lol/cost-basis-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCostBasisCalculator(body) {
    const { tech_stock, tech_shares, tech_prices } = body;

    const shares_values = [];
    const prices_values = [];
    const upr = [];

    if (Array.isArray(tech_shares) && Array.isArray(tech_prices)) {
      for (let i = 0; i < tech_shares.length; i++) {
        const share = tech_shares[i];
        const price = tech_prices[i];

        if (
          isFinite(share) &&
          isFinite(price) &&
          share !== null &&
          price !== null
        ) {
          shares_values.push(Number(share));
          prices_values.push(Number(price));
          upr.push(share * price);
        }
      }

      if (shares_values.length >= 2 && prices_values.length >= 2) {
        const total_shares = shares_values.reduce((a, b) => a + b, 0);
        const cost_basis = upr.reduce((a, b) => a + b, 0) / total_shares;
        const stock_profit = (tech_stock - cost_basis) * total_shares;
        const percentage = ((tech_stock - cost_basis) / cost_basis) * 100;

        return {
          tech_cost_basis: +cost_basis.toFixed(2),
          tech_stock_profit: +stock_profit.toFixed(2),
          tech_percentage: +percentage.toFixed(2),
          total_shares,
          shares_values,
          prices_values,
          tech_arrayLengthshere: shares_values.length + 1,
          tech_arrayLengthprice: prices_values.length + 1,
        };
      } else {
        return {
          error: "At least two stock purchases are required.",
          tech_shares: tech_shares,
          tech_prices: tech_prices,
        };
      }
    } else {
      return {
        error: "Shares and prices must be arrays.",
      };
    }
  }

  /**
   * getCalculationComparativeAdvantageCalculator: Service Method
   * POST: /api/calculators-lol/comparative-advantage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationComparativeAdvantageCalculator(body) {
    const { tech_first, tech_second, tech_third, tech_four } = body;

    if (isFinite(tech_first) && isFinite(tech_second) && isFinite(tech_third)) {
      const tech_X_A = +(tech_second / tech_first).toFixed(2);
      const tech_X_B = +(tech_first / tech_second).toFixed(2);
      const tech_Y_A = +(tech_four / tech_third).toFixed(2);
      const tech_Y_B = +(tech_third / tech_four).toFixed(2);

      return {
        tech_X_A,
        tech_X_B,
        tech_Y_A,
        tech_Y_B,
        tech_first,
        tech_second,
        tech_third,
        tech_four,
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /**
   * getCalculationCurrentRationCalculator: Service Method
   * POST: /api/calculators-lol/current-ratio-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCurrentRationCalculator(body) {
    const tech_assets = Number(body.tech_assets);
    const tech_liabilities = Number(body.tech_liabilities);

    if (isFinite(tech_assets) && isFinite(tech_liabilities)) {
      const tech_answer = tech_assets / tech_liabilities;
      return {
        tech_answer,
        tech_assets,
        tech_liabilities,
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /**
   * getCalculationDeadWeightLossCalculator: Service Method
   * POST: /api/calculators-lol/deadweight-loss-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDeadWeightLossCalculator(body) {
    const tech_original_price = Number(body.tech_original_price);
    const tech_new_price = Number(body.tech_new_price);
    const tech_original_quantity = Number(body.tech_original_quantity);
    const tech_new_quantity = Number(body.tech_new_quantity);

    if (
      isFinite(tech_original_price) &&
      isFinite(tech_new_price) &&
      isFinite(tech_original_quantity) &&
      isFinite(tech_new_quantity)
    ) {
      const tech_total_price = tech_new_price - tech_original_price;
      const tech_total_quantity = tech_original_quantity - tech_new_quantity;
      const tech_dead = tech_total_price * tech_total_quantity;
      const tech_deadweight = tech_dead / 2;

      return {
        tech_deadweight,
        tech_dead,
        tech_total_price,
        tech_total_quantity,
        tech_original_price,
        tech_new_price,
        tech_original_quantity,
        tech_new_quantity,
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /**
   * getCalculationReverSaleTaxCalculator: Service Method
   * POST: /api/calculators-lol/reverse-sales-tax-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationReverSaleTaxCalculator(body) {
    const tech_final = Number(body.tech_final);
    const tech_sale = Number(body.tech_sale);

    if (isFinite(tech_final) && isFinite(tech_sale)) {
      const tech_sales = tech_sale / 100;
      const tech_reverse = tech_final / (1 + tech_sales);

      return {
        tech_reverse,
        tech_final,
        tech_sale,
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /**
   * getCalculationMarginalRevenueCalculator: Service Method
   * POST: /api/calculators-lol/marginal-revenue-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMarginalRevenueCalculator(body) {
    const tech_initial_re = Number(body.tech_initial_re);
    const tech_initial_qu = Number(body.tech_initial_qu);
    const tech_final_re = Number(body.tech_final_re);
    const tech_final_qu = Number(body.tech_final_qu);

    if (
      isFinite(tech_initial_re) &&
      isFinite(tech_initial_qu) &&
      isFinite(tech_final_re) &&
      isFinite(tech_final_qu)
    ) {
      const tech_total_rev = tech_final_re - tech_initial_re;
      const tech_quantity = tech_final_qu - tech_initial_qu;

      // Avoid division by zero
      if (tech_quantity === 0) {
        return {
          error: "Quantity change cannot be zero.",
        };
      }

      const tech_marginal_rev = tech_total_rev / tech_quantity;

      return {
        tech_total_rev,
        tech_quantity,
        tech_marginal_rev,
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /**
   * getCalculationCashBackCalculator: Service Method
   * POST: /api/calculators-lol/cash-back-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCashBackCalculator(body) {
    const tech_purchase = Number(body.tech_purchase);
    const tech_cash = Number(body.tech_cash);

    if (isFinite(tech_purchase) && isFinite(tech_cash)) {
      const tech_answer = tech_purchase * (tech_cash / 100);
      return {
        tech_answer,
        tech_purchase,
        tech_cash,
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /**
   * getCalculationEarningPerShareCalculator: Service Method
   * POST: /api/calculators-lol/earnings-per-share-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationEarningPerShareCalculator(body) {
    const tech_net_income = Number(body.tech_net_income);
    const tech_dividends = Number(body.tech_dividends);
    const tech_common_shares = Number(body.tech_common_shares);

    if (
      isFinite(tech_net_income) &&
      isFinite(tech_dividends) &&
      isFinite(tech_common_shares)
    ) {
      if (tech_common_shares <= 0) {
        return {
          error: "Number of common shares should be an integer greater than 0.",
        };
      }

      const share_income = tech_net_income - tech_dividends;
      const tech_share_dividends = share_income / tech_common_shares;

      return {
        tech_share_dividends,
        tech_net_income,
        tech_dividends,
        tech_common_shares,
      };
    } else {
      return {
        error: "Please! Check Your Input",
      };
    }
  }

  /**
   * getCalculationOptionProfitCalculator: Service Method
   * POST: /api/calculators-lol/earnings-per-share-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationOptionProfitCalculator(body) {
    const tech_ot = String(body.tech_ot).trim().toLowerCase();
    const tech_sp = Number(body.tech_sp);
    const tech_op = Number(body.tech_op);
    const tech_stp = Number(body.tech_stp);
    const tech_nc = Number(body.tech_nc);

    if (
      tech_ot &&
      isFinite(tech_sp) &&
      isFinite(tech_op) &&
      isFinite(tech_stp) &&
      isFinite(tech_nc) &&
      tech_sp >= 0 &&
      tech_op >= 0 &&
      tech_stp >= 0 &&
      tech_nc >= 0
    ) {
      const tech_ec = tech_nc * 100;
      let tech_ans;

      if (tech_ot === "c") {
        tech_ans = (tech_sp - tech_stp - tech_op) * tech_ec;
      } else if (tech_ot === "p") {
        tech_ans = (tech_stp - (tech_sp + tech_op)) * tech_ec;
      } else {
        return {
          error: 'Invalid option type. Use "c" for call or "p" for put.',
        };
      }

      return {
        tech_ans,
        tech_ot,
        tech_sp,
        tech_op,
        tech_stp,
        tech_nc,
        tech_ec,
      };
    } else {
      return {
        error: "Please! Check Your Input",
      };
    }
  }

  /**
   * getCalculationDividendYieldCalculator: Service Method
   * POST: /api/calculators-lol/dividend-yield-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDividendYieldCalculator(body) {
    const tech_first = Number(body.tech_first); // Dividends per period
    const tech_operations = String(body.tech_operations); // 1=Annual, 2=Semi-Annual, 3=Quarterly, 4=Monthly
    const tech_second = Number(body.tech_second); // Share price

    if (isFinite(tech_first) && isFinite(tech_second)) {
      if (tech_first < 0) {
        return { error: "Dividends per period should not be negative." };
      }

      if (tech_second < 0) {
        return { error: "Share price should not be negative." };
      }

      let tech_annual_div = 0;

      switch (tech_operations) {
        case "1":
          tech_annual_div = tech_first;
          break;
        case "2":
          tech_annual_div = tech_first * 2;
          break;
        case "3":
          tech_annual_div = tech_first * 4;
          break;
        case "4":
          tech_annual_div = tech_first * 12;
          break;
        default:
          return { error: "Invalid operation type. Use 1, 2, 3, or 4." };
      }

      const tech_divide = tech_annual_div / tech_second;
      const tech_dividend_yield = tech_divide * 100;

      return {
        tech_annual_div,
        tech_dividend_yield,
      };
    } else {
      return { error: "Please! Check Your Input" };
    }
  }

  /**
   * getCalculationMarkdownCalculator: Service Method
   * POST: /api/calculators-lol/markdown-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMarkdownCalculator(body) {
    const tech_osp = Number(body.tech_osp); // Original Selling Price
    const tech_asp = Number(body.tech_asp); // Actual Selling Price

    if (
      isFinite(tech_osp) &&
      isFinite(tech_asp) &&
      tech_osp > 0 &&
      tech_asp > 0
    ) {
      if (tech_asp < tech_osp) {
        const tech_markdown = tech_osp - tech_asp;
        const tech_markdown_percent = (tech_markdown / tech_asp) * 100;

        return {
          tech_markdown,
          tech_markdown_percent: parseFloat(tech_markdown_percent.toFixed(2)),
        };
      } else {
        return {
          error: "Original Selling Price > Actual Selling Price",
        };
      }
    } else {
      return {
        error: "Please! Check Your Input",
      };
    }
  }

  /**
   * getCalculationAGICalculator: Service Method
   * POST: /api/calculators-lol/agi-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationAGICalculator(body) {
    // Collect and parse all 24 inputs
    const inputs = [];
    for (let i = 1; i <= 24; i++) {
      const key = `tech_input${i}`;
      const value = Number(body[key]);
      if (!isFinite(value)) {
        return {
          error: "Please! Check Your Input",
        };
      }
      inputs.push(value);
    }

    // Calculate add1 (sum of input1 to input13)
    const tech_add1 = inputs.slice(0, 13).reduce((sum, val) => sum + val, 0);
    // Calculate add2 (sum of input14 to input24)
    const tech_add2 = inputs.slice(13).reduce((sum, val) => sum + val, 0);
    // Subtract
    const tech_minus = tech_add1 - tech_add2;

    return {
      tech_add1,
      tech_add2,
      tech_minus,
    };
  }

  /**
   * getCalculationMPCCalculator: Service Method
   * POST: /api/calculators-lol/mpc-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMPCCalculator(body) {
    const param = {};
    const income = Number(body.tech_income);
    const save = Number(body.tech_save);

    function setVeri(inss, sv) {
      return isFinite(inss) && isFinite(sv);
    }

    function getAns(income, save) {
      if (income === 0) {
        throw new Error("Division by zero.");
      }
      return save / income;
    }

    try {
      if (setVeri(income, save)) {
        const ans = getAns(income, save);
        param.tech_ans = parseFloat(ans.toFixed(4));
        return param;
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }
    } catch (e) {
      param.error = "Please! Check Your Input";
      return param;
    }
  }

  /**
   * getCalculationMaximumProfitCalculator: Service Method
   * POST: /api/calculators-lol/maximum-profit-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMaximumProfitCalculator(body) {
    const param = {};
    const p = Number(body.tech_p);
    const Q = Number(body.tech_Q);
    const C = Number(body.tech_C);

    if (isFinite(p) && isFinite(Q) && isFinite(C)) {
      const R = p * Q;
      const cost = C * p;
      const profit = R - cost;

      param.tech_R = R;
      param.tech_profit = profit;
      return param;
    } else {
      param.error = "Please! Check Your Input";
      return param;
    }
  }

  /**
   * getCalculationIncomeElasticityOfDemandCalculator: Service Method
   * POST: /api/calculators-lol/income-elasticity-of-demand-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationIncomeElasticityOfDemandCalculator(body) {
    const param = {};
    const { tech_i_p, tech_n_p, tech_i_q, tech_n_q } = body;

    // Helper function to round numbers
    const round = (num, dec = 2) => {
      return Math.round(num * Math.pow(10, dec)) / Math.pow(10, dec);
    };

    // Validate if all inputs are numbers
    if (
      isFinite(tech_i_p) &&
      isFinite(tech_n_p) &&
      isFinite(tech_i_q) &&
      isFinite(tech_n_q)
    ) {
      const pi = (tech_n_q - tech_i_q) / tech_i_q;
      const pq = (tech_n_p - tech_i_p) / tech_i_p;
      const eq = (tech_n_q - tech_i_q) / (tech_n_q + tech_i_q);
      const ep = (tech_n_p - tech_i_p) / (tech_n_p + tech_i_p);
      const ie = eq / ep;
      const ir = tech_i_p * tech_i_q;
      const fr = tech_n_p * tech_n_q;
      const R = round(tech_i_p * tech_i_q - tech_n_p * tech_n_q, 2);

      let rs = "";
      if (R > 0) {
        rs = "Elastic Demand";
      } else if (R === 1) {
        rs = "Unitary Elastic";
      } else if (R < 1) {
        rs = "Inelastic Demand";
      } else if (R === 0) {
        rs = "Perfectly Inelastic";
      } else {
        rs = "Perfectly Elastic";
      }

      const rin = round(((fr - ir) / ir) * 100, 2);
      const cq = round(pi, 2);
      const cp = round(pq, 2);

      param.ie = ie;
      param.ir = ir;
      param.fr = fr;
      param.sr = rs;
      param.cq = cq;
      param.cp = cp;
      param.rin = rin;

      return param;
    } else {
      param.error = "Please fill all fields.";
      return param;
    }
  }

  /**
   * getCalculationProfitMarginCalculator: Service Method
   * POST: /api/calculators-lol/profit-margin-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationProfitMarginCalculator(body) {
    const param = {};
    const { tech_x, tech_y, tech_method } = body;

    if (typeof tech_x === "number" && typeof tech_y === "number") {
      if (tech_method === "Gross") {
        const margin = parseFloat(
          ((100 * (tech_y - tech_x)) / tech_y).toFixed(2)
        );
        const profit = tech_y - tech_x;
        const mark = parseFloat(((profit / tech_x) * 100).toFixed(2));

        param.tech_margin = `${margin} %`;
        param.tech_profit = `${profit}`;
        param.tech_mark = `${mark} %`;

        return param;
      }

      if (tech_method === "Net") {
        const margin = parseFloat(((tech_y / tech_x) * 100).toFixed(2));
        param.tech_margin = `${margin} %`;
        return param;
      }

      if (tech_method === "Operating") {
        const margin = parseFloat(((tech_y / tech_x) * 100).toFixed(2));
        param.tech_operating = `${margin} %`;
        return param;
      }
    } else {
      param.error = "Please fill all fields.";
      return param;
    }
  }

  /**
   * getCalculationEnterpriseValueCalculator: Service Method
   * POST: /api/calculators-lol/enterprise-value-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationEnterpriseValueCalculator(body) {
    const param = {};
    const { tech_cs, tech_ps, tech_mvd, tech_mi, tech_ce } = body;

    if (
      typeof tech_cs === "number" &&
      typeof tech_ps === "number" &&
      typeof tech_mvd === "number" &&
      typeof tech_mi === "number" &&
      typeof tech_ce === "number"
    ) {
      const EV = tech_cs + tech_ps + tech_mvd + tech_mi - tech_ce;
      param.tech_ev = EV.toLocaleString(); // Format the result as a number with commas
      return param;
    } else {
      param.error = "Please fill all fields.";
      return param;
    }
  }

  /**
   * getCalculationCPCalculator: Service Method
   * POST: /api/calculators-lol/cpc-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCPCalculator(body) {
    const param = {};
    const { tech_method, tech_x, tech_y } = body;

    if (
      tech_method &&
      typeof tech_x === "number" &&
      typeof tech_y === "number"
    ) {
      let cpc;
      if (tech_method === "cpc") {
        cpc = tech_x / tech_y;
        param.ans = `${cpc}`;
      } else if (tech_method === "cost") {
        cpc = tech_x * tech_y;
        param.ans = `${cpc}`;
      } else if (tech_method === "click") {
        cpc = tech_x / tech_y;
        param.ans = cpc;
      }
      return param;
    } else {
      param.error = "Please fill all fields.";
      return param;
    }
  }

  /**
   * getCalculationOutTheDoorPriceCalculator: Service Method
   * POST: /api/calculators-lol/out-the-door-price-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationOutTheDoorPriceCalculator(body) {
    const param = {};
    const { tech_car, tech_dealership, tech_taxes } = body;

    if (
      typeof tech_car === "number" &&
      typeof tech_dealership === "number" &&
      typeof tech_taxes === "number"
    ) {
      const answer = tech_car + tech_dealership + tech_taxes;
      param.tech_answer = answer;
      param.tech_car = tech_car;
      param.tech_dealership = tech_dealership;
      param.tech_taxes = tech_taxes;
      return param;
    } else {
      param.error = "Please! Check Your Input";
      return param;
    }
  }

  /**
   * getCalculationSalaryCalculator: Service Method
   * POST: /api/calculators-lol/salary-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSalaryCalculator(body) {
    const param = {};

    const salary = parseFloat(body.salary);
    const week_hours = parseFloat(body.hours);
    const week_day = parseFloat(body.days);
    const holidays = parseFloat(body.holidays) || 0;
    const vacation = parseFloat(body.vacation) || 0;
    const total_leaves = holidays + vacation;

    if (!isNaN(salary) && !isNaN(week_hours)) {
      const yearly_hours = week_hours * 52;
      const daily_hours = week_hours / week_day;

      let hourly, daily, week, bi_week, yearly, monthly, sami_month, quarterly;
      let a_hourly,
        a_daily,
        a_week,
        a_bi_week,
        a_monthly,
        a_sami_month,
        a_quarterly,
        a_yearly;

      if (body.per === "Hourly") {
        hourly = salary;
        daily = +(salary * daily_hours).toFixed(2);
        week = +(week_hours * salary).toFixed(2);
        bi_week = +(week * 2).toFixed(2);
        yearly = +(yearly_hours * salary).toFixed(2);
        monthly = +(yearly / 12).toFixed(2);
        sami_month = +(monthly / 2).toFixed(2);
        quarterly = +(yearly / 4).toFixed(2);
      } else if (body.per === "Daily") {
        daily = salary;
        hourly = +(salary / daily_hours).toFixed(2);
        week = +(week_hours * hourly).toFixed(2);
        bi_week = +(week * 2).toFixed(2);
        yearly = +(yearly_hours * hourly).toFixed(2);
        monthly = +(yearly / 12).toFixed(2);
        sami_month = +(monthly / 2).toFixed(2);
        quarterly = +(yearly / 4).toFixed(2);
      } else if (body.per === "Weekly") {
        a_week = salary;
        a_hourly = +(a_week / week_hours).toFixed(2);
        a_daily = +(a_hourly * daily_hours).toFixed(2);
        a_bi_week = +(a_week * 2).toFixed(2);
        a_yearly = +(yearly_hours * a_hourly).toFixed(2);
        a_monthly = +(a_yearly / 12).toFixed(2);
        a_sami_month = +(a_monthly / 2).toFixed(2);
        a_quarterly = +(a_yearly / 4).toFixed(2);
      } else if (body.per === "Bi-Weekly") {
        a_bi_week = salary;
        a_week = +(a_bi_week * 2).toFixed(2);
        a_hourly = +(a_week / week_hours).toFixed(2);
        a_daily = +(a_hourly * daily_hours).toFixed(2);
        a_yearly = +(yearly_hours * a_hourly).toFixed(2);
        a_monthly = +(a_yearly / 12).toFixed(2);
        a_sami_month = +(a_monthly / 2).toFixed(2);
        a_quarterly = +(a_yearly / 4).toFixed(2);
      } else if (body.per === "Semi-Monthly") {
        a_sami_month = salary;
        a_monthly = +(a_sami_month * 2).toFixed(2);
        a_yearly = +(a_monthly * 12).toFixed(2);
        a_quarterly = +(a_yearly / 4).toFixed(2);
        a_hourly = +(a_yearly / yearly_hours).toFixed(2);
        a_daily = +(a_hourly * daily_hours).toFixed(2);
        a_week = +(week_hours * a_daily).toFixed(2);
        a_bi_week = +(a_week * 2).toFixed(2);
      } else if (body.per === "Monthly") {
        a_yearly = +(salary * 12).toFixed(2);
        a_quarterly = +(a_yearly / 4).toFixed(2);
        a_sami_month = +(salary / 2).toFixed(2);
        a_hourly = +(a_yearly / yearly_hours).toFixed(2);
        a_week = +(week_hours * a_hourly).toFixed(2);
        a_bi_week = +(a_week * 2).toFixed(2);
        a_daily = +(a_hourly * daily_hours).toFixed(2);
        a_monthly = salary;
      } else if (body.per === "Quarterly") {
        a_quarterly = salary;
        a_yearly = +(a_quarterly * 4).toFixed(2);
        a_hourly = +(a_yearly / yearly_hours).toFixed(2);
        a_daily = +(a_hourly * daily_hours).toFixed(2);
        a_week = +(week_hours * a_daily).toFixed(2);
        a_bi_week = +(a_week / 2).toFixed(2);
        a_monthly = +(a_yearly / 12).toFixed(2);
        a_sami_month = +(a_monthly / 2).toFixed(2);
      } else if (body.per === "Annual") {
        a_yearly = salary;
        a_hourly = +(a_yearly / yearly_hours).toFixed(2);
        a_daily = +(a_hourly * daily_hours).toFixed(2);
        a_week = +(week_hours * a_hourly).toFixed(2);
        a_bi_week = +(a_week * 2).toFixed(2);
        a_monthly = +(a_yearly / 12).toFixed(2);
        a_sami_month = +(a_monthly / 2).toFixed(2);
        a_quarterly = +(a_yearly * 4).toFixed(2);
      }
      if (total_leaves !== 0) {
        if (body.per === "Hourly" || body.per === "Daily") {
          const sub_salary = daily * total_leaves;
          a_yearly = +(yearly - sub_salary).toFixed(2);
          a_hourly = +(a_yearly / yearly_hours).toFixed(2);
          a_quarterly = +(a_yearly / 4).toFixed(2);
          a_monthly = +(a_yearly / 12).toFixed(2);
          a_sami_month = +(a_monthly / 2).toFixed(2);
          a_daily = +(a_hourly * daily_hours).toFixed(2);
          a_week = +(week_hours * a_hourly).toFixed(2);
          a_bi_week = +(a_week * 2).toFixed(2);
        } else {
          const hh = (260 - total_leaves) / 5;
          hourly = +(a_monthly / ((hh / 12) * week_hours)).toFixed(2);
          yearly = +(hourly * yearly_hours).toFixed(2);
          quarterly = +(yearly / 4).toFixed(2);
          monthly = +(yearly / 12).toFixed(2);
          sami_month = +(monthly / 2).toFixed(2);
          daily = +(hourly * daily_hours).toFixed(2);
          week = +(week_hours * hourly).toFixed(2);
          bi_week = +(week * 2).toFixed(2);
        }
      } else {
        if (body.per === "Hourly" || body.per === "Daily") {
          a_yearly = yearly;
          a_quarterly = quarterly;
          a_monthly = monthly;
          a_sami_month = sami_month;
          a_bi_week = bi_week;
          a_week = week;
          a_daily = daily;
          a_hourly = hourly;
        } else {
          yearly = a_yearly;
          quarterly = a_quarterly;
          monthly = a_monthly;
          sami_month = a_sami_month;
          bi_week = a_bi_week;
          week = a_week;
          daily = a_daily;
          hourly = a_hourly;
        }
      }

      let tax;
      if (!isNaN(body.tax)) {
        if (body.are === 1) {
          tax = body.tax / 100;
        } else {
          tax = 1 - body.tax / 100;
        }
      }

      Object.assign(param, {
        Hourly: +hourly.toFixed(2),
        Daily: daily,
        Week: week,
        Bi_week: bi_week,
        Monthly: monthly,
        Sami_month: sami_month,
        Quarterly: quarterly,
        Yearly: yearly,
        a_Hourly: +a_hourly.toFixed(2),
        a_Daily: a_daily,
        a_Week: a_week,
        a_Bi_week: a_bi_week,
        a_Monthly: a_monthly,
        a_Sami_month: a_sami_month,
        a_Quarterly: a_quarterly,
        a_Yearly: a_yearly,
        RESULT: 1,
      });

      if (typeof tax !== "undefined") {
        param.tax = tax;
      }

      return param;
    } else {
      return {
        error: "Please fill all fields.",
      };
    }
  }

  /**
   * getCalculationIBMCalculator: Service Method
   * POST: /api/calculators-lol/bmi-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationIBMCalculator(body) {
    // const { age, height_cm, ft_in, weight, stage, gender, unit_type } = body;

    let age = body.age;
    let height_cm = body.height_cm;
    let ft_in = body.ft_in;
    let weight = body.weight;
    let stage = body.stage;
    let gender = body.gender;
    let unit_type = body.unit_type;

    let param = {};
    let result = {};
    let height_in;

    if (isNaN(weight)) {
      param.error = "Please Check Your Input.";
      return param;
    }

    if (age > 20) {
      param.error = "Age value Must be less than or equal to 20 ";
      return param;
    }

    let heightInCm = height_cm;

    if (unit_type === "lbs") {
      if (!ft_in) {
        param.error = "Please Select Height";
        return param;
      }
      heightInCm = ft_in * 2.54;
    } else {
      if (!height_cm) {
        param.error = "Please Enter Height";
        return param;
      }
      weight = weight * 2.205; // Convert weight to lbs
    }

    const heightInInches = heightInCm / 2.54;
    const bmi = (weight * 703) / (heightInInches * heightInInches);
    const roundBmi = Math.round(bmi * 100) / 100;

    if (stage === "child") {
      const n = [
        50, 50.399, 50.798, 51.197, 51.595, 51.994, 52.392, 52.79, 53.188,
        53.586, 53.983, 54.38, 54.776, 55.172, 55.567, 55.962, 56.356, 56.749,
        57.142, 57.535, 57.926, 58.317, 58.706, 59.095, 59.483, 59.871, 60.257,
        60.642, 61.026, 61.409, 61.791, 62.172, 62.552, 62.93, 63.307, 63.683,
        64.058, 64.431, 64.803, 65.173, 65.542, 65.91, 66.276, 66.64, 67.003,
        67.364, 67.724, 68.082, 68.439, 68.793, 69.146, 69.497, 69.847, 70.194,
        70.54, 70.884, 71.226, 71.566, 71.904, 72.24, 72.575, 72.907, 73.237,
        73.565, 73.891, 74.215, 74.537, 74.857, 75.175, 75.49, 75.804, 76.115,
        76.424, 76.73, 77.035, 77.337, 77.637, 77.935, 78.23, 78.524, 78.814,
        79.103, 79.389, 79.673, 79.955, 80.234, 80.511, 80.785, 81.057, 81.327,
        81.594, 81.859, 82.121, 82.381, 82.639, 82.894, 83.147, 83.398, 83.646,
        83.891, 84.134, 84.375, 84.614, 84.849, 85.083, 85.314, 85.543, 85.769,
        85.993, 86.214, 86.433, 86.65, 86.864, 87.076, 87.286, 87.493, 87.698,
        87.9, 88.1, 88.298, 88.493, 88.686, 88.877, 89.065, 89.251, 89.435,
        89.617, 89.796, 89.973, 90.147, 90.32, 90.49, 90.658, 90.824, 90.988,
        91.149, 91.308, 91.466, 91.621, 91.774, 91.924, 92.073, 92.22, 92.364,
        92.507, 92.647, 92.785, 92.922, 93.056, 93.189, 93.319, 93.448, 93.574,
        93.699, 93.822, 93.943, 94.062, 94.179, 94.295, 94.408, 94.52, 94.63,
        94.738, 94.845, 94.95, 95.053, 95.154, 95.254, 95.352, 95.449, 95.543,
        95.637, 95.728, 95.818, 95.907, 95.994, 96.08, 96.164, 96.246, 96.327,
        96.407, 96.485, 96.562, 96.638, 96.712, 96.784, 96.856, 96.926, 96.995,
        97.062, 97.128, 97.193, 97.257, 97.32, 97.381, 97.441, 97.5, 97.558,
        97.615, 97.67, 97.725, 97.778, 97.831, 97.882, 97.932, 97.982, 98.03,
        98.077, 98.124, 98.169, 98.214, 98.257, 98.3, 98.341, 98.382, 98.422,
        98.461, 98.5, 98.537, 98.574, 98.61, 98.645, 98.679, 98.713, 98.745,
        98.778, 98.809, 98.84, 98.87, 98.899, 98.928, 98.956, 98.983, 99.01,
        99.036, 99.061, 99.086, 99.111, 99.134, 99.158, 99.18, 99.202, 99.224,
        99.245, 99.266, 99.286, 99.305, 99.324, 99.343, 99.361, 99.379, 99.396,
        99.413, 99.43, 99.446, 99.461, 99.477, 99.492, 99.506, 99.52, 99.534,
        99.547, 99.56, 99.573, 99.585, 99.598, 99.609, 99.621, 99.632, 99.643,
        99.653, 99.664, 99.674, 99.683, 99.693, 99.702, 99.711, 99.72, 99.728,
        99.736, 99.744, 99.752, 99.76, 99.767, 99.774, 99.781, 99.788, 99.795,
        99.801, 99.807, 99.813, 99.819, 99.825, 99.831, 99.836, 99.841, 99.846,
        99.851, 99.856, 99.861, 99.865, 99.869, 99.874, 99.878, 99.882, 99.886,
        99.889, 99.893, 99.896, 99.9,
      ];

      let L, M, S, zScore, thisPercentile;

      const ageMonths = age * 12;

      if (gender === "Male") {
        if (ageMonths >= 24 && ageMonths < 25) {
          L = -1.982373595;
          M = 16.54777487;
          S = 0.080127429;
        } else if (ageMonths >= 25 && ageMonths < 26) {
          L = -1.924100169;
          M = 16.49442763;
          S = 0.079233994;
        } else if (ageMonths >= 26 && ageMonths < 27) {
          L = -1.86549793;
          M = 16.44259552;
          S = 0.078389356;
        } else if (ageMonths >= 27 && ageMonths < 28) {
          L = -1.807261899;
          M = 16.3922434;
          S = 0.077593501;
        } else if (ageMonths >= 28 && ageMonths < 29) {
          L = -1.750118905;
          M = 16.34333654;
          S = 0.076846462;
        } else if (ageMonths >= 29 && ageMonths < 30) {
          L = -1.69481584;
          M = 16.29584097;
          S = 0.076148308;
        } else if (ageMonths >= 30 && ageMonths < 31) {
          L = -1.642106779;
          M = 16.24972371;
          S = 0.075499126;
        } else if (ageMonths >= 31 && ageMonths < 32) {
          L = -1.592744414;
          M = 16.20495268;
          S = 0.074898994;
        } else if (ageMonths >= 32 && ageMonths < 33) {
          L = -1.547442391;
          M = 16.16149871;
          S = 0.074347997;
        } else if (ageMonths >= 33 && ageMonths < 34) {
          L = -1.506902601;
          M = 16.11933258;
          S = 0.073846139;
        } else if (ageMonths >= 34 && ageMonths < 35) {
          L = -1.471770047;
          M = 16.07842758;
          S = 0.07339337;
        } else if (ageMonths >= 35 && ageMonths < 36) {
          L = -1.442628957;
          M = 16.03875896;
          S = 0.072989551;
        } else if (ageMonths >= 36 && ageMonths < 37) {
          L = -1.419991255;
          M = 16.00030401;
          S = 0.072634432;
        } else if (ageMonths >= 37 && ageMonths < 38) {
          L = -1.404277619;
          M = 15.96304277;
          S = 0.072327649;
        } else if (ageMonths >= 38 && ageMonths < 39) {
          L = -1.39586317;
          M = 15.92695418;
          S = 0.07206864;
        } else if (ageMonths >= 39 && ageMonths < 40) {
          L = -1.394935252;
          M = 15.89202582;
          S = 0.071856805;
        } else if (ageMonths >= 40 && ageMonths < 41) {
          L = -1.401671596;
          M = 15.85824093;
          S = 0.071691278;
        } else if (ageMonths >= 41 && ageMonths < 42) {
          L = -1.416100312;
          M = 15.82558822;
          S = 0.071571093;
        } else if (ageMonths >= 42 && ageMonths < 43) {
          L = -1.438164899;
          M = 15.79405728;
          S = 0.071495113;
        } else if (ageMonths >= 43 && ageMonths < 44) {
          L = -1.467669032;
          M = 15.76364255;
          S = 0.071462106;
        } else if (ageMonths >= 44 && ageMonths < 45) {
          L = -1.504376347;
          M = 15.73433668;
          S = 0.071470646;
        } else if (ageMonths >= 45 && ageMonths < 46) {
          L = -1.547942838;
          M = 15.70613566;
          S = 0.071519218;
        } else if (ageMonths >= 46 && ageMonths < 47) {
          L = -1.597896397;
          M = 15.67904062;
          S = 0.071606277;
        } else if (ageMonths >= 47 && ageMonths < 48) {
          L = -1.653732283;
          M = 15.65305192;
          S = 0.071730167;
        } else if (ageMonths >= 48 && ageMonths < 49) {
          L = -1.714869347;
          M = 15.62817269;
          S = 0.071889214;
        } else if (ageMonths >= 49 && ageMonths < 50) {
          L = -1.780673181;
          M = 15.604408;
          S = 0.072081737;
        } else if (ageMonths >= 50 && ageMonths < 51) {
          L = -1.850468473;
          M = 15.58176458;
          S = 0.072306081;
        } else if (ageMonths >= 51 && ageMonths < 52) {
          L = -1.923551865;
          M = 15.56025067;
          S = 0.072560637;
        } else if (ageMonths >= 52 && ageMonths < 53) {
          L = -1.999220429;
          M = 15.5398746;
          S = 0.07284384;
        } else if (ageMonths >= 53 && ageMonths < 54) {
          L = -2.076707178;
          M = 15.52064993;
          S = 0.073154324;
        } else if (ageMonths >= 54 && ageMonths < 55) {
          L = -2.155348017;
          M = 15.50258427;
          S = 0.073490667;
        } else if (ageMonths >= 55 && ageMonths < 56) {
          L = -2.234438552;
          M = 15.48568973;
          S = 0.073851672;
        } else if (ageMonths >= 56 && ageMonths < 57) {
          L = -2.313321723;
          M = 15.46997718;
          S = 0.074236235;
        } else if (ageMonths >= 57 && ageMonths < 58) {
          L = -2.391381273;
          M = 15.45545692;
          S = 0.074643374;
        } else if (ageMonths >= 58 && ageMonths < 59) {
          L = -2.468032491;
          M = 15.44213961;
          S = 0.075072264;
        } else if (ageMonths >= 59 && ageMonths < 60) {
          L = -2.542781541;
          M = 15.43003207;
          S = 0.075522104;
        } else if (ageMonths >= 60 && ageMonths < 61) {
          L = -2.61516595;
          M = 15.41914163;
          S = 0.07599225;
        } else if (ageMonths >= 61 && ageMonths < 62) {
          L = -2.684789516;
          M = 15.40947356;
          S = 0.076482128;
        } else if (ageMonths >= 62 && ageMonths < 63) {
          L = -2.751316949;
          M = 15.40103139;
          S = 0.076991232;
        } else if (ageMonths >= 63 && ageMonths < 64) {
          L = -2.81445945;
          M = 15.39381785;
          S = 0.077519149;
        } else if (ageMonths >= 64 && ageMonths < 65) {
          L = -2.87402476;
          M = 15.38783094;
          S = 0.07806539;
        } else if (ageMonths >= 65 && ageMonths < 66) {
          L = -2.92984048;
          M = 15.38306945;
          S = 0.078629592;
        } else if (ageMonths >= 66 && ageMonths < 67) {
          L = -2.981796828;
          M = 15.37952958;
          S = 0.079211369;
        } else if (ageMonths >= 67 && ageMonths < 68) {
          L = -3.029831343;
          M = 15.37720582;
          S = 0.079810334;
        } else if (ageMonths >= 68 && ageMonths < 69) {
          L = -3.073924224;
          M = 15.37609107;
          S = 0.080426086;
        } else if (ageMonths >= 69 && ageMonths < 70) {
          L = -3.114093476;
          M = 15.37617677;
          S = 0.081058206;
        } else if (ageMonths >= 70 && ageMonths < 71) {
          L = -3.15039004;
          M = 15.37745304;
          S = 0.081706249;
        } else if (ageMonths >= 71 && ageMonths < 72) {
          L = -3.182893018;
          M = 15.37990886;
          S = 0.082369741;
        } else if (ageMonths >= 72 && ageMonths < 73) {
          L = -3.21170511;
          M = 15.38353217;
          S = 0.083048178;
        } else if (ageMonths >= 73 && ageMonths < 74) {
          L = -3.23694834;
          M = 15.38831005;
          S = 0.083741021;
        } else if (ageMonths >= 74 && ageMonths < 75) {
          L = -3.25876011;
          M = 15.39422883;
          S = 0.0844477;
        } else if (ageMonths >= 75 && ageMonths < 76) {
          L = -3.277281546;
          M = 15.40127496;
          S = 0.085167651;
        } else if (ageMonths >= 76 && ageMonths < 77) {
          L = -3.292683774;
          M = 15.40943252;
          S = 0.085900184;
        } else if (ageMonths >= 77 && ageMonths < 78) {
          L = -3.305124073;
          M = 15.41868691;
          S = 0.086644667;
        } else if (ageMonths >= 78 && ageMonths < 79) {
          L = -3.314768951;
          M = 15.42902273;
          S = 0.087400421;
        } else if (ageMonths >= 79 && ageMonths < 80) {
          L = -3.321785992;
          M = 15.44042439;
          S = 0.088166744;
        } else if (ageMonths >= 80 && ageMonths < 81) {
          L = -3.326345795;
          M = 15.45287581;
          S = 0.088942897;
        } else if (ageMonths >= 81 && ageMonths < 82) {
          L = -3.328602731;
          M = 15.46636218;
          S = 0.089728202;
        } else if (ageMonths >= 82 && ageMonths < 83) {
          L = -3.328725277;
          M = 15.48086704;
          S = 0.090521875;
        } else if (ageMonths >= 83 && ageMonths < 84) {
          L = -3.32687018;
          M = 15.49637465;
          S = 0.091323162;
        } else if (ageMonths >= 84 && ageMonths < 85) {
          L = -3.323188896;
          M = 15.51286936;
          S = 0.092131305;
        } else if (ageMonths >= 85 && ageMonths < 86) {
          L = -3.317827016;
          M = 15.53033563;
          S = 0.092945544;
        } else if (ageMonths >= 86 && ageMonths < 87) {
          L = -3.310923871;
          M = 15.54875807;
          S = 0.093765118;
        } else if (ageMonths >= 87 && ageMonths < 88) {
          L = -3.302612272;
          M = 15.56812143;
          S = 0.09458927;
        } else if (ageMonths >= 88 && ageMonths < 89) {
          L = -3.293018361;
          M = 15.58841065;
          S = 0.095417247;
        } else if (ageMonths >= 89 && ageMonths < 90) {
          L = -3.282260813;
          M = 15.60961101;
          S = 0.096248301;
        } else if (ageMonths >= 90 && ageMonths < 91) {
          L = -3.270454609;
          M = 15.63170735;
          S = 0.097081694;
        } else if (ageMonths >= 91 && ageMonths < 92) {
          L = -3.257703616;
          M = 15.65468563;
          S = 0.097916698;
        } else if (ageMonths >= 92 && ageMonths < 93) {
          L = -3.244108214;
          M = 15.67853139;
          S = 0.098752593;
        } else if (ageMonths >= 93 && ageMonths < 94) {
          L = -3.229761713;
          M = 15.70323052;
          S = 0.099588675;
        } else if (ageMonths >= 94 && ageMonths < 95) {
          L = -3.214751287;
          M = 15.72876911;
          S = 0.100424251;
        } else if (ageMonths >= 95 && ageMonths < 96) {
          L = -3.199158184;
          M = 15.75513347;
          S = 0.101258643;
        } else if (ageMonths >= 96 && ageMonths < 97) {
          L = -3.18305795;
          M = 15.78231007;
          S = 0.102091189;
        } else if (ageMonths >= 97 && ageMonths < 98) {
          L = -3.166520664;
          M = 15.8102856;
          S = 0.102921245;
        } else if (ageMonths >= 98 && ageMonths < 99) {
          L = -3.1496103;
          M = 15.83904708;
          S = 0.103748189;
        } else if (ageMonths >= 99 && ageMonths < 100) {
          L = -3.132389637;
          M = 15.86858123;
          S = 0.104571386;
        } else if (ageMonths >= 100 && ageMonths < 101) {
          L = -3.114911153;
          M = 15.89887562;
          S = 0.105390269;
        } else if (ageMonths >= 101 && ageMonths < 102) {
          L = -3.097226399;
          M = 15.92991765;
          S = 0.106204258;
        } else if (ageMonths >= 102 && ageMonths < 103) {
          L = -3.079383079;
          M = 15.96169481;
          S = 0.107012788;
        } else if (ageMonths >= 103 && ageMonths < 104) {
          L = -3.061423765;
          M = 15.99419489;
          S = 0.107815327;
        } else if (ageMonths >= 104 && ageMonths < 105) {
          L = -3.043386071;
          M = 16.02740607;
          S = 0.108611374;
        } else if (ageMonths >= 105 && ageMonths < 106) {
          L = -3.025310003;
          M = 16.0613159;
          S = 0.109400388;
        } else if (ageMonths >= 106 && ageMonths < 107) {
          L = -3.007225737;
          M = 16.09591292;
          S = 0.110181915;
        } else if (ageMonths >= 107 && ageMonths < 108) {
          L = -2.989164598;
          M = 16.13118532;
          S = 0.110955478;
        } else if (ageMonths >= 108 && ageMonths < 109) {
          L = -2.971148225;
          M = 16.16712234;
          S = 0.111720691;
        } else if (ageMonths >= 109 && ageMonths < 110) {
          L = -2.953208047;
          M = 16.20371168;
          S = 0.112477059;
        } else if (ageMonths >= 110 && ageMonths < 111) {
          L = -2.935363951;
          M = 16.24094239;
          S = 0.1132242;
        } else if (ageMonths >= 111 && ageMonths < 112) {
          L = -2.917635157;
          M = 16.27880346;
          S = 0.113961734;
        } else if (ageMonths >= 112 && ageMonths < 113) {
          L = -2.900039803;
          M = 16.31728385;
          S = 0.114689291;
        } else if (ageMonths >= 113 && ageMonths < 114) {
          L = -2.882593796;
          M = 16.35637267;
          S = 0.115406523;
        } else if (ageMonths >= 114 && ageMonths < 115) {
          L = -2.865311266;
          M = 16.39605916;
          S = 0.116113097;
        } else if (ageMonths >= 115 && ageMonths < 116) {
          L = -2.848204697;
          M = 16.43633265;
          S = 0.116808702;
        } else if (ageMonths >= 116 && ageMonths < 117) {
          L = -2.831285052;
          M = 16.47718256;
          S = 0.117493042;
        } else if (ageMonths >= 117 && ageMonths < 118) {
          L = -2.81456189;
          M = 16.51859843;
          S = 0.11816584;
        } else if (ageMonths >= 118 && ageMonths < 119) {
          L = -2.79804347;
          M = 16.56056987;
          S = 0.118826835;
        } else if (ageMonths >= 119 && ageMonths < 120) {
          L = -2.781736856;
          M = 16.60308661;
          S = 0.119475785;
        } else if (ageMonths >= 120 && ageMonths < 121) {
          L = -2.765648008;
          M = 16.64613844;
          S = 0.120112464;
        } else if (ageMonths >= 121 && ageMonths < 122) {
          L = -2.749782197;
          M = 16.68971518;
          S = 0.120736656;
        } else if (ageMonths >= 122 && ageMonths < 123) {
          L = -2.734142443;
          M = 16.73380695;
          S = 0.121348181;
        } else if (ageMonths >= 123 && ageMonths < 124) {
          L = -2.718732873;
          M = 16.77840363;
          S = 0.121946849;
        } else if (ageMonths >= 124 && ageMonths < 125) {
          L = -2.703555506;
          M = 16.82349538;
          S = 0.122532501;
        } else if (ageMonths >= 125 && ageMonths < 126) {
          L = -2.688611957;
          M = 16.86907238;
          S = 0.123104991;
        } else if (ageMonths >= 126 && ageMonths < 127) {
          L = -2.673903164;
          M = 16.91512487;
          S = 0.123664186;
        } else if (ageMonths >= 127 && ageMonths < 128) {
          L = -2.659429443;
          M = 16.96164317;
          S = 0.124209969;
        } else if (ageMonths >= 128 && ageMonths < 129) {
          L = -2.645190534;
          M = 17.00861766;
          S = 0.124742239;
        } else if (ageMonths >= 129 && ageMonths < 130) {
          L = -2.631185649;
          M = 17.05603879;
          S = 0.125260905;
        } else if (ageMonths >= 130 && ageMonths < 131) {
          L = -2.617413511;
          M = 17.10389705;
          S = 0.125765895;
        } else if (ageMonths >= 131 && ageMonths < 132) {
          L = -2.603872392;
          M = 17.15218302;
          S = 0.126257147;
        } else if (ageMonths >= 132 && ageMonths < 133) {
          L = -2.590560148;
          M = 17.20088732;
          S = 0.126734613;
        } else if (ageMonths >= 133 && ageMonths < 134) {
          L = -2.577474253;
          M = 17.25000062;
          S = 0.12719826;
        } else if (ageMonths >= 134 && ageMonths < 135) {
          L = -2.564611831;
          M = 17.29951367;
          S = 0.127648067;
        } else if (ageMonths >= 135 && ageMonths < 136) {
          L = -2.551969684;
          M = 17.34941726;
          S = 0.128084023;
        } else if (ageMonths >= 136 && ageMonths < 137) {
          L = -2.539539972;
          M = 17.39970308;
          S = 0.128506192;
        } else if (ageMonths >= 137 && ageMonths < 138) {
          L = -2.527325681;
          M = 17.45036072;
          S = 0.128914497;
        } else if (ageMonths >= 138 && ageMonths < 139) {
          L = -2.515320235;
          M = 17.50138161;
          S = 0.129309001;
        } else if (ageMonths >= 139 && ageMonths < 140) {
          L = -2.503519447;
          M = 17.55275674;
          S = 0.129689741;
        } else if (ageMonths >= 140 && ageMonths < 141) {
          L = -2.491918934;
          M = 17.60447714;
          S = 0.130056765;
        } else if (ageMonths >= 141 && ageMonths < 142) {
          L = -2.480514136;
          M = 17.6565339;
          S = 0.130410133;
        } else if (ageMonths >= 142 && ageMonths < 143) {
          L = -2.469300331;
          M = 17.70891811;
          S = 0.130749913;
        } else if (ageMonths >= 143 && ageMonths < 144) {
          L = -2.458272656;
          M = 17.76162094;
          S = 0.131076187;
        } else if (ageMonths >= 144 && ageMonths < 145) {
          L = -2.447426113;
          M = 17.81463359;
          S = 0.131389042;
        } else if (ageMonths >= 145 && ageMonths < 146) {
          L = -2.436755595;
          M = 17.86794729;
          S = 0.131688579;
        } else if (ageMonths >= 146 && ageMonths < 147) {
          L = -2.426255887;
          M = 17.92155332;
          S = 0.131974905;
        } else if (ageMonths >= 147 && ageMonths < 148) {
          L = -2.415921689;
          M = 17.97544299;
          S = 0.132248138;
        } else if (ageMonths >= 148 && ageMonths < 149) {
          L = -2.405747619;
          M = 18.02960765;
          S = 0.132508403;
        } else if (ageMonths >= 149 && ageMonths < 150) {
          L = -2.395728233;
          M = 18.08403868;
          S = 0.132755834;
        } else if (ageMonths >= 150 && ageMonths < 151) {
          L = -2.385858029;
          M = 18.1387275;
          S = 0.132990575;
        } else if (ageMonths >= 151 && ageMonths < 152) {
          L = -2.376131459;
          M = 18.19366555;
          S = 0.133212776;
        } else if (ageMonths >= 152 && ageMonths < 153) {
          L = -2.366542942;
          M = 18.24884431;
          S = 0.133422595;
        } else if (ageMonths >= 153 && ageMonths < 154) {
          L = -2.357086871;
          M = 18.3042553;
          S = 0.133620197;
        } else if (ageMonths >= 154 && ageMonths < 155) {
          L = -2.347757625;
          M = 18.35989003;
          S = 0.133805756;
        } else if (ageMonths >= 155 && ageMonths < 156) {
          L = -2.338549576;
          M = 18.41574009;
          S = 0.133979452;
        } else if (ageMonths >= 156 && ageMonths < 157) {
          L = -2.3294571;
          M = 18.47179706;
          S = 0.13414147;
        } else if (ageMonths >= 157 && ageMonths < 158) {
          L = -2.320474586;
          M = 18.52805255;
          S = 0.134292005;
        } else if (ageMonths >= 158 && ageMonths < 159) {
          L = -2.311596446;
          M = 18.5844982;
          S = 0.134431256;
        } else if (ageMonths >= 159 && ageMonths < 160) {
          L = -2.302817124;
          M = 18.64112567;
          S = 0.134559427;
        } else if (ageMonths >= 160 && ageMonths < 161) {
          L = -2.294131107;
          M = 18.69792663;
          S = 0.134676731;
        } else if (ageMonths >= 161 && ageMonths < 162) {
          L = -2.285532933;
          M = 18.75489278;
          S = 0.134783385;
        } else if (ageMonths >= 162 && ageMonths < 163) {
          L = -2.277017201;
          M = 18.81201584;
          S = 0.134879611;
        } else if (ageMonths >= 163 && ageMonths < 164) {
          L = -2.268578584;
          M = 18.86928753;
          S = 0.134965637;
        } else if (ageMonths >= 164 && ageMonths < 165) {
          L = -2.260211837;
          M = 18.92669959;
          S = 0.135041695;
        } else if (ageMonths >= 165 && ageMonths < 166) {
          L = -2.251911809;
          M = 18.98424378;
          S = 0.135108024;
        } else if (ageMonths >= 166 && ageMonths < 167) {
          L = -2.243673453;
          M = 19.04191185;
          S = 0.135164867;
        } else if (ageMonths >= 167 && ageMonths < 168) {
          L = -2.235491842;
          M = 19.09969557;
          S = 0.135212469;
        } else if (ageMonths >= 168 && ageMonths < 169) {
          L = -2.227362173;
          M = 19.15758672;
          S = 0.135251083;
        } else if (ageMonths >= 169 && ageMonths < 170) {
          L = -2.21927979;
          M = 19.21557707;
          S = 0.135280963;
        } else if (ageMonths >= 170 && ageMonths < 171) {
          L = -2.211240187;
          M = 19.27365839;
          S = 0.135302371;
        } else if (ageMonths >= 171 && ageMonths < 172) {
          L = -2.203239029;
          M = 19.33182247;
          S = 0.135315568;
        } else if (ageMonths >= 172 && ageMonths < 173) {
          L = -2.195272161;
          M = 19.39006106;
          S = 0.135320824;
        } else if (ageMonths >= 173 && ageMonths < 174) {
          L = -2.187335625;
          M = 19.44836594;
          S = 0.135318407;
        } else if (ageMonths >= 174 && ageMonths < 175) {
          L = -2.179425674;
          M = 19.50672885;
          S = 0.135308594;
        } else if (ageMonths >= 175 && ageMonths < 176) {
          L = -2.171538789;
          M = 19.56514153;
          S = 0.135291662;
        } else if (ageMonths >= 176 && ageMonths < 177) {
          L = -2.163671689;
          M = 19.62359571;
          S = 0.135267891;
        } else if (ageMonths >= 177 && ageMonths < 178) {
          L = -2.155821357;
          M = 19.6820831;
          S = 0.135237567;
        } else if (ageMonths >= 178 && ageMonths < 179) {
          L = -2.147985046;
          M = 19.74059538;
          S = 0.135200976;
        } else if (ageMonths >= 179 && ageMonths < 180) {
          L = -2.140160305;
          M = 19.7991242;
          S = 0.135158409;
        } else if (ageMonths >= 180 && ageMonths < 181) {
          L = -2.132344989;
          M = 19.85766121;
          S = 0.135110159;
        } else if (ageMonths >= 181 && ageMonths < 182) {
          L = -2.124537282;
          M = 19.916198;
          S = 0.135056522;
        } else if (ageMonths >= 182 && ageMonths < 183) {
          L = -2.116735712;
          M = 19.97472615;
          S = 0.134997797;
        } else if (ageMonths >= 183 && ageMonths < 184) {
          L = -2.108939167;
          M = 20.03323719;
          S = 0.134934285;
        } else if (ageMonths >= 184 && ageMonths < 185) {
          L = -2.10114692;
          M = 20.09172262;
          S = 0.134866291;
        } else if (ageMonths >= 185 && ageMonths < 186) {
          L = -2.093358637;
          M = 20.15017387;
          S = 0.134794121;
        } else if (ageMonths >= 186 && ageMonths < 187) {
          L = -2.085574403;
          M = 20.20858236;
          S = 0.134718085;
        } else if (ageMonths >= 187 && ageMonths < 188) {
          L = -2.077794735;
          M = 20.26693944;
          S = 0.134638494;
        } else if (ageMonths >= 188 && ageMonths < 189) {
          L = -2.070020599;
          M = 20.32523642;
          S = 0.134555663;
        } else if (ageMonths >= 189 && ageMonths < 190) {
          L = -2.062253431;
          M = 20.38346455;
          S = 0.13446991;
        } else if (ageMonths >= 190 && ageMonths < 191) {
          L = -2.054495145;
          M = 20.44161501;
          S = 0.134381553;
        } else if (ageMonths >= 191 && ageMonths < 192) {
          L = -2.046748156;
          M = 20.49967894;
          S = 0.134290916;
        } else if (ageMonths >= 192 && ageMonths < 193) {
          L = -2.039015385;
          M = 20.5576474;
          S = 0.134198323;
        } else if (ageMonths >= 193 && ageMonths < 194) {
          L = -2.031300282;
          M = 20.6155114;
          S = 0.134104101;
        } else if (ageMonths >= 194 && ageMonths < 195) {
          L = -2.023606828;
          M = 20.67326189;
          S = 0.134008581;
        } else if (ageMonths >= 195 && ageMonths < 196) {
          L = -2.015942013;
          M = 20.73088905;
          S = 0.133912066;
        } else if (ageMonths >= 196 && ageMonths < 197) {
          L = -2.008305745;
          M = 20.7883851;
          S = 0.133814954;
        } else if (ageMonths >= 197 && ageMonths < 198) {
          L = -2.000706389;
          M = 20.84574003;
          S = 0.133717552;
        } else if (ageMonths >= 198 && ageMonths < 199) {
          L = -1.993150137;
          M = 20.90294449;
          S = 0.1336202;
        } else if (ageMonths >= 199 && ageMonths < 200) {
          L = -1.985643741;
          M = 20.95998909;
          S = 0.133523244;
        } else if (ageMonths >= 200 && ageMonths < 201) {
          L = -1.97819451;
          M = 21.01686433;
          S = 0.133427032;
        } else if (ageMonths >= 201 && ageMonths < 202) {
          L = -1.970810308;
          M = 21.07356067;
          S = 0.133331914;
        } else if (ageMonths >= 202 && ageMonths < 203) {
          L = -1.96349954;
          M = 21.1300685;
          S = 0.133238245;
        } else if (ageMonths >= 203 && ageMonths < 204) {
          L = -1.956271141;
          M = 21.18637813;
          S = 0.133146383;
        } else if (ageMonths >= 204 && ageMonths < 205) {
          L = -1.949134561;
          M = 21.24247982;
          S = 0.13305669;
        } else if (ageMonths >= 205 && ageMonths < 206) {
          L = -1.942099744;
          M = 21.29836376;
          S = 0.132969531;
        } else if (ageMonths >= 206 && ageMonths < 207) {
          L = -1.935177101;
          M = 21.35402009;
          S = 0.132885274;
        } else if (ageMonths >= 207 && ageMonths < 208) {
          L = -1.92837748;
          M = 21.40943891;
          S = 0.132804292;
        } else if (ageMonths >= 208 && ageMonths < 209) {
          L = -1.921712136;
          M = 21.46461026;
          S = 0.132726962;
        } else if (ageMonths >= 209 && ageMonths < 210) {
          L = -1.915192685;
          M = 21.51952414;
          S = 0.132653664;
        } else if (ageMonths >= 210 && ageMonths < 211) {
          L = -1.908831065;
          M = 21.57417053;
          S = 0.132584784;
        } else if (ageMonths >= 211 && ageMonths < 212) {
          L = -1.902639482;
          M = 21.62853937;
          S = 0.132520711;
        } else if (ageMonths >= 212 && ageMonths < 213) {
          L = -1.896630358;
          M = 21.68262062;
          S = 0.132461838;
        } else if (ageMonths >= 213 && ageMonths < 214) {
          L = -1.890816268;
          M = 21.73640419;
          S = 0.132408563;
        } else if (ageMonths >= 214 && ageMonths < 215) {
          L = -1.885209876;
          M = 21.78988003;
          S = 0.132361289;
        } else if (ageMonths >= 215 && ageMonths < 216) {
          L = -1.879823505;
          M = 21.84303819;
          S = 0.132320427;
        } else if (ageMonths >= 216 && ageMonths < 217) {
          L = -1.874670324;
          M = 21.8958685;
          S = 0.132286382;
        } else if (ageMonths >= 217 && ageMonths < 218) {
          L = -1.869760299;
          M = 21.94836168;
          S = 0.1322596;
        } else if (ageMonths >= 218 && ageMonths < 219) {
          L = -1.865113245;
          M = 22.00050569;
          S = 0.132240418;
        } else if (ageMonths >= 219 && ageMonths < 220) {
          L = -1.860734944;
          M = 22.05229242;
          S = 0.13222933;
        } else if (ageMonths >= 220 && ageMonths < 221) {
          L = -1.85663384;
          M = 22.10371305;
          S = 0.132226801;
        } else if (ageMonths >= 221 && ageMonths < 222) {
          L = -1.852827186;
          M = 22.15475603;
          S = 0.132233201;
        } else if (ageMonths >= 222 && ageMonths < 223) {
          L = -1.849323204;
          M = 22.20541249;
          S = 0.132248993;
        } else if (ageMonths >= 223 && ageMonths < 224) {
          L = -1.846131607;
          M = 22.255673;
          S = 0.132274625;
        } else if (ageMonths >= 224 && ageMonths < 225) {
          L = -1.843261294;
          M = 22.30552831;
          S = 0.132310549;
        } else if (ageMonths >= 225 && ageMonths < 226) {
          L = -1.840720248;
          M = 22.3549693;
          S = 0.132357221;
        } else if (ageMonths >= 226 && ageMonths < 227) {
          L = -1.83851544;
          M = 22.40398706;
          S = 0.132415103;
        } else if (ageMonths >= 227 && ageMonths < 228) {
          L = -1.83665586;
          M = 22.45257182;
          S = 0.132484631;
        } else if (ageMonths >= 228 && ageMonths < 229) {
          L = -1.835138046;
          M = 22.50071778;
          S = 0.132566359;
        } else if (ageMonths >= 229 && ageMonths < 230) {
          L = -1.833972004;
          M = 22.54841437;
          S = 0.132660699;
        } else if (ageMonths >= 230 && ageMonths < 231) {
          L = -1.833157751;
          M = 22.59565422;
          S = 0.132768153;
        } else if (ageMonths >= 231 && ageMonths < 232) {
          L = -1.83269562;
          M = 22.64242956;
          S = 0.132889211;
        } else if (ageMonths >= 232 && ageMonths < 233) {
          L = -1.832584342;
          M = 22.68873292;
          S = 0.133024368;
        } else if (ageMonths >= 233 && ageMonths < 234) {
          L = -1.832820974;
          M = 22.73455713;
          S = 0.133174129;
        } else if (ageMonths >= 234 && ageMonths < 235) {
          L = -1.833400825;
          M = 22.7798953;
          S = 0.133338999;
        } else if (ageMonths >= 235 && ageMonths < 236) {
          L = -1.834317405;
          M = 22.82474087;
          S = 0.133519496;
        } else if (ageMonths >= 236 && ageMonths < 237) {
          L = -1.83555752;
          M = 22.86908912;
          S = 0.133716192;
        } else if (ageMonths >= 237 && ageMonths < 238) {
          L = -1.837119466;
          M = 22.91293151;
          S = 0.133929525;
        } else if (ageMonths >= 238 && ageMonths < 239) {
          L = -1.838987063;
          M = 22.95626373;
          S = 0.134160073;
        } else if (ageMonths >= 239 && ageMonths < 240) {
          L = -1.841146139;
          M = 22.99908062;
          S = 0.134408381;
        } else if (ageMonths >= 240 && ageMonths < 241) {
          L = -1.843580575;
          M = 23.04137734;
          S = 0.134675001;
        }
        zScore = (Math.pow(roundBmi / M, L) - 1) / (L * S);
      }

      if (gender === "Female") {
        if (ageMonths >= 24 && ageMonths < 25) {
          L = -1.024496827;
          M = 16.38804056;
          S = 0.085025838;
        } else if (ageMonths >= 25 && ageMonths < 26) {
          L = -1.102698353;
          M = 16.3189719;
          S = 0.084214052;
        } else if (ageMonths >= 26 && ageMonths < 27) {
          L = -1.18396635;
          M = 16.25207985;
          S = 0.083455124;
        } else if (ageMonths >= 27 && ageMonths < 28) {
          L = -1.268071036;
          M = 16.18734669;
          S = 0.082748284;
        } else if (ageMonths >= 28 && ageMonths < 29) {
          L = -1.354751525;
          M = 16.12475448;
          S = 0.082092737;
        } else if (ageMonths >= 29 && ageMonths < 30) {
          L = -1.443689692;
          M = 16.06428762;
          S = 0.081487717;
        } else if (ageMonths >= 30 && ageMonths < 31) {
          L = -1.53454192;
          M = 16.00593001;
          S = 0.080932448;
        } else if (ageMonths >= 31 && ageMonths < 32) {
          L = -1.626928093;
          M = 15.94966631;
          S = 0.080426175;
        } else if (ageMonths >= 32 && ageMonths < 33) {
          L = -1.720434829;
          M = 15.89548197;
          S = 0.079968176;
        } else if (ageMonths >= 33 && ageMonths < 34) {
          L = -1.814635262;
          M = 15.84336179;
          S = 0.079557735;
        } else if (ageMonths >= 34 && ageMonths < 35) {
          L = -1.909076262;
          M = 15.79329146;
          S = 0.079194187;
        } else if (ageMonths >= 35 && ageMonths < 36) {
          L = -2.003296102;
          M = 15.7452564;
          S = 0.078876895;
        } else if (ageMonths >= 36 && ageMonths < 37) {
          L = -2.096828937;
          M = 15.69924188;
          S = 0.078605255;
        } else if (ageMonths >= 37 && ageMonths < 38) {
          L = -2.189211877;
          M = 15.65523282;
          S = 0.078378696;
        } else if (ageMonths >= 38 && ageMonths < 39) {
          L = -2.279991982;
          M = 15.61321371;
          S = 0.078196674;
        } else if (ageMonths >= 39 && ageMonths < 40) {
          L = -2.368732949;
          M = 15.57316843;
          S = 0.078058667;
        } else if (ageMonths >= 40 && ageMonths < 41) {
          L = -2.455021314;
          M = 15.53508019;
          S = 0.077964169;
        } else if (ageMonths >= 41 && ageMonths < 42) {
          L = -2.538471972;
          M = 15.49893145;
          S = 0.077912684;
        } else if (ageMonths >= 42 && ageMonths < 43) {
          L = -2.618732901;
          M = 15.46470384;
          S = 0.077903716;
        } else if (ageMonths >= 43 && ageMonths < 44) {
          L = -2.695488973;
          M = 15.43237817;
          S = 0.077936763;
        } else if (ageMonths >= 44 && ageMonths < 45) {
          L = -2.768464816;
          M = 15.40193436;
          S = 0.078011309;
        } else if (ageMonths >= 45 && ageMonths < 46) {
          L = -2.837426693;
          M = 15.37335154;
          S = 0.078126817;
        } else if (ageMonths >= 46 && ageMonths < 47) {
          L = -2.902178205;
          M = 15.34660842;
          S = 0.078282739;
        } else if (ageMonths >= 47 && ageMonths < 48) {
          L = -2.962580386;
          M = 15.32168181;
          S = 0.078478449;
        } else if (ageMonths >= 48 && ageMonths < 49) {
          L = -3.018521987;
          M = 15.29854897;
          S = 0.078713325;
        } else if (ageMonths >= 49 && ageMonths < 50) {
          L = -3.069936555;
          M = 15.27718618;
          S = 0.078986694;
        } else if (ageMonths >= 50 && ageMonths < 51) {
          L = -3.116795864;
          M = 15.2575692;
          S = 0.079297841;
        } else if (ageMonths >= 51 && ageMonths < 52) {
          L = -3.159107331;
          M = 15.23967338;
          S = 0.079646006;
        } else if (ageMonths >= 52 && ageMonths < 53) {
          L = -3.196911083;
          M = 15.22347371;
          S = 0.080030389;
        } else if (ageMonths >= 53 && ageMonths < 54) {
          L = -3.230276759;
          M = 15.20894491;
          S = 0.080450145;
        } else if (ageMonths >= 54 && ageMonths < 55) {
          L = -3.259300182;
          M = 15.19606152;
          S = 0.080904391;
        } else if (ageMonths >= 55 && ageMonths < 56) {
          L = -3.284099963;
          M = 15.18479799;
          S = 0.081392203;
        } else if (ageMonths >= 56 && ageMonths < 57) {
          L = -3.30481415;
          M = 15.17512871;
          S = 0.081912623;
        } else if (ageMonths >= 57 && ageMonths < 58) {
          L = -3.321596954;
          M = 15.16702811;
          S = 0.082464661;
        } else if (ageMonths >= 58 && ageMonths < 59) {
          L = -3.334615646;
          M = 15.16047068;
          S = 0.083047295;
        } else if (ageMonths >= 59 && ageMonths < 60) {
          L = -3.344047622;
          M = 15.15543107;
          S = 0.083659478;
        } else if (ageMonths >= 60 && ageMonths < 61) {
          L = -3.35007771;
          M = 15.15188405;
          S = 0.084300139;
        } else if (ageMonths >= 61 && ageMonths < 62) {
          L = -3.352893805;
          M = 15.14980479;
          S = 0.0849682;
        } else if (ageMonths >= 62 && ageMonths < 63) {
          L = -3.352691376;
          M = 15.14916825;
          S = 0.085662539;
        } else if (ageMonths >= 63 && ageMonths < 64) {
          L = -3.34966438;
          M = 15.14994984;
          S = 0.086382035;
        } else if (ageMonths >= 64 && ageMonths < 65) {
          L = -3.343998803;
          M = 15.15212585;
          S = 0.087125591;
        } else if (ageMonths >= 65 && ageMonths < 66) {
          L = -3.335889574;
          M = 15.15567186;
          S = 0.087892047;
        } else if (ageMonths >= 66 && ageMonths < 67) {
          L = -3.325522491;
          M = 15.16056419;
          S = 0.088680264;
        } else if (ageMonths >= 67 && ageMonths < 68) {
          L = -3.31307846;
          M = 15.16677947;
          S = 0.089489106;
        } else if (ageMonths >= 68 && ageMonths < 69) {
          L = -3.298732648;
          M = 15.17429464;
          S = 0.090317434;
        } else if (ageMonths >= 69 && ageMonths < 70) {
          L = -3.282653831;
          M = 15.18308694;
          S = 0.091164117;
        } else if (ageMonths >= 70 && ageMonths < 71) {
          L = -3.265003896;
          M = 15.1931339;
          S = 0.092028028;
        } else if (ageMonths >= 71 && ageMonths < 72) {
          L = -3.245937506;
          M = 15.20441335;
          S = 0.092908048;
        } else if (ageMonths >= 72 && ageMonths < 73) {
          L = -3.225606516;
          M = 15.21690296;
          S = 0.093803033;
        } else if (ageMonths >= 73 && ageMonths < 74) {
          L = -3.204146115;
          M = 15.2305815;
          S = 0.094711916;
        } else if (ageMonths >= 74 && ageMonths < 75) {
          L = -3.181690237;
          M = 15.24542745;
          S = 0.095633595;
        } else if (ageMonths >= 75 && ageMonths < 76) {
          L = -3.158363475;
          M = 15.26141966;
          S = 0.096566992;
        } else if (ageMonths >= 76 && ageMonths < 77) {
          L = -3.134282833;
          M = 15.27853728;
          S = 0.097511046;
        } else if (ageMonths >= 77 && ageMonths < 78) {
          L = -3.109557879;
          M = 15.29675967;
          S = 0.09846471;
        } else if (ageMonths >= 78 && ageMonths < 79) {
          L = -3.084290931;
          M = 15.31606644;
          S = 0.099426955;
        } else if (ageMonths >= 79 && ageMonths < 80) {
          L = -3.058577292;
          M = 15.33643745;
          S = 0.100396769;
        } else if (ageMonths >= 80 && ageMonths < 81) {
          L = -3.032505499;
          M = 15.35785274;
          S = 0.101373159;
        } else if (ageMonths >= 81 && ageMonths < 82) {
          L = -3.0061576;
          M = 15.38029261;
          S = 0.10235515;
        } else if (ageMonths >= 82 && ageMonths < 83) {
          L = -2.979609448;
          M = 15.40373754;
          S = 0.103341788;
        } else if (ageMonths >= 83 && ageMonths < 84) {
          L = -2.952930993;
          M = 15.42816819;
          S = 0.104332139;
        } else if (ageMonths >= 84 && ageMonths < 85) {
          L = -2.926186592;
          M = 15.45356545;
          S = 0.105325289;
        } else if (ageMonths >= 85 && ageMonths < 86) {
          L = -2.899435307;
          M = 15.47991037;
          S = 0.106320346;
        } else if (ageMonths >= 86 && ageMonths < 87) {
          L = -2.872731211;
          M = 15.50718419;
          S = 0.10731644;
        } else if (ageMonths >= 87 && ageMonths < 88) {
          L = -2.846123683;
          M = 15.53536829;
          S = 0.108312721;
        } else if (ageMonths >= 88 && ageMonths < 89) {
          L = -2.819657704;
          M = 15.56444426;
          S = 0.109308364;
        } else if (ageMonths >= 89 && ageMonths < 90) {
          L = -2.793374145;
          M = 15.5943938;
          S = 0.110302563;
        } else if (ageMonths >= 90 && ageMonths < 91) {
          L = -2.767310047;
          M = 15.6251988;
          S = 0.111294537;
        } else if (ageMonths >= 91 && ageMonths < 92) {
          L = -2.741498897;
          M = 15.65684126;
          S = 0.112283526;
        } else if (ageMonths >= 92 && ageMonths < 93) {
          L = -2.715970894;
          M = 15.68930333;
          S = 0.113268793;
        } else if (ageMonths >= 93 && ageMonths < 94) {
          L = -2.690753197;
          M = 15.7225673;
          S = 0.114249622;
        } else if (ageMonths >= 94 && ageMonths < 95) {
          L = -2.665870146;
          M = 15.75661555;
          S = 0.115225321;
        } else if (ageMonths >= 95 && ageMonths < 96) {
          L = -2.641343436;
          M = 15.79143062;
          S = 0.116195218;
        } else if (ageMonths >= 96 && ageMonths < 97) {
          L = -2.617192204;
          M = 15.82699517;
          S = 0.117158667;
        } else if (ageMonths >= 97 && ageMonths < 98) {
          L = -2.593430614;
          M = 15.86329241;
          S = 0.118115073;
        } else if (ageMonths >= 98 && ageMonths < 99) {
          L = -2.570076037;
          M = 15.90030484;
          S = 0.119063807;
        } else if (ageMonths >= 99 && ageMonths < 100) {
          L = -2.547141473;
          M = 15.93801545;
          S = 0.12000429;
        } else if (ageMonths >= 100 && ageMonths < 101) {
          L = -2.524635245;
          M = 15.97640787;
          S = 0.120935994;
        } else if (ageMonths >= 101 && ageMonths < 102) {
          L = -2.502569666;
          M = 16.01546483;
          S = 0.121858355;
        } else if (ageMonths >= 102 && ageMonths < 103) {
          L = -2.48095189;
          M = 16.05516984;
          S = 0.12277087;
        } else if (ageMonths >= 103 && ageMonths < 104) {
          L = -2.459785573;
          M = 16.09550688;
          S = 0.123673085;
        } else if (ageMonths >= 104 && ageMonths < 105) {
          L = -2.439080117;
          M = 16.13645881;
          S = 0.124564484;
        } else if (ageMonths >= 105 && ageMonths < 106) {
          L = -2.418838304;
          M = 16.17800955;
          S = 0.125444639;
        } else if (ageMonths >= 106 && ageMonths < 107) {
          L = -2.399063683;
          M = 16.22014281;
          S = 0.126313121;
        } else if (ageMonths >= 107 && ageMonths < 108) {
          L = -2.379756861;
          M = 16.26284277;
          S = 0.127169545;
        } else if (ageMonths >= 108 && ageMonths < 109) {
          L = -2.360920527;
          M = 16.30609316;
          S = 0.128013515;
        } else if (ageMonths >= 109 && ageMonths < 110) {
          L = -2.342557728;
          M = 16.34987759;
          S = 0.128844639;
        } else if (ageMonths >= 110 && ageMonths < 111) {
          L = -2.324663326;
          M = 16.39418118;
          S = 0.129662637;
        } else if (ageMonths >= 111 && ageMonths < 112) {
          L = -2.307240716;
          M = 16.43898741;
          S = 0.130467138;
        } else if (ageMonths >= 112 && ageMonths < 113) {
          L = -2.290287663;
          M = 16.48428082;
          S = 0.131257852;
        } else if (ageMonths >= 113 && ageMonths < 114) {
          L = -2.273803847;
          M = 16.53004554;
          S = 0.132034479;
        } else if (ageMonths >= 114 && ageMonths < 115) {
          L = -2.257782149;
          M = 16.57626713;
          S = 0.132796819;
        } else if (ageMonths >= 115 && ageMonths < 116) {
          L = -2.242227723;
          M = 16.62292864;
          S = 0.133544525;
        } else if (ageMonths >= 116 && ageMonths < 117) {
          L = -2.227132805;
          M = 16.67001572;
          S = 0.134277436;
        } else if (ageMonths >= 117 && ageMonths < 118) {
          L = -2.212495585;
          M = 16.71751288;
          S = 0.134995324;
        } else if (ageMonths >= 118 && ageMonths < 119) {
          L = -2.19831275;
          M = 16.76540496;
          S = 0.135697996;
        } else if (ageMonths >= 119 && ageMonths < 120) {
          L = -2.184580762;
          M = 16.81367689;
          S = 0.136385276;
        } else if (ageMonths >= 120 && ageMonths < 121) {
          L = -2.171295888;
          M = 16.86231366;
          S = 0.137057004;
        } else if (ageMonths >= 121 && ageMonths < 122) {
          L = -2.158454232;
          M = 16.91130036;
          S = 0.137713039;
        } else if (ageMonths >= 122 && ageMonths < 123) {
          L = -2.146051754;
          M = 16.96062216;
          S = 0.138353254;
        } else if (ageMonths >= 123 && ageMonths < 124) {
          L = -2.134084303;
          M = 17.0102643;
          S = 0.138977537;
        } else if (ageMonths >= 124 && ageMonths < 125) {
          L = -2.122547629;
          M = 17.06021213;
          S = 0.139585795;
        } else if (ageMonths >= 125 && ageMonths < 126) {
          L = -2.111437411;
          M = 17.11045106;
          S = 0.140177947;
        } else if (ageMonths >= 126 && ageMonths < 127) {
          L = -2.100749266;
          M = 17.16096656;
          S = 0.140753927;
        } else if (ageMonths >= 127 && ageMonths < 128) {
          L = -2.090478774;
          M = 17.21174424;
          S = 0.141313686;
        } else if (ageMonths >= 128 && ageMonths < 129) {
          L = -2.080621484;
          M = 17.26276973;
          S = 0.141857186;
        } else if (ageMonths >= 129 && ageMonths < 130) {
          L = -2.071172932;
          M = 17.31402878;
          S = 0.142384404;
        } else if (ageMonths >= 130 && ageMonths < 131) {
          L = -2.062128649;
          M = 17.3655072;
          S = 0.142895332;
        } else if (ageMonths >= 131 && ageMonths < 132) {
          L = -2.053484173;
          M = 17.4171909;
          S = 0.143389972;
        } else if (ageMonths >= 132 && ageMonths < 133) {
          L = -2.045235058;
          M = 17.46906585;
          S = 0.143868341;
        } else if (ageMonths >= 133 && ageMonths < 134) {
          L = -2.03737688;
          M = 17.52111811;
          S = 0.144330469;
        } else if (ageMonths >= 134 && ageMonths < 135) {
          L = -2.029906684;
          M = 17.57333347;
          S = 0.144776372;
        } else if (ageMonths >= 135 && ageMonths < 136) {
          L = -2.022817914;
          M = 17.62569869;
          S = 0.145206138;
        } else if (ageMonths >= 136 && ageMonths < 137) {
          L = -2.016107084;
          M = 17.67819987;
          S = 0.145619819;
        } else if (ageMonths >= 137 && ageMonths < 138) {
          L = -2.009769905;
          M = 17.7308234;
          S = 0.146017491;
        } else if (ageMonths >= 138 && ageMonths < 139) {
          L = -2.003802134;
          M = 17.78355575;
          S = 0.146399239;
        } else if (ageMonths >= 139 && ageMonths < 140) {
          L = -1.998199572;
          M = 17.83638347;
          S = 0.146765161;
        } else if (ageMonths >= 140 && ageMonths < 141) {
          L = -1.992958064;
          M = 17.88929321;
          S = 0.147115364;
        } else if (ageMonths >= 141 && ageMonths < 142) {
          L = -1.988073505;
          M = 17.94227168;
          S = 0.147449967;
        } else if (ageMonths >= 142 && ageMonths < 143) {
          L = -1.983541835;
          M = 17.9953057;
          S = 0.147769097;
        } else if (ageMonths >= 143 && ageMonths < 144) {
          L = -1.979359041;
          M = 18.04838216;
          S = 0.148072891;
        } else if (ageMonths >= 144 && ageMonths < 145) {
          L = -1.975521156;
          M = 18.10148804;
          S = 0.148361495;
        } else if (ageMonths >= 145 && ageMonths < 146) {
          L = -1.972024258;
          M = 18.15461039;
          S = 0.148635067;
        } else if (ageMonths >= 146 && ageMonths < 147) {
          L = -1.968864465;
          M = 18.20773639;
          S = 0.148893769;
        } else if (ageMonths >= 147 && ageMonths < 148) {
          L = -1.966037938;
          M = 18.26085325;
          S = 0.149137776;
        } else if (ageMonths >= 148 && ageMonths < 149) {
          L = -1.963540872;
          M = 18.31394832;
          S = 0.14936727;
        } else if (ageMonths >= 149 && ageMonths < 150) {
          L = -1.961369499;
          M = 18.36700902;
          S = 0.149582439;
        } else if (ageMonths >= 150 && ageMonths < 151) {
          L = -1.959520079;
          M = 18.42002284;
          S = 0.149783482;
        } else if (ageMonths >= 151 && ageMonths < 152) {
          L = -1.9579889;
          M = 18.47297739;
          S = 0.149970604;
        } else if (ageMonths >= 152 && ageMonths < 153) {
          L = -1.956772271;
          M = 18.52586035;
          S = 0.15014402;
        } else if (ageMonths >= 153 && ageMonths < 154) {
          L = -1.95586652;
          M = 18.57865951;
          S = 0.15030395;
        } else if (ageMonths >= 154 && ageMonths < 155) {
          L = -1.955267984;
          M = 18.63136275;
          S = 0.150450621;
        } else if (ageMonths >= 155 && ageMonths < 156) {
          L = -1.954973011;
          M = 18.68395801;
          S = 0.15058427;
        } else if (ageMonths >= 156 && ageMonths < 157) {
          L = -1.954977947;
          M = 18.73643338;
          S = 0.150705138;
        } else if (ageMonths >= 157 && ageMonths < 158) {
          L = -1.955279136;
          M = 18.788777;
          S = 0.150813475;
        } else if (ageMonths >= 158 && ageMonths < 159) {
          L = -1.955872909;
          M = 18.84097713;
          S = 0.150909535;
        } else if (ageMonths >= 159 && ageMonths < 160) {
          L = -1.956755579;
          M = 18.89302212;
          S = 0.150993582;
        } else if (ageMonths >= 160 && ageMonths < 161) {
          L = -1.957923436;
          M = 18.94490041;
          S = 0.151065883;
        } else if (ageMonths >= 161 && ageMonths < 162) {
          L = -1.959372737;
          M = 18.99660055;
          S = 0.151126714;
        } else if (ageMonths >= 162 && ageMonths < 163) {
          L = -1.9610997;
          M = 19.04811118;
          S = 0.151176355;
        } else if (ageMonths >= 163 && ageMonths < 164) {
          L = -1.963100496;
          M = 19.09942105;
          S = 0.151215094;
        } else if (ageMonths >= 164 && ageMonths < 165) {
          L = -1.96537124;
          M = 19.15051899;
          S = 0.151243223;
        } else if (ageMonths >= 165 && ageMonths < 166) {
          L = -1.967907983;
          M = 19.20139397;
          S = 0.151261042;
        } else if (ageMonths >= 166 && ageMonths < 167) {
          L = -1.970706706;
          M = 19.25203503;
          S = 0.151268855;
        } else if (ageMonths >= 167 && ageMonths < 168) {
          L = -1.973763307;
          M = 19.30243131;
          S = 0.151266974;
        } else if (ageMonths >= 168 && ageMonths < 169) {
          L = -1.977073595;
          M = 19.35257209;
          S = 0.151255713;
        } else if (ageMonths >= 169 && ageMonths < 170) {
          L = -1.980633277;
          M = 19.40244671;
          S = 0.151235395;
        } else if (ageMonths >= 170 && ageMonths < 171) {
          L = -1.984437954;
          M = 19.45204465;
          S = 0.151206347;
        } else if (ageMonths >= 171 && ageMonths < 172) {
          L = -1.988483106;
          M = 19.50135548;
          S = 0.151168902;
        } else if (ageMonths >= 172 && ageMonths < 173) {
          L = -1.992764085;
          M = 19.55036888;
          S = 0.151123398;
        } else if (ageMonths >= 173 && ageMonths < 174) {
          L = -1.997276103;
          M = 19.59907464;
          S = 0.15107018;
        } else if (ageMonths >= 174 && ageMonths < 175) {
          L = -2.002014224;
          M = 19.64746266;
          S = 0.151009595;
        } else if (ageMonths >= 175 && ageMonths < 176) {
          L = -2.00697335;
          M = 19.69552294;
          S = 0.150942;
        } else if (ageMonths >= 176 && ageMonths < 177) {
          L = -2.012148213;
          M = 19.7432456;
          S = 0.150867753;
        } else if (ageMonths >= 177 && ageMonths < 178) {
          L = -2.017533363;
          M = 19.79062086;
          S = 0.150787221;
        } else if (ageMonths >= 178 && ageMonths < 179) {
          L = -2.023123159;
          M = 19.83763907;
          S = 0.150700774;
        } else if (ageMonths >= 179 && ageMonths < 180) {
          L = -2.028911755;
          M = 19.88429066;
          S = 0.150608788;
        } else if (ageMonths >= 180 && ageMonths < 181) {
          L = -2.034893091;
          M = 19.9305662;
          S = 0.150511645;
        } else if (ageMonths >= 181 && ageMonths < 182) {
          L = -2.041060881;
          M = 19.97645636;
          S = 0.150409731;
        } else if (ageMonths >= 182 && ageMonths < 183) {
          L = -2.047408604;
          M = 20.02195192;
          S = 0.15030344;
        } else if (ageMonths >= 183 && ageMonths < 184) {
          L = -2.05392949;
          M = 20.06704377;
          S = 0.150193169;
        } else if (ageMonths >= 184 && ageMonths < 185) {
          L = -2.060616513;
          M = 20.11172291;
          S = 0.150079322;
        } else if (ageMonths >= 185 && ageMonths < 186) {
          L = -2.067462375;
          M = 20.15598047;
          S = 0.149962308;
        } else if (ageMonths >= 186 && ageMonths < 187) {
          L = -2.074459502;
          M = 20.19980767;
          S = 0.14984254;
        } else if (ageMonths >= 187 && ageMonths < 188) {
          L = -2.081600029;
          M = 20.24319586;
          S = 0.149720441;
        } else if (ageMonths >= 188 && ageMonths < 189) {
          L = -2.088875793;
          M = 20.28613648;
          S = 0.149596434;
        } else if (ageMonths >= 189 && ageMonths < 190) {
          L = -2.096278323;
          M = 20.32862109;
          S = 0.149470953;
        } else if (ageMonths >= 190 && ageMonths < 191) {
          L = -2.103798828;
          M = 20.37064138;
          S = 0.149344433;
        } else if (ageMonths >= 191 && ageMonths < 192) {
          L = -2.111428194;
          M = 20.41218911;
          S = 0.149217319;
        } else if (ageMonths >= 192 && ageMonths < 193) {
          L = -2.119156972;
          M = 20.45325617;
          S = 0.14909006;
        } else if (ageMonths >= 193 && ageMonths < 194) {
          L = -2.126975375;
          M = 20.49383457;
          S = 0.14896311;
        } else if (ageMonths >= 194 && ageMonths < 195) {
          L = -2.134873266;
          M = 20.5339164;
          S = 0.148836931;
        } else if (ageMonths >= 195 && ageMonths < 196) {
          L = -2.142840157;
          M = 20.57349387;
          S = 0.148711989;
        } else if (ageMonths >= 196 && ageMonths < 197) {
          L = -2.150865204;
          M = 20.61255929;
          S = 0.148588757;
        } else if (ageMonths >= 197 && ageMonths < 198) {
          L = -2.158937201;
          M = 20.65110506;
          S = 0.148467715;
        } else if (ageMonths >= 198 && ageMonths < 199) {
          L = -2.167044578;
          M = 20.6891237;
          S = 0.148349348;
        } else if (ageMonths >= 199 && ageMonths < 200) {
          L = -2.175176987;
          M = 20.72660728;
          S = 0.14823412;
        } else if (ageMonths >= 200 && ageMonths < 201) {
          L = -2.183317362;
          M = 20.76355011;
          S = 0.148122614;
        } else if (ageMonths >= 201 && ageMonths < 202) {
          L = -2.191457792;
          M = 20.79994337;
          S = 0.148015249;
        } else if (ageMonths >= 202 && ageMonths < 203) {
          L = -2.199583649;
          M = 20.83578051;
          S = 0.147912564;
        } else if (ageMonths >= 203 && ageMonths < 204) {
          L = -2.207681525;
          M = 20.87105449;
          S = 0.147815078;
        } else if (ageMonths >= 204 && ageMonths < 205) {
          L = -2.215737645;
          M = 20.90575839;
          S = 0.147723315;
        } else if (ageMonths >= 205 && ageMonths < 206) {
          L = -2.223739902;
          M = 20.93988477;
          S = 0.147637768;
        } else if (ageMonths >= 206 && ageMonths < 207) {
          L = -2.231667995;
          M = 20.97342858;
          S = 0.147559083;
        } else if (ageMonths >= 207 && ageMonths < 208) {
          L = -2.239511942;
          M = 21.00638171;
          S = 0.147487716;
        } else if (ageMonths >= 208 && ageMonths < 209) {
          L = -2.247257081;
          M = 21.0387374;
          S = 0.14742421;
        } else if (ageMonths >= 209 && ageMonths < 210) {
          L = -2.254885145;
          M = 21.07048996;
          S = 0.147369174;
        } else if (ageMonths >= 210 && ageMonths < 211) {
          L = -2.26238209;
          M = 21.10163241;
          S = 0.147323144;
        } else if (ageMonths >= 211 && ageMonths < 212) {
          L = -2.269731517;
          M = 21.13215845;
          S = 0.147286698;
        } else if (ageMonths >= 212 && ageMonths < 213) {
          L = -2.276917229;
          M = 21.16206171;
          S = 0.147260415;
        } else if (ageMonths >= 213 && ageMonths < 214) {
          L = -2.283925442;
          M = 21.1913351;
          S = 0.147244828;
        } else if (ageMonths >= 214 && ageMonths < 215) {
          L = -2.290731442;
          M = 21.21997472;
          S = 0.147240683;
        } else if (ageMonths >= 215 && ageMonths < 216) {
          L = -2.29732427;
          M = 21.24797262;
          S = 0.147248467;
        } else if (ageMonths >= 216 && ageMonths < 217) {
          L = -2.303687802;
          M = 21.27532239;
          S = 0.14726877;
        } else if (ageMonths >= 217 && ageMonths < 218) {
          L = -2.309799971;
          M = 21.30201933;
          S = 0.147302299;
        } else if (ageMonths >= 218 && ageMonths < 219) {
          L = -2.315651874;
          M = 21.32805489;
          S = 0.147349514;
        } else if (ageMonths >= 219 && ageMonths < 220) {
          L = -2.32121731;
          M = 21.35342563;
          S = 0.147411215;
        } else if (ageMonths >= 220 && ageMonths < 221) {
          L = -2.326481911;
          M = 21.37812462;
          S = 0.147487979;
        } else if (ageMonths >= 221 && ageMonths < 222) {
          L = -2.331428139;
          M = 21.40214589;
          S = 0.147580453;
        } else if (ageMonths >= 222 && ageMonths < 223) {
          L = -2.336038473;
          M = 21.42548351;
          S = 0.147689289;
        } else if (ageMonths >= 223 && ageMonths < 224) {
          L = -2.34029545;
          M = 21.44813156;
          S = 0.14781515;
        } else if (ageMonths >= 224 && ageMonths < 225) {
          L = -2.344181703;
          M = 21.47008412;
          S = 0.147958706;
        } else if (ageMonths >= 225 && ageMonths < 226) {
          L = -2.34768;
          M = 21.49133529;
          S = 0.148120633;
        } else if (ageMonths >= 226 && ageMonths < 227) {
          L = -2.350773286;
          M = 21.51187918;
          S = 0.148301619;
        } else if (ageMonths >= 227 && ageMonths < 228) {
          L = -2.353444725;
          M = 21.53170989;
          S = 0.148502355;
        } else if (ageMonths >= 228 && ageMonths < 229) {
          L = -2.355677743;
          M = 21.55082155;
          S = 0.148723546;
        } else if (ageMonths >= 229 && ageMonths < 230) {
          L = -2.35745607;
          M = 21.56920824;
          S = 0.148965902;
        } else if (ageMonths >= 230 && ageMonths < 231) {
          L = -2.358763788;
          M = 21.58686406;
          S = 0.149230142;
        } else if (ageMonths >= 231 && ageMonths < 232) {
          L = -2.359585369;
          M = 21.60378309;
          S = 0.149516994;
        } else if (ageMonths >= 232 && ageMonths < 233) {
          L = -2.359905726;
          M = 21.61995939;
          S = 0.149827195;
        } else if (ageMonths >= 233 && ageMonths < 234) {
          L = -2.359710258;
          M = 21.635387;
          S = 0.150161492;
        } else if (ageMonths >= 234 && ageMonths < 235) {
          L = -2.358980464;
          M = 21.65006126;
          S = 0.150520734;
        } else if (ageMonths >= 235 && ageMonths < 236) {
          L = -2.357714508;
          M = 21.6639727;
          S = 0.150905439;
        } else if (ageMonths >= 236 && ageMonths < 237) {
          L = -2.355892424;
          M = 21.67711736;
          S = 0.151316531;
        } else if (ageMonths >= 237 && ageMonths < 238) {
          L = -2.353501353;
          M = 21.68948935;
          S = 0.151754808;
        } else if (ageMonths >= 238 && ageMonths < 239) {
          L = -2.350528726;
          M = 21.70108288;
          S = 0.152221086;
        } else if (ageMonths >= 239 && ageMonths < 240) {
          L = -2.346962247;
          M = 21.71189225;
          S = 0.152716206;
        } else if (ageMonths >= 240 && ageMonths < 241) {
          L = -2.342796948;
          M = 21.72190973;
          S = 0.153240872;
        }
        zScore = (Math.pow(roundBmi / M, L) - 1) / (L * S);
      }

      const az = Math.abs(zScore);

      if (zScore < -3.09) {
        thisPercentile = 0.1;
      } else if (zScore > 3.09) {
        thisPercentile = 99.9;
      } else {
        thisPercentile = n[Math.round(az * 100)];
      }

      if (zScore < 0) {
        thisPercentile = 100 - thisPercentile;
      }

      thisPercentile = Math.round(thisPercentile * 10) / 10;

      let status, color, left;
      if (thisPercentile < 5) {
        status = "Underweight";
        param.under = "bg-blue-800 text-white";
        color = "#20BEC8";
        left = "3";
      } else if (thisPercentile >= 5 && thisPercentile < 85) {
        status = "Healthy Weight";
        param.healthy = "bg-green-800 text-white";
        color = "#10951D";
      } else if (thisPercentile >= 85 && thisPercentile < 95) {
        status = "Overweight";
        param.over = "bg-turmeric text-white";
        color = "#CABE52";
      } else if (thisPercentile >= 95) {
        status = "Obese";
        param.obese1 = "bg-red-800 text-white";
        color = "#FF0000";
      }

      if (thisPercentile >= 5 && thisPercentile < 10) {
        left = "13";
      }
      if (thisPercentile >= 10 && thisPercentile < 40) {
        left = "20";
      }
      if (thisPercentile >= 40 && thisPercentile < 60) {
        left = "30";
      }
      if (thisPercentile >= 60 && thisPercentile < 80) {
        left = "45";
      }
      if (thisPercentile >= 80 && thisPercentile < 85) {
        left = "48";
      }
      if (thisPercentile >= 85 && thisPercentile < 90) {
        left = "56";
      }
      if (thisPercentile >= 90 && thisPercentile < 95) {
        left = "70";
      }
      if (thisPercentile >= 95) {
        left = "82";
      }

      param.tech_child = "active";
      param.tech_BMI_kid = roundBmi;
      param.tech_percent = thisPercentile;
      param.tech_Status = status;
      param.tech_color = color;
      param.tech_left = left;
      param.tech_stage = stage;
      return param;
    } else {
      const convert_height = heightInInches;
      const BMI =
        Math.round(((weight * 703) / (convert_height * convert_height)) * 100) /
        100;
      const weight_lbs = weight / 2.205;
      const height_m = convert_height / 39.37;
      const PI = Math.round((weight_lbs / Math.pow(height_m, 3)) * 10) / 10;

      let status = "";
      let rotate = "";
      let color = "";
      let left = "";

      if (BMI <= 18.5) {
        status = "Underweight.";
        rotate = "-95";
        color = "#20BEC8";
        left = "2";
        result["tech_under"] = "bg-blue-800 text-white";
      } else if (BMI > 18.5 && BMI <= 24.9) {
        status = "Healthy Weight.";
        rotate = "-82";
        color = "#10951D";
        left = "26";
        result["tech_healthy"] = "bg-green-800 text-white";
      } else if (BMI > 24.9 && BMI <= 29.9) {
        status = "Overweight.";
        rotate = "-45";
        color = "#CABE52";
        left = "50";
        result["tech_over"] = "bg-turmeric text-white";
      } else if (BMI > 29.9 && BMI <= 34.9) {
        status = "Obese";
        rotate = "0";
        color = "#FF0000";
        left = "74";
        result["tech_obese1"] = "bg-red-800 text-white";
      } else if (BMI > 34.9 && BMI <= 39.9) {
        status = "Severely Obese.";
        rotate = "45";
        color = "#FF0000";
        left = "80";
        result["tech_obese2"] = "bg-red-800 text-white";
      } else {
        status = "Morbidly Obese.";
        rotate = "90";
        color = "#FF0000";
        left = "80";
        result["tech_obese3"] = "bg-red-800 text-white";
      }

      let Robinson, Miller, Devine, Hamwi;

      if (gender === "Female") {
        Robinson = Math.round(49 + 1.7 * (convert_height - 60));
        Miller = Math.round(53.1 + 1.36 * (convert_height - 60));
        Devine = Math.round(45.5 + 2.3 * (convert_height - 60));
        Hamwi = Math.round(45 + 2.2 * (convert_height - 60));
      } else {
        Robinson = Math.round(52 + 1.9 * (convert_height - 60));
        Miller = Math.round(56.2 + 1.41 * (convert_height - 60));
        Devine = Math.round(50 + 2.3 * (convert_height - 60));
        Hamwi = Math.round(48 + 2.7 * (convert_height - 60));
      }

      let ibw = "";
      if (unit_type === "lbs") {
        ibw = `${Math.round(Robinson * 2.205)} - ${Math.round(
          Hamwi * 2.205
        )} lbs`;
      } else if (unit_type === "kg") {
        ibw = `${Robinson} - ${Hamwi} kg`;
      }

      const heightFeet = Math.floor(ft_in / 12);
      const heightInch = ft_in % 12;

      // Return Values
      result["tech_BMI"] = BMI;
      result["tech_ibw"] = ibw;
      result["tech_PI"] = PI;
      result["tech_Add"] = "active";
      result["tech_Standerd"] = "active";
      result["tech_Feet"] = heightFeet;
      result["tech_Inch"] = heightInch;
      result["tech_Status"] = status;
      result["tech_Rotate"] = rotate;
      result["tech_color"] = color;
      result["tech_left"] = left;
      result["tech_stage"] = stage;
      return result;
    }
  }

  /**
   * getCalculationVatCalculator: Service Method
   * POST: /api/calculators-lol/vat-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationVatCalculator(body) {
    let vat = body.tech_vat;
    let amount = body.tech_amount;
    let method = body.tech_method;
    const param = {};

    // Validation
    if (!vat || !amount) {
      param.error = "Please fill all fields.";
      return param;
    }
    if (isNaN(vat) || isNaN(amount)) {
      param.error = "Invalid Input.";
      return param;
    }

    let vatAmount, net, gross;

    if (method === "add") {
      net = amount;
      vatAmount = (vat * amount) / 100;
      gross = amount + vatAmount;
    } else {
      gross = amount;
      const vatMultiplier = 1 + vat / 100;
      net = parseFloat((amount / vatMultiplier).toFixed(2));
      vatAmount = amount - net;
    }

    // Return values
    param.tech_vatAmount = vatAmount;
    param.tech_net = net;
    param.tech_gross = gross;
    return param;
  }

  /**
   * getCalculationSalestaxCalculator: Service Method
   * POST: /api/calculators-lol/salestax-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSalestaxCalculator(body) {
    let vat = body.tech_vat;
    let amount = body.tech_amount;
    let method = body.tech_method;

    const param = {};

    // Check if vat and amount are numeric
    if (isNaN(vat) || isNaN(amount)) {
      param.error = "Please fill any two fields.";
      return param;
    }

    let vatAmount, netBill;

    if (method === "add") {
      vatAmount = (vat * amount) / 100;
      netBill = amount + vatAmount;
    } else {
      const vatMultiplier = 1 + vat / 100;
      netBill = parseFloat((amount / vatMultiplier).toFixed(2));
      vatAmount = amount - netBill;
    }

    // Prepare response
    param.tech_vatAmount = parseFloat(vatAmount.toFixed(2));
    param.tech_netBill = parseFloat(netBill.toFixed(2));
    return param;
  }

  /**
   * getCalculationPriceElasticaityDemandCalculator: Service Method
   * POST: /api/calculators-lol/price-elasticity-demand-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPriceElasticaityDemandCalculator(body) {
    let unit_type = body.tech_unit_type;
    let method = body.tech_method;
    let prince = body.tech_prince;
    let quantity = body.tech_quantity;
    let n_q = body.tech_n_q;
    let i_q = body.tech_i_q;
    let n_p = body.tech_n_p;
    let i_p = body.tech_i_p;
    let i_r = body.tech_i_r;
    let f_r = body.tech_f_r;
    let inc = body.tech_inc;
    const param = {};
    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function round(num, decimals) {
      return Number(Math.round(num + "e" + decimals) + "e-" + decimals);
    }

    function getDemandType(PED) {
      console.log(PED);
      const absPED = Math.abs(PED); // ABS lelo, taake negative value ka magnitude mile
      if (absPED > 1) {
        return "Elastic Demand";
      } else if (absPED === 1) {
        return "Unitary Elastic";
      } else if (absPED < 1 && absPED > 0) {
        return "Inelastic Demand";
      } else if (absPED === 0) {
        return "Perfectly Inelastic";
      } else {
        return "Invalid PED";
      }
    }

    if (unit_type === "Revenue") {
      if (isNumeric(i_r) && isNumeric(f_r)) {
        if (
          isNumeric(i_r) &&
          isNumeric(f_r) &&
          (inc === undefined || inc === "")
        ) {
          if (i_r == 0) {
            var r_percent = "0";
          } else {
            var r_percent = round(((f_r - i_r) / i_r) * 100, 2);
          }
          param.tech_i_r = i_r;
          param.tech_f_r = f_r;
          param.tech_r_percent = r_percent;
          param.tech_rev = "active";
          return param;
        } else {
          param.error = "Please Enter Only Two Values.";
          return param;
        }
      }

      if (isNumeric(f_r) && isNumeric(inc)) {
        if (
          (i_r === undefined || i_r === "") &&
          isNumeric(f_r) &&
          isNumeric(inc)
        ) {
          const incFactor = inc / 100 + 1;
          const i_r_calc = round(f_r / incFactor, 2);
          param.tech_i_r = i_r_calc;
          param.tech_f_r = f_r;
          param.tech_r_percent = inc;
          param.tech_rev = "active";
          return param;
        } else {
          param.error = "Please Enter Only Two Values.";
          return param;
        }
      }

      if (isNumeric(i_r) && isNumeric(inc)) {
        if (
          (f_r === undefined || f_r === "") &&
          isNumeric(i_r) &&
          isNumeric(inc)
        ) {
          const incFactor = inc / 100;
          const f_r_calc = round(i_r + i_r * incFactor, 2);
          param.tech_i_r = i_r;
          param.tech_f_r = f_r_calc;
          param.tech_r_percent = inc;
          param.tech_rev = "active";
          return param;
        } else {
          param.error = "Please Enter Only Two Values.";
          return param;
        }
      }

      param.error = "Please Enter Only Two Values.";
      return param;
    } else if (method === "1") {
      if (
        isNumeric(i_p) &&
        isNumeric(n_p) &&
        isNumeric(i_q) &&
        isNumeric(n_q)
      ) {
        let PED;
        if (i_p == n_p) {
          PED = (n_q - i_q) / ((n_q + i_q) / 2);
        } else {
          PED =
            (n_q - i_q) / ((n_q + i_q) / 2) / ((n_p - i_p) / ((n_p + i_p) / 2));
        }

        PED = round(PED, 4);

        const type = getDemandType(PED);
        const i_r = i_p * i_q;
        const f_r = n_p * n_q;
        const r_percent = round(((f_r - i_r) / i_r) * 100, 2);

        param.tech_type = type;
        param.tech_i_r = i_r;
        param.tech_f_r = f_r;
        param.tech_r_percent = r_percent;
        param.tech_PED = PED;
        param.tech_method = method;
        return param;
      } else {
        param.error = "Please fill all fields.";
        return param;
      }
    } else if (method === "2") {
      if (
        isNumeric(i_p) &&
        isNumeric(n_p) &&
        isNumeric(i_q) &&
        isNumeric(n_q)
      ) {
        let PED;
        if (i_p == n_p) {
          PED = (n_q - i_q) / i_q;
        } else {
          PED = (n_q - i_q) / i_q / ((n_p - i_p) / i_p);
        }

        PED = round(PED, 4);

        const type = getDemandType(PED);
        const i_r = i_p * i_q;
        const f_r = n_p * n_q;
        const r_percent = round(((f_r - i_r) / i_r) * 100, 2);

        param.tech_type = type;
        param.tech_i_r = i_r;
        param.tech_f_r = f_r;
        param.tech_r_percent = r_percent;
        param.tech_PED = PED;
        param.tech_method = method;
        return param;
      } else {
        param.error = "Please fill all fields.";
        return param;
      }
    } else if (method === "3") {
      if (isNumeric(quantity) && isNumeric(prince)) {
        let PED = quantity / prince;
        PED = round(PED, 4);

        const type = getDemandType(PED);

        param.tech_type = type;
        param.tech_PED = PED;
        param.tech_method = method;
        return param;
      } else {
        param.error = "Please fill all fields.";
        return param;
      }
    }

    param.error = "Invalid Request.";
    return param;
  }

  /**
   * getCalculationWaccCalculator: Service Method
   * POST: /api/calculators-lol/wacc-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationWaccCalculator(body) {
    let param = {};

    // Helper functions
    function isNumeric(value) {
      return !isNaN(parseFloat(value)) && isFinite(value);
    }

    function round(value, decimals) {
      return Number(Math.round(value + "e" + decimals) + "e-" + decimals);
    }

    if (!body || typeof body !== "object") {
      param.error = "Invalid input!";
      return param;
    }

    if (body.tech_unit_type === "debt") {
      if (
        isNumeric(body.tech_risk) &&
        isNumeric(body.tech_beta) &&
        isNumeric(body.tech_eq)
      ) {
        const eq = round(body.tech_risk + body.tech_beta * body.tech_eq, 4);
        param.tech_eq = eq;
        return param;
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }
    } else if (body.tech_unit_type === "cd") {
      if (isNumeric(body.tech_rate) && isNumeric(body.tech_tax)) {
        if (
          isNumeric(body.tech_risk) &&
          isNumeric(body.tech_beta) &&
          isNumeric(body.tech_eq)
        ) {
          const eq = round(body.tech_risk + body.tech_beta * body.tech_eq, 4);
          param.tech_eq = eq;
        }
        const cd = round(
          (body.tech_rate / 100) * (1 - body.tech_tax / 100) * 100,
          4
        );
        param.tech_cd = cd;
        return param;
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }
    } else {
      if (
        isNumeric(body.tech_a) &&
        isNumeric(body.tech_b) &&
        isNumeric(body.tech_c) &&
        isNumeric(body.tech_d) &&
        isNumeric(body.tech_e)
      ) {
        const D = body.tech_a;
        let RD = body.tech_b / 100;
        const E = body.tech_c;
        let RE = body.tech_d / 100;
        let T = body.tech_e / 100;

        const wacc = round(
          ((E / (E + D)) * RE + (D / (E + D)) * RD * (1 - T)) * 100,
          4
        );
        const pfe = round((E / (E + D)) * 100, 4);
        const pfd = round((D / (E + D)) * 100, 4);

        RD = RD * 100;
        RE = RE * 100;
        T = T * 100;

        param = {
          tech_wacc: wacc,
          tech_D: D,
          tech_RD: RD,
          tech_E: E,
          tech_RE: RE,
          tech_pfe: pfe,
          tech_pfd: pfd,
          tech_T: T,
        };
        return param;
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }
    }
  }

  /**
   * getCalculationEbitdaCalculator: Service Method
   * POST: /api/calculators-lol/ebitda-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationEbitdaCalculator(body) {
    let param = {};

    // Helper functions
    function isNumeric(value) {
      return !isNaN(parseFloat(value)) && isFinite(value);
    }

    if (!body || typeof body !== "object") {
      param.error = "Invalid input!";
      return param;
    }

    let unit_type = body.tech_unit_type;
    let x = body.tech_x;
    let y = body.tech_y;
    let a = body.tech_a;
    let d = body.tech_d;
    let rev = body.tech_rev;
    let net = body.tech_net;
    let Interest = body.tech_Interest;
    let Taxes = body.tech_Taxes;
    let ae = body.tech_ae;
    let de = body.tech_de;

    if (unit_type === "simple") {
      if (isNumeric(x) && isNumeric(y) && isNumeric(a) && isNumeric(d)) {
        const ebitda = x - y + a + d;
        const margin = Math.round((ebitda / x) * 100 * 100) / 100; // Round to 2 decimals
        param.tech_ebitda = ebitda;
        param.tech_margin = margin + " %";
        return param;
      } else {
        param.error = "Please fill all fields.";
        return param;
      }
    } else if (unit_type === "extended") {
      if (
        isNumeric(rev) &&
        isNumeric(net) &&
        isNumeric(Interest) &&
        isNumeric(Taxes) &&
        isNumeric(ae) &&
        isNumeric(de)
      ) {
        const ebitda = net + Interest + Taxes + de + ae;
        const margin = Math.round((ebitda / rev) * 100 * 100) / 100;
        param.tech_ebitda = ebitda;
        param.tech_extended = "active";
        param.tech_margin = margin + " %";
        return param;
      } else {
        param.error = "Please fill all fields.";
        return param;
      }
    } else {
      param.error = "Invalid unit_type!";
      return param;
    }
  }

  /**
   * getCalculationPaypalFeeCalculator: Service Method
   * POST: /api/calculators-lol/paypal-fee-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPaypalFeeCalculator(body) {
    let param = {};

    // Helper function
    function isNumeric(value) {
      return !isNaN(parseFloat(value)) && isFinite(value);
    }

    if (!body || typeof body !== "object") {
      param.error = "Invalid input!";
      return param;
    }

    let x = body.tech_x;
    let rate = body.tech_rate;

    if (isNumeric(x)) {
      let fee = 0;
      let send = 0;

      switch (rate) {
        case "0":
          fee = Math.round(((2.9 / 100) * x + 0.3) * 100) / 100;
          send = Math.round(((100 * x + 30) / (100 - 2.9)) * 100) / 100;
          break;
        case "1":
          fee = Math.round(((2.7 / 100) * x + 0.3) * 100) / 100;
          send = Math.round(((100 * x + 30) / (100 - 2.7)) * 100) / 100;
          break;
        case "2":
          fee = Math.round(((2.2 / 100) * x + 0.3) * 100) / 100;
          send = Math.round(((100 * x + 30) / (100 - 2.2)) * 100) / 100;
          break;
        case "3":
          fee = Math.round(((5 / 100) * x + 0.05) * 100) / 100;
          send = Math.round(((100 * x + 5) / (100 - 5)) * 100) / 100;
          break;
        case "4":
          fee = Math.round(((4.4 / 100) * x + 0.3) * 100) / 100;
          send = Math.round(((100 * x + 30) / (100 - 4.4)) * 100) / 100;
          break;
        case "5":
          fee = Math.round(((4.2 / 100) * x + 0.3) * 100) / 100;
          send = Math.round(((100 * x + 30) / (100 - 4.2)) * 100) / 100;
          break;
        case "6":
          fee = Math.round(((3.7 / 100) * x + 0.3) * 100) / 100;
          send = Math.round(((100 * x + 30) / (100 - 3.7)) * 100) / 100;
          break;
        case "7":
          fee = Math.round(((6.5 / 100) * x + 0.05) * 100) / 100;
          send = Math.round(((100 * x + 5) / (100 - 6.5)) * 100) / 100;
          break;
        case "8":
          fee = Math.round((2.7 / 100) * x * 100) / 100;
          send = Math.round(((100 * x) / (100 - 2.7)) * 100) / 100;
          break;
        case "9":
          fee = Math.round(((3.5 / 100) * x + 0.15) * 100) / 100;
          send = Math.round(((100 * x + 15) / (100 - 3.5)) * 100) / 100;
          break;
        case "10":
          fee = Math.round(((3.1 / 100) * x + 0.3) * 100) / 100;
          send = Math.round(((100 * x + 30) / (100 - 3.1)) * 100) / 100;
          break;
        default:
          param.error = "Invalid rate!";
          return param;
      }

      const receive = Math.round((x - fee) * 100) / 100;
      const fee1 = Math.round((send - x) * 100) / 100;

      param.tech_receive = receive.toFixed(2);
      param.tech_send = send.toFixed(2);
      param.tech_fee = fee.toFixed(2);
      param.tech_fee1 = fee1.toFixed(2);

      return param;
    } else {
      param.error = "Please fill all fields.";
      return param;
    }
  }

  /**
   * getCalculationMarginOfErrorCalculator: Service Method
   * POST: /api/calculators-lol/margin-of-error-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMarginOfErrorCalculator(body) {
    let per = body.tech_per;
    let x = body.tech_x;
    let y = body.tech_y;
    let z = body.tech_z;

    if (per && x && y && z) {
      let perValue = per.split("@")[0];
      let p = x / 100;
      let n = y;
      let Na = z;
      let ans = 0;

      if (perValue == 11 || perValue == 22) {
        perValue = 2.05;
      }

      ans =
        Math.round(
          ((perValue * Math.sqrt(p * (1 - p))) / Math.sqrt(n)) * 10000
        ) / 10000;

      if (Na !== undefined && Na !== null && Na !== "") {
        if (n == Na) {
          ans = 0;
        } else {
          ans =
            (Math.round(
              ((perValue * Math.sqrt(p * (1 - p))) /
                Math.sqrt(((Na - 1) * n) / (Na - n))) *
                10000
            ) /
              10000) *
            100;
        }
      }

      return {
        tech_ans: `±${ans}%`,
        tech_x: body.tech_x,
        tech_y: body.tech_y,
        tech_z: body.tech_z,
        tech_per: body.tech_per,
      };
    } else {
      return {
        error: "Please fill all fields.",
      };
    }
  }

  /**
   * getCalculationCpmCalculator: Service Method
   * POST: /api/calculators-lol/cpm-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCpmCalculator(body) {
    let checkbox = body.tech_checkbox;
    let xf = body.tech_xf;
    let yf = body.tech_yf;
    let xs = body.tech_xs;
    let ys = body.tech_ys;
    let methodf = body.tech_methodf;
    let methods = body.tech_methods;
    let x = body.tech_x;
    let y = body.tech_y;
    let method = body.tech_method;
    let currency = body.tech_my_current;

    // Helper functions
    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function roundToThree(num) {
      return Math.round(num * 1000) / 1000;
    }

    if (checkbox) {
      // Checkbox selected case
      if (isNumeric(xf) && isNumeric(yf) && isNumeric(xs) && isNumeric(ys)) {
        let ansf, anss, cpmf, cpms;

        if (methodf === "cpm") {
          ansf = roundToThree((1000 * yf) / xf);
          cpmf = ansf;
          ansf = `${currency} ${ansf}`;
        } else if (methodf === "tc") {
          ansf = roundToThree((xf * yf) / 1000);
          cpmf = xf;
          ansf = `${currency} ${ansf}`;
        } else {
          cpmf = xf;
          ansf = roundToThree((1000 * yf) / xf);
        }

        if (methods === "cpm") {
          anss = roundToThree((1000 * ys) / xs);
          cpms = anss;
          anss = `${currency} ${anss}`;
        } else if (methods === "tc") {
          anss = roundToThree((xs * ys) / 1000);
          cpms = xs;
          anss = `${currency} ${anss}`;
        } else {
          cpms = xs;
          anss = roundToThree((1000 * ys) / xs);
        }
        return {
          tech_ansf: ansf,
          tech_cpmf: cpmf,
          tech_anss: anss,
          tech_cpms: cpms,
          tech_methodf: methodf,
          tech_methods: methods,
        };
      } else {
        return {
          error: "Please fill all fields.",
        };
      }
    } else {
      // Without checkbox case
      if (isNumeric(x) && isNumeric(y)) {
        let ansResult;
        if (method === "cpm") {
          ansResult = x == 0 ? 0 : roundToThree((1000 * y) / x);
        } else if (method === "tc") {
          ansResult = x == 0 ? 0 : roundToThree((x * y) / 1000);
        } else {
          ansResult = x == 0 ? 0 : roundToThree((1000 * y) / x);
        }

        return {
          tech_ans: `${currency} ${ansResult}`,
          tech_method: method,
        };
      } else {
        return {
          error: "Please fill all fields.",
        };
      }
    }
  }

  /**
   * getCalculationMarkupCalculator: Service Method
   * POST: /api/calculators-lol/markup-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMarkupCalculator(body) {
    let to_cal = body.tech_to_cal;
    let a = body.tech_a;
    let b = body.tech_b;
    let c = body.tech_c;
    let d = body.tech_d;

    let result = {};

    if (to_cal === "1") {
      if (!isNaN(a) && !isNaN(b)) {
        let cost = parseFloat(a);
        let markup = parseFloat(b);
        let revenue = cost + cost * (markup / 100);
        let profit = revenue - cost;
        let margin = (100 * profit) / revenue;

        result = {
          tech_cost: cost.toFixed(2),
          tech_markup: markup.toFixed(2),
          tech_revenue: revenue.toFixed(2),
          tech_profit: profit.toFixed(2),
          tech_margin: margin.toFixed(2),
        };
      } else {
        result.error = "Please fill all fields.";
      }
    } else if (to_cal === "2") {
      if (!isNaN(a) && !isNaN(c)) {
        let cost = parseFloat(a);
        let revenue = parseFloat(c);
        let profit = revenue - cost;
        let margin = (100 * profit) / revenue;
        let markup = (100 * profit) / cost;

        result = {
          tech_cost: cost.toFixed(2),
          tech_markup: markup.toFixed(2),
          tech_revenue: revenue.toFixed(2),
          tech_profit: profit.toFixed(2),
          tech_margin: margin.toFixed(2),
        };
      } else {
        result.error = "Please fill all fields.";
      }
    } else if (to_cal === "3") {
      if (!isNaN(a) && !isNaN(d)) {
        let cost = parseFloat(a);
        let profit = parseFloat(d);
        let revenue = profit + cost;
        let margin = (100 * profit) / revenue;
        let markup = (100 * profit) / cost;

        result = {
          tech_cost: cost.toFixed(2),
          tech_markup: markup.toFixed(2),
          tech_revenue: revenue.toFixed(2),
          tech_profit: profit.toFixed(2),
          tech_margin: margin.toFixed(2),
        };
      } else {
        result.error = "Please fill all fields.";
      }
    } else if (to_cal === "4") {
      if (!isNaN(b) && !isNaN(c)) {
        let markup = parseFloat(b);
        let revenue = parseFloat(c);
        let margin = (markup / 100 / (1 + markup / 100)) * 100;
        let cost = revenue - (margin * revenue) / 100;
        let profit = revenue - cost;

        result = {
          tech_cost: cost.toFixed(2),
          tech_markup: markup.toFixed(2),
          tech_revenue: revenue.toFixed(2),
          tech_profit: profit.toFixed(2),
          tech_margin: margin.toFixed(2),
        };
      } else {
        result.error = "Please fill all fields.";
      }
    } else if (to_cal === "5") {
      if (!isNaN(b) && !isNaN(d)) {
        let markup = parseFloat(b);
        let profit = parseFloat(d);
        let margin = (markup / 100 / (1 + markup / 100)) * 100;
        let revenue = (100 * profit) / margin;
        let cost = revenue - (margin * revenue) / 100;

        result = {
          tech_cost: cost.toFixed(2),
          tech_markup: markup.toFixed(2),
          tech_revenue: revenue.toFixed(2),
          tech_profit: profit.toFixed(2),
          tech_margin: margin.toFixed(2),
        };
      } else {
        result.error = "Please fill all fields.";
      }
    } else if (to_cal === "6") {
      if (!isNaN(c) && !isNaN(d)) {
        let revenue = parseFloat(c);
        let profit = parseFloat(d);
        let cost = revenue - profit;
        let markup = (100 * profit) / cost;
        let margin = (markup / 100 / (1 + markup / 100)) * 100;

        result = {
          tech_cost: cost.toFixed(2),
          tech_markup: markup.toFixed(2),
          tech_revenue: revenue.toFixed(2),
          tech_profit: profit.toFixed(2),
          tech_margin: margin.toFixed(2),
        };
      } else {
        result.error = "Please fill all fields.";
      }
    } else {
      result.error = "Please fill all fields.";
    }

    return result;
  }

  /**
   * getCalculationCapRateCalculator: Service Method
   * POST: /api/calculators-lol/cap-rate-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCapRateCalculator(body) {
    // Separate variables
    let prop_val = body.tech_prop_val;
    let ann_grs_inc = body.tech_ann_grs_inc;
    let op_exp = body.tech_op_exp;
    let op_exp_unit = body.tech_op_exp_unit;
    let vac_rate = body.tech_vac_rate;

    // Remove commas
    prop_val = prop_val ? prop_val.toString().replace(/,/g, "") : "0";
    ann_grs_inc = ann_grs_inc ? ann_grs_inc.toString().replace(/,/g, "") : "0";
    op_exp = op_exp ? op_exp.toString().replace(/,/g, "") : "0";
    vac_rate = vac_rate ? vac_rate.toString().replace(/,/g, "") : "0";

    let param = {};

    // Check if inputs are numeric
    if (!isNaN(prop_val) && !isNaN(ann_grs_inc) && !isNaN(op_exp)) {
      vac_rate = isNaN(vac_rate) ? 0 : parseFloat(vac_rate);

      prop_val = parseFloat(prop_val);
      ann_grs_inc = parseFloat(ann_grs_inc);
      op_exp = parseFloat(op_exp);

      let vac_rate1 = (vac_rate / 100) * ann_grs_inc;
      let grs_op_inc = ann_grs_inc - vac_rate1;
      let ann_net_inc = 0;

      if (op_exp_unit === "%") {
        ann_net_inc =
          ((100 - op_exp) / 100) * ((100 - vac_rate) / 100) * ann_grs_inc;
        param["percent"] = "%";
      } else {
        ann_net_inc = grs_op_inc - op_exp;
      }

      let cap = (ann_net_inc / prop_val) * 100;

      param["tech_grs_op_inc"] = Math.round(grs_op_inc).toLocaleString();
      param["tech_ann_net_inc"] = Math.round(ann_net_inc).toLocaleString();
      param["tech_cap"] = parseFloat(cap.toFixed(3));
      param["tech_prop_val"] = Math.round(prop_val).toLocaleString();
      param["tech_ann_grs_inc"] = Math.round(ann_grs_inc).toLocaleString();
      param["tech_op_exp"] = Math.round(op_exp).toLocaleString();
      param["tech_vac_rate"] = Math.round(vac_rate).toLocaleString();
      param["tech_vac_rate1"] = Math.round(vac_rate1).toLocaleString();
      param["input_prop_val"] = body.tech_prop_val;
      param["input_ann_grs_inc"] = body.tech_ann_grs_inc;
      param["input_op_exp"] = body.tech_op_exp;
      param["input_op_exp_unit"] = body.tech_op_exp_unit;
      param["input_vac_rate"] = body.tech_vac_rate;

      return param;
    } else {
      param["error"] = "Please! Check Your Input";
      return param;
    }
  }

  /**
   * getCalculationCapmRateCalculator: Service Method
   * POST: /api/calculators-lol/capm-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCapmRateCalculator(body) {
    // Separate variables
    let cal = body.tech_cal;
    let rf = body.tech_rf;
    let rm = body.tech_rm;
    let bi = body.tech_bi;
    let r = body.tech_r;

    let param = {};

    if (cal && !isNaN(rf) && !isNaN(rm) && !isNaN(bi) && !isNaN(r)) {
      rf = parseFloat(rf);
      rm = parseFloat(rm);
      bi = parseFloat(bi);
      r = parseFloat(r);

      let eq_market_prem = 0;
      let risk_prem = 0;
      let r_mr = 0;
      let r_mrp = 0;

      if (cal === "R" && !isNaN(rf) && !isNaN(rm) && !isNaN(bi)) {
        eq_market_prem = rm - rf;
        risk_prem = bi * eq_market_prem;
        r = rf + risk_prem;
        r_mr = (rm * bi) / rf;
        r_mrp = r + r_mr;
      } else if (cal === "Bi" && !isNaN(r) && !isNaN(rf) && !isNaN(rm)) {
        let s1 = r - rf;
        eq_market_prem = rm - rf;
        if (eq_market_prem > 0) {
          bi = s1 / eq_market_prem;
        } else {
          bi = 0;
        }
        risk_prem = bi * eq_market_prem;
        r_mr = (rm * bi) / rf;
        r_mrp = r + r_mr;
        param["s1"] = parseFloat(s1.toFixed(3));
      } else if (cal === "Rf" && !isNaN(r) && !isNaN(rm) && !isNaN(bi)) {
        let s1 = bi * rm;
        let s2 = s1 - r;
        let s3 = bi - 1;
        rf = s2 / s3;
        eq_market_prem = rm - rf;
        risk_prem = bi * eq_market_prem;
        r_mr = (rm * bi) / rf;
        r_mrp = r + r_mr;
        param["tech_s1"] = parseFloat(s1.toFixed(3));
        param["tech_s2"] = parseFloat(s2.toFixed(3));
        param["tech_s3"] = parseFloat(s3.toFixed(3));
      } else if (cal === "Rm" && !isNaN(r) && !isNaN(rf) && !isNaN(bi)) {
        let s1 = bi - 1;
        let s2 = rf * s1;
        let s3 = s2 + r;
        rm = s3 / bi;
        eq_market_prem = rm - rf;
        risk_prem = bi * eq_market_prem;
        r_mr = (rm * bi) / rf;
        r_mrp = r + r_mr;
        param["tech_s1"] = parseFloat(s1.toFixed(3));
        param["tech_s2"] = parseFloat(s2.toFixed(3));
        param["tech_s3"] = parseFloat(s3.toFixed(3));
      } else {
        param["error"] = "Please fill all fields.";
        return param;
      }

      param["tech_cal"] = cal;
      param["tech_R"] = parseFloat(r.toFixed(3));
      param["tech_Rp"] = parseFloat(risk_prem.toFixed(3));
      param["tech_Emp"] = parseFloat(eq_market_prem.toFixed(3));
      param["tech_Rf"] = parseFloat(rf.toFixed(3));
      param["tech_Rm"] = parseFloat(rm.toFixed(3));
      param["tech_Bi"] = parseFloat(bi.toFixed(3));
      param["tech_Rmr"] = parseFloat(r_mr.toFixed(3));
      param["tech_Rmrp"] = parseFloat(r_mrp.toFixed(3));
      param["input_cal"] = body.tech_cal;
      param["input_rf"] = body.tech_rf;
      param["input_rm"] = body.tech_rm;
      param["input_bi"] = body.tech_bi;
      param["input_r"] = body.tech_r;

      return param;
    } else {
      param["error"] = "Please fill all fields.";
      return param;
    }
  }

  /**
   * getCalculationMarginalCostCalculator: Service Method
   * POST: /api/calculators-lol/marginal-cost-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMarginalCostCalculator(body) {
    let unit_type = body.tech_unit_type;

    // Variables separate
    let dc, dq, dq_unit, sr;
    let cc, fc, cq, cq_unit, fq, fq_unit, gr;

    let param = {}; // same as $this->param in PHP

    if (unit_type === "sr") {
      dc = body.tech_dc;
      dq = body.tech_dq;
      dq_unit = body.tech_dq_unit;
      sr = unit_type;
    } else {
      cc = body.tech_cc;
      fc = body.tech_fc;
      cq = body.tech_cq;
      cq_unit = body.tech_cq_unit;
      fq = body.tech_fq;
      fq_unit = body.tech_fq_unit;
      gr = unit_type;
    }

    let check = false;

    if (sr) {
      if (!isNaN(dc) && !isNaN(dq) && dq_unit) {
        check = true;
      }
    } else {
      if (
        !isNaN(cc) &&
        !isNaN(fc) &&
        !isNaN(cq) &&
        !isNaN(fq) &&
        cq_unit &&
        fq_unit
      ) {
        check = true;
      }
    }

    if (check) {
      if (dq_unit) {
        if (dq_unit === "pairs") {
          dq = dq * 2;
        } else if (dq_unit === "decades") {
          dq = dq * 10;
        } else if (dq_unit === "dozens") {
          dq = dq * 12;
        }
      }

      if (cq_unit) {
        if (cq_unit === "pairs") {
          cq = cq * 2;
        } else if (cq_unit === "decades") {
          cq = cq * 10;
        } else if (cq_unit === "dozens") {
          cq = cq * 12;
        }
      }

      if (fq_unit) {
        if (fq_unit === "pairs") {
          fq = fq * 2;
        } else if (fq_unit === "decades") {
          fq = fq * 10;
        } else if (fq_unit === "dozens") {
          fq = fq * 12;
        }
      }

      let mc, dcFinal, dqFinal;

      if (sr) {
        if (!isNaN(dc) && !isNaN(dq)) {
          mc = dc / dq;
          dcFinal = dc;
          dqFinal = dq;
          param["tech_check"] = "m1";
        }
      } else if (gr) {
        if (!isNaN(cc) && !isNaN(fc) && !isNaN(cq) && !isNaN(fq)) {
          dcFinal = fc - cc;
          dqFinal = fq - cq;
          mc = dcFinal / dqFinal;
          param["tech_check"] = "m2";
          param["tech_cc"] = cc;
          param["tech_fc"] = fc;
          param["tech_cq"] = cq;
          param["tech_fq"] = fq;
        }
      } else {
        param["error"] = "Please fill all fields.";
        return param;
      }

      param["tech_mc"] = mc;
      param["tech_dc"] = dcFinal;
      param["tech_dq"] = dqFinal;

      return param;
    } else {
      param["error"] = "Please fill all fields.";
      return param;
    }
  }

  /**
   * getCalculationOvertimeCalculator: Service Method
   * POST: /api/calculators-lol/overtime-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationOvertimeCalculator(body) {
    // Separate variables from body
    let pay = body.tech_pay;
    let per = body.tech_per;
    let timeper = "h_m"; // Hardcoded as in your PHP code
    let multi = body.tech_multi;
    let time = body.tech_time;
    let over = body.tech_over;
    let overper = body.tech_overper; // not used but extracted

    let param = {};

    if (!isNaN(pay) && per && !isNaN(multi)) {
      let hourly = pay;

      if (per === "hour") {
        hourly = hourly;
      } else if (per === "day") {
        hourly = hourly / 8;
      } else if (per === "week") {
        hourly = hourly / 40;
      } else {
        hourly = hourly / 173.6;
      }

      let monthTime = time;

      if (timeper === "h_m") {
        monthTime = monthTime;
      } else if (timeper === "d_m") {
        monthTime = monthTime * 8;
      } else if (timeper === "w_m") {
        monthTime = monthTime * 5 * 8;
      } else if (timeper === "h_w") {
        monthTime = monthTime * 4.344;
      } else if (timeper === "d_w") {
        monthTime = monthTime * 8 * 4.345;
      } else if (timeper === "h_d") {
        monthTime = monthTime * 5 * 4.345;
      }

      let regPay = +(hourly * monthTime);

      let overPayPerHour = +(multi * hourly);
      let overHour = +over;
      let overTotalPay = +(overHour * overPayPerHour);

      param["tech_overPayPerHour"] = overPayPerHour;
      param["tech_overTotalPay"] = overTotalPay;
      param["tech_regPay"] = regPay;
      param["tech_total"] = overTotalPay + regPay;
      return param;
    } else {
      param["error"] = "Please fill all fields.";
      return param;
    }
  }

  /**
   * getCalculationRoiCalculator: Service Method
   * POST: /api/calculators-lol/roi-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationRoiCalculator(body) {
    function tech_years(tech_a, tech_b) {
      if (tech_b === "1") {
        return tech_a / 365;
      } else if (tech_b === "2") {
        return tech_a / 12;
      } else if (tech_b === "3") {
        return tech_a / 52.143;
      } else if (tech_b === "4") {
        return tech_a * 1;
      }
      return tech_a;
    }

    function tech_dateDiffInDays(tech_date1, tech_date2) {
      const tech_diff = new Date(tech_date2) - new Date(tech_date1);
      return Math.abs(Math.round(tech_diff / (1000 * 60 * 60 * 24)));
    }

    function tech_formatNumberWithCommas(tech_num) {
      const tech_parts = parseFloat(tech_num).toFixed(4).split(".");
      tech_parts[0] = tech_parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
      return tech_parts.join(".");
    }

    const {
      tech_invest: tech_invest,
      tech_return: tech_returnAmount,
      tech_find: tech_find,
      tech_annualized: tech_annualized,
      tech_date: tech_date,
      tech_s_date: tech_s_date,
      tech_e_date: tech_e_date,
      tech_length: tech_length,
      tech_length_unit: tech_length_unit,
      tech_compare: tech_compare,
      tech_invest_compare: tech_invest_compare,
      tech_return_compare: tech_return_compare,
      tech_find_compare: tech_find_compare,
      tech_annualized_compare: tech_annualized_compare,
      tech_date_compare: tech_date_compare,
      tech_s_date_compare: tech_s_date_compare,
      tech_e_date_compare: tech_e_date_compare,
      tech_length_compare: tech_length_compare,
      tech_length_unit_compare: tech_length_unit_compares,
    } = body;

    let result = {};
    let tech_annualized_answer, tech_time, tech_loss, tech_gain, tech_roi;

    // Convert length units to numeric values
    let tech_length_unit_val = "1";
    if (tech_length_unit === "days") tech_length_unit_val = "1";
    else if (tech_length_unit === "weeks") tech_length_unit_val = "2";
    else if (tech_length_unit === "months") tech_length_unit_val = "3";
    else if (tech_length_unit === "years") tech_length_unit_val = "4";

    let tech_length_unit_compare_val = "1";
    if (tech_length_unit_compares === "days")
      tech_length_unit_compare_val = "1";
    else if (tech_length_unit_compares === "weeks")
      tech_length_unit_compare_val = "2";
    else if (tech_length_unit_compares === "months")
      tech_length_unit_compare_val = "3";
    else if (tech_length_unit_compares === "years")
      tech_length_unit_compare_val = "4";

    // Validate required fields
    if (tech_invest === undefined || tech_returnAmount === undefined) {
      result.error = "Investment and return amount are required";
      return result;
    }

    // Main calculation
    if (!(tech_invest <= 0)) {
      if (!(tech_returnAmount <= 0)) {
        const tech_answer = tech_returnAmount - tech_invest;

        if (tech_answer >= 0) {
          tech_loss = "0.00";
          tech_gain = tech_answer;
        } else {
          tech_loss = (-1 * tech_answer).toFixed(2);
          tech_gain = "0.00";
        }

        const tech_a1 = tech_answer / tech_invest;
        tech_roi = (tech_a1 * 100).toFixed(2);

        if (tech_find === "1") {
          if (tech_date === "1") {
            if (!tech_s_date || !tech_e_date) {
              result.error = "Start and end dates are required";
              return result;
            }

            let tech_from = new Date(tech_s_date);
            let tech_to = new Date(tech_e_date);

            if (tech_from > tech_to)
              [tech_from, tech_to] = [tech_to, tech_from];

            result.tech_from = tech_from.toLocaleDateString("en-US", {
              month: "short",
              day: "numeric",
              year: "numeric",
            });
            result.tech_to = tech_to.toLocaleDateString("en-US", {
              month: "short",
              day: "numeric",
              year: "numeric",
            });

            const tech_days = tech_dateDiffInDays(tech_from, tech_to);
            const tech_yrs = tech_days / 365;
            const tech_top_n = 1 / tech_yrs;
            const tech_inner1 = 1 + tech_a1;
            const tech_outer = Math.pow(tech_inner1, tech_top_n);
            const tech_annual_ans = tech_outer - 1;
            tech_annualized_answer = tech_annual_ans * 100;
            tech_time = tech_yrs;
          } else if (tech_date === "2") {
            if (!tech_length || tech_length == 0) {
              result.error = "Investment Length cannot be zero.";
              return result;
            }

            const tech_length_yrs = tech_years(
              tech_length,
              tech_length_unit_val
            );
            const tech_n_top = 1 / tech_length_yrs;
            const tech_inner = 1 + tech_a1;
            const tech_final = Math.pow(tech_inner, tech_n_top);
            const tech_annualized_ans1 = tech_final - 1;
            tech_annualized_answer = tech_annualized_ans1 * 100;
            tech_time = tech_length_yrs;
          }

          if (tech_annualized_answer !== undefined) {
            result.tech_annualized_answer = tech_formatNumberWithCommas(
              tech_annualized_answer
            );
          }
        } else if (tech_find === "2") {
          if (!tech_annualized) {
            result.error = "Annualized rate is required";
            return result;
          }

          const tech_annual = tech_annualized / 100;
          const tech_plus_roi = 1 + tech_a1;
          const tech_left = tech_annual + 1;
          const tech_log_left = Math.log(tech_left);
          const tech_log_right = Math.log(tech_plus_roi);

          let tech_ans =
            tech_log_right === 0 ? 0 : tech_log_left / tech_log_right;
          tech_time = tech_ans === 0 ? 0 : 1 / tech_ans;
        }
      } else {
        result.error = "The minimum returned amount is 0.";
        return result;
      }
    } else {
      result.error = "You have to invest some money!";
      return result;
    }

    // Comparison calculation
    if (tech_compare === "2") {
      if (
        tech_invest_compare === undefined ||
        tech_return_compare === undefined
      ) {
        result.error = "Comparison investment and return amount are required";
        return result;
      }

      if (!(tech_invest_compare <= 0)) {
        if (!(tech_return_compare <= 0)) {
          const tech_answer2 = tech_return_compare - tech_invest_compare;
          let tech_loss2, tech_gain2;

          if (tech_answer2 >= 0) {
            tech_loss2 = "0.00";
            tech_gain2 = tech_answer2.toFixed(2);
          } else {
            tech_loss2 = (-1 * tech_answer2).toFixed(2);
            tech_gain2 = "0.00";
          }

          const tech_a12 = tech_answer2 / tech_invest_compare;
          const tech_roi2 = (tech_a12 * 100).toFixed(2);
          let tech_annualized_answer2, tech_time2;

          if (tech_find_compare === "1") {
            if (tech_date_compare === "1") {
              if (!tech_s_date_compare || !tech_e_date_compare) {
                result.error = "Comparison start and end dates are required";
                return result;
              }

              let tech_from2 = new Date(tech_s_date_compare);
              let tech_to2 = new Date(tech_e_date_compare);

              if (tech_from2 > tech_to2)
                [tech_from2, tech_to2] = [tech_to2, tech_from2];

              result.tech_from2 = tech_from2.toLocaleDateString("en-US", {
                month: "short",
                day: "numeric",
                year: "numeric",
              });
              result.tech_to2 = tech_to2.toLocaleDateString("en-US", {
                month: "short",
                day: "numeric",
                year: "numeric",
              });

              const tech_days2 = tech_dateDiffInDays(tech_from2, tech_to2);
              const tech_yrs2 = tech_days2 / 365;
              const tech_top_n2 = 1 / tech_yrs2;
              const tech_inner12 = 1 + tech_a12;
              const tech_outer2 = Math.pow(tech_inner12, tech_top_n2);
              const tech_annual_ans2 = tech_outer2 - 1;
              tech_annualized_answer2 = tech_annual_ans2 * 100;
              tech_time2 = tech_yrs2;
            } else if (tech_date_compare === "2") {
              if (!tech_length_compare || tech_length_compare == 0) {
                result.error = "Comparison investment length cannot be zero";
                return result;
              }

              const tech_length_compare_yrs = tech_years(
                tech_length_compare,
                tech_length_unit_compare_val
              );
              const tech_n_top2 = 1 / tech_length_compare_yrs;
              const tech_inner2 = 1 + tech_a12;
              const tech_final2 = Math.pow(tech_inner2, tech_n_top2);
              const tech_annualized_ans12 = tech_final2 - 1;
              tech_annualized_answer2 = tech_annualized_ans12 * 100;
              tech_time2 = tech_length_compare_yrs;
            }

            if (tech_annualized_answer2 !== undefined) {
              result.tech_annualized_answer2 = tech_formatNumberWithCommas(
                tech_annualized_answer2
              );
            }
          } else if (tech_find_compare === "2") {
            if (!tech_annualized_compare) {
              result.error = "Comparison annualized rate is required";
              return result;
            }

            const tech_annual2 = tech_annualized_compare / 100;
            const tech_plus_roi2 = 1 + tech_a12;
            const tech_left2 = tech_annual2 + 1;
            const tech_log_left2 = Math.log(tech_left2);
            const tech_log_right2 = Math.log(tech_plus_roi2);
            const tech_ans2 = tech_log_left2 / tech_log_right2;
            tech_time2 = 1 / tech_ans2;
          }

          result.tech_time2 = parseFloat(tech_time2.toFixed(3));
          result.tech_loss2 = tech_loss2;
          result.tech_gain2 = tech_gain2;
          result.tech_roi2 = tech_roi2;
        } else {
          result.error = "The minimum comparison returned amount is 0.";
          return result;
        }
      } else {
        result.error = "You have to invest some money for comparison!";
        return result;
      }
    }

    // Common result properties
    result.tech_time =
      tech_time !== undefined ? parseFloat(tech_time.toFixed(3)) : undefined;
    result.tech_loss = tech_loss;
    result.tech_gain = tech_gain;
    result.tech_roi = tech_roi;
    result.tech_compare = tech_compare;
    result.tech_find = tech_find;
    result.tech_date = tech_date;
    result.tech_s_date = tech_s_date;
    result.tech_e_date = tech_e_date;

    return result;
  }

  /**
   * getCalculationFutureValueOfAnnuityCalculator: Service Method
   * POST: /api/calculators-lol/future-value-of-annuity
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationFutureValueOfAnnuityCalculator(body) {
    let payment = parseFloat(body.tech_payment);
    let interest = parseFloat(body.tech_interest);
    let term = parseFloat(body.tech_term);
    let term_unit = body.tech_term_unit;
    let compounding = parseFloat(body.tech_compounding);
    let payment_fre = parseFloat(body.tech_payment_fre);
    let annuity_type = body.tech_annuity_type;
    let g = body.tech_g ? parseFloat(body.tech_g) : null;

    function yearsConvert(term, term_unit) {
      if (term_unit === "mons") {
        return term / 12;
      } else if (term_unit === "yrs") {
        return term * 1;
      }
      return term;
    }

    let param = {};

    if (!isNaN(payment) && !isNaN(interest) && !isNaN(term)) {
      term = yearsConvert(term, term_unit);
      let r = interest / 100;
      let i = r / compounding;
      let n = term * compounding;
      let f_part = 1 + i;
      let s_part = Math.pow(f_part, n);
      let up_part = s_part - 1;
      let l_part = payment / i;

      let annuity;
      if (annuity_type === "mons") {
        annuity = up_part * l_part;
      } else if (annuity_type === "yrs") {
        let annuity_ans = up_part * l_part;
        annuity = annuity_ans * f_part;
      }

      if (!isNaN(g)) {
        if (g === i) {
          let n1 = n - 1;
          let s_part2 = Math.pow(f_part, n1);
          annuity = payment * n * s_part2;
        } else if (g !== i) {
          let G = g / 100;
          let ig = i - G;
          let iG = 1 + G;
          let ig_part = Math.pow(iG, n);
          let part1 = payment / ig;
          let part2 = s_part - ig_part;
          annuity = part1 * part2;
        }
      }

      if (compounding === 366) {
        let ry = r * term;
        let e1 = Math.pow(Math.E, ry);
        let e2 = Math.pow(Math.E, r);
        let top = e1 - 1;
        let down = e2 - 1;
        let annu = top / down;
        annuity = payment * annu;
      }

      let div = r / compounding;
      let top_div = compounding / payment_fre;
      let final_a = div + 1;
      let overall = Math.pow(final_a, top_div);
      let res = overall - 1;
      let equ = payment_fre * res * 100;
      let equ2 = equ;

      if (payment_fre === 1) {
        term = term * 1;
        annuity = annuity * 1;
        equ2 = equ;
      } else if (payment_fre === 2) {
        term = term * 2;
        annuity = annuity * 2;
        equ2 = equ / 2;
      } else if (payment_fre === 4) {
        term = term * 4;
        annuity = annuity * 4;
        equ2 = equ / 4;
      } else if (payment_fre === 12) {
        term = term * 12;
        annuity = annuity * 12;
        equ2 = equ / 12;
      } else if (payment_fre === 52) {
        term = term * 52;
        annuity = annuity * 52;
        equ2 = equ / 52;
      } else if (payment_fre === 365) {
        term = term * 365;
        annuity = annuity * 365;
        equ2 = equ / 365;
      }

      param["tech_term"] = term.toFixed(2);
      param["tech_annuity"] = annuity.toFixed(2);
      param["tech_equ"] = equ.toFixed(4);
      param["tech_equ2"] = equ2.toFixed(4);
    } else {
      param["error"] = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationUnemploymentRateCalculator: Service Method
   * POST: /api/calculators-lol/unemployment-rate-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationUnemploymentRateCalculator(body) {
    let employed_people = parseFloat(body.tech_employed_people);
    let unemployed_people = parseFloat(body.tech_unemployed_people);
    let adult_population = body.tech_adult_population;
    let calculate = body.tech_calculate;
    let labor_force = parseFloat(body.tech_labor_force);
    let unemployment_rate = parseFloat(body.tech_unemployment_rate);

    let param = {};
    let method;

    if (calculate == "1") {
      method = 1;
      if (!isNaN(employed_people) && !isNaN(unemployed_people)) {
        let cal_labor_force = employed_people + unemployed_people;
        let cal_unemployed_people = (unemployed_people / cal_labor_force) * 100;
        param["tech_labor_force"] = cal_labor_force.toFixed(2);
        param["tech_unemployment_rate"] = cal_unemployed_people.toFixed(2);
      } else {
        param["error"] = "Please fill all fields.";
        return param;
      }
    } else if (calculate == "2") {
      method = 2;
      if (!isNaN(labor_force) && !isNaN(unemployment_rate)) {
        let percent = unemployment_rate / 100;
        let unemployment = labor_force * percent;
        let employment = labor_force - unemployment;
        param["tech_unemployment"] = unemployment.toFixed(2);
        param["tech_employment"] = employment.toFixed(2);
      } else {
        param["error"] = "Please fill all fields.";
        return param;
      }
    }

    if (adult_population !== "") {
      adult_population = parseFloat(adult_population);
      if (!isNaN(adult_population)) {
        let cal_labor_force = employed_people + unemployed_people;
        let labor_force_participation =
          (cal_labor_force / adult_population) * 100;
        param["tech_labor_force_participation"] =
          labor_force_participation.toFixed(2);
      } else {
        param["error"] = "Please fill all fields.";
        return param;
      }
    }

    param["tech_method"] = method;

    return param;
  }

  /**
   * getCalculationCostOfEquityCalculator: Service Method
   * POST: /api/calculators-lol/cost-of-equity-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCostOfEquityCalculator(body) {
    let pay = body.tech_pay;
    let dividend_per_share = parseFloat(body.tech_dividend_per_share);
    let current_market_value = parseFloat(body.tech_current_market_value);
    let growth_rate_dividend = parseFloat(body.tech_growth_rate_dividend);
    let risk_rate_return = parseFloat(body.tech_risk_rate_return);
    let market_rate_return = parseFloat(body.tech_market_rate_return);
    let beta = parseFloat(body.tech_beta);

    let param = {};
    let final_answer;

    if (pay == "1") {
      if (
        !isNaN(dividend_per_share) &&
        !isNaN(current_market_value) &&
        !isNaN(growth_rate_dividend)
      ) {
        let ans =
          dividend_per_share / current_market_value +
          growth_rate_dividend / 100;
        final_answer = ans * 100;
      } else {
        param["error"] = "Please fill all fields.";
        return param;
      }
    } else if (pay == "2") {
      if (
        !isNaN(risk_rate_return) &&
        !isNaN(market_rate_return) &&
        !isNaN(beta)
      ) {
        final_answer =
          risk_rate_return + beta * (market_rate_return - risk_rate_return);
      } else {
        param["error"] = "Please fill all fields.";
        return param;
      }
    } else {
      param["error"] = "Invalid pay option.";
      return param;
    }

    param["tech_ans"] = final_answer.toFixed(2);
    param["tech_pay"] = pay;

    return param;
  }

  /**
   * getCalculationConsumerSurplusCalculator: Service Method
   * POST: /api/calculators-lol/consumer-surplus-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationConsumerSurplusCalculator(body) {
    let operations1 = body.tech_operations1;
    let operations2 = body.tech_operations2;
    let first = parseFloat(body.tech_first);
    let second = parseFloat(body.tech_second);
    let third = parseFloat(body.tech_third);
    let four = parseFloat(body.tech_four);
    let five = parseFloat(body.tech_five);

    let param = {};
    let answer1, answer2, pmax, ps, line1, line2;

    if (operations1 == "1") {
      if (!isNaN(first) && !isNaN(second) && !isNaN(third)) {
        answer1 = second - first;
        pmax = second;
        line1 = "Consumer Surplus";
        ps = answer1 + five;
      } else {
        param["error"] = "Please fill all fields.";
        return param;
      }
    } else if (operations1 == "2") {
      if (!isNaN(first) && !isNaN(second) && !isNaN(five)) {
        answer1 = second - first;
        pmax = second;
        ps = first + five;
        line1 = "Actual Price";
      } else {
        param["error"] = "Please fill all fields.";
        return param;
      }
    } else if (operations1 == "3") {
      if (!isNaN(first) && !isNaN(second) && !isNaN(five)) {
        answer1 = second + first;
        pmax = answer1;
        ps = first + five;
        line1 = "Willing Price";
      } else {
        param["error"] = "Please fill all fields.";
        return param;
      }
    } else {
      param["error"] = "Invalid operations1 option.";
      return param;
    }

    if (operations2 == "1") {
      if (!isNaN(third) && !isNaN(four)) {
        let mul1 = four * 0.5;
        answer2 = mul1 - pmax - third;
        line2 = "Extended Consumer Surplus";
      } else {
        param["error"] = "Please fill all fields.";
        return param;
      }
    } else if (operations2 == "2") {
      if (!isNaN(third) && !isNaN(four)) {
        let mul1 = 0.5 * four;
        answer2 = mul1 - pmax - third;
        line2 = "Equilibrium Price";
      } else {
        param["error"] = "Please fill all fields.";
        return param;
      }
    } else if (operations2 == "3") {
      if (!isNaN(third) && !isNaN(four)) {
        let div = four / 0.5;
        answer2 = div + pmax + third;
        line2 = "Equilibrium Quantity";
      } else {
        param["error"] = "Please fill all fields.";
        return param;
      }
    } else {
      param["error"] = "Invalid operations2 option.";
      return param;
    }

    param["tech_answer1"] = answer1.toFixed(2);
    param["tech_answer2"] = answer2.toFixed(2);
    param["tech_line1"] = line1;
    param["tech_ps"] = ps.toFixed(2);
    param["tech_line2"] = line2;
    param["tech_operations1"] = operations1;
    param["tech_operations2"] = operations2;
    return param;
  }

  /**
   * getCalculationStockCalculator: Service Method
   * POST: /api/calculators-lol/stock-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationStockCalculator(body) {
    let first = body.tech_first;
    let second = body.tech_second;
    let third = body.tech_third;
    let t_unit = body.tech_t_unit;
    let four = body.tech_four;
    let five = body.tech_five;
    let f_unit = body.tech_f_unit;
    let cgt = body.tech_cgt;
    let mycurrency = body.tech_mycurrency;

    let param = {};

    if (t_unit === "%") {
      t_unit = 1;
    } else {
      t_unit = 0.01;
    }

    if (f_unit === "%") {
      f_unit = 1;
    } else {
      f_unit = 0.01;
    }
    // if (t_unit === '%') {
    //     t_unit = 1;
    // } else if (t_unit === mycurrency) {
    //     t_unit = 0.01;
    // }

    // if (f_unit === '%') {
    //     f_unit = 1;
    // } else if (f_unit === mycurrency) {
    //     f_unit = 0.01;
    // }

    third = third * t_unit;
    five = five * f_unit;

    if (
      !isNaN(first) &&
      !isNaN(second) &&
      !isNaN(third) &&
      !isNaN(four) &&
      !isNaN(five) &&
      !isNaN(cgt)
    ) {
      if (cgt > 0) {
        let div1 = first / 100;
        let mul1 = second * third;
        let b_c = 0;

        if (t_unit === 1) {
          b_c = div1 * mul1;
        } else if (t_unit === 0.01) {
          b_c = third * 100;
        }

        let net_by = second * first;
        let netby_ans = net_by + b_c;

        let mul2 = four * five;
        let s_c = 0;

        if (f_unit === 1) {
          s_c = div1 * mul2;
        } else if (f_unit === 0.01) {
          s_c = five * 100;
        }

        let net_sa = four * first;
        let netsa_ans = net_sa - s_c;

        let profit = netsa_ans - netby_ans;
        let pro_per = profit / cgt;
        let pro_ans = profit - pro_per;

        let roi = profit / netby_ans;
        let roi_ans = roi * 100;
        let roi_ans1 = roi_ans / cgt;
        let roi_answer = roi_ans - roi_ans1;

        let per = five / 100;
        let minus_per = 1 - per;
        let mul_no = first * minus_per;
        let break_ans = netby_ans / mul_no;

        param.tech_b_c = b_c;
        param.tech_netby_ans = netby_ans;
        param.tech_s_c = s_c;
        param.tech_netsa_ans = netsa_ans;
        param.tech_profit = pro_ans;
        param.tech_roi_ans = roi_answer;
        param.tech_break_ans = break_ans;
      } else {
        param.error = "CGT Rate cannot be negative.";
      }
    } else {
      param.error = "Please fill all fields.";
    }

    return param;
  }

  /**
   * getCalculationPayRaiseCalculator: Service Method
   * POST: /api/calculators-lol/pay-raise-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPayRaiseCalculator(body) {
    let pay = body.tech_pay;
    let period = body.tech_period;
    let hour = body.tech_hour;
    let type = body.tech_type;
    let newAmount = body.tech_new;

    let param = {};

    if (!isNaN(pay) && !isNaN(hour) && !isNaN(newAmount)) {
      let hourly,
        weekly,
        monthly,
        yearly,
        incHour,
        incWeek,
        incMonth,
        incYear,
        percent;

      if (period == 1) {
        hourly = pay;
        weekly = pay * hour;
        monthly = Math.round(weekly * 4.3333 * 1000) / 1000;
        yearly = weekly * 52;
      } else if (period == 2) {
        hourly = pay / hour;
        weekly = pay;
        monthly = Math.round(weekly * 4.3333 * 1000) / 1000;
        yearly = weekly * 52;
      } else if (period == 3) {
        monthly = pay;
        yearly = monthly * 12;
        weekly = Math.round(((monthly * 12) / 52) * 1000) / 1000;
        hourly = weekly / hour;
      } else if (period == 4) {
        yearly = pay;
        monthly = yearly / 12;
        weekly = Math.round(((monthly * 12) / 52) * 1000) / 1000;
        hourly = weekly / hour;
      }

      if (type == 1) {
        incHour = hourly * (newAmount / 100);
        incWeek = weekly * (newAmount / 100);
        incMonth = monthly * (newAmount / 100);
        incYear = yearly * (newAmount / 100);
        percent = newAmount;
      } else {
        if (period == 1) {
          percent = (newAmount / hourly) * 100;
        } else if (period == 2) {
          percent = (newAmount / weekly) * 100;
        } else if (period == 3) {
          percent = (newAmount / monthly) * 100;
        } else if (period == 4) {
          percent = (newAmount / yearly) * 100;
        }
        incHour = hourly * (percent / 100);
        incWeek = weekly * (percent / 100);
        incMonth = monthly * (percent / 100);
        incYear = yearly * (percent / 100);
      }

      param.tech_percent = Math.round(percent * 100) / 100;
      param.tech_incHour = Math.round(incHour * 1000) / 1000;
      param.tech_incWeek = Math.round(incWeek * 1000) / 1000;
      param.tech_incMonth = Math.round(incMonth * 1000) / 1000;
      param.tech_incYear = Math.round(incYear * 1000) / 1000;
      param.tech_hourly = Math.round(hourly * 1000) / 1000;
      param.tech_weekly = Math.round(weekly * 1000) / 1000;
      param.tech_monthly = Math.round(monthly * 1000) / 1000;
      param.tech_yearly = Math.round(yearly * 1000) / 1000;
      param.tech_type = type;
      return param;
    } else {
      param.error = "Please fill all fields.";
      return param;
    }
  }

  /**
   * getCalculationRoasCalculator: Service Method
   * POST: /api/calculators-lol/roas-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationRoasCalculator(body) {
    let first = body.tech_first;
    let hidden_currency = body.tech_hidden_currency;
    let operations1 = body.tech_operations1;
    let second = body.tech_second;
    let third = body.tech_third;

    let param = {};

    if (operations1 == 1) {
      if (!isNaN(first) && !isNaN(second)) {
        let divide1 = second / first;
        let answer1 = divide1 * 100;
        let line = "";

        if (!isNaN(third)) {
          let answer2 = third - first;
          param.tech_answer2 = answer2;
        }

        if (answer1 > 0 && answer1 < 400) {
          line = `❌ Danger! Your ROAS is ${answer1.toFixed(
            2
          )}% that is alarming. If return is less than 400% ROAS, you are in loss. So you actually spend more on ad campaign.`;
        } else if (answer1 >= 400 && answer1 < 800) {
          line = `🚫 Your ROAS is ${answer1.toFixed(
            2
          )}% that is fair enough. But you must target 800% and spend more than before in ads.`;
        } else if (answer1 >= 800) {
          line = `✔ Great! Your ROAS is ${answer1.toFixed(
            2
          )}% that is fairly good enough.`;
        }

        param.tech_answer1 = answer1;
        param.tech_line = line;
        param.tech_first = first;
        param.tech_second = second;
        param.tech_operations1 = operations1;
        return param;
      } else {
        param.error = "Please fill all fields.";
        return param;
      }
    } else if (operations1 == 2) {
      if (!isNaN(first)) {
        if (first > 0) {
          let answer1 = first * 8;
          let answer2 = answer1 * 10;
          let line = `✅ Aim for ${hidden_currency} ${answer1} as climbing 800% ROAS will let you earn good initiatives.`;

          param.tech_answer1 = answer1;
          param.tech_answer2 = answer2;
          param.tech_line = line;
          param.tech_first = first;
          param.tech_second = second;
          param.tech_operations1 = operations1;
          return param;
        } else {
          param.error = "Money spent on ads cannot be negative or zero";
          return param;
        }
      } else {
        param.error = "Please fill all fields.";
        return param;
      }
    } else {
      param.error = "Invalid operation selected.";
      return param;
    }
  }

  /**
   * getCalculationTurboCalculator: Service Method
   * POST: /api/calculators-lol/turo-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationTurboCalculator(body) {
    let type = body.tech_type;
    let operations = body.tech_operations;
    let first = body.tech_first;
    let second = body.tech_second;
    let third = body.tech_third;
    let four = body.tech_four;
    let f_first = body.tech_f_first;
    let f_second = body.tech_f_second;
    let f_third = body.tech_f_third;

    let param = {};

    if (type === "first") {
      if (!isNaN(f_first) && !isNaN(f_second) && !isNaN(f_third)) {
        let multiply = f_third * f_second;
        let answer = multiply - f_first;
        let heading = "Turo Profit";

        param.tech_answer = answer;
        param.tech_heading = heading;
        param.tech_type = type;
        return param;
      } else {
        param.error = "Please fill all fields.";
        param.tech_type = type;
        return param;
      }
    } else if (type === "second") {
      if (operations === "1") {
        if (!isNaN(first) && !isNaN(second)) {
          let answer = first * second;
          let heading = "Income";

          param.tech_answer = answer;
          param.tech_heading = heading;
          param.tech_type = type;
          param.tech_operations = operations;
          return param;
        } else {
          param.error = "Please fill all fields.";
          param.tech_type = type;
          param.tech_operations = operations;
          return param;
        }
      } else if (operations === "2") {
        if (!isNaN(first) && !isNaN(second) && !isNaN(third)) {
          let divide = first / third;
          let answer = divide + second;
          answer = parseFloat(answer.toFixed(2));
          let heading = "Lease Details";

          param.tech_answer = answer;
          param.tech_heading = heading;
          param.tech_type = type;
          param.tech_operations = operations;
          return param;
        } else {
          param.error = "Please fill all fields.";
          param.tech_type = type;
          param.tech_operations = operations;
          return param;
        }
      } else if (operations === "3") {
        if (!isNaN(first) && !isNaN(second) && !isNaN(third) && !isNaN(four)) {
          let answer = first + second + 50 + four;
          let heading = "Expenses";

          param.tech_answer = answer;
          param.tech_heading = heading;
          param.tech_type = type;
          param.tech_operations = operations;
          return param;
        } else {
          param.error = "Please fill all fields.";
          return param;
        }
      }
    }

    param.error = "Invalid operation or type.";
    return param;
  }

  /**
   * getCalculationCommissionCalculator: Service Method
   * POST: /api/calculators-lol/commission-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCommissionCalculator(body) {
    let find = body.tech_find;
    let select1 = body.tech_select1;
    let sale_price = body.tech_sale_price;
    let commission_rate = body.tech_commission_rate;
    let commission_amount = body.tech_commission_amount;

    let param = {};

    if (find === "1" || find === "2") {
      let method = 1;

      if (select1 === "commission") {
        if (
          !isNaN(sale_price) &&
          !isNaN(commission_rate) &&
          sale_price > 0 &&
          commission_rate > 0
        ) {
          let answer = (sale_price * commission_rate) / 100;
          param.tech_sale_price = sale_price;
          param.tech_commission_rate = commission_rate;
          param.tech_answer = answer;
          param.tech_method = method;
          return param;
        } else {
          param.error = "Please fill all fields.";
          return param;
        }
      } else if (select1 === "sale_price") {
        method = 2;
        if (
          !isNaN(commission_rate) &&
          !isNaN(commission_amount) &&
          commission_rate > 0 &&
          commission_amount > 0
        ) {
          let answer = (commission_amount / commission_rate) * 100;
          param.tech_commission_rate = commission_rate;
          param.tech_commission_amount = commission_amount;
          param.tech_answer = answer;
          param.tech_method = method;
          return param;
        } else {
          param.error = "Please fill all fields.";
          return param;
        }
      } else if (select1 === "commission_rate") {
        method = 3;
        if (
          !isNaN(sale_price) &&
          !isNaN(commission_amount) &&
          sale_price > 0 &&
          commission_amount > 0
        ) {
          let answer = (commission_amount / sale_price) * 100;
          param.tech_sale_price = sale_price;
          param.tech_commission_amount = commission_amount;
          param.tech_answer = answer;
          param.tech_method = method;
          return param;
        } else {
          param.error = "Please fill all fields.";
          return param;
        }
      }
    }

    param.error = "Invalid calculation method or missing fields.";
    return param;
  }

  /**
   * getCalculationTimeAndaHalfCalculator: Service Method
   * POST: /api/calculators-lol/time-and-a-half
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationTimeAndaHalfCalculator(body) {
    let currency = body.tech_currency.trim();
    let normal_pay = parseFloat(body.tech_normal_pay.trim());
    let normal_time = parseFloat(body.tech_normal_time.trim());
    let over_time = parseFloat(body.tech_over_time.trim());
    let multiplier = parseFloat(body.tech_multiplier.trim());
    let pay_period = parseInt(body.tech_pay_period.trim(), 10);

    let param = {};

    if (
      !isNaN(normal_pay) &&
      !isNaN(normal_time) &&
      !isNaN(over_time) &&
      !isNaN(pay_period)
    ) {
      if (
        normal_pay >= 0 &&
        normal_time >= 0 &&
        over_time >= 0 &&
        pay_period >= 0
      ) {
        let half,
          half_pay,
          Overtime_Pay_per_Year,
          standered_pay,
          total,
          Regular_Pay_per_Year,
          Total_Pay_per_Year;

        if (
          (over_time === "" && normal_pay === 0) ||
          (over_time === 0 && normal_pay === 0)
        ) {
          half = "";
          half_pay = 0;
          Overtime_Pay_per_Year = 0;
          normal_pay = 0;
          normal_time = 0;
        } else if (over_time === 0 || over_time === "") {
          half = normal_pay * multiplier;
          half_pay = 0;
          Overtime_Pay_per_Year = 0;
        } else {
          half = normal_pay * multiplier;
          half_pay = normal_pay * multiplier * over_time;
          Overtime_Pay_per_Year = half_pay * pay_period;
        }

        if (normal_pay === 0 && normal_time === 0) {
          standered_pay = 0;
          total = "";
          Regular_Pay_per_Year = 0;
          Total_Pay_per_Year = 0;
        } else {
          standered_pay = normal_pay * normal_time;
          total = standered_pay + half_pay;
          Regular_Pay_per_Year = standered_pay * pay_period;
          Total_Pay_per_Year = total * pay_period;
        }

        param.tech_currency = currency;
        param.tech_normal_pay = normal_pay;
        param.tech_half = half;
        param.tech_half_pay = half_pay;
        param.tech_Overtime_Pay_per_Year = Overtime_Pay_per_Year;
        param.tech_standed_pay = standered_pay;
        param.tech_total = total;
        param.tech_Regular_Pay_per_Year = Regular_Pay_per_Year;
        param.tech_Total_Pay_per_Year = Total_Pay_per_Year;
        param.tech_multiplier = multiplier;
        param.tech_over_time = over_time;
        param.tech_normal_time = normal_time;

        return param;
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }
    } else {
      param.error = "Please! Check Your Input";
      return param;
    }
  }

  /**
   * getCalculationVariableCostCalculator: Service Method
   * POST: /api/calculators-lol/variable-cost-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationVariableCostCalculator(body) {
    let type = body.tech_type;
    let cost = parseFloat(body.tech_cost.trim());
    let output = parseFloat(body.tech_output.trim());

    let param = {};

    if (type && (type === "average_cost" || type === "variable_cost")) {
      if (isNaN(cost) || isNaN(output)) {
        param.error = "Please fill all fields.";
        return param;
      }

      if (type === "average_cost") {
        let av_cost = cost / output;
        param.tech_cost = cost;
        param.tech_output = output;
        param.tech_av_cost = av_cost;
      } else if (type === "variable_cost") {
        let v_cost = cost - output;
        param.tech_cost = cost;
        param.tech_output = output;
        param.tech_v_cost = v_cost;
      }
    } else {
      param.error = "Please fill all fields.";
      return param;
    }

    param.tech_type = type;
    return param;
  }

  /**
   * getCalculationGrowthRateCalculator: Service Method
   * POST: /api/calculators-lol/growth-rate-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationGrowthRateCalculator(body) {
    let operation = body.tech_operation.trim();
    let present_val = parseFloat(body.tech_present_val.trim());
    let past_val = parseFloat(body.tech_past_val.trim());
    let time_val = parseFloat(body.tech_time_val.trim());

    let param = {};

    if (operation === "1") {
      if (isNaN(present_val) || isNaN(past_val)) {
        param.error = "Please! Check Your Input";
        param.tech_operation = operation;
        return param;
      }

      let growth_diff = present_val - past_val;
      let growth_val = growth_diff / past_val;
      let growth_percent = growth_val * 100;
      param.tech_growth_diff = growth_diff;
      param.tech_growth_val = growth_val;
      param.tech_growth_percent = growth_percent;
    } else if (operation === "2") {
      if (isNaN(present_val) || isNaN(past_val) || isNaN(time_val)) {
        param.error = "Please! Check Your Input";
        param.tech_operation = operation;
        return param;
      }

      let growth_sub = present_val / past_val;
      let time_p = 1 / time_val;
      let g_val = Math.pow(growth_sub, time_p);
      let growth_val = g_val - 1;
      let growth_percent = growth_val * 100;
      param.tech_growth_sub = growth_sub;
      param.tech_g_val = g_val;
      param.tech_growth_val = growth_val;
      param.tech_growth_percent = growth_percent;
    } else {
      param.error = "Invalid operation";
      return param;
    }

    param.tech_present_val = present_val;
    param.tech_past_val = past_val;
    param.tech_time_val = time_val;
    param.tech_operation = operation;
    return param;
  }

  /**
   * getCalculationLaborCostCalculator: Service Method
   * POST: /api/calculators-lol/growth-rate-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationLaborCostCalculator(body) {
    let h_p_w = parseFloat(body.tech_h_p_w);
    let p_r = parseFloat(body.tech_p_r);
    let a_d_p_y = parseFloat(body.tech_a_d_p_y);
    let tax = parseFloat(body.tech_tax);
    let insurance = parseFloat(body.tech_insurance);
    let benefits = parseFloat(body.tech_benefits);
    let overtime = parseFloat(body.tech_overtime);
    let supplies = parseFloat(body.tech_supplies);
    let total_revenue = parseFloat(body.tech_total_revenue);

    let param = {};

    if (
      !isNaN(h_p_w) &&
      !isNaN(p_r) &&
      !isNaN(a_d_p_y) &&
      !isNaN(tax) &&
      !isNaN(insurance) &&
      !isNaN(benefits) &&
      !isNaN(overtime) &&
      !isNaN(supplies) &&
      !isNaN(total_revenue)
    ) {
      let g_h_per_year = h_p_w * 52;
      let gross_pay = g_h_per_year * p_r;
      let n_w_p_year = a_d_p_y * 8;
      let net_h_work = g_h_per_year - n_w_p_year;
      let annual_cost = tax + insurance + benefits + overtime + supplies;
      let annual_p_labor_cost = gross_pay + annual_cost;
      let h_l_cost = annual_p_labor_cost / net_h_work;
      let l_c_percentge = annual_p_labor_cost / total_revenue;

      param.tech_annual_p_labor_cost = annual_p_labor_cost;
      param.tech_h_l_cost = h_l_cost;
      param.tech_g_h_per_year = g_h_per_year;
      param.tech_gross_pay = gross_pay;
      param.tech_n_w_p_year = n_w_p_year;
      param.tech_net_h_work = net_h_work;
      param.tech_annual_cost = annual_cost;
      param.tech_l_c_percentge = l_c_percentge;
    } else {
      param.error = "Please fill all fields.";
      return param;
    }

    param.tech_h_p_w = h_p_w;
    param.tech_p_r = p_r;
    param.tech_a_d_p_y = a_d_p_y;
    param.tech_tax = tax;
    param.tech_insurance = insurance;
    param.tech_benefits = benefits;
    param.tech_overtime = overtime;
    param.tech_supplies = supplies;
    param.tech_total_revenue = total_revenue;

    return param;
  }

  /**
   * getCalculationBetaCalculator: Service Method
   * POST: /api/calculators-lol/beta-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBetaCalculator(body) {
    let rs = body.tech_rs;
    let rm = body.tech_rm;

    // Function to calculate significant figures
    function sigFig(value, digits) {
      if (value !== "") {
        let decimalPlaces;
        if (value === 0) {
          decimalPlaces = digits - 1;
        } else if (value < 0) {
          decimalPlaces = digits - Math.floor(Math.log10(Math.abs(value))) - 1;
        } else {
          decimalPlaces = digits - Math.floor(Math.log10(value)) - 1;
        }
        let answer = Number(value.toFixed(decimalPlaces));
        return answer;
      }
    }

    let param = {};

    if (!rs || !rm) {
      param.error = "Please! Check Your Input.";
      return param;
    }

    // Convert comma-separated string to an array of numbers
    rs = rs.split(",").map((value) => parseFloat(value.trim()));
    rm = rm.split(",").map((value) => parseFloat(value.trim()));

    const n = rs.length;

    if (n !== rm.length) {
      param.error = "The number of values should be same in both inputs.";
      return param;
    }

    let check = true;

    // Check if all values are numeric
    for (let i = 0; i < n; i++) {
      if (isNaN(rs[i]) || isNaN(rm[i])) {
        check = false;
        break;
      }
    }

    if (check) {
      let xy_sum = 0;
      let xi2 = [];
      let yi2 = [];

      // Calculate necessary sums
      for (let i = 0; i < n; i++) {
        xi2.push(Math.pow(rm[i], 2));
        yi2.push(Math.pow(rs[i], 2));
        xy_sum += rm[i] * rs[i];
      }

      const rs_sum = rs.reduce((acc, val) => acc + val, 0);
      const rm_sum = rm.reduce((acc, val) => acc + val, 0);
      const xi2_sum = xi2.reduce((acc, val) => acc + val, 0);
      const yi2_sum = yi2.reduce((acc, val) => acc + val, 0);

      const ss_xx = xi2_sum - Math.pow(rm_sum, 2) / n;
      const ss_yy = yi2_sum - Math.pow(rs_sum, 2) / n;
      const ss_xy = xy_sum - (rm_sum * rs_sum) / n;
      const beta_1 = ss_xy / ss_xx;

      param.tech_n = n;
      param.tech_rs = rs;
      param.tech_rm = rm;
      param.tech_rs_sum = rs_sum;
      param.tech_rm_sum = rm_sum;
      param.tech_xi2 = xi2;
      param.tech_yi2 = yi2;
      param.tech_xi2_sum = xi2_sum;
      param.tech_yi2_sum = yi2_sum;
      param.tech_xy_sum = xy_sum;
      param.tech_ss_xx = ss_xx;
      param.tech_ss_yy = ss_yy;
      param.tech_ss_xy = ss_xy;
      param.tech_beta_1 = sigFig(beta_1, 4);
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationGPDCalculator: Service Method
   * POST: /api/calculators-lol/gdp-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationGPDCalculator(body) {
    const consumption = body.tech_consumption;
    const consumption_unit = body.tech_consumption_unit;
    const investment = body.tech_investment;
    const investment_unit = body.tech_investment_unit;
    const purchases = body.tech_purchases;
    const purchases_unit = body.tech_purchases_unit;
    const exports = body.tech_exports;
    const exports_unit = body.tech_exports_unit;
    const imports = body.tech_imports;
    const imports_unit = body.tech_imports_unit;

    const units = (value, unit) => {
      let convertedValue = parseFloat(value);
      if (unit === "million") {
        return convertedValue * 1;
      } else if (unit === "billion") {
        return convertedValue * 1000;
      } else if (unit === "trillion") {
        return convertedValue * 1000000;
      }
      return convertedValue;
    };

    // Check if all values are numbers
    if (
      !isNaN(consumption) &&
      !isNaN(investment) &&
      !isNaN(purchases) &&
      !isNaN(exports) &&
      !isNaN(imports)
    ) {
      // Convert to the correct units
      const consumptionValue = units(consumption, consumption_unit);
      const investmentValue = units(investment, investment_unit);
      const purchasesValue = units(purchases, purchases_unit);
      const exportsValue = units(exports, exports_unit);
      const importsValue = units(imports, imports_unit);

      // Calculate net export and GDP
      const netExport = exportsValue - importsValue;
      const gdp =
        consumptionValue + investmentValue + purchasesValue + netExport;

      // Return the result
      return {
        tech_net_export: netExport,
        tech_gdp: gdp,
        input_consumption: body.tech_consumption,
        input_investment: body.tech_investment,
        input_purchases: body.tech_purchases,
        input_exports: body.tech_exports,
        input_imports: body.tech_imports,
      };
    } else {
      return {
        error: "Please! Check Your Input",
      };
    }
  }

  /**
   * getCalculationNPSCalculator: Service Method
   * POST: /api/calculators-lol/nps-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationNPSCalculator(body) {
    let score_ten = body.tech_score_ten;
    let score_nine = body.tech_score_nine;
    let score_eight = body.tech_score_eight;
    let score_seven = body.tech_score_seven;
    let score_six = body.tech_score_six;
    let score_five = body.tech_score_five;
    let score_four = body.tech_score_four;
    let score_three = body.tech_score_three;
    let score_two = body.tech_score_two;
    let score_one = body.tech_score_one;
    let score_zero = body.tech_score_zero;

    // Check if all values are numbers
    if (
      !isNaN(score_ten) &&
      !isNaN(score_nine) &&
      !isNaN(score_eight) &&
      !isNaN(score_seven) &&
      !isNaN(score_six) &&
      !isNaN(score_five) &&
      !isNaN(score_four) &&
      !isNaN(score_three) &&
      !isNaN(score_two) &&
      !isNaN(score_one) &&
      !isNaN(score_zero)
    ) {
      // Calculate good, neutral, and bad scores
      const good = parseFloat(score_ten) + parseFloat(score_nine);
      const neutral = parseFloat(score_eight) + parseFloat(score_seven);
      const bad =
        parseFloat(score_six) +
        parseFloat(score_five) +
        parseFloat(score_four) +
        parseFloat(score_three) +
        parseFloat(score_two) +
        parseFloat(score_one) +
        parseFloat(score_zero);
      const total = good + neutral + bad;

      // Check if total is zero
      if (total === 0) {
        return {
          error: "Check Your Input Total NPS not equal to zero",
        };
      }

      // Calculate the NPS score
      const answer = ((good / total - bad / total) * 100).toFixed(2); // Rounded to 2 decimal places
      return {
        tech_good: good,
        tech_neutral: neutral,
        tech_bad: bad,
        tech_total: total,
        tech_answer: answer,
        tech_score_ten: score_ten,
        tech_score_nine: score_nine,
        tech_score_eight: score_eight,
        tech_score_seven: score_seven,
        tech_score_six: score_six,
        tech_score_five: score_five,
        tech_score_four: score_four,
        tech_score_three: score_three,
        tech_score_two: score_two,
        tech_score_one: score_one,
        tech_score_zero: score_zero,
      };
    } else {
      return {
        error: "Please fill all fields.",
      };
    }
  }

  /**
   * getCalculationBondPriceCalculator: Service Method
   * POST: /api/calculators-lol/nps-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBondPriceCalculator(body) {
    let faceValue = body.tech_faceValue;
    let couponRate = body.tech_couponRate;
    let yearsToMaturity = body.tech_yearsToMaturity;
    let frequency = body.tech_frequency;
    let yieldRate = body.tech_yieldRate;

    if (
      !isNaN(faceValue) &&
      !isNaN(couponRate) &&
      !isNaN(yearsToMaturity) &&
      !isNaN(frequency) &&
      !isNaN(yieldRate)
    ) {
      const couponRateDecimal = couponRate / 100;
      const yieldDecimal = yieldRate / 100;

      // Function to calculate the bond price
      function calculateBondPrice(
        faceValue,
        couponRateDecimal,
        yearsToMaturity,
        yieldDecimal
      ) {
        const couponPayment = faceValue * couponRateDecimal;
        const totalPayments = yearsToMaturity;
        let presentValue = 0;

        for (let i = 1; i <= totalPayments; i++) {
          presentValue += couponPayment / Math.pow(1 + yieldDecimal, i);
        }
        presentValue += faceValue / Math.pow(1 + yieldDecimal, totalPayments);

        return presentValue;
      }

      const bondPrice = calculateBondPrice(
        faceValue,
        couponRateDecimal,
        yearsToMaturity,
        yieldDecimal
      );
      const couponPayment = (faceValue * couponRateDecimal) / frequency;
      const annualPayment = faceValue * couponRateDecimal;

      return {
        tech_couponPayment: parseFloat(couponPayment.toFixed(2)),
        tech_annual: parseFloat(annualPayment.toFixed(2)),
        tech_bondPrice: parseFloat(bondPrice.toFixed(2)),
      };
    } else {
      return {
        error: "Please check your input.",
      };
    }
  }

  /**
   * getCalculationOpportunityCostCalculator: Service Method
   * POST: /api/calculators-lol/opportunity-cost-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationOpportunityCostCalculator(body) {
    let return_best = body.tech_return_best;
    let return_choose = body.tech_return_choose;
    let param = {};
    // Trim and convert to numbers
    const bestReturn = parseFloat(return_best?.toString().trim());
    const chosenReturn = parseFloat(return_choose?.toString().trim());

    if (!isNaN(bestReturn) && !isNaN(chosenReturn)) {
      param.tech_OpportunityCost = bestReturn - chosenReturn;
      param.tech_return_best = bestReturn;
      param.tech_return_choose = chosenReturn;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationCarDepreciationCalculator: Service Method
   * POST: /api/calculators-lol/car-depreciation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCarDepreciationCalculator(body) {
    let car_cost = body.tech_car_cost;
    let c_age = body.tech_c_age;
    let car_year = body.tech_car_year;
    let rate_level = body.tech_rate_level;
    let hiddent_currency = body.tech_hiddent_currency;

    let result = {};

    car_cost = parseFloat(car_cost);
    c_age = parseInt(c_age);
    car_year = parseInt(car_year);
    rate_level = String(rate_level).trim();
    hiddent_currency = String(hiddent_currency).trim();

    if (
      isNaN(car_cost) ||
      isNaN(c_age) ||
      isNaN(car_year) ||
      !rate_level ||
      isNaN(car_cost)
    ) {
      result.error = "Please! Check Your Input";
      return result;
    }

    let asset = car_cost;
    let asset1 = car_cost;
    let depreciation = 0;
    let c_depreciation = 0;
    let table = "";
    let total_years = "";
    let total_book_value = "";

    for (let i = 1; i <= car_year; i++) {
      let rate = 0;
      if (rate_level === "1") {
        rate = 21.4;
      } else if (rate_level === "2") {
        rate = 15.6;
      } else {
        rate = 10.4;
      }

      if (i === 1 && c_age === 0) {
        if (rate_level === "1") {
          rate = 35.0;
        } else if (rate_level === "2") {
          rate = 25.0;
        } else {
          rate = 16.0;
        }
      }

      total_years += i + ",";
      depreciation = parseFloat(((asset1 * rate) / 100).toFixed(2));
      c_depreciation = parseFloat((c_depreciation + depreciation).toFixed(2));
      let end_book_value = parseFloat((asset - c_depreciation).toFixed(2));
      total_book_value += end_book_value + ",";

      table += `<tr><td className="py-2 border-b">${i}</td><td className="py-2 border-b"> ${hiddent_currency} ${asset1}</td><td className="py-2 border-b">${rate}%</td><td className="py-2 border-b"> ${hiddent_currency} ${depreciation}</td><td className="py-2 border-b"> ${hiddent_currency} ${c_depreciation}</td><td className="py-2 border-b"> ${hiddent_currency} ${end_book_value}</td></tr>`;

      asset1 = asset - c_depreciation;
    }

    result.tech_table = table;
    result.tech_total_years = total_years;
    result.tech_total_book_value = total_book_value;

    return result;
  }

  /**
   * getCalculationPropertyDepreciationCalculator: Service Method
   * POST: /api/calculators-lol/property-depreciation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPropertyDepreciationCalculator(body) {
    let basis = body.tech_basis;
    let recovery = body.tech_recovery;
    let round = body.tech_round;
    let date1 = body.tech_date1;
    let hiddent_currency = body.tech_hiddent_currency;

    // Helper functions
    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function roundNumber(value, decimals) {
      return Number(Math.round(value + "e" + decimals) + "e-" + decimals);
    }

    const result = {};

    // Validate inputs
    if (!isNumeric(basis) || !isNumeric(recovery) || !date1) {
      result.error = "Please! Check Your Input";
      return result;
    }

    const asset = parseFloat(basis);
    let asset1 = parseFloat(basis);
    let depreciation = 0;
    let c_depreciation = 0;
    let table = "";
    let total_years = [];
    let total_book_value = [];

    // Parse date (assuming format YYYY-MM-DD)
    const dateParts = date1.split("-");
    const startYear = parseInt(dateParts[0]);
    const startMonth = parseInt(dateParts[1]);

    for (let i = 0; i <= recovery; i++) {
      let rate = roundNumber(100 / recovery, 2);

      // First year partial calculation
      if (i === 0) {
        const months = 12.5 - startMonth;
        rate = rate / 12;
        rate = roundNumber(rate * months, 2);
      }

      const currentYear = startYear + i;
      total_years.push(currentYear);

      // Calculate depreciation based on rounding preference
      if (round === "yes") {
        depreciation = Math.round(asset * (rate / 100));
        c_depreciation = Math.round(c_depreciation + depreciation);
      } else {
        depreciation = roundNumber(asset * (rate / 100), 2);
        c_depreciation = roundNumber(c_depreciation + depreciation, 2);
      }

      let end_book_value =
        round === "yes"
          ? Math.round(asset - c_depreciation)
          : roundNumber(asset - c_depreciation, 2);

      // Handle negative book value
      if (end_book_value < 0) {
        end_book_value = 0;
        c_depreciation = c_depreciation - depreciation;
        depreciation = asset1;
        c_depreciation = c_depreciation + depreciation;
        rate = roundNumber((depreciation / asset) * 100, 2);
      }

      total_book_value.push(end_book_value);

      // Build HTML table row
      table += `<tr>
                    <td className="py-2 border-b">${currentYear}</td>
                    <td className="py-2 border-b">${hiddent_currency} ${asset1.toFixed(
        round === "yes" ? 0 : 2
      )}</td>
                    <td className="py-2 border-b">${rate}%</td>
                    <td className="py-2 border-b">${hiddent_currency} ${depreciation.toFixed(
        round === "yes" ? 0 : 2
      )}</td>
                    <td className="py-2 border-b">${hiddent_currency} ${c_depreciation.toFixed(
        round === "yes" ? 0 : 2
      )}</td>
                    <td className="py-2 border-b">${hiddent_currency} ${end_book_value.toFixed(
        round === "yes" ? 0 : 2
      )}</td>
                </tr>`;

      asset1 = asset - c_depreciation;
    }

    // Convert arrays to comma-separated strings
    result.tech_total_years = total_years.join(",");
    result.tech_total_book_value = total_book_value.join(",");
    result.tech_table = table;

    return result;
  }

  /**
   * getCalculationPaybackPeriodCalculator: Service Method
   * POST: /api/calculators-lol/payback-period-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPaybackPeriodCalculator(body) {
    // const {
    //     unit_type,
    //     initial,
    //     cash,
    //     in_de,
    //     year,
    //     discount,
    //     add_sub,
    //     initial2,
    //     discount2,
    //     count,
    //     currency,
    //     currency1
    // } = body;
    let unit_type = body.tech_unit_type;
    let initial = body.tech_initial;
    let cash = body.tech_cash;
    let in_de = body.tech_in_de;
    let year = body.tech_year_first;
    let discount = body.tech_discount;
    let add_sub = body.tech_add_sub;
    let initial2 = body.tech_initial2;
    let discount2 = body.tech_discount2;
    let count = body.tech_count;
    let currency = body.tech_currency;
    let currency1 = body.tech_currency1;

    let result = {};
    let param = {};

    if (unit_type === "same") {
      if (
        typeof initial === "number" &&
        typeof cash === "number" &&
        typeof in_de === "number" &&
        typeof year === "number" &&
        typeof discount === "number"
      ) {
        if (year <= 100) {
          let total = initial;
          let cdcf = initial * -1;
          let cdcf_ = initial * -1;
          let table = "";
          let com = 0;
          let back = 0;
          let dis_back = 0;

          let currentCash = cash;
          for (let i = 1; i <= year; i++) {
            if (i !== 1) {
              if (add_sub === "in") {
                currentCash += currentCash * (in_de / 100);
              } else {
                currentCash -= currentCash * (in_de / 100);
              }
            }
            const pv = currentCash / Math.pow(1 + discount / 100, i);
            com += pv;
            table += `<tr><td className='py-2 border-b'>Year ${i}</td><td className='py-2 border-b'>${currency} ${currentCash.toFixed(
              2
            )}</td><td className='py-2 border-b'>${currency} ${(
              cdcf + currentCash
            ).toFixed(
              2
            )}</td><td className='py-2 border-b'>${currency} ${pv.toFixed(
              2
            )}</td><td className='py-2 border-b'>${currency} ${(
              cdcf_ + pv
            ).toFixed(2)}</td></tr>`;
            cdcf += currentCash;
            cdcf_ += pv;
          }
          com /= year;
          const percent = ((com / total) * 100).toFixed(3);

          // Calculate payback period
          let i = 1;
          currentCash = cash;
          cdcf = 0;
          cdcf_ = 0;

          while (initial > cdcf_) {
            if (i !== 1) {
              if (add_sub === "in") {
                currentCash = currentCash + currentCash * (in_de / 100);
              } else {
                currentCash = currentCash - currentCash * (in_de / 100);
              }
            }
            const pv = currentCash / Math.pow(1 + discount / 100, i);
            cdcf_ += pv;
            if (cdcf_ >= initial && !dis_back) {
              const A = i - 1;
              const B = initial - (cdcf_ - pv);
              const C = pv;
              dis_back = (A + B / C).toFixed(3);
            }
            i++;
          }

          // Calculate non-discounted payback period
          i = 1;
          currentCash = cash;
          cdcf = 0;

          while (initial > cdcf) {
            if (i !== 1) {
              if (add_sub === "in") {
                currentCash = currentCash + currentCash * (in_de / 100);
              } else {
                currentCash = currentCash - currentCash * (in_de / 100);
              }
            }
            cdcf += currentCash;
            if (cdcf >= initial && !back) {
              const A = i - 1;
              const B = initial - (cdcf - currentCash);
              const C = currentCash;
              back = (A + B / C).toFixed(3);
            }
            i++;
          }

          result = {
            tech_back: back,
            tech_same: back,
            tech_percent: percent,
            tech_total: total,
            tech_dis_back: dis_back,
            tech_table: table,
          };
        } else {
          result.error =
            "Please provide a positive number of years that is 100 or less.";
        }
      } else {
        result.error = "Please! Check Your Input ";
      }
    } else if (unit_type === "not_same") {
      if (!isNaN(body.tech_initial2) && !isNaN(body.tech_discount2)) {
        const total = Number(body.tech_initial2);
        const discount = Number(body.tech_discount2);

        let cdcf = total * -1;
        let cdcf_ = total * -1;

        const put_input = {
          initial2: body.tech_initial2,
          discount2: body.tech_discount2,
          count: body.tech_count,
          time: new Date().toLocaleString("en-GB", {
            timeZone: "Asia/Karachi",
          }),
        };
        const save_input = [put_input];

        let table = "";
        let ave = 0;
        let total_back = 0;
        let distotal_back = 0;
        let ave_dis = 0;
        let ave_i = 0;
        let back, dis_back;
        let back_check = false;
        let dis_back_check = false;

        for (let i = 1; i <= body.tech_count; i++) {
          if (!isNaN(i)) {
            const cash = i;
            ave += cash;
            ave_i++;

            const pv = cash / Math.pow(1 + discount / 100, i);
            ave_dis += pv;

            table += `<tr><td className='py-2 border-b'>Year ${i}</td><td className='py-2 border-b'>${
              body.tech_currency1
            }${cash.toFixed(2)}</td><td className='py-2 border-b'>${
              body.tech_currency1
            }${(cdcf + cash).toFixed(2)}</td><td className='py-2 border-b'>${
              body.tech_currency1
            }${pv.toFixed(2)}</td><td className='py-2 border-b'>${
              body.tech_currency1
            }${(cdcf_ + pv).toFixed(2)}</td></tr>`;

            cdcf += cash;
            total_back += cash;

            if (cdcf >= 0 && back === undefined) {
              const A = i - 1;
              const B = total - (total_back - cash);
              const C = cash;
              back = +(A + B / C).toFixed(3);
              back_check = true;
            }

            cdcf_ += pv;
            distotal_back += pv;

            if (cdcf_ >= 0 && dis_back === undefined) {
              const A = i - 1;
              const B = total - (distotal_back - pv);
              const C = pv;
              dis_back = +(A + B / C).toFixed(3);
              dis_back_check = true;
            }
          }
        }

        let ave_cash = ave_i === 0 ? 0 : +(ave / ave_i).toFixed(2);
        let ave_cash_d = ave_i === 0 ? 0 : +(ave_dis / ave_i).toFixed(2);

        if (!dis_back_check) {
          param["dis_not_back"] = true;
          let i = 1;
          let temp_cdcf = 0;

          while (total > temp_cdcf) {
            temp_cdcf += ave_cash_d;
            if (temp_cdcf >= total) {
              const A = i - 1;
              const B = total - (temp_cdcf - ave_cash_d);
              const C = ave_cash_d;
              dis_back = +(A + B / C).toFixed(3);
            }
            i++;
          }
        }

        if (!back_check) {
          param["not_back"] = true;
          let i = 1;
          let temp_cdcf = 0;

          while (total > temp_cdcf) {
            temp_cdcf += ave_cash;
            if (temp_cdcf >= total) {
              const A = i - 1;
              const B = total - (temp_cdcf - ave_cash);
              const C = ave_cash;
              back = +(A + B / C).toFixed(3);
            }
            i++;
          }
        }

        param["tech_ave_i"] = ave_i;
        param["tech_ave_cash"] = ave_cash;
        param["tech_ave_cash_d"] = ave_cash_d;
        param["tech_back"] = back;
        param["tech_total"] = total;
        param["tech_dis_back"] = dis_back;
        param["tech_table"] = table;
        return param;
      } else {
        param["error"] = "Please! Check Your Input";
        return param;
      }
    }
    return result;
  }

  /**
   * getCalculationBasisPontCalculator: Service Method
   * POST: /api/calculators-lol/basis-point-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBasisPontCalculator(body) {
    let dec = body.tech_dec;
    let percent = body.tech_percent;
    let perm = body.tech_perm;
    let bsp = body.tech_bsp;
    let unit_type = body.tech_unit_type;
    let bps1 = body.tech_bps1;
    let bps_unit = body.tech_bps_unit;
    let of = body.tech_of;
    let equals = body.tech_equals;

    let param = {};

    if (bps_unit === "decimal") {
      bps_unit = "1";
    } else if (bps_unit === "percent") {
      bps_unit = "2";
    } else if (bps_unit === "permil") {
      bps_unit = "3";
    } else if (bps_unit === "bps") {
      bps_unit = "4";
    }

    if (unit_type === "submit") {
      if (!isNaN(dec) && percent === "" && perm === "" && bsp === "") {
        percent = dec * 100;
        perm = dec * 1000;
        bsp = dec * 10000;
        param.tech_percent = percent;
        param.tech_perm = perm;
        param.tech_bsp = bsp;
        param.tech_ans = 1;
        return param;
      } else if (dec === "" && !isNaN(percent) && perm === "" && bsp === "") {
        dec = percent / 100;
        perm = percent * 10;
        bsp = percent * 100;
        param.tech_dec = dec;
        param.tech_perm = perm;
        param.tech_bsp = bsp;
        param.tech_ans = 2;
        return param;
      } else if (dec === "" && percent === "" && !isNaN(perm) && bsp === "") {
        dec = perm / 1000;
        percent = perm / 10;
        bsp = perm * 10;
        param.tech_dec = dec;
        param.tech_percent = percent;
        param.tech_bsp = bsp;
        param.tech_ans = 3;
        return param;
      } else if (dec === "" && percent === "" && perm === "" && !isNaN(bsp)) {
        dec = bsp / 10000;
        percent = bsp / 100;
        perm = bsp / 10;
        param.tech_dec = dec;
        param.tech_perm = perm;
        param.tech_percent = percent;
        param.tech_ans = 4;
        return param;
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }
    } else if (unit_type === "submit1") {
      if (!isNaN(bps1) && !isNaN(of) && equals === "") {
        if (bps_unit === "1") {
          bps1 = bps1 * 10000;
        } else if (bps_unit === "2") {
          bps1 = bps1 * 100;
        } else if (bps_unit === "3") {
          bps1 = bps1 * 10;
        }

        equals = (bps1 * of) / 10000;
        param.tech_equals = equals;
        param.tech_of = of;
        param.tech_bps1 = bps1;
        param.tech_ans = 5;
        return param;
      } else if (!isNaN(bps1) && of === "" && !isNaN(equals)) {
        if (bps_unit === "1") {
          bps1 = bps1 * 10000;
        } else if (bps_unit === "2") {
          bps1 = bps1 * 100;
        } else if (bps_unit === "3") {
          bps1 = bps1 * 10;
        }
        of = (equals * 10000) / bps1;
        param.tech_equals = equals;
        param.tech_of = of;
        param.tech_bps1 = bps1;
        param.tech_ans = 5;
        return param;
      } else if (bps1 === "" && !isNaN(of) && !isNaN(equals)) {
        bps1 = (equals * 10000) / of;
        param.tech_equals = equals;
        param.tech_of = of;
        param.tech_bps1 = bps1;
        param.tech_ans = 5;
        return param;
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }
    }
  }

  /**
   * getCalculationWeddingBudgetCalculator: Service Method
   * POST: /api/calculators-lol/wedding-budget-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationWeddingBudgetCalculator(body) {
    let spend = body.tech_spend ? parseFloat(body.tech_spend) : 0;
    let guest = body.tech_guest ? parseFloat(body.tech_guest) : 0;
    let dress = body.tech_dress ? parseFloat(body.tech_dress) : 0;
    let jewelery = body.tech_jewelery ? parseFloat(body.tech_jewelery) : 0;
    let accessories = body.tech_accessories
      ? parseFloat(body.tech_accessories)
      : 0;
    let ring = body.tech_ring ? parseFloat(body.tech_ring) : 0;
    let makeup = body.tech_makeup ? parseFloat(body.tech_makeup) : 0;
    let stationery = body.tech_stationery
      ? parseFloat(body.tech_stationery)
      : 0;
    let photography = body.tech_photography
      ? parseFloat(body.tech_photography)
      : 0;
    let florist = body.tech_florist ? parseFloat(body.tech_florist) : 0;
    let planner = body.tech_planner ? parseFloat(body.tech_planner) : 0;
    let venue = body.tech_venue ? parseFloat(body.tech_venue) : 0;
    let dinner = body.tech_dinner ? parseFloat(body.tech_dinner) : 0;
    let catering = body.tech_catering ? parseFloat(body.tech_catering) : 0;
    let cake = body.tech_cake ? parseFloat(body.tech_cake) : 0;
    let DJs = body.tech_DJs ? parseFloat(body.tech_DJs) : 0;
    let liquors = body.tech_liquors ? parseFloat(body.tech_liquors) : 0;
    let ceremony = body.tech_ceremony ? parseFloat(body.tech_ceremony) : 0;
    let officiant = body.tech_officiant ? parseFloat(body.tech_officiant) : 0;
    let hotel = body.tech_hotel ? parseFloat(body.tech_hotel) : 0;
    let transportation = body.tech_transportation
      ? parseFloat(body.tech_transportation)
      : 0;
    let other = body.tech_other ? parseFloat(body.tech_other) : 0;
    let clickvalue1 = body.tech_clickvalue1
      ? parseFloat(body.tech_clickvalue1)
      : 0;
    let clickvalue2 = body.tech_clickvalue2
      ? parseFloat(body.tech_clickvalue2)
      : 0;
    let clickvalue3 = body.tech_clickvalue3
      ? parseFloat(body.tech_clickvalue3)
      : 0;
    let clickvalue4 = body.tech_clickvalue4
      ? parseFloat(body.tech_clickvalue4)
      : 0;
    let clickvalue5 = body.tech_clickvalue5
      ? parseFloat(body.tech_clickvalue5)
      : 0;

    let param = {};

    if (!isNaN(spend) && !isNaN(guest) && guest !== 0) {
      let bride_groom = dress + jewelery + accessories + ring + makeup;
      let sub_contractors = stationery + photography + florist + planner;
      let food_drinks = venue + dinner + catering + cake + DJs + liquors;
      let ceremony_total = ceremony + officiant;
      let trans_accomo = hotel + transportation;
      let total =
        bride_groom +
        sub_contractors +
        food_drinks +
        ceremony_total +
        trans_accomo;
      let average_cost = (total + other) / guest;
      let budget_balance = spend - total;

      param = {
        tech_average_cost: average_cost,
        tech_budget_balance: budget_balance,
        tech_bride_groom: bride_groom,
        tech_sub_contractors: sub_contractors,
        tech_food_drinks: food_drinks,
        tech_ceremony_total: ceremony_total,
        tech_trans_accomo: trans_accomo,
        tech_other: other,
        tech_spend: spend,
        tech_dress: dress,
        tech_jewelery: jewelery,
        tech_accessories: accessories,
        tech_ring: ring,
        tech_makeup: makeup,
        tech_clickvalue1: clickvalue1,
        tech_clickvalue2: clickvalue2,
        tech_clickvalue3: clickvalue3,
        tech_clickvalue4: clickvalue4,
        tech_clickvalue5: clickvalue5,
      };
    } else {
      param = {
        error: "Please fill all fields.",
      };
    }

    return param;
  }

  /**
   * getCalculationEmloyeeCostCalculator: Service Method
   * POST: /api/calculators-lol/employee-cost-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationEmloyeeCostCalculator(body) {
    let unit_type = body.tech_unit_type;
    let rate = body.tech_rate;
    let hour_worked = body.tech_hour_worked;
    let month = body.tech_month;
    let benefits = body.tech_benefits ?? 0; // if null or undefined, default to 0
    let health = body.tech_health ?? 0;
    let dental = body.tech_dental ?? 0;
    let vision = body.tech_vision ?? 0;
    let perk_name = body.tech_perk_name; // assume array
    let annual_contribution = body.tech_annual_contribution; // assume array

    rate = parseFloat(rate);
    hour_worked = parseFloat(hour_worked);
    month = parseFloat(month);
    benefits = parseFloat(benefits);
    health = parseFloat(health);
    dental = parseFloat(dental);
    vision = parseFloat(vision);

    let param = {};

    function calculatePerk(perk_name, annual_contribution) {
      let perk = 0;
      let name_array = [];
      let perk_val = [];

      for (
        let i = 0;
        i < perk_name.length && i < annual_contribution.length;
        i++
      ) {
        name_array.push(perk_name[i]);
        perk_val.push(parseFloat(annual_contribution[i]));
        perk += parseFloat(annual_contribution[i]);
      }
      return [name_array, perk, perk_val];
    }

    if (unit_type === "hourly") {
      if (!isNaN(rate) && !isNaN(hour_worked) && !isNaN(month)) {
        let emp_rate = rate * 4.66484 * hour_worked * month;
        let emp_h_r = emp_rate + benefits + health + dental + vision;

        if (perk_name && annual_contribution) {
          const [name_array, perk, perk_val] = calculatePerk(
            perk_name,
            annual_contribution
          );
          param.tech_perk_array = name_array;
          param.tech_perk = perk;
          param.tech_perk_val = perk_val;
          param.tech_emp_h_r_p = emp_h_r + perk;
        }

        param.tech_emp_h_r = emp_h_r;
        param.tech_rate = rate;
        param.tech_hour_worked = hour_worked;
        param.tech_benefits = benefits;
        param.tech_health = health;
        param.tech_dental = dental;
        param.tech_vision = vision;
        param.tech_month = month;
        param.tech_emp_rate = emp_rate;
      } else {
        param.error = "Please Enter valid values.";
        return param;
      }
    } else if (unit_type === "salary") {
      if (!isNaN(rate) && !isNaN(month)) {
        let per_anum = rate * 0.0765;
        let anual_salary =
          per_anum + rate + benefits + health + dental + vision;

        if (perk_name && annual_contribution) {
          const [name_array, perk, perk_val] = calculatePerk(
            perk_name,
            annual_contribution
          );
          param.tech_perk_array = name_array;
          param.tech_perk = perk;
          param.tech_perk_val = perk_val;
          param.tech_emp_h_r_p = anual_salary + perk;
        }

        param.tech_anual_salary = anual_salary;
        param.tech_rate = rate;
        param.tech_per_anum = per_anum;
        param.tech_benefits = benefits;
        param.tech_health = health;
        param.tech_dental = dental;
        param.tech_vision = vision;
      } else {
        param.error = "Please Enter valid values.";
        return param;
      }
    } else {
      param.error = "Invalid unit type.";
      return param;
    }

    param.tech_submit = unit_type;
    return param;
  }

  /**
   * getCalculationNPVCalculator: Service Method
   * POST: /api/calculators-lol/npv-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationNPVCalculator(body) {
    let initial = body.tech_initial;
    let discount = body.tech_discount;
    let year = body.tech_year; // year should be an array of values

    let param = {}; // to store and return results

    if (
      typeof initial === "number" &&
      typeof discount === "number" &&
      Array.isArray(year)
    ) {
      discount = discount / 100;
      let all_npv = [];

      for (let i = 1; i <= year.length; i++) {
        let npv_btm = Math.pow(1 + discount, i);
        all_npv.push(year[i - 1] / npv_btm);
      }

      let npv_ans = all_npv.reduce((a, b) => a + b, 0) - initial;
      let total_return = year.reduce((a, b) => a + b, 0) - initial;
      let gross_return = (total_return / initial) * 100;
      let net_cash_flow = (initial / 100) * gross_return;

      // DataPoints for Chart
      let dataPoints = year.map((value, index) => ({
        y: parseInt(value),
        label: `Year ${index + 1}`,
      }));

      param.tech_npv_ans = parseFloat(npv_ans.toFixed(2));
      param.tech_gross_return = parseFloat(gross_return.toFixed(2));
      param.tech_net_cash_flow = parseFloat(net_cash_flow.toFixed(2));
      param.tech_dataPoints = dataPoints;
      param.tech_year = year;
      param.tech_arrayLength = year.length;
    } else {
      param.error = "Please fill all fields correctly.";
      return param;
    }

    return param;
  }

  /**
   * getCalculationTipCalculator: Service Method
   * POST: /api/calculators-loltip-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTipCalculator(body) {
    // Separate input variables
    let tipFor = body.tech_for;
    let bill = body.tech_x;
    let xs = body.tech_xs;
    let tip = body.tech_y;
    let person = body.tech_z;
    let round = body.tech_round;
    let rounds = body.tech_rounds;
    // const { for: tipFor, x: bill, xs, y: tip, z: person, round, rounds } = body;

    // Helper function to check if value is numeric
    function isNumeric(value) {
      return !isNaN(value) && value !== null && value !== "";
    }

    // Helper function for rounding
    function roundNumber(value, precision = 0) {
      return precision
        ? parseFloat(value.toFixed(precision))
        : Math.round(value);
    }

    let response = {};

    // Handle single tip calculation
    if (tipFor === "single") {
      if (isNumeric(xs)) {
        response.tech_single = 1;
        return response;
      } else {
        response.error = "Please! Fill all the Input Fields";
        return response;
      }
    } else {
      // Handle multiple person tip calculation
      if (isNumeric(bill) && isNumeric(tip) && isNumeric(person)) {
        let a, b, c, d;

        if (round === "yes") {
          a = roundNumber((tip / 100) * bill);
          b = roundNumber(bill + a);
          c = roundNumber(a / person);
          d = roundNumber(b / person);
        } else {
          a = roundNumber((tip / 100) * bill, 2);
          b = roundNumber(bill + a, 2);
          c = roundNumber(a / person, 2);
          d = roundNumber(b / person, 2);
        }

        response.tech_a = a;
        response.tech_b = b;
        response.tech_c = c;
        response.tech_d = d;
        return response;
      } else {
        response.error = "Please! Fill all the Input Fields";
        return response;
      }
    }
  }

  /**
   * getCalculationHourlyToSalaryCalculator: Service Method
   * POST: /api/calculators-lol/hourly-to-salary-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationHourlyToSalaryCalculator(body) {
    // Separate input variables
    let first = body.tech_first;
    let second = body.tech_second;
    let third = body.tech_third;
    let car = body.tech_car;

    let response = {};
    // Helper function to check if value is numeric
    function isNumeric(value) {
      return !isNaN(value) && value !== null && value !== "";
    }

    // Check if inputs are numeric
    if (isNumeric(first) && isNumeric(second) && isNumeric(third)) {
      let annuly = first * second * third;
      let weekly = first * second;
      let monthly = annuly / 12;

      response.tech_annuly = annuly;
      response.tech_weekly = weekly;
      response.tech_monthly = monthly;
    } else {
      response.error = "Please! Check Your Input";
      return response;
    }

    response.car = car;
    return response;
  }

  /**
   * getCalculationSalaryToHourlyCalculator: Service Method
   * POST: /api/calculators-lol/salary-to-hourly-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSalaryToHourlyCalculator(body) {
    // Separate input variables
    let salary = body.tech_salary;
    let hweek = body.tech_hweek;
    let hyear = body.tech_hyear;
    let type = body.tech_type;
    let currency = body.tech_currency;
    // Helper function to check if value is numeric
    function isNumeric(value) {
      return !isNaN(value) && value !== null && value !== "";
    }
    let response = {};

    // Check if inputs are numeric and type is not empty
    if (
      isNumeric(salary) &&
      isNumeric(hweek) &&
      isNumeric(hyear) &&
      type !== ""
    ) {
      let median_sal,
        name = "";

      // Set median salary based on currency
      if (currency === "$") {
        median_sal = 53924;
        name = "Of US Median";
      } else if (currency === "£") {
        median_sal = 31285;
        name = "Of UK Median";
      } else {
        median_sal = 53924;
      }

      if (hweek > 0 && hyear > 0 && salary > 0) {
        let weekly_rate, hourly_rate, monthaly_rate, mean;

        // Perform calculations based on type
        if (type === "an") {
          weekly_rate = salary / hyear;
          hourly_rate = weekly_rate / hweek;
          monthaly_rate = salary / 12;
          mean = (salary / median_sal) * 100;
        } else if (type === "mo") {
          monthaly_rate = salary;
          hourly_rate = (monthaly_rate * 12) / hyear / hweek;
          weekly_rate = hourly_rate * hweek;
          mean = (salary / median_sal) * 100;
        } else if (type === "we") {
          weekly_rate = salary;
          hourly_rate = weekly_rate / hweek;
          monthaly_rate = (hourly_rate * hyear * hweek) / 12;
          mean = (salary / median_sal) * 100;
        } else if (type === "da") {
          hourly_rate = salary / (hweek / 5);
          weekly_rate = hourly_rate * hweek;
          monthaly_rate = (hourly_rate * hyear * hweek) / 12;
          mean = (salary / median_sal) * 100;
        }

        // Set values in the response object
        response.tech_hourly_rate = hourly_rate;
        response.tech_weekly_rate = weekly_rate;
        response.tech_monthaly_rate = monthaly_rate;
        response.tech_mean = mean;
        response.tech_name = name;
        response.tech_currency = currency;
        return response;
      } else {
        response.error = "Please! Enter the Correct Value";
        return response;
      }
    } else {
      response.error = "Please! Check Your Input";
      return response;
    }
  }

  /**
   * getCalculationRentSpitCalculator: Service Method
   * POST: /api/calculators-lol/rent-split-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRentSpitCalculator(body) {
    // Separate input variables
    let total_rent = body.tech_total_rent;
    let total_area = body.tech_total_area;
    let bedrooms = body.tech_bedrooms;
    let room_area = body.tech_room_area;
    let persons = body.tech_persons;
    let bath = body.tech_bath;

    // Helper function to check if value is numeric
    function isNumeric(value) {
      return !isNaN(value) && value !== null && value !== "";
    }

    // Helper function to sum an array of numbers
    function sumArray(arr) {
      return arr.reduce((acc, val) => acc + val, 0);
    }

    let response = {};

    // Check if inputs are numeric and not empty
    if (
      isNumeric(total_rent) &&
      isNumeric(total_area) &&
      bedrooms > 0 &&
      persons.length > 0 &&
      room_area.length > 0 &&
      bath.length > 0
    ) {
      if (total_area >= sumArray(room_area) + sumArray(bath)) {
        let common_area = total_area - sumArray(room_area) - sumArray(bath);
        let rent_per_sq = total_rent / (total_area - common_area);

        let room_rent = [];
        for (let i = 0; i < bedrooms; i++) {
          room_rent[i] = ((room_area[i] + bath[i]) * rent_per_sq) / persons[i];
        }

        response.tech_room_rent = room_rent;
        return response;
      } else {
        response.error =
          "Combined square footage of rooms should not exceed total square footage of house";
        return response;
      }
    } else {
      response.error = "Please! Check Your Input";
      return response;
    }
  }

  /**
   * getCalculationARVCalculator: Service Method
   * POST: /api/calculators-lol/arv-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationARVCalculator(body) {
    const method_unit = body.tech_method_unit.trim();
    const property = parseFloat(body.tech_property.trim());
    const area = parseFloat(body.tech_area.trim());
    const area_unit = body.tech_area_unit.trim();
    const value = parseFloat(body.tech_value.trim());
    const total = parseFloat(body.tech_total.trim());
    const total_unit = body.tech_total_unit.trim();
    const average = parseFloat(body.tech_average.trim());
    const average_unit = body.tech_average_unit.trim();
    const cost = parseFloat(body.tech_cost.trim());
    const purchase = parseFloat(body.tech_purchase.trim());

    let response = {};

    // Function to handle area unit conversions
    function arv_units(area, area_unit) {
      if (area_unit === "m²") {
        return area; // No conversion needed for m²
      } else if (area_unit === "ft²") {
        return area * 0.092903; // Convert ft² to m²
      } else if (area_unit === "yd²") {
        return area * 0.836127; // Convert yd² to m²
      } else if (area_unit === "mi²") {
        return area * 2.58999e6; // Convert mi² to m²
      } else {
        return "Unsupported unit or invalid input.";
      }
    }

    // Input validation
    if (
      isNaN(area) ||
      isNaN(total) ||
      isNaN(property) ||
      isNaN(value) ||
      isNaN(average) ||
      isNaN(cost) ||
      isNaN(purchase)
    ) {
      response.error = "Please! Check Your Input";
      return response;
    }

    if (area == 0) {
      response.error = "Average Area Price value cannot be equal to zero";
      return response;
    }
    if (total == 0) {
      response.error =
        "Total area of the property value cannot be equal to zero";
      return response;
    }
    if (property == 0) {
      response.error = "Property current value cannot be equal to zero";
      return response;
    }
    if (value == 0) {
      response.error = "Value of renovations cannot be equal to zero";
      return response;
    }
    if (average == 0) {
      response.error = "Repair cost value cannot be equal to zero";
      return response;
    }
    if (cost == 0) {
      response.error = "Total cost of renovation cannot be equal to zero";
      return response;
    }
    if (purchase == 0) {
      response.error = "Investor's purchase rule value cannot be equal to zero";
      return response;
    }
    if (purchase > 100) {
      response.error = "Investor's purchase rule % cannot exceed 100%";
      return response;
    }

    // ARV calculation logic
    let after_repair_value;
    if (method_unit === "Value Of The Property") {
      after_repair_value = property + value; // After repair value is property value + renovation value
    } else {
      const areas = arv_units(area, area_unit);
      const totals = arv_units(total, total_unit);
      after_repair_value = areas * totals; // After repair value = area * total
    }

    const averages = arv_units(average, average_unit);
    const requires_repairs = cost / averages; // Cost of repairs divided by average repair cost
    const maximum_bid_price = after_repair_value * (purchase / 100) - cost; // Maximum bid price
    const percentage = Math.abs(purchase - 100); // Difference between purchase and 100%
    const roi = (percentage / 100) * after_repair_value; // Return on investment

    // Return the response with calculated values
    response.tech_after_repair_value = after_repair_value;
    response.tech_requires_repairs = requires_repairs;
    response.tech_maximum_bid_price = maximum_bid_price;
    response.tech_percentage = percentage;
    response.tech_roi = roi;
    return response;
  }

  /**
   * getCalculation6MinuteWalkTestCalculator: Service Method
   * POST: /api/calculators-lol/6-minute-walk-test
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculation6MinuteWalkTestCalculator(body) {
    let age = body.tech_age;
    let weight = body.tech_weight;
    let distance = body.tech_distance;
    let heightFt = body.tech_height_ft;
    let heightIn = body.tech_height_in;
    let heightCm = body.tech_height_cm;
    let unit = body.tech_unit;
    let unit_ft_in = body.tech_unit_ft_in;
    let gender = body.tech_gender;
    let dis_unit = body.tech_dis_unit;

    let result = {};

    // Validate inputs
    if (
      !isNaN(age) &&
      !isNaN(weight) &&
      !isNaN(distance) &&
      (!isNaN(heightFt) || !isNaN(heightIn) || !isNaN(heightCm))
    ) {
      let wt = parseFloat(weight);
      let dist = parseFloat(distance);
      let ht_cm = parseFloat(heightCm);
      let ht_ft = parseFloat(heightFt);
      let ht_in = parseFloat(heightIn);

      // Convert weight from lbs to kg
      if (unit === "lbs") {
        wt = wt / 2.205;
      }

      // Convert height from ft/in to cm
      if (unit_ft_in === "ft/in") {
        ht_cm = ht_ft * 30.48;
        if (!isNaN(ht_in)) {
          ht_cm += ht_in * 2.54;
        }
      }

      // Gender-based calculation
      let ans = 0;
      let limit = 0;

      if (gender === "Male") {
        ans = Math.round(7.57 * ht_cm - 5.02 * age - 1.76 * wt - 309);
        limit = ans - 153;
      } else {
        ans = Math.round(2.11 * ht_cm - 5.78 * age - 2.29 * wt + 667);
        limit = ans - 139;
      }

      // Convert distance from feet to meters
      if (dis_unit === "ft") {
        dist = dist / 3.281;
      }

      const percent = Math.round((dist / ans) * 100);

      result = {
        tech_Ans: ans,
        tech_limit: limit,
        tech_Percent: percent,
      };
    } else {
      result = {
        error: "Please fill All the Required fields.",
      };
    }

    return result;
  }

  /**
   * getCalculationRMRCalculator: Service Method
   * POST: /api/calculators-lol/rmr-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRMRCalculator(body) {
    let age = body.tech_age;
    let weight = body.tech_weight;
    let height_ft = body.tech_height_ft;
    let height_in = body.tech_height_in;
    let height_cm = body.tech_height_cm;
    let unit = body.tech_unit;
    let unit_h = body.tech_unit_h;
    let gender = body.tech_gender;
    let result = {};

    if (
      !isNaN(age) &&
      !isNaN(weight) &&
      (!isNaN(height_ft) || !isNaN(height_in) || !isNaN(height_cm))
    ) {
      age = parseFloat(age);
      weight = parseFloat(weight);
      height_ft = parseFloat(height_ft);
      height_in = parseFloat(height_in);
      height_cm = parseFloat(height_cm);

      // Convert weight to kg if in lbs
      if (unit === "lbs") {
        weight = weight / 2.205;
      }

      // Convert height to cm if provided in ft/in
      if (unit_h === "ft/in") {
        height_cm = height_ft * 30.48;
        if (!isNaN(height_in)) {
          height_cm += height_in * 2.54;
        }
      }

      let rmr;

      if (gender === "Female") {
        rmr = parseFloat(
          (655 + 9.6 * weight + 1.8 * height_cm - 4.7 * age).toFixed(2)
        );
      } else {
        rmr = parseFloat(
          (66 + 13.7 * weight + 5 * height_cm - 6.8 * age).toFixed(2)
        );
      }

      result = {
        tech_RMR: rmr,
      };
    } else {
      result = {
        error: "Please fill All fields.",
      };
    }

    return result;
  }

  /**
   * getCalculationBMRCalculator: Service Method
   * POST: /api/calculators-lol/bmr-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationBMRCalculator(body) {
    let age = body.tech_age;
    let weight = body.tech_weight;
    let height_ft = body.tech_height_ft;
    let height_in = body.tech_height_in;
    let height_cm = body.tech_height_cm;
    let unit = body.tech_unit;
    let unit_ft_in = body.tech_unit_ft_in;
    let gender = body.tech_gender;
    let result = {};

    if (
      !isNaN(age) &&
      !isNaN(weight) &&
      (!isNaN(height_ft) || !isNaN(height_in) || !isNaN(height_cm))
    ) {
      age = parseFloat(age);
      weight = parseFloat(weight);
      height_ft = parseFloat(height_ft);
      height_in = parseFloat(height_in);
      height_cm = parseFloat(height_cm);

      // Convert weight to kg if in lbs
      if (unit === "lbs") {
        weight = weight / 2.205;
      }

      // Convert height to cm if in ft/in
      if (unit_ft_in === "ft/in") {
        height_cm = height_ft * 30.48;
        if (!isNaN(height_in)) {
          height_cm += height_in * 2.54;
        }
      }

      let bmr, hbmr, sbmr;

      if (gender === "Female") {
        bmr = parseFloat(
          (9.99 * weight + 6.25 * height_cm - 4.92 * age - 161).toFixed(2)
        );
        hbmr = parseFloat(
          (447.593 + 9.247 * weight + 3.098 * height_cm - 4.33 * age).toFixed(2)
        );

        if (age >= 18 && age < 30) {
          sbmr = 14.818 * weight + 486.6;
        } else if (age >= 30 && age < 60) {
          sbmr = 8.126 * weight + 845.6;
        } else if (age >= 60) {
          sbmr = 9.082 * weight + 658.5;
        }
      } else {
        bmr = parseFloat(
          (9.99 * weight + 6.25 * height_cm - 4.92 * age + 5).toFixed(2)
        );
        hbmr = parseFloat(
          (88.362 + 13.397 * weight + 4.799 * height_cm - 5.677 * age).toFixed(
            2
          )
        );

        if (age >= 18 && age < 30) {
          sbmr = 15.057 * weight + 692.2;
        } else if (age >= 30 && age < 60) {
          sbmr = 11.472 * weight + 873.1;
        } else if (age >= 60) {
          sbmr = 11.711 * weight + 587.7;
        }
      }

      result = {
        tech_BMR: bmr,
        tech_hbmr: hbmr,
        tech_sbmr: parseFloat(sbmr.toFixed(2)),
      };
    } else {
      result = {
        error: "Please Fill All Fields.",
      };
    }

    return result;
  }

  /**
   * getCalculationIdealWeightCalculator: Service Method
   * POST: /api/calculators-lol/ideal-weight-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationIdealWeightCalculator(body) {
    let age = body.tech_age;
    let weight = body.tech_weight;
    let gender = body.tech_gender;
    let heightFt = body.tech_height_ft;
    let heightIn = body.tech_height_in;
    let heightCm = body.tech_height_cm;
    let unit = body.tech_unit;
    let unit_ft_in = body.tech_unit_ft_in;
    let hidden_nameunit = body.tech_hidden_nameunit;

    if (
      !isNaN(age) &&
      !isNaN(weight) &&
      (!isNaN(heightFt) || !isNaN(heightIn) || !isNaN(heightCm))
    ) {
      let param = {};
      let height_cm = heightCm;
      if (unit_ft_in === "ft/in") {
        height_cm = heightFt * 30.48;
        if (heightIn != null) {
          height_cm += heightIn * 2.54;
        }
      }

      let height_in = height_cm / 2.54;
      let weight_kg = weight;

      if (unit === "lbs") {
        weight_kg = weight / 2.205;
      }

      const height_meters = height_in / 39.37;
      let ans = 0;

      if (gender === "Female") {
        if (height_in < 60) {
          const Intuitive = +(45.5 - 2.3 * (60 - height_in)).toFixed(2);
          const Baseline = +(45.5 - 0.758 * (60 - height_in)).toFixed(2);
          ans = Baseline;
          Object.assign(param, {
            tech_Intuitive: Intuitive,
            tech_Baseline: Baseline,
          });
        } else {
          const Robinson = +(49 + 1.7 * (height_in - 60)).toFixed(2);
          const Miller = +(53.1 + 1.36 * (height_in - 60)).toFixed(2);
          ans = +(45.5 + 2.3 * (height_in - 60)).toFixed(2);
          const Devine = ans;
          const Hamwi = +(45 + 2.2 * (height_in - 60)).toFixed(2);
          const Broca = +(
            height_cm -
            100 -
            (height_cm - 100) * (15 / 100)
          ).toFixed(2);
          const Lorentz = +(height_cm - 100 - (height_cm - 150) / 2).toFixed(2);
          const Peterson = +(
            2.2 * 22 +
            3.5 * 22 * (height_meters - 1.5)
          ).toFixed(2);
          const Lemmens = +(22 * Math.pow(height_meters, 2)).toFixed(2);
          const BMI_Method = +(25 * (height_meters * height_meters)).toFixed(2);
          Object.assign(param, {
            tech_Robinson: Robinson,
            tech_Miller: Miller,
            tech_Devine: Devine,
            tech_Hamwi: Hamwi,
            tech_Broca: Broca,
            tech_Lorentz: Lorentz,
            tech_Peterson: Peterson,
            tech_Lemmens: Lemmens,
            tech_BMI_Method: BMI_Method,
          });
        }
      } else {
        if (height_in < 60) {
          const Intuitive = +(50 - 2.3 * (60 - height_in)).toFixed(2);
          const Baseline = +(50 - 0.833 * (60 - height_in)).toFixed(2);
          ans = Baseline;
          Object.assign(param, {
            tech_Intuitive: Intuitive,
            tech_Baseline: Baseline,
          });
        } else {
          const Robinson = +(52 + 1.9 * (height_in - 60)).toFixed(2);
          const Miller = +(56.2 + 1.41 * (height_in - 60)).toFixed(2);
          ans = +(50 + 2.3 * (height_in - 60)).toFixed(2);
          const Devine = ans;
          const Hamwi = +(48 + 2.7 * (height_in - 60)).toFixed(2);
          const Broca = +(
            height_cm -
            100 -
            (height_cm - 100) * (10 / 100)
          ).toFixed(2);
          const Lorentz = +(height_cm - 100 - (height_cm - 150) / 4).toFixed(2);
          const Peterson = +(
            2.2 * 22 +
            3.5 * 22 * (height_meters - 1.5)
          ).toFixed(2);
          const Lemmens = +(22 * Math.pow(height_meters, 2)).toFixed(2);
          const BMI_Method = +(25 * (height_meters * height_meters)).toFixed(2);
          Object.assign(param, {
            tech_Robinson: Robinson,
            tech_Miller: Miller,
            tech_Devine: Devine,
            tech_Hamwi: Hamwi,
            tech_Broca: Broca,
            tech_Lorentz: Lorentz,
            tech_Peterson: Peterson,
            tech_Lemmens: Lemmens,
            tech_BMI_Method: BMI_Method,
          });
        }
      }

      const bmi_range1 = +(18.5 * (height_meters * height_meters)).toFixed(2);
      const bmi_range2 = +(25 * (height_meters * height_meters)).toFixed(2);

      let abw, Percent, bmi;
      if (unit === "kg") {
        abw = +(ans + 0.4 * (weight - ans)).toFixed(2) + " kg";
        Percent = +(((weight - ans) / ans) * 100).toFixed(2) + " %";
        bmi = +(weight / Math.pow(height_meters, 2)).toFixed(2);
      } else {
        abw = +(ans * 2.205 + 0.4 * (weight - ans * 2.205)).toFixed(2) + " lbs";
        Percent =
          +(((weight - ans * 2.205) / (ans * 2.205)) * 100).toFixed(2) + " %";
        bmi = +(weight / 2.205 / Math.pow(height_meters, 2)).toFixed(2);
      }

      let lbw;
      if (gender === "Female") {
        lbw = +((9270 * weight_kg) / (8780 + 244 * bmi)).toFixed(2);
      } else {
        lbw = +((9270 * weight_kg) / (6680 + 216 * bmi)).toFixed(2);
      }

      param.tech_ans =
        unit === "kg"
          ? `${ans} <span className='text-blue font-s-20'>kg</span>`
          : `${(ans * 2.205).toFixed(
              2
            )} <span className='text-blue font-s-20'>lbs</span>`;
      param.tech_lbw =
        unit === "kg" ? `${lbw} kg` : `${(lbw * 2.205).toFixed(2)} lbs`;
      param.tech_abw = abw;
      param.tech_hidden_nameunit = hidden_nameunit;
      param.tech_Percent = Percent;
      param.tech_bmi = bmi + " kg/m<sup>2</sup>";
      param.tech_bsa =
        +(
          0.007184 *
          Math.pow(weight_kg, 0.425) *
          Math.pow(height_cm, 0.725)
        ).toFixed(2) + " M<sup>2</sup>";
      param.tech_BMI1 = `${bmi_range1} - ${bmi_range2} kg`;
      param.tech_BMI2 = `${(bmi_range1 * 2.205).toFixed(2)} - ${(
        bmi_range2 * 2.205
      ).toFixed(2)} lbs`;

      return param;
    } else {
      return {
        hidden_nameunit,
        error: "Please Fill All fields.",
      };
    }
  }

  /**
   * getCalculationLeanBodyMassCalculator: Service Method
   * POST: /api/calculators-lol/lean-body-mass-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLeanBodyMassCalculator(body) {
    let weight = body.tech_weight;
    let heightFt = body.tech_height_ft;
    let heightIn = body.tech_height_in;
    let heightCm = body.tech_height_cm;
    let unit = body.tech_unit;
    let unit_ft_in = body.tech_unit_ft_in;
    let gender = body.tech_gender;
    let formula = body.tech_formula;

    let param = {};

    if (
      !isNaN(weight) &&
      (!isNaN(heightFt) || !isNaN(heightIn) || !isNaN(heightCm))
    ) {
      weight = parseFloat(weight);
      heightFt = parseFloat(heightFt) || 0;
      heightIn = parseFloat(heightIn) || 0;
      heightCm = parseFloat(heightCm) || 0;

      if (unit === "lbs") {
        weight = weight / 2.205;
      }

      if (unit_ft_in === "ft/in") {
        heightCm = heightFt * 30.48;
        if (heightIn) {
          heightCm += heightIn * 2.54;
        }
      }

      let Boer, James, Hume, Peters, Boer_per, James_per, Hume_per, Peters_per;

      if (gender === "Female") {
        Boer = 0.252 * weight + 0.473 * heightCm - 48.3;
        Boer_per = (Boer / weight) * 100;

        James = 1.07 * weight - 148 * Math.pow(weight / heightCm, 2);
        James_per = (James / weight) * 100;

        Hume = 0.29569 * weight + 0.41813 * heightCm - 43.2933;
        Hume_per = (Hume / weight) * 100;
      } else {
        Boer = 0.407 * weight + 0.267 * heightCm - 19.2;
        Boer_per = (Boer / weight) * 100;

        James = 1.1 * weight - 128 * Math.pow(weight / heightCm, 2);
        James_per = (James / weight) * 100;

        Hume = 0.3281 * weight + 0.33929 * heightCm - 29.5336;
        Hume_per = (Hume / weight) * 100;
      }

      Peters = 0.0817 * (Math.pow(weight, 0.6469) * Math.pow(heightCm, 0.7236));
      Peters_per = (Peters / weight) * 100;

      if (unit === "lbs") {
        Boer = Boer * 2.205;
        James = James * 2.205;
        Hume = Hume * 2.205;
        Peters = Peters * 2.205;
      }

      Boer = parseFloat(Boer.toFixed(2));
      James = parseFloat(James.toFixed(2));
      Hume = parseFloat(Hume.toFixed(2));
      Peters = parseFloat(Peters.toFixed(2));

      Boer_per = parseFloat(Boer_per.toFixed(2));
      James_per = parseFloat(James_per.toFixed(2));
      Hume_per = parseFloat(Hume_per.toFixed(2));
      Peters_per = parseFloat(Peters_per.toFixed(2));

      let ans = 0;
      let ans_per = 0;

      switch (formula) {
        case "Boer":
          param["tech_Boer_f"] = "bg-gradient text-white";
          ans = Boer;
          ans_per = Boer_per;
          break;
        case "James":
          param["tech_James_f"] = "bg-gradient text-white";
          ans = James;
          ans_per = James_per;
          break;
        case "Hume":
          param["tech_Hume_f"] = "bg-gradient text-white";
          ans = Hume;
          ans_per = Hume_per;
          break;
        case "Peters":
          param["tech_Peters_f"] = "bg-gradient text-white";
          ans = Peters;
          ans_per = Peters_per;
          break;
      }

      param["tech_Boer"] = `${Boer} ${unit}`;
      param["tech_Boer_per"] = Boer_per;
      param["tech_James"] = `${James} ${unit}`;
      param["tech_James_per"] = James_per;
      param["tech_Hume"] = `${Hume} ${unit}`;
      param["tech_Hume_per"] = Hume_per;
      param["tech_Peters"] = `${Peters} ${unit}`;
      param["tech_Peters_per"] = Peters_per;
      param["tech_ans"] = ans;
      param["tech_ans_per"] = ans_per;

      return param;
    } else {
      return { error: "Please Fill All Fields." };
    }
  }

  /**
   * getCalculationBSACalculator: Service Method
   * POST: /api/calculators-lol/bsa-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationBSACalculator(body) {
    let weight = body.tech_weight;
    let gender = body.tech_gender;
    let unit = body.tech_unit;
    let heightFt = body.tech_height_ft;
    let heightIn = body.tech_height_in;
    let heightCm = body.tech_height_cm;
    let unit_ft_in = body.tech_unit_ft_in;

    let response = {};

    if (
      !isNaN(weight) &&
      (!isNaN(heightFt) || !isNaN(heightIn) || !isNaN(heightCm))
    ) {
      weight = parseFloat(weight);
      heightFt = parseFloat(heightFt) || 0;
      heightIn = parseFloat(heightIn) || 0;
      heightCm = parseFloat(heightCm) || 0;

      if (unit === "lbs") {
        weight = weight / 2.205;
      }

      if (unit_ft_in === "ft/in") {
        heightCm = heightFt * 30.48;
        if (heightIn) {
          heightCm += heightIn * 2.54;
        }
      }

      const DuBois = +(
        0.007184 *
        Math.pow(weight, 0.425) *
        Math.pow(heightCm, 0.725)
      ).toFixed(2);
      const Mosteller = +(
        0.016667 *
        Math.sqrt(weight) *
        Math.sqrt(heightCm)
      ).toFixed(2);
      const Haycock = +(
        0.024265 *
        Math.pow(weight, 0.5378) *
        Math.pow(heightCm, 0.3964)
      ).toFixed(2);
      const Gehan = +(
        0.0235 *
        Math.pow(weight, 0.51456) *
        Math.pow(heightCm, 0.42246)
      ).toFixed(2);
      const Boyd = +(
        0.0333 *
        Math.pow(weight, 0.6157 - 0.0188 * Math.log10(weight)) *
        Math.pow(heightCm, 0.3)
      ).toFixed(2);
      const Fujimoto = +(
        0.008883 *
        Math.pow(weight, 0.444) *
        Math.pow(heightCm, 0.663)
      ).toFixed(2);
      const Takahira = +(
        0.007241 *
        Math.pow(weight, 0.425) *
        Math.pow(heightCm, 0.725)
      ).toFixed(2);

      let Schlich;
      if (gender === "Male") {
        Schlich = +(
          0.000579479 *
          Math.pow(weight, 0.38) *
          Math.pow(heightCm, 1.24)
        ).toFixed(2);
      } else {
        Schlich = +(
          0.000975482 *
          Math.pow(weight, 0.46) *
          Math.pow(heightCm, 1.08)
        ).toFixed(2);
      }

      response = {
        tech_DuBois: DuBois,
        tech_Mosteller: Mosteller,
        tech_Haycock: Haycock,
        tech_Gehan: Gehan,
        tech_Boyd: Boyd,
        tech_Fujimoto: Fujimoto,
        tech_Takahira: Takahira,
        tech_Schlich: Schlich,
      };
    } else {
      response.error = "Please fill all fields.";
    }

    return response;
  }

  /**
   * getCalculationCorrectedCalciumCalculator: Service Method
   * POST: /api/calculators-lol/corrected-calcium-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCorrectedCalciumCalculator(body) {
    let calcium = body.tech_calcium;
    let albumin = body.tech_albumin;
    let normal = body.tech_normal;
    let unit_c = body.tech_unit_c;
    let unit_a = body.tech_unit_a;
    let unit_n = body.tech_unit_n;

    let response = {};

    if (!isNaN(calcium) && !isNaN(albumin) && !isNaN(normal)) {
      calcium = parseFloat(calcium);
      albumin = parseFloat(albumin);
      normal = parseFloat(normal);

      if (unit_c === "mmol/l") {
        calcium = calcium * 4.0;
      }

      if (unit_a === "g/L") {
        albumin = albumin * 0.1;
      }

      if (unit_n === "g/L") {
        normal = normal * 0.1;
      }

      let Calcium_res = +(0.8 * (normal - albumin) + calcium).toFixed(1);

      if (unit_c === "mmol/l") {
        Calcium_res = Calcium_res / 4.0;
      }

      response = {
        tech_Calcium_res: +Calcium_res.toFixed(2),
        input_calcium: body.tech_calcium,
        input_albumin: body.tech_albumin,
        input_normal: body.tech_normal,
        input_unit_c: body.tech_unit_c,
        input_unit_a: body.tech_unit_a,
        input_unit_n: body.tech_unit_n,
      };
    } else {
      response = {
        error: "Please fill all fields.",
      };
    }

    return response;
  }

  /**
   * getCalculationANCCalculator: Service Method
   * POST: /api/calculators-lol/anc-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationANCCalculator(body) {
    let wbs = body.tech_wbs;
    let segs = body.tech_segs;
    let bands = body.tech_bands;
    let response = {};

    // Check if any non-submit field is empty
    let isValid = true;
    for (let key in body) {
      if (
        key !== "submit" &&
        (body[key] === "" || body[key] === null || body[key] === undefined)
      ) {
        isValid = false;
        break;
      }
    }

    if (!isNaN(wbs) && !isNaN(segs) && !isNaN(bands) && isValid) {
      wbs = parseFloat(wbs);
      segs = parseFloat(segs);
      bands = parseFloat(bands);

      let anc = (wbs * (segs + bands)) / 100;

      response = {
        tech_anc: +anc.toFixed(2),
      };
    } else {
      response = {
        error: "Please Fill All Fields.",
      };
    }

    return response;
  }

  /**
   * getCalculationALCCalculator: Service Method
   * POST: /api/calculators-lol/alc-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationALCCalculator(body) {
    let wbc = body.tech_wbs;
    let l = body.tech_l;

    let response = {};

    if (!isNaN(wbc) && !isNaN(l)) {
      wbc = parseFloat(wbc);
      l = parseFloat(l);

      let alc = parseFloat(((l / 100) * wbc).toFixed(3));

      response = {
        tech_alc: alc,
      };
    } else {
      response = {
        error: "Please Fill All Fields.",
      };
    }

    return response;
  }

  /**
   * getCalculationReticulocyteCountCalculator: Service Method
   * POST: /api/calculators-lol/reticulocyte-count-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationReticulocyteCountCalculator(body) {
    let x = body.tech_x;
    let y = body.tech_y;
    let z = body.tech_z;

    let response = {};

    if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
      let r = parseFloat(x);
      let h = parseFloat(y);
      let n = parseFloat(z);

      let reticulocyteIndex = r * (h / n);

      let maturationFactor;
      if (h < 20) {
        maturationFactor = 2.5;
      } else if (h < 25) {
        maturationFactor = 2.0;
      } else if (h < 35) {
        maturationFactor = 1.5;
      } else {
        maturationFactor = 1.0;
      }

      let correctedCount = reticulocyteIndex / maturationFactor;

      let ans, ans_p;
      if (reticulocyteIndex < 2) {
        ans = "Hypoproliferation";
        ans_p = "Reticulocyte index <2 indicates Hypoproliferation";
      } else {
        ans = "Adequate";
        ans_p = "Reticulocyte index ≥2 indicates Adequate response";
      }

      response = {
        tech_x: parseFloat(reticulocyteIndex.toFixed(2)),
        tech_y: parseFloat(correctedCount.toFixed(3)),
        tech_ans: ans,
        tech_ans_p: ans_p,
      };
    } else {
      response = {
        error: "Please Fill All Fields.",
      };
    }

    return response;
  }

  /**
   * getCalculationCentorScoreCalculator: Service Method
   * POST: /api/calculators-lol/centor-score-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCentorScoreCalculator(body) {
    let tonsils = body.tech_tonsils;
    let cough = body.tech_cough;
    let lymph = body.tech_lymph;
    let age = body.tech_age;
    let temp = body.tech_temp;
    let unit = body.tech_unit;
    let response = {};

    // Validate all inputs are present (allowing 0 as valid)
    if (
      tonsils !== undefined &&
      cough !== undefined &&
      lymph !== undefined &&
      age !== undefined &&
      temp !== undefined &&
      unit !== undefined &&
      !isNaN(age) &&
      !isNaN(temp)
    ) {
      tonsils = parseInt(tonsils);
      cough = parseInt(cough);
      lymph = parseInt(lymph);
      age = parseFloat(age);
      temp = parseFloat(temp);

      let ageScore;
      if (age < 15) {
        ageScore = 1;
      } else if (age >= 15 && age < 45) {
        ageScore = 0;
      } else {
        ageScore = -1;
      }

      let tempScore = 0;
      if (unit === "°C") {
        tempScore = temp > 38 ? 1 : 0;
      } else {
        tempScore = temp > 100.4 ? 1 : 0;
      }

      let ans = tonsils + cough + lymph + ageScore + tempScore;
      let per = "";
      let text = "";

      if (ans === 0) {
        per = "(1 - 2.5 %)";
        text = "There is no need for further testing or antibiotics.";
      } else if (ans === 1) {
        per = "(5 - 10 %)";
        text = "There is no need for further testing or antibiotics.";
      } else if (ans === 2) {
        per = "(11 - 17 %)";
        text = "At this point, rapid strep testing and/or culture (Optional).";
      } else if (ans === 3) {
        per = "(28 - 35 %)";
        text =
          "There is a need to consider rapid strep testing and/or culture.";
      } else {
        per = "(51 - 53 %)";
        text = "There is a need to treat empirically using antibiotics.";
      }

      response = {
        tech_ans: `${ans} Points`,
        tech_per: per,
        tech_text: text,
      };
    } else {
      response = {
        error: "Please Fill All Fields.",
      };
    }

    return response;
  }

  /**
   * getCalculationChildPughCalculator: Service Method
   * POST: /api/calculators-lol/child-pugh-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationChildPughCalculator(body) {
    let a = body.tech_a;
    let e = body.tech_e;
    let b = body.tech_b;
    let as = body.tech_as;
    let i = body.tech_i;
    let response = {};

    // Check if all required fields are provided
    if ([a, e, b, as, i].every((val) => val !== undefined && val !== "")) {
      a = parseInt(a);
      e = parseInt(e);
      b = parseInt(b);
      as = parseInt(as);
      i = parseInt(i);

      const ans = a + e + i + b + as;

      let classGroup = "";
      let ansa = "";
      let ansb = "";
      let percent1 = "";
      let percent2 = "";

      if (ans === 5 || ans === 6) {
        classGroup = "A";
        ansa = "Life Expectancy : 15-20 years";
        ansb = "Abdominal surgery peri-operative mortality: 10%";
        percent1 = "100";
        percent2 = "85";
      } else if (ans > 6 && ans < 10) {
        classGroup = "B";
        ansa = "Indication for transplant evaluation";
        ansb = "Abdominal surgery peri-operative mortality: 30%";
        percent1 = "81";
        percent2 = "57";
      } else {
        classGroup = "C";
        ansa = "Life Expectancy : 1-3 years";
        ansb = "Abdominal surgery peri-operative mortality: 82%";
        percent1 = "45";
        percent2 = "35";
      }

      response = {
        tech_ans: `${ans} Points`,
        tech_class: classGroup,
        tech_ansa: ansa,
        tech_ansb: ansb,
        tech_percent1: percent1,
        tech_percent2: percent2,
      };
    } else {
      response = {
        error: "Please Fill All Fields.",
      };
    }

    return response;
  }

  /**
   * getCalculationWaistToHipRatioCalculator: Service Method
   * POST: /api/calculators-lol/waist-to-hip-ratio-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationWaistToHipRatioCalculator(body) {
    let w = body.tech_w;
    let h = body.tech_h;
    let unit = body.tech_unit;
    let unit1 = body.tech_unit1;
    let gender = body.tech_gender;
    let response = {};

    if (!isNaN(w) && !isNaN(h)) {
      w = parseFloat(w);
      h = parseFloat(h);

      let ans = 0;

      // Unit conversion
      if (unit === unit1) {
        ans = parseFloat((w / h).toFixed(3));
      } else {
        if (unit === "in") {
          w = w * 2.54;
          ans = parseFloat((w / h).toFixed(3));
        } else if (unit1 === "in") {
          h = h * 2.54;
          ans = parseFloat((w / h).toFixed(3));
        }
      }

      // Always convert waist to cm for classification
      let waist = unit === "in" ? w * 2.54 : w;

      // Optional classification logic (still commented out)
      /*
          if (gender === 'male') {
              if (waist <= 90) response.health = "bg-green-800 text-white";
              else if (waist > 90 && waist <= 102) response.inc = "bg-orange text-white";
              else if (waist > 102) response.risk = "bg-red-800 text-white";
  
              if (ans <= 0.95) response.low = "bg-green-800 text-white";
              else if (ans > 0.95 && ans <= 1.0) response.mod = "bg-orange text-white";
              else if (ans > 1.0) response.high = "bg-red-800 text-white";
          } else {
              if (waist <= 80) response.health = "bg-green-800 text-white";
              else if (waist > 80 && waist <= 88) response.inc = "bg-orange text-white";
              else if (waist > 88) response.risk = "bg-red-800 text-white";
  
              if (ans <= 0.80) response.low = "bg-green-800 text-white";
              else if (ans > 0.80 && ans <= 0.84) response.mod = "bg-orange text-white";
              else if (ans > 0.84) response.high = "bg-red-800 text-white";
          }
          */

      response.tech_ans = ans;
      response.inpit_w = body.tech_w;
      response.inpit_h = body.tech_h;
      response.inpit_unit = body.tech_unit;
      response.inpit_unit1 = body.tech_unit1;
    } else {
      response.error = "Please Fill All Fields.";
    }

    return response;
  }

  /**
   * getCalculationWaistToHeightRatioCalculator: Service Method
   * POST: /api/calculators-lol/waist-to-height-ratio-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationWaistToHeightRatioCalculator(body) {
    let height_ft = body.tech_height_ft;
    let height_in = body.tech_height_in;
    let height_cm = body.tech_height_cm;
    let waist = body.tech_waist;
    let unit_ft_in = body.tech_unit_ft_in;
    let unit = body.tech_unit;
    let gender = body.tech_gender;

    let response = {};
    let color = "";
    let left = "";
    let ans = 0;

    if (
      (!isNaN(height_ft) || !isNaN(height_in) || !isNaN(height_cm)) &&
      !isNaN(waist)
    ) {
      // Convert height to cm
      let total_height_cm = 0;

      if (unit_ft_in === "ft/in") {
        if (!isNaN(height_ft)) {
          total_height_cm += parseFloat(height_ft) * 30.48;
        }
        if (!isNaN(height_in)) {
          total_height_cm += parseFloat(height_in) * 2.54;
        }
      } else {
        total_height_cm = parseFloat(height_cm);
      }

      // Convert waist to cm if it's in inches
      if (unit === "in") {
        waist = parseFloat(waist) * 2.54;
      } else {
        waist = parseFloat(waist);
      }

      // Ratio calculation
      ans = parseFloat((waist / total_height_cm).toFixed(2));

      if (gender === "Male") {
        if (ans < 0.34) {
          color = "#20BEC8";
          left = "2%";
          response.tech_under = "Underweight";
          response.tech_xslim = "bg-blue-800 text-white";
        } else if (ans > 0.34 && ans < 0.42) {
          color = "#20BEC8";
          left = "2%";
          response.tech_slim = "bg-blue-800 text-white";
          response.tech_under = "Underweight";
        } else if (ans >= 0.42 && ans <= 0.52) {
          color = "#10951D";
          left = "26%";
          response.tech_healthy = "Healthy";
          response.tech_health = "bg-green-800 text-white";
        } else if (ans >= 0.53 && ans <= 0.57) {
          color = "#CABE52";
          left = "50%";
          response.tech_over = "Overweight";
          response.tech_overc = "bg-yellow-800 text-white";
        } else if (ans > 0.58 && ans <= 0.62) {
          color = "#FF0000";
          left = "50%";
          response.tech_over = "Overweight";
          response.tech_overh = "bg-red-800 text-white";
        } else if (ans >= 0.63 && ans <= 0.8) {
          color = "#FF0000";
          left = "74%";
          response.tech_obese = "Obese";
          response.tech_obesew = "bg-red-800 text-white";
        } else if (ans > 0.8) {
          color = "#FF0000";
          left = "80%";
          response.tech_obese = "Obese";
          response.tech_obesew = "bg-red-800 text-white";
        }
      } else if (gender === "Female") {
        if (ans < 0.34) {
          color = "#20BEC8";
          left = "2%";
          response.tech_under = "Underweight";
          response.tech_xslim = "bg-blue-800 text-white";
        } else if (ans > 0.34 && ans < 0.42) {
          color = "#20BEC8";
          left = "2%";
          response.tech_slim = "bg-blue-800 text-white";
          response.tech_under = "Underweight";
        } else if (ans >= 0.42 && ans <= 0.48) {
          color = "#10951D";
          left = "26%";
          response.tech_healthy = "Healthy";
          response.tech_health = "bg-green-800 text-white";
        } else if (ans >= 0.49 && ans <= 0.53) {
          color = "#CABE52";
          left = "50%";
          response.tech_over = "Overweight";
          response.tech_overc = "bg-yellow-800 text-white";
        } else if (ans > 0.53 && ans <= 0.57) {
          color = "#FF0000";
          left = "50%";
          response.tech_over = "Overweight";
          response.tech_overh = "bg-red-800 text-white";
        } else if (ans >= 0.58 && ans <= 0.8) {
          color = "#FF0000";
          left = "74%";
          response.tech_obese = "Obese";
          response.tech_obesew = "bg-red-800 text-white";
        } else if (ans > 0.8) {
          color = "#FF0000";
          left = "80%";
          response.tech_obese = "Obese";
          response.tech_obesew = "bg-red-800 text-white";
        }
      }

      response.tech_ratio = ans;
      response.tech_color = color;
      response.tech_left = left;
    } else {
      response.error = "Please Fill All Fields.";
    }

    return response;
  }

  /**
   * getCalculationFFMICalculator: Service Method
   * POST: /api/calculators-lol/ffmi-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationFFMICalculator(body) {
    const result = {};

    let height_ft = Number(body.tech_height_ft);
    let height_in = Number(body.tech_height_in);
    let height_cm = Number(body.tech_height_cm);
    let percent = Number(body.tech_percent);
    let weight = Number(body.tech_weight);
    let unit = body.tech_unit;
    let unit_ft_in = body.tech_unit_ft_in;

    if (
      !isNaN(weight) &&
      !isNaN(percent) &&
      (!isNaN(height_ft) || !isNaN(height_in) || !isNaN(height_cm))
    ) {
      // Convert weight if in lbs
      if (unit === "lbs") {
        weight = weight / 2.205;
      }

      // Handle ft/in to cm
      if (unit_ft_in === "ft/in") {
        height_cm = height_ft * 30.48;
        if (height_in != null) {
          height_cm += height_in * 2.54;
        }
      }

      // Convert height to meters
      let height_inch = height_cm / 2.54;
      let height_m = height_inch / 39.37;

      // Calculations
      let body_fat = +(weight * (percent / 100)).toFixed(2);
      let lean = +(weight * (1 - percent / 100)).toFixed(2);
      let ffmi = +(lean / Math.pow(height_m, 2)).toFixed(2);
      let nffmi = +(ffmi + 6.1 * (1.8 - height_m)).toFixed(2);
      let bmi = +(weight / Math.pow(height_m, 2)).toFixed(2);

      let cat = "";
      // if (ffmi < 18) {
      //   result.skinny = "purple text-white";
      //   cat = "Below Average";
      // } else if (ffmi >= 18 && ffmi < 20) {
      //   result.average = "cyan text-white";
      //   cat = "Average";
      // } else if (ffmi >= 20 && ffmi < 22) {
      //   result.fat = "red text-white";
      //   cat = "Above Average";
      // } else if (ffmi >= 22 && ffmi < 23) {
      //   result.athlete = "orange text-white";
      //   cat = "Excellent";
      // } else if (ffmi >= 23 && ffmi < 26) {
      //   result.gym = "orange text-white";
      //   cat = "Superior";
      // } else if (ffmi >= 26 && ffmi < 28) {
      //   result.body = "bg-gradient text-white";
      //   cat = "Suspicion of steroid use";
      // } else {
      //   result.unlikely = "bg-gradient text-white";
      //   cat = "Unlikely";
      // }
      if (ffmi < 18) {
        result.skinny = "bg-purple-600 text-white";
        cat = "Below Average";
      } else if (ffmi >= 18 && ffmi < 20) {
        result.average = "bg-cyan-600 text-white";
        cat = "Average";
      } else if (ffmi >= 20 && ffmi < 22) {
        result.fat = "bg-red-600 text-white";
        cat = "Above Average";
      } else if (ffmi >= 22 && ffmi < 23) {
        result.athlete = "bg-orange-500 text-white";
        cat = "Excellent";
      } else if (ffmi >= 23 && ffmi < 26) {
        result.gym = "bg-orange-700 text-white";
        cat = "Superior";
      } else if (ffmi >= 26 && ffmi < 28) {
        result.body =
          "bg-gradient-to-r from-yellow-400 via-red-500 to-pink-500 text-white";
        cat = "Suspicion of steroid use";
      } else {
        result.unlikely =
          "bg-gradient-to-r from-gray-700 via-red-700 to-black text-white";
        cat = "Unlikely";
      }

      result.tech_body_fat = body_fat;
      result.tech_lean = lean;
      result.tech_ffmi = ffmi;
      result.tech_nffmi = nffmi;
      result.tech_bmi = bmi;
      result.tech_cat = cat;

      return result;
    } else {
      return {
        error: "Please Fill All Fields.",
      };
    }
  }

  /**
   * getCalculationBodyShapeCalculator: Service Method
   * POST: /api/calculators-lol/body-shape-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBodyShapeCalculator(body) {
    let high = parseFloat(body.tech_high);
    let chest = parseFloat(body.tech_chest);
    let waist = parseFloat(body.tech_waist);
    let hip = parseFloat(body.tech_hip);
    let high_units = body.tech_high_units;
    let chest_units = body.tech_bust_units;
    let waist_units = body.tech_waist_units;
    let hip_units = body.tech_hip_units;
    let gender = body.tech_gender;

    const cm_convert = (val, unit) => {
      return unit === "cm" ? val * 2.54 : val;
    };

    if (isFinite(high) && isFinite(chest) && isFinite(waist) && isFinite(hip)) {
      high = cm_convert(high, high_units);
      chest = cm_convert(chest, chest_units);
      waist = cm_convert(waist, waist_units);
      hip = cm_convert(hip, hip_units);

      let shape = "";
      let img = "";

      if (gender === "men") {
        if (
          Math.abs(chest - waist) <= 2 &&
          Math.abs(waist - hip) <= 2 &&
          Math.abs(hip - high) <= 2
        ) {
          shape = "Rectangle";
          img = "Rectangle_man";
        } else if (chest > waist && chest > hip) {
          shape = "Inverted Triangle";
          img = "male_inver_tri";
        } else if (
          chest > waist &&
          chest > high &&
          !(chest > waist && chest > hip && chest > high)
        ) {
          shape = "Trapezoid";
          img = "Trapezoid";
        } else if (hip > chest && high > chest) {
          shape = "Triangle";
          img = "male_tri";
        } else if (waist > chest && waist > hip) {
          shape = "Oval";
          img = "Oval_man";
        } else if (waist > chest && waist > high) {
          shape = "Triangle";
          img = "Triangle_man";
        } else {
          shape = "Oval";
          img = "Oval_man";
        }
      } else {
        if (
          chest - hip <= 1 &&
          hip - chest < 3.6 &&
          (chest - waist >= 9 || hip - waist >= 10)
        ) {
          shape = "Hourglass";
          img = "Hourglass";
        } else if (
          hip - chest >= 3.6 &&
          hip - chest < 10 &&
          hip - waist >= 9 &&
          high / waist < 1.193
        ) {
          shape = "Bottom Hourglass";
          img = "Bottom_Hourglass";
        } else if (chest - hip > 1 && chest - hip < 10 && chest - waist >= 9) {
          shape = "Top Hourglass";
          img = "Top_Hourglass";
        } else if (
          hip - chest > 2 &&
          hip - waist >= 7 &&
          high / waist >= 1.193
        ) {
          shape = "Spoon";
          img = "Spoon";
        } else if (hip - chest >= 3.6 && hip - waist < 9) {
          shape = "Triangle";
          img = "Triangle";
        } else if (chest - hip >= 3.6 && chest - waist < 9) {
          shape = "Inverted Triangle";
          img = "Inverted_Triangle";
        } else if (
          hip - chest < 3.6 &&
          chest - hip < 3.6 &&
          chest - waist < 9 &&
          hip - waist < 10
        ) {
          shape = "Rectangle";
          img = "Rectangle";
        } else if (chest > waist && hip > high) {
          shape = "Top Hourglass";
          img = "Top_Hourglass";
        } else {
          shape = "Rectangle";
          img = "Rectangle";
        }
      }

      const whr = parseFloat((waist / hip).toFixed(2));

      return {
        tech_shape: shape,
        tech_img: img,
        tech_whr: whr,
      };
    } else {
      return {
        error: "Please Input Values!",
      };
    }
  }

  /**
   * getCalculationWeightLossPercentageCalculator: Service Method
   * POST: /api/calculators-lol/weight-loss-percentage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationWeightLossPercentageCalculator(body) {
    let inw = body.tech_inw;
    let crw = body.tech_crw;
    let unit = body.tech_unit;
    let unit1 = body.tech_unit1;

    let param = {};

    inw = parseFloat(inw);
    crw = parseFloat(crw);

    if (!isNaN(inw) && !isNaN(crw)) {
      let inw_lbs, inw_kg, crw_lbs, crw_kg, pw, wg;

      if (unit === "lbs") {
        inw_lbs = inw;
        inw_kg = inw / 2.20462;
      } else {
        inw_lbs = inw * 2.20462;
        inw_kg = inw;
      }

      if (unit1 === "lb") {
        crw_lbs = crw;
        crw_kg = crw / 2.20462;
      } else {
        crw_lbs = crw * 2.20462;
        crw_kg = crw;
      }

      if (unit === unit1) {
        pw = parseFloat((((inw - crw) / inw) * 100).toFixed(2));
        wg = `${crw - inw} ${unit1}`;
      } else {
        if (unit === "kg") inw = inw * 2.20462;
        if (unit1 === "lbs") crw = crw * 2.20462;
        pw = parseFloat((((inw - crw) / inw) * 100).toFixed(2));
        wg = `${crw - inw} lbs`;
      }

      param.tech_pw = pw;
      param.tech_wg = wg;
      param.tech_inw_lbs = inw_lbs.toFixed(2);
      param.tech_inw_kg = inw_kg.toFixed(2);
      param.tech_crw_lbs = crw_lbs.toFixed(2);
      param.tech_crw_kg = crw_kg.toFixed(2);

      return param;
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /**
   * getCalculationDosageCalculator: Service Method
   * POST: /api/calculators-lol/dosage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDosageCalculator(body) {
    let w = body.tech_w;
    let w1 = body.tech_w1;
    let d = body.tech_d;
    let d1 = body.tech_d1;
    let f = body.tech_f;
    let mc = body.tech_mc;
    let mc1 = body.tech_mc1;
    let param = {};

    w = parseFloat(w);
    d = parseFloat(d);
    mc = parseFloat(mc);

    if (mc1 === "g/L") {
      mc1 = "gl";
    } else if (mc1 === "mg/mL") {
      mc1 = "mgl";
    } else if (mc1 === "µg/L") {
      mc1 = "ugl";
    } else if (mc1 === "mg/mL") {
      mc1 = "mg-ml";
    } else if (mc1 === "µg/mL") {
      mc1 = "ug-ml";
    }

    if (d1 === "µg/kg") {
      d1 = "u-kg";
    } else if (d1 === "mg/kg") {
      d1 = "mg-kg";
    } else if (d1 === "g/kg") {
      d1 = "g-kg";
    }

    if (w1 === "kg") {
      w1 = "kg";
    } else if (w1 === "lbs") {
      w1 = "lb";
    }

    if (!isNaN(w) && !isNaN(d)) {
      if (w1 === "lb") {
        w = w / 2.205;
      }

      if (d1 === "u-kg") {
        d = d / 1000;
      }

      if (d1 === "g-kg") {
        d = d * 1000;
      }

      if (mc1 === "mgl" || mc1 === "ug-ml") {
        mc = mc / 1000;
      }

      if (mc1 === "ugl") {
        mc = mc / 1000000;
      }

      let tdose = w * d;
      let gr = tdose / 1000;
      let ug = tdose * 1000;
      let dose;

      if (f != 1) {
        switch (f) {
          case "4h":
            dose = tdose / 6;
            break;
          case "3h":
            dose = tdose / 8;
            break;
          case "2h":
            dose = tdose / 12;
            break;
          case "h":
            dose = tdose / 24;
            break;
          default:
            dose = tdose / parseFloat(f);
        }
        param["tech_dose"] = dose;
      }

      if (!isNaN(mc)) {
        let lq_dose = tdose / mc;
        let g = lq_dose / 1000;

        param["tech_lq_dose"] = parseFloat(lq_dose.toFixed(2));
        param["tech_g"] = parseFloat(g.toFixed(2));

        if (f != 1) {
          let lq_dose1 = dose / mc;
          param["tech_lq_dose1"] = parseFloat(lq_dose1.toFixed(2));
        }
      }

      param["tech_tdose"] = parseFloat(tdose.toFixed(1));
      param["tech_ug"] = parseFloat(ug.toFixed(2));
      param["tech_gr"] = parseFloat(gr.toFixed(2));

      return param;
    } else {
      return { error: "Please fill all fields." };
    }
  }

  /**
   * getCalculationBraSizeCalculator: Service Method
   * POST: /api/calculators-lol/bra-size-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
       async  getCalculationBraSizeCalculator(body) {
        let bust = parseFloat(body.tech_bust);
        let unit = body.tech_unit?.trim();
        let band = parseFloat(body.tech_band);
        let unit1 = body.tech_unit1?.trim();
    
        let response = {};
    
        if (!isNaN(bust) && !isNaN(band)) {
            const sizes = {
                '0': ['AA', 'AA', 'AA', 'AA', 'AA'],
                '1': ['A', 'A', 'A', 'A', 'A'],
                '2': ['B', 'B', 'B', 'B', 'B'],
                '3': ['C', 'C', 'C', 'C', 'C'],
                '4': ['D', 'D', 'D', 'E', 'E'],
                '5': ['DD/E', 'DD', 'DD', 'F', 'F'],
                '6': ['DDD/F', 'E', 'E', 'G', 'G'],
                '7': ['DDDD/G', 'F', 'F', 'H', 'H'],
                '8': ['H', 'G', 'FF', 'J', 'J'],
                '9': ['I', 'H', 'G', 'K', 'K'],
                '10': ['J', 'I', 'GG', 'L', 'L'],
                '11': ['K', 'J', 'H', 'M', 'M'],
                '12': ['L', 'K', 'HH', 'O', 'O'],
                '13': ['M', 'L', 'J', 'P', 'P'],
                '14': ['N', 'M', 'JJ', 'Q', 'Q'],
                '15': ['O', 'N', 'K', 'S', 'S'],
                '16': ['P', 'O', 'KK', 'T', 'T'],
                '17': ['Q', 'P', 'L', 'U', 'U'],
                '18': ['R', 'Too big bust size', 'LL', 'V', 'V'],
                '19': ['Too big bust size', 'Too big bust size', 'Too big bust size', 'Y', 'Y'],
                '20': ['Too big bust size', 'Too big bust size', 'Too big bust size', 'Z', 'Z'],
            };
    
            let main_bust = bust;
            let main_band = band;
    
            if (unit === 'cm') bust = Math.round(bust / 2.54);
            if (unit1 === 'cm') band = Math.round(band / 2.54);
    
            let diff;
            if (band % 2 === 0) {
                diff = Math.round(bust) - Math.round(band);
            } else {
                band = band > main_band ? band - 1 : band + 1;
                diff = Math.round(bust) - Math.round(band);
            }
    
            if (band > bust) {
                response.error = 'Bust size must be greater than Band size.';
                return response;
            }
    
            let aus, eu, fr;
            if (band < 26) {
                band = aus = eu = fr = 'Band too small';
            } else {
                let diff1 = band - 26;
                aus = 4 + diff1;
                eu = 55 + (diff1 * 2.5);
                fr = 70 + (diff1 * 2.5);
            }
    
            let ans = diff > 20 ? 
                ['Too big bust size', 'Too big bust size', 'Too big bust size', 'Too big bust size', 'Too big bust size'] :
                sizes[diff] || ['Unknown', 'Unknown', 'Unknown', 'Unknown', 'Unknown'];
    
            response.tech_band = band;
            response.tech_aus = aus;
            response.tech_ans = ans;
            response.tech_eu = eu;
            response.tech_fr = fr;
        } else {
            response.error = 'Please Check Your Input.';
        }
    
        return response;
    }
    
     
  /**
   * getCalculationImplantationCalculator: Service Method
   * POST: /api/calculators-lol/implantation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationImplantationCalculator(body) {
    let know = body.tech_know;
    let ovd = body.tech_ovd;
    let lp = body.tech_lp;
    let mcl = body.tech_mcl;
    let ivf = body.tech_ivf;

    know = (know || "").trim();
    ovd = (ovd || "").trim();
    lp = (lp || "").trim();
    mcl = parseInt(mcl) || 0;
    ivf = (ivf || "").trim();

    let result = {};

    let ovulationDate;

    if (know === "yes" && ovd) {
      ovulationDate = moment(ovd);
    } else if (know === "no" && lp) {
      const days = mcl - 14;
      ovulationDate = moment(lp).add(days, "days");
    } else {
      result.error = "Please Check Your Input.";
      return result;
    }

    const formattedOvulationDate = ovulationDate.format("MMM DD, YYYY");

    let table = `<table className="w-full" cellspacing="0">
          <thead className="bggreen_implantation_calculator">
              <tr>
                  <td colspan="3" className="text-center border-2 radius-t-10 px-3 py-2">
                      Ovulation Date: "${formattedOvulationDate}"
                  </td>
              </tr>
              <tr>
                  <td className="radius-bl-10 px-3 py-2">Days Past Ovulation (DPO)</td>
                  <td className="px-3">Date</td>
                  <td className="radius-br-10 px-3">Probability of Implantation</td>
              </tr>
          </thead>
          <tbody>`;

    for (let i = 0; i < 17; i++) {
      const impDate = ovulationDate
        .clone()
        .add(i, "days")
        .format("MMM DD, YYYY");
      let cmnt = "";
      let clr = "";

      if (i === 0) {
        cmnt = "Ovulation";
        clr = "clr_0";
      } else if (i > 0 && i < 6) {
        cmnt = "Travel inside Fallopian tube";
        clr = "clr_1";
      } else if ((i > 5 && i < 9) || (i > 9 && i < 13)) {
        cmnt = "Implantation possible";
        clr = "clr_2";
      } else if (i === 9) {
        cmnt = "Implantation very possible";
        clr = "clr_3";
      } else if (i > 12 && i < 15) {
        cmnt = "Implantation unlikely";
        clr = "clr_1";
      } else {
        cmnt = "Missed Period: Pregnancy Test?";
        clr = "clr_4";
      }

      const border = i < 16 ? "border-b" : "";
      table += `<tr className='${clr}'><th className='text-start ${border} px-3 py-3'>${i} DPO</th><td className='${border} px-3'>${impDate}</td><td className='${border} px-3'>${cmnt}</td></tr>`;
    }

    table += "</tbody></table>";

    if (ivf) {
      const ivfDate = moment(ivf).add(5, "days").format("MMM DD, YYYY");
      result.tech_ivf = ivfDate;
    }

    result.tech_table = table;
    return result;
  }

  /**
   * getCalculationBloodTypeCalculator: Service Method
   * POST: /api/calculators-lol/blood-type-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationBloodTypeCalculator(body) {
    let op = body.tech_selection;
    let op1 = body.tech_c_unit;
    let op2 = body.tech_selection3;
    let op3 = body.tech_d_unit;

    let A = 0,
      B = 0,
      AB = 0,
      O = 0;
    let Rhpos = 0,
      Rhneg = 0;

    // Blood group logic
    if (op === "0" && op2 === "0") {
      A = 0;
      B = 0;
      AB = 0;
      O = 100;
    }
    if (op === "1" && op2 === "1") {
      A = 93.75;
      B = 0;
      AB = 0;
      O = 6.25;
    }
    if (op === "2" && op2 === "2") {
      A = 0;
      B = 93.75;
      AB = 0;
      O = 6.25;
    }
    if (op === "3" && op2 === "3") {
      A = 25;
      B = 25;
      AB = 50;
      O = 0;
    }
    if ((op === "0" && op2 === "1") || (op === "1" && op2 === "0")) {
      A = 75;
      B = 0;
      AB = 0;
      O = 25;
    }
    if ((op === "0" && op2 === "2") || (op === "2" && op2 === "0")) {
      A = 0;
      B = 75;
      AB = 0;
      O = 25;
    }
    if ((op === "0" && op2 === "3") || (op === "3" && op2 === "0")) {
      A = 50;
      B = 50;
      AB = 0;
      O = 0;
    }
    if ((op === "1" && op2 === "2") || (op === "2" && op2 === "1")) {
      A = 18.75;
      B = 18.75;
      AB = 56.25;
      O = 6.25;
    }
    if ((op === "1" && op2 === "3") || (op === "3" && op2 === "1")) {
      A = 50;
      B = 12.5;
      AB = 37.5;
      O = 0;
    }
    if ((op === "2" && op2 === "3") || (op === "3" && op2 === "2")) {
      A = 12.5;
      B = 50;
      AB = 37.5;
      O = 0;
    }

    // Rh factor logic
    if (op1 === "0" && op3 === "0") {
      Rhpos = 93.75;
      Rhneg = 6.25;
    }
    if ((op1 === "0" && op3 === "1") || (op1 === "1" && op3 === "0")) {
      Rhpos = 75;
      Rhneg = 25;
    }
    if (op1 === "1" && op3 === "1") {
      Rhpos = 0;
      Rhneg = 100;
    }

    return {
      tech_A: A,
      tech_B: B,
      tech_AB: AB,
      tech_O: O,
      tech_rhpos: Rhpos,
      tech_rhneg: Rhneg,
    };
  }

  /**
   * getCalculationMelatoninDosageCalculator: Service Method
   * POST: /api/calculators-lol/melatonin-dosage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMelatoninDosageCalculator(body) {
    let selection = body.tech_selection;
    let selection1 = body.tech_selection3;
    let units = body.tech_d_unit;
    let inputs = body.tech_charge;

    let unit;
    if (units === "days") {
      unit = 1;
    } else if (units === "weeks") {
      unit = 2;
    } else if (units === "months") {
      unit = 3;
    } else if (units === "years") {
      unit = 4;
    } else {
      unit = units; // in case it's already converted
    }

    let days,
      weeks,
      months,
      years,
      cn,
      drops,
      applications,
      tablets,
      strips,
      ml,
      ans2,
      ans3,
      ans4,
      ans1_second,
      ans1_third,
      ans1_four,
      tablet;

    if (isNaN(inputs) || inputs <= 0) {
      return { error: "Please! Enter value greater than 0." };
    }

    if (unit == 1) {
      days = "days";
      cn = inputs * 1;
    } else if (unit == 2) {
      weeks = "weeks";
      cn = inputs * 7;
    } else if (unit == 3) {
      months = "months";
      const cn1 = inputs * 30.44;
      const cn2 = cn1 + 0.4;
      cn = Math.round(cn2);
    } else if (unit == 4) {
      years = "years";
      const cn1 = inputs * 365.25;
      const cn2 = cn1 + 0.4;
      cn = Math.round(cn2);
    }

    let answer1, answer2, answer3, answer4, ans1, ans1_first;

    switch (selection) {
      case "1":
        answer1 = "0.3-5";
        answer2 = "Taken 1 h before sleep.";
        switch (selection1) {
          case "1":
            answer3 = "Number of tablets needed for a";
            tablets = "tablets";
            answer4 = inputs;
            ans1_first = cn * 5;
            const ans1_sec = ans1_first / 3;
            ans1_second = Math.round(ans1_sec + 0.4);
            ans1_third = cn;
            const ans1_four1 = ans1_first / 10;
            ans1_four = Math.round(ans1_four1 + 0.4);
            ans1 = "1 mg →";
            ans2 = "3 mg →";
            ans3 = "5 mg →";
            ans4 = "10 mg →";
            break;
          case "2":
            answer3 = "Volume needed for a";
            answer4 = inputs;
            drops = "drops";
            ml = "mL";
            ans1 = "1 mg/25ml →";
            ans1_first = cn * 125;
            ans1_second = ans1_first / 5;
            break;
          case "3":
            answer3 = "Number of spray applications needed for";
            answer4 = inputs;
            applications = "applications";
            ans1 = "0.5 mg/application →";
            ans1_first = cn * 10;
            break;
          case "4":
            answer3 = "Number of strips needed for";
            answer4 = inputs;
            strips = "strips";
            ans1 = "1 mg →";
            ans2 = "3 mg →";
            const ans1_first1 = cn * 5;
            ans1_first = Math.round(ans1_first1 + 0.4);
            const ans1_sec1 = ans1_first / 3;
            ans1_second = Math.round(ans1_sec1 + 0.4);
            break;
        }
        break;
      case "2":
        answer1 = "1-6";
        answer2 =
          "For eastbound flights (e.g., US to Europe) take melatonin for two days before the flight, around 7 PM. Continue taking melatonin for 4 days after arrival, right before going to bed.";
        switch (selection1) {
          case "1":
            answer3 = "Number of tablets needed for a";
            tablets = "tablets";
            answer4 = inputs;
            ans1_first = cn * 6;
            const ans1_sec = ans1_first / 3;
            ans1_second = Math.round(ans1_sec + 0.4);
            const ans1_third1 = ans1_first / 5;
            ans1_third = Math.round(ans1_third1 + 0.4);
            const ans1_four1 = ans1_first / 10;
            ans1_four = Math.round(ans1_four1 + 0.4);
            ans1 = "1 mg →";
            ans2 = "3 mg →";
            ans3 = "5 mg →";
            ans4 = "10 mg →";
            break;
          case "2":
            answer3 = "Volume needed for a";
            answer4 = inputs;
            drops = "drops";
            ml = "mL";
            ans1 = "1 mg/25ml →";
            ans1_first = cn * 150;
            ans1_second = ans1_first / 5;
            break;
          case "3":
            answer3 = "Number of spray applications needed for";
            answer4 = inputs;
            applications = "applications";
            ans1 = "0.5 mg/application →";
            ans1_first = cn * 12;
            break;
          case "4":
            answer3 = "Number of strips needed for";
            answer4 = inputs;
            strips = "strips";
            ans1 = "1 mg →";
            ans2 = "3 mg →";
            const ans1_first1 = cn * 6;
            ans1_first = Math.round(ans1_first1 + 0.4);
            const ans1_sec1 = ans1_first / 3;
            ans1_second = Math.round(ans1_sec1 + 0.4);
            break;
        }
        break;
      case "3":
        answer1 = "1-6";
        answer2 =
          "For westbound flights (e.g., Europe to the US) take melatonin for 4 days after arrival, right before going to bed.";
        switch (selection1) {
          case "1":
            answer3 = "Number of tablets needed for a";
            tablets = "tablets";
            answer4 = inputs;
            ans1_first = cn * 6;
            const ans1_sec = cn * 2;
            ans1_second = Math.round(ans1_sec + 0.4);
            const ans1_third1 = ans1_first / 5;
            ans1_third = Math.round(ans1_third1 + 0.4);
            const ans1_four1 = ans1_first / 10;
            ans1_four = Math.round(ans1_four1 + 0.4);
            ans1 = "1 mg →";
            ans2 = "3 mg →";
            ans3 = "5 mg →";
            ans4 = "10 mg →";
            break;
          case "2":
            answer3 = "Volume needed for a";
            answer4 = inputs;
            drops = "drops";
            ml = "mL";
            ans1 = "1 mg/25ml →";
            ans1_first = cn * 150;
            ans1_second = ans1_first / 5;
            break;
          case "3":
            answer3 = "Number of spray applications needed for";
            answer4 = inputs;
            applications = "applications";
            ans1 = "0.5 mg/application →";
            ans1_first = cn * 12;
            break;
          case "4":
            answer3 = "Number of strips needed for";
            answer4 = inputs;
            strips = "strips";
            ans1 = "1 mg →";
            ans2 = "3 mg →";
            const ans1_first1 = cn * 6;
            ans1_first = Math.round(ans1_first1 + 0.4);
            const ans1_sec1 = ans1_first / 3;
            ans1_second = Math.round(ans1_sec1 + 0.4);
            break;
        }
        break;
      case "4":
        answer1 = "0.5";
        answer2 = "Take melatonin around 9-10 PM, before going to sleep.";
        switch (selection1) {
          case "1":
            answer3 = "Number of tablets needed for a";
            tablet = "tablets";
            answer4 = inputs;
            const ans1_first1s = cn * 0.5;
            ans1_first = Math.round(ans1_first1s + 0.4);
            const ans1_sec = ans1_first / 3;
            ans1_second = Math.round(ans1_sec + 0.4);
            ans1 = "1 mg →";
            ans2 = "3 mg →";
            break;
          case "2":
            answer3 = "Volume needed for a";
            answer4 = inputs;
            drops = "drops";
            ml = "mL";
            ans1 = "1 mg/25ml →";
            ans1_first = cn * 12.5;
            ans1_second = cn * 2.5;
            break;
          case "3":
            answer3 = "Number of spray applications needed for";
            answer4 = inputs;
            applications = "applications";
            ans1 = "0.5 mg/application →";
            ans1_first = cn;
            break;
          case "4":
            answer3 = "Number of strips needed for";
            answer4 = inputs;
            strips = "strips";
            ans1 = "1 mg →";
            const ans1_first1 = cn * 0.5;
            ans1_first = Math.round(ans1_first1 + 0.4);
            break;
        }
        break;
      case "5":
        answer1 = "2.5";
        answer2 = "Taken daily, for up to 4 weeks.";
        switch (selection1) {
          case "1":
            answer3 = "Number of tablets needed for a";
            tablets = "tablets";
            answer4 = inputs;
            const ans1_first1d = cn * 2.5;
            ans1_first = Math.round(ans1_first1d + 0.4);
            const ans1_sec = ans1_first / 3;
            ans1_second = Math.round(ans1_sec + 0.4);
            const ans1_third1 = ans1_first / 5;
            ans1_third = Math.round(ans1_third1 + 0.4);
            const ans1_four1 = ans1_first / 10;
            ans1_four = Math.round(ans1_four1 + 0.4);
            ans1 = "1 mg →";
            ans2 = "3 mg →";
            ans3 = "5 mg →";
            ans4 = "10 mg →";
            break;
          case "2":
            answer3 = "Volume needed for a";
            answer4 = inputs;
            drops = "drops";
            ml = "mL";
            ans1 = "1 mg/25ml →";
            ans1_first = cn * 62.5;
            ans1_second = ans1_first / 5;
            break;
          case "3":
            answer3 = "Number of spray applications needed for";
            answer4 = inputs;
            applications = "applications";
            ans1 = "0.5 mg/application →";
            const ans1_first1e = cn * 5;
            ans1_first = Math.round(ans1_first1e + 0.4);
            break;
          case "4":
            answer3 = "Number of strips needed for";
            answer4 = inputs;
            strips = "strips";
            ans1 = "1 mg →";
            ans2 = "3 mg →";
            const ans1_first1 = cn * 2.5;
            ans1_first = Math.round(ans1_first1 + 0.4);
            const ans1_sec1 = ans1_first / 3;
            ans1_second = Math.round(ans1_sec1 + 0.4);
            break;
        }
        break;
      case "6":
        answer1 = "10";
        answer2 = "Taken daily, for up to 8 weeks.";
        switch (selection1) {
          case "1":
            answer3 = "Number of tablets needed for a";
            tablets = "tablets";
            answer4 = inputs;
            const ans1_first1 = cn * 10;
            ans1_first = Math.round(ans1_first1 + 0.4);
            const ans1_sec = ans1_first / 3;
            ans1_second = Math.round(ans1_sec + 0.4);
            const ans1_third1 = ans1_first / 5;
            ans1_third = Math.round(ans1_third1 + 0.4);
            const ans1_four1 = ans1_first / 10;
            ans1_four = Math.round(ans1_four1 + 0.4);
            ans1 = "1 mg →";
            ans2 = "3 mg →";
            ans3 = "5 mg →";
            ans4 = "10 mg →";
            break;
          case "2":
            answer3 = "Volume needed for a";
            answer4 = inputs;
            drops = "drops";
            ml = "mL";
            ans1 = "1 mg/25ml →";
            ans1_first = cn * 250;
            ans1_second = ans1_first / 5;
            break;
          case "3":
            answer3 = "Number of spray applications needed for";
            answer4 = inputs;
            applications = "applications";
            ans1 = "0.5 mg/application →";
            ans1_first = cn * 20;
            break;
          case "4":
            answer3 = "Number of strips needed for";
            answer4 = inputs;
            strips = "strips";
            ans1 = "1 mg →";
            ans2 = "3 mg →";
            const ans1_first111 = cn * 10;
            ans1_first = Math.round(ans1_first111 + 0.4);
            const ans1_sec1 = ans1_first / 3;
            ans1_second = Math.round(ans1_sec1 + 0.4);
            break;
        }
        break;
      default:
        return { error: "Invalid selection" };
    }

    return {
      tech_answer1: answer1,
      tech_answer2: answer2,
      tech_answer3: answer3,
      tech_answer4: answer4,
      tech_ans1: ans1,
      tech_ans2: ans2,
      tech_ans3: ans3,
      tech_ans4: ans4,
      tech_ans1_first: ans1_first,
      tech_ans1_second: ans1_second,
      tech_ans1_third: ans1_third,
      tech_ans1_four: ans1_four,
      tech_tablets: tablets,
      tech_tablet: tablet,
      tech_ml: ml,
      tech_drops: drops,
      tech_unit: unit,
      tech_applications: applications,
      tech_strips: strips,
      tech_cn: cn,
      tech_years: years,
      tech_days: days,
      tech_weeks: weeks,
      tech_months: months,
    };
  }

  /**
   * getCalculationProstateVolumeCalculator: Service Method
   * POST: /api/calculators-lol/prostate-volume-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationProstateVolumeCalculator(body) {
    let length = body.tech_length;
    let length_unit = body.tech_length_unit;
    let width = body.tech_width;
    let width_unit = body.tech_width_unit;
    let height = body.tech_height;
    let height_unit = body.tech_height_unit;
    let psa = body.tech_psa;

    // Unit conversion map
    const unitMap = {
      mm: 10,
      cm: 1,
      dm: 0.1,
      m: 0.01,
      km: 0.00001,
      mi: 0.000006213711922373,
      in: 0.3937007874016,
      ft: 0.03280839895013,
      yd: 0.01093613298338,
    };

    let result = {};

    // Convert to float
    length = parseFloat(length);
    width = parseFloat(width);
    height = parseFloat(height);
    psa = parseFloat(psa);

    if (!isNaN(length) && !isNaN(width) && !isNaN(height)) {
      let first = length * unitMap[length_unit];
      let second = width * unitMap[width_unit];
      let third = height * unitMap[height_unit];

      let div = Math.PI / 6;
      let div2 = (5 * Math.PI) / 24;

      let answer = first * second * third * div;
      let answer22 = first * second * third * div2;

      let answer2 = 0;
      let answer23 = 0;

      if (!isNaN(psa)) {
        if (psa !== 0) {
          answer2 = psa / answer;
          answer23 = psa / answer22;
        }
      }

      result.tech_answer = answer;
      result.tech_answer22 = answer22;
      result.tech_answer2 = answer2;
      result.tech_answer23 = answer23;
    } else {
      result.error = "Please! Check your input.";
    }

    return result;
  }

  /**
   * getCalculationDihybridcrossCalculator: Service Method
   * POST: /api/calculators-lol/dihybrid-cross-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDihybridcrossCalculator(body) {
    const mother1 = body.tech_mtype1 ? body.tech_mtype1.trim() : "";
    const mother2 = body.tech_mtype2 ? body.tech_mtype2.trim() : "";
    const father1 = body.tech_ftype1 ? body.tech_ftype1.trim() : "";
    const father2 = body.tech_ftype2 ? body.tech_ftype2.trim() : "";

    const result = {
      tech_table: "",
      tech_finalRes: null,
      tech_tablResults: [],
    };

    function isNumeric(value) {
      return /^\d+$/.test(value);
    }
    if (
      isNumeric(mother1) &&
      isNumeric(mother2) &&
      isNumeric(father1) &&
      isNumeric(father2)
    ) {
      let m1, m2, m3, m4;
      let f1, f2, f3, f4;

      // Mother's gametes
      if (mother1 === "0" && mother2 === "0") {
        m1 = m2 = m3 = m4 = "AB";
      } else if (mother1 === "0" && mother2 === "1") {
        m1 = m2 = "AB";
        m3 = m4 = "Ab";
      } else if (mother1 === "0" && mother2 === "2") {
        m1 = m2 = m3 = m4 = "Ab";
      } else if (mother1 === "1" && mother2 === "1") {
        m1 = "AB";
        m2 = "Ab";
        m3 = "aB";
        m4 = "ab";
      } else if (mother1 === "1" && mother2 === "0") {
        m1 = m2 = "AB";
        m3 = m4 = "aB";
      } else if (mother1 === "1" && mother2 === "2") {
        m1 = m2 = "Ab";
        m3 = m4 = "ab";
      } else if (mother1 === "2" && mother2 === "0") {
        m1 = m2 = m3 = m4 = "aB";
      } else if (mother1 === "2" && mother2 === "1") {
        m1 = m2 = "aB";
        m3 = m4 = "ab";
      } else if (mother1 === "2" && mother2 === "2") {
        m1 = m2 = m3 = m4 = "ab";
      }

      // Father's gametes
      if (father1 === "0" && father2 === "0") {
        f1 = f2 = f3 = f4 = "AB";
      } else if (father1 === "0" && father2 === "1") {
        f1 = f2 = "AB";
        f3 = f4 = "Ab";
      } else if (father1 === "0" && father2 === "2") {
        f1 = f2 = f3 = f4 = "Ab";
      } else if (father1 === "1" && father2 === "1") {
        f1 = "AB";
        f2 = "Ab";
        f3 = "aB";
        f4 = "ab";
      } else if (father1 === "1" && father2 === "0") {
        f1 = f2 = "AB";
        f3 = f4 = "aB";
      } else if (father1 === "1" && father2 === "2") {
        f1 = f2 = "Ab";
        f3 = f4 = "ab";
      } else if (father1 === "2" && father2 === "0") {
        f1 = f2 = f3 = f4 = "aB";
      } else if (father1 === "2" && father2 === "1") {
        f1 = f2 = "aB";
        f3 = f4 = "ab";
      } else if (father1 === "2" && father2 === "2") {
        f1 = f2 = f3 = f4 = "ab";
      }

      // Generate table
      result.tech_table = `<table className="dihybrid-cross-calculator" cellspacing="0">
              <tr>
                  <td className="border-b py-2"><b>♂️\\♀️</b></td>
                  <td className="border-b"><b>${m1}</b></td>
                  <td className="border-b py-2"><b>${m2}</b></td>
                  <td className="border-b"><b>${m3}</b></td>
                  <td className="border-b py-2"><b>${m4}</b></td>
              </tr>
              <tr>
                  <td className="border-b py-2"><b>${f1}</b></td>
                  <td className="border-b py-2">${m1[0]}${f1[0]}${m1[1]}${f1[1]}</td>
                  <td className="border-b py-2">${m2[0]}${f1[0]}${m2[1]}${f1[1]}</td>
                  <td className="border-b py-2">${m3[0]}${f1[0]}${m3[1]}${f1[1]}</td>
                  <td className="border-b py-2">${m4[0]}${f1[0]}${m4[1]}${f1[1]}</td>
              </tr>
              <tr>
                  <td className="border-b py-2"><b>${f2}</b></td>
                  <td className="border-b py-2">${m1[0]}${f2[0]}${m1[1]}${f2[1]}</td>
                  <td className="border-b py-2">${m2[0]}${f2[0]}${m2[1]}${f2[1]}</td>
                  <td className="border-b py-2">${m3[0]}${f2[0]}${m3[1]}${f2[1]}</td>
                  <td className="border-b py-2">${m4[0]}${f2[0]}${m4[1]}${f2[1]}</td>
              </tr>
              <tr>
                  <td className="border-b py-2"><b>${f3}</b></td>
                  <td className="border-b py-2">${m1[0]}${f3[0]}${m1[1]}${f3[1]}</td>
                  <td className="border-b py-2">${m2[0]}${f3[0]}${m2[1]}${f3[1]}</td>
                  <td className="border-b py-2">${m3[0]}${f3[0]}${m3[1]}${f3[1]}</td>
                  <td className="border-b py-2">${m4[0]}${f3[0]}${m4[1]}${f3[1]}</td>
              </tr>
              <tr>
                  <td className="py-2"><b>${f4}</b></td>
                  <td>${m1[0]}${f4[0]}${m1[1]}${f4[1]}</td>
                  <td>${m2[0]}${f4[0]}${m2[1]}${f4[1]}</td>
                  <td>${m3[0]}${f4[0]}${m3[1]}${f4[1]}</td>
                  <td>${m4[0]}${f4[0]}${m4[1]}${f4[1]}</td>
              </tr>
          </table>`;

      const tablMother = [parseInt(mother1), parseInt(mother2)];
      const tablFather = [parseInt(father1), parseInt(father2)];

      const tablProp = [
        [
          [1, 0.5, 0],
          [0.5, 0.25, 0],
          [0, 0, 0],
        ],
        [
          [0, 0.5, 1],
          [0.5, 0.5, 0.5],
          [1, 0.5, 0],
        ],
        [
          [0, 0, 0],
          [0, 0.25, 0.5],
          [0, 0.5, 1],
        ],
      ];

      for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
          result.tech_tablResults[3 * i + j] =
            tablProp[i][tablMother[0]][tablFather[0]] *
            tablProp[j][tablMother[1]][tablFather[1]];
        }
      }

      function getTablResults(mother1, father1, mother2, father2, idx) {
        const tablMother = [parseInt(mother1), parseInt(mother2)];
        const tablFather = [parseInt(father1), parseInt(father2)];
        const tablProp = [
          [
            [1, 0.5, 0],
            [0.5, 0.25, 0],
            [0, 0, 0],
          ],
          [
            [0, 0.5, 1],
            [0.5, 0.5, 0.5],
            [1, 0.5, 0],
          ],
          [
            [0, 0, 0],
            [0, 0.25, 0.5],
            [0, 0.5, 1],
          ],
        ];
        const tech_tablResults = [];
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            tech_tablResults[3 * i + j] =
              tablProp[i][tablMother[0]][tablFather[0]] *
              tablProp[j][tablMother[1]][tablFather[1]];
          }
        }
        return tech_tablResults[idx];
      }

      result.tech_finalRes = getTablResults(
        mother1,
        father1,
        mother2,
        father2,
        0
      );
    } else {
      result.error = "Please Check Your Input.";
    }

    return result;
  }

  /**
   * getCalculationHCGCalculator: Service Method
   * POST: /api/calculators-lol/hcg-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationHCGCalculator(body) {
    let first = parseFloat(body.tech_first);
    let second = parseFloat(body.tech_second);
    let third = parseFloat(body.tech_third);
    let unit3 = body.tech_unit3;

    function din(a, b) {
      if (a === "hours") {
        return b * 0.04167;
      } else if (a === "days") {
        return b * 1;
      } else {
        return 0; // fallback for unsupported units
      }
    }

    third = din(unit3, third);

    if (!isNaN(first) && !isNaN(second) && !isNaN(third)) {
      let difference = second - first;
      let pos = Math.abs(difference);
      let div1 = pos / first;
      let percent = div1 * 100;
      let div2 = second / first;
      let log = Math.log2(div2);
      let t2 = third / log;
      let hours = t2 * 24;
      let f_div = 24 / hours;
      let s_div = 48 / hours;
      let f_pow = Math.pow(2, f_div);
      let s_pow = Math.pow(2, s_div);
      let f_min = f_pow - 1;
      let s_min = s_pow - 1;
      let i1 = f_min * 100;
      let i2 = s_min * 100;

      return {
        tech_difference: difference,
        tech_percent: percent,
        tech_t2: t2,
        tech_i1: i1,
        tech_i2: i2,
      };
    } else {
      return {
        error: "Please! check your input.",
      };
    }
  }

  /**
   * getCalculationDressSizeCalculator: Service Method
   * POST: /api/calculators-lol/dress-size-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDressSizeCalculator(body) {
    let bust = Number(body.tech_bust);
    let waist = Number(body.tech_waist);
    let hips = Number(body.tech_hips);
    let response = {};

    function getUSSize(EuroSize) {
      if (EuroSize <= 30) return "00";
      else if (EuroSize <= 32) return "0";
      else if (EuroSize <= 34) return "2";
      else if (EuroSize <= 36) return "4";
      else if (EuroSize <= 38) return "6";
      else if (EuroSize <= 40) return "8";
      else if (EuroSize <= 42) return "10";
      else if (EuroSize <= 44) return "12";
      else if (EuroSize <= 46) return "14";
      else if (EuroSize <= 48) return "16";
      else if (EuroSize <= 50) return "18";
      else if (EuroSize <= 52) return "20";
      else if (EuroSize <= 54) return "22";
      else return "Not strictly determined";
    }

    function getUKSize(EuroSize) {
      if (EuroSize <= 30) return "2";
      else if (EuroSize <= 32) return "4";
      else if (EuroSize <= 34) return "6";
      else if (EuroSize <= 36) return "8";
      else if (EuroSize <= 38) return "10";
      else if (EuroSize <= 40) return "12";
      else if (EuroSize <= 42) return "14";
      else if (EuroSize <= 44) return "16";
      else if (EuroSize <= 46) return "18";
      else if (EuroSize <= 48) return "20";
      else if (EuroSize <= 50) return "22";
      else if (EuroSize <= 52) return "24";
      else if (EuroSize <= 54) return "26";
      else return "Not strictly determined";
    }

    function getInternationalSize(EuroSize) {
      if (EuroSize <= 30) return "XXS";
      else if (EuroSize <= 32) return "XS";
      else if (EuroSize <= 34) return "XS";
      else if (EuroSize <= 36) return "S";
      else if (EuroSize <= 38) return "S";
      else if (EuroSize <= 40) return "M";
      else if (EuroSize <= 42) return "M";
      else if (EuroSize <= 44) return "L";
      else if (EuroSize <= 46) return "L";
      else if (EuroSize <= 48) return "XL";
      else if (EuroSize <= 50) return "XL";
      else if (EuroSize <= 52) return "XXL";
      else if (EuroSize <= 54) return "XXL";
      else return "Not strictly determined";
    }

    if (bust && waist && hips) {
      if (bust === waist && waist === hips) {
        let euroSize = bust.toString();
        let usaSize = getUSSize(bust);
        let ukSize = getUKSize(bust);
        let internationalSize = getInternationalSize(bust);

        if (bust >= 56) {
          response.tech_firstText =
            "Sorry, we couldn't calculate a dress size based on your measurements. Check the catalog or manufacturer before buying your dress, or try it on if you can";
        } else {
          response.tech_usaSize = usaSize;
          response.tech_ukSize = ukSize;
          response.tech_euroSize = euroSize;
          response.tech_internationalSize = internationalSize;
        }
      } else {
        if (bust >= 56 || waist >= 56 || hips >= 56) {
          response.tech_firstText =
            "Sorry, we couldn't calculate a dress size based on your measurements. Check the catalog or manufacturer before buying your dress, or try it on if you can";
        } else {
          response.tech_secondText =
            "Looks like your measurements fall into different size categories (as shown in the table below). Check the <b>detailed dress size chart</b> in the article to assess which size should fit you best.";

          response.tech_usBust = getUSSize(bust);
          response.tech_usWaist = getUSSize(waist);
          response.tech_usHips = getUSSize(hips);

          response.tech_ukBust = getUKSize(bust);
          response.tech_ukWaist = getUKSize(waist);
          response.tech_ukHips = getUKSize(hips);

          response.tech_euBust = bust;
          response.tech_euWaist = waist;
          response.tech_euHips = hips;

          response.tech_internationalBust = getInternationalSize(bust);
          response.tech_internationalWaist = getInternationalSize(waist);
          response.tech_internationalHips = getInternationalSize(hips);
        }
      }
    } else {
      response.error = "Please check your input.";
    }

    return response;
  }

  /**
   * getCalculationTinettiCalculator: Service Method
   * POST: /api/calculators-lol/tinetti-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTinettiCalculator(body) {
    let a1 = Number(body.tech_a1);
    let a2 = Number(body.tech_a2);
    let a3 = Number(body.tech_a3);
    let a4 = Number(body.tech_a4);
    let a5 = Number(body.tech_a5);
    let a6 = Number(body.tech_a6);
    let a7 = Number(body.tech_a7);
    let a8 = Number(body.tech_a8);
    let a9 = Number(body.tech_a9);
    let a10 = Number(body.tech_a10);

    let b1 = Number(body.tech_b1);
    let b2 = Number(body.tech_b2);
    let b3 = Number(body.tech_b3);
    let b4 = Number(body.tech_b4);
    let b5 = Number(body.tech_b5);
    let b6 = Number(body.tech_b6);
    let b7 = Number(body.tech_b7);
    let b8 = Number(body.tech_b8);
    let b9 = Number(body.tech_b9);
    let b10 = Number(body.tech_b10);

    let add1 = a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10;
    let add2 = b1 + b2 + b3 + b4 + b5 + b6 + b7 + b8 + b9 + b10;
    let add3 = add1 + add2;

    return {
      tech_add1: add1,
      tech_add2: add2,
      tech_add3: add3,
    };
  }

  /**
   * getCalculationDripRateCalculator: Service Method
   * POST: /api/calculators-lol/drip-rate-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDripRateCalculator(body) {
    let result = {};

    let v = Number(body.tech_v);
    let v_unit = body.tech_v_unit.replace("@", "");
    let t = Number(body.tech_t);
    let t_unit = body.tech_t_unit;
    let dp = Number(body.tech_dp);
    let dp_unit = body.tech_dp_unit.replace("@", "");
    let type = body.tech_type;

    let d = Number(body.tech_d);
    let d_unit = body.tech_d_unit;
    let bw = Number(body.tech_bw);
    let bw_unit = body.tech_bw_unit;
    let bv = Number(body.tech_bv);
    let bv_unit = body.tech_bv_unit;
    let drug = Number(body.tech_drug);
    let drug_unit = body.tech_drug_unit;

    // Volume units
    let v_units = {
      "mm³": 0.001,
      "cm³": 1,
      "dm³": 1000,
      ml: 1,
      cl: 10,
      l: 1000,
    };
    v_unit = v_units[v_unit] || 1;

    // Time units
    let t_units = {
      sec: 0.0166667,
      min: 1,
      hrs: 60,
    };
    t_unit = t_units[t_unit] || 1;

    // Dose units
    let d_units = {
      "mg/kg/min": 0.0166667,
      "mg/oz/min": 35.274,
      "mg/lb/min": 0.15747, // used only the last one from PHP (duplicate key bug in PHP code)
    };
    d_unit = d_units[d_unit] || 1;

    // Body weight units
    let bw_units = {
      kg: 1,
      oz: 0.02835,
      lbs: 0.4536,
      stone: 6.35,
    };
    bw_unit = bw_units[bw_unit] || 1;

    // Bag volume units
    let bv_units = {
      ml: 1,
      cl: 10,
      l: 1000,
    };
    bv_unit = bv_units[bv_unit] || 1;

    // Drug units
    let drug_units = {
      µg: 0.001,
      mg: 1,
      g: 1000,
    };
    drug_unit = drug_units[drug_unit] || 1;

    // Drip units
    let dp_units = {
      "gtts/mm³": 1000,
      "gtts/cm³": 1,
      "gtts/ml": 1,
    };
    dp_unit = dp_units[dp_unit] || 1;

    if (type === "first") {
      if (v > 0 && t > 0 && dp > 0) {
        let v_val = v * v_unit;
        let t_val = t * t_unit;
        let dp_val = dp * dp_unit;

        let dpm = (v_val * dp_val) / t_val;
        let dph = (v_val * dp_val) / (t_val / 60);
        let dr = dph / dp_val;

        result.tech_dpm = dpm;
        result.tech_dph = dph;
        result.tech_dr = dr;
      } else {
        return { error: "Please! Check Your Input." };
      }
    } else if (type === "second") {
      if (d > 0 && bw > 0 && bv > 0 && drug > 0 && dp > 0) {
        let d_val = d * d_unit;
        let bw_val = bw * bw_unit;
        let bv_val = bv * bv_unit;
        let drug_val = drug * drug_unit;
        let dp_val = dp * dp_unit;

        if (bw_val > 0 && bw_val < 300) {
          let dr =
            ((((60 * d_val) / 1000) * bw_val * bv_val) / (1000 * drug_val)) *
            1000000;
          let concentration = (drug_val / bv_val) * 1000;
          let time_to_bag = (d_val * bw_val * 60) / drug_val;
          let flow_rate = dr * dp_val;

          result.tech_concentration = concentration;
          result.tech_time_to_bag = time_to_bag;
          result.tech_flow_rate = flow_rate;
          result.tech_dr = dr;
        } else {
          return {
            error: "Body weight must be greater than 0 and less than 300 kg.",
          };
        }
      } else {
        return { error: "Please! Check Your Input." };
      }
    }

    result.tech_type = type;
    return result;
  }

  /**
   * getCalculationStepstoCaloriesCalculator: Service Method
   * POST: /api/calculators-lol/steps-to-calories-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationStepstoCaloriesCalculator(body) {
    let weight = body.tech_weight;
    let w_unit = body.tech_w_unit;
    let height_ft = body.tech_height_ft;
    let height_in = body.tech_height_in;
    let height_cm = body.tech_height_cm;
    let steps = body.tech_steps;
    let speed = body.tech_speed;
    let h_unit = body.tech_unit_ft_in;

    // Helper
    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }
    // Weight conversion
    if (w_unit === "kg") {
      w_unit = 1;
    } else if (w_unit === "lbs") {
      w_unit = 2;
    } else if (w_unit === "stone") {
      w_unit = 3;
    }

    function convertWeight(unit, value) {
      if (unit === 1) return value * 1;
      if (unit === 2) return value * 0.4536;
      if (unit === 3) return value * 6.35;
      return null;
    }

    weight = convertWeight(w_unit, weight);

    let convert_height;

    if (h_unit === "ft/in") {
      if (isNumeric(height_ft) || isNumeric(height_in)) {
        convert_height = height_ft * 12 + (height_in || 0);
      } else {
        return { error: "Please! Check your input." };
      }
    } else if (h_unit === "cm") {
      if (isNumeric(height_cm)) {
        convert_height = height_cm / 2.54;
      } else {
        return { error: "Please! Check your input." };
      }
    } else if (h_unit === "ft") {
      if (isNumeric(height_cm)) {
        convert_height = height_cm * 12;
      } else {
        return { error: "Please! Check your input." };
      }
    } else if (h_unit === "in") {
      if (isNumeric(height_cm)) {
        convert_height = height_cm * 1;
      } else {
        return { error: "Please! Check your input." };
      }
    } else if (h_unit === "m") {
      if (isNumeric(height_cm)) {
        convert_height = height_cm * 39.37;
      } else {
        return { error: "Please! Check your input." };
      }
    }

    if (isNumeric(weight) && isNumeric(steps)) {
      if (weight >= 15) {
        if (convert_height >= 50) {
          let text, sp;

          if (speed === 0.9) {
            text = "2 miles/hour (3.2 km/h)";
            sp = 2.8;
          } else if (speed === 1.34) {
            text = "3 miles/hour (4.8 km/h)";
            sp = 3.5;
          } else if (speed === 1.79) {
            text = "4 miles/hour (6.4 km/h)";
            sp = 5;
          } else {
            return { error: "Invalid speed value." };
          }

          const distance = steps / 2000;
          const waqat = distance / sp;
          let time = Math.round(waqat * 60);
          const cal_burn = time * 3.5 * sp * (weight / 200);
          const cal_per = cal_burn / steps;

          const main_text =
            `<p className="mt-1">Taking ${steps} steps at this pace taesk about ${time} minutes</p>` +
            `<p className="mt-1">In some cases, taking <b>the same amount of steps at a slower pace may burn more calories</b>. However, they will be burned over a longer period of time, and most of the calories burnt are just so the body can maintain itself <b>(basal metabolism), not from the exercise!</b></p>` +
            `<p><b>Example:</b> An average man, walking at a normal pace, will take 7,000 steps in 1 hour, and he will burn 260 kcal. For a person who walks slowly, taking the same amount of steps will take 1.5 hrs, and will burn approx. 300 kcal (however this person will be burning 200 kcal per hour).</p>`;

          return {
            tech_cal_burn: cal_burn,
            tech_cal_per: cal_per,
            tech_main_text: main_text,
            tech_text: text,
          };
        } else {
          return {
            error: "This calculator is intended for those 50 cm or taller.",
          };
        }
      } else {
        return {
          error: "This calculator is intended for those 15 kg or heavier.",
        };
      }
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /**
   * getCalculationCholesterolRatioCalculator: Service Method
   * POST: /api/calculators-lol/cholesterol-ratio-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCholesterolRatioCalculator(body) {
    let tc = body.tech_tc;
    let tc_unit = body.tech_tc_unit;
    let hc = body.tech_hc;
    let hc_unit = body.tech_hc_unit;
    let lc = body.tech_lc;
    let lc_unit = body.tech_lc_unit;
    let tr = body.tech_tr;
    let tr_unit = body.tech_tr_unit;
    let gender = body.tech_gender;

    let param = {};

    // Convert units to mg/dL
    tc_unit = tc_unit === "mmol/L" ? 38.67 : 1;
    hc_unit = hc_unit === "mmol/L" ? 38.67 : 1;
    lc_unit = lc_unit === "mmol/L" ? 38.67 : 1;
    tr_unit = tr_unit === "mmol/L" ? 88.57 : 1;

    // Ensure values are numbers
    tc = parseFloat(tc);
    hc = parseFloat(hc);
    lc = parseFloat(lc);
    tr = parseFloat(tr);

    let ans1, ans2, ans3, ans4, ans5, ans6;

    if (!isNaN(tc) && !isNaN(hc) && !isNaN(lc) && isNaN(tr)) {
      if (tc > 0 && hc > 0 && lc > 0) {
        tc *= tc_unit;
        hc *= hc_unit;
        lc *= lc_unit;
        ans1 = tc / hc;
        ans2 = lc / hc;
        ans3 = tc;
        ans4 = hc;
        ans5 = lc;
        ans6 = (tc - hc - lc) * 5;
      } else {
        param.error = "Please! Enter Positive Value.";
        return param;
      }
    } else if (!isNaN(tc) && !isNaN(hc) && !isNaN(tr) && isNaN(lc)) {
      if (tc > 0 && hc > 0 && tr > 0) {
        tc *= tc_unit;
        hc *= hc_unit;
        tr *= tr_unit;
        ans3 = tc;
        ans4 = hc;
        ans5 = tc - hc - 0.2 * tr;
        ans2 = ans5 / hc;
        ans1 = tc / hc;
        ans6 = tr;
      } else {
        param.error = "Please! Enter Positive Value.";
        return param;
      }
    } else if (!isNaN(hc) && !isNaN(lc) && !isNaN(tr) && isNaN(tc)) {
      if (hc > 0 && lc > 0 && tr > 0) {
        hc *= hc_unit;
        lc *= lc_unit;
        tr *= tr_unit;
        ans3 = hc + lc + 0.2 * tr;
        ans1 = ans3 / hc;
        ans2 = lc / hc;
        ans4 = hc;
        ans5 = lc;
        ans6 = tr;
      } else {
        param.error = "Please! Enter Positive Value.";
        return param;
      }
    } else if (!isNaN(tc) && !isNaN(lc) && !isNaN(tr) && isNaN(hc)) {
      if (tc > 0 && lc > 0 && tr > 0) {
        tc *= tc_unit;
        lc *= lc_unit;
        tr *= tr_unit;
        ans3 = tc;
        ans4 = tc - lc - 0.2 * tr;
        ans5 = lc;
        ans6 = tr;
        ans2 = lc / ans4;
        ans1 = tc / ans4;
      } else {
        param.error = "Please! Enter Positive Value.";
        return param;
      }
    } else {
      param.error = "Please! Enter Only Three Values or Check your input.";
      return param;
    }

    return {
      tech_ans1: ans1,
      tech_ans2: ans2,
      tech_ans3: ans3,
      tech_ans4: ans4,
      tech_ans5: ans5,
      tech_ans6: ans6,
      tech_gender: gender,
    };
  }

  /**
   * getCalculationParacetamolDosageCalculator: Service Method
   * POST: /api/calculators-lol/paracetamol-dosage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationParacetamolDosageCalculator(body) {
    let age = body.tech_age;
    let age_unit = body.tech_age_unit;
    let weight = body.tech_weight;
    let weight_unit = body.tech_weight_unit;
    let ss = body.tech_ss;
    let med_type = body.tech_med_type;
    let param = {};

    // Convert age_unit to years
    if (age_unit === "weeks") age_unit = 0.0191651;
    else if (age_unit === "months") age_unit = 0.08333;
    else if (age_unit === "years") age_unit = 1;

    // Convert weight_unit to kg
    if (weight_unit === "kg") weight_unit = 1;
    else if (weight_unit === "lbs") weight_unit = 0.453592;

    if (["1", "2", "3"].includes(med_type)) {
      if (!isNaN(weight)) {
        const weight_val = weight * weight_unit;
        let dose;

        if (["1", "2"].includes(med_type)) {
          if (weight_val >= 5 && weight_val <= 7) dose = 4;
          else if (weight_val >= 8 && weight_val < 10) dose = 5;
          else if (weight_val >= 11 && weight_val <= 14) dose = 6;
          else if (weight_val >= 15 && weight_val <= 19) dose = 9;
          else if (weight_val >= 20 && weight_val <= 24) dose = 12;
          else if (weight_val >= 25 && weight_val <= 29) dose = 15;
          else if (weight_val >= 30 && weight_val <= 34) dose = 18;
          else if (weight_val >= 35 && weight_val <= 39) dose = 21;
          else if (weight_val >= 40 && weight_val <= 44) dose = 25;
          else if (weight_val <= 0) {
            param.error = "Child weight should be a positive number.";
            return param;
          } else if (weight_val > 100) {
            param.error =
              "The maximum value for a child weight is 100 kg or 220 lb.";
            return param;
          }
        } else if (med_type === "3") {
          if (weight_val >= 35 && weight_val <= 49) dose = 1;
          else if (weight_val >= 50 && weight_val <= 64) dose = 1.5;
          else if (weight_val >= 65 && weight_val <= 100) dose = 2;
          else if (weight_val <= 0) {
            param.error = "Child weight should be a positive number.";
            return param;
          } else if (weight_val > 100) {
            param.error =
              "The maximum value for a child weight is 100 kg or 220 lb.";
            return param;
          }
        }

        if (age !== "") {
          if (!isNaN(age)) {
            const age_val = age * age_unit;
            if (med_type === "1") {
              if (age_val < 1) {
                param.error =
                  "Infant syrup is not suitable for children under the age of 2 months. Consult a doctor for individualised dosing scheme.";
                return param;
              } else if (age_val > 6) {
                param.error =
                  "For children older than 6 years, try <i>Six plus syrup</i>.";
                return param;
              }
            } else if (med_type === "2") {
              if (age_val < 6) {
                param.error =
                  "Six plus syrup is not suitable for children under the age of 6 years. Try Infant syrup.";
                return param;
              }
            } else if (med_type === "3") {
              if (age_val < 6) {
                param.error =
                  "Tablets not suitable for children under the age of 6 years. Try Infant syrup.";
                return param;
              }
            }
          } else {
            param.error = "Please! Check your input.";
            return param;
          }
        }

        if (["1", "2"].includes(med_type)) {
          if (
            (weight_val >= 45 && weight_val <= 100) ||
            (weight_val >= 1 && weight_val <= 4)
          ) {
            param.tech_line =
              "The form of medication is not suitable for chosen weight. Try a different type or consult a physician.";
          } else {
            param.tech_dose = med_type === "1" ? dose : dose / 2;
          }
        } else if (med_type === "3") {
          if (weight_val <= 34) {
            param.tech_line =
              "The form of medication is not suitable for chosen weight. Try a different type or consult a physician.";
          } else {
            param.tech_dose = dose;
          }
        }

        const fifteen = weight_val * 15;
        const sixty = weight_val * 60;

        param.tech_fifteen = fifteen > 1000 ? 1000 : fifteen;
        param.tech_sixty = sixty > 4000 ? 4000 : sixty;
      } else {
        param.error = "Please! Check your input.";
        return param;
      }
    } else if (med_type === "4") {
      if (!isNaN(weight) && !isNaN(ss)) {
        const weight_val = weight * weight_unit;

        if (weight <= 0) {
          param.error = "Child weight should be a positive number.";
          return param;
        } else if (weight > 100) {
          param.error =
            "The maximum value for a child weight is 100 kg or 220 lb.";
          return param;
        }

        if (ss < 0) {
          param.error = "Solution strength should be a positive number.";
          return param;
        } else {
          if (age !== "") {
            if (age < 0) {
              param.error =
                "The Infant/Child Age should be a whole (integer) number!";
              return param;
            } else if (age >= 18) {
              param.error =
                "Please note the infant/child age you specified is over 18 years. This calculator is suitable for infant/child age below 18 years of age.";
              return param;
            } else {
              param.tech_fifteen = weight_val * 15;
              param.tech_sixty = weight_val * 60;
              param.tech_solution_amount = param.tech_fifteen / ss;
            }
          }
        }
      } else {
        param.error = "Please! Check your input.";
        return param;
      }
    }

    param.tech_med_type = med_type;
    return param;
  }

  /**
   * getCalculationAmoxicillinPediatricDosageCalculator: Service Method
   * POST: /api/calculators-lol/amoxicillin-pediatric-dosage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAmoxicillinPediatricDosageCalculator(body) {
    let age = body.tech_age;
    let age_unit = body.tech_age_unit;
    let weight = body.tech_weight;
    let weight_unit = body.tech_weight_unit;
    let med_type = body.tech_med_type;
    let general_dosing = body.tech_general_dosing;
    let route = body.tech_route;
    let dosag = body.tech_dosag;

    let param = {};

    // Age unit conversion
    let ageConversion;
    if (age_unit === "Weeks") {
      ageConversion = 0.019165;
    } else if (age_unit === "Months") {
      ageConversion = 0.08333;
    } else if (age_unit === "Years") {
      ageConversion = 1;
    }

    // Weight unit conversion
    let weightConversion;
    if (weight_unit === "kg") {
      weightConversion = 1;
    } else if (weight_unit === "lbs") {
      weightConversion = 0.453592;
    } else if (weight_unit === "stone") {
      weightConversion = 6.35;
    }

    if (isNaN(weight)) {
      param.error = "Please! Check your input.";
      return param;
    }
    let weightVal = weight * weightConversion;

    // Age check
    if (age !== "") {
      if (isNaN(age)) {
        param.error = "Please! Check your input.";
        return param;
      }
      let ageVal = age * ageConversion;
      if (ageVal <= 0 || ageVal > 18) {
        param.error = "Please Enter Age Between 1 and 18.";
        return param;
      }
    }

    // Weight check
    if (weight <= 0) {
      param.error = "Weight must be greater than 0.";
      return param;
    } else if (weight >= 100) {
      param.error = "Weight cannot exceed 100 kg (220 lb).";
      return param;
    }

    let inMm, inMilli;

    // General dosing calculations
    if (general_dosing === "1") {
      let inMmValue = weightVal * 15;
      if (med_type === "1") {
        inMilli = inMmValue / 25;
      } else if (med_type === "2") {
        inMilli = inMmValue / 50;
      } else if (med_type === "3") {
        inMilli = inMmValue / 40;
      } else if (med_type === "4") {
        inMilli = inMmValue / 80;
      }
      if (route === "1") {
        inMm = inMmValue;
        inMilli = inMilli;
      } else if (route === "2") {
        inMm = inMmValue * 2;
        inMilli = inMilli * 2;
      }
    } else if (general_dosing === "2") {
      let inMmValue =
        weightVal < 15
          ? weightVal * 50
          : weight < 30
          ? 750
          : weight < 100
          ? 1000
          : 0;
      inMilli = inMmValue / 25;
      if (med_type === "2") {
        inMilli = inMmValue / 50;
      } else if (med_type === "3") {
        inMilli = inMmValue / 40;
      } else if (med_type === "4") {
        inMilli = inMmValue / 80;
      }
    } else if (general_dosing === "3") {
      let inMmValue = weightVal * 50;
      if (med_type === "1") {
        inMilli = inMmValue / 25;
      } else if (med_type === "2") {
        inMilli = inMmValue / 50;
      } else if (med_type === "3") {
        inMilli = inMmValue / 40;
      } else if (med_type === "4") {
        inMilli = inMmValue / 80;
      }
    }

    param.tech_in_mm = inMm;
    param.tech_in_milli = inMilli;
    param.tech_general_dosing = general_dosing;
    param.tech_route = route;
    param.tech_dosag = dosag;
    param.tech_w_val = weightVal;

    return param;
  }

  /**
   * getCalculationHarrisBenedictCalculator: Service Method
   * POST: /api/calculators-lol/harris-benedict-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationHarrisBenedictCalculator(body) {
    let age = body.tech_age;
    let weight = body.tech_weight;
    let height_ft = body.tech_height_ft;
    let height_in = body.tech_height_in;
    let height_cm = body.tech_height_cm;
    let unit = body.tech_unit;
    let gender = body.tech_gender;
    let activity = body.tech_activity;
    let unit_h = body.tech_unit_ft_in;

    if (
      isFinite(age) &&
      isFinite(weight) &&
      (isFinite(height_ft) || isFinite(height_in) || isFinite(height_cm))
    ) {
      // Weight Conversion
      if (unit === "lbs") {
        weight = weight / 2.205;
      } else if (unit === "stone") {
        weight = weight * 6.35;
      } else if (unit === "kg") {
        weight = weight * 1;
      }

      // Height Conversion
      if (unit_h === "ft/in") {
        height_cm = height_ft * 30.48;
        if (height_in != null) {
          height_cm += height_in * 2.54;
        }
      } else if (unit_h === "ft") {
        height_cm = height_cm * 30.48;
      } else if (unit_h === "in") {
        height_cm = height_cm * 2.54;
      } else if (unit_h === "cm") {
        height_cm = height_cm * 1;
      } else if (unit_h === "m") {
        height_cm = height_cm * 100;
      }

      let bmr_ans;
      if (gender === "female") {
        bmr_ans = Math.round(
          665.1 + 9.563 * weight + 1.85 * height_cm - 4.676 * age
        );
      } else {
        bmr_ans = Math.round(
          66.5 + 13.75 * weight + 5.003 * height_cm - 6.75 * age
        );
      }

      const pro = 15;
      const fats = 30;
      const carb = 55;

      const tee = activity * bmr_ans;
      const cal_gram = tee * 0.129598;

      const pro_gram_ans = Math.round(((pro / 100) * tee) / 4);
      const carb_gram_ans = Math.round(((carb / 100) * tee) / 4);
      const fats_gram_ans = Math.round(((fats / 100) * tee) / 4);

      const sum = pro_gram_ans + carb_gram_ans + fats_gram_ans;

      const pro_per = Math.round((pro_gram_ans / sum) * 100);
      const carb_per = Math.round((carb_gram_ans / sum) * 100);
      const fats_per = Math.round((fats_gram_ans / sum) * 100);

      return {
        tech_bmr_ans: bmr_ans,
        tech_tee: tee,
        tech_pro_gram_ans: pro_gram_ans,
        tech_carb_gram_ans: carb_gram_ans,
        tech_fats_gram_ans: fats_gram_ans,
        tech_pro_per: pro_per,
        tech_carb_per: carb_per,
        tech_fats_per: fats_per,
      };
    } else {
      return {
        error: "Please! Check your input.",
      };
    }
  }

  /**
   * getCalculationCaloriesBurnedBikingCalculator: Service Method
   * POST: /api/calculators-lol/calories-burned-biking-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCaloriesBurnedBikingCalculator(body) {
    let operations = body.tech_operations;
    let activity = body.tech_activity;
    let first = body.tech_first;
    let units1 = body.tech_units1;
    let second = body.tech_second;
    let units2 = body.tech_units2;
    let third = body.tech_third;
    let units3 = body.tech_units3;
    let met = body.tech_met;
    let height_ft = body.tech_height_ft;
    let height_in = body.tech_height_in;
    let height_cm = body.tech_height_cm;
    let unit_ft_in = body.tech_unit_ft_in;
    let gender = body.tech_gender;
    let age = body.tech_age;

    // Unit conversion: Power
    const power = (unit, value) => {
      switch (unit) {
        case "mW":
          return value / 1000;
        case "W":
          return value;
        case "kW":
          return value * 1000;
        case "BTU/h":
          return value * 0.2931;
        case "hp(l)":
          return value * 745.7;
        case "kcal/min":
          return value * 69.73;
        case "kcal/h":
          return value * 1.1622;
        default:
          return null;
      }
    };

    // Unit conversion: Weight
    const weight = (unit, value) => {
      switch (unit) {
        case "lbs":
          return value / 2.205;
        case "kg":
          return value;
        case "stone":
          return value * 6.35;
        default:
          return null;
      }
    };

    // Unit conversion: Time
    const time2 = (unit, value) => {
      switch (unit) {
        case "sec":
          return value / 3600;
        case "min":
          return value / 60;
        case "hrs":
          return value;
        case "days":
          return value * 16;
        default:
          return null;
      }
    };

    first = power(units1, first);
    second = weight(units2, second);
    third = time2(units3, third);

    if (isNaN(second) || (!height_ft && !height_in && !height_cm)) {
      return { error: "Please! Check your input." };
    }

    // Convert height to cm
    if (unit_ft_in === "ft/in") {
      height_cm = height_ft * 30.48;
      if (height_in) {
        height_cm += height_in * 2.54;
      }
    } else if (unit_ft_in === "ft") {
      height_cm *= 30.48;
    } else if (unit_ft_in === "in") {
      height_cm *= 2.54;
    } else if (unit_ft_in === "m") {
      height_cm *= 100;
    } else if (unit_ft_in === "cm") {
      height_cm = height_cm;
    }

    // BMR Calculation
    let bmr_ans;
    if (gender === "female") {
      bmr_ans = Math.round(
        665.1 + 9.563 * second + 1.85 * height_cm - 4.676 * age
      );
    } else {
      bmr_ans = Math.round(
        66.5 + 13.75 * second + 5.003 * height_cm - 6.75 * age
      );
    }

    let calories, w_loss;

    if (operations === "Yes") {
      if (!isNaN(first) && !isNaN(third)) {
        calories = (first * third) / 4.18 / 0.24;
        w_loss = calories / 7700;
      } else {
        return { error: "Please! Check your input." };
      }
    } else if (operations === "No") {
      if (!isNaN(second) && !isNaN(met) && !isNaN(third)) {
        calories = (third * 60 * met * 3.5 * second) / 200;
        w_loss = calories / 7700;
      } else {
        return { error: "Please! Check your input." };
      }
    }

    const exercise = met * third;

    return {
      tech_bmr_ans: bmr_ans,
      tech_calories: calories,
      tech_w_loss: w_loss,
      tech_exercise: exercise,
    };
  }

  /**
   * getCalculationTreadmillCalorieCalculator: Service Method
   * POST: /api/calculators-lol/treadmill-calorie-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTreadmillCalorieCalculator(body) {
    let gradient = body.tech_gradient;
    let weight = body.tech_weight;
    let weight_unit = body.tech_weight_unit;
    let speed = body.tech_speed;
    let speed_unit = body.tech_speed_unit;
    let distance = body.tech_distance;
    let distance_unit = body.tech_distance_unit;
    let time = body.tech_time;

    let result = {};

    if (gradient < -0.001) {
      result.error = "Please input the gradient above 0.";
      return result;
    }
    if (speed < 0) {
      result.error = "Please input the speed above 0.";
      return result;
    }
    if (time < 0) {
      result.error = "Please input the running-time(min) above 0.";
      return result;
    }
    if (distance < 0) {
      result.error = "Please input the running-distance(Mile/Km) above 0.";
      return result;
    }
    if (weight < 0) {
      result.error = "Please input the weight(lbs/Kg) above 0.";
      return result;
    }

    if (
      typeof speed === "number" &&
      typeof distance === "number" &&
      typeof time === "number"
    ) {
      result.error =
        "Speed, Time, and the Distance cannot be specified at the same time.";
      return result;
    }

    if (
      (!speed && !distance && !time) ||
      (!distance && !time) ||
      (!speed && !time) ||
      (!distance && !speed)
    ) {
      result.error = "Please! Check your Input.";
      return result;
    }

    if (typeof gradient === "number" && typeof weight === "number") {
      let speed_mph, speed_kmh, distance_m, distance_km, time_ans;

      if (typeof speed === "number" && typeof distance === "number") {
        if (speed_unit === "km/h" || distance_unit === "km") {
          speed_mph = speed / 1.609;
          distance_m = distance / 1.609;
          speed_kmh = speed;
          distance_km = distance;
        } else {
          speed_kmh = speed * 1.609;
          distance_km = distance * 1.609;
          speed_mph = speed;
          distance_m = distance;
        }
        time_ans = (distance_m / speed_mph) * 60;
      } else if (typeof speed === "number" && typeof time === "number") {
        if (speed_unit === "km/h") {
          speed_mph = speed / 1.609;
          speed_kmh = speed;
        } else {
          speed_kmh = speed * 1.609;
          speed_mph = speed;
        }
        time_ans = time / 60;
        distance_m = speed_mph * time_ans;
        distance_km = distance_m * 1.609;
      } else if (typeof distance === "number" && typeof time === "number") {
        if (distance_unit === "km") {
          distance_m = distance / 1.609;
          distance_km = distance;
        } else {
          distance_km = distance * 1.609;
          distance_m = distance;
        }
        time_ans = time / 60;
        speed_mph = distance_m / time_ans;
        speed_kmh = speed_mph * 1.609;
      }

      let weight_kg = weight_unit === "lbs" ? weight / 2.205 : weight;
      let speed_mph_sec = speed_mph + (speed_mph * gradient * 9) / 200;
      let speed_kmh_sec = speed_kmh + (speed_kmh * gradient * 9) / 200;
      let distance_m_sec = (speed_mph_sec * time_ans) / 60;
      let distance_km_sec = (speed_kmh_sec * time_ans) / 60;
      let y0 = speed_kmh + (speed_kmh * gradient * 9) / 200;

      let cal = (((y0 * 1000) / 60 + 17.5) * time_ans * weight_kg) / 1000;
      let fat = cal / 7 / 2;
      let fatoz_ans = fat / 28.3495;
      let fatg_ans = fat;
      let mets = (cal / weight_kg / time_ans) * 60;
      let energy_kj = 4.184 * cal;
      let energy_kw_ans = energy_kj / 3600;
      let electric_heater_ans = 60 * energy_kw_ans;
      let light_bulb_ans = (electric_heater_ans * 10) / 60;
      let cburger_ans = cal / 310;
      let beer2_ans = cal / 153.1;
      let cleanning_ans = (cal / 1.59 / weight) * 60;
      let shop_ans = cal / 2.5;

      let meter_dash_ans = 360 / y0;
      let meter_run_h_ans = Math.floor(600 / y0);
      let meter_run_m_ans = (600 / y0 - meter_run_h_ans) * 60;

      let half_marathon = (21.095 * 60) / y0;
      let half_marathonh = Math.floor(half_marathon / 60);
      let half_marathonm = Math.floor(half_marathon - half_marathonh * 60);
      let half_marathons =
        (half_marathon - half_marathonh * 60 - half_marathonm) * 60;

      let marathon = (42.195 * 60) / y0;
      let marathonh = Math.floor(marathon / 60);
      let marathonm = Math.floor(marathon - marathonh * 60);
      let marathons = (marathon - marathonh * 60 - marathonm) * 60;
      let myrecord = marathon / 60;
      let record_ans = (2.0275 / myrecord) * 100;

      result = {
        tech_speed_mph: Number(speed_mph.toFixed(1)),
        tech_speed_kmh: Number(speed_kmh.toFixed(1)),
        tech_time_ans: Number(time_ans.toFixed(1)),
        tech_distance_m: Number(distance_m.toFixed(1)),
        tech_distance_km: Number(distance_km.toFixed(1)),
        tech_speed_mph_sec: Number(speed_mph_sec.toFixed(1)),
        tech_speed_kmh_sec: Number(speed_kmh_sec.toFixed(1)),
        tech_distance_m_sec: Number(distance_m_sec.toFixed(1)),
        tech_distance_km_sec: Number(distance_km_sec.toFixed(1)),
        tech_cal: Number(cal.toFixed(1)),
        tech_fatoz_ans: Number(fatoz_ans.toFixed(1)),
        tech_fatg_ans: Number(fatg_ans.toFixed(1)),
        tech_mets: Number(mets.toFixed(1)),
        tech_energy_kw_ans: Number(energy_kw_ans.toFixed(1)),
        tech_electric_heater_ans: Number(electric_heater_ans.toFixed(1)),
        tech_light_bulb_ans: Number(light_bulb_ans.toFixed(1)),
        tech_cburger_ans: Number(cburger_ans.toFixed(1)),
        tech_beer2_ans: Number(beer2_ans.toFixed(1)),
        tech_shop_ans: Number(shop_ans.toFixed(1)),
        tech_cleanning_ans: Number(cleanning_ans.toFixed(1)),
        tech_meter_dash_ans: Number(meter_dash_ans.toFixed(1)),
        tech_meter_run_h_ans: Number(meter_run_h_ans.toFixed(1)),
        tech_meter_run_m_ans: Number(meter_run_m_ans.toFixed(1)),
        tech_half_marathonh: Number(half_marathonh.toFixed(1)),
        tech_half_marathonm: Number(half_marathonm.toFixed(1)),
        tech_half_marathons: Number(half_marathons.toFixed(1)),
        tech_marathonh: Number(marathonh.toFixed(1)),
        tech_marathonm: Number(marathonm.toFixed(1)),
        tech_marathons: Number(marathons.toFixed(1)),
        tech_record_ans: Number(record_ans.toFixed(1)),
        tech_gradient: gradient,
      };
      return result;
    } else {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /**
   * getCalculationWalkingCalorieCalculator: Service Method
   * POST: /api/calculators-lol/walking-calorie-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationWalkingCalorieCalculator(body) {
    let unit_type = body.tech_unit_type?.trim();
    let age = parseFloat(body.tech_age);
    let gender = body.tech_gender?.trim();
    let height = parseFloat(body.tech_height);
    let inches = parseFloat(body.tech_inches);
    let weight = parseFloat(body.tech_weight);
    let speed_unit = body.tech_speed_unit?.trim();
    let mets = parseFloat(body.tech_mets);
    let duration = parseFloat(body.tech_duration);

    let result = {};
    // Helper functions
    function getSpeedKmh(speed_unit) {
      switch (speed_unit) {
        case "less than 2.0mph (3.2km/h)":
        case "2.0mph (3.2km/h)":
          return 3.2;
        case "2.5mph (4.0km/h)":
          return 4.0;
        case "3.0mph (4.8km/h)":
          return 4.8;
        case "3.5mph (5.6km/h)":
          return 5.6;
        case "4.0mph (6.4km/h)":
          return 6.4;
        case "4.5mph (7.2km/h)":
          return 7.2;
        default:
          return 8.0;
      }
    }

    function getSpeedMph(speed_unit) {
      switch (speed_unit) {
        case "less than 2.0mph (3.2km/h)":
        case "2.0mph (3.2km/h)":
          return 2.0;
        case "2.5mph (4.0km/h)":
          return 2.5;
        case "3.0mph (4.8km/h)":
          return 3.0;
        case "3.5mph (5.6km/h)":
          return 3.5;
        case "4.0mph (6.4km/h)":
          return 4.0;
        case "4.5mph (7.2km/h)":
          return 4.5;
        default:
          return 5.0;
      }
    }
    if (unit_type === "sl") {
      if (
        isFinite(age) &&
        isFinite(height) &&
        isFinite(weight) &&
        isFinite(mets) &&
        isFinite(duration)
      ) {
        let male_calories;
        if (gender === "male") {
          male_calories =
            88.362 + 13.397 * weight + 4.799 * height - 5.677 * age;
        } else {
          male_calories =
            447.593 + 9.247 * weight + 3.098 * height - 4.33 * age;
        }

        let exercise = (duration * mets) / 60;
        let hour_duration = duration / 60;

        let speed_kmh = getSpeedKmh(speed_unit);
        let speed_mph = getSpeedMph(speed_unit);

        let hour_duration_min = hour_duration * speed_kmh;
        let hour_mile = hour_duration * speed_mph;

        let burned = Math.round((male_calories * mets * hour_duration) / 24);

        result = {
          tech_male_calories: male_calories,
          tech_exercise: exercise,
          tech_hour_duration_min: hour_duration_min,
          tech_hour_mile: hour_mile,
          tech_burned: burned,
        };
      } else {
        result = { error: "Please! Check Your Input." };
      }
    } else {
      if (
        isFinite(age) &&
        isFinite(height) &&
        isFinite(weight) &&
        isFinite(mets) &&
        isFinite(duration) &&
        isFinite(inches)
      ) {
        let heig_ft = height * 30.48;
        let heig_in = inches * 2.54;
        height = heig_ft + heig_in;
        weight = weight / 2.205;

        let male_calories;
        if (gender === "male") {
          male_calories =
            88.362 + 13.397 * weight + 4.799 * height - 5.677 * age;
        } else {
          male_calories =
            447.593 + 9.247 * weight + 3.098 * height - 4.33 * age;
        }

        let exercise = (duration * mets) / 60;
        let hour_duration = duration / 60;

        let speed_kmh = getSpeedKmh(speed_unit);
        let speed_mph = getSpeedMph(speed_unit);

        let hour_duration_min = hour_duration * speed_kmh;
        let hour_mile = hour_duration * speed_mph;

        let burned = Math.round((male_calories * mets * hour_duration) / 24);

        result = {
          tech_male_calories: male_calories,
          tech_exercise: exercise,
          tech_hour_duration_min: hour_duration_min,
          tech_hour_mile: hour_mile,
          tech_burned: burned,
        };
      } else {
        result = { error: "Please! Check Your Input." };
      }
    }

    return result;
  }

  /**
   * getCalculationEllipticalCalorieCalculator: Service Method
   * POST: /api/calculators-lol/elliptical-calorie-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationEllipticalCalorieCalculator(body) {
    let weight = String(body.tech_weight).trim();
    let weightUnit = String(body.tech_weight_unit).trim();
    let time = String(body.tech_time).trim();
    let hour = String(body.tech_hour).trim();
    let min = String(body.tech_min).trim();
    let timeUnit = String(body.tech_unit_hrs_min).trim();
    let effort = String(body.tech_effort).trim();
    let effortUnit = String(body.tech_effort_unit).trim();

    const response = {};

    if ((!hour || hour === "0") && (!min || min === "0")) {
      response.error = "Please! Check Your Input.";
      return response;
    }

    hour = hour ? parseFloat(hour) : 0;
    min = min ? parseFloat(min) : 0;

    if (weightUnit === "kg") {
      weight = parseFloat(weight);
    } else if (weightUnit === "lbs") {
      weight = parseFloat(weight) * 2.205;
    } else if (weightUnit === "stone") {
      weight = parseFloat(weight) / 6.35;
    }

    if (timeUnit === "sec") {
      time = parseFloat(time);
    } else if (timeUnit === "min") {
      time = parseFloat(time) * 60;
    } else if (timeUnit === "hrs") {
      time = parseFloat(time) * 3600;
    } else if (timeUnit === "hrs/min") {
      time = hour * 3600 + min * 60;
    }

    if (effortUnit === "Light (MET = 4.6)") {
      effort = 4.6;
    } else if (effortUnit === "Moderate (MET = 4.9)") {
      effort = 4.9;
    } else if (effortUnit === "Vigorous (MET = 5.7)") {
      effort = 5.7;
    } else if (effortUnit === "Custom (enter MET value)") {
      effort = parseFloat(effort);
    }

    if (isFinite(weight) && isFinite(time) && isFinite(effort)) {
      const answer = (time * effort * 3.5 * weight) / (200 * 60);
      const subAnswer = (60 * effort * 3.5 * weight) / 200;

      response.tech_weight = weight;
      response.tech_time = time;
      response.tech_answer = answer;
      response.tech_sub_answer = subAnswer;
      return response;
    } else {
      response.error = "Please! Check Your Input.";
      return response;
    }
  }

  /**
   * getCalculationBulkingCalculator: Service Method
   * POST: /api/calculators-lol/bulking-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBulkingCalculator(body) {
    let age = Number(body.tech_age);
    let heightFt = Number(body.tech_height_ft);
    let heightCm = Number(body.tech_height_cm);
    let weight = Number(body.tech_weight);
    let perCal = Number(body.tech_per_cal);
    let gender = String(body.tech_gender);
    let percent = Number(body.tech_percent);
    let activity = String(body.tech_activity);
    let stype = String(body.tech_stype);
    let start = String(body.tech_start);
    let target = String(body.tech_target);
    let weight1 = Number(body.tech_weight1);
    let surplus = String(body.tech_surplus);
    let kalDay = Number(body.tech_kal_day);
    let submit = String(body.tech_unit_type);

    const response = {};
    const want = "2";

    if (
      !isFinite(age) ||
      !isFinite(weight) ||
      !isFinite(weight1) ||
      !start ||
      !target
    ) {
      response.error = "Please fill All Fields.";
      return response;
    }

    let heightIn, unit;
    if (submit === "imperial") {
      heightIn = heightFt * 2.54;
      weight = weight / 2.205;
      weight1 = weight1 / 2.205;
      unit = "lbs";
    } else {
      if (isFinite(heightCm)) {
        heightIn = heightCm;
        unit = "kg";
      } else {
        response.error = "Please enter height.";
        return response;
      }
    }

    let BMR, Robinson, Miller, Devine, Hamwi, tdee;
    if (gender === "Male") {
      BMR = Math.round(
        10 * Math.round(weight) + 6.25 * Math.round(heightCm) - 5 * age + 5
      );
      if (activity === "sedentary") tdee = Math.round(BMR * 1.1);
      else if (activity === "Lightly_Active") tdee = Math.round(BMR * 1.2);
      else if (activity === "Moderately_Active") tdee = Math.round(BMR * 1.4);
      else if (activity === "Very_Active") tdee = Math.round(BMR * 1.6);
      else tdee = Math.round(BMR * 1.8);

      Robinson = Math.round(49 + 1.7 * (heightIn - 60));
      Miller = Math.round(53.1 + 1.36 * (heightIn - 60));
      Devine = Math.round(45.5 + 2.3 * (heightIn - 60));
      Hamwi = Math.round(45 + 2.2 * (heightIn - 60));
    } else {
      BMR = Math.round(10 * weight + 6.25 * heightCm - 5 * age - 161);
      if (activity === "sedentary") tdee = Math.round(BMR * 1.1);
      else if (activity === "Lightly_Active") tdee = Math.round(BMR * 1.2);
      else if (activity === "Moderately_Active") tdee = Math.round(BMR * 1.4);
      else if (activity === "Very_Active") tdee = Math.round(BMR * 1.6);
      else tdee = Math.round(BMR * 1.8);

      Robinson = Math.round(52 + 1.9 * (heightIn - 60));
      Miller = Math.round(56.2 + 1.41 * (heightIn - 60));
      Devine = Math.round(50 + 2.3 * (heightIn - 60));
      Hamwi = Math.round(48 + 2.7 * (heightIn - 60));
    }

    if (percent) {
      const lbm = (weight * (100 - percent)) / 100;
      BMR = Math.round(370 + 21.6 * lbm);
    }

    const heightM = heightIn / 39.37;
    const BMI = Math.round((weight / (heightM * heightM)) * 100) / 100;

    let youAre = "";
    if (BMI <= 18.5) youAre = "Underweight";
    else if (BMI > 18.5 && BMI <= 24.9) youAre = "Normal Weight";
    else if (BMI > 24.9 && BMI <= 29.9) youAre = "Overweight";
    else if (BMI > 29.9 && BMI <= 35) youAre = "Obesity";
    else youAre = "Severe Obesity";

    const ibw =
      submit === "imperial"
        ? `${Math.round(Robinson * 2.205)}-${Math.round(Hamwi * 2.205)} lbs`
        : `${Robinson}-${Hamwi} kg`;

    const startDate = DateTime.fromISO(start);
    const targetDate = DateTime.fromISO(target);

    if (!startDate.isValid || !targetDate.isValid) {
      response.error = "Please Enter Start and Target Date.";
      return response;
    }

    if (startDate >= targetDate) {
      response.error = "Target Date must be later than start date.";
      return response;
    }

    const days = targetDate.diff(startDate, "days").days;
    const poundsDaily = Math.round((weight1 / days) * 100) / 100;
    const highRiskWeight = poundsDaily > 0.3;

    let caloriesGain;
    if (surplus === "custom") {
      if (stype === "Incal") {
        caloriesGain = kalDay;
      } else {
        caloriesGain = tdee * (perCal / 100);
      }
    } else {
      if (surplus === "0.10") caloriesGain = tdee * 0.1;
      else if (surplus === "0.15") caloriesGain = tdee * 0.15;
      else caloriesGain = tdee * 0.2;
    }

    const caloriesDaily = Math.round(tdee + caloriesGain);
    const highRiskCalories = caloriesDaily < 1200;

    const goal =
      submit === "imperial"
        ? Math.round(weight + weight1)
        : Math.round(((weight + weight1) / 2.205) * 100) / 100;

    const fat = Math.round((caloriesDaily / 9) * 0.2);
    const protein = Math.round((caloriesDaily / 4) * 0.3);
    const carbs = Math.round((caloriesDaily / 4) * 0.5);

    return {
      tech_HighRiskWeight: highRiskWeight,
      tech_PoundsDaily: poundsDaily,
      tech_HighRiskCalories: highRiskCalories,
      tech_CaloriesDaily: caloriesDaily,
      tech_CaloriesLess: Math.round(caloriesGain),
      tech_Calories: tdee,
      tech_Goal: goal,
      tech_days: days,
      tech_BMR: BMR,
      tech_BMI: BMI,
      tech_you_are: youAre,
      tech_lbm: percent
        ? Math.round((weight * (100 - percent)) / 100)
        : undefined,
      tech_ibw: ibw,
      tech_fat: fat,
      tech_po: protein,
      tech_cb: carbs,
      tech_want: want,
      tech_unit: unit,
    };
  }

  /**
   * getCalculationFoodCostCalculator: Service Method
   * POST: /api/calculators-lol/food-cost-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationFoodCostCalculator(body) {
    let food_type = body.tech_food_type;
    let menu = body.tech_menu;
    let measure_unit = body.tech_measure_unit;
    let units_case = body.tech_units_case;
    let cost_unit = body.tech_cost_unit;
    let serving_size = body.tech_serving_size;
    let other = body.tech_other;
    let menu_price = body.tech_menu_price;

    let response = {};

    // Convert to numbers
    menu = Number(menu);
    units_case = Number(units_case);
    cost_unit = Number(cost_unit);
    serving_size = Number(serving_size);
    other = Number(other);
    menu_price = Number(menu_price);

    if (
      isNaN(menu) ||
      isNaN(units_case) ||
      isNaN(cost_unit) ||
      isNaN(serving_size) ||
      isNaN(other) ||
      isNaN(menu_price)
    ) {
      response.error = "Please! Check Your Input.";
      return response;
    }

    let costPerUnit;
    if (food_type === "food_piece") {
      costPerUnit = cost_unit;
    } else {
      if (units_case > 0 && cost_unit > 0) {
        costPerUnit = Math.round((cost_unit / units_case) * 100) / 100;
      } else {
        response.error = "Please! Check Your Input.";
        return response;
      }
    }

    let costPerServing;
    if (serving_size > 0) {
      costPerServing = Math.round(serving_size * costPerUnit * 100) / 100;
    } else {
      response.error = "Serving Size Cannot be Less Than Zero.";
      return response;
    }

    let costPerPlate = costPerServing + other;

    let contributionPerPlate;
    let food_cost;
    if (menu_price > 0) {
      contributionPerPlate = menu_price - costPerPlate;
      food_cost = Math.round((costPerPlate / menu_price) * 100);
    } else {
      response.error = "Please! Check Your Input.";
      return response;
    }

    let profitPerCase;
    if (units_case > 0 && serving_size > 0) {
      let servingsPerCase = units_case / serving_size;
      profitPerCase = contributionPerPlate * servingsPerCase;
    } else {
      response.error = "Please! Check Your Input.";
      return response;
    }

    response.tech_costPerUnit = costPerUnit;
    response.tech_costPerServing = costPerServing;
    response.tech_costPerPlate = costPerPlate;
    response.tech_contributionPerPlate = contributionPerPlate;
    response.tech_food_cost = food_cost;
    response.tech_profitPerCase = profitPerCase;

    return response;
  }

  /**
   * getCalculationStepsToMilesCalculator: Service Method
   * POST: /api/calculators-lol/steps-to-miles-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationStepsToMilesCalculator(body) {
    let methods = body.tech_methods;
    let sex = body.tech_sex;
    let first = body.tech_first;
    let unit = body.tech_unit;
    let steps = body.tech_steps;

    let response = {};

    // Convert numeric inputs
    first = Number(first);
    steps = Number(steps);

    // Normalize unit to numeric code
    if (unit === "cm") {
      unit = "1";
    } else if (unit === "dm") {
      unit = "2";
    } else if (unit === "m") {
      unit = "3";
    } else if (unit === "in") {
      unit = "4";
    } else if (unit === "ft") {
      unit = "5";
    } else if (unit === "mi") {
      unit = "6";
    }

    // Height conversion helper
    function height(a, b) {
      if (a === "1") {
        return b / 30.48;
      } else if (a === "2") {
        return b / 3.048;
      } else if (a === "3") {
        return b * 3.281;
      } else if (a === "4") {
        return b / 12;
      } else if (a === "5") {
        return b;
      } else if (a === "6") {
        return b * 5280;
      }
      return b;
    }

    first = height(unit, first);

    let answer;

    if (methods === "1") {
      if (!isNaN(steps)) {
        if (sex === "1") {
          answer = steps * 0.0004735;
        } else if (sex === "2") {
          answer = steps * 0.0004167;
        }
      } else {
        response.error = "Please! Check your input.";
        return response;
      }
    } else if (methods === "2") {
      if (!isNaN(first) && !isNaN(steps)) {
        if (sex === "1") {
          answer = steps * 0.0004735;
        } else if (sex === "2") {
          answer = steps * 0.0004167;
        }
      } else {
        response.error = "Please! Check your input.";
        return response;
      }
    } else if (methods === "3") {
      if (!isNaN(first) && !isNaN(steps)) {
        answer = (steps * first) / 5280;
      } else {
        response.error = "Please! Check your input.";
        return response;
      }
    } else {
      response.error = "Invalid method selected.";
      return response;
    }

    response.tech_answer = answer;
    return response;
  }

  /**
   * getCalculationFatBurningHeartCalculator: Service Method
   * POST: /api/calculators-lol/fat-burning-heart-rate
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationFatBurningHeartCalculator(body) {
    let age = body.tech_age;
    let gender = body.tech_gender;
    let RHR = body.tech_RHR;

    let response = {};
    age = Number(age);
    RHR = Number(RHR);

    if (!isNaN(age)) {
      if (age <= 150) {
        let MHR = 220 - age;
        let NHR;

        if (gender === "male") {
          NHR = [
            ["49-55", "49-54", "50-56", "50-57", "51-56", "50-55"],
            ["56-61", "55-61", "57-62", "58-63", "57-61", "56-61"],
            ["62-65", "62-65", "63-66", "64-67", "62-67", "62-65"],
            ["66-69", "66-70", "67-70", "68-71", "68-71", "66-69"],
            ["70-73", "71-74", "71-75", "72-76", "72-75", "70-73"],
            ["74-81", "75-81", "76-62", "77-83", "76-81", "74-79"],
            ["82+", "82+", "83+", "84+", "82+", "80+"],
          ];
        } else {
          NHR = [
            ["54-60", "54-59", "54-59", "54-60", "54-59", "54-59"],
            ["61-65", "60-64", "60-64", "61-65", "60-64", "60-64"],
            ["66-69", "65-68", "65-69", "66-69", "65-68", "65-68"],
            ["70-73", "69-72", "70-73", "70-73", "69-73", "69-72"],
            ["74-78", "73-76", "74-78", "74-77", "74-77", "73-76"],
            ["79-84", "77-82", "79-84", "78-83", "78-83", "77-84"],
            ["85+", "83+", "85+", "84+", "84+", "84+"],
          ];
        }

        let res = [];
        let res_normal = "";

        if (age < 18) {
          res_normal = "Normal Heart Rate Cannot be calculated under age 18";
          res = ["", "", "", "", "", "", ""];
        } else if (age >= 18 && age <= 25) {
          for (let i = 0; i < 7; i++) res[i] = NHR[i][0];
        } else if (age >= 26 && age <= 35) {
          for (let i = 0; i < 7; i++) res[i] = NHR[i][1];
        } else if (age >= 36 && age <= 45) {
          for (let i = 0; i < 7; i++) res[i] = NHR[i][2];
        } else if (age >= 46 && age <= 55) {
          for (let i = 0; i < 7; i++) res[i] = NHR[i][3];
        } else if (age >= 56 && age <= 65) {
          for (let i = 0; i < 7; i++) res[i] = NHR[i][4];
        } else if (age >= 66) {
          for (let i = 0; i < 7; i++) res[i] = NHR[i][5];
        } else {
          res_normal = "Invalid Age";
          res = [""];
        }

        let HRR = !isNaN(RHR) ? MHR - RHR : "";

        // let HRR;

        // if (!isNaN(RHR) && !isNaN(MHR)) {
        //     HRR = MHR - RHR;
        // } else {
        //     RHR = "";
        //     HRR = "";
        // }

        // 60-80% method
        let percent_lower = (MHR * 60) / 100;
        let percent_upper = (MHR * 80) / 100;

        // Zoladz method
        let zoladz_lower = MHR - 50 - 5;
        let zoladz_upper = MHR - 40 + 5;

        // Karvonen method
        let karvonen_lower = !isNaN(RHR) ? (HRR * 60) / 100 + RHR : "";
        let karvonen_upper = !isNaN(RHR) ? (HRR * 80) / 100 + RHR : "";

        response.tech_percent_lower = Number(percent_lower.toFixed(4));
        response.tech_percent_upper = Number(percent_upper.toFixed(4));
        response.tech_MHR = MHR;
        response.tech_HRR = HRR;
        response.tech_zoladz_lower = zoladz_lower;
        response.tech_zoladz_upper = zoladz_upper;
        response.tech_karvonen_lower = karvonen_lower;
        response.tech_karvonen_upper = karvonen_upper;
        response.tech_res_normal = res_normal;
        response.tech_res0 = res[0];
        response.tech_res1 = res[1];
        response.tech_res2 = res[2];
        response.tech_res3 = res[3];
        response.tech_res4 = res[4];
        response.tech_res5 = res[5];
        response.tech_res6 = res[6];
        response.input_age = body.tech_age;
        response.input_gender = body.tech_gender;
        response.input_RHR = body.tech_RHR;

        return response;
      } else {
        response.error = "Age must be less than 150.";
        return response;
      }
    } else {
      response.error = "Please! Check your input.";
      return response;
    }
  }

  /**
   * getCalculationNNTCalculator: Service Method
   * POST: /api/calculators-lol/nnt-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationNNTCalculator(body) {
    let outcome = body.tech_outcome;
    let first = body.tech_first;
    let second = body.tech_second;
    let third = body.tech_third;

    let response = {};

    first = Number(first);
    second = Number(second);
    third = Number(third);

    let arr, nnt;

    if (outcome === "per") {
      if (!isNaN(second) && !isNaN(third)) {
        if (second > 0 && third > 0) {
          let minus = second - third;
          arr = minus / 100;
          nnt = 1 / arr;
        } else {
          response.error = "This value can't be negative.";
          return response;
        }
      } else {
        response.error = "Please! Check your input.";
        return response;
      }
    } else {
      if (!isNaN(first) && !isNaN(second) && !isNaN(third)) {
        if (first > 0 && second > 0 && third > 0) {
          let f_div = (-1 * second) / first;
          let s_div = (-1 * third) / first;
          let r0 = 1 - Math.exp(f_div);
          let r1 = 1 - Math.exp(s_div);
          arr = r0 - r1;
          nnt = 1 / arr;
        } else {
          response.error = "This value can't be negative.";
          return response;
        }
      } else {
        response.error = "Please! Check your input.";
        return response;
      }
    }

    response.tech_arr = arr;
    response.tech_nnt = nnt;
    response.input_outcome = body.tech_outcome;
    response.input_first = body.tech_first;
    response.input_second = body.tech_second;
    response.input_third = body.tech_third;
    return response;
  }

  /**
   * getCalculationAstAltRatioCalculator: Service Method
   * POST: /api/calculators-lol/ast-alt-ratio-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationAstAltRatioCalculator(body) {
    let ast = String(body.tech_ast).trim();
    let ast_unit = String(body.tech_ast_unit).trim().replace("U / ", "");
    let alt = String(body.tech_alt).trim();
    let alt_unit = String(body.tech_alt_unit).trim().replace("U / ", "");

    function sigFig(value, digits) {
      if (value !== "") {
        let decimalPlaces;
        if (value === 0) {
          decimalPlaces = digits - 1;
        } else if (value < 0) {
          decimalPlaces = digits - Math.floor(Math.log10(value * -1)) - 1;
        } else {
          decimalPlaces = digits - Math.floor(Math.log10(value)) - 1;
        }
        return Number(value.toFixed(decimalPlaces));
      }
    }

    let result = {};

    if (
      !isNaN(ast) &&
      ast !== "" &&
      !isNaN(alt) &&
      alt !== "" &&
      ast_unit !== "" &&
      alt_unit !== ""
    ) {
      ast = parseFloat(ast);
      alt = parseFloat(alt);

      // Unit Conversion AST
      if (ast_unit === "mm³") {
        ast = ast / 0.000001;
      } else if (ast_unit === "cm³") {
        ast = ast / 0.001;
      } else if (ast_unit === "cu in") {
        ast = ast / 0.016387;
      } else if (ast_unit === "cu ft") {
        ast = ast / 28.317;
      } else if (ast_unit === "ml") {
        ast = ast / 0.001;
      } else if (ast_unit === "cl") {
        ast = ast / 0.01;
      }

      // Unit Conversion ALT
      if (alt_unit === "mm³") {
        alt = alt / 0.000001;
      } else if (alt_unit === "cm³") {
        alt = alt / 0.001;
      } else if (alt_unit === "cu in") {
        alt = alt / 0.016387;
      } else if (alt_unit === "cu ft") {
        alt = alt / 28.317;
      } else if (alt_unit === "ml") {
        alt = alt / 0.001;
      } else if (alt_unit === "cl") {
        alt = alt / 0.01;
      }

      if (ast >= 2000) {
        return { error: "AST cannot be greater than or equal to 2000." };
      }
      if (alt >= 2000) {
        return { error: "ALT cannot be greater than or equal to 2000." };
      }

      let ratio = ast / alt;
      let m1 = "";
      let m2 = "";
      let m3 = "";

      if (ast < 8) {
        m1 = "Lower than the average";
      } else if (ast >= 8 && ast <= 48) {
        m1 = "Within normal range";
      } else if (ast > 48) {
        m1 = "Higher than the average";
      }

      if (alt < 7) {
        m2 = "Lower than the average";
      } else if (alt >= 7 && alt <= 55) {
        m2 = "Within normal range";
      } else if (alt > 55) {
        m2 = "Higher than the average";
      }

      if (ratio < 0.6) {
        m3 = "Lower than the average";
      } else if (ratio >= 0.6 && ratio <= 1) {
        m3 = "Within normal range";
      } else if (ratio > 1) {
        m3 = "Too high - indicative of cirrhosis";
      }

      result = {
        tech_ratio: sigFig(ratio, 3),
        tech_ast: ast,
        tech_alt: alt,
        tech_m1: m1,
        tech_m2: m2,
        tech_m3: m3,
      };
    } else {
      result = { error: "Please! Check Your Input." };
    }

    return result;
  }

  /**
   * getCalculationNetCarbsCalculator: Service Method
   * POST: /api/calculators-lol/net-carbs-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationNetCarbsCalculator(body) {
    let serving = body.tech_serving;
    let location = body.tech_location;
    let carbohydrates = body.tech_carbohydrates;
    let fiber = body.tech_fiber;
    let alcohol = body.tech_alcohol;
    let contains = body.tech_contains;

    // Helper function
    function isNumeric(value) {
      return !isNaN(value) && value !== "" && value !== null;
    }

    let result = {};

    if (location === "yes") {
      if (isNumeric(carbohydrates) && isNumeric(fiber) && isNumeric(alcohol)) {
        carbohydrates = parseFloat(carbohydrates);
        fiber = parseFloat(fiber);
        alcohol = parseFloat(alcohol);

        let Net_carbs;
        if (contains === "no") {
          Net_carbs = carbohydrates - fiber - alcohol / 2;
          result.tech_Net_carbs = Net_carbs;
        } else if (contains === "yes") {
          Net_carbs = carbohydrates - fiber - alcohol;
          result.tech_Net_carbs = Net_carbs;
        } else {
          result.error = "Please! Check Your Input.";
          return result;
        }

        result.input_carbohydrates = carbohydrates;
        result.input_fiber = fiber;
        result.input_alcohol = alcohol;
      } else {
        result.error = "Please! Check Your Input.";
        return result;
      }
    } else if (location === "no") {
      if (isNumeric(carbohydrates) && isNumeric(alcohol)) {
        carbohydrates = parseFloat(carbohydrates);
        alcohol = parseFloat(alcohol);

        let Net_carbs;
        if (contains === "yes") {
          Net_carbs = carbohydrates - alcohol;
          result.tech_Net_carbs = Net_carbs;
        } else if (contains === "no") {
          Net_carbs = carbohydrates - alcohol / 2;
          result.tech_Net_carbs = Net_carbs;
        } else {
          result.error = "Please! Check Your Input.";
          return result;
        }

        result.input_carbohydrates = carbohydrates;
        result.input_alcohol = alcohol;
        result.input_fiber = fiber;
      } else {
        result.error = "Please! Check Your Input.";
        return result;
      }
    } else {
      result.error = "Please! Check Your Input.";
      return result;
    }

    return result;
  }

  /**
   * getCalculationUrineOutputCalculator: Service Method
   * POST: /api/calculators-lol/urine-output-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationUrineOutputCalculator(body) {
    let weight = body.tech_weight;
    let weight_unit = body.tech_weight_unit;
    let time = body.tech_time;
    let time_unit = body.tech_time_unit;
    let urine = body.tech_urine;
    let urine_unit = body.tech_urine_unit;
    let fluid = body.tech_fluid;
    let fluid_unit = body.tech_fluid_unit;
    let output_unit = body.tech_output_unit;
    let balance_unit = body.tech_balance_unit;
    let min = body.tech_time_min;
    let sec = body.tech_time_sec;
    let hours = body.tech_time_min;
    let mins = body.tech_time_sec;

    let result = {};

    function converter(value, unit) {
      if (unit === "g") value = value * 1000;
      else if (unit === "dag") value = value * 100;
      else if (unit === "kg") value = value * 1;
      else if (unit === "oz") value = value * 35.274;
      else if (unit === "lbs") value = value * 2.205;
      return value;
    }

    function timex(value, unit) {
      if (unit === "sec") value = value * 3600;
      else if (unit === "min") value = value * 60;
      else if (unit === "hrs") value = value * 1;
      else if (unit === "day") value = value / 24;
      return value;
    }

    function urinex(value, unit) {
      if (unit === "mm³") value = value * 1000;
      else if (unit === "cm³") value = value / 1;
      else if (unit === "dm³") value = value / 1000;
      else if (unit === "cu in") value = value / 16.387;
      else if (unit === "ml") value = value * 1;
      else if (unit === "cl") value = value / 10;
      else if (unit === "liters") value = value / 1000;
      else if (unit === "us gal") value = value / 3785;
      else if (unit === "uk gal") value = value / 4546;
      else if (unit === "us fl oz") value = value / 28.413;
      else if (unit === "uk fl oz") value = value / 28.413;
      return value;
    }

    function isNumeric(val) {
      return !isNaN(val) && val !== "" && val !== null;
    }

    if (
      isNumeric(urine) &&
      isNumeric(weight) &&
      isNumeric(time) &&
      isNumeric(fluid)
    ) {
      let time_ans;

      if (time_unit === "min/sec" || time_unit === "hrs/min") {
        if (time_unit === "min/sec") {
          if (isNumeric(min) && isNumeric(sec)) {
            time = min / 60 + sec / 3600;
            time_ans = time;
          } else {
            result.error = "Please! Check Your Input.";
            return result;
          }
        } else if (time_unit === "hrs/min") {
          if (isNumeric(hours) && isNumeric(mins)) {
            time = hours + mins / 60;
            time_ans = time;
          } else {
            result.error = "Please! Check Your Input.";
            return result;
          }
        }
      } else {
        time = timex(time, time_unit);
        time_ans = time;
      }

      urine = urinex(urine, urine_unit);
      weight = converter(weight, weight_unit);
      let answer_unit = urine / (weight * time);
      let answer = converter(answer_unit, output_unit);
      fluid = urinex(fluid, fluid_unit);
      let sec_answer = fluid - urine;

      result.tech_answer = answer;
      result.tech_sec_answer = sec_answer;
      result.tech_time_ans = Number(time_ans.toFixed(4));
    } else {
      result.error = "Please! Check Your Input.";
      return result;
    }

    return result;
  }

  /**
   * getCalculationBishopScoreCalculator: Service Method
   * POST: /api/calculators-lol/bishop-score-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBishopScoreCalculator(body) {
    let effacement = body.tech_effacement;
    let consistency = body.tech_consistency;
    let fetal_station = body.tech_fetal_station;
    let head_position = body.tech_head_position;
    let dilation = body.tech_dilation;

    let resultData = {};

    function isNumeric(val) {
      return !isNaN(val) && val !== "" && val !== null;
    }

    if (
      isNumeric(effacement) &&
      isNumeric(consistency) &&
      isNumeric(fetal_station) &&
      isNumeric(head_position) &&
      isNumeric(dilation)
    ) {
      let bishopScore =
        Number(dilation) +
        Number(effacement) +
        Number(consistency) +
        Number(fetal_station) +
        Number(head_position);

      let resultMessage = "";
      if (bishopScore <= 6) {
        resultMessage =
          "You are not expected to go into labor in the upcoming weeks. If induction is needed, consider adding cervical ripening agents.";
      } else if (bishopScore >= 8) {
        resultMessage =
          "You are expected to go into labor within a few days. If induction is needed, it's likely to be successful.";
      } else {
        resultMessage = "Consider further evaluation.";
      }

      resultData.tech_bishopScore = bishopScore;
      resultData.tech_result = resultMessage;
    } else {
      resultData.error = "Please! Check Your Input.";
      return resultData;
    }

    return resultData;
  }

  /**
   * getCalculationArmyBodyFatCalculator: Service Method
   * POST: /api/calculators-lol/army-body-fat-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationArmyBodyFatCalculator(body) {
    let activeDuty = body.tech_activeDuty;
    let age = body.tech_age;
    let gender = body.tech_gender;
    let height = body.tech_height_cm;
    let height_unit = body.tech_unit_ft_in;
    let height_ft = body.tech_height_ft;
    let height_in = body.tech_height_in;
    let neck = body.tech_neck_cm;
    let neck_unit = body.tech_unit_ft_in1;
    let neck_ft = body.tech_neck_ft;
    let neck_in = body.tech_neck_in;
    let waist = body.tech_waist_cm;
    let waist_unit = body.tech_unit_ft_in2;
    let waist_ft = body.tech_waist_ft;
    let waist_in = body.tech_waist_in;
    let hip_unit = body.tech_unit_ft_in3;
    let hip_ft = body.tech_hip_ft;
    let hip_in = body.tech_hip_in;

    let hip =
      gender === "female" && body.tech_hip_cm !== undefined
        ? body.tech_hip_cm
        : null;

    function convertToInches(value, unit, ft, inches) {
      if (unit === "ft/in") {
        return ft * 12 + inches;
      } else if (unit === "cm") {
        return value * 0.393701;
      } else if (unit === "m") {
        return value * 39.3701;
      } else if (unit === "ft") {
        return value * 12;
      } else if (unit === "in") {
        return value;
      } else {
        return null;
      }
    }

    height = convertToInches(height, height_unit, height_ft, height_in);
    waist = convertToInches(waist, waist_unit, waist_ft, waist_in);
    neck = convertToInches(neck, neck_unit, neck_ft, neck_in);
    if (gender === "female" && hip !== null) {
      hip = convertToInches(hip, hip_unit, hip_ft, hip_in);
    }

    function isNumeric(val) {
      return !isNaN(val) && val !== null && val !== "";
    }

    let resultData = {};

    if (
      isNumeric(height) &&
      isNumeric(waist) &&
      isNumeric(neck) &&
      (gender !== "female" || isNumeric(hip))
    ) {
      function calculateMaleBodyFat(height, neck, waist) {
        return (
          86.01 * Math.log10(waist - neck) - 70.041 * Math.log10(height) + 36.76
        );
      }

      function calculateFemaleBodyFat(height, neck, waist, hip) {
        return (
          163.205 * Math.log10(waist + hip - neck) -
          97.684 * Math.log10(height) -
          78.387
        );
      }

      function determineBodyFatCategory(
        age,
        gender,
        activeDuty,
        bodyFatPercentage
      ) {
        let maxBodyFat;
        if (gender === "male") {
          if (age >= 17 && age <= 20) {
            maxBodyFat = activeDuty ? 20 : 24;
          } else if (age >= 21 && age <= 27) {
            maxBodyFat = activeDuty ? 22 : 26;
          } else if (age >= 28 && age <= 39) {
            maxBodyFat = activeDuty ? 24 : 28;
          } else {
            maxBodyFat = activeDuty ? 26 : 30;
          }
        } else if (gender === "female") {
          if (age >= 17 && age <= 20) {
            maxBodyFat = 30;
          } else if (age >= 21 && age <= 27) {
            maxBodyFat = 32;
          } else if (age >= 28 && age <= 39) {
            maxBodyFat = 34;
          } else {
            maxBodyFat = 36;
          }
        }

        if (bodyFatPercentage <= maxBodyFat) {
          return "Congratulations! You meet the US Army body fat standards!";
        } else {
          return "Sorry, you are not fit enough to join the US Army. Keep on training!";
        }
      }

      let bodyFatPercentage;
      if (gender === "male") {
        bodyFatPercentage = calculateMaleBodyFat(height, neck, waist);
      } else {
        bodyFatPercentage = calculateFemaleBodyFat(height, neck, waist, hip);
      }

      let bodyFatCategory = determineBodyFatCategory(
        age,
        gender,
        activeDuty,
        bodyFatPercentage
      );

      resultData.tech_bodyFatPercentage = bodyFatPercentage;
      resultData.tech_bodyFatCategory = bodyFatCategory;
    } else {
      resultData.error = "Please! Check Your Input.";
    }

    return resultData;
  }

  /**
   * getCalculationAdjustedBodyWeightCalculator: Service Method
   * POST: /api/calculators-lol/adjusted-body-weight-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationAdjustedBodyWeightCalculator(body) {
    let weight = body.tech_weight;
    let weight_unit = body.tech_weight_unit;
    let gender = body.tech_gender;
    let height = body.tech_height_cm;
    let height_unit = body.tech_unit_ft_in;
    let height_ft = body.tech_height_ft;
    let height_in = body.tech_height_in;

    // Convert height to inches
    if (height_unit) {
      if (height_unit === "ft/in") {
        let feet_to_inches = height_ft * 12;
        height = feet_to_inches + height_in;
      } else if (height_unit === "cm") {
        height = height * 0.393701;
      } else if (height_unit === "m") {
        height = height * 39.3701;
      } else if (height_unit === "ft") {
        height = height * 12;
      } else if (height_unit === "in") {
        height = height;
      }
    }

    // Convert weight to kg if needed
    if (weight_unit) {
      if (weight_unit === "lbs") {
        weight = weight * 0.45359237;
      }
    }

    let result = {};

    if (!isNaN(height) && !isNaN(weight)) {
      function calculateIdealBodyWeight(gender, height) {
        if (gender === "male") {
          return 52 + 1.9 * (height - 60);
        } else if (gender === "female") {
          return 49 + 1.7 * (height - 60);
        }
        return null;
      }

      function calculateAdjustedBodyWeight(idealBodyWeight, weight) {
        return idealBodyWeight + 0.4 * (weight - idealBodyWeight);
      }

      let idealBodyWeight = calculateIdealBodyWeight(gender, height);
      let adjustedBodyWeight = calculateAdjustedBodyWeight(
        idealBodyWeight,
        weight
      );

      result.tech_idealBodyWeight = Number(idealBodyWeight.toFixed(2));
      result.tech_adjustedBodyWeight = Number(adjustedBodyWeight.toFixed(2));
    } else {
      result.error = "Please! Check Your Input.";
    }

    return result;
  }

  /**
   * getCalculationBenchPressCalculator: Service Method
   * POST: /api/calculators-lol/bench-press-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBenchPressCalculator(body) {
    let weight = parseFloat(body.tech_weight);
    let unit = body.tech_unit;
    let reps = parseFloat(body.tech_reps);
    let tableType = body.tech_tableType; // currently unused, but included for consistency

    // Convert input weight to pounds if necessary
    if (unit === "kg") {
      weight *= 2.20462;
    } else if (unit === "stone") {
      weight *= 14;
    }

    // Calculate one-rep max using Epley formula
    let oneRepMax = weight * (1 + reps / 30);

    // Convert result back to input unit
    if (unit === "kg") {
      oneRepMax /= 2.20462;
    } else if (unit === "stone") {
      oneRepMax /= 14;
    }

    let result = {
      tech_oneRepMax: Number(oneRepMax.toFixed(2)),
    };

    return result;
  }

  /**
   * getCalculationDrugHalfLifeCalculator: Service Method
   * POST: /api/calculators-lol/drug-half-life-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDrugHalfLifeCalculator(body) {
    let half = parseFloat(body.tech_time);
    let half_one = parseFloat(body.tech_time_min);
    let half_sec = parseFloat(body.tech_time_sec);
    let half_unit = body.tech_time_unit;
    let dosage = parseFloat(body.tech_dosage);
    let dosage_unit = body.tech_dosage_unit;

    function secUnit(dosage, dosage_unit) {
      if (dosage_unit === "µg") {
        dosage = dosage / 1000;
      } else if (dosage_unit === "mg") {
        dosage = dosage;
      } else if (dosage_unit === "g") {
        dosage = dosage * 1000;
      }
      return dosage;
    }

    function timeUnit(half, half_unit) {
      if (half_unit === "mins") {
        half = half * 60;
      } else if (half_unit === "hrs") {
        half = half * 3600;
      } else if (half_unit === "days") {
        half = half * 86400;
      } else if (half_unit === "sec") {
        half = half;
      }
      return half;
    }

    function otherTime(half_one, half_sec, half_unit) {
      let half = 0;
      if (half_unit === "hrs/min") {
        half = half_one * 3600 + half_sec * 60;
      } else if (half_unit === "min/sec") {
        half = half_one * 60 + half_sec;
      }
      return half;
    }

    let result = {};

    if (half_unit === "min/sec" || half_unit === "hrs/min") {
      if (isNaN(half_one) && isNaN(half_sec)) {
        result.error = "Please! Enter Input.";
        return result;
      }
      if (isNaN(half_one)) half_one = 0;
      if (isNaN(half_sec)) half_sec = 0;

      if (!isNaN(dosage)) {
        half = otherTime(half_one, half_sec, half_unit);
        if (half === 0) {
          result.error = "Half life value cannot be equal to zero.";
          return result;
        }

        let time_convert = half_unit === "min/sec" ? half / 60 : half / 3600;

        let answer = +time_convert.toFixed(3);
        let answer_one = +(answer + answer).toFixed(2);
        let answer_two = +(answer_one + answer).toFixed(2);
        let answer_three = +(answer_two + answer).toFixed(2);
        let answer_four = +(answer_three + answer).toFixed(2);
        let answer_five = +(answer_four + answer).toFixed(2);

        let subanswer = secUnit(dosage, dosage_unit) / 2;
        let subanswer_one = subanswer / 2;
        let subanswer_sec = subanswer_one / 2;
        let subanswer_three = subanswer_sec / 2;
        let subanswer_four = subanswer_three / 2;
        let subanswer_five = subanswer_four / 2;

        result = {
          tech_subanswer: subanswer,
          tech_subanswer_one: subanswer_one,
          tech_subanswer_sec: subanswer_sec,
          tech_subanswer_three: subanswer_three,
          tech_subanswer_four: subanswer_four,
          tech_subanswer_five: subanswer_five,
          tech_answer: answer,
          tech_answer_one: answer_one,
          tech_answer_two: answer_two,
          tech_answer_three: answer_three,
          tech_answer_four: answer_four,
          tech_answer_five: answer_five,
        };
      } else {
        result.error = "Please! Check Your Input.";
        return result;
      }
    } else {
      if (!isNaN(half) && !isNaN(dosage)) {
        if (half === 0) {
          result.error = "Half life value cannot be equal to zero.";
          return result;
        }

        if (half_unit === "mins") {
          half = timeUnit(half, half_unit);
          time_convert = half / 60;
        } else if (half_unit === "hrs") {
          half = timeUnit(half, half_unit);
          time_convert = half / 3600;
        } else if (half_unit === "days") {
          half = timeUnit(half, half_unit);
          time_convert = half / 86400;
        } else if (half_unit === "sec") {
          half = timeUnit(half, half_unit);
          time_convert = half;
        }

        let answer = +time_convert.toFixed(3);
        let answer_one = +(answer + answer).toFixed(2);
        let answer_two = +(answer_one + answer).toFixed(2);
        let answer_three = +(answer_two + answer).toFixed(2);
        let answer_four = +(answer_three + answer).toFixed(2);
        let answer_five = +(answer_four + answer).toFixed(2);

        let subanswer = secUnit(dosage, dosage_unit) / 2;
        let subanswer_one = subanswer / 2;
        let subanswer_sec = subanswer_one / 2;
        let subanswer_three = subanswer_sec / 2;
        let subanswer_four = subanswer_three / 2;
        let subanswer_five = subanswer_four / 2;

        result = {
          tech_subanswer: subanswer,
          tech_subanswer_one: subanswer_one,
          tech_subanswer_sec: subanswer_sec,
          tech_subanswer_three: subanswer_three,
          tech_subanswer_four: subanswer_four,
          tech_subanswer_five: subanswer_five,
          tech_answer: answer,
          tech_answer_one: answer_one,
          tech_answer_two: answer_two,
          tech_answer_three: answer_three,
          tech_answer_four: answer_four,
          tech_answer_five: answer_five,
        };
      } else {
        result.error = "Please! Check Your Input.";
        return result;
      }
    }

    return result;
  }

  /**
   * getCalculationMacroCalculator: Service Method
   * POST: /api/calculators-lol/macro-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMacroCalculator(body) {
    let check = true;

    // Check all input fields except ignored ones
    for (let key in body) {
      if (
        key !== "tech_height_ft" &&
        key !== "tech_height_in" &&
        key !== "tech_height_cm" &&
        key !== "tech_submit" &&
        key !== "tech_percent" &&
        key !== "/macro-calculator/"
      ) {
        if (!body[key]) {
          check = false;
        }
      }
    }

    let heightFt = parseFloat(body["tech_height_ft"]);
    let heightIn = parseFloat(body["tech_height_in"]);
    let heightCm = parseFloat(body["tech_height_cm"]);

    if (isNaN(heightFt) && isNaN(heightIn) && isNaN(heightCm)) {
      check = false;
    }

    let result = {};

    if (check === true) {
      let age = parseFloat(body.tech_age);
      let weight = parseFloat(body.tech_weight);
      let unit = body.tech_unit;
      let unitFtIn = body.tech_unit_ft_in;
      let gender = body.tech_gender;
      let formula = body.tech_formula;
      let percent = body.tech_percent ? parseFloat(body.tech_percent) : null;
      let activity = body.tech_activity;
      let goal = body.tech_goal;
      let meal = body.tech_meal;

      if (unit === "lbs") {
        weight = weight / 2.205;
      }

      if (unitFtIn === "ft/in") {
        heightCm = heightFt * 30.48;
        if (heightIn) {
          heightCm += heightIn * 2.54;
        }
      }

      let BMR = 0;
      let sugar = gender === "Female" ? 25 : 37.5;

      if (gender === "Female") {
        if (formula === "first") {
          BMR = Math.round(10 * weight + 6.25 * heightCm - 5 * age - 161);
        } else if (formula === "2nd") {
          BMR = Math.round(
            9.247 * weight + 3.098 * heightCm - 4.33 * age + 447.593
          );
        } else {
          if (!percent) {
            result.error = "Please fill required fields.";
            return result;
          }
          BMR = Math.round(370 + 21.6 * (1 - percent / 100) * weight);
        }
      } else {
        // Male
        if (formula === "first") {
          BMR = Math.round(10 * weight + 6.25 * heightCm - 5 * age + 5);
        } else if (formula === "2nd") {
          BMR = Math.round(
            13.397 * weight + 4.799 * heightCm - 5.677 * age + 88.362
          );
        } else {
          if (!percent) {
            result.error = "Please fill required fields.";
            return result;
          }
          BMR = Math.round(370 + 21.6 * (1 - percent / 100) * weight);
        }
      }

      let tdee = 0;

      if (activity === "Sedentary") {
        tdee = Math.round(BMR * 1.2);
      } else if (activity === "Lightly Active") {
        tdee = Math.round(BMR * 1.375);
      } else if (activity === "Moderately Active") {
        tdee = Math.round(BMR * 1.465);
      } else if (activity === "Very Active") {
        tdee = Math.round(BMR * 1.725);
      } else {
        tdee = Math.round(BMR * 1.9);
      }

      if (goal === "Fat Loss") {
        tdee = tdee - 500;
      } else if (goal === "Loss 10%") {
        tdee = tdee * 0.1;
      } else if (goal === "Maintain") {
        tdee = tdee * 1;
      } else {
        tdee = tdee * 1.1;
      }

      if (meal !== "all") {
        tdee = Math.round(tdee / parseInt(meal));
        sugar = Math.round(sugar / parseInt(meal));
      }

      let stand_fat = Math.round((tdee * 0.1) / 9);

      result.tech_calories = tdee;
      result.tech_Sugar = sugar;
      result.tech_stand_fat = stand_fat;

      return result;
    } else {
      result.error = "Please fill All fields.";
      return result;
    }
  }

  /**
   * getCalculationMealCalorieCalculator: Service Method
   * POST: /api/calculators-lol/meal-calorie-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMealCalorieCalculator(body) {
    let calorie = body.tech_calorie;
    let meals = body.tech_meals;

    const parsedCalorie = parseFloat(calorie);
    let response = {};

    if (!isNaN(parsedCalorie)) {
      if (meals === "3") {
        const b_f = Math.round((32.5 / 100) * parsedCalorie);
        const lanch = Math.round((37.5 / 100) * parsedCalorie);
        const dinner = Math.round((30 / 100) * parsedCalorie);
        response = {
          tech_b_f: b_f,
          tech_lanch: lanch,
          tech_dinner: dinner,
        };
      } else if (meals === "4") {
        const b_f = Math.round((27.5 / 100) * parsedCalorie);
        const m_s = Math.round((7.5 / 100) * parsedCalorie);
        const lanch = Math.round((37.5 / 100) * parsedCalorie);
        const dinner = Math.round((27.5 / 100) * parsedCalorie);
        response = {
          tech_b_f: b_f,
          tech_m_s: m_s,
          tech_lanch: lanch,
          tech_dinner: dinner,
        };
      } else if (meals === "5") {
        const b_f = Math.round((27.5 / 100) * parsedCalorie);
        const m_s = Math.round((7.5 / 100) * parsedCalorie);
        const lanch = Math.round((37.5 / 100) * parsedCalorie);
        const a_n = Math.round((7.5 / 100) * parsedCalorie);
        const dinner = Math.round((27.5 / 100) * parsedCalorie);
        response = {
          tech_b_f: b_f,
          tech_m_s: m_s,
          tech_lanch: lanch,
          tech_a_n: a_n,
          tech_dinner: dinner,
        };
      } else {
        response = { error: "Invalid number of meals. Choose 3, 4, or 5." };
      }
    } else {
      response = { error: "Please Fill All Fields." };
    }

    return response;
  }

  /**
   * getCalculationTargetHeartRateCalculator: Service Method
   * POST: /api/calculators-lol/target-heart-rate-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationTargetHeartRateCalculator(body) {
    let method = body.tech_method;
    let age = body.tech_age;
    let formula = body.tech_formula;
    let percent = body.tech_percent;
    let rhr = body.tech_rhr;
    let rhrm = body.tech_rhrm;
    let hrr = body.tech_hrr;
    let inputMhr = body.tech_mhr;

    let mhr;

    // Main MHR calculation based on formula if method is NOT 3
    if (method !== "3" && !isNaN(age)) {
      const ageNum = parseFloat(age);
      switch (parseInt(formula)) {
        case 1:
          mhr = 220 - ageNum;
          break;
        case 2:
          mhr = 226 - ageNum;
          break;
        case 3:
          mhr = 205.8 - 0.685 * ageNum;
          break;
        case 4:
          mhr = 206.3 - 0.711 * ageNum;
          break;
        case 5:
          mhr = 217 - 0.85 * ageNum;
          break;
        case 6:
          mhr = 208 - 0.7 * ageNum;
          break;
        case 7:
          mhr = 206.9 - 0.67 * ageNum;
          break;
        case 8:
          mhr = 211 - 0.64 * ageNum;
          break;
        case 9:
          mhr = 203.7 / (1 + Math.exp(0.033 * (ageNum - 104.3)));
          break;
        case 10:
          mhr = 190.2 / (1 + Math.exp(0.0453 * (ageNum - 107.5)));
          break;
        case 11:
          mhr = 206 - 0.88 * ageNum;
          break;
        default:
          mhr = 220 - ageNum;
      }
    } else {
      mhr = 220 - parseFloat(age);
    }

    let response = {};

    if (method === "1") {
      if (!isNaN(age) && !isNaN(percent)) {
        response = {
          tech_mhr: mhr,
        };
      } else {
        response = { error: "Please fill All fields." };
      }
    } else if (method === "2") {
      if (!isNaN(age) && !isNaN(rhr) && !isNaN(percent)) {
        response = {
          tech_mhr: mhr,
          tech_rhr: parseFloat(rhr),
        };
      } else {
        response = { error: "Please fill All fields." };
      }
    } else if (method === "3") {
      if (!isNaN(inputMhr) && !isNaN(rhrm) && !isNaN(percent)) {
        response = {
          tech_mhr: parseFloat(inputMhr),
          tech_rhr: parseFloat(rhr),
        };
      } else {
        response = { error: "Please fill All fields." };
      }
    } else if (method === "4") {
      if (!isNaN(age) && !isNaN(hrr) && !isNaN(percent)) {
        const rhrCalculated = mhr - parseFloat(hrr);
        response = {
          tech_mhr: mhr,
          tech_rhr: rhrCalculated,
        };
      } else {
        response = { error: "Please fill All fields." };
      }
    }

    return response;
  }

  /**
   * getCalculationWilksCalculator: Service Method
   * POST: /api/calculators-lol/wilks-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationWilksCalculator(body) {
    let sex = body.tech_sex;
    let method = body.tech_method;
    let bw = body.tech_bw;
    let unit = body.tech_unit;
    let bp = body.tech_bp;
    let bp_reps = body.tech_bp_reps;
    let bs = body.tech_bs;
    let bs_reps = body.tech_bs_reps;
    let dl = body.tech_dl;
    let dl_reps = body.tech_dl_reps;
    let wl = body.tech_wl;

    let response = {};

    if (
      !isNaN(bw) &&
      !isNaN(bp) &&
      !isNaN(bs) &&
      !isNaN(dl) &&
      !isNaN(wl) &&
      !isNaN(bp_reps) &&
      !isNaN(bs_reps) &&
      !isNaN(dl_reps) &&
      sex &&
      method &&
      unit
    ) {
      let weightBw = parseFloat(bw);
      let weightWl = parseFloat(wl);
      let weightBp = parseFloat(bp);
      let weightBs = parseFloat(bs);
      let weightDl = parseFloat(dl);

      if (method === "au") {
        if (unit === "lbs") {
          weightBw *= 0.4536;
          weightWl *= 0.4536;
          response.lb = parseFloat(weightBw.toFixed(2));
          response.lb1 = parseFloat(weightWl.toFixed(2));
        }

        if (!isNaN(weightBw) && !isNaN(weightWl)) {
          let ws_cal, ws;

          if (sex === "male") {
            ws_cal =
              500 /
              (-216.0475144 +
                16.2606339 * weightBw +
                -0.002388645 * Math.pow(weightBw, 2) +
                -0.00113732 * Math.pow(weightBw, 3) +
                0.00000701863 * Math.pow(weightBw, 4) +
                -1.291e-8 * Math.pow(weightBw, 5));
          } else if (sex === "female") {
            ws_cal =
              500 /
              (594.31747775582 +
                -27.23842536447 * weightBw +
                0.82112226871 * Math.pow(weightBw, 2) +
                -0.00930733913 * Math.pow(weightBw, 3) +
                0.00004731582 * Math.pow(weightBw, 4) +
                -9.054e-8 * Math.pow(weightBw, 5));
          }

          ws = weightWl * ws_cal;
          response.tech_ws_cal = parseFloat(ws_cal.toFixed(3));
          response.tech_ws = parseFloat(ws.toFixed(2));
        } else {
          response.error = "Please Fill All The Fields.";
        }
      } else if (method === "sep") {
        if (unit === "lbs") {
          weightBw *= 0.4536;
          weightBp *= 0.4536;
          weightBs *= 0.4536;
          weightDl *= 0.4536;
          response.lb = parseFloat(weightBw.toFixed(2));
        }

        if (
          !isNaN(weightBw) &&
          !isNaN(weightBp) &&
          !isNaN(weightBs) &&
          !isNaN(weightDl)
        ) {
          const bpw = weightBp * (1 + bp_reps / 30);
          const bsw = weightBs * (1 + bs_reps / 30);
          const dlw = weightDl * (1 + dl_reps / 30);
          let fw = bpw + bsw + dlw;
          let ws_cal, ws;

          if (sex === "male") {
            ws_cal =
              500 /
              (-216.0475144 +
                16.2606339 * weightBw +
                -0.002388645 * Math.pow(weightBw, 2) +
                -0.00113732 * Math.pow(weightBw, 3) +
                0.00000701863 * Math.pow(weightBw, 4) +
                -1.291e-8 * Math.pow(weightBw, 5));
          } else if (sex === "female") {
            ws_cal =
              500 /
              (594.31747775582 +
                -27.23842536447 * weightBw +
                0.82112226871 * Math.pow(weightBw, 2) +
                -0.00930733913 * Math.pow(weightBw, 3) +
                0.00004731582 * Math.pow(weightBw, 4) +
                -9.054e-8 * Math.pow(weightBw, 5));
          }

          ws = fw * ws_cal;
          response.lb1 = parseFloat(fw.toFixed(2));
          if (unit === "lbs") fw = fw / 0.4536;
          response.tech_ws_cal = parseFloat(ws_cal.toFixed(3));
          response.tech_ws = parseFloat(ws.toFixed(2));
          response.tech_fw = parseFloat(fw.toFixed(2));
        } else {
          response.error = "Please Fill All The Fields.";
        }
      }
    } else {
      response.error = "Please! Check Your Input.";
    }

    return response;
  }

  /**
   * getCalculationAlleleFrequencyCalculator: Service Method
   * POST: /api/calculators-lol/allele-frequency-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationAlleleFrequencyCalculator(body) {
    let type = body.tech_type;
    let operations = body.tech_operations;
    let first = body.tech_first;
    let second = body.tech_second;
    let third = body.tech_third;
    let four = body.tech_four;

    let response = {};
    let pfreq, qfreq, p_square, q_square, p_q;

    if (type === "frst") {
      if (!isNaN(first) && !isNaN(second) && !isNaN(third)) {
        const mul1 = 0.5 * second;
        const downAdd =
          parseFloat(first) + parseFloat(second) + parseFloat(third);
        const p = parseFloat(first) + mul1;
        const q = parseFloat(third) + mul1;
        pfreq = p / downAdd;
        qfreq = q / downAdd;
      } else {
        response.error = "Please! Check Your Input.";
        return response;
      }
    } else if (type === "scnd") {
      if (operations === 1 || operations === 2) {
        if (!isNaN(four)) {
          if (four > 1) {
            const f_ans = 100 / four;
            const div = 1 / f_ans;
            qfreq = Math.sqrt(div);

            const A = 1;
            const B = 2 * qfreq;
            const q_sq = Math.pow(qfreq, 2);
            const C = q_sq - 1;
            const dis = Math.pow(B, 2) - 4 * A * C;

            if (dis > 0) {
              const x1 = (-B + Math.sqrt(dis)) / (2 * A);
              const x2 = (-B - Math.sqrt(dis)) / (2 * A);
              pfreq = Math.max(x1, x2);
            } else if (dis < 0) {
              // Complex roots (the original Laravel code turns them into strings)
              const realPart = -B / (2 * A);
              const imagPart = Math.sqrt(-dis) / (2 * A);
              const x1 = `${realPart} + ${imagPart}`;
              const x2 = `${realPart} - ${imagPart}`;
              pfreq = x1; // You could choose to return both as well
            } else {
              pfreq = -B / (2 * A);
            }

            response.tech_f_ans = f_ans;
          } else {
            response.error =
              "Occurrence of the disease must be greater than 1 in 1 person.";
            return response;
          }
        } else {
          response.error = "Please! Check Your Input.";
          return response;
        }
      }
    }

    if (
      pfreq !== undefined &&
      qfreq !== undefined &&
      !isNaN(pfreq) &&
      !isNaN(qfreq)
    ) {
      p_square = Math.pow(pfreq, 2);
      q_square = Math.pow(qfreq, 2);
      p_q = 2 * pfreq * qfreq;
    }

    response.tech_pfreq = pfreq;
    response.tech_qfreq = qfreq;
    response.tech_p_square = p_square;
    response.tech_q_square = q_square;
    response.tech_p_q = p_q;
    response.tech_type = body.tech_type;
    response.tech_operations = body.tech_operations;
    response.tech_first = body.tech_first;
    response.tech_second = body.tech_second;
    response.tech_third = body.tech_third;
    response.tech_four = body.tech_four;

    return response;
  }

  /**
   * getCalculationWeightWatchersPointsCalculator: Service Method
   * POST: /api/calculators-lol/weight-watchers-points-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationWeightWatchersPointsCalculator(body) {
    let fe = body.tech_fe;
    let fe_unit = body.tech_fe_unit;
    let sf = body.tech_sf;
    let sf_unit = body.tech_sf_unit;
    let sgr = body.tech_sgr;
    let sgr_unit = body.tech_sgr_unit;
    let ptn = body.tech_ptn;
    let ptn_unit = body.tech_ptn_unit;
    let ptn2 = body.tech_ptn2;
    let ptn2_unit = body.tech_ptn2_unit;
    let carbo = body.tech_carbo;
    let carbo_unit = body.tech_carbo_unit;
    let fat = body.tech_fat;
    let fat_unit = body.tech_fat_unit;
    let fiber = body.tech_fiber;
    let fiber_unit = body.tech_fiber_unit;
    let fat2 = body.tech_fat2;
    let fat2_unit = body.tech_fat2_unit;
    let fiber2 = body.tech_fiber2;
    let fiber2_unit = body.tech_fiber2_unit;
    let call2 = body.tech_call2;
    let call2_unit = body.tech_call2_unit;
    let selection = body.tech_selection;
    let weight = body.tech_weight;
    let weight_unit = body.tech_weight_unit;
    let height = body.tech_height;
    let height_unit = body.tech_height_unit;
    let age = body.tech_age;
    let gender = body.tech_gender;
    let activity = body.tech_activity;

    let response = {};
    let ans;

    // Convert energy units
    if (fe_unit === "cal") fe_unit = 1;
    else if (fe_unit === "kJ") fe_unit = 0.239006;
    else if (fe_unit === "J") fe_unit = 0.1434;

    if (call2_unit === "cal") call2_unit = 1;
    else if (call2_unit === "kJ") call2_unit = 0.239006;
    else if (call2_unit === "J") call2_unit = 0.1434;

    // Convert weight units
    if (weight_unit === "kg") weight_unit = 1;
    else if (weight_unit === "lbs") weight_unit = 0.453592;

    // Convert height units
    if (height_unit === "in") height_unit = 0.0254;
    else if (height_unit === "cm") height_unit = 1;

    function convertGrams(unit, value) {
      if (unit === "mg") return value / 1000;
      if (unit === "g") return value;
      if (unit === "kg") return value / 0.001;
      if (unit === "oz") return value / 0.03527396194958;
      if (unit === "lbs") return value / 0.002204622621849;
      if (unit === "dr") return value / 0.5643833911933;
      if (unit === "gr") return value / 15.43235835294;
      return value;
    }

    // Method 1
    if (selection === "1") {
      if (
        !isNaN(fe) &&
        !isNaN(sf) &&
        !isNaN(sgr) &&
        !isNaN(ptn) &&
        fe > 0 &&
        sf > 0 &&
        sgr > 0
      ) {
        const fev = fe_unit * fe;
        const sfv = convertGrams(sf_unit, sf);
        const sgrv = convertGrams(sgr_unit, sgr);
        const ptnv = convertGrams(ptn_unit, ptn);
        ans = Math.round(
          fev * 0.0305 + sfv * 0.275 + sgrv * 0.12 - ptnv * 0.098
        );
      } else {
        response.error = "Please! Check Your Input.";
        return response;
      }
    }

    // Method 2
    else if (selection === "2") {
      if (
        !isNaN(ptn2) &&
        !isNaN(fat) &&
        !isNaN(fiber) &&
        !isNaN(carbo) &&
        ptn2 > 0 &&
        fat > 0 &&
        fiber > 0 &&
        carbo > 0
      ) {
        const ptn2_val = convertGrams(ptn2_unit, ptn2);
        const fatv = convertGrams(fat_unit, fat);
        const fiberv = convertGrams(fiber_unit, fiber);
        const carbov = convertGrams(carbo_unit, carbo);
        ans = Math.round(
          fatv / 3.8889 + carbov / 9.2105 + ptn2_val / 10.9375 - fiberv / 12.5
        );
      } else {
        response.error = "Please! Check Your Input.";
        return response;
      }
    }

    // Method 3
    else if (selection === "3") {
      if (
        !isNaN(fat2) &&
        !isNaN(fiber2) &&
        !isNaN(call2) &&
        fat2 > 0 &&
        fiber2 > 0 &&
        call2 > 0
      ) {
        let fat2v = convertGrams(fat2_unit, fat2);
        let fiber2v = convertGrams(fiber2_unit, fiber2);
        let call2v = call2_unit * call2;
        if (fiber2v > 4) fiber2v = 4;
        ans = Math.round(call2v / 50 + fat2v / 12 - fiber2v / 5);
      } else {
        response.error = "Please! Check Your Input.";
        return response;
      }
    }

    // Method 4
    else if (selection === "4") {
      if (!isNaN(height) && !isNaN(weight) && !isNaN(age)) {
        if (age >= 19) {
          let base, agefact, actfact, wgtfact, hgtfact;

          if (gender === "male") {
            base = 864;
            agefact = 9.72;
            actfact = 1.12;
            wgtfact = 14.2;
            hgtfact = 503;
          } else {
            base = 387;
            agefact = 7.31;
            actfact = 1.14;
            wgtfact = 10.9;
            hgtfact = 660.7;
          }

          const totage = age * agefact;
          const wgtKG = weight * weight_unit;
          const totwgt = wgtKG * wgtfact;
          const hgtCM = height * height_unit;
          const tothgt = hgtCM * hgtfact;

          const tee1 = (totwgt + tothgt) * actfact;
          const tee2 = base - totage + tee1;
          const atee1 = tee2 * 0.1 - 200;
          const atee2 = tee2 - atee1;
          const targ1 = (atee2 - 1000) / 35;

          ans = Math.round(targ1 - 11);

          if (ans <= 26) ans = 26;
          else if (ans >= 71) ans = 71;

          if (activity === "1") ans += 0;
          else if (activity === "2") ans += 3;
          else if (activity === "3") ans += 6;
          else if (activity === "4") ans += 9;
        } else {
          response.error = "This calculator is for people aged 19 or older.";
          return response;
        }
      } else {
        response.error = "Please! Check Your Input.";
        return response;
      }
    }

    response.tech_method = selection;
    response.tech_ans = ans;
    return response;
  }

  /**
   * getCalculationProteinCalculator: Service Method
   * POST: /api/calculators-lol/protein-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationProteinCalculator(body) {
    let age = body.tech_age;
    let gender = body.tech_gender;
    let weight = body.tech_weight;
    let weight_unit = body.tech_weight_unit;
    let activity_level = body.tech_activity_level;
    let protein_for = body.tech_protein_for;
    let height_ft = body.tech_height_ft;
    let height_in = body.tech_height_in;
    let height_cm = body.tech_height_cm;
    let h_unit = body.tech_unit_ft_in;

    const convertToCm = (unit, value) => {
      switch (unit) {
        case "cm":
          return value;
        case "in":
          return value * 2.54;
        case "m":
          return value * 100;
        case "ft":
          return value * 30.48;
        default:
          return null;
      }
    };

    const convertToKg = (unit, value) => {
      switch (unit) {
        case "g":
          return value / 1000;
        case "kg":
          return value;
        case "lb":
          return value / 2.205;
        case "stone":
          return value * 6.35;
        default:
          return null;
      }
    };

    if (h_unit === "ft/in") {
      if (isNaN(height_ft) || isNaN(height_in)) {
        return { error: "Please! Check your input." };
      }
      height_cm = height_ft * 30.48 + height_in * 2.54;
    } else {
      if (isNaN(height_cm)) {
        return { error: "Please! Check your input." };
      }
      height_cm = convertToCm(h_unit, height_cm);
    }

    if (!isNaN(age) && !isNaN(weight)) {
      const weight_kg = convertToKg(weight_unit, weight);
      let BMR;

      if (gender === "male") {
        BMR = 10 * weight_kg + 6.25 * height_cm - 5 * age + 5;
      } else {
        BMR = 10 * weight_kg + 6.25 * height_cm - 5 * age - 161;
      }

      let multiplier;
      switch (activity_level) {
        case "sedentary":
          multiplier = 1.2;
          break;
        case "light":
          multiplier = 1.375;
          break;
        case "moderate":
          multiplier = 1.55;
          break;
        case "very_active":
          multiplier = 1.725;
          break;
        default:
          multiplier = 1.9;
          break;
      }

      const calories = BMR * multiplier;

      return {
        tech_calories: calories,
        tech_weight_kg: weight_kg,
      };
    } else {
      return { error: "Please! Check your input." };
    }
  }

  /**
   * getCalculationWeightGainCalculator: Service Method
   * POST: /api/calculators-lol/weight-gain-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationWeightGainCalculator(body) {
    let age = body.tech_age;
    let height_ft = body.tech_height_ft;
    let height_cm = body.tech_height_cm;
    let weight = body.tech_weight;
    let per_cal = body.tech_per_cal;
    let gender = body.tech_gender;
    let percent = body.tech_percent;
    let activity = body.tech_activity;
    let stype = body.tech_stype;
    let start = body.tech_start;
    let target = body.tech_target;
    let weight1 = body.tech_weight1;
    let surplus = body.tech_surplus;
    let kal_day = body.tech_kal_day;
    let submit = body.tech_unit_type;

    const want = "2";
    let unit, height_in;

    if (isNaN(age) || isNaN(weight) || isNaN(weight1) || !start || !target) {
      return { error: "Please fill All Fields." };
    }

    // Convert imperial to metric if needed
    if (submit === "imperial") {
      height_in = height_ft * 2.54;
      weight = weight / 2.205;
      weight1 = weight1 / 2.205;
      unit = "lb";
    } else {
      if (isNaN(height_cm)) {
        return { error: "Please enter height." };
      }
      height_in = height_cm;
      unit = "kg";
    }

    let BMR, tdee, Robinson, Miller, Devine, Hamwi;

    const round = (num) => Math.round(num);

    if (gender === "Male") {
      BMR = round(10 * round(weight) + 6.25 * round(height_cm) - 5 * age + 5);
      switch (activity) {
        case "sedentary":
          tdee = round(BMR * 1.1);
          break;
        case "Lightly_Active":
          tdee = round(BMR * 1.2);
          break;
        case "Moderately_Active":
          tdee = round(BMR * 1.4);
          break;
        case "Very_Active":
          tdee = round(BMR * 1.6);
          break;
        default:
          tdee = round(BMR * 1.8);
      }
      Robinson = round(49 + 1.7 * (height_in - 60));
      Miller = round(53.1 + 1.36 * (height_in - 60));
      Devine = round(45.5 + 2.3 * (height_in - 60));
      Hamwi = round(45 + 2.2 * (height_in - 60));
    } else {
      BMR = round(10 * weight + 6.25 * height_cm - 5 * age - 161);
      switch (activity) {
        case "sedentary":
          tdee = round(BMR * 1.1);
          break;
        case "Lightly_Active":
          tdee = round(BMR * 1.2);
          break;
        case "Moderately_Active":
          tdee = round(BMR * 1.4);
          break;
        case "Very_Active":
          tdee = round(BMR * 1.6);
          break;
        default:
          tdee = round(BMR * 1.8);
      }
      Robinson = round(52 + 1.9 * (height_in - 60));
      Miller = round(56.2 + 1.41 * (height_in - 60));
      Devine = round(50 + 2.3 * (height_in - 60));
      Hamwi = round(48 + 2.7 * (height_in - 60));
    }

    let lbm;
    if (percent) {
      lbm = (weight * (100 - percent)) / 100;
      BMR = round(370 + 21.6 * lbm);
    }

    const height_m = height_in / 39.37;
    const BMI = +(weight / (height_m * height_m)).toFixed(2);

    let you_are;
    if (BMI <= 18.5) you_are = "Underweight";
    else if (BMI <= 24.9) you_are = "Normal Weight";
    else if (BMI <= 29.9) you_are = "Overweight";
    else if (BMI <= 35) you_are = "Obesity";
    else you_are = "Severe Obesity";

    const ibw =
      submit === "imperial"
        ? `${round(Robinson * 2.205)}-${round(Hamwi * 2.205)} lbs`
        : `${Robinson}-${Hamwi} kg`;

    const startDate = new Date(start);
    const targetDate = new Date(target);

    if (startDate >= targetDate) {
      return { error: "Target Date must be later than start date." };
    }

    const days = Math.ceil((targetDate - startDate) / (1000 * 60 * 60 * 24));
    const pounds_daily = +(weight1 / days).toFixed(2);
    const high_risk_weight = pounds_daily > 0.3;

    let calories_gain;

    if (surplus === "custom") {
      calories_gain = stype === "Incal" ? kal_day : tdee * (per_cal / 100);
    } else {
      const surplusMap = {
        "0.10": 0.1,
        0.15: 0.15,
        "0.20": 0.2,
      };
      calories_gain = tdee * (surplusMap[surplus] || 0.2);
    }

    const calories_daily = round(tdee + calories_gain);
    const high_risk_calories = calories_daily < 1200;

    const goal =
      submit === "imperial"
        ? +(weight + weight1).toFixed(2)
        : +((weight + weight1) / 2.205).toFixed(2);

    const fat = round((calories_daily / 9) * 0.2);
    const po = round((calories_daily / 4) * 0.3);
    const cb = round((calories_daily / 4) * 0.5);

    return {
      tech_HighRiskWeight: high_risk_weight,
      tech_PoundsDaily: pounds_daily,
      tech_HighRiskCalories: high_risk_calories,
      tech_CaloriesDaily: calories_daily,
      tech_CaloriesLess: round(calories_gain),
      tech_Calories: tdee,
      tech_Goal: goal,
      tech_days: days,
      tech_BMR: BMR,
      tech_BMI: BMI,
      tech_you_are: you_are,
      tech_lbm: lbm,
      tech_ibw: ibw,
      tech_fat: fat,
      tech_po: po,
      tech_cb: cb,
      tech_want: want,
      tech_unit: unit,
    };
  }

  /**
   * getCalculationPediatricDoseCalculator: Service Method
   * POST: /api/calculators-lol/pediatric-dose-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPediatricDoseCalculator(body) {
    let dose = body.tech_dose;
    let dose_unit = body.tech_dose_unit;
    let dose_unit2 = body.tech_dose_unit2;
    let dose_unit3 = body.tech_dose_unit3;
    let bsa = body.tech_bsa;
    let weight = body.tech_weight;
    let weight_unit = body.tech_weight_unit;
    let mass = body.tech_mass;
    let mass_unit = body.tech_mass_unit;
    let per = body.tech_per;
    let per_unit = body.tech_per_unit;
    let dose_frequency = body.tech_dose_frequency;
    let type = body.tech_type;
    let child_age = body.tech_child_age;

    const quarter = (unit, value) => {
      const map = {
        qD: 1,
        BID: 2,
        TID: 3,
        QID: 4,
        "q8 hr": 3,
        "q6 hr": 4,
        "q4 hr": 6,
        "q3 hr": 8,
        "q2 hr": 12,
        "q1 hr": 24,
      };
      return value * (map[unit] || 1);
    };

    const quarter2 = (unit, value) => {
      const map = {
        qD: 1,
        BID: 2,
        TID: 3,
        QID: 4,
        "q8 hr": 3,
        "q6 hr": 4,
        "q4 hr": 6,
        "q3 hr": 8,
        "q2 hr": 12,
        "q1 hr": 24,
      };
      return value / (map[unit] || 1);
    };

    const mass_convert = (unit, value) => {
      const map = { mg: 1, µg: 0.001, g: 1000 };
      return value * (map[unit] || 1);
    };

    const milli_convert = (unit, value) => {
      const map = {
        ml: 1,
        "mm³": 0.001,
        "cm³": 1,
        "cu in": 16.387,
        cl: 10,
        cc: 0.1,
      };
      return value * (map[unit] || 1);
    };

    const weil = (unit, value) => {
      const map = {
        kg: 1,
        lbs: 0.4536,
        g: 0.001,
        dag: 0.01,
        oz: 0.02835,
      };
      return value * (map[unit] || 1);
    };

    const weil2 = (unit, value) => {
      const map = {
        kg: 2.2046,
        lbs: 1,
        g: 0.001,
        dag: 0.01,
        oz: 0.02835,
      };
      return value * (map[unit] || 1);
    };

    let param = {};
    let main_answer1, ans1, main_answer3, main_answer4;

    try {
      dose = parseFloat(dose);
      weight = parseFloat(weight);
      mass = parseFloat(mass);
      per = parseFloat(per);
      bsa = parseFloat(bsa);
      child_age = parseFloat(child_age);

      if (type === "first") {
        if (dose > 0 && weight > 0 && mass > 0 && per > 0) {
          let wv = weil(weight_unit, weight);
          let mv = mass_convert(mass_unit, mass);
          let perv = milli_convert(per_unit, per);

          if (["mg/kg", "mg/kg/day"].includes(dose_unit)) {
            main_answer1 = dose * wv;
          } else if (dose_unit === "mg/kg/dose") {
            main_answer1 = quarter(dose_frequency, dose * wv);
          } else if (["mcg/kg", "mcg/kg/day"].includes(dose_unit)) {
            main_answer1 = (dose * wv) / 1000;
          } else if (dose_unit === "mcg/kg/dose") {
            main_answer1 = quarter(dose_frequency, (dose * wv) / 1000);
          }
        } else {
          throw new Error("Please! Check your input.");
        }
      } else if (type === "second") {
        if (dose > 0 && bsa > 0 && mass > 0 && per > 0) {
          let mv = mass_convert(mass_unit, mass);
          let perv = milli_convert(per_unit, per);

          if (dose_unit2 === "mg/m²") {
            main_answer1 = dose * bsa;
          } else if (dose_unit2 === "mg/day") {
            main_answer1 = (dose * bsa) / 1.73;
          } else if (dose_unit2 === "mg/dose") {
            main_answer1 = quarter(dose_frequency, (dose * bsa) / 1.73);
          } else if (dose_unit2 === "mcg/m²") {
            main_answer1 = (dose * bsa) / 1000;
          } else if (dose_unit2 === "mcg/day") {
            main_answer1 = (dose * bsa) / 1.73 / 1000;
          } else if (dose_unit2 === "mcg/dose") {
            main_answer1 = quarter(dose_frequency, (dose * bsa) / 1.73 / 1000);
          }
        } else {
          throw new Error("Please! Check your input.");
        }
      } else if (type === "third") {
        if (dose > 0 && child_age > 0 && mass > 0 && per > 0) {
          let mv = mass_convert(mass_unit, mass);
          let perv = milli_convert(per_unit, per);

          if (dose_unit3 === "mg/day") {
            main_answer1 = dose * (child_age / (child_age + 12));
          } else if (dose_unit3 === "mg/dose") {
            main_answer1 = quarter(
              dose_frequency,
              dose * (child_age / (child_age + 12))
            );
          } else if (dose_unit3 === "mcg/day") {
            main_answer1 = (dose * (child_age / (child_age + 12))) / 1000;
          } else if (dose_unit3 === "mcg/dose") {
            main_answer1 = quarter(
              dose_frequency,
              (dose * (child_age / (child_age + 12))) / 1000
            );
          }
        } else {
          throw new Error("Please! Check your input.");
        }
      } else if (type === "fourth") {
        if (dose > 0 && weight > 0 && mass > 0 && per > 0) {
          let wv = weil2(weight_unit, weight);
          let mv = mass_convert(mass_unit, mass);
          let perv = milli_convert(per_unit, per);

          if (dose_unit3 === "mg/day") {
            main_answer1 = dose * (wv / 150);
          } else if (dose_unit3 === "mg/dose") {
            main_answer1 = quarter(dose_frequency, dose * (wv / 150));
          } else if (dose_unit3 === "mcg/day") {
            main_answer1 = (dose * (wv / 150)) / 1000;
          } else if (dose_unit3 === "mcg/dose") {
            main_answer1 = quarter(dose_frequency, (dose * (wv / 150)) / 1000);
          }
        } else {
          throw new Error("Please! Check your input.");
        }
      }

      ans1 = quarter2(dose_frequency, main_answer1);
      let mv = mass_convert(mass_unit, mass);
      let perv = milli_convert(per_unit, per);
      main_answer3 = mv / perv;
      let l = main_answer1 / main_answer3;
      main_answer4 = quarter2(dose_frequency, l);

      return {
        tech_mass: mass,
        tech_mass_unit: mass_unit,
        tech_per: per,
        tech_per_unit: per_unit,
        tech_ans1: ans1,
        tech_dose_frequency: dose_frequency,
        tech_main_answer1: main_answer1,
        tech_main_answer3: main_answer3,
        tech_main_answer4: main_answer4,
      };
    } catch (error) {
      return { error: error.message };
    }
  }

  /**
   * getCalculationMaintenanceCalorieCalculator: Service Method
   * POST: /api/calculators-lol/maintenance-calorie-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMaintenanceCalorieCalculator(body) {
    let unit_type = body.tech_unit_type;
    let gender = body.tech_gender;
    let age = body.tech_age;
    let ft_in = body.tech_ft_in;
    let height_cm = body.tech_height_cm;
    let weight = body.tech_weight;
    let activity = body.tech_activity;

    // Helper functions
    function round(value, decimals = 0) {
      return Number(Math.round(value + "e" + decimals) + "e-" + decimals);
    }

    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }

    let param = {};

    if (isNumeric(age) && isNumeric(weight) && gender && activity) {
      let weight_kg, height_in;

      if (unit_type === "lbs") {
        if (!ft_in) {
          return { error: "Please Select Height." };
        }
        weight_kg = weight / 2.205;
        height_cm = ft_in * 2.54;
      } else {
        if (!height_cm) {
          return { error: "Please Enter Height." };
        }
        weight_kg = weight;
      }

      let height_m = height_cm / 100;
      height_in = height_cm / 2.54;
      let weight_lbs = weight_kg * 2.205;
      let BMI = round(weight_kg / (height_m * height_m), 2);

      let rmr, BMR, tdee, Miller, Hamwi;

      if (gender === "Female") {
        rmr = round(655 + 9.6 * weight_kg + 1.8 * height_cm - 4.7 * age);
        BMR = round(height_cm * 6.25 + weight_kg * 10 - age * 5 - 161);
        Miller = round(53.1 + 1.36 * (height_in - 60));
        Hamwi = round(45 + 2.2 * (height_in - 60));
      } else {
        rmr = round(66 + 13.7 * weight_kg + 5 * height_cm - 6.8 * age);
        BMR = round(height_cm * 6.25 + weight_kg * 10 - age * 5 + 5);
        Miller = round(56.2 + 1.41 * (height_in - 60));
        Hamwi = round(48 + 2.7 * (height_in - 60));
      }

      const activityFactors = {
        Sedentary: 1.2,
        "Lightly Active": 1.375,
        "Moderately Active": 1.55,
        "Very Active": 1.725,
        "Extra Active": 1.9,
      };

      tdee = round(BMR * (activityFactors[activity] || 1.2));

      let ibwRange;
      if (unit_type === "lbs") {
        Miller = Miller * 2.205;
        Hamwi = Hamwi * 2.205;
      }

      if (Hamwi >= Miller) {
        ibwRange = `${round(Miller)}-${round(Hamwi)}`;
      } else {
        ibwRange = `${round(Hamwi)}-${round(Miller)}`;
      }

      let fat = round((tdee / 9) * 0.2);
      let po = round((tdee / 4) * 0.3);
      let cb = round((tdee / 4) * 0.5);

      param = {
        tech_Calories: tdee,
        tech_BMR: BMR,
        tech_rmr: rmr,
        tech_BMI: BMI,
        tech_ibw: ibwRange,
        tech_fat: fat,
        tech_po: po,
        tech_cb: cb,
        tech_submit: unit_type,
      };

      return param;
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /**
   * getCalculationBreastfeedingCalorieCalculator: Service Method
   * POST: /api/calculators-lol/breastfeeding-calorie-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBreastfeedingCalorieCalculator(body) {
    let unit_type = body.tech_unit_type;
    let age = body.tech_age;
    let ft_in = body.tech_ft_in;
    let height_cm = body.tech_height_cm;
    let weight = body.tech_weight;
    let activity = body.tech_activity;
    let bf = body.tech_bf;
    let pregnant = body.tech_pregnant;

    let param = {};

    // Trim string fields and convert numbers
    let submit = unit_type?.trim();
    age = parseFloat(age);
    weight = parseFloat(weight);
    ft_in = parseFloat(ft_in);
    height_cm = parseFloat(height_cm);
    activity = parseFloat(activity);
    bf = parseFloat(bf);
    pregnant = parseFloat(pregnant);

    let check = false;

    if (submit === "lbs" && isNumeric(age) && isNumeric(weight)) {
      check = true;
    } else if (
      submit === "kg" &&
      isNumeric(age) &&
      isNumeric(height_cm) &&
      isNumeric(weight)
    ) {
      check = true;
    }

    if (check) {
      if (submit === "lbs") {
        weight = weight * 0.45359237;
        height_cm = ft_in * 2.54;
      }

      let maintain = round(
        (10 * weight + 6.25 * height_cm - 5 * age - 161) * activity +
          bf +
          pregnant
      );
      let lose = maintain - 300;
      let supply = maintain - 500;

      param = {
        tech_maintain: maintain,
        tech_lose: lose,
        tech_supply: supply,
        tech_carbos1: round((maintain * 0.44) / 4),
        tech_carbos2: round((lose * 0.44) / 4),
        tech_proteins1: round((maintain * 0.26) / 4),
        tech_proteins2: round((lose * 0.26) / 4),
        tech_fats1: round((maintain * 0.25) / 9),
        tech_fats2: round((lose * 0.25) / 9),
      };

      return param;
    } else {
      return { error: "Please! Check Your Input." };
    }

    // Helper functions
    function round(value, decimals = 0) {
      return Number(Math.round(value + "e" + decimals) + "e-" + decimals);
    }

    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }
  }

  /**
   * getCalculationSwimmingCalorieCalculator: Service Method
   * POST: /api/calculators-lol/swimming-calorie-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationSwimmingCalorieCalculator(body) {
    let weight = body.tech_weight;
    let weight_unit = body.tech_weight_unit;
    let time = body.tech_time;
    let time_unit = body.tech_time_unit;
    let style = body.tech_style;

    // Trim and parse values
    weight = parseFloat(String(weight).trim());
    time = parseFloat(String(time).trim());
    style = parseFloat(String(style).trim());
    weight_unit = String(weight_unit).trim();
    time_unit = String(time_unit).trim();

    let param = {};
    // Helpers
    function round(value, decimals = 0) {
      return Number(Math.round(value + "e" + decimals) + "e-" + decimals);
    }

    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }
    // Validation
    if (!isNumeric(style) || !isNumeric(weight) || !weight_unit) {
      return { error: "Please! Check Your Inputs" };
    }

    if (!time_unit) {
      return { error: "Please! Check Your Inputs" };
    }

    if (!isNumeric(time)) {
      return { error: "Please! Check Your Inputs" };
    }

    // Conversion helpers
    function convertToKg(unit, value) {
      if (unit === "lb") return value / 2.205;
      if (unit === "kg") return value;
      if (unit === "stone") return value * 6.35;
      return NaN;
    }

    function convertToMin(unit, value) {
      if (unit === "sec") return value / 60;
      if (unit === "min") return value;
      if (unit === "hrs") return value * 60;
      return NaN;
    }

    const final_weight = convertToKg(weight_unit, weight);
    const final_min = convertToMin(time_unit, time);

    if (!isNumeric(final_weight) || !isNumeric(final_min)) {
      return { error: "Conversion failed. Invalid input units." };
    }

    const cal_burned_per_min = (style * final_weight * 3.5) / 200;
    const total_cal_burned = cal_burned_per_min * final_min;

    param.tech_cal_burned_per_min = round(cal_burned_per_min, 2);
    param.tech_total_cal_burned = round(total_cal_burned, 2);

    return param;
  }

  /**
   * getCalculationDistanceCalculator: Service Method
   * POST: /api/calculators-lol/distance-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDistanceCalculator(body) {
    let submit = body.tech_submit;

    let lat1 = body.tech_lat1;
    let long1 = body.tech_long1;
    let lat2 = body.tech_lat2;
    let long2 = body.tech_long2;

    let deg1 = body.tech_deg1;
    let mint1 = body.tech_mint1;
    let sec1 = body.tech_sec1;
    let dir1 = body.tech_dir1;

    let deg2 = body.tech_deg2;
    let mint2 = body.tech_mint2;
    let sec2 = body.tech_sec2;
    let dir2 = body.tech_dir2;

    let deg21 = body.tech_deg21;
    let mint21 = body.tech_mint21;
    let sec21 = body.tech_sec21;
    let dir21 = body.tech_dir21;

    let deg22 = body.tech_deg22;
    let mint22 = body.tech_mint22;
    let sec22 = body.tech_sec22;
    let dir22 = body.tech_dir22;

    let to_cal = body.tech_to_cal;

    let param = {};

    const findDistance = (lat1, lon1, lat2, lon2) => {
      const theta = lon1 - lon2;
      let dist =
        Math.sin(degToRad(lat1)) * Math.sin(degToRad(lat2)) +
        Math.cos(degToRad(lat1)) *
          Math.cos(degToRad(lat2)) *
          Math.cos(degToRad(theta));
      dist = Math.acos(dist);
      dist = radToDeg(dist);
      const miles = dist * 60 * 1.1515;
      return miles;
    };

    const ConvertDMSToDD = (degrees, minutes, seconds, direction) => {
      let dd = Number(degrees) + Number(minutes) / 60 + Number(seconds) / 3600;
      if (direction === "S" || direction === "W") {
        dd *= -1;
      }
      return dd;
    };

    const degToRad = (deg) => (deg * Math.PI) / 180;
    const radToDeg = (rad) => (rad * 180) / Math.PI;

    if (to_cal === "decimal") {
      if (submit) {
        const miles = findDistance(
          Number(lat1),
          Number(long1),
          Number(lat2),
          Number(long2)
        );
        param.tech_mile = miles;
        param.tech_km = miles * 1.609344;
      } else {
        param.error = "Please! Check Your Input";
      }
    } else {
      if (submit) {
        const lat1_dd = ConvertDMSToDD(deg1, mint1, sec1, dir1);
        const long1_dd = ConvertDMSToDD(deg2, mint2, sec2, dir2);
        const lat2_dd = ConvertDMSToDD(deg21, mint21, sec21, dir21);
        const long2_dd = ConvertDMSToDD(deg22, mint22, sec22, dir22);
        const miles = findDistance(lat1_dd, long1_dd, lat2_dd, long2_dd);
        param.tech_mile = miles;
        param.tech_km = miles * 1.609344;
      } else {
        param.error = "Please! Check Your Input";
      }
    }

    return param;
  }

  /**
   * getCalculationErACalculator: Service Method
   * POST: /api/calculators-lol/era-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationErACalculator(body) {
    let x = body.tech_x;
    let y = body.tech_y;
    let z = body.tech_z;
    let g = body.tech_g;

    let param = {};

    if (!isNaN(x) || !isNaN(y) || !isNaN(z)) {
      const earn_run = Number(x);
      let inning = Number(y);
      const game = g !== undefined && g !== "" ? Number(g) : 9;

      if (z !== undefined && z !== "") {
        inning = Number(y) + Number(z) / 3;
      }

      const era = parseFloat(((earn_run / inning) * game).toFixed(3));
      param.tech_era = era;
    } else {
      param.error = "Please! Fill all the Input Fields";
    }

    return param;
  }

  /**
   * getCalculationAgeDifferenceCalculator: Service Method
   * POST: /api/calculators-lol/vorici-chromatic-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationVoriciChromaticCalculator(body) {
    let submit = body.tech_submit;
    let s_f = body.tech_s_f;
    let str_f = body.tech_str_f;
    let dex_f = body.tech_dex_f;
    let int_f = body.tech_int_f;
    let r_f = body.tech_r_f;
    let g_f = body.tech_g_f;
    let b_f = body.tech_b_f;

    let param = {};

    if (submit) {
      // Ensure that all input fields are provided
      param.tech_s_f = s_f;
      param.tech_str_f = str_f;
      param.tech_dex_f = dex_f;
      param.tech_int_f = int_f;
      param.tech_r_f = r_f;
      param.tech_g_f = g_f;
      param.tech_b_f = b_f;
    } else {
      param.error = "Please! Fill all the Input Fields";
    }

    return param;
  }

  /**
   * getCalculationAspectRatioCalculator: Service Method
   * POST: /api/calculators-lol/aspect-ratio-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAspectRatioCalculator(body) {
    let ratios = body.tech_ratios;
    let w1 = body.tech_w1;
    let h1 = body.tech_h1;
    let w2 = body.tech_w2;
    let h2 = body.tech_h2;

    // Trim string values
    ratios = ratios?.trim();
    w1 = w1?.toString().trim();
    h1 = h1?.toString().trim();
    w2 = w2?.toString().trim();
    h2 = h2?.toString().trim();

    w1 = parseFloat(w1);
    h1 = parseFloat(h1);
    w2 = parseFloat(w2);
    h2 = parseFloat(h2);

    const response = {};

    if (!isNaN(w1) && !isNaN(h1)) {
      function gcd(a, b) {
        if (b === 0) return a;
        return gcd(b, a % b);
      }

      function reduceRatio(numerator, denominator) {
        if (numerator === denominator) return "1 : 1";
        const divisor = gcd(numerator, denominator);
        let left = numerator / divisor;
        let right = denominator / divisor;
        if (left == 8 && right == 5) {
          left = 16;
          right = 10;
        }
        return `${left} : ${right}`;
      }

      function solve(width, height, numerator, denominator) {
        if (!isNaN(width)) {
          return Math.round(width / (numerator / denominator));
        } else if (!isNaN(height)) {
          return Math.round(height * (numerator / denominator));
        } else {
          return "";
        }
      }

      function ratio2css(numerator, denominator) {
        let width = "";
        let height = "";
        if (numerator > denominator) {
          width = 200;
          height = solve(width, "", numerator, denominator);
        } else {
          height = 200;
          width = solve("", height, numerator, denominator);
        }
        return `width:${Math.round(width)}px;height:${Math.round(
          height
        )}px;line-height:${Math.round(height)}px`;
      }

      let x1v = w1;
      let y1v = h1;
      let stop = 0;
      const maxIterations = 10;
      while (!Number.isInteger(x1v) || !Number.isInteger(y1v)) {
        x1v *= 10;
        y1v *= 10;
        ++stop;
        if (stop > maxIterations) break;
      }

      if (!isNaN(w2) && isNaN(h2)) {
        h2 = (h1 / w1) * w2;
        response.tech_check = "h2";
        response.tech_ans = Math.round(h2 * 1000) / 1000;
      } else if (isNaN(w2) && !isNaN(h2)) {
        w2 = (w1 / h1) * h2;
        response.tech_check = "w2";
        response.tech_ans = Math.round(w2 * 1000) / 1000;
      } else if (!isNaN(w2) && !isNaN(h2)) {
        response.error = "Please enter either W₂ or H₂ to find the other.";
        return response;
      }

      const mode = w1 >= h1 ? "Landscape" : "Portrait";

      response.tech_asp_ratio = reduceRatio(w1, h1);
      response.tech_vsl_ratio = ratio2css(x1v, y1v);
      response.tech_pixels = (w1 * h1).toLocaleString();
      response.tech_mode = mode;
      return response;
    } else {
      return { error: "Please! Check Your Input" };
    }
  }

  /**
   * getCalculationBoardFootCalculator: Service Method
   * POST: /api/calculators-lol/board-foot-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationBoardFootCalculator(body) {
    let length = body.tech_length?.toString().trim();
    let no = body.tech_no?.toString().trim();
    let length_unit = body.tech_length_unit?.toString().trim();
    let width = body.tech_width?.toString().trim();
    let width_unit = body.tech_width_unit?.toString().trim();
    let thickness = body.tech_thickness?.toString().trim();
    let thickness_unit = body.tech_thickness_unit?.toString().trim();
    let price = body.tech_price?.toString().trim();

    // Convert strings to numbers
    length = parseFloat(length);
    no = parseFloat(no);
    width = parseFloat(width);
    thickness = parseFloat(thickness);

    const response = {};

    if (!isNaN(length) && !isNaN(no) && !isNaN(width) && !isNaN(thickness)) {
      // Thickness conversion to inches
      if (thickness_unit === "cm") {
        thickness *= 0.3937;
      } else if (thickness_unit === "m") {
        thickness *= 39.37;
      } else if (thickness_unit === "ft") {
        thickness *= 12;
      } else if (thickness_unit === "yd") {
        thickness *= 36;
      }

      // Width conversion to inches
      if (width_unit === "cm") {
        width *= 0.3937;
      } else if (width_unit === "m") {
        width *= 39.37;
      } else if (width_unit === "ft") {
        width *= 12;
      } else if (width_unit === "yd") {
        width *= 36;
      }

      // Length conversion to feet
      if (length_unit === "cm") {
        length *= 0.03281;
      } else if (length_unit === "m") {
        length *= 3.281;
      } else if (length_unit === "in") {
        length /= 12;
      } else if (length_unit === "yd") {
        length *= 3;
      }

      // Calculate board foot
      let ans = length * width * (thickness / 12);
      ans *= no;

      response.tech_ans = ans;
      return response;
    } else {
      return { error: "Please! Check Your Inputs" };
    }
  }

  /**
   * getCalculationEdpiCalculator: Service Method
   * POST: /api/calculators-lol/edpi-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationEdpiCalculator(body) {
    let dpi = body.tech_dpi?.toString().trim();
    let row = body.tech_row?.toString().trim();
    let sen = body.tech_sen?.toString().trim();
    let game = body.tech_game?.toString().trim();
    let win = body.tech_win?.toString().trim();
    let submit = body.tech_submit;

    // Convert to numeric
    dpi = parseFloat(dpi);
    row = parseFloat(row);
    sen = parseFloat(sen);
    game = parseInt(game);
    win = parseFloat(win);

    const response = {};

    if (submit) {
      // Helper: Calculate Sensitivity Type
      const CalcSn = (e, game) => {
        const s = e * 1;
        switch (game) {
          case 1:
          case 6:
            if (s > 0 && s < 700) return "Low Sens";
            if (s >= 700 && s < 1200) return "Medium Sens";
            if (s >= 1200) return "High Sens";
            break;
          case 3:
            if (s > 0 && s < 200) return "Low Sens";
            if (s >= 200 && s < 400) return "Medium Sens";
            if (s >= 400) return "High Sens";
            break;
          case 4:
            if (s > 0 && s < 40) return "Low Sens";
            if (s >= 40 && s < 80) return "Medium Sens";
            if (s >= 80) return "High Sens";
            break;
          case 5:
            if (s > 0 && s < 3000) return "Low Sens";
            if (s >= 3000 && s < 6000) return "Medium Sens";
            if (s >= 6000) return "High Sens";
            break;
          case 2:
          default:
            return "";
        }
      };

      // Helper: Calculate 360cm
      const Calc360 = (e, game) => {
        const coeff = {
          1: 0.022,
          2: 0.0066,
          3: 0.07,
          4: 0.005555,
          5: 0.0066,
          6: 0.021999,
        };
        const multiplier = coeff[game] || 0.022;
        return (360 / (multiplier * e)) * 2.54;
      };

      let ans = 0;
      if (game === 1) {
        let t = row === 0 ? win : 1;
        ans = dpi * sen * t;
      } else if (game === 4) {
        ans = (dpi * sen) / 100;
      } else {
        ans = dpi * sen;
      }

      const type = CalcSn(ans, game);
      const cm = Calc360(ans, game);
      const inch = cm / 2.54;

      response.tech_ans = parseFloat(ans.toFixed(2));
      response.tech_cm = parseFloat(cm.toFixed(2));
      response.tech_in = parseFloat(inch.toFixed(2));
      response.tech_type = type;
      return response;
    } else {
      return { error: "Please! Check Your Inputs" };
    }
  }

  /**
   * getCalculationVisaChanceCalculator: Service Method
   * POST: /api/calculators-lol/visa-chance-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationVisaChanceCalculator(body) {
    let name = body.tech_name?.trim();
    let resident = body.tech_resident?.trim();
    let nationality = body.tech_nationality?.trim();
    let travel = parseInt(body.tech_travel);

    const response = {};

    if (!travel || !nationality || !resident) {
      response.error = "Please! Check Your Inputs";
      return response;
    }

    const ec = [
      [],
      [
        "Albania",
        "Algeria",
        "Andorra",
        "Argentina",
        "Australia",
        "Austria",
        "Bahamas",
        "Bahrain",
        "Barbados",
        "Belgium",
        "Bolivia",
        "Bosnia & herzegovina",
        "Brazil",
        "Brunei darussalam",
        "Bulgaria",
        "Canada",
        "Chile",
        "China",
        "Colombia",
        "Costa rica",
        "Croatia",
        "Cuba",
        "Cyprus",
        "Czech republic",
        "Denmark",
        "Djibouti",
        "Ecuador",
        "Estonia",
        "Finland",
        "France",
        "Germany",
        "Greece",
        "Guatemala",
        "Holy see (vatican)",
        "Honduras",
        "Hungary",
        "Iceland",
        "India",
        "Indonesia",
        "Iran",
        "Ireland",
        "Israel",
        "Italy",
        "Jamaica",
        "Japan",
        "Jordan",
        "Korea",
        "Kuwait",
        "Latvia",
        "Liechtenstein",
        "Lithuania",
        "Luxembourg",
        "Macedonia",
        "Malaysia",
        "Maldives",
        "Malta",
        "Mauritius",
        "Mexico",
        "Monaco",
        "Mongolia",
        "Montenegro",
        "Morocco",
        "Nepal",
        "Netherlands",
        "New zealand",
        "Norway",
        "Oman",
        "Pakistan",
        "Panama",
        "Paraguay",
        "Peru",
        "Poland",
        "Portugal",
        "Qatar",
        "Romania",
        "San marino",
        "Saudi arabia",
        "Serbia",
        "Seychelles",
        "Singapore",
        "Slovakia",
        "Slovenia",
        "South africa",
        "Spain",
        "Sri lanka",
        "Sweden",
        "Switzerland",
        "Thailand",
        "Trinidad and tobago",
        "Turkey",
        "Turkmenistan",
        "United arab emirates",
        "United kingdom",
        "United states of america",
        "Vietnam",
      ],
      [
        "Afghanistan",
        "Albania",
        "Algeria",
        "American Samoa",
        "Andorra",
        "Angola",
        "Anguilla",
        "Antarctica",
        "Antigua and Barbuda",
        "Argentina",
        "Armenia",
        "Aruba",
        "Australia",
        "Austria",
        "Azerbaijan",
        "Bahamas",
        "Bahrain",
        "Bangladesh",
        "Barbados",
        "Belarus",
        "Belgium",
        "Belize",
        "Benin",
        "Bermuda",
        "Bhutan",
        "Bolivia",
        "Bosnia and Herzegovina",
        "Botswana",
        "Bouvet Island",
        "Brazil",
        "British Indian Ocean Territory",
        "Brunei Darussalam",
        "Bulgaria",
        "Burkina Faso",
        "Burundi",
        "Cambodia",
        "Cameroon",
        "Canada",
        "Cape Verde",
        "Cayman Islands",
        "Central African Republic",
        "Chad",
        "Chile",
        "China",
        "Christmas Island",
        "Cocos (Keeling) Islands",
        "Colombia",
        "Comoros",
        "Congo",
        "Cook Islands",
        "Costa Rica",
        "Croatia (Hrvatska)",
        "Cuba",
        "Cyprus",
        "Czech Republic",
        "Denmark",
        "Djibouti",
        "Dominica",
        "Dominican Republic",
        "East Timor",
        "Ecuador",
        "Egypt",
        "El Salvador",
        "Equatorial Guinea",
        "Eritrea",
        "Estonia",
        "Ethiopia",
        "Falkland Islands (Malvinas)",
        "Faroe Islands",
        "Fiji",
        "Finland",
        "France",
        "France, Metropolitan",
        "French Guiana",
        "French Polynesia",
        "French Southern Territories",
        "Gabon",
        "Gambia",
        "Georgia",
        "Germany",
        "Ghana",
        "Gibraltar",
        "Greece",
        "Greenland",
        "Grenada",
        "Guadeloupe",
        "Guam",
        "Guatemala",
        "Guernsey",
        "Guinea",
        "Guinea-Bissau",
        "Guyana",
        "Haiti",
        "Heard and Mc Donald Islands",
        "Honduras",
        "Hong Kong",
        "Hungary",
        "Iceland",
        "India",
        "Indonesia",
        "Iran (Islamic Republic of)",
        "Iraq",
        "Ireland",
        "Isle of Man",
        "Israel",
        "Italy",
        "Ivory Coast",
        "Jamaica",
        "Japan",
        "Jersey",
        "Jordan",
        "Kazakhstan",
        "Kenya",
        "Kiribati",
        "Korea, Democratic People's Republic of",
        "Korea, Republic of",
        "Kosovo",
        "Kuwait",
        "Kyrgyzstan",
        "Lao People's Democratic Republic",
        "Latvia",
        "Lebanon",
        "Lesotho",
        "Liberia",
        "Libyan Arab Jamahiriya",
        "Liechtenstein",
        "Lithuania",
        "Luxembourg",
        "Macau",
        "Macedonia",
        "Madagascar",
        "Malawi",
        "Malaysia",
        "Maldives",
        "Mali",
        "Malta",
        "Marshall Islands",
        "Martinique",
        "Mauritania",
        "Mauritius",
        "Mayotte",
        "Mexico",
        "Micronesia, Federated States of",
        "Moldova, Republic of",
        "Monaco",
        "Mongolia",
        "Montenegro",
        "Montserrat",
        "Morocco",
        "Mozambique",
        "Myanmar",
        "Namibia",
        "Nauru",
        "Nepal",
        "Netherlands",
        "Netherlands Antilles",
        "New Caledonia",
        "New Zealand",
        "Nicaragua",
        "Niger",
        "Nigeria",
        "Niue",
        "Norfolk Island",
        "Northern Mariana Islands",
        "Norway",
        "Oman",
        "Pakistan",
        "Palau",
        "Palestine",
        "Panama",
        "Papua New Guinea",
        "Paraguay",
        "Peru",
        "Philippines",
        "Pitcairn",
        "Poland",
        "Portugal",
        "Puerto Rico",
        "Qatar",
        "Reunion",
        "Romania",
        "Russian Federation",
        "Rwanda",
        "Saint Kitts and Nevis",
        "Saint Lucia",
        "Saint Vincent and the Grenadines",
        "Samoa",
        "San Marino",
        "Sao Tome and Principe",
        "Saudi Arabia",
        "Senegal",
        "Serbia",
        "Seychelles",
        "Sierra Leone",
        "Singapore",
        "Slovakia",
        "Slovenia",
        "Solomon Islands",
        "Somalia",
        "South Africa",
        "South Georgia South Sandwich Islands",
        "South Sudan",
        "Spain",
        "Sri Lanka",
        "St. Helena",
        "St. Pierre and Miquelon",
        "Sudan",
        "Suriname",
        "Svalbard and Jan Mayen Islands",
        "Swaziland",
        "Sweden",
        "Switzerland",
        "Syrian Arab Republic",
        "Taiwan",
        "Tajikistan",
        "Tanzania, United Republic of",
        "Thailand",
        "Togo",
        "Tokelau",
        "Tonga",
        "Trinidad and Tobago",
        "Tunisia",
        "Turkey",
        "Turkmenistan",
        "Turks and Caicos Islands",
        "Tuvalu",
        "Uganda",
        "Ukraine",
        "United Arab Emirates",
        "United Kingdom",
        "United States",
        "United States minor outlying islands",
        "Uruguay",
        "Uzbekistan",
        "Vanuatu",
        "Vatican City State",
        "Venezuela",
        "Vietnam",
        "Virgin Islands (British)",
        "Virgin Islands (U.S.)",
        "Wallis and Futuna Islands",
        "Western Sahara",
        "Yemen",
        "Zaire",
        "Zambia",
        "Zimbabwe",
      ],
    ];

    const lowerNationality = nationality.toLowerCase();
    const matchList = (ec[travel] || []).map((n) => n.toLowerCase());

    const ans = matchList.includes(lowerNationality)
      ? "There are more likely 99% chances of your visa eligibility!"
      : "There are more likely 50% chances of your visa eligibility!";

    response.tech_ans = ans;
    return response;
  }

  /**
   * getCalculationPopulationDensityCalculator: Service Method
   * POST: /api/calculators-lol/population-density-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPopulationDensityCalculator(body) {
    let area = body.tech_area?.toString().trim();
    let no = body.tech_no?.toString().trim();

    const response = {};

    if (!isNaN(area) && !isNaN(no)) {
      let areaNum = parseFloat(area);
      let noNum = parseFloat(no);

      let ans = noNum / areaNum;
      response.tech_ans = Math.round(ans);
      return response;
    } else {
      response.error = "Please! Check Input Fields";
      return response;
    }
  }

  /**
   * getCalculationProratedrentCalculator: Service Method
   * POST: /api/calculators-lol/prorated-rent-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationProratedrentCalculator(body) {
    let date = body.tech_date?.toString().trim();
    let rent = parseFloat(body.tech_rent?.toString().trim());
    let bill_on = parseInt(body.tech_bill_on?.toString().trim());

    const response = {};

    if (!isNaN(rent) && !isNaN(bill_on) && date) {
      let dt = new Date(date);
      let year = dt.getFullYear();
      let mon = dt.getMonth(); // 0-indexed
      let day = dt.getDate();

      // Get total days in the current month
      let daysInMonth = new Date(year, mon + 1, 0).getDate();
      let per_day = rent / daysInMonth;
      let pror = 0;
      let days_in_mon = 0;
      let end_date = "";
      let res = 0;

      if (bill_on >= day || bill_on === 1) {
        res = 1;

        if (bill_on <= daysInMonth) {
          if (bill_on === 1) {
            days_in_mon = daysInMonth - day + 1;
            pror = per_day * days_in_mon;
            end_date = `${year}-${String(mon + 1).padStart(
              2,
              "0"
            )}-${daysInMonth}`;
          } else {
            days_in_mon = bill_on - day;
            pror = per_day * days_in_mon;
            end_date = `${year}-${String(mon + 1).padStart(2, "0")}-${String(
              bill_on - 1
            ).padStart(2, "0")}`;
          }
        } else {
          days_in_mon = 1;
          pror = per_day * days_in_mon;
          end_date = `${year}-${String(mon + 1).padStart(
            2,
            "0"
          )}-${daysInMonth}`;
        }
      } else if (bill_on < day) {
        res = 2;
        days_in_mon = daysInMonth - day + 1;
        pror = per_day * days_in_mon;

        let nextMonth = new Date(year, mon + 1, 1);
        let year1 = nextMonth.getFullYear();
        let mon1 = nextMonth.getMonth();
        let daysInNextMonth = new Date(year1, mon1 + 1, 0).getDate();
        let per_day1 = rent / daysInNextMonth;
        let days_in_mon1 = bill_on - 1;
        let pror1 = per_day1 * days_in_mon1;

        end_date = `${year1}-${String(mon1 + 1).padStart(2, "0")}-${String(
          bill_on - 1
        ).padStart(2, "0")}`;

        response.tech_d1 = daysInNextMonth;
        response.tech_per_day1 = parseFloat(per_day1.toFixed(2));
        response.tech_days_in_mon1 = days_in_mon1;
        response.tech_pror1 = parseFloat(pror1.toFixed(2));
      }

      response.tech_date = date;
      response.tech_d = daysInMonth;
      response.tech_per_day = parseFloat(per_day.toFixed(2));
      response.tech_days_in_mon = days_in_mon;
      response.tech_pror = parseFloat(pror.toFixed(2));
      response.tech_end_date = end_date;
      response.tech_res = res;
      return response;
    } else {
      response.error = "Please! Check Your Input";
      return response;
    }
  }

  /**
   * getCalculationKoreanAgeCalculator: Service Method
   * POST: /api/calculators-lol/korean-age-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationKoreanAgeCalculator(body) {
    const current_year = parseInt(body.tech_current_year?.toString().trim());
    const year = parseInt(body.tech_year?.toString().trim());
    const birthday_unit = body.tech_birthday_unit?.toString().trim(); // "1" or "2"
    const age = parseInt(body.tech_age?.toString().trim());
    const room_unit = body.tech_room_unit?.toString().trim(); // "1" or "2"

    const response = {};

    if (room_unit === "1") {
      // Calculate from year of birth
      if (!isNaN(year) && !isNaN(current_year)) {
        if (year < current_year) {
          const korean_age = current_year - year + 1;
          response.tech_korean_age = korean_age;
        } else {
          response.error =
            "It is must that your birth year is earlier than current one in case you are from the future";
        }
      } else {
        response.error = "Please! Check Your Inputs";
      }
    } else if (room_unit === "2") {
      // Calculate from international age
      if (!isNaN(age)) {
        if (age > 0) {
          let korean_age;
          if (birthday_unit === "1") {
            korean_age = age + 2;
          } else if (birthday_unit === "2") {
            korean_age = age + 1;
          }

          if (korean_age !== undefined) {
            response.tech_korean_age = korean_age;
          } else {
            response.error = "Invalid birthday unit";
          }
        } else {
          response.error = "Age Cannot be negative";
        }
      } else {
        response.error = "Please! Check Your Inputs";
      }
    } else {
      response.error = "Invalid room unit";
    }

    return response;
  }

  /**
   * getCalculationWinningPercentageCalculator: Service Method
   * POST: /api/calculators-lol/winning-percentage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationWinningPercentageCalculator(body) {
    const win = parseFloat(body.tech_win?.toString().trim());
    const loss = parseFloat(body.tech_loss?.toString().trim());
    const tie =
      body.tie !== undefined ? parseFloat(body.tech_tie?.toString().trim()) : 0;
    const value =
      body.value !== undefined
        ? parseFloat(body.tech_value?.toString().trim())
        : null;

    const response = {};

    if (!isNaN(win) && !isNaN(loss)) {
      const no_games = win * loss;
      let total = win + loss;

      if (!isNaN(tie)) {
        total += tie;
      }

      let ans;
      if (!isNaN(value) && value !== 0) {
        ans = ((win + value * tie) / total) * 100;
      } else {
        ans = (win / total) * 100;
      }

      response.tech_ans = ans;
      response.tech_no_games = no_games;
    } else {
      response.error = "Please! Check Your Inputs";
    }

    return response;
  }

  /**
   * getCalculationMcgToMgCalculator: Service Method
   * POST: /api/calculators-lol/mcg-to-mg-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMcgToMgCalculator(body) {
    const operations = body.tech_operations?.toString().trim();
    const first = parseFloat(body.tech_first?.toString().trim());

    const response = {};

    if (operations === "1") {
      if (!isNaN(first)) {
        response.tech_jawab = first / 1000;
      } else {
        response.error = "Please! Check Your Inputs";
        return response;
      }
    } else if (operations === "2") {
      if (!isNaN(first)) {
        response.tech_jawab = first * 1000;
      } else {
        response.error = "Please! Check Your Inputs";
        return response;
      }
    } else {
      response.error = "Invalid operation selected";
      return response;
    }

    response.tech_operations = operations;
    response.input_first = first;
    return response;
  }

  /**
   * getCalculationDownloadCalculator: Service Method
   * POST: /api/calculators-lol/download-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDownloadCalculator(body) {
    const operations = body.tech_operations;
    const first = parseFloat(body.tech_first);
    const second = parseFloat(body.tech_second);
    const third = parseFloat(body.tech_third);
    const f_unit = body.tech_f_unit;
    const s_unit = body.tech_s_unit;
    const t_unit = body.tech_t_unit;

    const response = {};

    function calculate(unit, value) {
      const map = {
        B: value / 1e6,
        kB: value / 1e3,
        MB: value * 1,
        GB: value * 1e3,
        TB: value * 1e6,
        PB: value * 1e9,
        EB: value * 1e12,
        ZB: value * 1e15,
        YB: value * 1e18,
        bit: value / 8e6,
        kbit: value * 0.000125,
        Mbit: value / 8,
        Gbits: value * 125,
        Tbit: value * 125000,
        KiB: value * 0.001024,
        MiB: value * 1.0486,
        GiB: value * 1073.7,
        TiB: value * 1099512,
        PiB: value * 1125899907,
        EiB: value * 1152921504607,
        ZiB: value * 1180591620717411,
        YiB: value * 1208925819614629175,
        Kibit: value * 0.000128,
        Mibit: value * 0.13107,
        Gibit: value * 134.22,
        Tibit: value * 137439,
      };
      return map[unit] ?? 0;
    }

    function tim(unit, value) {
      const map = {
        sec: value,
        min: value * 60,
        hrs: value * 3600,
        days: value * 86400,
        wks: value * 604800,
        mos: value * 2629800,
        yrs: value * 31557600,
      };
      return map[unit] ?? 0;
    }

    let jawab = 0;
    if (operations === "1") {
      if (first > 0 && second > 0) {
        const size = calculate(f_unit, first);
        const speed = calculate(s_unit, second);
        jawab = size / speed;
        const bandwidths = [
          28800, 56000, 256000, 512000, 1000000, 2000000, 8000000, 24000000,
          10000000, 100000000, 7200000, 80000000, 1000000000,
        ];

        bandwidths.forEach((bw, i) => {
          const filetime = (size * 1024 * 8) / bw;
          const hours = String(Math.floor(filetime / 3600)).padStart(2, "0");
          const minutes = String(Math.floor((filetime % 3600) / 60)).padStart(
            2,
            "0"
          );
          const seconds = String(Math.floor(filetime % 60)).padStart(2, "0");
          response[`f${i + 1}`] = `${hours}:${minutes}:${seconds}`;
        });
      } else {
        response.error =
          first <= 0
            ? "Please input a file size greater than 0."
            : "Please enter a positive download speed.";
        return response;
      }
    } else if (operations === "2") {
      if (first > 0 && third > 0) {
        const size = calculate(f_unit, first);
        const time = tim(t_unit, third);
        jawab = size / time;
      } else {
        response.error =
          first <= 0
            ? "Please input a file size greater than 0."
            : "Please enter a download time greater than 0.";
        return response;
      }
    } else if (operations === "3") {
      if (second > 0 && third > 0) {
        const speed = calculate(s_unit, second);
        const time = tim(t_unit, third);
        jawab = speed * time;
      } else {
        response.error =
          second <= 0
            ? "Please enter a positive download speed."
            : "Please enter a download time greater than 0.";
        return response;
      }
    } else {
      response.error = "Invalid operation";
      return response;
    }

    response.tech_jawab = Math.round(jawab);
    return response;
  }

  /**
   * getCalculationKdCalculator: Service Method
   * POST: /api/calculators-lol/kd-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationKdCalculator(body) {
    let kills = body.tech_kills;
    let deaths = body.tech_deaths;
    let assists = body.tech_assists;

    let param = {};
    // Helper function
    function isNumeric(value) {
      return !isNaN(parseFloat(value)) && isFinite(value);
    }
    // Validate kills and deaths
    if (isNumeric(kills) && isNumeric(deaths)) {
      if (kills > 0 && deaths > 0) {
        const kd_ratio = kills / deaths;

        if (assists !== undefined && assists !== "") {
          if (isNumeric(assists)) {
            if (assists > 0) {
              const kda_ratio = (kills + assists) / deaths;
              param.kda_ratio = kda_ratio;
            } else {
              return { error: "Enter Positive Value" };
            }
          } else {
            return { error: "Please! Check Your Input" };
          }
        }

        param.tech_kd_ratio = kd_ratio;
        return param;
      } else {
        return { error: "Enter Positive Value" };
      }
    } else {
      return { error: "Please! Check Your Input" };
    }
  }

  /**
   * getCalculationDataTransferCalculator: Service Method
   * POST: /api/calculators-lol/data-transfer-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDataTransferCalculator(body) {
    let first = body.tech_first;
    let f_unit = body.tech_f_unit;
    let second = body.tech_second;
    let s_unit = body.tech_s_unit;
    let kilo = body.tech_kilo;
    let overhead = body.tech_overhead;

    const param = {};

    function calculateHazar(a, b) {
      const conversions = {
        1: b / 1000000,
        2: b / 1000,
        3: b * 1,
        4: b * 1000,
        5: b * 1000000,
        6: b * 1000000000,
        7: b * 1000000000000,
        8: b * 1000000000000000,
        9: b * 1000000000000000000,
        10: b / 8000000,
        11: b * 0.000125,
        12: b / 8,
        13: b * 125,
        14: b * 125000,
        15: b * 0.001024,
        16: b * 1.0486,
        17: b * 1073.7,
        18: b * 1099512,
        19: b * 1125899907,
        20: b * 1152921504607,
        21: b * 1180591620717411,
        22: b * 1208925819614629175,
        23: b * 0.000128,
        24: b * 0.13107,
        25: b * 134.22,
        26: b * 137439,
      };
      return conversions[a] ?? b;
    }

    function calculateHazar24(a, b) {
      const conversions = {
        1: b / 1000024,
        2: b / 1024,
        3: b * 1,
        4: b * 1024,
        5: b * 1000024,
        6: b * 1000000024,
        7: b * 1000000000024,
        8: b * 1000000000000024,
        9: b * 1000000000000000024,
        10: b / 8000024,
        11: b * 0.000125,
        12: b / 8,
        13: b * 125,
        14: b * 125024,
        15: b * 0.001024,
        16: b * 1.0486,
        17: b * 1073.7,
        18: b * 1099512,
        19: b * 1125899907,
        20: b * 1152921504607,
        21: b * 1180591620717411,
        22: b * 1208925819614629175,
        23: b * 0.000128,
        24: b * 0.13107,
        25: b * 134.22,
        26: b * 137439,
      };
      return conversions[a] ?? b;
    }

    function formatTime(t) {
      const hours = String(Math.floor(t / 3600)).padStart(2, "0");
      const minutes = String(Math.floor((t % 3600) / 60)).padStart(2, "0");
      const seconds = String(Math.floor(t % 60)).padStart(2, "0");
      return `${hours}:${minutes}:${seconds}`;
    }

    if (isNaN(first) || isNaN(second)) {
      param.error = "Please check your input";
      return param;
    }

    let f1 = parseFloat(first);
    let s1 = parseFloat(second);

    const fUnit = parseInt(f_unit);
    const sUnit = parseInt(s_unit);
    const kiloVal = parseInt(kilo);
    const overheadVal = parseInt(overhead);

    if (kiloVal === 1) {
      f1 = calculateHazar24(fUnit, f1);
      s1 = calculateHazar24(sUnit, s1);
    } else if (kiloVal === 2) {
      f1 = calculateHazar(fUnit, f1);
      s1 = calculateHazar(fUnit, s1);
    }

    if (overheadVal === 2) f1 += f1 * 0.05;
    else if (overheadVal === 3) f1 += f1 * 0.1;
    else if (overheadVal === 4) f1 += f1 * 0.2;
    else if (overheadVal === 5) f1 += f1 * 0.3;
    else if (overheadVal === 6) f1 += f1 * 0.4;
    else if (overheadVal === 7) f1 += f1 * 0.5;

    if (f1 <= 0) {
      param.error = "Please input a file size greater than 0.";
      return param;
    }

    if (s1 <= 0) {
      param.error = "Please enter a positive download speed.";
      return param;
    }

    const jawab = Math.round(f1 / s1);
    const mainAns = formatTime(jawab);

    const bandwidths = [1.544, 10, 100, 1000, 10240, 480, 5120, 10240, 20480];
    const tableAns = bandwidths.map((bw) => {
      const filetime = (f1 * 1024 * 8) / (bw * 1024);
      return formatTime(filetime);
    });

    param.tech_jawab = jawab;
    param.tech_main_ans = mainAns;
    for (let i = 0; i < tableAns.length; i++) {
      param[`tech_f${i + 1}`] = tableAns[i];
    }

    return param;
  }

  /**
   * getCalculationWordsPerMinuteCalculator: Service Method
   * POST: /api/calculators-lol/words-per-minute-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationWordsPerMinuteCalculator(body) {
    let speak_speed = body.tech_speak_speed;
    let ss = body.tech_ss;
    let reading_speed = body.tech_reading_speed;
    let rs = body.tech_rs;
    let select = body.tech_select;
    let words = body.tech_words;
    let x = body.tech_x;

    const param = {};

    function formatTime(t, f = ":") {
      const hours = String(Math.floor(t / 3600)).padStart(2, "0");
      const minutes = String(Math.floor((t / 60) % 60)).padStart(2, "0");
      const seconds = String(Math.floor(t % 60)).padStart(2, "0");
      return `${hours}${f}${minutes}${f}${seconds}`;
    }

    if (!isNaN(ss) && !isNaN(rs)) {
      ss = parseFloat(ss);
      rs = parseFloat(rs);

      if (ss > 0) {
        if (rs > 0) {
          let speak_ans, read_ans;

          if (select == "1") {
            if (!isNaN(words)) {
              words = parseInt(words);
              if (words > 0) {
                speak_ans = words / ss;
                read_ans = words / rs;
              } else {
                param.error = "The number of words must be more than 0.";
                return param;
              }
            } else {
              param.error = "Please check your input";
              return param;
            }
          } else if (select == "2") {
            if (x && typeof x === "string" && x.trim().length > 0) {
              const para_words = x.trim().split(/\s+/).length;
              if (para_words > 0) {
                speak_ans = para_words / ss;
                read_ans = para_words / rs;
                param.tech_para_words = para_words;
              } else {
                param.error = "The number of words must be more than 0.";
                return param;
              }
            } else {
              param.error = "Please check your input";
              return param;
            }
          }

          const speak_time = formatTime(speak_ans * 60);
          const read_time = formatTime(read_ans * 60);

          param.tech_speak_ans = speak_ans;
          param.tech_read_ans = read_ans;
          param.tech_speak_time = speak_time;
          param.tech_read_time = read_time;

          return param;
        } else {
          param.error = "The reading speed must be more than 0.";
          return param;
        }
      } else {
        param.error = "The speaking speed must be more than 0.";
        return param;
      }
    } else {
      param.error = "Please check your input";
      return param;
    }
  }

  /**
   * getCalculationDeskHeightCalculator: Service Method
   * POST: /api/calculators-lol/desk-height-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDeskHeightCalculator(body) {
    let units = body.tech_units;
    let height = body.tech_height;
    let height2 = body.tech_height2;
    let position = body.tech_position;

    let unit;
    if (units === "Centimeters") {
      unit = 2.54;
      height = parseFloat(height);
    } else if (units === "Feet and Inches") {
      unit = 1;
      height = parseFloat(height2);
    }

    const seat_min = (0.3219306 * height) / 2.54 - 5.312559;
    const seat_max = (0.2715447 * height) / 2.54 - 0.1796748;
    const table_min = (0.4739837 * height) / 2.54 - 6.677846;
    const table_max = (0.5528455 * height) / 2.54 - 9.427033;
    const monitor_min = (0.7248521 * height) / 2.54 - 1.95858;
    const monitor_max = (0.7376726 * height) / 2.54 - 1.21499;
    const table_min_standing = (0.6005917 * height) / 2.54 + 0.02662722;
    const table_max_standing = (0.6656805 * height) / 2.54 - 1.044379;
    const monitor_min_standing = (0.9674556 * height) / 2.54 - 2.464497;
    const monitor_max_standing = (0.9349112 * height) / 2.54 + 1.071006;

    let ans1 = "";
    let ans2 = "";
    let ans3 = "";

    if (position === "0") {
      ans1 = `${Math.round(seat_min * unit * 2) / 2} - ${
        Math.round(seat_max * unit * 2) / 2
      }`;
      ans2 = `${Math.round(table_min * unit * 2) / 2} - ${
        Math.round(table_max * unit * 2) / 2
      }`;
      ans3 = `${Math.round(monitor_min * unit * 2) / 2} - ${
        Math.round(monitor_max * unit * 2) / 2
      }`;
    } else if (position === "1") {
      ans2 = `${Math.round(table_min_standing * unit * 2) / 2} - ${
        Math.round(table_max_standing * unit * 2) / 2
      }`;
      ans3 = `${Math.round(monitor_min_standing * unit * 2) / 2} - ${
        Math.round(monitor_max_standing * unit * 2) / 2
      }`;
    }

    return {
      tech_units: units,
      tech_position: position,
      tech_ans1: ans1,
      tech_ans2: ans2,
      tech_ans3: ans3,
    };
  }
  /**
   * getCalculationRingSizeCalculator: Service Method
   * POST: /api/calculators-lol/ring-size-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationRingSizeCalculator(body) {
    let unit = body.tech_unit;
    let cd = body.tech_to_measure;
    let dia_mm = body.tech_d_o_r_mm;
    let dia_in = body.tech_d_o_r_in;
    let cir_mm = body.tech_c_o_f_mm;
    let cir_in = body.tech_c_o_f_in;

    const param = {};
    let ring_size, uk_au, us_ca, f, g, j, s;
    if (
      !isNaN(cir_mm) &&
      !isNaN(cir_in) &&
      !isNaN(dia_mm) &&
      !isNaN(dia_in) &&
      cd !== "" &&
      unit !== ""
    ) {
      const pie = 3.14159;

      if (cd === "d_o_r") {
        if (unit === "millimeters") {
          ring_size = Math.round(dia_mm * pie * 100) / 100;
        } else if (unit === "inches") {
          ring_size = Math.round(dia_in * pie * 100) / 100;
        }
      } else if (cd === "c_o_f") {
        if (unit === "millimeters") {
          ring_size = Math.round((cir_mm / pie) * 100) / 100;
        } else if (unit === "inches") {
          ring_size = Math.round((cir_in / pie) * 1000) / 1000;
        }
      }

      if (
        ring_size == 9.91 ||
        ring_size == 0.388 ||
        ring_size == 31.13 ||
        ring_size == 1.23
      ) {
        us_ca = "0000";
        uk_au = "-";
        f = "-";
        g = "-";
        j = "-";
        s = "-";
      } else if (
        ring_size == 10.72 ||
        ring_size == 0.442 ||
        ring_size == 33.68 ||
        ring_size == 1.39
      ) {
        us_ca = "00";
        uk_au = "-";
        f = "-";
        g = "-";
        j = "-";
        s = "-";
      } else if (
        ring_size == 11.53 ||
        ring_size == 0.454 ||
        ring_size == 36.22 ||
        ring_size == 1.43
      ) {
        us_ca = "0";
        uk_au = "-";
        f = "-";
        g = "-";
        j = "-";
        s = "-";
      } else if (
        ring_size == 11.95 ||
        ring_size == 0.474 ||
        ring_size == 37.54 ||
        ring_size == 1.49
      ) {
        us_ca = "1/2";
        uk_au = "A";
        f = "-";
        g = "-";
        j = "-";
        s = "-";
      } else if (
        ring_size == 12.18 ||
        ring_size == 0.482 ||
        ring_size == 38.26 ||
        ring_size == 1.51
      ) {
        us_ca = "3/4";
        uk_au = "A 1/2";
        f = "-";
        g = "-";
        j = "-";
        s = "-";
      } else if (
        ring_size == 12.37 ||
        ring_size == 0.487 ||
        ring_size == 38.86 ||
        ring_size == 1.53
      ) {
        us_ca = "1";
        uk_au = "B";
        f = "-";
        g = "-";
        j = "1";
        s = "-";
      } else if (
        ring_size == 12.6 ||
        ring_size == 0.496 ||
        ring_size == 39.58 ||
        ring_size == 1.56
      ) {
        us_ca = "1 1/4";
        uk_au = "B 1/2";
        f = "-";
        g = "-";
        j = "1";
        s = "-";
      } else if (
        ring_size == 12.78 ||
        ring_size == 0.503 ||
        ring_size == 40.15 ||
        ring_size == 1.58
      ) {
        us_ca = "1 1/2";
        uk_au = "C";
        f = "-";
        g = "-";
        j = "-";
        s = "-";
      } else if (
        ring_size == 13.0 ||
        ring_size == 0.512 ||
        ring_size == 40.84 ||
        ring_size == 1.61
      ) {
        us_ca = "1 3/4";
        uk_au = "C 1/2";
        f = "-";
        g = "-";
        j = "-";
        s = "-";
      } else if (
        ring_size == 13.21 ||
        ring_size == 0.52 ||
        ring_size == 41.5 ||
        ring_size == 1.63
      ) {
        us_ca = "2";
        uk_au = "D";
        f = "41 1/2";
        g = "13 1/2";
        j = "2";
        s = "1 1/2";
      } else if (
        ring_size == 13.41 ||
        ring_size == 0.528 ||
        ring_size == 42.13 ||
        ring_size == 1.66
      ) {
        us_ca = "2 1/4";
        uk_au = "D 1/2";
        f = "-";
        g = "-";
        j = "-";
        s = "-";
      } else if (
        ring_size == 13.61 ||
        ring_size == 0.536 ||
        ring_size == 42.76 ||
        ring_size == 1.68
      ) {
        us_ca = "2 1/2";
        uk_au = "E";
        f = "42 3/4";
        g = "13 3/4";
        j = "3";
        s = "2 3/4";
      } else if (
        ring_size == 13.83 ||
        ring_size == 0.544 ||
        ring_size == 43.45 ||
        ring_size == 1.71
      ) {
        us_ca = "2 3/4";
        uk_au = "E 1/2";
        f = "-";
        g = "-";
        j = "-";
        s = "-";
      } else if (
        ring_size == 14.05 ||
        ring_size == 0.553 ||
        ring_size == 44.14 ||
        ring_size == 1.74
      ) {
        us_ca = "3";
        uk_au = "F";
        f = "44";
        g = "14";
        j = "4";
        s = "4";
      } else if (
        ring_size == 14.15 ||
        ring_size == 0.557 ||
        ring_size == 44.45 ||
        ring_size == 1.75
      ) {
        us_ca = "3 1/8";
        uk_au = "F 1/2";
        f = "-";
        g = "-";
        j = "-";
        s = "-";
      } else if (
        ring_size == 14.25 ||
        ring_size == 0.561 ||
        ring_size == 44.77 ||
        ring_size == 1.76
      ) {
        us_ca = "3 1/4";
        uk_au = "F 3/4";
        f = "-";
        g = "-";
        j = "-";
        s = "-";
      } else if (
        ring_size == 14.36 ||
        ring_size == 0.565 ||
        ring_size == 45.11 ||
        ring_size == 1.77
      ) {
        us_ca = "3 1/2";
        uk_au = "G 1/4";
        f = "45 1/4";
        g = "-";
        j = "5";
        s = "5 1/4";
      } else if (
        ring_size == 14.45 ||
        ring_size == 0.569 ||
        ring_size == 45.4 ||
        ring_size == 1.79
      ) {
        us_ca = "3 3/4";
        uk_au = "H";
        f = "46 1/2";
        g = "-";
        j = "-";
        s = "6 1/2";
      } else if (
        ring_size == 14.56 ||
        ring_size == 0.573 ||
        ring_size == 45.74 ||
        ring_size == 1.8
      ) {
        us_ca = "4";
        uk_au = "H 1/2";
        f = "-";
        g = "15";
        j = "7";
        s = "-";
      } else if (
        ring_size == 14.65 ||
        ring_size == 0.577 ||
        ring_size == 46.02 ||
        ring_size == 1.81
      ) {
        us_ca = "4 1/4";
        uk_au = "I";
        f = "47 3/4";
        g = "-";
        j = "-";
        s = "7 3/4";
      } else if (
        ring_size == 14.86 ||
        ring_size == 0.585 ||
        ring_size == 46.68 ||
        ring_size == 1.84
      ) {
        us_ca = "4 1/2";
        uk_au = "I 1/2";
        f = "-";
        g = "15 1/4";
        j = "8";
        s = "-";
      } else if (
        ring_size == 15.04 ||
        ring_size == 0.592 ||
        ring_size == 47.25 ||
        ring_size == 1.86
      ) {
        us_ca = "4 5/8";
        uk_au = "J";
        f = "49";
        g = "15 1/2";
        s = "9";
        j = "-";
      } else if (
        ring_size == 15.27 ||
        ring_size == 0.601 ||
        ring_size == 47.97 ||
        ring_size == 1.89
      ) {
        us_ca = "5";
        uk_au = "J 1/2";
        f = "-";
        g = "15 3/4";
        s = "-";
        j = "9";
      } else if (
        ring_size == 15.4 ||
        ring_size == 0.606 ||
        ring_size == 48.38 ||
        ring_size == 1.9
      ) {
        us_ca = "5 1/8";
        uk_au = "K";
        f = "50";
        g = "-";
        s = "10";
        j = "-";
      } else if (
        ring_size == 15.53 ||
        ring_size == 0.611 ||
        ring_size == 48.79 ||
        ring_size == 1.92
      ) {
        us_ca = "4 3/4";
        uk_au = "J 1/4";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 15.7 ||
        ring_size == 0.618 ||
        ring_size == 49.32 ||
        ring_size == 1.94
      ) {
        us_ca = "3 3/8";
        uk_au = "G";
        f = "-";
        g = "14 1/2";
        s = "-";
        j = "-";
      } else if (
        ring_size == 15.8 ||
        ring_size == 0.622 ||
        ring_size == 49.64 ||
        ring_size == 1.95
      ) {
        us_ca = "5 3/8";
        uk_au = "K 1/2";
        f = "-";
        g = "10";
        s = "-";
        j = "-";
      } else if (
        ring_size == 15.9 ||
        ring_size == 0.626 ||
        ring_size == 49.95 ||
        ring_size == 1.97
      ) {
        us_ca = "5 1/4";
        uk_au = "K 1/4";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 16.0 ||
        ring_size == 0.63 ||
        ring_size == 50.27 ||
        ring_size == 1.98
      ) {
        us_ca = "5 3/8";
        uk_au = "K 1/2";
        f = "-";
        g = "-";
        s = "-";
        j = "10";
      } else if (
        ring_size == 16.1 ||
        ring_size == 0.634 ||
        ring_size == 50.58 ||
        ring_size == 1.99
      ) {
        us_ca = "5 1/2";
        uk_au = "L";
        f = "51 3/4";
        g = "16";
        s = "11 3/4";
        j = "-";
      } else if (
        ring_size == 16.3 ||
        ring_size == 0.642 ||
        ring_size == 51.21 ||
        ring_size == 2.02
      ) {
        us_ca = "5 3/4";
        uk_au = "L 1/4";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 16.41 ||
        ring_size == 0.646 ||
        ring_size == 51.55 ||
        ring_size == 2.03
      ) {
        us_ca = "5 7/8";
        uk_au = "L 1/2";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 16.51 ||
        ring_size == 0.65 ||
        ring_size == 51.87 ||
        ring_size == 2.04
      ) {
        us_ca = "6";
        uk_au = "M";
        f = "52 3/4";
        g = "16 1/2";
        s = "12 3/4";
        j = "12";
      } else if (
        ring_size == 16.71 ||
        ring_size == 0.658 ||
        ring_size == 51.5 ||
        ring_size == 2.07
      ) {
        us_ca = "6 1/4";
        uk_au = "M 1/2";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 16.92 ||
        ring_size == 0.666 ||
        ring_size == 53.16 ||
        ring_size == 2.09
      ) {
        us_ca = "6 1/2";
        uk_au = "N";
        f = "54";
        g = "17";
        s = "14";
        j = "13";
      } else if (
        ring_size == 17.13 ||
        ring_size == 0.674 ||
        ring_size == 53.82 ||
        ring_size == 2.12
      ) {
        us_ca = "6 3/4";
        uk_au = "N 1/2";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 17.35 ||
        ring_size == 0.683 ||
        ring_size == 54.51 ||
        ring_size == 2.15
      ) {
        us_ca = "7";
        uk_au = "O";
        f = "55 1/4";
        g = "17 1/4";
        s = "15 1/4";
        j = "14";
      } else if (
        ring_size == 17.45 ||
        ring_size == 0.687 ||
        ring_size == 54.82 ||
        ring_size == 2.16
      ) {
        us_ca = "7 1/4";
        uk_au = "O 1/2";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 17.75 ||
        ring_size == 0.699 ||
        ring_size == 55.76 ||
        ring_size == 2.2
      ) {
        us_ca = "7 1/2";
        uk_au = "P";
        f = "56 1/2";
        g = "17 3/4";
        s = "16 1/2";
        j = "15";
      } else if (
        ring_size == 17.97 ||
        ring_size == 0.707 ||
        ring_size == 56.45 ||
        ring_size == 2.22
      ) {
        us_ca = "7 3/4";
        uk_au = "P 1/2";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 18.19 ||
        ring_size == 0.716 ||
        ring_size == 57.15 ||
        ring_size == 2.25
      ) {
        us_ca = "8";
        uk_au = "Q";
        f = "57 3/4";
        g = "18";
        s = "17 3/4";
        j = "16";
      } else if (
        ring_size == 18.35 ||
        ring_size == 0.722 ||
        ring_size == 57.65 ||
        ring_size == 2.27
      ) {
        us_ca = "8 1/4";
        uk_au = "Q 1/2";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 18.53 ||
        ring_size == 0.729 ||
        ring_size == 58.21 ||
        ring_size == 2.29
      ) {
        us_ca = "8 1/2";
        uk_au = "Q 3/4";
        f = "-";
        g = "18 1/2";
        s = "-";
        j = "17";
      } else if (
        ring_size == 18.61 ||
        ring_size == 0.733 ||
        ring_size == 58.47 ||
        ring_size == 2.3
      ) {
        us_ca = "8 5/8";
        uk_au = "R";
        f = "59";
        g = "14 1/2";
        s = "19";
        j = "-";
      } else if (
        ring_size == 18.69 ||
        ring_size == 0.736 ||
        ring_size == 58.72 ||
        ring_size == 2.31
      ) {
        us_ca = "8 3/4";
        uk_au = "R 1/4";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 18.8 ||
        ring_size == 0.738 ||
        ring_size == 59.06 ||
        ring_size == 2.32
      ) {
        us_ca = "8 7/8";
        uk_au = "R 1/2";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 18.89 ||
        ring_size == 0.748 ||
        ring_size == 59.34 ||
        ring_size == 2.35
      ) {
        us_ca = "9";
        uk_au = "R 3/4";
        f = "-";
        g = "19";
        s = "-";
        j = "18";
      } else if (
        ring_size == 19.1 ||
        ring_size == 0.752 ||
        ring_size == 60.0 ||
        ring_size == 2.36
      ) {
        us_ca = "9 1/8";
        uk_au = "S";
        f = "60 1/4";
        g = "-";
        s = "20 1/4";
        j = "-";
      } else if (
        ring_size == 19.22 ||
        ring_size == 0.757 ||
        ring_size == 60.38 ||
        ring_size == 2.38
      ) {
        us_ca = "9 1/4";
        uk_au = "S 1/4";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 19.31 ||
        ring_size == 0.761 ||
        ring_size == 60.66 ||
        ring_size == 2.39
      ) {
        us_ca = "9 3/8";
        uk_au = "S 1/2";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 19.41 ||
        ring_size == 0.764 ||
        ring_size == 60.98 ||
        ring_size == 2.4
      ) {
        us_ca = "9 1/2";
        uk_au = "S 3/4";
        f = "-";
        g = "19 1/2";
        s = "-";
        j = "19";
      } else if (
        ring_size == 19.51 ||
        ring_size == 0.768 ||
        ring_size == 61.29 ||
        ring_size == 2.41
      ) {
        us_ca = "9 5/8";
        uk_au = "T";
        f = "61 1/2";
        g = "-";
        s = "21 1/2";
        j = "-";
      } else if (
        ring_size == 19.62 ||
        ring_size == 0.772 ||
        ring_size == 61.64 ||
        ring_size == 2.43
      ) {
        us_ca = "9 3/4";
        uk_au = "T 1/4";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 19.84 ||
        ring_size == 0.781 ||
        ring_size == 62.33 ||
        ring_size == 2.45
      ) {
        us_ca = "10";
        uk_au = "T 1/2";
        f = "-";
        g = "20";
        s = "-";
        j = "20";
      } else if (
        ring_size == 20.02 ||
        ring_size == 0.788 ||
        ring_size == 62.89 ||
        ring_size == 2.48
      ) {
        us_ca = "10 1/4";
        uk_au = "U";
        f = "62 3/4";
        g = "_";
        s = "22 3/4";
        j = "21";
      } else if (
        ring_size == 20.2 ||
        ring_size == 0.797 ||
        ring_size == 63.46 ||
        ring_size == 2.5
      ) {
        us_ca = "10 1/2";
        uk_au = "U 1/2";
        f = "-";
        g = "20 1/4";
        s = "-";
        j = "22";
      } else if (
        ring_size == 20.32 ||
        ring_size == 0.8 ||
        ring_size == 63.84 ||
        ring_size == 2.51
      ) {
        us_ca = "10 5/8";
        uk_au = "V";
        f = "63";
        g = "-";
        s = "23 3/4";
        j = "-";
      } else if (
        ring_size == 20.44 ||
        ring_size == 0.805 ||
        ring_size == 64.21 ||
        ring_size == 2.53
      ) {
        us_ca = "10 3/4";
        uk_au = "V 1/4";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 20.68 ||
        ring_size == 0.814 ||
        ring_size == 64.97 ||
        ring_size == 2.56
      ) {
        us_ca = "11";
        uk_au = "V 1/2";
        f = "-";
        g = "20 3/4";
        s = "-";
        j = "23";
      } else if (
        ring_size == 20.76 ||
        ring_size == 0.817 ||
        ring_size == 65.22 ||
        ring_size == 2.57
      ) {
        us_ca = "11 1/8";
        uk_au = "W";
        f = "65";
        g = "-";
        s = "25";
        j = "-";
      } else if (
        ring_size == 20.85 ||
        ring_size == 0.821 ||
        ring_size == 65.5 ||
        ring_size == 2.58
      ) {
        us_ca = "11 1/4";
        uk_au = "W 1/4";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 20.94 ||
        ring_size == 0.824 ||
        ring_size == 65.78 ||
        ring_size == 2.59
      ) {
        us_ca = "11 3/8";
        uk_au = "W 1/2";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 21.08 ||
        ring_size == 0.83 ||
        ring_size == 66.22 ||
        ring_size == 2.61
      ) {
        us_ca = "11 1/2";
        uk_au = "W 3/4";
        f = "-";
        g = "21";
        s = "-";
        j = "24";
      } else if (
        ring_size == 21.18 ||
        ring_size == 0.834 ||
        ring_size == 66.54 ||
        ring_size == 2.62
      ) {
        us_ca = "11 5/8";
        uk_au = "X";
        f = "66 1/4";
        g = "-";
        s = "26 1/4";
        j = "-";
      } else if (
        ring_size == 21.24 ||
        ring_size == 0.836 ||
        ring_size == 66.73 ||
        ring_size == 2.63
      ) {
        us_ca = "11 3/4";
        uk_au = "X 1/4";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 21.3 ||
        ring_size == 0.839 ||
        ring_size == 66.92 ||
        ring_size == 2.64
      ) {
        us_ca = "11 7/8";
        uk_au = "X 1/2";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 21.49 ||
        ring_size == 0.846 ||
        ring_size == 67.51 ||
        ring_size == 2.66
      ) {
        us_ca = "12";
        uk_au = "Y";
        f = "67 1/2";
        g = "21 1/4";
        s = "27 1/2";
        j = "25";
      } else if (
        ring_size == 21.69 ||
        ring_size == 0.854 ||
        ring_size == 68.14 ||
        ring_size == 2.68
      ) {
        us_ca = "12 1/4";
        uk_au = "Y 1/2";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 21.89 ||
        ring_size == 0.862 ||
        ring_size == 68.77 ||
        ring_size == 2.71
      ) {
        us_ca = "12 1/2";
        uk_au = "Z";
        f = "68 3/4";
        g = "21 3/4";
        s = "28 3/4";
        j = "26";
      } else if (
        ring_size == 22.1 ||
        ring_size == 0.869 ||
        ring_size == 69.43 ||
        ring_size == 2.73
      ) {
        us_ca = "12 3/4";
        uk_au = "Z +1/2";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      } else if (
        ring_size == 22.33 ||
        ring_size == 0.879 ||
        ring_size == 70.15 ||
        ring_size == 2.76
      ) {
        us_ca = "13";
        uk_au = "Z+1";
        f = "-";
        g = "22";
        s = "-";
        j = "27";
      } else if (
        ring_size == 22.6 ||
        ring_size == 0.891 ||
        ring_size == 71 ||
        ring_size == 2.8
      ) {
        us_ca = "13 1/2";
        uk_au = "Z + 1.5";
        f = "-";
        g = "-";
        s = "-";
        j = "-";
      }

      return {
        tech_ring_size: ring_size,
        tech_uk_au: uk_au,
        tech_us_ca: us_ca,
        tech_f: f,
        tech_g: g,
        tech_j: j,
        tech_s: s,
        tech_unit: unit,
      };
    } else {
      param.error = "Please check your input";
      return param;
    }
  }

  /**
   * getCalculationShoeSizeCalculator: Service Method
   * POST: /api/calculators-lol/shoe-size-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationShoeSizeCalculator(body) {
    const result = {};

    // Separate input variables from body
    let gen = (body.tech_gen || "").trim();
    let country = (body.tech_country || "").trim();
    let size = parseFloat(body.tech_size || 0);

    // Validate input
    if (!isNaN(size) && size >= 0) {
      let fcm, fin, us, uk, eu, ko, wo, m, mj;

      if (country === "fcm") {
        fcm = size;
      } else if (country === "fin") {
        fcm = size * 2.54;
      } else if (country === "ko") {
        fcm = size / 10;
      } else if (country === "mj") {
        fcm = size;
      } else if (country === "m") {
        fcm = size / 10;
      }

      if (gen === "ad") {
        if (country === "us") {
          fcm = (size + 24) * 0.847 - 2 * 0.847;
        } else if (country === "uk") {
          fcm = (size + 25) * 0.847 - 2 * 0.847;
        } else if (country === "eu") {
          fcm = size * 0.667 - 2 * 0.667;
        }

        fin = fcm / 2.54;
        us = (fcm + 2 * 0.847) / 0.847 - 24;
        ko = ((us + 22) / 3) * 25.5;
        wo = (fcm + 2 * 0.847) / 0.847 - 23;
        uk = fin * 3 - 23;
        eu = Math.floor(1.27 * (uk + 23 + 2));
        m = fcm * 10;
        mj = fcm;
      } else if (gen === "c") {
        if (country === "us") {
          fcm = ((size + 11.5 - 0.4) * 0.847) / 1.08;
        } else if (country === "uk") {
          fcm = ((size + 12 - 0.4) * 0.847) / 1.08;
        } else if (country === "eu") {
          fcm = (size * 0.667) / 1.08;
        }

        ko = fcm * 10;
        fin = fcm / 2.54;
        us = (fcm * 1.08) / 0.847 - 11.5 + 0.4;
        uk = (fcm * 1.08) / 0.847 - 12 + 0.4;
        eu = (fcm + 2 * 0.667) / 0.667;
        m = fcm * 10;
        mj = fcm;
        wo = "not yet";
      }

      result.tech_us = us;
      result.tech_fcm = fcm;
      result.tech_fin = fin;
      result.tech_uk = uk;
      result.tech_eu = eu;
      result.tech_ko = ko;
      result.tech_wo = wo;
      result.tech_m = m;
      result.tech_mj = mj;
      result.tech_country = country;
      result.tech_gen = gen;
    } else {
      result.error = "Please! Check Your Input";
    }

    return result;
  }

  /**
   * getCalculationCurtainSizeCalculator: Service Method
   * POST: /api/calculators-lol/curtain-size-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCurtainSizeCalculator(body) {
    let type_curtain = (body.tech_type_curtain || "").trim();
    let fullness = (body.tech_fullness || "").trim();
    let w_height = parseFloat(body.tech_w_height);
    let w_width = parseFloat(body.tech_w_width);
    let wh_units = (body.tech_wh_units || "").trim();
    let ww_units = (body.tech_ww_units || "").trim();

    let result = {};

    if (!type_curtain) {
      result.error = "Please! Check Your Inputs";
      return result;
    }

    if (!isFinite(w_height) || !isFinite(w_width)) {
      result.error = "Please! Check Your Inputs";
      return result;
    }

    // Convert height units to inches
    if (wh_units === "mm") {
      w_height = w_height * 25.4;
    } else if (wh_units === "cm") {
      w_height = w_height * 2.54;
    } else if (wh_units === "m") {
      w_height = w_height / 39.37;
    } else if (wh_units === "ft") {
      w_height = w_height / 12;
      console.log(w_height);
    } else if (wh_units === "yd") {
      w_height = w_height / 36;
    }

    // Convert width units to inches
    if (ww_units === "mm") {
      w_width = w_width * 25.4;
    } else if (ww_units === "cm") {
      w_width = w_width * 2.54;
    } else if (ww_units === "m") {
      w_width = w_width / 39.37;
    } else if (ww_units === "ft") {
      w_width = w_width / 12;
    } else if (ww_units === "yd") {
      w_width = w_width / 36;
    }

    let c_lenght = 0;
    if (type_curtain === "sill_lenght") {
      c_lenght = w_height + 4;
    } else if (type_curtain === "cafe_length") {
      c_lenght = w_height / 2;
    } else if (type_curtain === "extra_long") {
      c_lenght = w_height + 4 + 6;
    }

    let c_width = 0;
    if (fullness === "std_full") {
      c_width = w_width * 2;
    } else if (fullness === "del_full") {
      c_width = w_width * 2.5;
    } else if (fullness === "ult_full") {
      c_width = w_width * 3;
    }

    result.tech_type_curtain = type_curtain;
    result.tech_w_height = w_height;
    result.tech_w_width = w_width;
    result.tech_c_lenght = c_lenght;
    result.tech_c_width = c_width;
    return result;
  }

  /**
   * getCalculationTeslaChargingCalculator: Service Method
   * POST: /api/calculators-lol/tesla-charging-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTeslaChargingCalculator(body) {
    let main_unit = (body.tech_main_unit || "").trim();
    let battery = parseFloat(body.tech_battery);
    let electricity = parseFloat(body.tech_electricity);
    let type = (body.tech_type || "").trim();
    let price = parseFloat(body.tech_price);
    let distance = parseFloat(body.tech_distance);
    let units = (body.tech_units || "").trim();

    let result = {};

    if (main_unit === "Full Capacity Charging Cost") {
        if (isFinite(battery) && isFinite(electricity)) {
            let cost = battery * electricity;
            result.tech_cost = cost;
        } else {
            result.error = 'Please! Check Your Inputs';
            return result;
        }
    } else if (main_unit === "Custom Distance Charging Cost") {
      const Model = {
        1: { name: "Tesla Model S (2013 - 60D)", capacity: 60, efficiency: 35 },
        2: { name: "Tesla Model S (2016 - 60D)", capacity: 62, efficiency: 32 },
        3: {
          name: "Tesla Model S (2017 - 100D)",
          capacity: 95,
          efficiency: 33,
        },
        4: { name: "Tesla Model 3 (2019)", capacity: 54, efficiency: 26 },
        5: { name: "Tesla Model 3 (2021)", capacity: 82, efficiency: 29 },
        6: { name: "Tesla Model X (2016 - 90D)", capacity: 90, efficiency: 34 },
        7: {
          name: "Tesla Model X (2016 - P100D)",
          capacity: 100,
          efficiency: 38,
        },
        8: { name: "Tesla Model Y (2021)", capacity: 75, efficiency: 24 },
        9: { name: "Chevrolet Bolt (2016)", capacity: 60, efficiency: 20.8 },
        10: { name: "Audi Q4 e-tron 50 quattro", capacity: 77, efficiency: 32 },
        11: { name: "Nissan Leaf", capacity: 36, efficiency: 28 },
        12: {
          name: "Hyundai IONIQ Electric",
          capacity: 38.3,
          efficiency: 24.5,
        },
        13: { name: "Citroen e-C4", capacity: 45, efficiency: 29 },
        14: { name: "Kia EV6", capacity: 58, efficiency: 26.5 },
        15: { name: "Kia Soul EV", capacity: 64, efficiency: 28 },
        16: { name: "BMW i3", capacity: 37.9, efficiency: 26 },
        17: { name: "BMW i4", capacity: 80, efficiency: 29 },
        18: { name: "Fiat 500e", capacity: 42, efficiency: 27.5 },
        19: { name: "Hyundai Kona Electric", capacity: 64, efficiency: 26 },
      };

      if (!type || !Model[type]) {
        result.error = "Please! Check Your Inputs";
        return result;
      }

      if (!isFinite(price) || !isFinite(distance)) {
        result.error = "Please! Check Your Inputs";
        return result;
      }

      let model = Model[type];
      let name = model.name;
      let capacity = model.capacity;
      let efficiency = model.efficiency;

      if (units === "mi") {
        distance = distance * 1.609; // Convert miles to km
      }

      efficiency = efficiency * 0.621; // Convert km/kw to mi/kw

      let cost = price * capacity;
      let res = price * distance * efficiency;
      let ec = res / 100;

        result.tech_name = name;
        result.tech_capacity = capacity;
        result.tech_efficiency = efficiency;
        result.tech_cost = cost;
        result.tech_ec = ec;
    } else {
      result.error = "Please! Check Your Inputs";
      return result;
    }
    return result;
  }

  /**
   * getCalculationCompressionHightCalculator: Service Method
   * POST: /api/calculators-lol/compression-height-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCompressionHightCalculator(body) {
    let height = parseFloat(body.tech_height);
    let height_unit = (body.tech_height_unit || "").trim();
    let stone = parseFloat(body.tech_stone);
    let stone_unit = (body.tech_stone_unit || "").trim();
    let length = parseFloat(body.tech_length);
    let length_unit = (body.tech_length_unit || "").trim();
    let deck = parseFloat(body.tech_deck);
    let deck_unit = (body.tech_deck_unit || "").trim();

    function unitIn(value, unit) {
      return unit === "in" ? value : value * 39.37;
    }

    let result = {};

    if (
      isFinite(height) &&
      isFinite(stone) &&
      isFinite(length) &&
      isFinite(deck)
    ) {
      height = unitIn(height, height_unit);
      length = unitIn(length, length_unit);
      stone = unitIn(stone, stone_unit);
      deck = unitIn(deck, deck_unit);

      let compression_val = height - 0.5 * stone - length - deck;
      let compression_val_m = compression_val / 39.37;

      result.tech_compression_val = compression_val;
      result.tech_compression_val_m = compression_val_m;
    } else {
      result.error = "Please! Check Your Inputs";
      return result;
    }

    return result;
  }

  /**
   * getCalculationFuelCostCalculator: Service Method
   * POST: /api/calculators-lol/fuel-cost-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationFuelCostCalculator(body) {
    let distance = parseFloat(body.tech_distance);
    let d_units = (body.tech_d_units || "").trim();
    let f_efficiency = parseFloat(body.tech_f_efficiency);
    let f_eff_units = (body.tech_f_eff_units || "").trim();
    let f_price = parseFloat(body.tech_f_price);
    let f_p_units = (body.tech_f_p_units || "").trim();
    let currency = (body.tech_currancy || "").trim();

    let result = {};

    // Clean up currency from price unit (e.g., "$/L" -> "/L")
    f_p_units = f_p_units.replace(currency, "");

    if (isFinite(distance) && isFinite(f_efficiency) && isFinite(f_price)) {
      // Convert distance to kilometers if in miles
      if (d_units === "mi") {
        distance *= 1.6093;
      }

      // Convert fuel efficiency to km per liter
      if (f_eff_units === "L/100km") {
        f_efficiency = 100 / f_efficiency;
      } else if (f_eff_units === "US mpg") {
        f_efficiency = f_efficiency * 0.425144;
      } else if (f_eff_units === "UK mpg") {
        f_efficiency = f_efficiency * 0.354006;
      } else if (f_eff_units === "lpm") {
        f_efficiency = (1 / f_efficiency) * 1.6093;
      }

      // Convert fuel price to per liter
      if (f_p_units === "/cl") {
        f_price = f_price * 100;
      } else if (f_p_units === "/US gal") {
        f_price = f_price * 0.26;
      } else if (f_p_units === "/UK gal") {
        f_price = f_price * 0.22;
      }

      let fuel = distance / f_efficiency;
      let trip_cost = fuel * f_price;

      result.tech_distance = distance;
      result.tech_f_efficiency = f_efficiency;
      result.tech_f_eff_units = f_eff_units;
      result.tech_f_p_units = f_p_units;
      result.tech_f_price = f_price;
      result.tech_fuel = fuel;
      result.tech_trip_cost = trip_cost;
    } else {
      result.error = "Please! Check Your Inputs";
    }

    return result;
  }

  /**
   * getCalculationLawnMowingCostCalculator: Service Method
   * POST: /api/calculators-lol/lawn-mowing-cost-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLawnMowingCostCalculator(body) {
    let type = (body.tech_type || "").trim();
    let charges = (body.tech_charges || "").trim();
    let mow_price = parseFloat(body.tech_mow_price);
    let m_p_units = (body.tech_m_p_units || "").trim();
    let currancy = (body.tech_currancy || "").trim();
    let area_mow = parseFloat(body.tech_area_mow);
    let a_m_units = (body.tech_a_m_units || "").trim();
    let hours_work = parseFloat(body.tech_hours_work);
    let mow_speed = parseFloat(body.tech_mow_speed);
    let mow_speed_units = (body.tech_mow_speed_units || "").trim();
    let mow_width = parseFloat(body.tech_mow_width);
    let mow_width_units = (body.tech_mow_width_units || "").trim();
    let mow_pro = parseFloat(body.tech_mow_pro);
    let to_mow = parseFloat(body.tech_to_mow);
    let to_mow_units = (body.tech_to_mow_units || "").trim();

    m_p_units = m_p_units.replace(currancy + " ", "");

    let result = {};

    function perAreaUnit(input, unit) {
      if (unit === "m²") input = input / 1000000;
      else if (unit === "ft²") input = input / 10760000;
      else if (unit === "yd²") input = input / 1196000;
      else if (unit === "a") input = input * 0.0001;
      else if (unit === "da") input = input * 0.001;
      else if (unit === "ha") input = input / 100;
      else if (unit === "ac") input = input / 247.1;
      return input;
    }

    if (type === "lawn_mowed") {
      if (charges === "area") {
        if (isFinite(mow_price) && isFinite(area_mow)) {
          if (m_p_units) mow_price = perAreaUnit(mow_price, m_p_units);
          if (a_m_units) area_mow = perAreaUnit(area_mow, a_m_units);
          let total_cost = mow_price * area_mow;

          result.tech_mow_price = mow_price;
          result.tech_area_mow = area_mow;
          result.tech_total_cost = total_cost;
        } else {
          return { error: "Please! Check Your Input" };
        }
      } else if (charges === "hour") {
        if (isFinite(mow_price) && isFinite(hours_work)) {
          let total_cost = mow_price * hours_work;
          result.tech_mow_price = mow_price;
          result.tech_hours_work = hours_work;
          result.tech_total_cost = total_cost;
        } else {
          return { error: "Please! Check Your Input" };
        }
      }

      result.charges = charges;
    } else if (type === "mowing_time") {
      if (isFinite(mow_speed) && isFinite(mow_width) && isFinite(mow_pro)) {
        if (mow_speed_units === "m/h") {
          mow_speed /= 1000;
        } else if (mow_speed_units === "ft/h") {
          mow_speed /= 3281;
        }

        if (mow_width_units === "cm") {
          mow_width /= 100000;
        } else if (mow_width_units === "m") {
          mow_width /= 1000;
        } else if (mow_width_units === "in") {
          mow_width /= 39370;
        } else if (mow_width_units === "ft") {
          mow_width /= 3281;
        }

        let res = mow_speed * mow_width;
        let per = mow_pro / 100;
        let m_cost = res * per;

        result.tech_mow_speed = mow_speed;
        result.tech_mow_width = mow_width;
        result.tech_mow_pro = mow_pro;
        result.tech_m_cost = m_cost;

        if (!isNaN(to_mow)) {
          if (to_mow_units) {
            to_mow = perAreaUnit(to_mow, to_mow_units);
          }
          let m_time = to_mow / m_cost;
          let hours = Math.floor(m_time);
          let minutes = Math.floor((m_time - hours) * 60);
          result.tech_to_mow = to_mow;
          result.tech_hours = hours;
          result.tech_minutes = minutes;
        }
      } else {
        return { error: "Please! Check Your Input" };
      }
    }

    result.tech_type = type;
    return result;
  }

  /**
   * getCalculationTvSizeCalculator: Service Method
   * POST: /api/calculators-lol/tv-size-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTvSizeCalculator(body) {
    let selection = body.tech_selection;
    let size = body.tech_size;
    let size_unit = body.tech_size_unit;
    let resolution = body.tech_resolution;
    let angle = body.tech_angle;
    let angle_unit = body.tech_angle_unit;
    let distance = body.tech_distance;
    let distance_unit = body.tech_distance_unit;

    // Helper function to get total vertical pixels from resolution keyword
    function getPixelValue(resolution) {
      const pixelMap = {
        "480p": 480,
        "720p": 720,
        "1080p": 1080,
        ultra_hd: 2160,
        "4k": 2160,
        "8k": 4320,
      };
      return pixelMap[resolution] || 0;
    }

    // Helper to round to significant figures
    function sigFig(value, digits) {
      if (value !== "") {
        if (value === 0) return parseFloat(value.toFixed(digits - 1));
        let decimalPlaces =
          digits - Math.floor(Math.log10(Math.abs(value))) - 1;
        decimalPlaces = Math.max(decimalPlaces, 0); // Prevent negative decimals
        return parseFloat(value.toFixed(decimalPlaces));
      }
      return "";
    }

    let param = {};

    // Parse input numbers
    let sizeFloat = parseFloat(size);
    let distanceFloat = parseFloat(distance);
    let angleFloat = parseFloat(angle);

    // Output variables
    let width, height, pixels, new_angle, md, unit;
    let md_cm,
      md_m,
      md_ft,
      od = "",
      od_cm = "",
      od_m = "",
      od_ft = "";

    if (selection === "size") {
      // If calculating from screen size
      if (!isNaN(sizeFloat) && size_unit && resolution) {
        // Convert input size to inches
        if (size_unit === "cm") sizeFloat /= 2.54;
        else if (size_unit === "m") sizeFloat /= 0.0254;
        else if (size_unit === "ft") sizeFloat /= 0.08333;

        width = (16 / Math.sqrt(16 ** 2 + 9 ** 2)) * sizeFloat;
        height = sizeFloat * 0.49;

        pixels = (16 / 9) * getPixelValue(resolution);
        new_angle = pixels / 60;

        md = width / (2 * Math.tan((new_angle / 2) * (Math.PI / 180)));
        unit = size_unit;

        md_cm = md * 2.54;
        md_m = md * 0.0254;
        md_ft = md * 0.08333;
      } else {
        return { error: "Please! Check Your Input" };
      }
    } else if (selection === "distance") {
      // If calculating from distance
      if (!isNaN(distanceFloat) && distance_unit && resolution) {
        const jugaadValues = {
          "480p": 0.28616,
          "720p": 0.4322,
          "1080p": 0.658,
          ultra_hd: 1.434,
          "4k": 1.5556,
          "8k": 4.705,
        };
        const jugaad = jugaadValues[resolution];
        if (!jugaad) return { error: "Unsupported resolution" };

        pixels = (16 / 9) * getPixelValue(resolution);
        new_angle = pixels / 60;

        width =
          distanceFloat * (2 * Math.tan((new_angle / 2) * (Math.PI / 180)));
        width = width / 0.08333;

        sizeFloat = distanceFloat * jugaad;
        sizeFloat = sizeFloat / 0.08333;

        height = sizeFloat * 0.49;
        md = distanceFloat;
        unit = distance_unit;

        md_cm = md * 30.5;
        md_m = md * 0.305;
        md_ft = md;
        md = md * 12;
      } else {
        return { error: "Please! Check Your Input" };
      }
    } else {
      return { error: "Please! Check Your Input" };
    }

    // Calculate optimal viewing distance based on visual angle
    if (!isNaN(angleFloat) && angle_unit) {
      let angleRad =
        angle_unit === "deg" ? angleFloat * (Math.PI / 180) : angleFloat;
      if (angleRad > Math.PI) {
        return {
          error:
            "Flat screens have a 180° field of vision; you can't see beyond that angle (unless your nose is touching it 😉).",
        };
      }

      let tanVal = Math.tan(angleRad / 2);
      od = (0.5 * width) / tanVal;

      od_cm = od * 2.54;
      od_m = od * 0.0254;
      od_ft = od * 0.08333;
    }

    // Unit conversions
    let size_cm = sizeFloat * 2.54;
    let size_m = sizeFloat * 0.0254;
    let size_ft = sizeFloat * 0.08333;

    let width_cm = width * 2.54;
    let width_m = width * 0.0254;
    let width_ft = width * 0.08333;

    let height_cm = height * 2.54;
    let height_m = height * 0.0254;
    let height_ft = height * 0.08333;

    // Final formatted answer
    const ans = [
      sigFig(sizeFloat, 4),
      sigFig(width, 4),
      sigFig(height, 4),
      sigFig(od_ft, 3),
      sigFig(md_ft, 3),
    ];

    return {
      tech_ans: ans,
      tech_unit: unit,
      tech_units_cm: [
        sigFig(size_cm, 4),
        sigFig(width_cm, 4),
        sigFig(height_cm, 4),
        sigFig(od_cm, 3),
        sigFig(md_cm, 3),
      ],
      tech_units_m: [
        sigFig(size_m, 4),
        sigFig(width_m, 4),
        sigFig(height_m, 4),
        sigFig(od_m, 3),
        sigFig(md_m, 3),
      ],
      tech_units_in: [
        sigFig(sizeFloat, 4),
        sigFig(width, 4),
        sigFig(height, 4),
        sigFig(od, 3),
        sigFig(md, 3),
      ],
      tech_units_ft: [
        sigFig(size_ft, 4),
        sigFig(width_ft, 4),
        sigFig(height_ft, 4),
        sigFig(od_ft, 3),
        sigFig(md_ft, 3),
      ],
    };
  }

  /**
   * getCalculationRiverRockCalculator: Service Method
   * POST: /api/calculators-lol/river-rock-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRiverRockCalculator(body) {
    let rock_type = body.tech_rock_type;
    let density = body.tech_density;
    let density_unit = body.tech_density_unit;
    let length = body.tech_length;
    let length_unit = body.tech_length_unit;
    let width = body.tech_width;
    let width_unit = body.tech_width_unit;
    let depth = body.tech_depth;
    let depth_unit = body.tech_depth_unit;
    let wastage = body.tech_wastage;
    let price = body.tech_price;
    let price_unit = body.tech_price_unit;
    let currancy = body.tech_currancy;

    price_unit = price_unit.replace(currancy, "");

    function sigFig(value, digits) {
      if (value !== "") {
        if (value === 0) {
          return Number(value.toFixed(digits - 1));
        }
        let decimalPlaces =
          digits - Math.floor(Math.log10(Math.abs(value))) - 1;
        return Number(value.toFixed(Math.max(0, decimalPlaces)));
      }
    }

    if (
      !isNaN(length) &&
      length_unit &&
      !isNaN(width) &&
      width_unit &&
      !isNaN(depth) &&
      depth_unit &&
      !isNaN(density)
    ) {
      length = parseFloat(length);
      width = parseFloat(width);
      depth = parseFloat(depth);
      density = parseFloat(density);
      wastage = parseFloat(wastage || 0);
      price = parseFloat(price || 0);

      // Unit conversions
      const unitMap = {
        mm: 1000,
        cm: 100,
        in: 39.3701,
        ft: 3.28084,
        yd: 1.093613,
      };

      if (unitMap[length_unit]) length = length / unitMap[length_unit];
      if (unitMap[width_unit]) width = width / unitMap[width_unit];
      if (unitMap[depth_unit]) depth = depth / unitMap[depth_unit];

      const densityConversions = {
        t_m3: 1 / 0.001,
        g_cm3: 1 / 0.001,
        lb_cu_in: 1 / 0.0000361273,
        lb_cu_ft: 1 / 0.062428,
        lb_cu_yd: 1 / 1.685555,
      };

      if (densityConversions[density_unit])
        density = density * densityConversions[density_unit];

      const area = width * length;
      const volume = area * depth * (1 + wastage / 100);
      let weight = volume * density * 0.001;

      let price_v = 0;
      let total_cost = 0;
      let price_v_units = [];

      if (!isNaN(price) && price_unit) {
        const priceConversions = {
          "/kg": 1000,
          "/lb": 2204.62,
          "/stone": 157.47,
          "/us_ton": 1.1,
          "/long_ton": 0.98,
        };
        if (priceConversions[price_unit])
          price = price * priceConversions[price_unit];

        price_v = (price * density) / 1000;
        total_cost = price * weight;

        price_v_units = [
          `${sigFig(price_v / 1000000, 3)}@@@cm³`,
          `${sigFig(price_v / 61023.74, 3)}@@@cu in`,
          `${sigFig(price_v * 0.03, 3)}@@@cu ft`,
          `${sigFig(price_v * 0.76, 3)}@@@cu yd`,
        ];
      }

      const volume_units = [
        `${sigFig(volume * 1000000, 3)}@@@cm³`,
        `${sigFig(volume * 61024, 3)}@@@cu in`,
        `${sigFig(volume * 35.3, 3)}@@@cu ft`,
        `${sigFig(volume * 1.308, 3)}@@@cu yd`,
      ];

      const weight_units = [
        `${sigFig(weight * 1000, 3)}@@@kg`,
        `${sigFig(weight * 2205, 3)}@@@lb`,
        `${sigFig(weight * 157.5, 3)}@@@stone`,
        `${sigFig(weight * 1.102, 3)}@@@US ton`,
        `${sigFig(weight * 0.984, 3)}@@@Long ton`,
      ];

      const area_units = [
        `${sigFig(area * 10000, 3)}@@@cm²`,
        `${sigFig(area * 0.000001, 3)}@@@km²`,
        `${sigFig(area * 1550, 3)}@@@in²`,
        `${sigFig(area * 10.76, 3)}@@@ft²`,
        `${sigFig(area * 1.196, 3)}@@@yd²`,
        `${sigFig(area * 0.000000386, 3)}@@@mi²`,
      ];

      return {
        tech_volume: sigFig(volume, 3),
        tech_volume_units: volume_units,
        tech_weight: sigFig(weight, 3),
        tech_weight_units: weight_units,
        tech_area: sigFig(area, 3),
        tech_area_units: area_units,
        tech_price_v: sigFig(price_v, 3),
        tech_price_v_units: price_v_units,
        tech_total_cost: sigFig(total_cost, 3),
      };
    } else {
      return { error: "Please! Check Your Inputs" };
    }
  }

  /**
   * getCalculationCircleSkirtCalculator: Service Method
   * POST: /api/calculators-lol/circle-skirt-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCircleSkirtCalculator(body) {
    let type = body.tech_type;
    let length = body.tech_length;
    let length_unit = body.tech_length_unit;
    let waist = body.tech_waist;
    let waist_unit = body.tech_waist_unit;

    function convertToCm(value, unit) {
      switch (unit) {
        case "mm":
          return value * 0.1; // Millimeters to centimeters
        case "cm":
          return value; // Centimeters to centimeters
        case "m":
          return value * 100; // Meters to centimeters
        case "in":
          return value * 2.54; // Inches to centimeters
        case "ft":
          return value * 30.48; // Feet to centimeters
        default:
          return null; // Invalid unit
      }
    }

    if (!isNaN(length) && !isNaN(waist) && type) {
      length = parseFloat(length);
      waist = parseFloat(waist);

      let length_cm = convertToCm(length, length_unit);
      let waist_cm = convertToCm(waist, waist_unit);

      if (length_cm === null || waist_cm === null) {
        return { error: "Invalid unit provided" };
      }

      let radius_cm;

      // π = 3.14
      const pi = 3.14;
      if (type === "full") {
        radius_cm = waist_cm / (2 * pi) - 2;
      } else if (type === "three-quarter") {
        radius_cm = ((4 / 3) * waist_cm) / (2 * pi) - 2;
      } else if (type === "half") {
        radius_cm = (2 * waist_cm) / (2 * pi) - 2;
      } else if (type === "quarter") {
        radius_cm = (4 * waist_cm) / (2 * pi) - 2;
      } else {
        return { error: "Invalid skirt type" };
      }

      let radius_mm = radius_cm * 10;
      let radius_m = radius_cm / 100;
      let radius_in = radius_cm / 2.54;
      let radius_ft = radius_cm / 30.48;

      let fabric_length_cm = length_cm + radius_cm + 2;
      let fabric_length_mm = fabric_length_cm * 10;
      let fabric_length_m = fabric_length_cm / 100;
      let fabric_length_in = fabric_length_cm / 2.54;
      let fabric_length_ft = fabric_length_cm / 30.48;

      return {
        tech_radius_cm: Number(radius_cm.toFixed(2)),
        tech_radius_mm: Number(radius_mm.toFixed(2)),
        tech_radius_m: Number(radius_m.toFixed(2)),
        tech_radius_in: Number(radius_in.toFixed(2)),
        tech_radius_ft: Number(radius_ft.toFixed(2)),
        tech_fabric_length_cm: Number(fabric_length_cm.toFixed(2)),
        tech_fabric_length_mm: Number(fabric_length_mm.toFixed(2)),
        tech_fabric_length_m: Number(fabric_length_m.toFixed(2)),
        tech_fabric_length_in: Number(fabric_length_in.toFixed(2)),
        tech_fabric_length_ft: Number(fabric_length_ft.toFixed(2)),
      };
    } else {
      return { error: "Please! Check Your Inputs" };
    }
  }

  /**
   * getCalculationBotoxCostCalculator: Service Method
   * POST: /api/calculators-lol/botox-cost-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationBotoxCostCalculator(body) {
    let solve = body.tech_solve;
    let input_f = body.tech_input_f;
    let input_s = body.tech_input_s;

    if (isNaN(input_f) || isNaN(input_s)) {
      return { error: "Please! Check Your Input" };
    }

    let answer;

    // Check if solve is "1" or "2"
    if (solve === "1" || solve === "2") {
      answer = input_f / input_s; // Division
    } else {
      answer = input_f * input_s; // Multiplication
    }

    return {
      tech_answer: answer,
    };
  }
  /**
   * getCalculationYardsToTonsCalculator: Service Method
   * POST: /api/calculators-lol/yards-to-tons-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationYardsToTonsCalculator(body) {
    let density = body.tech_density;
    let density_unit = body.tech_density_unit;
    let cubic_yards = body.tech_cubic_yards;

    // Function to convert density to cubic yard based on the density unit
    function cubicYard(density, density_unit) {
      let total_cubic_yard = 0;

      if (density_unit === "lb/ft³") {
        total_cubic_yard = density / 74.074;
      } else if (density_unit === "kg/m³") {
        total_cubic_yard = density / 1187;
      }

      return total_cubic_yard;
    }

    // Check if the inputs are numeric
    if (isNaN(density) || isNaN(cubic_yards)) {
      return { error: "Please! Check Your Input" };
    }

    // Convert density and calculate tons
    density = cubicYard(density, density_unit);
    let tons = density * cubic_yards;
    let metric_tonnes = tons * 0.907185;
    let pounds = metric_tonnes * 2204.62;

    return {
      tech_tons: tons,
      tech_metric_tonnes: metric_tonnes,
      tech_pounds: pounds,
    };
  }
  /**
   * getCalculationDilutionRatioCalculator: Service Method
   * POST: /api/calculators-lol/dilution-ratio-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDilutionRatioCalculator(body) {
    let final_volume = body.tech_final_volume;
    let final_unit = body.tech_final_unit;
    let dilution_ratio = body.tech_dilution_ratio;
    let concentrate_volume = body.tech_concentrate_volume;
    let concentrate_unit = body.tech_concentrate_unit;
    let water_volume = body.tech_water_volume;
    let water_unit = body.tech_water_unit;

    const dilutionUnit = (input, unit) => {
      const conversions = {
        "cm³": 0.001,
        "dm³": 1,
        "m³": 1000,
        cuin: 0.016387,
        cuft: 28.317,
        cuyd: 764.6,
        ml: 0.001,
        cl: 0.01,
        USgal: 3.7854,
        UKgal: 4.546,
      };
      return input * (conversions[unit] || 1);
    };

    const isNumeric = (n) => !isNaN(parseFloat(n)) && isFinite(n);

    if (
      isNumeric(final_volume) &&
      isNumeric(dilution_ratio) &&
      !concentrate_volume &&
      !water_volume
    ) {
      final_volume = dilutionUnit(final_volume, final_unit);
      let cv = final_volume / (parseFloat(dilution_ratio) + 1);
      let wv = cv * parseFloat(dilution_ratio);
      return {
        tech_res1: `${cv.toFixed(2)} liters`,
        tech_res11: cv.toFixed(2),
        tech_res2: `${wv.toFixed(2)} liters`,
        tech_res22: wv.toFixed(2),
        tech_name1: "Concentrate volume",
        tech_name2: "Water volume",
      };
    } else if (
      isNumeric(final_volume) &&
      !dilution_ratio &&
      isNumeric(concentrate_volume) &&
      !water_volume
    ) {
      final_volume = dilutionUnit(final_volume, final_unit);
      concentrate_volume = dilutionUnit(concentrate_volume, concentrate_unit);
      let dr = final_volume / concentrate_volume - 1;
      let wv = dr * concentrate_volume;
      return {
        tech_res1: `${dr.toFixed(1)} :1`,
        tech_res11: dr.toFixed(1),
        tech_res2: `${wv.toFixed(2)} liters`,
        tech_res22: wv.toFixed(2),
        tech_name1: "Dilution ratio",
        tech_name2: "Water volume",
      };
    } else if (
      isNumeric(final_volume) &&
      !dilution_ratio &&
      !concentrate_volume &&
      isNumeric(water_volume)
    ) {
      final_volume = dilutionUnit(final_volume, final_unit);
      water_volume = dilutionUnit(water_volume, water_unit);
      let cv = final_volume - water_volume;
      if (cv === 0) {
        return { error: "Please! Division by zero chose other values" };
      }
      let dr = water_volume / cv;
      return {
        tech_res1: `${dr.toFixed(2)} :1`,
        tech_res11: dr.toFixed(2),
        tech_res2: `${cv.toFixed(2)} liters`,
        tech_res22: cv.toFixed(2),
        tech_name1: "Dilution ratio",
        tech_name2: "Concentrate volume",
      };
    } else if (
      !final_volume &&
      isNumeric(dilution_ratio) &&
      isNumeric(concentrate_volume) &&
      !water_volume
    ) {
      concentrate_volume = dilutionUnit(concentrate_volume, concentrate_unit);
      let fv = concentrate_volume * (parseFloat(dilution_ratio) + 1);
      let wv = concentrate_volume * parseFloat(dilution_ratio);
      return {
        tech_res1: `${fv.toFixed(2)} liters`,
        tech_res11: fv.toFixed(2),
        tech_res2: `${wv.toFixed(2)} liters`,
        tech_res22: wv.toFixed(2),
        tech_name1: "Final volume",
        tech_name2: "Water volume",
      };
    } else if (
      !final_volume &&
      isNumeric(dilution_ratio) &&
      !concentrate_volume &&
      isNumeric(water_volume)
    ) {
      water_volume = dilutionUnit(water_volume, water_unit);
      if (parseFloat(dilution_ratio) === 0) {
        return { error: "Please! Division by zero, chose other values" };
      }
      let cv = water_volume / parseFloat(dilution_ratio);
      let fv = cv * (parseFloat(dilution_ratio) + 1);
      return {
        tech_res1: `${fv.toFixed(2)} liters`,
        tech_res11: fv.toFixed(2),
        tech_res2: `${cv.toFixed(2)} liters`,
        tech_res22: cv.toFixed(2),
        tech_name1: "Final volume",
        tech_name2: "Concentrate volume",
      };
    } else if (
      !final_volume &&
      !dilution_ratio &&
      isNumeric(concentrate_volume) &&
      isNumeric(water_volume)
    ) {
      concentrate_volume = dilutionUnit(concentrate_volume, concentrate_unit);
      water_volume = dilutionUnit(water_volume, water_unit);
      let dr = water_volume / concentrate_volume;
      let fv = concentrate_volume * (dr + 1);
      return {
        tech_res1: `${dr.toFixed(2)} :1`,
        tech_res11: dr.toFixed(2),
        tech_res2: `${fv.toFixed(2)} liters`,
        tech_res22: fv.toFixed(2),
        tech_name1: "Dilution ratio",
        tech_name2: "Final volume",
      };
    } else {
      return { error: "Please! Enter only two values to get your result" };
    }
  }

  /**
   * getCalculationgpMCalculator: Service Method
   * POST: /api/calculators-lol/gpm-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationgpMCalculator(body) {
    let volume = body.tech_volume?.toString().trim();
    let vol_unit = body.tech_vol_unit?.toString().trim();
    let time = body.tech_time?.toString().trim();
    let time_unit = body.tech_time_unit?.toString().trim();
    let ans_unit = body.tech_ans_unit?.toString().trim();

    function volume_convert(a, b) {
      const conversions = {
        "mm³": a * 0.00000026417,
        "cm³": a * 0.00026417,
        "dm³": a * 0.26417,
        "m³": a * 264.17,
        "cu in": a * 0.004329,
        "cu ft": a * 7.48,
        "cu yd": a * 201.97,
        ml: a * 0.00026417,
        cl: a * 0.0026417,
        liters: a * 0.26417,
        "US gal": a,
        "UK gal": a * 1.201,
        "US fl oz": a * 0.007813,
        "UK fl oz": a * 0.007506,
        cups: a * 0.0625,
        tbsp: a * 0.0039626,
        tsp: a * 0.0013209,
        "US qt": a * 0.25,
        "UK qt": a * 0.30024,
        "US pt": a * 0.125,
        "UK pt": a * 0.15012,
      };
      return conversions[b] ?? null;
    }

    function time_convert(a, b) {
      const conversions = {
        sec: a * 1,
        min: a * 60,
        hrs: a * 3600,
        days: a * 86400,
        wks: a * 604800,
        mos: a * 2629800,
        yrs: a * 31557600,
      };
      return conversions[b] ?? null;
    }

    function ans_convert(a, b) {
      const map = {
        1: { val: a * 1, unit: "US gal/s" },
        2: { val: a * 60, unit: "US gal/min" },
        3: { val: a * 3600, unit: "US gal/h" },
        4: { val: a * 86400, unit: "US gal/day" },
        5: { val: a * 0.8327, unit: "UK gal/s" },
        6: { val: a * 49.96, unit: "UK gal/min" },
        7: { val: a * 2997.6, unit: "UK gal/h" },
        8: { val: a * 71943, unit: "UK gal/day" },
        9: { val: a * 0.13368, unit: "ft³/s" },
        10: { val: a * 8.021, unit: "ft³/min" },
        11: { val: a * 481.25, unit: "ft³/h" },
        12: { val: a * 11550, unit: "ft³/day" },
        13: { val: a * 3785410, unit: "mm³/s" },
        14: { val: a * 0.0037854, unit: "m³/s" },
        15: { val: a * 0.22712, unit: "m³/min" },
        16: { val: a * 13.627, unit: "m³/h" },
        17: { val: a * 327.06, unit: "m³/day" },
        18: { val: a * 3.7854, unit: "L/s" },
        19: { val: a * 227.12, unit: "L/min" },
        20: { val: a * 13627, unit: "L/h" },
        21: { val: a * 327059, unit: "L/day" },
        22: { val: a * 227125, unit: "ml/min" },
        23: { val: a * 13627476, unit: "ml/h" },
        24: { val: a * 7680, unit: "US fl oz / min" },
        25: { val: a * 460800, unit: "US fl oz / h" },
        26: { val: a * 7994, unit: "UK fl oz / min" },
        27: { val: a * 479620, unit: "UK fl oz / h" },
        28: { val: a * 480, unit: "US pt / min" },
        29: { val: a * 28800, unit: "US pt / h" },
        30: { val: a * 399.7, unit: "UK pt / min" },
        31: { val: a * 23981, unit: "UK pt / h" },
      };
      return map[b] ?? null;
    }

    const param = {};

    if (!isNaN(volume) && !isNaN(time)) {
      const volConverted = volume_convert(parseFloat(volume), vol_unit);
      const timeConverted = time_convert(parseFloat(time), time_unit);

      if (volConverted == null || timeConverted == null) {
        return { error: "Invalid volume or time unit" };
      }

      const rawRate = volConverted / timeConverted;
      const result = ans_convert(rawRate, ans_unit);

      if (result == null) {
        return { error: "Invalid answer unit selection" };
      }

      param.tech_main_ans = result.val;
      param.tech_answer_unit = result.unit;
    } else {
      param.error = "Please! Check Your Inputs";
    }

    return param;
  }

  /**
   * getCalculationCeilingfanSizeCalculator: Service Method
   * POST: /api/calculators-lol/ceiling-fan-size-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCeilingfanSizeCalculator(body) {
    let room_width = body.tech_room_width?.toString().trim();
    let room_length = body.tech_room_length?.toString().trim();
    let ceiling_height = body.tech_ceiling_height?.toString().trim();

    const param = {};

    if (!isNaN(room_width) && !isNaN(room_length) && !isNaN(ceiling_height)) {
      const width = parseFloat(room_width);
      const length = parseFloat(room_length);
      const height = parseFloat(ceiling_height);

      const squareFootage = width * length;

      let fanSize = "";
      if (squareFootage <= 75) {
        fanSize = "29 to 36 inches";
      } else if (squareFootage <= 144) {
        fanSize = "36 to 42 inches";
      } else if (squareFootage <= 225) {
        fanSize = "44 to 50 inches";
      } else {
        fanSize = "52 inches or larger";
      }

      const downrodLength = height >= 9 ? "6 inches" : "3 inches";

      param.tech_squareFootage = squareFootage;
      param.tech_fanSize = fanSize;
      param.tech_downrodLength = downrodLength;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }
  /**
   * getCalculationCostPerMileDrivingCalculator: Service Method
   * POST: /api/calculators-lol/cost-per-mile-driving-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCostPerMileDrivingCalculator(body) {
    let cost_of_gas = body.tech_cost_of_gas?.toString().trim();
    let miles_per_gallon = body.tech_miles_per_gallon?.toString().trim();
    let car_value = body.tech_car_value?.toString().trim();

    const param = {};

    if (!isNaN(cost_of_gas) && !isNaN(miles_per_gallon) && !isNaN(car_value)) {
      let gasCost = parseFloat(cost_of_gas); // e.g., 7
      let mpg = parseFloat(miles_per_gallon); // e.g., 7
      let carVal = parseFloat(car_value); // e.g., 4

      let car_value_div = carVal / 25000; // 0.00016
      let total_car_value = car_value_div * 0.03; // 4.8e-6
      let total_cost_mile = gasCost / mpg; // 1
      let answer = total_cost_mile + total_car_value + 0.05; // 1.0500048

      return {
        tech_answer: answer,
        tech_car_value: car_value_div,
        tech_total_car_value: total_car_value.toExponential(1), // "4.8e-6"
        tech_total_cost_mile: total_cost_mile,
        input_cost_of_gas: gasCost,
        input_miles_per_gallon: mpg,
        input_car_value: carVal,
      };
    } else {
      param.error = "Please! Check Your Input";
    }
  }

  /**
   * getCalculationGoldCostPerPoundCalculator: Service Method
   * POST: /api/calculators-lol/gold-cost-per-pound-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationGoldCostPerPoundCalculator(body) {
    let weight = body.tech_weight?.toString().trim();
    let cost = body.tech_cost?.toString().trim();

    const param = {};

    if (!isNaN(weight) && !isNaN(cost)) {
      let numericWeight = parseFloat(weight);
      let numericCost = parseFloat(cost);
      let GCP = numericCost / numericWeight;

      param.tech_GCP = parseFloat(GCP.toFixed(2)); // format to 2 decimal places
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }
  /**
   * getCalculationMoistureContentCalculator: Service Method
   * POST: /api/calculators-lol/moisture-content-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMoistureContentCalculator(body) {
    let wet = body.tech_wet?.toString().trim();
    let wet_unit = body.tech_wet_unit?.toString().trim();
    let dry = body.tech_dry?.toString().trim();
    let dry_unit = body.tech_dry_unit?.toString().trim();

    const param = {};

    if (!isNaN(wet) && !isNaN(dry)) {
      wet = parseFloat(wet);
      dry = parseFloat(dry);

      // Convert wet units
      switch (wet_unit) {
        case "mg":
          wet = wet / 1_000_000;
          break;
        case "g":
          wet = wet / 1_000;
          break;
        case "oz":
          wet = wet / 35.27396;
          break;
        case "lb":
          wet = wet / 2.204623;
          break;
      }

      // Convert dry units
      switch (dry_unit) {
        case "mg":
          dry = dry / 1_000_000;
          break;
        case "g":
          dry = dry / 1_000;
          break;
        case "oz":
          dry = dry / 35.27396;
          break;
        case "lb":
          dry = dry / 2.204623;
          break;
      }

      const mc = ((wet - dry) / wet) * 100;

      param.tech_mc = mc;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }
  /**
   * getCalculationShadedAreaCalculator: Service Method
   * POST: /api/calculators-lol/shaded-area-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationShadedAreaCalculator(body) {
    let solve = body.tech_solve?.toString().trim(); // e.g., "2@@m²"
    let input = body.tech_input?.toString().trim(); // e.g., "10"
    let in_unit = body.tech_in_unit?.toString().trim(); // e.g., "cm"

    const param = {};

    function convertInput(input, unit) {
      switch (unit) {
        case "m":
          return input * 1;
        case "AU":
          return input * 1.5e11;
        case "cm":
          return input * 0.001;
        case "km":
          return input * 1000;
        case "in":
          return input * 0.0254;
        case "ft":
          return input * 0.3048;
        case "mil":
          return input * 0.0000254;
        case "mm":
          return input * 0.001;
        case "nm":
          return input * 1e-9;
        case "mile":
          return input * 1609.344;
        case "parsec":
          return input * 3.08e16;
        case "pm":
          return input * 1e-12;
        case "yd":
          return input * 0.9144;
        default:
          return null;
      }
    }

    if (!isNaN(input)) {
      input = parseFloat(input);
      let convertedInput = convertInput(input, in_unit);

      if (convertedInput === null) {
        param.error = "Invalid input unit";
        return param;
      }

      const [val, unit] = solve.split("@@");
      const factor = parseFloat(val);

      const answer =
        Math.pow(convertedInput, 2) -
        3.14 * Math.pow(convertedInput / 2, 2) * factor;

      param.tech_answer = answer;
      param.tech_unit = unit;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationEngneHourstoMilesCalculator: Service Method
   * POST: /api/calculators-lol/engine-hours-to-miles-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationEngneHourstoMilesCalculator(body) {
    const f_input = parseFloat(body.tech_f_input);
    const s_input = parseFloat(body.tech_s_input);

    const param = {};

    if (!isNaN(f_input) && !isNaN(s_input)) {
      const answer = f_input * s_input;

      param.tech_answer = answer;
      param.input_f_input = f_input;
      param.input_s_input = s_input;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationMagnificationCalculator: Service Method
   * POST: /api/calculators-lol/magnification-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMagnificationCalculator(body) {
    let d = parseFloat(body.tech_d);
    const d_unit = body.tech_d_unit;
    let f = parseFloat(body.tech_f);
    const f_unit = body.tech_f_unit;

    const param = {};

    function sigFig2(value, digits) {
      if (value === 0) {
        return 0;
      }
      const decimalPlaces =
        digits - Math.floor(Math.log10(Math.abs(value))) - 1;
      return parseFloat(value.toFixed(decimalPlaces));
    }

    if (!isNaN(d) && !isNaN(f)) {
      // Distance unit conversion
      switch (d_unit) {
        case "mm":
          d /= 1000;
          break;
        case "cm":
          d /= 100;
          break;
        case "km":
          d /= 0.001;
          break;
        case "in":
          d /= 39.3701;
          break;
        case "ft":
          d /= 3.28084;
          break;
        case "yd":
          d /= 1.093613;
          break;
        case "mi":
          d /= 0.000621371;
          break;
        case "nmi":
          d /= 0.000539957;
          break;
      }

      // Focal length unit conversion
      switch (f_unit) {
        case "mm":
          f /= 1000;
          break;
        case "cm":
          f /= 100;
          break;
        case "km":
          f /= 0.001;
          break;
        case "in":
          f /= 39.3701;
          break;
        case "ft":
          f /= 3.28084;
          break;
        case "yd":
          f /= 1.093613;
          break;
      }

      const k = Math.pow(d, 2) / 4 - f * d;
      if (k < 0) {
        param.error = "Oops! Something Went Wrong";
        return param;
      }

      const r = Math.sqrt(k);
      const h = d / 2 - r;
      const g = d / 2 + r;
      const m = h / g;

      param.tech_h = sigFig2(h, 5);
      param.tech_g = sigFig2(g, 5);
      param.tech_m = sigFig2(m, 5);
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationSplitBillCalculator: Service Method
   * POST: /api/calculators-lol/split-bill-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationSplitBillCalculator(body) {
    const billAmount = parseFloat(body.tech_bill_amount);
    const split = parseFloat(body.tech_split);
    const param = {};

    if (!isNaN(billAmount) && !isNaN(split)) {
      if (split === 0) {
        param.error =
          "Number of ways to split the bill value cannot be equal to zero.";
        return param;
      }

      const answer = billAmount / split;
      param.tech_answer = answer;
      param.input_billAmount = billAmount;
      param.input_split = split;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationDrawLengthCalculator: Service Method
   * POST: /api/calculators-lol/draw-length-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDrawLengthCalculator(body) {
    const length = parseFloat(body.tech_length);
    const param = {};

    if (!isNaN(length)) {
      const draw = length / 2.5;
      const arrow = draw + 1.5;
      const draw_cm = draw * 2.54;
      const arrow_cm = arrow * 2.54;

      param.tech_draw = draw;
      param.tech_arrow = arrow;
      param.tech_draw_cm = draw_cm;
      param.tech_arrow_cm = arrow_cm;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationOnBasePercentageCalculator: Service Method
   * POST: /api/calculators-lol/on-base-percentage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationOnBasePercentageCalculator(body) {
    const hits = parseFloat(body.tech_hits);
    const bases = parseFloat(body.tech_bases);
    const pitch = parseFloat(body.tech_pitch);
    const bats = parseFloat(body.tech_bats);
    const flies = parseFloat(body.tech_flies);

    const param = {};

    if (
      !isNaN(hits) &&
      !isNaN(bases) &&
      !isNaN(pitch) &&
      !isNaN(bats) &&
      !isNaN(flies)
    ) {
      const denominator = bats + bases + pitch + flies;
      if (denominator === 0) {
        param.error = "Division by zero error. Please check input values.";
        return param;
      }

      const answer = (hits + bases + pitch) / denominator;
      param.tech_answer = answer;
      param.input_hits = hits;
      param.input_bases = bases;
      param.input_pitch = pitch;
      param.input_bats = bats;
      param.input_flies = flies;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationTaperCalculator: Service Method
   * POST: /api/calculators-lol/taper-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationTaperCalculator(body) {
    const major = parseFloat(body.tech_major);
    const majorUnit = body.tech_major_unit;
    const minor = parseFloat(body.tech_minor);
    const minorUnit = body.tech_minor_unit;
    const length = parseFloat(body.tech_length);
    const lengthUnit = body.tech_length_unit;

    const param = {};

    // Unit conversion function for length
    function taperUnit(length, lengthUnit) {
      let inches;
      switch (lengthUnit) {
        case "mm":
          inches = length / 25.4;
          break;
        case "in":
          inches = length * 1;
          break;
        case "cm":
          inches = length / 2.54;
          break;
        case "m":
          inches = length * 39.37;
          break;
        case "ft":
          inches = length / 12;
          break;
        default:
          inches = length;
      }
      return inches;
    }

    if (!isNaN(major) && !isNaN(minor) && !isNaN(length)) {
      const lengthMain = taperUnit(length, lengthUnit);
      const majorMain = taperUnit(major, majorUnit);
      const minorMain = taperUnit(minor, minorUnit);

      const taper = (majorMain - minorMain) / lengthMain;
      const main = taper * 1;
      const mainCm = taper / 2.54;
      const mainM = taper * 39.37;
      const mainFt = taper / 12;
      const mainMm = taper / 25.4;

      const sub = main / 2;
      const sudans = Math.atan(sub);
      const angle = (sudans * 180) / Math.PI; // Convert to degrees
      const answer = angle * 1;
      const answerRad = sudans;
      const answerGon = Math.pow(angle, 1.11111);

      param.tech_main = main;
      param.tech_main_cm = mainCm;
      param.tech_main_m = mainM;
      param.tech_main_ft = mainFt;
      param.tech_main_mm = mainMm;
      param.tech_answer = answer;
      param.tech_answer_rad = answerRad;
      param.tech_answer_gon = answerGon;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationBatteryLifeCalculator: Service Method
   * POST: /api/calculators-lol/battery-life-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBatteryLifeCalculator(body) {
    let batteryCapacity = parseFloat(body.tech_battery_capacity);
    const batteryUnits = body.tech_battery_units;
    const dischargeSafety = parseFloat(body.tech_discharge_safety);
    let deviceCon1 = parseFloat(body.tech_device_con1);
    const deviceCon1Units = body.tech_device_con1_units;
    let awakeTime = parseFloat(body.tech_awake_time);
    const awakeTimeUnits = body.tech_awake_time_units;
    let deviceCon2 = parseFloat(body.tech_device_con2);
    const deviceCon2Units = body.tech_device_con2_units;
    let sleepTime = parseFloat(body.tech_sleep_time);
    const sleepTimeUnits = body.tech_sleep_time_units;

    const param = {};
    if (
      !isNaN(batteryCapacity) &&
      !isNaN(dischargeSafety) &&
      !isNaN(deviceCon1) &&
      !isNaN(awakeTime) &&
      !isNaN(deviceCon2) &&
      !isNaN(sleepTime)
    ) {
      // Battery capacity units

      if (batteryUnits) {
        if (batteryUnits == "Ah") {
          batteryCapacity = batteryCapacity * 1000;
        } else if (batteryUnits == "mAh") {
          batteryCapacity = batteryCapacity;
        }
      }

      if (deviceCon1Units) {
        if (deviceCon1Units == "A") {
          deviceCon1 = deviceCon1 * 1000;
        } else if (deviceCon1Units == "µA") {
          deviceCon1 = deviceCon1 * 1000;
        }
      }

      if (awakeTimeUnits) {
        if (awakeTimeUnits == "sec") {
          awakeTime = awakeTime;
        } else if (awakeTimeUnits == "min") {
          awakeTime = awakeTime * 60;
        } else if (awakeTimeUnits == "hrs") {
          awakeTime = awakeTime * 3600;
        } else if (awakeTimeUnits == "days") {
          awakeTime = awakeTime * 86400;
        } else if (awakeTimeUnits == "wks") {
          awakeTime = awakeTime * 604800;
        } else if (awakeTimeUnits == "mos") {
          awakeTime = awakeTime * 2629800;
        } else if (awakeTimeUnits == "yrs") {
          awakeTime = awakeTime * 31557600;
        }
      }
      if (deviceCon2Units) {
        if (deviceCon1Units == "A") {
          deviceCon1 = deviceCon1 * 0.001;
        } else if (deviceCon1Units == "µA") {
          deviceCon1 = deviceCon1 * 1000;
        } else if (deviceCon1Units == "mA") {
          deviceCon1 = deviceCon1;
        }
      }

      if (sleepTimeUnits) {
        if (awakeTimeUnits == "sec") {
          sleepTime = sleepTime;
        } else if (sleepTime == "min") {
          sleepTime = sleepTime * 60;
        } else if (sleepTime == "hrs") {
          sleepTime = sleepTime * 3600;
        } else if (sleepTime == "days") {
          sleepTime = sleepTime * 86400;
        } else if (sleepTime == "wks") {
          sleepTime = sleepTime * 604800;
        } else if (sleepTime == "mos") {
          sleepTime = sleepTime * 2629800;
        } else if (sleepTime == "yrs") {
          sleepTime = sleepTime * 31557600;
        }
      }

      let per = dischargeSafety / 100;
      let x = 1 - per;
      let y = batteryCapacity / deviceCon1;
      let Battery_life = y * x;
      let Average_consumption =
        (deviceCon1 * awakeTime + deviceCon2 * sleepTime) /
        (awakeTime + sleepTime);
      param["tech_Battery_life"] = Battery_life;
      param["tech_Average_consumption"] = Average_consumption;
      param["input_battery_capacity"] = batteryCapacity;
      param["input_discharge_safety"] = dischargeSafety;
      param["input_device_con1"] = deviceCon1;
      param["input_awake_time"] = body.tech_awake_time;
      param["input_device_con2"] = deviceCon2;
      param["input_sleep_time"] = sleepTime;
    } else {
      param.error = "Please ! Check Input";
    }

    return param;
  }
  /**
   * getCalculationSluggingPercentageCalculator: Service Method
   * POST: /api/calculators-lol/slugging-percentage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationSluggingPercentageCalculator(body) {
    const singles = parseFloat(body.tech_singles);
    const doubles = parseFloat(body.tech_doubles);
    const triples = parseFloat(body.tech_triples);
    const home = parseFloat(body.tech_home);
    const bats = parseFloat(body.tech_bats);

    const param = {};

    if (
      !isNaN(singles) &&
      !isNaN(doubles) &&
      !isNaN(triples) &&
      !isNaN(home) &&
      !isNaN(bats)
    ) {
      if (bats === 0) {
        param.error = "At Bats value cannot be equal to zero";
        return param;
      }

      const answer = (singles + 2 * doubles + 3 * triples + 4 * home) / bats;

      param.tech_answer = answer;
      param.tech_singles = singles;
      param.tech_doubles = doubles;
      param.tech_triples = triples;
      param.tech_home = home;
      param.tech_bats = bats;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationMagicNumberCalculator: Service Method
   * POST: /api/calculators-lol/magic-number-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMagicNumberCalculator(body) {
    const win = parseFloat(body.tech_win);
    const loss = parseFloat(body.tech_loss);

    const param = {};

    if (!isNaN(win) && !isNaN(loss)) {
      const answer = 162 - win - loss + 1;

      param.tech_answer = answer;
      param.input_win = win;
      param.input_loss = loss;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationFabricCalculator: Service Method
   * POST: /api/calculators-lol/fabric-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationFabricCalculator(body) {
    let fabric = parseFloat(body.tech_fabric);
    const fabric_unit = body.tech_fabric_unit;
    let width = parseFloat(body.tech_width);
    const width_unit = body.tech_width_unit;
    let length = parseFloat(body.tech_length);
    const length_unit = body.tech_length_unit;
    const piece = parseFloat(body.tech_piece);
    const unit = body.tech_unit;

    const param = {};

    function convertUnit(value, unit) {
      switch (unit) {
        case "mm":
          return value * 1000;
        case "cm":
          return value * 100;
        case "m":
          return value;
        case "km":
          return value / 1000;
        case "in":
          return value * 39.37;
        case "ft":
          return value * 3.281;
        case "yd":
          return value * 1.094;
        default:
          return value;
      }
    }

    if (!isNaN(fabric) && !isNaN(width) && !isNaN(length) && !isNaN(piece)) {
      width = convertUnit(width, width_unit);
      fabric = convertUnit(fabric, fabric_unit);

      if (fabric === 0) {
        param.error = "fabric width cannot be equal to zero";
        return param;
      }

      if (width === 0) {
        param.error = "pieces to cut width cannot be equal to zero";
        return param;
      }

      const sub_across = fabric / width;
      const across = Math.round(sub_across);
      if (across === 0) {
        param.error = "across value cannot be equal to zero";
        return param;
      }

      const sub_down = piece / across;
      const down = Math.round(sub_down);

      length = convertUnit(length, length_unit);
      const sub_material = length * down;
      const material = Math.round(sub_material);
      const unit_material = convertUnit(material, unit);
      const answer = Math.round(unit_material);

      param.tech_answer = answer;
      param.tech_down = down;
      param.tech_across = across;
      param.tech_unit = unit;
      param.tech_piece = piece;
      param.tech_fabric = fabric;
      param.tech_width = width;
      param.tech_length = length;
      param.input_fabric = parseFloat(body.tech_fabric);
      param.input_width = parseFloat(body.tech_width);
      param.input_length = parseFloat(body.tech_length);
      param.input_piece = parseFloat(body.tech_piece);
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationSemestergradeCalculator: Service Method
   * POST: /api/calculators-lol/semester-grade-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationSemestergradeCalculator(body) {
    const f_grade = parseFloat(body.tech_f_grade);
    const f_weight = parseFloat(body.tech_f_weight);
    const s_grade = parseFloat(body.tech_s_grade);
    const s_weight = parseFloat(body.tech_s_weight);
    const l_grade = parseFloat(body.tech_l_grade);
    const l_weight = parseFloat(body.tech_l_weight);

    const param = {};

    if (
      !isNaN(f_grade) &&
      !isNaN(f_weight) &&
      !isNaN(s_grade) &&
      !isNaN(s_weight) &&
      !isNaN(l_grade) &&
      !isNaN(l_weight)
    ) {
      const semesterGrade =
        f_grade * f_weight + s_grade * s_weight + l_grade * l_weight;
      param.tech_semesterGrade = semesterGrade / 100;
    } else {
      param.error = "Please check input.";
    }

    return param;
  }

  /**
   * getCalculationScreenSizeCalculator: Service Method
   * POST: /api/calculators-lol/screen-size-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationScreenSizeCalculator(body) {
    let screen = body.tech_screen;
    let ratio_1 = body.tech_ratio_1;
    let ratio_2 = body.tech_ratio_2;
    let type = body.tech_type;
    let curvature = body.tech_curvature;
    let radius = body.tech_radius;
    let radius_units = body.tech_radius_units;
    let select_one = body.tech_select_one;
    let select_two = body.tech_select_two;
    let curved_dimensions = body.tech_curved_dimensions;
    let curved_dimensions_units = body.tech_curved_dimensions_units;
    let flat_dimensions = body.tech_flat_dimensions;
    let flat_dimensions_units = body.tech_flat_dimensions_units;
    const param = {};

    function conversionScreen(unit, value) {
      if (!unit) return value;
      switch (unit) {
        case "cm":
          return value / 2.54;
        case "m":
          return value / 0.0254;
        case "in":
          return value;
        case "ft":
          return value * 12;
        case "yd":
          return value * 36;
        case "mm":
          return value / 25.4;
        default:
          return value;
      }
    }

    const isNumeric = (n) => !isNaN(parseFloat(n)) && isFinite(n);

    if (type === "flat") {
      if (
        isNumeric(ratio_1) &&
        isNumeric(ratio_2) &&
        isNumeric(flat_dimensions)
      ) {
        const convertedFlatDim = conversionScreen(
          flat_dimensions_units,
          flat_dimensions
        );
        const r1 = parseFloat(ratio_1);
        const r2 = parseFloat(ratio_2);

        if (select_one === "Diagonal") {
          const width = (r1 / Math.sqrt(r1 ** 2 + r2 ** 2)) * convertedFlatDim;
          const height = (r2 / Math.sqrt(r1 ** 2 + r2 ** 2)) * convertedFlatDim;
          param.tech_screenArea = width * height;
          param.tech_width = width;
          param.tech_height = height;
        } else if (select_one === "Width") {
          const height = (r2 / r1) * convertedFlatDim;
          const diagonal = Math.sqrt(convertedFlatDim ** 2 + height ** 2);
          param.tech_screenArea = convertedFlatDim * height;
          param.tech_diagonal = diagonal;
          param.tech_height = height;
        } else if (select_one === "Height") {
          const width = (r1 / r2) * convertedFlatDim;
          const diagonal = Math.sqrt(width ** 2 + convertedFlatDim ** 2);
          param.tech_screenArea = width * convertedFlatDim;
          param.tech_width = width;
          param.tech_diagonal = diagonal;
        }
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }
    } else {
      if (
        isNumeric(ratio_1) &&
        isNumeric(ratio_2) &&
        isNumeric(curved_dimensions)
      ) {
        let radius1 = conversionScreen(radius_units, radius);
        const convertedCurvedDim = conversionScreen(
          curved_dimensions_units,
          curved_dimensions
        );
        const r1 = parseFloat(ratio_1);
        const r2 = parseFloat(ratio_2);

        if (select_two === "Diagonal") {
          const height =
            (r2 / Math.sqrt(r1 ** 2 + r2 ** 2)) * convertedCurvedDim;
          const base_width = Math.sqrt(
            convertedCurvedDim ** 2 - Math.round(height, 1) ** 2
          );
          const screen_length = (r1 / r2) * height;
          const base_depth =
            radius1 * (1 - Math.cos(screen_length / (2 * radius1)));
          param.tech_screenArea = base_width * height;
          param.tech_base_width = base_width;
          param.tech_height = height;
          param.tech_base_depth = base_depth;
          param.tech_screen_length = screen_length;
        } else if (select_two === "Width") {
          const height = convertedCurvedDim / (r1 / r2);
          const diagonal = Math.sqrt(convertedCurvedDim ** 2 + height ** 2);
          const screen_length = (r1 / r2) * height;
          const base_depth =
            radius1 * (1 - Math.cos(screen_length / (2 * radius1)));
          param.tech_screenArea = convertedCurvedDim * height;
          param.tech_height = height;
          param.tech_diagonal = diagonal;
          param.tech_base_depth = base_depth;
          param.tech_screen_length = screen_length;
        } else if (select_two === "Height") {
          const base_width = convertedCurvedDim * (r1 / r2);
          const diagonal = Math.sqrt(base_width ** 2 + convertedCurvedDim ** 2);
          const screen_length = (r1 / r2) * convertedCurvedDim;
          const base_depth =
            radius1 * (1 - Math.cos(screen_length / (2 * radius1)));
          param.tech_base_width = base_width;
          param.tech_diagonal = diagonal;
          param.tech_screenArea = base_width * convertedCurvedDim;
          param.tech_base_depth = base_depth;
          param.tech_screen_length = screen_length;
        }
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }
    }
    return param;
  }

  /**
   * getCalculationRecessedLightingCalculator: Service Method
   * POST: /api/calculators-lol/recessed-lighting-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationRecessedLightingCalculator(body) {
    let a = body.tech_a;
    let b = body.tech_b;
    let columns_fixture = body.tech_columns_fixture;
    let rows_fixture = body.tech_rows_fixture;

    const param = {};

    const isNumeric = (n) => !isNaN(parseFloat(n)) && isFinite(n);

    if (isNumeric(a) && isNumeric(b)) {
      a = parseFloat(a);
      b = parseFloat(b);
      columns_fixture = parseFloat(columns_fixture);
      rows_fixture = parseFloat(rows_fixture);

      const a_not = a / (2 * rows_fixture);
      const a_i = a / rows_fixture;
      const b_not = b / (2 * columns_fixture);
      const b_i = b / columns_fixture;
      const y_not = a / rows_fixture;
      const y_i = a / rows_fixture;
      const x_not = b / 2;
      const x_i = b / 2;

      param.tech_a_not = a_not;
      param.tech_a_i = a_i;
      param.tech_b_not = b_not;
      param.tech_b_i = b_i;
      param.tech_y_not = y_not;
      param.tech_y_i = y_i;
      param.tech_x_not = x_not;
      param.tech_x_i = x_i;
    } else {
      param.error = "Please! Check Your Input";
      return param;
    }

    return param;
  }

  /**
   * getCalculationCMFCalculator: Service Method
   * POST: /api/calculators-lol/cfm-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCMFCalculator(body) {
    let length = body.tech_length;
    let length_units = body.tech_length_units;
    let width = body.tech_width;
    let width_units = body.tech_width_units;
    let celling = body.tech_celling;
    let celling_units = body.tech_celling_units;
    let airflow = body.tech_airflow;

    const param = {};

    const isNumeric = (n) => !isNaN(parseFloat(n)) && isFinite(n);

    function convertToMeters(value, unit) {
      if (unit === "m") return value;
      if (unit === "cm") return value * 0.01;
      if (unit === "in") return value * 0.0254;
      if (unit === "ft") return value * 0.3048;
      if (unit === "yd") return value * 0.9144;
      return null;
    }

    if (
      isNumeric(length) &&
      isNumeric(width) &&
      isNumeric(celling) &&
      isNumeric(airflow)
    ) {
      length = convertToMeters(parseFloat(length), length_units);
      width = convertToMeters(parseFloat(width), width_units);
      celling = convertToMeters(parseFloat(celling), celling_units);
      airflow = parseFloat(airflow);

      const floorArea = length * width;
      const volume = floorArea * celling;

      const airflow_rate = volume * airflow;
      const requiredAirFlow = (floorArea * celling * airflow) / 1.7;

      param.tech_floorArea = floorArea;
      param.tech_volume = volume;
      param.tech_airflow_rate = airflow_rate;
      param.tech_requiredAirFlow = requiredAirFlow;
    } else {
      param.error = "Please! Check Your Input";
      return param;
    }

    return param;
  }

  /**
   * getCalculationBoxFillCalculator: Service Method
   * POST: /api/calculators-lol/box-fill-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBoxFillCalculator(body) {
    let conducting_wire_size = body.tech_conducting_wire_size;
    let clamps = body.tech_clamps;
    let conducting_wire = body.tech_conducting_wire;
    let fittings = body.tech_fittings;
    let devices = body.tech_devices;
    let grounding_conductor = body.tech_grounding_conductor;
    let largest_wire_size = body.tech_largest_wire_size;

    const param = {};
    let clamp_vol_allownce,
      conductor_fill_volume,
      clamp_fill_vol,
      fitt_vol_allownce,
      device_vol_allownce,
      fitt_fill_vol,
      device_fill_vol,
      grounding_fill_vol_allownce,
      grounding_fill_vol,
      larg_cond_wire,
      total_box_vol,
      total_volume_allowance_needed;
    const isNumeric = (n) => !isNaN(parseFloat(n)) && isFinite(n);

    if (
      isNumeric(conducting_wire) &&
      isNumeric(devices) &&
      isNumeric(grounding_conductor)
    ) {
      conducting_wire = parseFloat(conducting_wire);
      devices = parseFloat(devices);
      grounding_conductor = parseFloat(grounding_conductor);
      conducting_wire_size = parseFloat(conducting_wire_size);
      largest_wire_size = parseFloat(largest_wire_size);

      conductor_fill_volume = conducting_wire * conducting_wire_size;
      if (clamps == "yes") {
        clamp_vol_allownce = 1;
        clamp_fill_vol = conducting_wire_size;
      } else {
        clamp_vol_allownce = 0;
        clamp_fill_vol = 0;
      }
      if (fittings == "yes") {
        fitt_vol_allownce = 1;
        fitt_fill_vol = conducting_wire_size;
      } else {
        fitt_vol_allownce = 0;
        fitt_fill_vol = 0;
      }

      device_vol_allownce = devices * 2;
      device_fill_vol = device_vol_allownce * conducting_wire_size;
      grounding_fill_vol_allownce = grounding_conductor / 4;
      grounding_fill_vol = largest_wire_size * grounding_fill_vol_allownce;
      larg_cond_wire =
        grounding_conductor +
        device_vol_allownce +
        clamp_vol_allownce +
        fitt_vol_allownce;
      total_box_vol =
        conductor_fill_volume +
        clamp_fill_vol +
        fitt_fill_vol +
        device_fill_vol +
        grounding_fill_vol;
      total_volume_allowance_needed =
        conducting_wire +
        clamp_vol_allownce +
        fitt_vol_allownce +
        device_vol_allownce +
        grounding_fill_vol_allownce;

      param.tech_conducting_wire = conducting_wire;
      param.tech_conducting_wire_size = conducting_wire_size;
      param.tech_conductor_fill_volume = conductor_fill_volume;
      param.tech_clamp_vol_allownce = clamp_vol_allownce;
      param.tech_clamp_fill_vol = clamp_fill_vol;
      param.tech_fitt_vol_allownce = fitt_vol_allownce;
      param.tech_fitt_fill_vol = fitt_fill_vol;
      param.tech_device_vol_allownce = device_vol_allownce;
      param.tech_device_fill_vol = device_fill_vol;
      param.tech_grounding_fill_vol_allownce = grounding_fill_vol_allownce;
      param.tech_largest_wire_size = largest_wire_size;
      param.tech_grounding_fill_vol = grounding_fill_vol;
      param.tech_larg_cond_wire = larg_cond_wire;
      param.tech_total_volume_allowance_needed = total_volume_allowance_needed;
      param.tech_total_box_vol = total_box_vol;
    } else {
      param.error = "Please! Check Your Input";
      return param;
    }
    return param;
  }

  /**
   * getCalculationTonnageCalculator: Service Method
   * POST: /api/calculators-lol/tonnage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationTonnageCalculator(body) {
    let unit_weight = parseFloat(body.tech_unit_weight);
    let length = parseFloat(body.tech_length);
    let length_units = body.tech_length_units;
    let width = parseFloat(body.tech_width);
    let width_units = body.tech_width_units;
    let depth = parseFloat(body.tech_depth);
    let depth_units = body.tech_depth_units;
    let price_per = parseFloat(body.tech_price_per);
    let price_per_units = body.tech_price_per_units;
    let wastage = parseFloat(body.tech_wastage);

    const param = {};
    let tonnage, weight_needed, total_cost;
    const isNumeric = (n) => !isNaN(parseFloat(n)) && isFinite(n);

    if (price_per_units !== undefined) {
      if (price_per_units === "kg") {
        price_per = price_per;
      } else if (price_per_units === "t") {
        price_per = price_per * 1000;
      } else if (price_per_units === "lb") {
        price_per = price_per * 0.453592;
      } else if (price_per_units === "st") {
        price_per = price_per * 6.35029;
      }
    }

    function convertToM(value, unit) {
      if (unit === "m") {
        return value;
      } else if (unit === "cm") {
        return value * 100;
      } else if (unit === "in") {
        return value * 39.37;
      } else if (unit === "ft") {
        return value * 3.281;
      } else if (unit === "yd") {
        return value * 1.094;
      } else {
        return null;
      }
    }

    if (
      isNumeric(length) &&
      isNumeric(width) &&
      isNumeric(depth) &&
      isNumeric(price_per) &&
      isNumeric(wastage)
    ) {
      width = convertToM(width, width_units);
      length = convertToM(length, length_units);
      depth = convertToM(depth, depth_units);
      // Calculate area
      console.log(length, width);
      const area = length * width;
      console.log(area);
      // Calculate volume
      const volume = area * depth;

      // Calculate tonnage
      tonnage = Math.round(volume * unit_weight * 0.001, 2);

      // Calculate weight needed considering wastage
      weight_needed = Math.round(Math.round(tonnage) / (1 - wastage / 100), 2);

      // Calculate total cost
      total_cost = Math.round(weight_needed, 5) * price_per;

      param.tech_area = area;
      param.tech_volume = volume;
      param.tech_tonnage = tonnage;
      param.tech_weight_needed = weight_needed;
      param.tech_total_cost = total_cost;
    } else {
      param.error = "Please! Check Your Input";
      return param;
    }

    return param;
  }

  /**
   * getCalculationDunkCalculator: Service Method
   * POST: /api/calculators-lol/dunk-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDunkCalculator(body) {
    let height = parseFloat(body.tech_height);
    let height_unit = body.tech_height_unit;
    let mass = parseFloat(body.tech_mass);
    let mass_unit = body.tech_mass_unit;
    let acceleration = parseFloat(body.tech_acceleration);
    let acceleration_unit = body.tech_acceleration_unit;
    let palm_size = parseFloat(body.tech_palm_size);
    let palm_size_unit = body.tech_palm_size_unit;
    let standing = parseFloat(body.tech_standing);
    let standing_unit = body.tech_standing_unit;

    const param = {};

    const isNumeric = (n) => !isNaN(parseFloat(n)) && isFinite(n);

    function unitConvert(unit, value) {
      switch (unit) {
        case "m":
          return value * 100;
        case "in":
          return value * 2.54;
        case "ft":
          return value * 30.48;
        case "yd":
          return value * 91.44;
        case "mm":
          return value * 0.1;
        case "km":
          return value * 1;
        case "mi":
          return value * 2.54;
        case "nmi":
          return value * 2.54;
        default:
          return value;
      }
    }

    function massUnitConvert(unit, value) {
      switch (unit) {
        case "g":
          return value * 0.001;
        case "t":
          return value * 1000;
        case "lb":
          return value * 0.4536;
        case "st":
          return value * 6.35;
        case "US ton":
          return value * 907.2;
        case "long ton":
          return value * 1016;
        case "Earths":
          return value * 5.9722e24;
        default:
          return value;
      }
    }

    function gravUnitConvert(unit, value) {
      switch (unit) {
        case "g":
          return value * 9.807;
        case "ft/s²":
          return value * 0.3048;
        default:
          return value;
      }
    }

    if (
      isNumeric(height) &&
      isNumeric(mass) &&
      isNumeric(acceleration) &&
      isNumeric(palm_size) &&
      isNumeric(standing)
    ) {
      height = unitConvert(height_unit, height);
      mass = massUnitConvert(mass_unit, mass);
      acceleration = gravUnitConvert(acceleration_unit, acceleration);
      palm_size = unitConvert(palm_size_unit, palm_size);
      standing = unitConvert(standing_unit, standing);

      const minimum_vertical_leap = height - standing + palm_size;
      const hang_time = +(
        Math.sqrt((8 * minimum_vertical_leap) / acceleration) / 10
      ).toFixed(3);
      const jumping_energy = +(
        (mass * acceleration * minimum_vertical_leap) /
        100
      ).toFixed(3);
      const initial_jumping_speed = +(
        Math.sqrt(2 * acceleration * minimum_vertical_leap) / 10
      ).toFixed(3);

      param.tech_minimum_vertical_leap = minimum_vertical_leap;
      param.tech_hang_time = hang_time;
      param.tech_jumping_energy = jumping_energy;
      param.tech_initial_jumping_speed = initial_jumping_speed;
    } else {
      param.error = "Please! Check Your Input";
    }

    return param;
  }

  /**
   * getCalculationNetherPortalCalculator: Service Method
   * POST: /api/calculators-lol/nether-portal-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationNetherPortalCalculator(body) {
      const submit = String(body.tech_submit || "").trim();
      const sim_adv = String(body.tech_sim_adv || "").trim();
      const cal = String(body.cal || "").trim();

    const x = parseFloat(body.tech_x);
    const y = parseFloat(body.tech_y);
    const z = parseFloat(body.tech_z);

    const x1 = parseFloat(body.tech_x1);
    const y1 = parseFloat(body.tech_y1);
    const z1 = parseFloat(body.tech_z1);
    const x2 = parseFloat(body.tech_x2);
    const y2 = parseFloat(body.tech_y2);
    const z2 = parseFloat(body.tech_z2);

    const param = {};

    const isNum = (val) => !isNaN(parseFloat(val)) && isFinite(val);

    if (!submit) {
      param.error = "Please! Check Your Input";
      return param;
    }

    if (sim_adv === "simple") {
      if (cal === "1") {
        if (!isNum(x) && !isNum(y) && !isNum(z)) {
          param.error = "Please! Check Your Input";
          return param;
        }

        const ox = isNum(x) ? x : 0;
        const oy = isNum(y) ? y : 0;
        const oz = isNum(z) ? z : 0;

        const nx = Math.floor(ox / 8);
        const ny = oy;
        const nz = Math.floor(oz / 8);

        if (oy > 123 && oy < 256) {
          param.tech_comment =
            "To correctly link your portal, it has to be placed on top of the Nether roof! The portal will, however, still work if it isn't on the roof.";
        }

        param.tech_x = nx;
        param.tech_y = ny;
        param.tech_z = nz;
        param.tech_share = "share";
      } else if (cal === "2") {
        if (!isNum(x) && !isNum(y) && !isNum(z)) {
          param.error = "Please! Check Your Input";
          return param;
        }

        const nx = isNum(x) ? x : 0;
        const ny = isNum(y) ? y : 0;
        const nz = isNum(z) ? z : 0;

        const ox = nx * 8;
        const oy = ny;
        const oz = nz * 8;

        if (ny > 123 && ny < 256) {
          param.tech_comment =
            "To correctly link your portal, it has to be placed on top of the Nether roof! The portal will, however, still work if it isn't on the roof.";
        }

        param.tech_x = ox;
        param.tech_y = oy;
        param.tech_z = oz;
        param.tech_share = "share";
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }
    } else {
      if (
        isNum(x1) &&
        isNum(y1) &&
        isNum(z1) &&
        isNum(x2) &&
        isNum(y2) &&
        isNum(z2)
      ) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const dz = z2 - z1;
        const distance = Math.sqrt(dx ** 2 + dy ** 2 + dz ** 2);
        param.tech_distance = distance;
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }
    }

    return param;
  }

  /**
   * getCalculationCBMCalculator: Service Method
   * POST: /api/calculators-lol/cbm-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCBMCalculator(body) {
    let type = body.tech_type;
    let width = body.tech_width;
    let width_unit = body.tech_width_unit;
    let length = body.tech_length;
    let length_unit = body.tech_length_unit;
    let heigth = body.tech_heigth;
    let heigth_unit = body.tech_heigth_unit;
    let quantity = body.tech_quantity;
    let weight = body.tech_weight;
    let weight_unit = body.tech_weight_unit;

    const convertToCm = (unit, value) => {
      switch (unit) {
        case "m":
          return value * 100;
        case "mm":
          return value / 10;
        case "cm":
          return value;
        case "km":
          return value * 100000;
        case "in":
          return value * 2.54;
        case "ft":
          return value * 30.48;
        case "yd":
          return value * 91.44;
        case "mi":
          return value * 160934;
        default:
          return 0;
      }
    };

    const convertToMeter = (unit, value) => {
      switch (unit) {
        case "cm":
          return value / 100;
        case "mm":
          return value / 1000;
        case "m":
          return value;
        case "km":
          return value * 1000;
        case "in":
          return value / 39.37;
        case "ft":
          return value / 3.281;
        case "yd":
          return value / 1.094;
        case "mi":
          return value * 1609;
        default:
          return 0;
      }
    };

    const convertToKg = (unit, value) => {
      switch (unit) {
        case "ug":
          return value / 1e9;
        case "mg":
          return value / 1e6;
        case "g":
          return value / 1000;
        case "dag":
          return value / 100;
        case "lb":
          return value / 2.205;
        case "kg":
          return value;
        case "t":
          return value * 1000;
        case "gr":
          return value / 15432;
        case "dr":
          return value / 295;
        case "oz":
          return value / 35.274;
        case "stone":
          return value * 6.35;
        case "us-ton":
          return value * 907.2;
        case "long-ton":
          return value * 1016;
        case "earths":
          return value * 5.972e24;
        case "me":
          return value * 1.098e30;
        case "u":
          return value * 6.022e26;
        case "oz-t":
          return value / 32.151;
        default:
          return 0;
      }
    };

    const formatNumber = (value) => {
      return value.toLocaleString("en-US", {
        minimumFractionDigits: 2,
        maximumFractionDigits: 2,
      });
    };

    const param = {};

    if (!isNaN(width) && !isNaN(length) && !isNaN(heigth) && !isNaN(quantity)) {
      const width_m = convertToMeter(width_unit, width);
      const length_m = convertToMeter(length_unit, length);
      const heigth_m = convertToMeter(heigth_unit, heigth);

      if (type === "basic") {
        const cbm = width_m * length_m * heigth_m * quantity;
        param.tech_cbm = formatNumber(cbm);
        return param;
      } else if (type === "advance") {
        if (!isNaN(weight)) {
          const width_cm = convertToCm(width_unit, width);
          const length_cm = convertToCm(length_unit, length);
          const heigth_cm = convertToCm(heigth_unit, heigth);
          const weight_kg = convertToKg(weight_unit, weight);

          const cbm = width_m * length_m * heigth_m;
          const total_cbm = cbm * quantity;
          const total_weight = weight_kg * quantity;
          const volumetric_weight = (width_cm * length_cm * heigth_cm) / 5000;
          const total_volumetric_weight = volumetric_weight * quantity;
          const size_20 = Math.floor(33.2 / cbm);
          const size_40 = Math.floor(67.67 / cbm);
          const size_40_hq = Math.floor(76.3 / cbm);
          const size_45_hq = Math.floor(88.4 / cbm);

          param.tech_cbm = formatNumber(cbm);
          param.tech_total_cbm = formatNumber(total_cbm);
          param.tech_total_weight = formatNumber(total_weight);
          param.tech_total_volumetric_weight = formatNumber(
            total_volumetric_weight
          );
          param.tech_size_20 = size_20;
          param.tech_size_40 = size_40;
          param.tech_size_40_hq = size_40_hq;
          param.tech_size_45_hq = size_45_hq;
          return param;
        } else {
          return { status: "error", message: "Please! Check Your Input" };
        }
      }
    } else {
      return { status: "error", message: "Please! Check Your Input" };
    }
  }

  /**
   * getCalculationBikeSizeCalculator: Service Method
   * POST: /api/calculators-lol/bike-size-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBikeSizeCalculator(body) {
    let bike_for = body.tech_bike_for;
    let bike_type = body.tech_bike_type;
    let kids_age = body.tech_kids_age;
    let hight = body.tech_hight;
    let hight_unit = body.tech_hight_unit;
    let inseam_length = body.tech_inseam_length;
    let inseam_length_unit = body.tech_inseam_length_unit;

    function convertToCm(unit, value) {
      if (unit === "cm") return value;
      if (unit === "in") return value * 2.54;
      if (unit === "ft") return value * 30.48;
      if (unit === "mm") return value / 10;
      return null;
    }

    const param = {};

    if (bike_for) {
      if (bike_for === "kids") {
        if (kids_age) {
          let wheel_size, hight_result;

          if (kids_age === "2-3") {
            wheel_size = 12;
            hight_result = "86-102";
          } else if (kids_age === "2-4") {
            wheel_size = 14;
            hight_result = "94-109";
          } else if (kids_age === "4-6") {
            wheel_size = 16;
            hight_result = "109-122";
          } else if (kids_age === "5-8") {
            wheel_size = 20;
            hight_result = "114-130";
          } else if (kids_age === "8-11") {
            wheel_size = 24;
            hight_result = "122-135";
          } else if (kids_age === "11+") {
            wheel_size = 26;
            hight_result = "135-145";
          }

          param.tech_wheel_mm = (wheel_size * 25.4).toFixed(2);
          param.tech_wheel_cm = (wheel_size * 2.54).toFixed(2);
          param.tech_wheel_in = wheel_size;
          param.tech_wheel_ft = (wheel_size / 12).toFixed(2);
          param.tech_hight = hight_result;
          param.tech_kids_age = kids_age;
          return param;
        } else {
          return { error: "Please! Check Your Input" };
        }
      } else {
        if (bike_type && !isNaN(inseam_length) && !isNaN(hight)) {
          let inseam_cm = convertToCm(inseam_length_unit, inseam_length);
          let hight_cm = convertToCm(hight_unit, hight);

          let frame_size;
          if (["trekking", "city", "hybrid"].includes(bike_type)) {
            frame_size = inseam_cm * 0.64;
          } else if (bike_type === "road") {
            frame_size = inseam_cm * 0.67;
          } else if (bike_type === "mountain") {
            frame_size = inseam_cm * 0.67 - 11;
          }

          let crank_size_mm = inseam_cm * 1.25 + 65;

          param.tech_frame_mm = (frame_size * 10).toFixed(2);
          param.tech_frame_cm = frame_size.toFixed(2);
          param.tech_frame_in = (frame_size / 2.54).toFixed(2);
          param.tech_frame_ft = (frame_size / 30.48).toFixed(2);

          param.tech_crank_mm = crank_size_mm.toFixed(2);
          param.tech_crank_cm = (crank_size_mm / 10).toFixed(2);
          param.tech_crank_in = (crank_size_mm / 25.4).toFixed(2);
          param.tech_crank_ft = (crank_size_mm / 304.8).toFixed(2);

          param.tech_crank_dia_mm = (crank_size_mm * 2).toFixed(2);
          param.tech_crank_dia_cm = ((crank_size_mm / 10) * 2).toFixed(2);
          param.tech_crank_dia_in = ((crank_size_mm / 25.4) * 2).toFixed(2);
          param.tech_crank_dia_ft = ((crank_size_mm / 304.8) * 2).toFixed(2);

          param.tech_hight_mm = (hight_cm * 10).toFixed(2);
          param.tech_hight_cm = hight_cm.toFixed(2);
          param.tech_hight_in = (hight_cm / 2.54).toFixed(2);
          param.tech_hight_ft = (hight_cm / 30.48).toFixed(2);

          param.tech_inseam_mm = (inseam_cm * 10).toFixed(2);
          param.tech_inseam_cm = inseam_cm.toFixed(2);
          param.tech_inseam_in = (inseam_cm / 2.54).toFixed(2);
          param.tech_inseam_ft = (inseam_cm / 30.48).toFixed(2);
          return param;
        } else {
          return { error: "Please! Check Your Input" };
        }
      }
    } else {
      return { error: "Please! Check Your Input" };
    }
  }

  /**
   * getCalculationAcBtuCalculator: Service Method
   * POST: /api/calculators-lol/ac-btu-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationAcBtuCalculator(body) {
    let calculate = body.tech_calculate;
    let height = body.tech_height;
    let height_unit = body.tech_height_unit;
    let width = body.tech_width;
    let width_unit = body.tech_width_unit;
    let length = body.tech_length;
    let length_unit = body.ltech_ength_unit;
    let temperature = body.tech_temperature;
    let temperature_unit = body.tech_temperature_unit;
    let peoples = body.tech_peoples;
    let type = body.tech_type;
    let insulation_condition = body.tech_insulation_condition;
    let sun_exposure = body.tech_sun_exposure;
    let climate = body.tech_climate;

    function convertToFt(unit, value) {
      return unit === "m" ? value * 3.281 : value;
    }

    function formatNumber(num, decimals = 2) {
      return Number(num).toLocaleString("en-US", {
        minimumFractionDigits: decimals,
        maximumFractionDigits: decimals,
      });
    }

    if (
      !isNaN(height) &&
      !isNaN(width) &&
      !isNaN(length) &&
      insulation_condition
    ) {
      let height_ft = convertToFt(height_unit, height);
      let width_ft = convertToFt(width_unit, width);
      let length_ft = convertToFt(length_unit, length);
      let area = width_ft * length_ft;

      let btu = 0;
      let total_btu = 0;

      if (calculate === "ac") {
        if (area <= 150) btu = 5000;
        else if (area <= 250) btu = 6000;
        else if (area <= 300) btu = 7000;
        else if (area <= 350) btu = 8000;
        else if (area <= 400) btu = 9000;
        else if (area <= 450) btu = 10000;
        else if (area <= 550) btu = 12000;
        else if (area <= 700) btu = 14000;
        else if (area <= 1000) btu = 18000;
        else if (area <= 1200) btu = 21000;
        else if (area <= 1500) btu = 24000;
        else if (area <= 2000) btu = 30000;
        else if (area <= 2500) btu = 34000;
        else btu = area * 20;

        total_btu = btu;

        if (height_ft > 8) {
          total_btu += (height_ft - 8) * 1000;
        }

        if (type && sun_exposure && climate && !isNaN(peoples)) {
          if (peoples > 2) {
            total_btu += (peoples - 2) * 600;
          }

          if (type === "living-room") total_btu += 1000;
          else if (type === "kitchen") total_btu += 4000;
          else if (type === "above-floor") total_btu += btu * 0.1;

          if (insulation_condition === "good") total_btu -= btu * 0.2;
          else if (insulation_condition === "poor") total_btu += btu * 0.2;

          if (sun_exposure === "shaded") total_btu -= btu * 0.1;
          else if (sun_exposure === "sunny") total_btu += btu * 0.1;

          if (climate === "cold") total_btu -= btu * 0.15;
          else if (climate === "hot") total_btu += btu * 0.2;
        } else {
          return { status: "error", message: "Please! Check Your Input" };
        }
      } else {
        if (temperature !== undefined && temperature !== null) {
          let temperature_f =
            temperature_unit === "cel"
              ? (temperature * 9) / 5 + 32
              : temperature;
          let final_temp = Math.abs(temperature_f - 30);

          btu = area * height_ft * final_temp * 0.135;
          total_btu = btu;

          if (insulation_condition === "good") total_btu -= btu * 0.4;
          else if (insulation_condition === "poor") total_btu = btu * 2.1;
        } else {
          return { status: "error", message: "Please! Check Your Input" };
        }
      }

      let ton = (total_btu / 12000).toFixed(2);
      let wattsValue = total_btu * 0.29307107017222;
      let kilowatts = (total_btu * 0.00029307107017222).toFixed(2);
      let hp_i = (total_btu * 0.0003930147789222).toFixed(2);
      let hp_e = hp_i;

      return {
        tech_ton: ton,
        tech_watts: formatNumber(wattsValue),
        tech_kilowatts: kilowatts,
        tech_hp_i: hp_i,
        tech_hp_e: hp_e,
        tech_total_btu: Math.round(total_btu),
      };
    } else {
      return { status: "error", message: "Please! Check Your Input" };
    }
  }

  /**
   * getCalculationBlindSizeCalculator: Service Method
   * POST: /api/calculators-lol/blind-size-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationBlindSizeCalculator(body) {
    let type = body.tech_type?.trim();
    let top = parseFloat(body.tech_top);
    let t_units = body.tech_t_units?.trim();
    let width = parseFloat(body.tech_width);
    let w_units = body.tech_w_units?.trim();
    let bottom = parseFloat(body.tech_bottom);
    let b_units = body.tech_b_units?.trim();
    let h_left = parseFloat(body.tech_h_left);
    let l_units = body.tech_l_units?.trim();
    let h_center = parseFloat(body.tech_h_center);
    let c_units = body.tech_c_units?.trim();
    let h_right = parseFloat(body.tech_h_right);
    let r_units = body.tech_r_units?.trim();

    let param = {};

    if (!type) {
      param.error = "Please! Check Your Inputs";
      return param;
    }

    if (
      isNaN(top) ||
      isNaN(width) ||
      isNaN(bottom) ||
      isNaN(h_left) ||
      isNaN(h_center) ||
      isNaN(h_right)
    ) {
      param.error = "Please! Check Your Inputs";
      return param;
    }

    function convertToInches(value, unit) {
      if (unit === "mm") return value / 25.4;
      if (unit === "cm") return value / 2.54;
      if (unit === "ft") return value * 12;
      return value; // already in inches
    }

    top = convertToInches(top, t_units);
    width = convertToInches(width, w_units);
    bottom = convertToInches(bottom, b_units);
    h_left = convertToInches(h_left, l_units);
    h_center = convertToInches(h_center, c_units);
    h_right = convertToInches(h_right, r_units);

    let blind_width,
      blind_lenght,
      s_lenght = "";

    if (type === "inside") {
      blind_width = Math.min(top, width, bottom);
      blind_lenght = Math.min(h_left, h_center, h_right);
      s_lenght = blind_lenght - 0.25;
    } else if (type === "outside") {
      blind_width = Math.min(top, width, bottom) + 3;
      blind_lenght = Math.min(h_left, h_center, h_right) + 1.5;
    }

    param.tech_type = type;
    param.tech_blind_width = +blind_width.toFixed(2);
    param.tech_blind_lenght = +blind_lenght.toFixed(2);
    param.tech_s_lenght = s_lenght !== "" ? +s_lenght.toFixed(2) : "";

    return param;
  }

  /**
   * getCalculationAverageTimeCalculator: Service Method
   * POST: /api/calculators-lol/average-time-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationAverageTimeCalculator(body) {
    let count_val = parseInt(body.tech_count_val);
    let inhour = body.tech_;
    let inminutes = body.tech_inminutes;
    let inseconds = body.tech_inseconds;
    let inmiliseconds = body.tech_inmiliseconds;
    let checkbox1 = body.tech_checkbox1;
    let checkbox2 = body.tech_checkbox2;
    let checkbox3 = body.tech_checkbox3;
    let checkbox4 = body.tech_checkbox4;

    let param = {};
    let hour_list = [];
    let min_list = [];
    let sec_list = [];
    let mili_list = [];
    let hoursminsandsecs = [];

    // Helper functions
    function calc_time(times) {
      let total = 0;
      for (let time of times) {
        let [h, m, s] = time.split(":").map(Number);
        total += h * 3600 + m * 60 + s;
      }
      return total;
    }

    function avg_time(times) {
      let total = calc_time(times);
      let avg = Math.round(total / times.length);
      let h = Math.floor(avg / 3600);
      avg %= 3600;
      let m = Math.floor(avg / 60);
      let s = avg % 60;
      return [
        h.toString().padStart(2, "0"),
        m.toString().padStart(2, "0"),
        s.toString().padStart(2, "0"),
      ];
    }

    for (let i = 0; i < count_val; i++) {
      let hour =
        checkbox1 === false ? 0 : inhour[i] === "" ? 0 : parseFloat(inhour[i]);
      let minute =
        checkbox2 === false
          ? 0
          : inminutes[i] === ""
          ? 0
          : parseFloat(inminutes[i]);
      let second =
        checkbox3 === false
          ? 0
          : inseconds[i] === ""
          ? 0
          : parseFloat(inseconds[i]);
      let milisecond =
        checkbox4 === false
          ? 0
          : inmiliseconds[i] === ""
          ? 0
          : parseFloat(inmiliseconds[i]);

      if (isNaN(hour) || isNaN(minute) || isNaN(second) || isNaN(milisecond)) {
        param.error = "Please! Check Your Input";
        return param;
      }

      hour_list.push(hour);
      min_list.push(minute);
      sec_list.push(second);
      mili_list.push(milisecond);

      let total_seconds = hour * 3600 + minute * 60 + second;
      let hours = Math.floor(total_seconds / 3600);
      let mins = Math.floor((total_seconds % 3600) / 60);
      let secs = Math.floor(total_seconds % 60);
      hoursminsandsecs.push(
        `${hours.toString().padStart(2, "0")}:${mins
          .toString()
          .padStart(2, "0")}:${secs.toString().padStart(2, "0")}`
      );
    }

    let [hr, min, s] = avg_time(hoursminsandsecs);
    let total_milliseconds = mili_list.reduce((sum, val) => sum + val, 0);
    let avg_milliseconds = total_milliseconds / mili_list.length;

    param.tech_hour_list = hour_list;
    param.tech_min_list = min_list;
    param.tech_sec_list = sec_list;
    param.tech_mili_list = mili_list;
    param.tech_time_hour = hr;
    param.tech_time_minutes = min;
    param.tech_time_seconds = s;
    param.tech_time_miliseconds = avg_milliseconds;

    return param;
  }

  /**
   * getCalculationHourlyPayCalculator: Service Method
   * POST: /api/calculators-lol/hourly-pay-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationHourlyPayCalculator(body) {
    let paytype = parseFloat(body.tech_paytype);
    let status = body.tech_status;
    let paidtype = body.tech_paidtype;
    let working = body.tech_working;
    let grosspay = body.tech_grosspay;
    let wage = body.tech_wage;
    let overtimeType = body.tech_overtimeType;
    let h_over = body.tech_h_over;
    let w_over = body.tech_w_over;

    let param = {};
    let weekly_salary = [];
    let salaries = [];
    let overtimes = [];

    function calculateFederalTax(income, filingStatus, standardDeduction) {
      const federalTaxBrackets = {
        single: [
          [0, 11000, 0.1],
          [11000, 44725, 0.12],
          [44725, 95375, 0.22],
          [95375, 182100, 0.24],
          [182100, 231250, 0.32],
          [231250, 578125, 0.35],
          [578125, Infinity, 0.37],
        ],
        married: [
          [0, 22000, 0.1],
          [22000, 89450, 0.12],
          [89450, 190750, 0.22],
          [190750, 364200, 0.24],
          [364200, 462500, 0.32],
          [462500, 693750, 0.35],
          [693750, Infinity, 0.37],
        ],
        head_of_household: [
          [0, 15700, 0.1],
          [15700, 59850, 0.12],
          [59850, 95350, 0.22],
          [95350, 182100, 0.24],
          [182100, 231250, 0.32],
          [231250, 578100, 0.35],
          [578100, Infinity, 0.37],
        ],
      };

      let taxableIncome = income - standardDeduction;
      if (taxableIncome <= 0) return 0;

      let tax = 0;
      for (let [lower, upper, rate] of federalTaxBrackets[filingStatus]) {
        if (taxableIncome > lower) {
          let amountInBracket = Math.min(taxableIncome, upper) - lower;
          tax += amountInBracket * rate;
          if (taxableIncome <= upper) break;
        }
      }
      return tax;
    }

    if (paytype && status) {
      for (let i = 0; i < paidtype.length; i++) {
        if (paidtype[i] === "hourly") {
          if (!isNaN(working[i]) && !isNaN(wage[i])) {
            let weekly = working[i] * wage[i];
            weekly_salary.push(weekly);
            salaries.push(weekly);
          } else {
            param.error = "Please! Check Your Input.";
            return param;
          }
        } else {
          if (grosspay[i] === "per_year") {
            if (!isNaN(wage[i])) {
              let weekly = wage[i] / paytype;
              weekly_salary.push(weekly);
              salaries.push(weekly);
            } else {
              param.error = "Please! Check Your Input.";
              return param;
            }
          } else {
            if (!isNaN(wage[i])) {
              weekly_salary.push(wage[i]);
              salaries.push(wage[i]);
            } else {
              param.error = "Please! Check Your Input.";
              return param;
            }
          }
        }
      }

      for (let j = 0; j < overtimeType.length; j++) {
        if (overtimeType[j] && !isNaN(h_over[j]) && !isNaN(w_over[j])) {
          let overtimeRate = overtimeType[j] === "overtime" ? 1.5 : 2;
          let overtimePay = h_over[j] * w_over[j] * overtimeRate;
          weekly_salary.push(overtimePay);
          overtimes.push(overtimePay);
        }
      }

      let total_weekly_salary = weekly_salary.reduce((a, b) => a + b, 0);
      let annualSalary = total_weekly_salary * paytype;

      let medicareTax =
        (annualSalary * 0.0145) / (annualSalary / total_weekly_salary);
      let socialSecurityTax = Math.min(annualSalary, 160200) * 0.062;
      socialSecurityTax =
        socialSecurityTax / (annualSalary / total_weekly_salary);

      let standardDeduction = 13850;
      let federalTax = calculateFederalTax(
        annualSalary,
        status,
        standardDeduction
      );
      federalTax = federalTax / (annualSalary / total_weekly_salary);
      if (federalTax > 2) federalTax -= 2;

      let total_tax = medicareTax + socialSecurityTax + federalTax;
      let take_home = total_weekly_salary - total_tax;

      param.tech_salaries = salaries;
      param.tech_overtimes = overtimes;
      param.tech_weekly_salary = weekly_salary;
      param.tech_total_weekly_salary = parseFloat(
        total_weekly_salary.toFixed(2)
      );
      param.tech_annualSalary = parseFloat(annualSalary.toFixed(2));
      param.tech_medicareTax = parseFloat(medicareTax.toFixed(2));
      param.tech_socialSecurityTax = Math.round(socialSecurityTax);
      param.tech_federalTax = parseFloat(federalTax.toFixed(2));
      param.tech_total_tax = parseFloat(total_tax.toFixed(2));
      param.tech_take_home = parseFloat(take_home.toFixed(2));

      return param;
    } else {
      param.error = "Please! Check Your Input.";
      return param;
    }
  }

  /** getCalculationLogWeightCalculator
   * POST: /api/calculators-lol/hourly-pay-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationLogWeightCalculator(body) {
    let category = body.tech_category;
    let woodSelector = body.tech_woodSelector;
    let small_end = body.tech_small_end;
    let small_unit = body.tech_small_unit;
    let large_end = body.tech_large_end;
    let large_unit = body.tech_large_unit;
    let length = body.tech_length;
    let length_unit = body.tech_length_unit;
    let stack_w = body.tech_stack_w;
    let stackw_unit = body.tech_stackw_unit;
    let stack_h = body.tech_stack_h;
    let stackh_unit = body.tech_stackh_unit;
    let custom = body.tech_custom;
    let custom_unit = body.tech_custom_unit;
    let submit = body.tech_submit;

    woodSelector = woodSelector?.replace("@", "");

    if (!submit) {
      return { error: "Please check your input" };
    }

    function convertToSm(a, unit) {
      const conversions = {
        cm: 1,
        m: 100,
        in: 2.54,
        ft: 30.48,
        yd: 91.44,
        mm: 0.1,
      };
      return a * (conversions[unit] || 1);
    }

    function calculateToLb(a, unit) {
      const conversions = {
        kg: 2.20462,
        lb: 1,
        st: 14,
        us_tom: 2000,
        l_ton: 2240,
      };
      return a * (conversions[unit] || 1);
    }

    function unitToFt(a, unit) {
      const conversions = {
        "kg/m³": 0.062428,
        "lb/ft": 1,
        "lb/yd": 0.037037037,
        "g/cm³": 62.427961,
        "kg/cm³": 62427.960591578,
        "g/m³": 0.000062427961,
      };
      return a * (conversions[unit] || 1);
    }

    let dm_of_mid, volume, weight, quantity_stack, weight_stack;

    if (category === "log") {
      if (!isNaN(small_end)) {
        let ds = convertToSm(small_end, small_unit);
        let dl = convertToSm(large_end, large_unit);
        let len = convertToSm(length, length_unit);
        let custom_val = unitToFt(custom, custom_unit);
        let stackWidth = convertToSm(stack_w, stackw_unit);
        let stackHeight = convertToSm(stack_h, stackh_unit);

        dm_of_mid = (ds + ds) / 2;
        volume = len * ((Math.PI * dm_of_mid * dm_of_mid) / 4) * 0.000035315;
        volume = parseFloat(volume.toFixed(7));

        weight =
          woodSelector === "custom"
            ? volume * custom_val
            : volume * parseFloat(woodSelector);

        stackWidth /= ds;
        stackHeight /= dl;

        quantity_stack = stackWidth * stackHeight;
        weight_stack = quantity_stack * weight;
      } else {
        return { error: "Please check your input" };
      }
    } else if (category === "board") {
      if (!isNaN(small_end) && !isNaN(large_end)) {
        let ds = convertToSm(small_end, small_unit);
        let dl = convertToSm(large_end, large_unit);
        let len = convertToSm(length, length_unit);
        let custom_val = unitToFt(custom, custom_unit);
        let stackWidth = convertToSm(stack_w, stackw_unit);
        let stackHeight = convertToSm(stack_h, stackh_unit);

        dm_of_mid = (ds + ds) / 2;
        volume = len * ds * dl * 0.000035315;
        volume = parseFloat(volume.toFixed(7));

        weight =
          woodSelector === "custom"
            ? volume * custom_val
            : volume * parseFloat(woodSelector);

        stackWidth /= ds;
        stackHeight /= dl;

        quantity_stack = stackWidth * stackHeight;
        weight_stack = quantity_stack * weight;
      } else {
        return { error: "Please check your input" };
      }
    }

    return {
      tech_dm_of_mid: dm_of_mid,
      tech_volume: volume,
      tech_weight: weight,
      tech_quantity_stack: quantity_stack,
      tech_weight_stack: weight_stack,
    };
  }

  /** getCalculationWaterWeightCalculator
   * POST: /api/calculators-lol/hourly-pay-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationWaterWeightCalculator(body) {
    let from = parseFloat(body.tech_from);
    let vol = parseFloat(body.tech_vol);
    let temp = parseFloat(body.tech_temp);

    if (isFinite(from) && isFinite(vol) && isFinite(temp)) {
      let ans = (1.0e16 / (from / vol)) * temp;
      let lbs = ans * 0.0022;
      let onz = ans * 0.03527396195;
      let kg = ans * 0.001;

      return {
        tech_gram: ans,
        tech_lbs: lbs,
        tech_onz: onz,
        tech_kg: kg,
      };
    } else {
      return {
        error: "Please! Check Your Inputs",
      };
    }
  }

  /** getCalculationTurkeySizeCalculator
   * POST: /api/calculators-lol/turkey-size-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationTurkeySizeCalculator(body) {
    let adults = parseFloat(body.tech_adults);
    let children = parseFloat(body.tech_children);
    let leftovers = body.tech_leftovers;

    function convertToHoursMins(time, format = "%02d hrs %02d mins") {
      if (time < 1) return null;
      let hours = Math.floor(time / 60);
      let minutes = Math.round(time % 60);
      return format
        .replace("%02d", String(hours).padStart(2, "0"))
        .replace("%02d", String(minutes).padStart(2, "0"));
    }

    if (
      isFinite(adults) &&
      adults >= 0 &&
      isFinite(children) &&
      children >= 0
    ) {
      let mul1, mul2, turkey_weight;

      if (leftovers === "no") {
        mul1 = adults;
        mul2 = 0.5 * children;
      } else {
        mul1 = adults * 1.5;
        mul2 = 0.75 * children;
      }

      turkey_weight = mul1 + mul2;
      let inside_fridge = turkey_weight * 5;
      let cold_water = turkey_weight;
      let unstuffed_turkey = convertToHoursMins(turkey_weight * 15);
      let stuffed_turkey = convertToHoursMins(turkey_weight * 17.5);

      return {
        tech_turkey_weight: turkey_weight,
        tech_inside_fridge: inside_fridge,
        tech_cold_water: cold_water,
        tech_unstuffed_turkey: unstuffed_turkey,
        tech_stuffed_turkey: stuffed_turkey,
      };
    } else if (adults < 0) {
      return { error: "Number of adults cannot be lower than 0." };
    } else if (children < 0) {
      return { error: "Number of children cannot be lower than 0." };
    } else {
      return { error: "Please! Check Your Inputs" };
    }
  }

  /** getCalculationAverageAtomicMassCalculator
   * POST: /api/calculators-lol/average-atomic-mass-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAverageAtomicMassCalculator(body) {
    let isotopes_no = body.tech_isotopes_no;
    let per = body.tech_per;
    let per_unit = body.tech_per_unit;
    let mass = body.tech_mass;

    let param = {};

    if (
      typeof isotopes_no === "number" &&
      Array.isArray(per) &&
      Array.isArray(per_unit) &&
      Array.isArray(mass)
    ) {
      let am_array = [];

      for (let i = 0; i < isotopes_no; i++) {
        if (per_unit[i] !== undefined && !isNaN(per[i]) && !isNaN(mass[i])) {
          let abundance = per_unit[i] === "decimal" ? per[i] : per[i] / 100;
          am_array[i] = mass[i] * abundance;
        } else {
          param.error = "Please! Check Your Input.";
          return param;
        }
      }

      let amSum = am_array.reduce((a, b) => a + b, 0);

      param.tech_amSum = amSum;
      param.tech_per = per;
      param.tech_mass = mass;
      return param;
    } else {
      param.error = "Please! Check Your Input.";
      return param;
    }
  }

  /** getCalculationGibbsFreeEnergyCalculator
   * POST: /api/calculators-lol/gibbs-free-energy-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationGibbsFreeEnergyCalculator(body) {
    let entropy = body.tech_entropy;
    let enthalpy = body.tech_enthalpy;
    let temperature = body.tech_temperature;
    let enthalpy_units = body.tech_enthalpy_units;
    let entropy_units = body.tech_entropy_units;
    let t_units = body.tech_t_units;

    let param = {};

    // Convert entropy units to KJ
    if (entropy_units) {
      if (entropy_units == "KJ") {
        entropy = entropy;
      } else if (entropy_units == "cal") {
        entropy = entropy * 0.004184;
      } else if (entropy_units == "kcal") {
        entropy = entropy * 4.184;
      } else if (entropy_units == "J") {
        entropy = entropy * 0.001;
      }
    }

    if (enthalpy_units) {
      if (enthalpy_units == "KJ") {
        enthalpy = enthalpy;
      } else if (enthalpy_units == "cal") {
        enthalpy = enthalpy * 0.004184;
      } else if (enthalpy_units == "kcal") {
        enthalpy = enthalpy * 4.184;
      } else if (enthalpy_units == "J") {
        enthalpy = enthalpy * 0.001;
      }
    }
    if (t_units) {
      if (t_units == "°F") {
        temperature = ((temperature - 32) * 5) / 9 + 273.15;
      } else if (t_units == "°C") {
        temperature = temperature + 273.15;
      }
    }

    // Validate numeric inputs
    if (
      typeof enthalpy === "number" &&
      typeof entropy === "number" &&
      typeof temperature === "number"
    ) {
      let gibbs_free_energy = enthalpy * 1000 - temperature * entropy * 1000; // J
      let gibbs = gibbs_free_energy / 1000; // KJ

      param.tech_gibbs = gibbs;
      param.tech_enthalpy = body.tech_enthalpy;
      param.tech_entropy = body.tech_entropy;
      param.tech_temperature = body.tech_temperature;
      return param;
    } else {
      param.error = "Please! Check Your Input.";
      return param;
    }
  }

  /** getCalculationvaporPressureCalculator
   * POST: /api/calculators-lol/vapor-pressure-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationvaporPressureCalculator(body) {
    let t1 = body.tech_t1;
    let t1_units = body.tech_t1_units;
    let t2 = body.tech_t2;
    let t2_units = body.tech_t2_units;
    let p1 = body.tech_p1;
    let p1_units = body.tech_p1_units; // not used in calculation, assumed already in correct unit
    let deltaHvap = body.tech_deltaHvap;
    let deltaHvap_units = body.tech_deltaHvap_units;
    let p_sol = body.tech_p_sol;
    let p_sol_units = body.tech_p_sol_units;
    let x_sol = body.tech_x_sol;

    let param = {};

    function convertToKelvin(value, unit) {
      switch (unit) {
        case "°C":
          return value + 273.15;
        case "°F":
          return ((value - 32) * 5) / 9 + 273.15;
        case "k":
          return value;
        case "°R":
          return (value * 5) / 9;
        case "°De":
          return 373.15 - (value * 2) / 3;
        case "°N":
          return (value * 100) / 33 + 273.15;
        case "°Ré":
          return (value * 5) / 4 + 273.15;
        case "°Rø":
          return ((value - 7.5) * 40) / 21 + 273.15;
        default:
          return null;
      }
    }

    function convertToPascals(value, unit) {
      switch (unit) {
        case "Pa":
          return value;
        case "Bar":
          return value * 100000;
        case "psi":
          return value * 6894.76;
        case "at":
        case "atm":
          return value * 101325;
        case "Torr":
          return value * 133.322;
        case "hPa":
          return value * 100;
        case "kPa":
          return value * 1000;
        case "MPa":
          return value * 1000000;
        case "GPa":
          return value * 1000000000;
        default:
          return null;
      }
    }

    function convertToJoules(value, unit) {
      switch (unit) {
        case "J":
          return value;
        case "KJ":
          return value * 1000;
        case "MJ":
          return value * 1000000;
        case "Wh":
          return value * 3600;
        case "KWh":
          return value * 3.6e6;
        case "ft-lb":
          return value * 1.35582;
        case "kcal":
          return value * 4184;
        default:
          return null;
      }
    }

    if (
      typeof t1 === "number" &&
      typeof t2 === "number" &&
      typeof p1 === "number" &&
      typeof deltaHvap === "number" &&
      typeof p_sol === "number" &&
      typeof x_sol === "number"
    ) {
      t1 = convertToKelvin(t1, t1_units);
      t2 = convertToKelvin(t2, t2_units);
      deltaHvap = convertToJoules(deltaHvap, deltaHvap_units);
      p_sol = convertToPascals(p_sol, p_sol_units);
      const R = 8.314;

      const rightSide = (-deltaHvap / R) * (1 / t2 - 1 / t1);
      let p2 = p1 * Math.exp(rightSide);
      let xsolvent = p_sol * x_sol;

      param.tech_p2 = p2;
      param.tech_xsolvent = xsolvent;
      return param;
    } else {
      param.error = "Please! Check Your Input.";
      return param;
    }
  }

  /** getCalculationEntropyCalculator
   * POST: /api/calculators-lol/entropy-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationEntropyCalculator(body) {
    let point_unit = body.tech_point_unit?.trim();
    let products = body.tech_products?.toString().trim();
    let products_unit = body.tech_products_unit?.trim();
    let reactants = body.tech_reactants?.toString().trim();
    let reactants_unit = body.tech_reactants_unit?.trim();
    let enthalpy = body.tech_enthalpy?.toString().trim();
    let enthalpy_unit = body.tech_enthalpy_unit?.trim();
    let temperature = body.tech_temperature?.toString().trim();
    let temperature_unit = body.tech_temperature_unit?.trim();
    let entropy = body.tech_entropy?.toString().trim();
    let entropy_unit = body.tech_entropy_unit?.trim();
    let base_unit = body.tech_base_unit?.trim();
    let moles = body.tech_moles?.toString().trim();
    let initial = body.tech_initial?.toString().trim();
    let initial_unit = body.tech_initial_unit?.trim();
    let pre_one_unit = body.tech_pre_one_unit?.trim();
    let final = body.tech_final?.toString().trim();
    let final_unit = body.tech_final_unit?.trim();
    let pre_two_unit = body.tech_pre_two_unit?.trim();

    let param = {};

    // Conversion stubs (define your actual logic here)

    function joules_unit(value, unit) {
      value = parseFloat(value);
      if (isNaN(value)) return null;

      switch (unit.toLowerCase()) {
        case "j/mol*k":
          return value;
        case "kj/mol*k":
          return value * 1000;
        case "mj/mol*k":
          return value * 1000000;
        case "wh/mol*k":
          return value * 3600;
        case "kwh/mol*k":
          return value * 3.6e6;
        case "ft-lb/mol*k":
          return value / 0.7375621493;
        case "cal/mol*k":
          return value * 4.184;
        case "kcal/mol*k":
          return value * 4184;
        case "ev/mol*k":
          return value / 6.242e18;
        default:
          return null; // Unsupported unit
      }
    }
    function joulez_unit(value, unit) {
      value = parseFloat(value);
      if (isNaN(value)) return null;

      switch (unit.toLowerCase()) {
        case "j":
          return value;
        case "kj":
          return value * 1000;
        case "mj":
          return value * 1000000;
        case "wh":
          return value * 3600;
        case "kwh":
          return value * 3.6e6;
        case "ft-lb":
          return value / 0.7375621493;
        case "cal":
          return value * 4.184;
        case "kcal":
          return value * 4184;
        case "ev":
          return value / 6.242e18;
        default:
          return null; // Unsupported unit
      }
    }
    function joulesz_unit(value, unit) {
      value = parseFloat(value);
      if (isNaN(value)) return null;

      switch (unit.toLowerCase()) {
        case "j/k":
          return value;
        case "kj/k":
          return value * 1000;
        case "mj/k":
          return value * 1000000;
        case "wh/k":
          return value * 3600;
        case "kwh/k":
          return value * 3.6e6;
        case "ft-lb/k":
          return value / 0.7375621493;
        case "cal/k":
          return value * 4.184;
        case "kcal/k":
          return value * 4184;
        case "ev/k":
          return value / 6.242e18;
        default:
          return null; // Unsupported unit
      }
    }
    function temp_unit(temperature, temperature_unit) {
      temperature = parseFloat(temperature); // Ensure it's a number

      if (isNaN(temperature)) {
        return null;
      }
      switch (temperature_unit) {
        case "°C":
          return temperature + 273.15; // Celsius to Kelvin
        case "°F":
          return (temperature - 32) * (5 / 9) + 273.15; // Fahrenheit to Kelvin
        case "K":
          return temperature; // Already Kelvin
        default:
          return null; // Invalid unit
      }
    }
    function firstunit(initial, initial_unit) {
      initial = parseFloat(initial);
      if (isNaN(initial)) return null;
      switch (initial_unit) {
        case "mm³":
          return initial;
        case "cm³":
          return initial * 1000;
        case "dm³":
          return initial * 1000000;
        case "m³":
          return initial * 1000000000;
        case "in³":
          return initial / 0.00006102; // 1 in³ = 16,387.064 mm³
        case "ft³":
          return initial * 28316846.592;
        case "ml":
          return initial / 0.001;
        case "cl":
          return initial * 10000;
        case "l":
          return initial * 1000000;
        case "US gal":
          return initial * 3785411.784;
        case "UK gal":
          return initial * 4546090.05;
        case "US fl oz":
          return initial / 0.000033814;
        case "UK fl oz":
          return initial / 0.000035195;
        default:
          return null; // Unsupported unit
      }
    }

    function sec_unit(initial, pre_one_unit) {
      initial = parseFloat(initial);
      if (isNaN(initial)) return null;

      switch (pre_one_unit) {
        case "Pa":
          return initial;
        case "Bar":
          return initial * 100000;
        case "psi":
          return initial * 6895;
        case "at":
          return initial / 0.0000101972;
        case "atm":
          return initial / 0.000009869;
        case "Torr":
          return initial * 133.3;
        case "hPa":
          return initial * 100;
        case "kPa":
          return initial * 1000;
        case "MPa":
          return initial * 1000000;
        case "GPa":
          return initial * 1000000000;
        case "inHg":
          return initial * 3386.39;
        case "mmHg":
          return initial * 133.322;
        default:
          return null; // Unsupported unit
      }
    }

    if (point_unit === "entropy change for a reaction") {
      if (!isNaN(products) && !isNaN(reactants)) {
        products = joules_unit(products, products_unit);
        reactants = joules_unit(reactants, reactants_unit);

        if (products == 0 || reactants == 0) {
          param.error =
            products == 0
              ? "total entropy Of Products value cannot be equal to zero."
              : "total entropy Of reactants value cannot be equal to zero.";
          return param;
        }

        param.entropy_reaction = products - reactants;
      } else {
        param.error = "Please! Check Your Input.";
        return param;
      }
    } else if (point_unit === "gibbs free energy ΔG = ΔH - T*ΔS") {
      if (!isNaN(enthalpy) && !isNaN(temperature) && !isNaN(entropy)) {
        enthalpy = joulez_unit(enthalpy, enthalpy_unit);
        entropy = joulesz_unit(entropy, entropy_unit);
        temperature = temp_unit(temperature, temperature_unit);
        param.tech_gibbs = enthalpy - temperature * entropy;
      } else {
        param.error = "Please! Check Your Input.";
        return param;
      }
    } else if (point_unit === "isothermal entropy change of an ideal gas") {
      if (base_unit === "volume") {
        if (!isNaN(moles) && !isNaN(initial) && !isNaN(final)) {
          if (
            parseFloat(moles) == 0 ||
            parseFloat(initial) == 0 ||
            parseFloat(final) == 0
          ) {
            param.error = "moles, initial, or final cannot be zero.";
            return param;
          }

          initial = firstunit(initial, initial_unit);
          final = firstunit(final, final_unit);
          param.tech_answer =
            parseFloat(moles) * 8.3145 * Math.log(final / initial);
        } else {
          param.error = "Please! Check Your Input.";
          return param;
        }
      } else if (base_unit === "pressure") {
        if (!isNaN(moles) && !isNaN(initial) && !isNaN(final)) {
          initial = sec_unit(initial, pre_one_unit);
          final = sec_unit(final, pre_two_unit);
          param.tech_answers =
            -parseFloat(moles) * 8.3145 * Math.log(final / initial);
        } else {
          param.error = "Please! Check Your Input.";
          return param;
        }
      } else {
        param.error = "Please! Check Your Input.";
        return param;
      }
    } else {
      param.error = "Please! Check Your Input.";
      return param;
    }
    return param;
  }

  /** getCalculationSolutionDilutionCalculator
   * POST: /api/calculators-lol/solution-dilution-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSolutionDilutionCalculator(body) {
    let concentration = parseFloat(body.tech_concentration);
    let concentration_unit = body.tech_concentration_unit?.trim();
    let volume = parseFloat(body.tech_volume);
    let volume_unit = body.tech_volume_unit?.trim();
    let final = parseFloat(body.tech_final);
    let final_unit = body.tech_final_unit?.trim();

    function convertToMolar(value, unit) {
      switch (unit) {
        case "M":
          return value;
        case "mM":
          return value / 1000;
        case "μM":
          return value / 1000000;
        case "nM":
          return value / 1000000000;
        case "pM":
          return value / 1000000000000;
        case "fM":
          return value / 1000000000000000;
        case "aM":
          return value / 1e18;
        case "zM":
          return value / 1e21;
        case "yM":
          return value / 1e24;
        default:
          return null;
      }
    }

    function unitToLiters(value, unit) {
      switch (unit) {
        case "mm³":
          return value / 1e9;
        case "cm³":
          return value / 1000;
        case "dm³":
          return value;
        case "m³":
          return value * 1000;
        case "in³":
          return value / 61023.7;
        case "ft³":
          return value * 28.3168;
        case "yd³":
          return value / 764.555;
        case "ml":
          return value / 1000;
        case "cl":
          return value / 100;
        case "l":
          return value;
        case "US gal":
          return value * 3.78541;
        case "UK gal":
          return value * 4.54609;
        case "US fl oz":
          return value / 33.814;
        case "UK fl oz":
          return value / 35.1951;
        case "cups":
          return value * 0.284131;
        case "tbsp":
          return value / 67.628;
        case "tsp":
          return value / 202.884;
        case "US qt":
          return value * 0.946353;
        case "UK qt":
          return value * 1.13652;
        case "US pt":
          return value / 1.05669;
        case "UK pt":
          return value / 1.13652;
        default:
          return null;
      }
    }

    let param = {};

    if (!isNaN(concentration) && !isNaN(volume) && !isNaN(final)) {
      let convertedConcentration = convertToMolar(
        concentration,
        concentration_unit
      );
      let convertedVolume = unitToLiters(volume, volume_unit);
      let convertedFinal = convertToMolar(final, final_unit);
      if (convertedFinal === 0 || convertedFinal === null) {
        param.error = "Concentration (final) cannot be zero or invalid.";
        return param;
      }

      let answer = (convertedConcentration * convertedVolume) / convertedFinal;
      console.log(
        convertedConcentration,
        convertedVolume,
        convertedFinal,
        answer
      );
      param.tech_answer = answer;
      return param;
    } else {
      param.error = "Please! Check Your Input.";
      return param;
    }
  }

  /** getCalculationChemicalEquationBalancerCalculator
   * POST: /api/calculators-lol/chemical-equation-balancer-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationChemicalEquationBalancerCalculator(body) {
    let eq = body.tech_eq?.trim();
    let param = {};

    if (!eq || /<|&|php|print_r|print|echo|script|%/i.test(eq)) {
      param.error = "Please Enter Valid Input.";
      return param;
    }

    // Prepare the equation
    let parem = eq
      .replace(/\s+/g, "")
      .replace(/→|->/g, "=")
      .replace(/%20/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/\^/g, "**");

    let [r, p] = parem.split("=");
    let option = 2;

    try {
      let response = await axios.get("http://167.172.134.148/limiting", {
        params: { r, p },
        timeout: 120000,
      });

      if (response.status !== 200 || !response.data.includes("@@@")) {
        param.error = "Please! Check Your Equation.";
        return param;
      }

      let [be, mols, atoms] = response.data.split("@@@");
      let inp = parem.replace(/plus/g, "+");

      param.tech_inp = inp;
      param.tech_be = be;
      param.tech_mols = mols;
      param.tech_atoms = atoms;
      param.tech_chemical_equation = eq.replace(/→|->/g, "=");
      param.tech_option = option;
      return param;
    } catch (error) {
      param.error = "Please! Check Your Input.";
      return param;
    }
  }

  /** getCalculationLimitingReactantCalculator
   * POST: /api/calculators-lol/limiting-reactant-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLimitingReactantCalculator(body) {
    let eq = (body.tech_eq || "").trim();

    // Validation against potentially dangerous input
    const invalidPattern = /<|>|&|php|print_r|print|echo|script|%/i;
    if (invalidPattern.test(eq)) {
      return { error: "Please Enter Valid Input." };
    }

    if (!eq) {
      return { error: "Please! Check Your Input." };
    }

    try {
      let parem = eq;
      parem = parem.replace(/\s+/g, "");
      parem = parem.replace(/%20/g, "");
      parem = parem.replace(/\+/g, "plus");
      parem = parem.replace(/{/g, "(");
      parem = parem.replace(/}/g, ")");
      parem = parem.replace(/e\^sqrt\(x\)/g, "exp(2*x)");
      parem = parem.replace(/e\^|exp\^/g, "exp");
      parem = parem.replace(/\^/g, "**");

      const [r, p] = parem.split("=");
      const option = 2;

      const response = await axios.get("http://167.172.134.148/limiting", {
        params: { r, p },
        timeout: 120000, // 120 seconds
      });

      const buffer = response.data.split("@@@");
      const inp = parem.replace(/plus/g, "+");

      return {
        teach_inp: inp,
        teach_be: buffer[0],
        teach_mols: buffer[1],
        teach_atoms: buffer[2],
        teach_chemical_equation: eq,
        teach_option: option,
      };
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationRedoxReactionCalculator
   * POST: /api/calculators-lol/redox-reaction-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRedoxReactionCalculator(body) {
    let eq = (body.tech_eq || "").trim();

    if (eq) {
      eq = eq.replace(/plus/g, "+");

      return {
        tech_eq: eq,
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /** getCalculationPPMCalculator
   * POST: /api/calculators-lol/ppm-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPPMCalculator(body) {
    let type = body.tech_calculator_name;
    let operations = body.tech_operations;
    let first = body.tech_first;
    let drop1 = body.tech_drop1;
    let drop2 = body.tech_drop2;
    let drop3 = body.tech_drop3;
    let second = body.tech_second;
    let drop4 = body.tech_drop4;
    let third = body.tech_third;

    let response = { tech_type: type };

    first = parseFloat(first);
    second = parseFloat(second);
    third = parseFloat(third);

    if (type === "calculator1") {
      if (isNaN(first)) {
        return { error: "Please! Check Your Input." };
      }

      switch (operations) {
        case "1":
          response.tech_answer1 = first;
          response.tech_answer2 = first * 100;
          response.tech_answer3 = first * 1000;
          response.tech_answer4 = first * 1000000;
          response.tech_answer5 = first * 1000000000;
          response.tech_answer6 = first * 1000000000000;
          break;
        case "2":
          response.tech_answer1 = first / 100;
          response.tech_answer2 = first;
          response.tech_answer3 = first * 10;
          response.tech_answer4 = first * 10000;
          response.tech_answer5 = first * 10000000;
          response.tech_answer6 = first * 10000000000;
          break;
        case "3":
          response.tech_answer1 = first / 1000;
          response.tech_answer2 = first / 10;
          response.tech_answer3 = first;
          response.tech_answer4 = first * 1000;
          response.tech_answer5 = first * 1000000;
          response.tech_answer6 = first * 1000000000;
          break;
        case "4":
          response.tech_answer1 = first / 1000000;
          response.tech_answer2 = first / 10000;
          response.tech_answer3 = first / 1000;
          response.tech_answer4 = first;
          response.tech_answer5 = first * 1000;
          response.tech_answer6 = first * 1000000;
          break;
        case "5":
          response.tech_answer1 = first / 1000000000;
          response.tech_answer2 = first / 10000000;
          response.tech_answer3 = first / 1000000;
          response.tech_answer4 = first / 1000;
          response.tech_answer5 = first;
          response.tech_answer6 = first * 1000;
          break;
        case "6":
          response.tech_answer1 = first / 1000000000000;
          response.tech_answer2 = first / 10000000000;
          response.tech_answer3 = first / 1000000000;
          response.tech_answer4 = first / 1000000;
          response.tech_answer5 = first / 1000;
          response.tech_answer6 = first;
          break;
        default:
          return { error: "Please! Check Your Input." };
      }
    } else if (type === "calculator2") {
      if (drop1 == 1 || drop1 == 2) {
        if (drop2 == 1) {
          if (drop4 == 1) {
            if (isNaN(second) || isNaN(third))
              return { error: "Please! Check Your Input." };
            let jawab1 = third * second;
            response.tech_jawab2 = parseFloat((jawab1 / 24.45).toFixed(3));
          } else if (drop4 == 2) {
            if (isNaN(second) || isNaN(third))
              return { error: "Please! Check Your Input." };
            let jawab1 = third * 24.45;
            response.tech_jawab2 = parseFloat((jawab1 / second).toFixed(3));
          }
        } else if (drop2 == 2) {
          if (drop4 == 1) {
            if (isNaN(second) || isNaN(third))
              return { error: "Please! Check Your Input." };
            let jawab1 = third * second;
            let jawab3 = jawab1 / 24.45;
            response.tech_jawab2 = jawab3 / 100000000000;
          } else if (drop4 == 2) {
            if (isNaN(second) || isNaN(third))
              return { error: "Please! Check Your Input." };
            let jawab1 = third * 24.45;
            let jawab3 = jawab1 / second;
            response.tech_jawab2 = jawab3 * 100000000000;
          }
        }
      } else if (drop1 == 3) {
        if (drop2 == 1) {
          if (drop4 == 1) {
            if (isNaN(third)) return { error: "Please! Check Your Input." };
            response.tech_jawab2 = parseFloat((third * 1.29).toFixed(3));
          } else if (drop4 == 2) {
            if (isNaN(third)) return { error: "Please! Check Your Input." };
            response.tech_jawab2 = parseFloat((third * 0.773).toFixed(3));
          }
        } else if (drop2 == 2) {
          if (drop4 == 1) {
            if (isNaN(third)) return { error: "Please! Check Your Input." };
            response.tech_jawab2 = parseFloat((third * 1000).toFixed(3));
          } else if (drop4 == 2) {
            if (isNaN(third)) return { error: "Please! Check Your Input." };
            response.tech_jawab2 = parseFloat((third / 1000).toFixed(3));
          }
        }
      }
    } else {
      return { error: "Invalid calculator_name" };
    }

    return response;
  }

  /** getCalculationMolalityCalculator
   * POST: /api/calculators-lol/molality-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMolalityCalculator(body) {
    let find = body.tech_find;
    let amount_solute = parseFloat(body.tech_amount_solute);
    let amount_solute_unit = body.tech_amount_solute_unit;
    let mass_solvent = parseFloat(body.tech_mass_solvent);
    let mass_solvent_unit = body.tech_mass_solvent_unit;
    let molality = parseFloat(body.tech_molality);
    let molality_unit = body.tech_molality_unit;
    let type = body.tech_type;
    let density = parseFloat(body.tech_density);
    let density_unit = parseFloat(body.tech_density_unit);
    let molecular_mass_solute = parseFloat(body.tech_molecular_mass_solute);
    let molecular_mass_solute_unit = parseFloat(
      body.tech_molecular_mass_solute_unit
    );

    let response = {};

    const unitConversion = {
      amount_solute_unit: {
        mol: 1,
        mmol: 0.001,
        µmol: 1e-6,
        nmol: 1e-9,
        pmol: 1e-12,
      },
      mass_solvent_unit: {
        µg: 1e-9,
        mg: 1e-6,
        g: 0.001,
        dag: 0.01,
        kg: 1,
        oz: 0.02835,
        lbs: 0.4536,
      },
      molality_unit: {
        "mol/µg": 1e-9,
        "mol/mg": 1e-6,
        "mol/g": 0.001,
        "mol/dag": 0.01,
        "mol/kg": 1,
        "mol/oz": 0.02835,
        "mol/lbs": 0.4536,
      },
    };

    amount_solute_unit =
      unitConversion.amount_solute_unit[amount_solute_unit] || 1;
    mass_solvent_unit =
      unitConversion.mass_solvent_unit[mass_solvent_unit] || 1;
    molality_unit = unitConversion.molality_unit[molality_unit] || 1;

    if (type === "first") {
      if (find === "1") {
        if (!isNaN(amount_solute) && !isNaN(mass_solvent)) {
          let amount_solute_value = amount_solute * amount_solute_unit;
          let mass_solvent_value = mass_solvent * mass_solvent_unit;
          let calculate_molality = amount_solute_value / mass_solvent_value;
          response.tech_molality = calculate_molality;
        } else {
          return { error: "Please! Check Your Input." };
        }
      } else if (find === "2") {
        if (!isNaN(molality) && !isNaN(mass_solvent)) {
          let mass_solvent_value = mass_solvent * mass_solvent_unit;
          let calculate_molality_value = molality * molality_unit;
          let amount_of_solute = mass_solvent_value * calculate_molality_value;
          response.tech_amount_of_solute = amount_of_solute;
        } else {
          return { error: "Please! Check Your Input." };
        }
      } else if (find === "3") {
        if (!isNaN(molality) && !isNaN(amount_solute)) {
          let amount_solute_value = amount_solute * amount_solute_unit;
          let calculate_molality_value = molality * molality_unit;
          let mass_of_solvent = amount_solute_value / calculate_molality_value;
          response.tech_amount_of_solvent = mass_of_solvent;
        } else {
          return { error: "Please! Check Your Input." };
        }
      }

      response.tech_method = find;
    } else if (type === "second") {
      if (
        !isNaN(density) &&
        !isNaN(molecular_mass_solute) &&
        !isNaN(molality)
      ) {
        let density_value = density * density_unit;
        let molecular_mass_solute_value =
          molecular_mass_solute / molecular_mass_solute_unit;
        let calculate_molality_value = molality * molality_unit;
        let calculate_molarity =
          density_value /
          (1 / calculate_molality_value + molecular_mass_solute_value / 1000);
        response.tech_molality = calculate_molarity;
      } else {
        return { error: "Please! Check Your Input." };
      }
    }

    response.tech_type = type;
    return response;
  }

  /** getCalculationMoleRatioCalculator
   * POST: /api/calculators-lol/mole-ratio-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMoleRatioCalculator(body) {
    let find = body.tech_find;
    let first_coefficient = body.tech_first_coefficient;
    let first_product = body.tech_first_product;
    let moles = body.tech_moles;

    let z = 0;
    let y = 0;
    let response = {};

    if (find === "1" || find === "2" || find === "3") {
      for (let i = 0; i < first_coefficient.length; i++) {
        if (isFinite(first_coefficient[i]) && first_coefficient[i] > 0) {
          z++;
        } else {
          response.error = "Please! Check Your Input.";
          return response;
        }
      }

      for (let j = 0; j < first_product.length; j++) {
        if (isFinite(first_product[j]) && first_product[j] > 0) {
          y++;
        } else {
          response.error = "Please! Check Your Input.";
          return response;
        }
      }
    }

    if (find === "2" && Array.isArray(moles)) {
      for (let k = 0; k < first_coefficient.length - 1; k++) {
        let smith =
          (moles[k] * first_coefficient[k + 1]) / first_coefficient[k];
        // You can add smith to response if needed
        // Example: response[`smith_${k}`] = smith;
      }
    }

    if (z === first_coefficient.length && y === first_product.length) {
      response.tch_coefficient = first_coefficient;
      response.tch_first_product = first_product;
    }

    return response;
  }

  /** getCalculationMolarityCalculator
   * POST: /api/calculators-lol/molarity-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMolarityCalculator(body) {
    let cal = String(body.tech_cal).trim();
    let mass = parseFloat(body.tech_mass);
    let mass_unit = String(body.tech_mass_unit).trim();
    let vol = parseFloat(body.tech_vol);
    let vol_unit = String(body.tech_vol_unit).trim();
    let conc = parseFloat(body.tech_conc);
    let conc_unit = String(body.tech_conc_unit).trim();
    let sc = parseFloat(body.tech_sc);
    let sc_unit = String(body.tech_sc_unit).trim();
    let dc = parseFloat(body.tech_dc);
    let dc_unit = String(body.tech_dc_unit).trim();
    let dv = parseFloat(body.tech_dv);
    let dv_unit = String(body.tech_dv_unit).trim();
    let mw = parseFloat(body.tech_mw);

    let response = {};

    const isValid = [mass, vol, conc, mw, sc, dc, dv].every((v) => !isNaN(v));

    if (!isValid) {
      response.error = "Please! Check Your Input.";
      return response;
    }

    // Unit conversions
    const unitConvert = {
      mass: { pg: 1e-12, ng: 1e-9, μg: 1e-6, mg: 1e-3, kg: 1e3 },
      vol: { nL: 1e-9, μL: 1e-6, mL: 1e-3 },
      conc: { fM: 1e-15, pM: 1e-12, nM: 1e-9, μM: 1e-6, mM: 1e-3 },
    };

    if (mass_unit in unitConvert.mass) mass *= unitConvert.mass[mass_unit];
    if (conc_unit in unitConvert.conc) conc *= unitConvert.conc[conc_unit];
    if (vol_unit in unitConvert.vol) vol *= unitConvert.vol[vol_unit];
    if (sc_unit in unitConvert.conc) sc *= unitConvert.conc[sc_unit];
    if (dc_unit in unitConvert.conc) dc *= unitConvert.conc[dc_unit];
    if (dv_unit in unitConvert.vol) dv *= unitConvert.vol[dv_unit];

    if (cal === "mass" && !isNaN(conc) && !isNaN(mw) && !isNaN(vol)) {
      mass = conc * vol * mw;
      response.tech_ans = `${(mass / 0.001).toFixed(
        4
      )} <span class="text-green font-s-25">mg</span>`;
      response.tech_ans_pg = `${(mass / 1e-12).toFixed(4)} pg`;
      response.tech_ans_ng = `${(mass / 1e-9).toFixed(4)} ng`;
      response.tech_ans_ug = `${(mass / 1e-6).toFixed(4)} μg`;
      response.tech_ans_g = `${mass.toFixed(4)} g`;
      response.tech_ans_kg = `${(mass / 1e6).toFixed(4)} kg`;
    } else if (cal === "vol" && !isNaN(mass) && !isNaN(mw) && !isNaN(conc)) {
      vol = mass / (conc * mw);
      response.tech_ans = `${(vol / 0.001).toFixed(
        4
      )} <span class="text-green font-s-25">mL</span>`;
      response.tech_ans_nl = `${(vol / 1e-9).toFixed(4)} nL`;
      response.tech_ans_ul = `${(vol / 1e-6).toFixed(4)} μL`;
      response.tech_ans_l = `${vol.toFixed(4)} L`;
    } else if (cal === "mol" && !isNaN(mass) && !isNaN(mw) && !isNaN(vol)) {
      let mol = mass / (vol * mw);
      response.tech_ans = `${(mol / 1e-3).toFixed(
        4
      )} <span class="text-green font-s-25">mM</span>`;
      response.tech_ans_fm = `${(mol / 1e-15).toFixed(4)} fM`;
      response.tech_ans_pm = `${(mol / 1e-12).toFixed(4)} pM`;
      response.tech_ans_nm = `${(mol / 1e-9).toFixed(4)} nM`;
      response.tech_ans_um = `${(mol / 1e-6).toFixed(4)} μM`;
      response.tech_ans_m = `${mol.toFixed(4)} M`;
    } else if (cal === "rv" && !isNaN(sc) && !isNaN(dc) && !isNaN(dv)) {
      if (dc > sc) {
        response.error =
          "Desired Concentration shouldn't be greater than Stock Concentration.";
        return response;
      }
      let rv = (dc / sc) * dv;
      response.tech_ans = `${(rv / 0.001).toFixed(
        4
      )} <span class="text-green font-s-25">mL</span>`;
      response.tech_ans_nl = `${(rv / 1e-9).toFixed(4)} nL`;
      response.tech_ans_ul = `${(rv / 1e-6).toFixed(4)} μL`;
      response.tech_ans_l = `${rv.toFixed(4)} L`;
    } else {
      response.error = "Please! Check Your Input.";
      return response;
    }

    return response;
  }
  /** getCalculationDilutionCalculator
   * POST: /api/calculators-lol/dilution-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDilutionCalculator(body) {
    let cal = body.tech_cal;
    let c1 = body.tech_c1;
    let c1_unit = body.tech_c1_unit;
    let v1 = body.tech_v1;
    let v1_unit = body.tech_v1_unit;
    let c2 = body.tech_c2;
    let c2_unit = body.tech_c2_unit;
    let v2 = body.tech_v2;
    let v2_unit = body.tech_v2_unit;

    c1 = parseFloat(c1);
    v1 = parseFloat(v1);
    c2 = parseFloat(c2);
    v2 = parseFloat(v2);

    let response = {};

    if (isFinite(c1) && isFinite(v1) && isFinite(c2) && isFinite(v2)) {
      // Convert concentration units to M
      if (c1_unit === "fM") c1 *= 1e-15;
      else if (c1_unit === "pM") c1 *= 1e-12;
      else if (c1_unit === "nM") c1 *= 1e-9;
      else if (c1_unit === "μM") c1 *= 1e-6;
      else if (c1_unit === "mM") c1 *= 1e-3;

      if (c2_unit === "fM") c2 *= 1e-15;
      else if (c2_unit === "pM") c2 *= 1e-12;
      else if (c2_unit === "nM") c2 *= 1e-9;
      else if (c2_unit === "μM") c2 *= 1e-6;
      else if (c2_unit === "mM") c2 *= 1e-3;

      // Convert volume units to L
      if (v1_unit === "nL") v1 *= 1e-9;
      else if (v1_unit === "μL") v1 *= 1e-6;
      else if (v1_unit === "mL") v1 *= 1e-3;

      if (v2_unit === "nL") v2 *= 1e-9;
      else if (v2_unit === "μL") v2 *= 1e-6;
      else if (v2_unit === "mL") v2 *= 1e-3;

      if (cal === "c1") {
        c1 = (c2 * v2) / v1;
        response.tech_ans = `${(c1 / 1e-3).toFixed(
          4
        )} <span class="text-green font-s-25">mM</span>`;
        response.tech_ans_fm = `${(c1 / 1e-15).toFixed(4)} fM`;
        response.tech_ans_pm = `${(c1 / 1e-12).toFixed(4)} pM`;
        response.tech_ans_nm = `${(c1 / 1e-9).toFixed(4)} nM`;
        response.tech_ans_um = `${(c1 / 1e-6).toFixed(4)} μM`;
        response.tech_ans_m = `${c1.toFixed(4)} M`;
      } else if (cal === "v1") {
        v1 = (c2 * v2) / c1;
        response.tech_ans = `${(v1 / 1e-3).toFixed(
          4
        )} <span class="text-green font-s-25">mL</span>`;
        response.tech_ans_nl = `${(v1 / 1e-9).toFixed(4)} nL`;
        response.tech_ans_ul = `${(v1 / 1e-6).toFixed(4)} μL`;
        response.tech_ans_l = `${v1.toFixed(4)} L`;
      } else if (cal === "c2") {
        c2 = (c1 * v1) / v2;
        response.tech_ans = `${(c2 / 1e-3).toFixed(
          4
        )} <span class="text-green font-s-25">mM</span>`;
        response.tech_ans_fm = `${(c2 / 1e-15).toFixed(4)} fM`;
        response.tech_ans_pm = `${(c2 / 1e-12).toFixed(4)} pM`;
        response.tech_ans_nm = `${(c2 / 1e-9).toFixed(4)} nM`;
        response.tech_ans_um = `${(c2 / 1e-6).toFixed(4)} μM`;
        response.tech_ans_m = `${c2.toFixed(4)} M`;
      } else if (cal === "v2") {
        v2 = (c1 * v1) / c2;
        response.tech_ans = `${(v2 / 1e-3).toFixed(
          4
        )} <span class="text-green font-s-25">mL</span>`;
        response.tech_ans_nl = `${(v2 / 1e-9).toFixed(4)} nL`;
        response.tech_ans_ul = `${(v2 / 1e-6).toFixed(4)} μL`;
        response.tech_ans_l = `${v2.toFixed(4)} L`;
      } else {
        response.error = "Please! Check Your Input.";
        return response;
      }

      return response;
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationAtomtoMolesCalculator
   * POST: /api/calculators-lol/atoms-to-moles-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAtomtoMolesCalculator(body) {
    let form = body.tech_form?.trim();
    let x = parseFloat(body.tech_x?.trim());

    let response = {};

    if (isFinite(x)) {
      let ans;

      if (form === "raw") {
        // Convert atomic mass unit to grams
        ans = x * 1.66053907e-24;
      } else {
        // Convert grams to number of atoms/moles
        ans = x * 6.02214076e23;
      }

      response.tech_ans = ans;
      return response;
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationGramstoAtomsCalculator
   * POST: /api/calculators-lol/grams-to-atoms-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationGramstoAtomsCalculator(body) {
    let form = body.tech_form?.trim();
    let x = parseFloat(body.tech_x?.trim());
    let y = parseFloat(body.tech_y?.trim());

    let response = {};

    if (isFinite(x)) {
      const na = 6.02214076e23;
      let ans;

      if (form === "raw") {
        ans = (na * y) / x;
      } else {
        ans = (y * x) / na;
      }

      response.tech_ans = ans.toExponential(3); // Same as sprintf('%.3e', ...) in PHP
      return response;
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationPkaToPhCalculator
   * POST: /api/calculators-lol/pka-to-ph-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPkaToPhCalculator(body) {
  const buf_unit = body.tech_buf_unit;
  const ka = parseFloat(body.tech_ka);
  const acid = parseFloat(body.tech_acid);
  const acid_unit = body.tech_acid_unit;
  const salt = parseFloat(body.tech_salt);
  const salt_unit = body.tech_salt_unit;
  const convert = body.tech_convert;
  const ph_input = parseFloat(body.tech_ph);

  const response = {};

  const log10 = (x) => Math.log(x) / Math.LN10;

  const getUnitMultiplier = (unit) => {
    switch (unit) {
      case "M": return 1;
      case "mM": return 0.001;
      case "μM": return 0.000001;
      default: return 0;
    }
  };

  const acid_unitx = getUnitMultiplier(acid_unit);
  const salt_unitx = getUnitMultiplier(salt_unit);

  const isValidNumber = (val) => isFinite(val) && val > 0;

  if (convert === "1") {
    // Convert from Ka to pH
    if ((buf_unit === "1" || buf_unit === "2") && isValidNumber(ka) && isValidNumber(acid) && isValidNumber(salt)) {
      const av = acid * acid_unitx;
      const sv = salt * salt_unitx;

      if (av <= 0 || sv <= 0) {
        return { error: "Converted acid/salt value must be greater than zero." };
      }

      let pka = -log10(ka);
      if (pka === -0) pka = 0;

      let ph;
      if (buf_unit === "1") {
        ph = pka - log10(av / sv);
      } else {
        ph = 14 - pka + log10(av / sv);
      }

      if (!isFinite(ph)) {
        return { error: "Calculation resulted in an invalid pH value." };
      }

      response.tech_unit = buf_unit;
      response.tech_pka = pka;
      response.tech_ph = ph;
    } else {
      return { error: "Please! Enter positive numeric values for Ka, Acid, and Salt." };
    }

  } else if (convert === "2") {
    // Convert from pH to Ka
    if ((buf_unit === "1" || buf_unit === "2") && isValidNumber(ph_input) && isValidNumber(acid) && isValidNumber(salt)) {
      const av = acid * acid_unitx;
      const sv = salt * salt_unitx;

      if (av <= 0 || sv <= 0) {
        return { error: "Converted acid/salt value must be greater than zero." };
      }

      let pka;
      if (buf_unit === "1") {
        pka = ph_input + log10(av / sv);
      } else {
        pka = 14 - ph_input + log10(av / sv);
      }

      const pk = Math.pow(10, -pka);

      if (!isFinite(pka) || !isFinite(pk)) {
        return { error: "Calculation resulted in an invalid pKa or Ka value." };
      }

      response.tech_unit = buf_unit;
      response.tech_pka = pka;
      response.tech_pk = pk;
    } else {
      return { error: "Please! Enter positive numeric values for pH, Acid, and Salt." };
    }

  } else {
    return { error: "Invalid conversion type." };
  }

  return response;
}


  /** getCalculationTheoreticalyieldCalculator
   * POST: /api/calculators-lol/theoretical-yield-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTheoreticalyieldCalculator(body) {
    let lx = parseFloat(body.tech_lx);
    let ly = parseFloat(body.tech_ly);
    let dx = parseFloat(body.tech_dx);
    let dy = parseFloat(body.tech_dy);
    let sx = parseFloat(body.tech_sx);
    let unit_x = body.tech_unit_x;

    let response = {};

    if (
      isFinite(lx) &&
      isFinite(ly) &&
      isFinite(dx) &&
      isFinite(dy) &&
      isFinite(sx)
    ) {
      let mass = lx;

      if (unit_x === "µg") {
        mass = mass / 1e6;
      } else if (unit_x === "mg") {
        mass = mass / 1000;
      } else if (unit_x === "kg") {
        mass = mass * 1000;
      } else if (unit_x === "lbs") {
        mass = mass * 454;
      }

      let mole = Math.round((mass / ly) * 100) / 100; // rounded to 2 decimal places
      let ans = Math.round(dx * dy * 100) / 100;
      let st = Math.round(dx * (sx / mole) * 100) / 100;

      response.tech_mole = mole;
      response.tech_st = st;
      response.tech_ans = ans;
      return response;
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationMolecularFormulaCalculator
   * POST: /api/calculators-lol/molecular-formula-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMolecularFormulaCalculator(body) {
    let no1 = parseFloat(body.tech_no1);
    let opt1 = body.tech_opt1?.trim();
    let no2 = parseFloat(body.tech_no2);
    let opt2 = body.tech_opt2?.trim();

    let response = {};

    if (isFinite(no1) && isFinite(no2) && opt1 && opt2) {
      let [nbr1, name] = opt1.split("@@");
      let [nbr2, name2] = opt2.split("@@");

      nbr1 = parseFloat(nbr1);
      nbr2 = parseFloat(nbr2);

      if (!isFinite(nbr1) || !isFinite(nbr2)) {
        response.error = "Invalid compound structure in opt1 or opt2.";
        return response;
      }

      let final_result1 = no1 / nbr1;
      let final_result2 = no2 / nbr2;
      let final_result3 = final_result1 / final_result2;

      response.tech_mode = 2;
      response.tech_name = name;
      response.tech_name2 = name2;
      response.tech_nbr1 = nbr1;
      response.tech_nbr2 = nbr2;
      response.tech_no1 = no1;
      response.tech_no2 = no2;
      response.tech_final_result1 = final_result1;
      response.tech_final_result2 = final_result2;
      response.tech_final_result3 = final_result3;

      return response;
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationFormalChargeCalculator
   * POST: /api/calculators-lol/formal-charge-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationFormalChargeCalculator(body) {
    let V = parseFloat(body.tech_V);
    let LP = parseFloat(body.tech_LP);
    let BE = parseFloat(body.tech_BE);

    let response = {};

    if (isFinite(V) && isFinite(LP) && isFinite(BE)) {
      let formal = V - (LP + 0.5 * BE);

      response.tech_formal = formal;
      return response;
    } else {
      response.error = "Please! Check Your Input.";
      return response;
    }
  }

  /** getCalculationEquilibriumConstantCalculator
   * POST: /api/calculators-lol/equilibrium-constant-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationEquilibriumConstantCalculator(body) {
    let concentration_one = parseFloat(body.tech_concentration_one);
    let concentration_one_unit = body.tech_concentration_one_unit;
    let concentration_two = parseFloat(body.tech_concentration_two);
    let concentration_two_unit = body.tech_concentration_two_unit;
    let concentration_three = parseFloat(body.tech_concentration_three);
    let concentration_three_unit = body.tech_concentration_three_unit;
    let concentration_four = parseFloat(body.tech_concentration_four);
    let concentration_four_unit = body.tech_concentration_four_unit;

    let a = parseFloat(body.tech_a);
    let b = parseFloat(body.tech_b);
    let c = parseFloat(body.tech_c);
    let d = parseFloat(body.tech_d);
    let selection = body.tech_selection;
    let chemical_equation = body.tech_chemical_equation || "";
    let total_pressure = parseFloat(body.tech_total_pressure);

    let response = {};

    // Input validation for chemical equation
    if (/[<>&]|php|print_r|print|echo|script|%/i.test(chemical_equation)) {
      response.error = "Please Enter Valid Input.";
      return response;
    }

    // Helper: Convert unit
    function convertUnit(unit, value) {
      switch (unit) {
        case "M":
          return value * 1;
        case "mM":
          return value * 0.001;
        case "μM":
          return value * 1e-6;
        case "nM":
          return value * 1e-9;
        case "pM":
          return value * 1e-12;
        case "fM":
          return value * 1e-15;
        case "aM":
        case "zM":
        case "yM":
          return value * 0;
        default:
          return NaN;
      }
    }

    if (chemical_equation) {
      if (selection === "1") {
        if (
          isFinite(concentration_one) &&
          isFinite(concentration_two) &&
          isFinite(concentration_three) &&
          isFinite(concentration_four) &&
          isFinite(a) &&
          isFinite(b) &&
          isFinite(c) &&
          isFinite(d)
        ) {
          let first_value = convertUnit(
            concentration_one_unit,
            concentration_one
          );
          let second_value = convertUnit(
            concentration_two_unit,
            concentration_two
          );
          let third_value = convertUnit(
            concentration_three_unit,
            concentration_three
          );
          let fourth_value = convertUnit(
            concentration_four_unit,
            concentration_four
          );

          let Kc =
            (Math.pow(third_value, c) * Math.pow(fourth_value, d)) /
            (Math.pow(second_value, b) * Math.pow(first_value, a));

          response.tech_answer = Kc;
          response.tech_opt = selection;
          return response;
        } else {
          response.error = "Please! Check Your Input.";
          return response;
        }
      } else if (selection === "2") {
        if (isFinite(total_pressure) && chemical_equation !== "") {
          response.tech_equation = chemical_equation;
          response.tech_total_pressure = total_pressure;
          response.tech_opt = selection;
          return response;
        } else {
          response.error = "Please! Check Your Input.";
          return response;
        }
      }
    }

    response.error = "Please Enter Valid Input.";
    return response;
  }

  /** getCalculationElectronConfigurationCalculator
   * POST: /api/calculators-lol/electron-configuration-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationElectronConfigurationCalculator(body) {
    let element = body.tech_element;

    if (!element) {
      return { error: "Element is required" };
    }

    const periodicTable = {
      H: [1, "Hydrogen", "Gas", 1.008, "1s¹", "N/A", "1s¹"],
      He: [2, "Helium", "Gas", 4.0026, "1s²", "N/A", "1s²"],
      Li: [3, "Lithium", "Solid", 6.94, "1s²2s¹", "[He]2s¹", "2s¹"],
      Be: [4, "Beryllium", "Solid", 9.0122, "1s²2s²", "[He]2s²", "2s²"],
      B: [5, "Boron", "Solid", 10.81, "1s²2s²2p¹", "[He]2s²2p¹", "2s²2p¹"],
      C: [6, "Carbon", "Solid", 12.011, "1s²2s²2p²", "[He]2s²2p²", "2s²2s²"],
      N: [7, "Nitrogen", "Gas", 14.007, "1s²2s²2p³", "[He]2s²2p³", "2s²2p³"],
      O: [8, "Oxygen", "Gas", 15.999, "1s²2s²2p⁴", "[He]2s²2p⁴", "2s²2p⁴"],
      F: [9, "Fluorine", "Gas", 18.998, "1s²2s²2p⁵", "[He]2s²2p⁵", "2s²2p⁵"],
      Ne: [10, "Neon", "Gas", 20.18, "1s²2s²2p⁶", "[He]2s²2p⁶", "2s²2p⁶"],
      Na: [11, "Sodium", "Solid", 22.99, "1s²2s²2p⁶3s¹", "[Ne]3s¹", "3s¹"],
      Mg: [12, "Magnesium", "Solid", 24.305, "1s²2s²2p⁶3s²", "[Ne]3s²", "3s²"],
      Al: [
        13,
        "Aluminum",
        "Solid",
        26.982,
        "1s²2s²2p⁶3s²3p¹",
        "[Ne]3s²3p¹",
        "3s²3p¹",
      ],
      Si: [
        14,
        "Silicon",
        "Solid",
        28.085,
        "1s²2s²2p⁶3s²3p²",
        "[Ne]3s²3p²",
        "3s²3p²",
      ],
      P: [
        15,
        "Phosphorus",
        "Solid",
        30.974,
        "1s²2s²2p⁶3s²3p³",
        "[Ne]3s²3p³",
        "3s²3p³",
      ],
      S: [
        16,
        "Sulfur",
        "Solid",
        32.06,
        "1s²2s²2p⁶3s²3p⁴",
        "[Ne]3s²3p⁴",
        "3s²3p⁴",
      ],
      Cl: [
        17,
        "Chlorine",
        "Gas",
        35.45,
        "1s²2s²2p⁶3s²3p⁵",
        "[Ne]3s²3p⁵",
        "3s²3p⁵",
      ],
      Ar: [
        18,
        "Argon",
        "Gas",
        39.948,
        "1s²2s²2p⁶3s²3p⁶",
        "[Ne]3s²3p⁶",
        "3s²3p⁶",
      ],
      K: [
        19,
        "Potassium",
        "Solid",
        39.098,
        "1s²2s²2p⁶3s²3p⁶4s¹",
        "[Ar]4s¹",
        "4s¹",
      ],
      Ca: [
        20,
        "Calcium",
        "Solid",
        40.078,
        "1s²2s²2p⁶3s²3p⁶4s²",
        "[Ar]4s²",
        "4s²",
      ],
      Sc: [
        21,
        "Scandium",
        "Solid",
        44.956,
        "1s²2s²2p⁶3s²3p⁶3d¹4s²",
        "[Ar]4s²3d¹",
        "3d¹4s²",
      ],
      Ti: [
        22,
        "Titanium",
        "Solid",
        47.867,
        "1s²2s²2p⁶3s²3p⁶3d²4s²",
        "[Ar]4s²3d²",
        "3d²4s²",
      ],
      V: [
        23,
        "Vanadium",
        "Solid",
        50.942,
        "1s²2s²2p⁶3s²3p⁶3d³4s²",
        "[Ar]4s²3d³",
        "3d³4s²",
      ],
      Cr: [
        24,
        "Chromium",
        "Solid",
        51.996,
        "1s²2s²2p⁶3s²3p⁶3d⁵4s¹",
        "[Ar]3d⁵4s¹",
        "3d⁵4s¹",
      ],
      Mn: [
        25,
        "Manganese",
        "Solid",
        54.938,
        "1s²2s²2p⁶3s²3p⁶3d⁵4s²",
        "[Ar]4s²3d⁵",
        "3d⁵4s²",
      ],
      Fe: [
        26,
        "Iron",
        "Solid",
        55.845,
        "1s²2s²2p⁶3s²3p⁶3d64s²",
        "[Ar]4s²3d⁶",
        "3d64s²",
      ],
      Co: [
        27,
        "Cobalt",
        "Solid",
        58.933,
        "1s²2s²2p⁶3s²3p⁶3d⁷4s²",
        "[Ar]4s²3d⁷",
        "3d⁷4s²",
      ],
      Ni: [
        28,
        "Nickel",
        "Solid",
        58.693,
        "1s²2s²2p⁶3s²3p⁶3d⁸4s²",
        "[Ar]4s²3d⁸",
        "3d⁸4s²",
      ],
      Cu: [
        29,
        "Copper",
        "Solid",
        63.546,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s¹",
        "[Ar]4s¹3d¹⁰",
        "3d¹⁰4s¹",
      ],
      Zn: [
        30,
        "Zinc",
        "Solid",
        65.38,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²",
        "[Ar]4s²3d¹⁰",
        "3d¹⁰4s²",
      ],
      Ga: [
        31,
        "Gallium",
        "Solid",
        69.723,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p¹",
        "[Ar]4s²3d¹⁰4p¹",
        "4s²4p¹",
      ],
      Ge: [
        32,
        "Germanium",
        "Solid",
        72.63,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p²",
        "[Ar]4s²3d¹⁰4p²",
        "4s²4p²",
      ],
      As: [
        33,
        "Arsenic",
        "Solid",
        74.922,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p³",
        "[Ar]4s²3d¹⁰4p³",
        "4s²4p³",
      ],
      Se: [
        34,
        "Selenium",
        "Solid",
        78.971,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁴",
        "[Ar]4s²3d¹⁰4p⁴",
        "4s²4p⁴",
      ],
      Br: [
        35,
        "Bromine",
        "Liquid",
        79.904,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁵",
        "[Ar]4s²3d¹⁰4p⁵",
        "4s²4p⁵",
      ],
      Kr: [
        36,
        "Krypton",
        "Gas",
        83.798,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶",
        "[Ar]4s²3d¹⁰4p⁶",
        "4s²4p⁶",
      ],
      Rb: [
        37,
        "Rubidium",
        "Solid",
        85.468,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶5s¹",
        "[Kr]5s¹",
        "5s¹",
      ],
      Sr: [
        38,
        "Strontium",
        "Solid",
        87.62,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶5s²",
        "[Kr]5s²",
        "5s²",
      ],
      Y: [
        39,
        "Yttrium",
        "Solid",
        88.906,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹5s²",
        "[Kr]5s²4d¹",
        "4d¹5s²",
      ],
      Zr: [
        40,
        "Zirconium",
        "Solid",
        91.224,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d²5s²",
        "[Kr]5s²4d²",
        "4d²5s²",
      ],
      Nb: [
        41,
        "Niobium",
        "Solid",
        92.906,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d⁴5s¹",
        "[Kr]5s¹4d⁴",
        "4d⁴5s¹",
      ],
      Mo: [
        42,
        "Molybdenum",
        "Solid",
        95.95,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d⁵5s¹",
        "[Kr]5s¹4d⁵",
        "4d⁵5s¹",
      ],
      Tc: [
        43,
        "Technetium",
        "Solid",
        98,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d⁵5s²",
        "[Kr]5s²4d⁵",
        "4d⁵5s²",
      ],
      Ru: [
        44,
        "Ruthenium",
        "Solid",
        101.07,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d⁷5s¹",
        "[Kr]5s¹4d⁷",
        "4d⁷5s¹",
      ],
      Rh: [
        45,
        "Rhodium",
        "Solid",
        102.91,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d⁸5s¹",
        "[Kr]5s¹4d⁸",
        "4d⁸5s¹",
      ],
      Pd: [
        46,
        "Palladium",
        "Solid",
        106.42,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰",
        "[Kr]4d¹⁰",
        "4d¹⁰",
      ],
      Ag: [
        47,
        "Silver",
        "Solid",
        107.87,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s¹",
        "[Kr]5s¹4d¹⁰",
        "4d¹⁰5s¹",
      ],
      Cd: [
        48,
        "Cadmium",
        "Solid",
        112.41,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²",
        "[Kr]5s²4d¹⁰",
        "4d¹⁰5s²",
      ],
      In: [
        49,
        "Indium",
        "Solid",
        114.82,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p¹",
        "[Kr]5s²4d¹⁰5p¹",
        "5s²5p¹",
      ],
      Sn: [
        50,
        "Tin",
        "Solid",
        118.71,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p²",
        "[Kr]5s²4d¹⁰5p²",
        "5s²5p²",
      ],
      Sb: [
        51,
        "Antimony",
        "Solid",
        121.76,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p³",
        "[Kr]5s²4d¹⁰5p³",
        "5s²5p³",
      ],
      Te: [
        52,
        "Tellurium",
        "Solid",
        127.6,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁴",
        "[Kr]5s²4d¹⁰5p⁴",
        "5s²5p⁴",
      ],
      I: [
        53,
        "Iodine",
        "Solid",
        126.9,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁵",
        "[Kr]5s²4d¹⁰5p⁵",
        "5s²5p⁵",
      ],
      Xe: [
        54,
        "Xenon",
        "Gas",
        131.29,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶",
        "[Kr]5s²4d¹⁰5p⁶",
        "5s²5p⁶",
      ],
      Cs: [
        55,
        "Cesium",
        "Solid",
        132.91,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s¹",
        "[Xe]6s¹",
        "6s¹",
      ],
      Ba: [
        56,
        "Barium",
        "Solid",
        137.33,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²",
        "[Xe]6s²",
        "6s²",
      ],
      La: [
        57,
        "Lanthanum",
        "Solid",
        138.91,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²5d¹",
        "[Xe]6s²5d¹",
        "6s²5d¹",
      ],
      Ce: [
        58,
        "Cerium",
        "Solid",
        140.12,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹5d¹",
        "[Xe]6s²4f¹5d¹",
        "6s²4f¹5d¹",
      ],
      Pr: [
        59,
        "Praseodymium",
        "Solid",
        140.91,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f³",
        "[Xe]6s²4f³",
        "6s²4f³",
      ],
      Nd: [
        60,
        "Neodymium",
        "Solid",
        144.24,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f⁴",
        "[Xe]6s²4f⁴",
        "6s²4f⁴",
      ],
      Pm: [
        61,
        "Promethium",
        "Solid",
        145,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f⁵",
        "[Xe]6s²4f⁵",
        "6s²4f⁵",
      ],
      Sm: [
        62,
        "Samarium",
        "Solid",
        150.36,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f⁶",
        "[Xe]6s²4f⁶",
        "6s²4f⁶",
      ],
      Eu: [
        63,
        "Europium",
        "Solid",
        151.96,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f⁷",
        "[Xe]6s²4f⁷",
        "6s²4f⁷",
      ],
      Gd: [
        64,
        "Gadolinium",
        "Solid",
        157.25,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶5d¹6s²4f⁷",
        "[Xe]6s²4f⁷5d¹",
        "6s²4f⁷5d¹",
      ],
      Tb: [
        65,
        "Terbium",
        "Solid",
        158.93,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f⁹",
        "[Xe]6s²4f⁹",
        "6s²4f⁹",
      ],
      Dy: [
        66,
        "Dysprosium",
        "Solid",
        162.5,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹⁰",
        "[Xe]6s²4f¹⁰",
        "6s²4f¹⁰",
      ],
      Ho: [
        67,
        "Holmium",
        "Solid",
        164.93,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹¹",
        "[Xe]6s²4f¹¹",
        "6s²4f¹¹",
      ],
      Er: [
        68,
        "Erbium",
        "Solid",
        167.26,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹²",
        "[Xe]6s²4f¹²",
        "6s²4f¹²",
      ],
      Tm: [
        69,
        "Thulium",
        "Solid",
        168.93,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹³",
        "[Xe]6s²4f¹³",
        "6s²4f¹³",
      ],
      Yb: [
        70,
        "Ytterbium",
        "Solid",
        173.05,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴",
        "[Xe]6s²4f¹⁴",
        "6s²4f¹⁴",
      ],
      Lu: [
        71,
        "Lutetium",
        "Solid",
        174.97,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹",
        "[Xe]6s²4f¹⁴5d¹",
        "6s²⁴5d¹",
      ],
      Hf: [
        72,
        "Hafnium",
        "Solid",
        178.49,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d²",
        "[Xe]6s²4f¹⁴5d²",
        "6s²5d²",
      ],
      Ta: [
        73,
        "Tantalum",
        "Solid",
        180.95,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d³",
        "[Xe]6s²4f¹⁴5d³",
        "6s²5d³",
      ],
      W: [
        74,
        "Tungsten",
        "Solid",
        183.84,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d⁴",
        "[Xe]6s²4f¹⁴5d⁴",
        "6s²5d⁴",
      ],
      Re: [
        75,
        "Rhenium",
        "Solid",
        186.21,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d⁵",
        "[Xe]6s²4f¹⁴5d⁵",
        "6s²5d⁵",
      ],
      Os: [
        76,
        "Osmium",
        "Solid",
        190.23,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d6",
        "[Xe]6s²4f¹⁴5d⁶",
        "6s²5d⁶",
      ],
      Ir: [
        77,
        "Iridium",
        "Solid",
        192.22,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d⁷",
        "[Xe]6s²4f¹⁴5d⁷",
        "6s²5d⁷",
      ],
      Pt: [
        78,
        "Platinum",
        "Solid",
        195.08,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s¹4f¹⁴5d⁹",
        "[Xe]6s¹4f¹⁴5d⁹",
        "6s¹5d⁹",
      ],
      Au: [
        79,
        "Gold",
        "Solid",
        196.97,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s¹4f¹⁴5d¹⁰",
        "[Xe]6s¹4f¹⁴5d¹⁰",
        "6s¹5d¹⁰",
      ],
      Hg: [
        80,
        "Mercury",
        "Solid",
        200.59,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰",
        "[Xe]6s²4f¹⁴5d¹⁰",
        "6s²5d¹⁰",
      ],
      Tl: [
        81,
        "Thallium",
        "Solid",
        204.38,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p¹",
        "[Xe]6s²4f¹⁴5d¹⁰6p¹",
        "6s²6p¹",
      ],
      Pb: [
        82,
        "Lead",
        "Solid",
        207.2,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p²",
        "[Xe]6s²4f¹⁴5d¹⁰6p²",
        "6s²6p²",
      ],
      Bi: [
        83,
        "Bismuth",
        "Solid",
        208.98,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p³",
        "[Xe]6s²4f¹⁴5d¹⁰6p³",
        "6s²6p³",
      ],
      Po: [
        84,
        "Polonium",
        "Solid",
        209,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁴",
        "[Xe]6s²4f¹⁴5d¹⁰6p⁴",
        "6s²6p⁴",
      ],
      At: [
        85,
        "Astatine",
        "Solid",
        210,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁵",
        "[Xe]6s²4f¹⁴5d¹⁰6p⁵",
        "6s²6p⁵",
      ],
      Rn: [
        86,
        "Radon",
        "Gas",
        222,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶",
        "[Xe]6s²4f¹⁴5d¹⁰6p⁶",
        "6s²6p⁶",
      ],
      Fr: [
        87,
        "Francium",
        "Solid",
        223,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s¹",
        "[Rn]7s¹",
        "7s¹",
      ],
      Ra: [
        88,
        "Radium",
        "Solid",
        226,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²",
        "[Rn]7s²",
        "7s²",
      ],
      Ac: [
        89,
        "Actinium",
        "Solid",
        227,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶6d¹7s²",
        "[Rn]7s²6d¹",
        "7s²6d¹",
      ],
      Th: [
        90,
        "Thorium",
        "Solid",
        232.04,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶6d²7s²",
        "[Rn]7s²6d²",
        "7s²6d²",
      ],
      Pa: [
        91,
        "Protactinium",
        "Solid",
        231.04,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f²6d¹",
        "[Rn]7s²5f²6d¹",
        "7s²5f²6d¹",
      ],
      U: [
        92,
        "Uranium",
        "Solid",
        238.03,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f³6d¹",
        "[Rn]7s²5f³6d¹",
        "7s²5f³6d¹",
      ],
      Np: [
        93,
        "Neptunium",
        "Solid",
        237,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²6p⁶4f¹⁴5d¹⁰7s²5f⁴6d¹ ",
        "[Rn]7s²5f⁴6d¹",
        "7s²5f⁴6d¹ ",
      ],
      Pu: [
        94,
        "Plutonium",
        "Solid",
        244,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²6s²4f¹⁴5d¹⁰6p⁶7s²5f⁶5p⁶",
        "[Rn]7s²5f⁶",
        "7s²5f⁶",
      ],
      Am: [
        95,
        "Americium",
        "Solid",
        243,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f⁷",
        "[Rn]7s²5f⁷",
        "7s²5f⁷",
      ],
      Cm: [
        96,
        "Curium",
        "Solid",
        247,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f⁷6d¹",
        "[Rn]7s²5f⁷6d¹",
        "7s²5f⁷6d¹",
      ],
      Bk: [
        97,
        "Berkelium",
        "Solid",
        247,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f⁹",
        "[Rn]7s²5f⁹",
        "7s²5f⁹",
      ],
      Cf: [
        98,
        "Californium",
        "Solid",
        251,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁰",
        "[Rn]7s²5f¹⁰",
        "7s²5f¹⁰",
      ],
      Es: [
        99,
        "Einsteinium",
        "Solid",
        252,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹¹",
        "[Rn]7s²5f¹¹",
        "7s²5f¹¹",
      ],
      Fm: [
        100,
        "Fermium",
        "Solid",
        257,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹²",
        "[Rn]5f¹²7s²",
        "5f¹²7s²",
      ],
      Md: [
        101,
        "Mendelevium",
        "Solid",
        258,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹³",
        "[Rn]7s²5f¹³",
        "7s²5f¹³",
      ],
      No: [
        102,
        "Nobelium",
        "Solid",
        259,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴",
        "[Rn]7s²5f¹⁴",
        "7s²5f¹⁴",
      ],
      Lr: [
        103,
        "Lawrencium",
        "Solid",
        266,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴7p¹",
        "[Rn]7s²5f¹⁴6d¹",
        "7s²7p¹",
      ],
      Rf: [
        104,
        "Rutherfordium",
        "Solid",
        267,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴6d²",
        "[Rn]7s²5f¹⁴6d²",
        "7s²6d²",
      ],
      Db: [
        105,
        "Dubnium",
        "Solid",
        268,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴6d³",
        "[Rn]7s²5f¹⁴6d³",
        "7s²6d³",
      ],
      Sg: [
        106,
        "Seaborgium",
        "Solid",
        269,
        "1s²2s²2p⁶3s²3p⁶4s²3d¹⁰4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴6d⁴",
        "[Rn]7s²5f¹⁴6d⁴",
        "7s²6d⁴",
      ],
      Bh: [
        107,
        "Bohrium",
        "Solid",
        270,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴6d⁵",
        "[Rn]7s²5f¹⁴6d⁵",
        "7s²6d⁵",
      ],
      Hs: [
        108,
        "Hassium",
        "Solid",
        277,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴6d⁶",
        "[Rn]7s²5f¹⁴6d⁶",
        "7s²6d⁶",
      ],
      Mt: [
        109,
        "Meitnerium",
        "Solid",
        278,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴6d⁷",
        "[Rn]7s²5f¹⁴6d⁷",
        "7s²6d⁷",
      ],
      Ds: [
        110,
        "Darmstadtium",
        "Solid (Expected)",
        281,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴6d⁸",
        "[Rn]7s²5f¹⁴6d⁸",
        "7s²6d⁸",
      ],
      Rg: [
        111,
        "Roentgenium",
        "Solid (Expected)",
        282,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴6d⁹",
        "[Rn]7s²5f¹⁴6d⁹",
        "7s²6d⁹",
      ],
      Cn: [
        112,
        "Copernicium",
        "Solid (Expected)",
        285,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶6d¹⁰7s²5f¹⁴",
        "[Rn]7s²5f¹⁴6d¹⁰",
        "7s²6d¹⁰",
      ],
      Nh: [
        113,
        "Nihonium",
        "Solid (Expected)",
        286,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴6d¹⁰7p¹",
        "[Rn]5f¹⁴6d¹⁰7s²7p¹",
        "7s²7p¹",
      ],
      Fl: [
        114,
        "Flerovium",
        "Solid (Expected)",
        289,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴6d¹⁰7p²",
        "[Rn]7s²7p²5f¹⁴6d¹⁰",
        "7s²7p²",
      ],
      Mc: [
        115,
        "Moscovium",
        "Solid (Expected)",
        290,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴6d¹⁰7p³",
        "[Rn]7s²7p³5f¹⁴6d¹⁰",
        "7s²7p³",
      ],
      Lv: [
        116,
        "Livermorium",
        "Solid (Expected)",
        293,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴6d¹⁰7p⁴",
        "[Rn]7s²7p⁴5f¹⁴6d¹⁰",
        "7s²7p⁴",
      ],
      Ts: [
        117,
        "Tennessine",
        "Solid (Expected)",
        294,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴6d¹⁰7p⁵",
        "[Rn]7s²7p⁵5f¹⁴6d¹⁰",
        "7s²7p⁵",
      ],
      Og: [
        118,
        "Oganesson",
        "Gas (Expected)",
        294,
        "1s²2s²2p⁶3s²3p⁶3d¹⁰4s²4p⁶4d¹⁰5s²5p⁶6s²4f¹⁴5d¹⁰6p⁶7s²5f¹⁴6d¹⁰7p⁶",
        "[Rn]7s²7p⁶5f¹⁴6d¹⁰",
        "7s²7p⁶",
      ],
    };

    const result = periodicTable[element];

    if (!result) {
      return { error: "Element not found in the periodic table." };
    }

    return {
      tech_atomicNumber: result[0],
      tech_element: result[1],
      tech_phase: result[2],
      tech_atomicMass: result[3],
      tech_configuration: result[4],
      tech_nobleGasNotation: result[5],
      tech_valenceConfiguration: result[6],
    };
  }
  /** getCalculationMolarMassCalculator
   * POST: /api/calculators-lol/molar-mass-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMolarMassCalculator(body) {
    let f = (body.tech_f || "").trim();

    // Basic input validation - similar regex to PHP
    const forbiddenPattern =
      /<|>|\&|php|print_r|print|echo|script|sin|cos|tan|arcsin|arccos|arctan|&|%/i;
    if (forbiddenPattern.test(f)) {
      return { error: "Please Enter Valid Input." };
    }

    if (!f) {
      return { error: "Please! Check Your Input." };
    }

    // Prepare the input string similar to PHP str_replace
    let parem = f;
    parem = parem.replace(/\s+/g, "");
    parem = parem.replace(/%20/g, "");
    parem = parem.replace(/\+/g, "plus");
    parem = parem.replace(/{/g, "(");
    parem = parem.replace(/}/g, ")");
    parem = parem.replace(/e\^/g, "exp");
    parem = parem.replace(/exp\^/g, "exp");
    parem = parem.replace(/\^/g, "**");
    parem = parem.replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    try {
      const response = await axios.get("http://167.172.134.148/molar", {
        timeout: 120000,
        params: { f: parem },
      });

      const buffer = response.data.split("@@@");

      let mass = buffer[2];
      let atoms = buffer[5];
      let elem = buffer[6].split("###");
      let mm = buffer[7].split("###");
      let num = buffer[8].split("###");
      let rm = buffer[9].split("###");
      let frac = buffer[10].split("###");
      let t_mm = buffer[11];

      let table = `<table class='col-12' cellspacing='0'>
              <thead>
                  <tr>
                      <th class='text-start border-b py-2 pe-2'>Element</th>
                      <th class='text-start border-b py-2 pe-2'>No. of Atoms</th>
                      <th class='text-start border-b py-2 pe-2'>Molar Mass (MM)</th>
                      <th class='text-start border-b py-2 pe-2'>(%)</th>
                      <th class='text-start py-2'>Subtotal Mass</th>
                  </tr>
              </thead>
              <tbody>`;

      table += `<tr><td class='border-b py-2'>&nbsp;</td><td class='border-b py-2'>&nbsp;</td><td class='border-b py-2'>(g/mol)</td><td class='border-b py-2'>(%)</td><td class='border-b py-2'>(g/mol)</td></tr>`;

      for (let i = 0; i < elem.length - 1; i++) {
        table += `<tr>
                  <td class='border-b py-2'>${elem[i]}</td>
                  <td class='border-b py-2'>${num[i]}</td>
                  <td class='border-b py-2'>${parseFloat(mm[i]).toFixed(4)}</td>
                  <td class='border-b py-2'>${parseFloat(frac[i]).toFixed(
                    2
                  )}</td>
                  <td class='border-b py-2'>${parseFloat(rm[i]).toFixed(4)}</td>
              </tr>`;
      }

      table += `<tr>
              <th class='text-start py-2'>Total</th>
              <th class='text-start py-2'>${atoms}</th>
              <th class='text-start py-2'>${parseFloat(t_mm).toFixed(4)}</th>
              <th class='text-start py-2'>100.00</th>
              <th class='text-start py-2'>${parseFloat(mass).toFixed(4)}</th>
          </tr></tbody></table>`;

      return {
        tech_hill: buffer[0],
        tech_emp: buffer[1],
        tech_mass: parseFloat(mass).toFixed(4),
        tech_n_mass: parseFloat(buffer[3]).toFixed(4),
        tech_m_mass: parseFloat(buffer[4]).toFixed(4),
        tech_atoms: atoms,
        tech_table: table,
        tech_elem: elem,
        tech_frac: frac,
      };
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationTitrationCalculator
   * POST: /api/calculators-lol/titration-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationTitrationCalculator(body) {
    let cal = (body.tech_cal || "").trim();
    let ma = parseFloat((body.tech_ma || "").toString().trim());
    let ma_unit = (body.tech_ma_unit || "").trim();
    let va = parseFloat((body.tech_va || "").toString().trim());
    let va_unit = (body.tech_va_unit || "").trim();
    let mb = parseFloat((body.tech_mb || "").toString().trim());
    let mb_unit = (body.tech_mb_unit || "").trim();
    let vb = parseFloat((body.tech_vb || "").toString().trim());
    let vb_unit = (body.tech_vb_unit || "").trim();
    let hp = parseFloat((body.tech_hp || "").toString().trim());
    let oh = parseFloat((body.tech_oh || "").toString().trim());

    // Helper function to convert molarity units to M (molar)
    function convertMolarity(value, unit) {
      if (isNaN(value)) return NaN;
      switch (unit) {
        case "pM":
          return value * 1e-12;
        case "nM":
          return value * 1e-9;
        case "μM":
          return value * 1e-6;
        case "mM":
          return value * 1e-3;
        default:
          return value;
      }
    }

    // Helper function to convert volume units to liters
    function convertVolume(value, unit) {
      if (isNaN(value)) return NaN;
      switch (unit) {
        case "mm³":
          return value * 1e-6;
        case "cm³":
          return value * 1e-3;
        case "dm³":
          return value * 1;
        case "m³":
          return value * 1000;
        case "cu in":
          return value * 0.0163871;
        case "cu ft":
          return value * 28.3168;
        case "cu yd":
          return value * 764.555;
        case "ml":
          return value * 0.001;
        case "cl":
          return value * 0.01;
        case "l":
          return value * 1;
        case "us gal":
          return value * 3.78541;
        case "uk gal":
          return value * 4.54609;
        case "us fl oz":
          return value * 0.0295735;
        case "uk fl oz":
          return value * 0.0284131;
        default:
          return value;
      }
    }

    // Convert units to standard units
    ma = convertMolarity(ma, ma_unit);
    va = convertVolume(va, va_unit);
    mb = convertMolarity(mb, mb_unit);
    vb = convertVolume(vb, vb_unit);

    // Validate numeric inputs
    if ([ma, va, mb, vb, hp, oh].some((x) => isNaN(x))) {
      return { error: "Please! Check Your Input." };
    }

    // Calculation cases
    if (cal === "ma") {
      // ma = (oh * mb * vb) / (va * hp)
      let ans = (oh * mb * vb) / (va * hp);

      return {
        tech_ans: `${ans} <span class="text-green font-s-25">M</span>`,
        tech_ans_pm: `${ans * 1e-12} pM`,
        tech_ans_nm: `${ans * 1e-9} nM`,
        tech_ans_um: `${ans * 1e-6} μM`,
        tech_ans_mm: `${ans * 1e-3} mM`,
      };
    } else if (cal === "va") {
      // va = (oh * mb * vb) / (ma * hp)
      let ans = (oh * mb * vb) / (ma * hp);

      return {
        tech_ans: `${ans} <span class="text-green font-s-25">liter</span>`,
        tech_ans_nl: `${ans * 1e-9} nL`,
        tech_ans_ul: `${ans * 1e-6} μL`,
        tech_ans_ml: `${ans * 1e-3} mL`,
      };
    } else if (cal === "hp") {
      // hp = (oh * mb * vb) / (ma * va)
      let tech_ans = (oh * mb * vb) / (ma * va);

      return { tech_ans };
    } else if (cal === "mb") {
      // mb = (hp * ma * va) / (oh * vb)
      let ans = (hp * ma * va) / (oh * vb);

      return {
        tech_ans: `${ans} <span class="font-s20">M</span>`,
        tech_ans_pm: `${ans * 1e-12} pM`,
        tech_ans_nm: `${ans * 1e-9} nM`,
        tech_ans_um: `${ans * 1e-6} μM`,
        tech_ans_mm: `${ans * 1e-3} mM`,
      };
    } else if (cal === "vb") {
      // vb = (hp * ma * va) / (oh * mb)
      let ans = (hp * ma * va) / (oh * mb);

      return {
        tech_ans: `${ans} <span class="font-s20">liter</span>`,
        tech_ans_nl: `${ans * 1e-9} nL`,
        tech_ans_ul: `${ans * 1e-6} μL`,
        ans_ml: `${ans * 1e-3} mL`,
      };
    } else if (cal === "oh") {
      // oh = (hp * ma * va) / (vb * mb)
      let tech_ans = (hp * ma * va) / (vb * mb);

      return { tech_ans };
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationHalfLifeCalculator
   * POST: /api/calculators-lol/half-life-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationHalfLifeCalculator(body) {
    let calculator_name = body.tech_calculator_name?.trim();
    let param = {};

    let check = false;

    if (calculator_name === "calculator1") {
      let find = body.tech_find?.trim();
      let nt = parseFloat(body.tech_nt?.trim());
      let n0 = parseFloat(body.tech_n0?.trim());
      let t = parseFloat(body.tech_t?.trim());
      let t1_2 = parseFloat(body.tech_t1_2?.trim());

      if (!isNaN(nt) && !isNaN(n0) && !isNaN(t) && !isNaN(t1_2)) {
        check = true;
      }

      if (check) {
        if (find === "nt") {
          let s1 = t / t1_2;
          let s2 = Math.pow(0.5, s1);
          nt = n0 * s2;
          param = {
            tech_ans: nt,
            tech_s1: s1,
            tech_s2: s2,
            tech_share: "share",
          };
        } else if (find === "n0") {
          let s1 = t / t1_2;
          let s2 = Math.pow(0.5, s1);
          n0 = nt / s2;
          param = {
            tech_ans: n0,
            tech_s1: s1,
            tech_s2: s2,
            tech_share: "share",
          };
        } else if (find === "t") {
          let s1 = nt / n0;
          let s2 = Math.log(s1);
          let s3 = t1_2 * s2;
          let s4 = -Math.log(2);
          t = s3 / s4;
          param = {
            tech_ans: t,
            tech_s1: s1,
            tech_s2: s2,
            tech_s3: s3,
            tech_s4: s4,
            tech_share: "share",
          };
        } else if (find === "t1_2") {
          let s1 = nt / n0;
          let s2 = Math.log(s1);
          let s3 = -Math.log(2);
          let s4 = t * s3;
          t1_2 = s4 / s2;
          param = {
            tech_ans: t1_2,
            tech_s1: s1,
            tech_s2: s2,
            tech_s3: s3,
            tech_s4: s4,
            tech_share: "share",
          };
        } else {
          param = { error: "Please! Check Your Input." };
        }
      }
    } else {
      let find_by = body.tech_find_by?.trim();
      let t_1_2 = parseFloat(body.tech_t_1_2?.trim());
      let T = parseFloat(body.tech_T?.trim());
      let lamda = parseFloat(body.tech_lamda?.trim());

      if (!isNaN(t_1_2) && !isNaN(T) && !isNaN(lamda)) {
        check = true;
      }

      if (check) {
        if (find_by === "t_1_2") {
          T = t_1_2 / Math.log(2);
          lamda = Math.log(2) / t_1_2;
        } else if (find_by === "T") {
          t_1_2 = T * Math.log(2);
          lamda = Math.log(2) / t_1_2;
        } else if (find_by === "lamda") {
          t_1_2 = Math.log(2) / lamda;
          T = t_1_2 / Math.log(2);
        } else {
          return { error: "Please! Check Your Input." };
        }

        param = {
          tech_t_1_2: t_1_2,
          tech_T: T,
          tech_lamda: lamda,
        };
      }
    }

    if (!check && !param.RESULT) {
      param = { error: "Please! Check Your Input." };
    }

    return param;
  }

  /** getCalculationMoleCalculator
   * POST: /api/calculators-lol/mole-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMoleCalculator(body) {
    let cal = body.tech_cal?.trim();
    let mass = parseFloat(body.tech_mass?.trim());
    let mass_unit = body.tech_mass_unit?.trim();
    let mw = parseFloat(body.tech_mw?.trim());
    let moles = parseFloat(body.tech_moles?.trim());
    let moles_unit = body.tech_moles_unit?.trim();
    let param = {};

    if (!isNaN(mass) && !isNaN(mw) && !isNaN(moles)) {
      function sigFig(value, digits) {
        if (value === 0) return 0;
        const decimalPlaces = Math.max(
          0,
          Math.min(100, digits - Math.floor(Math.log10(Math.abs(value))) - 1)
        );
        return Number(value.toFixed(decimalPlaces));
      }

      // Convert mass to grams
      const massConversions = {
        pg: 1e-12,
        ng: 1e-9,
        μg: 1e-6,
        mg: 1e-3,
        dag: 10,
        kg: 1000,
        t: 1e6,
        oz: 28.35,
        lbs: 453.6,
        stones: 6350,
        "US ton": 907185,
        "Long ton": 1016047,
        u: 1 / 6.02214e23,
      };
      if (massConversions[mass_unit]) {
        mass *= massConversions[mass_unit];
      }

      // Convert moles to base mol
      const molesConversions = {
        mM: 1e-3,
        μM: 1e-6,
        nM: 1e-9,
        pM: 1e-12,
      };
      if (molesConversions[moles_unit]) {
        moles *= molesConversions[moles_unit];
      }

      if (cal === "mass") {
        mass = mw * moles;

        param.tech_ans = `${sigFig(
          mass,
          4
        )} <span class="text-green font-s-25">g</span>`;
        param.tech_ans_pg = `${sigFig(mass / 1e-12, 4)} pg`;
        param.tech_ans_ng = `${sigFig(mass / 1e-9, 4)} ng`;
        param.tech_ans_ug = `${sigFig(mass / 1e-6, 4)} μg`;
        param.tech_ans_mg = `${sigFig(mass / 1e-3, 4)} mg`;
        param.tech_ans_dag = `${sigFig(mass / 10, 4)} dag`;
        param.tech_ans_kg = `${sigFig(mass / 1000, 4)} kg`;
        param.tech_ans_t = `${sigFig(mass / 1e6, 4)} t`;
        param.tech_ans_oz = `${sigFig(mass / 28.35, 4)} oz`;
        param.tech_ans_lb = `${sigFig(mass / 453.6, 4)} lb`;
        param.tech_ans_stone = `${sigFig(mass / 6350, 4)} stone`;
        param.tech_ans_us_ton = `${sigFig(mass / 907185, 4)} US ton`;
        param.tech_ans_long_ton = `${sigFig(mass / 1016047, 4)} Long ton`;
        param.tech_ans_u = `${sigFig(mass * 6.02214e23, 4)} u`;
      } else if (cal === "mw") {
        mw = mass / moles;
        param.tech_ans = `${sigFig(
          mw,
          4
        )} <span class="text-green font-s-25">g/mol</span>`;
      } else if (cal === "moles") {
        moles = mass / mw;

        param.tech_ans = `${sigFig(
          moles,
          4
        )} <span class="text-green font-s-25">M</span>`;
        param.tech_ans_mm = `${sigFig(moles / 1e-3, 4)} mM`;
        param.tech_ans_um = `${sigFig(moles / 1e-6, 4)} μM`;
        param.tech_ans_nm = `${sigFig(moles / 1e-9, 4)} nM`;
        param.tech_ans_pm = `${sigFig(moles / 1e-12, 4)} pM`;
      } else {
        return { error: "Please! Check Your Input." };
      }

      // Molecules calculations
      let molecules_23 = sigFig(moles * 6.02214076, 4);
      param.tech_molecules_23 = `${molecules_23}x10²³`;
      param.tech_molecules_22 = `${sigFig(molecules_23 * 10, 4)}x10²²`;
      param.tech_molecules_24 = `${sigFig(molecules_23 * 0.1, 4)}x10²⁴`;

      return param;
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationAtomicMassCalculator
   * POST: /api/calculators-lol/atomic-mass-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAtomicMassCalculator(body) {
    let z = parseInt(body.tech_z);
    let n = parseInt(body.tech_n);
    let param = {};

    if (isNaN(z) || isNaN(n)) {
      param.error = "Please! Check Your Input.";
      return param;
    }

    function checkIsotope(isotopeList, z, n) {
      return isotopeList.some((item) => item[0] === z && item[1] === n);
    }

    const elementSymbols = [
      "H",
      "He",
      "Li",
      "Be",
      "B",
      "C",
      "N",
      "O",
      "F",
      "Ne",
      "Na",
      "Mg",
      "Al",
      "Si",
      "P",
      "S",
      "Cl",
      "Ar",
      "K",
      "Ca",
      "Sc",
      "Ti",
      "V",
      "Cr",
      "Mn",
      "Fe",
      "Co",
      "Ni",
      "Cu",
      "Zn",
      "Ga",
      "Ge",
      "As",
      "Se",
      "Br",
      "Kr",
      "Rb",
      "Sr",
      "Y",
      "Zr",
      "Nb",
      "Mo",
      "Tc",
      "Ru",
      "Rh",
      "Pd",
      "Ag",
      "Cd",
      "In",
      "Sn",
      "Sb",
      "Te",
      "I",
      "Xe",
      "Cs",
      "Ba",
      "La",
      "Ce",
      "Pr",
      "Nd",
      "Pm",
      "Sm",
      "Eu",
      "Gd",
      "Tb",
      "Dy",
      "Ho",
      "Er",
      "Tm",
      "Yb",
      "Lu",
      "Hf",
      "Ta",
      "W",
      "Re",
      "Os",
      "Ir",
      "Pt",
      "Au",
      "Hg",
      "Tl",
      "Pb",
      "Bi",
      "Po",
      "At",
      "Rn",
      "Fr",
      "Ra",
      "Ac",
      "Th",
      "Pa",
      "U",
      "Np",
      "Pu",
      "Am",
      "Cm",
      "Bk",
      "Cf",
      "Es",
      "Fm",
      "Md",
      "No",
      "Lr",
      "Rf",
      "Db",
      "Sg",
      "Bh",
      "Hs",
      "Mt",
      "Ds",
      "Rg",
      "Cn",
      "Nh",
      "Fl",
      "Mc",
      "Lv",
      "Ts",
      "Og",
    ];

    const stableIsotopes = [
      [52, 76],
      [54, 70],
      [36, 42],
      [54, 82],
      [32, 44],
      [56, 74],
      [34, 48],
      [48, 68],
      [20, 28],
      [83, 126],
      [40, 56],
      [52, 78],
      [60, 90],
      [42, 58],
      [63, 88],
      [74, 106],
      [23, 27],
      [48, 65],
      [62, 86],
      [60, 84],
      [76, 110],
      [72, 102],
      [49, 66],
      [64, 88],
      [78, 112],
      [62, 85],
      [57, 81],
      [37, 50],
      [75, 112],
      [71, 105],
      [90, 142],
      [92, 146],
      [19, 21],
      [92, 143],
      [94, 150],
      [62, 84],
      [41, 51],
      [92, 144],
      [82, 123],
      [53, 76],
      [96, 151],
      [72, 110],
      [46, 61],
      [43, 54],
      [43, 55],
      [25, 28],
      [66, 88],
      [26, 34],
      [83, 127],
      [55, 80],
      [93, 144],
      [64, 86],
      [40, 53],
      [4, 6],
      [13, 13],
      [94, 148],
      [83, 125],
      [96, 152],
      [17, 19],
      [34, 45],
      [92, 142],
      [50, 76],
      [36, 45],
      [43, 56],
      [75, 111],
      [92, 141],
      [93, 143],
      [20, 21],
      [28, 31],
      [90, 140],
      [57, 80],
      [82, 120],
      [91, 140],
      [94, 145],
      [41, 53],
      [96, 149],
      [96, 154],
      [95, 148],
      [90, 139],
      [94, 146],
      [6, 8],
      [96, 150],
      [67, 96],
      [42, 51],
      [88, 138],
      [97, 150],
      [67, 99],
      [98, 153],
      [41, 50],
      [80, 114],
      [47, 61],
      [95, 146],
      [98, 151],
      [97, 151],
      [18, 21],
      [77, 115],
      [65, 93],
      [95, 147],
      [14, 18],
      [84, 125],
      [28, 35],
      [62, 89],
      [94, 144],
      [65, 92],
      [64, 84],
      [92, 140],
      [22, 22],
      [78, 115],
      [50, 71],
      [63, 87],
      [18, 24],
      [83, 124],
      [72, 106],
      [55, 82],
      [96, 147],
      [38, 52],
      [82, 128],
      [89, 138],
      [96, 148],
      [61, 84],
      [41, 52],
      [94, 147],
      [48, 65],
      [63, 89],
      [98, 152],
      [1, 2],
      [36, 49],
      [56, 77],
      [63, 91],
      [76, 118],
      [88, 140],
      [61, 85],
      [27, 33],
      [63, 92],
      [81, 123],
      [71, 103],
      [45, 56],
      [45, 57],
      [84, 124],
      [94, 142],
      [51, 74],
      [26, 29],
      [98, 154],
      [61, 86],
      [11, 11],
      [55, 79],
      [69, 102],
      [90, 138],
      [72, 100],
      [73, 106],
      [71, 102],
      [99, 153],
      [48, 61],
      [93, 142],
      [44, 62],
      [61, 83],
      [62, 83],
      [98, 150],
      [97, 152],
      [23, 26],
      [25, 29],
      [50, 69],
      [58, 86],
      [99, 155],
      [27, 30],
      [32, 36],
      [61, 82],
      [47, 63],
      [30, 35],
      [64, 89],
      [45, 57],
      [79, 116],
      [77, 117],
      [75, 109],
      [96, 146],
      [20, 25],
      [71, 106],
      [52, 69],
      [66, 93],
      [71, 103],
      [84, 126],
      [58, 81],
      [50, 73],
      [69, 101],
      [64, 87],
      [74, 107],
      [34, 41],
      [52, 71],
      [50, 63],
      [73, 109],
      [52, 75],
      [39, 49],
      [100, 157],
      [76, 109],
      [69, 99],
      [63, 86],
      [43, 54],
      [16, 19],
      [37, 46],
      [21, 25],
      [40, 48],
      [33, 40],
      [27, 29],
      [74, 111],
      [77, 115],
      [65, 95],
      [27, 31],
      [75, 108],
      [72, 103],
      [74, 114],
      [38, 47],
      [40, 55],
      [43, 52],
      [41, 50],
      [98, 156],
      [51, 73],
      [53, 72],
      [39, 52],
      [52, 73],
      [63, 85],
      [4, 3],
      [101, 157],
      [38, 51],
      [49, 65],
      [64, 82],
      [80, 123],
      [94, 143],
      [48, 67],
      [26, 33],
      [72, 109],
      [61, 87],
      [47, 58],
      [99, 156],
      [44, 59],
      [54, 73],
      [75, 109],
      [41, 54],
      [18, 19],
      [52, 77],
      [37, 47],
      [96, 145],
      [58, 83],
      [70, 99],
      [101, 159],
      [24, 27],
      [96, 144],
      [91, 142],
      [38, 44],
      [15, 18],
      [72, 107],
      [90, 144],
      [63, 84],
      [74, 104],
      [92, 138],
      [99, 154],
      [52, 69],
      [90, 137],
      [37, 49],
      [98, 155],
      [33, 41],
      [91, 139],
      [46, 57],
      [45, 54],
      [23, 25],
      [76, 115],
      [83, 122],
      [63, 93],
      [88, 137],
      [15, 17],
      [50, 67],
      [59, 84],
      [77, 112],
      [55, 81],
      [53, 73],
      [56, 84],
      [51, 75],
      [81, 121],
      [54, 77],
      [77, 113],
      [56, 75],
      [88, 135],
      [32, 39],
      [60, 87],
      [94, 152],
      [77, 116],
      [78, 110],
      [41, 51],
      [89, 136],
      [55, 76],
      [50, 75],
      [68, 101],
      [64, 85],
      [69, 98],
      [54, 75],
      [84, 122],
      [34, 38],
      [47, 59],
      [71, 100],
      [53, 78],
      [99, 158],
      [47, 64],
      [65, 96],
      [92, 145],
      [71, 101],
      [71, 106],
      [55, 77],
      [83, 123],
      [79, 117],
      [28, 28],
      [52, 66],
      [63, 82],
      [51, 69],
      [25, 27],
      [61, 87],
      [65, 91],
      [65, 90],
      [54, 79],
      [73, 110],
      [83, 127],
      [97, 148],
      [52, 67],
      [63, 83],
      [20, 27],
      [93, 141],
      [45, 56],
      [78, 115],
      [43, 53],
      [92, 139],
      [70, 105],
      [53, 71],
      [78, 117],
      [51, 76],
      [86, 136],
      [75, 111],
      [88, 136],
      [46, 54],
      [41, 54],
      [66, 100],
      [60, 80],
      [21, 26],
      [39, 48],
      [40, 49],
      [31, 36],
      [52, 80],
      [58, 76],
      [79, 120],
      [81, 120],
      [100, 153],
      [78, 113],
      [49, 62],
      [44, 53],
      [42, 57],
      [51, 71],
      [33, 38],
      [79, 119],
      [80, 117],
      [39, 51],
      [75, 107],
      [69, 103],
      [29, 38],
      [21, 23],
      [56, 72],
      [35, 42],
      [70, 96],
      [73, 104],
      [93, 146],
      [65, 88],
      [28, 38],
      [94, 153],
      [79, 119],
      [48, 67],
      [61, 88],
      [54, 79],
      [82, 121],
      [93, 145],
      [95, 145],
      [68, 104],
      [71, 99],
      [30, 42],
      [62, 91],
      [78, 124],
      [21, 27],
      [97, 149],
      [80, 115],
      [77, 111],
      [57, 83],
      [99, 155],
      [32, 37],
      [56, 77],
      [33, 44],
      [51, 68],
      [64, 83],
      [79, 115],
      [91, 138],
      [98, 148],
      [28, 29],
      [45, 60],
      [35, 47],
      [36, 43],
      [58, 79],
      [71, 98],
      [58, 85],
      [99, 152],
      [38, 45],
      [55, 74],
      [105, 163],
      [91, 141],
      [76, 117],
      [69, 96],
      [52, 79],
      [89, 137],
      [68, 92],
      [61, 90],
      [56, 79],
      [50, 71],
      [67, 99],
      [33, 43],
      [81, 119],
      [33, 39],
      [90, 141],
      [100, 152],
      [96, 156],
      [65, 91],
      [75, 114],
      [80, 117],
      [74, 113],
      [97, 151],
      [72, 101],
      [41, 55],
      [65, 89],
      [93, 143],
      [19, 24],
      [76, 106],
      [91, 137],
      [24, 24],
      [65, 89],
      [82, 118],
      [46, 66],
      [12, 16],
      [45, 55],
      [53, 80],
      [54, 68],
      [100, 155],
      [43, 52],
      [75, 106],
      [78, 119],
      [57, 78],
      [77, 117],
      [59, 83],
      [79, 121],
      [64, 95],
      [58, 77],
      [79, 114],
      [65, 86],
      [27, 28],
      [65, 87],
      [75, 113],
      [54, 71],
      [40, 57],
      [77, 109],
      [40, 46],
      [35, 41],
      [52, 67],
      [95, 147],
      [72, 98],
      [63, 94],
      [11, 13],
      [36, 40],
      [39, 47],
      [86, 125],
      [41, 49],
      [77, 108],
      [92, 148],
      [31, 41],
      [30, 39],
      [46, 63],
      [39, 48],
      [53, 70],
      [76, 115],
      [76, 107],
      [63, 87],
      [29, 35],
      [75, 107],
      [78, 122],
      [53, 77],
      [19, 23],
      [72, 99],
      [95, 144],
      [80, 113],
      [83, 120],
      [32, 45],
      [83, 121],
      [78, 111],
      [82, 130],
      [80, 115],
      [73, 102],
      [94, 151],
      [77, 110],
      [68, 97],
      [39, 54],
      [95, 149],
      [103, 163],
      [65, 89],
      [76, 107],
      [66, 89],
      [38, 53],
      [79, 117],
      [31, 35],
      [62, 94],
      [52, 75],
      [82, 119],
      [63, 89],
      [30, 32],
      [54, 81],
      [27, 31],
      [51, 77],
      [58, 79],
      [94, 140],
      [73, 111],
      [99, 151],
      [46, 55],
      [26, 26],
      [69, 104],
      [73, 107],
      [66, 91],
      [85, 125],
      [73, 103],
      [69, 97],
      [99, 157],
      [68, 103],
      [81, 118],
      [85, 126],
      [34, 39],
      [42, 51],
      [91, 143],
      [53, 82],
      [48, 59],
      [37, 45],
      [66, 87],
      [55, 72],
      [89, 139],
      [43, 56],
      [59, 86],
      [76, 113],
      [84, 123],
      [42, 48],
      [101, 156],
      [46, 65],
      [60, 79],
      [72, 108],
      [85, 124],
      [47, 66],
      [65, 91],
      [81, 117],
      [100, 151],
      [60, 78],
      [67, 93],
      [51, 67],
      [94, 149],
      [79, 113],
      [49, 61],
      [58, 75],
      [43, 51],
      [39, 46],
      [31, 42],
      [80, 112],
      [57, 75],
      [45, 54],
      [105, 162],
      [71, 108],
      [37, 44],
      [97, 146],
      [49, 66],
      [36, 49],
      [44, 61],
      [35, 45],
      [59, 80],
      [51, 78],
      [97, 147],
      [49, 60],
      [72, 112],
      [65, 84],
      [50, 60],
      [21, 23],
      [30, 41],
      [57, 84],
      [57, 76],
      [21, 22],
      [77, 118],
      [80, 113],
      [71, 105],
      [103, 159],
      [82, 120],
      [39, 53],
      [84, 120],
      [58, 74],
      [65, 85],
      [48, 69],
      [29, 32],
      [82, 127],
      [100, 154],
      [97, 153],
      [68, 93],
      [75, 115],
      [39, 51],
      [79, 112],
      [73, 100],
      [47, 65],
      [98, 149],
      [77, 107],
      [77, 113],
      [22, 23],
      [67, 100],
      [62, 72],
      [96, 143],
      [81, 116],
      [36, 52],
      [16, 22],
      [38, 49],
      [51, 66],
      [89, 135],
      [43, 50],
      [39, 46],
      [61, 89],
      [38, 54],
      [100, 156],
      [14, 17],
      [25, 31],
      [28, 37],
      [77, 118],
      [74, 102],
      [48, 69],
      [52, 64],
      [60, 81],
      [67, 94],
      [86, 124],
      [82, 116],
      [96, 142],
      [35, 48],
      [66, 86],
      [73, 105],
      [78, 109],
      [66, 99],
      [104, 163],
      [53, 79],
      [68, 90],
      [32, 34],
      [56, 73],
      [62, 88],
      [74, 103],
      [45, 61],
      [56, 73],
      [59, 79],
      [53, 68],
      [50, 77],
      [54, 69],
      [78, 108],
      [95, 150],
      [41, 48],
      [76, 119],
      [49, 68],
      [77, 109],
      [70, 107],
      [81, 117],
      [81, 115],
      [36, 47],
      [9, 9],
      [18, 23],
      [69, 94],
      [91, 148],
      [83, 118],
      [85, 122],
      [86, 138],
      [38, 42],
      [76, 105],
      [84, 121],
      [60, 89],
      [83, 119],
      [99, 150],
      [65, 82],
      [40, 47],
      [56, 70],
      [49, 64],
      [27, 34],
      [44, 51],
      [95, 143],
      [85, 123],
      [58, 75],
      [35, 40],
      [63, 89],
      [101, 158],
      [78, 119],
      [88, 142],
      [57, 85],
      [33, 45],
      [82, 117],
      [32, 46],
      [98, 157],
      [81, 115],
      [77, 119],
      [53, 79],
      [56, 83],
      [32, 43],
      [53, 67],
      [105, 161],
      [101, 155],
      [59, 78],
      [36, 51],
      [70, 94],
      [68, 95],
      [36, 41],
      [70, 108],
      [95, 142],
      [62, 80],
      [41, 56],
      [78, 107],
      [81, 114],
      [52, 77],
      [47, 57],
      [49, 61],
      [73, 101],
      [31, 37],
      [38, 47],
      [77, 113],
      [67, 95],
      [82, 122],
      [41, 48],
      [47, 56],
      [96, 153],
      [72, 111],
      [89, 140],
      [52, 65],
      [93, 147],
      [72, 110],
      [83, 129],
      [51, 65],
      [65, 83],
      [105, 165],
    ];

    const radioactiveIsotopes = [
      // Add any known radioactive isotopes here if needed.
    ];

    const a = z + n;

    if (z > 118) {
      param.error = "To date, the maximum number of protons is 118.";
      return param;
    } else if (n > 177) {
      param.error = "To date, the maximum number of neutrons is 177.";
      return param;
    } else if (a > 0 && z > 0 && n >= 0) {
      param.tech_symbol = elementSymbols[z - 1];

      if (checkIsotope(stableIsotopes, z, n)) {
        param.tech_stable = "Stable";
      } else if (checkIsotope(radioactiveIsotopes, z, n)) {
        param.tech_unstable = "Unstable";
      } else {
        param.tech_unobserved = "Unobserved";
      }

      param.tech_a = a;
      param.tech_asi = a * 1.66;
      return param;
    }

    param.error = "Please! Check Your Input.";
    return param;
  }

  /** getCalculationNernstEquationCalculator
   * POST: /api/calculators-lol/nernst-equation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationNernstEquationCalculator(body) {
    let cal = String(body.tech_cal).trim();
    let ecell = parseFloat(body.tech_ecell);
    let ecell_unit = String(body.tech_ecell_unit).trim();
    let eo = parseFloat(body.tech_eo);
    let eo_unit = String(body.tech_eo_unit).trim();
    let t = parseFloat(body.tech_t);
    let t_unit = String(body.tech_t_unit).trim();
    let n = parseFloat(body.tech_n);
    let q = parseFloat(body.tech_q);

    let param = {};

    if (isNaN(ecell) || isNaN(eo) || isNaN(t) || isNaN(n) || isNaN(q)) {
      param.error = "Please! Check Your Input.";
      return param;
    }

    // Convert units
    if (ecell_unit === "mV") {
      ecell *= 0.001;
    }
    if (eo_unit === "mV") {
      eo *= 0.001;
    }
    if (t_unit === "°C") {
      t = t * 1 + 273.15;
    } else if (t_unit === "°F") {
      t = ((t - 32) * 5) / 9 + 273.15;
    }

    const r = 0.00008617332;

    try {
      if (cal === "ecell") {
        ecell = eo - (r * t * Math.log(q)) / n;
        param.tech_ans = `${ecell} <span class="text-green font-s-25">V</span>`;
      } else if (cal === "eo") {
        eo = ecell + (r * t * Math.log(q)) / n;
        param.tech_ans = `${eo} <span class="text-green font-s-25">V</span>`;
      } else if (cal === "t") {
        const denominator = Math.log(q) * r;
        if (denominator === 0) {
          t = Infinity;
        } else {
          t = ((eo - ecell) * n) / denominator;
        }
        param.tech_ans = `${t} <span class="text-green font-s-25">K</span>`;
      } else if (cal === "n") {
        if (eo - ecell === 0) {
          n = Infinity;
        } else {
          n = (Math.log(q) * r * t) / (eo - ecell);
        }
        param.tech_ans = n;
      } else if (cal === "q") {
        if (r * t === 0) {
          q = Infinity;
        } else {
          q = Math.exp((n * (eo - ecell)) / (r * t));
        }
        param.tech_ans = q;
      } else {
        param.error = "Please! Check Your Input.";
        return param;
      }

      return param;
    } catch (e) {
      param.error = "An error occurred during calculation.";
      return param;
    }
  }

  /** getCalculationGramsToMolesCalculator
   * POST: /api/calculators-lol/grams-to-moles-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationGramsToMolesCalculator(body) {
    let chemical_selection = body.tech_chemical_selection;
    let unit = body.tech_unit;
    let mm_unit = body.tech_mm_unit;
    let mm = parseFloat(body.tech_mm);
    let m_unit = body.tech_m_unit;
    let m = parseFloat(body.tech_m);
    let nm = parseFloat(body.tech_nm);
    let nm_unit = body.tech_nm_unit;

    if (nm_unit == "mol") {
      nm_unit = "1";
    } else if (nm_unit == "mmol") {
      nm_unit = "2";
    } else if (nm_unit == "μmol") {
      nm_unit = "3";
    } else if (nm_unit == "nmol") {
      nm_unit = "4";
    } else if (nm_unit == "pmol") {
      nm_unit = "5";
    }

    if (m_unit == "ng") {
      m_unit = "1";
    } else if (m_unit == "µg") {
      m_unit = "2";
    } else if (m_unit == "mg") {
      m_unit = "3";
    } else if (m_unit == "g") {
      m_unit = "4";
    } else if (m_unit == "dag") {
      m_unit = "5";
    } else if (m_unit == "kg") {
      m_unit = "6";
    }

    if (mm_unit == "g/mol") {
      mm_unit = "1";
    } else if (mm_unit == "dag/mol") {
      mm_unit = "2";
    } else if (mm_unit == "kg/mol") {
      mm_unit = "3";
    }

    let param = {};
    let mm_convert, m_convert, ans1, ans2, nm_convert, ans3, ans4, ans5, ans6;
    if (unit === "1") {
      if (!isNaN(mm) && !isNaN(m) && mm > 0 && m > 0) {
        if (mm_unit == "1") {
          mm_convert = mm * 1;
        } else if (mm_unit == "2") {
          mm_convert = mm * 10;
        } else if (mm_unit == "3") {
          mm_convert = mm * 1000;
        }
        if (m_unit == "1") {
          m_convert = m * 0.000000001;
        } else if (m_unit == "2") {
          m_convert = m * 0.000001;
        } else if (m_unit == "3") {
          m_convert = m * 0.001;
        } else if (m_unit == "4") {
          m_convert = m * 1;
        } else if (m_unit == "5") {
          m_convert = m * 10;
        } else if (m_unit == "6") {
          m_convert = m * 1000;
        }
        ans1 = m_convert / mm_convert;
        ans2 = ans1 * 6.02214085774;

        param.tech_ans90 = m_convert;
        param.tech_ans91 = mm_convert;
        param.tech_ans1 = ans1;
        param.tech_ans2 = ans2;
      } else {
        param.error = "Please! Check Your Input.";
      }
    } else if (unit === "2") {
      if (!isNaN(mm) && !isNaN(nm) && mm > 0 && nm > 0) {
        if (mm_unit == "1") {
          mm_convert = mm * 1;
        } else if (mm_unit == "2") {
          mm_convert = mm * 10;
        } else if (mm_unit == "3") {
          mm_convert = mm * 1000;
        }
        if (nm_unit == "1") {
          nm_convert = nm * 1;
        } else if (nm_unit == "2") {
          nm_convert = nm * 0.001;
        } else if (nm_unit == "3") {
          nm_convert = nm * 0.000001;
        } else if (nm_unit == "4") {
          nm_convert = nm * 0.000000001;
        } else if (nm_unit == "5") {
          nm_convert = nm * 0.000000000001;
        }
        ans3 = nm_convert * mm_convert;
        ans4 = nm_convert * 6.02214085774;

        param.tech_ans90 = mm_convert;
        param.tech_ans91 = nm_convert;
        param.tech_ans3 = ans3;
        param.tech_ans4 = ans4;
      } else {
        param.error = "Please! Check Your Input.";
      }
    } else if (unit === "3") {
      if (!isNaN(m) && !isNaN(nm) && m > 0 && nm > 0) {
        if (m_unit == "1") {
          m_convert = m * 0.000000001;
        } else if (m_unit == "2") {
          m_convert = m * 0.000001;
        } else if (m_unit == "3") {
          m_convert = m * 0.001;
        } else if (m_unit == "4") {
          m_convert = m * 1;
        } else if (m_unit == "5") {
          m_convert = m * 10;
        } else if (m_unit == "6") {
          m_convert = m * 1000;
        }
        if (nm_unit == "1") {
          nm_convert = nm * 1;
        } else if (nm_unit == "2") {
          nm_convert = nm * 0.001;
        } else if (nm_unit == "3") {
          nm_convert = nm * 0.000001;
        } else if (nm_unit == "4") {
          nm_convert = nm * 0.000000001;
        } else if (nm_unit == "5") {
          nm_convert = nm * 0.000000000001;
        }
        ans5 = m_convert / nm_convert;
        ans6 = nm_convert * 6.02214085774;

        param.tech_ans5 = ans5;
        param.tech_ans6 = ans6;
        param.tech_ans90 = m_convert;
        param.tech_ans91 = nm_convert;
      } else {
        param.error = "Please! Check Your Input.";
      }
    }

    return param;
  }

  /** getCalculationMolesToGramsCalculator
   * POST: /api/calculators-lol/moles-to-grams-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMolesToGramsCalculator(body) {
    let {
      tech_chemical_selection,
      tech_unit: unit,
      tech_mm_unit: mm_unit,
      tech_mm: mm,
      tech_m_unit: m_unit,
      tech_m: m,
      tech_nm: nm,
      tech_nm_unit: nm_unit,
    } = body;

    let param = {};
    let nmUnits,
      mm_convert,
      m_convert,
      ans1,
      ans2,
      ans3,
      ans4,
      ans5,
      ans6,
      nm_convert;

    if (nm_unit == "mol") {
      nm_unit = "1";
    } else if (nm_unit == "mmol") {
      nm_unit = "2";
    } else if (nm_unit == "μmol") {
      nm_unit = "3";
    } else if (nm_unit == "nmol") {
      nm_unit = "4";
    } else if (nm_unit == "pmol") {
      nm_unit = "5";
    }

    if (m_unit == "ng") {
      m_unit = "1";
    } else if (m_unit == "µg") {
      m_unit = "2";
    } else if (m_unit == "mg") {
      m_unit = "3";
    } else if (m_unit == "g") {
      m_unit = "4";
    } else if (m_unit == "dag") {
      m_unit = "5";
    } else if (m_unit == "kg") {
      m_unit = "6";
    }

    if (mm_unit == "g/mol") {
      mm_unit = "1";
    } else if (mm_unit == "dag/mol") {
      mm_unit = "2";
    } else if (mm_unit == "kg/mol") {
      mm_unit = "3";
    }

    if (unit === "1") {
      if (!isNaN(mm) && !isNaN(m) && mm > 0 && m > 0) {
        if (mm_unit == "1") {
          mm_convert = mm * 1;
        } else if (mm_unit == "2") {
          mm_convert = mm * 10;
        } else if (mm_unit == "3") {
          mm_convert = mm * 1000;
        }
        if (m_unit == "1") {
          m_convert = m * 0.000000001;
        } else if (m_unit == "2") {
          m_convert = m * 0.000001;
        } else if (m_unit == "3") {
          m_convert = m * 0.001;
        } else if (m_unit == "4") {
          m_convert = m * 1;
        } else if (m_unit == "5") {
          m_convert = m * 10;
        } else if (m_unit == "6") {
          m_convert = m * 1000;
        }
        ans1 = m_convert / mm_convert;
        ans2 = ans1 * 6.02214085774;

        param = {
          tech_ans90: m_convert,
          tech_ans91: mm_convert,
          tech_ans1: ans1,
          tech_ans2: ans2,
        };
      } else {
        param.error = "Please! Check Your Input.";
      }
    } else if (unit === "2") {
      if (!isNaN(mm) && !isNaN(nm) && mm > 0 && nm > 0) {
        if (mm_unit == "1") {
          mm_convert = mm * 1;
        } else if (mm_unit == "2") {
          mm_convert = mm * 10;
        } else if (mm_unit == "3") {
          mm_convert = mm * 1000;
        }
        if (nm_unit == "1") {
          nm_convert = nm * 1;
        } else if (nm_unit == "2") {
          nm_convert = nm * 0.001;
        } else if (nm_unit == "3") {
          nm_convert = nm * 0.000001;
        } else if (nm_unit == "4") {
          nm_convert = nm * 0.000000001;
        } else if (nm_unit == "5") {
          nm_convert = nm * 0.000000000001;
        }
        ans3 = nm_convert * mm_convert;
        ans4 = nm_convert * 6.02214085774;

        param = {
          tech_ans90: mm_convert,
          tech_ans91: nm_convert,
          tech_ans3: ans3,
          tech_ans4: ans4,
        };
      } else {
        param.error = "Please! Check Your Input.";
      }
    } else if (unit === "3") {
      if (!isNaN(m) && !isNaN(nm) && m > 0 && nm > 0) {
        if (m_unit == "1") {
          m_convert = m * 0.000000001;
        } else if (m_unit == "2") {
          m_convert = m * 0.000001;
        } else if (m_unit == "3") {
          m_convert = m * 0.001;
        } else if (m_unit == "4") {
          m_convert = m * 1;
        } else if (m_unit == "5") {
          m_convert = m * 10;
        } else if (m_unit == "6") {
          m_convert = m * 1000;
        }
        if (nm_unit == "1") {
          nm_convert = nm * 1;
        } else if (nm_unit == "2") {
          nm_convert = nm * 0.001;
        } else if (nm_unit == "3") {
          nm_convert = nm * 0.000001;
        } else if (nm_unit == "4") {
          nm_convert = nm * 0.000000001;
        } else if (nm_unit == "5") {
          nm_convert = nm * 0.000000000001;
        }
        ans5 = m_convert / nm_convert;
        ans6 = nm_convert * 6.02214085774;

        param = {
          tech_ans90: m_convert,
          tech_ans91: nm_convert,
          tech_ans5: ans5,
          tech_ans6: ans6,
        };
      } else {
        param.error = "Please! Check Your Input.";
      }
    }

    return param;
  }

  /** getCalculationActivationEnergyCalculator
   * POST: /api/calculators-lol/activation-energy-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationActivationEnergyCalculator(body) {
    let {
      tech_temperature: temperature,
      tech_rate: rate,
      tech_const: constValue,
      tech_tempUnit: tempUnit,
      tech_rateUnits: rateUnits,
      tech_constUnits: constUnits,
    } = body;
    let input;
    temperature = Number(temperature);
    rate = Number(rate);
    constValue = Number(constValue);

    // Helper: Convert to per second
    function convertToPerSecond(value, unit) {
      if (unit === "sec") {
        input = value;
      } else if (unit === "min") {
        input = value * 60;
      } else if (unit === "hour") {
        input = value * 3600;
      } else if (unit === "day") {
        input = value * 86400;
      } else if (unit === "week") {
        input = value * 86400 * 7;
      } else if (unit === "month") {
        input = value * (30 * 86400);
      } else if (unit === "year") {
        input = value * (365.25 * 24 * 3600);
      }
      return input;
    }

    let param = {};

    if (!isNaN(temperature) && !isNaN(rate) && !isNaN(constValue)) {
      // Temperature conversion to Kelvin
      if (tempUnit === "fahrenheit") {
        temperature = ((temperature - 32) * 5) / 9 + 273.15;
      } else if (tempUnit === "celsius") {
        temperature = temperature + 273.15;
      }

      // Convert rate and const to per second
      rate = convertToPerSecond(rate, rateUnits);
      constValue = convertToPerSecond(constValue, constUnits);

      // Calculate activation energy
      let x = -0.008314 * temperature;
      let log = Math.log(rate / constValue);
      let res = x * log;

      let joule = res * 1000;
      let megajoule = res * 0.001;
      let calories = res * 239;
      let kilocalories = res * 0.239;

      param = {
        tech_temperature: temperature,
        tech_log: log,
        tech_rate: rate,
        tech_const: constValue,
        tech_res: res,
        tech_joule: joule,
        tech_megajoule: megajoule,
        tech_calories: calories,
        tech_kilocalories: kilocalories,
      };
    } else {
      param.error = "Please! Check Your Input.";
    }

    return param;
  }

  /** getCalculationMmolLToMgDlCalculator
   * POST: /api/calculators-lol/mmol-l-to-mg-dl-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMmolLToMgDlCalculator(body) {
    let { tech_solve: solve, tech_input: input } = body;

    input = Number(input);

    if (!isNaN(input)) {
      let answer;

      if (solve === "1") {
        answer = input * 18;
      } else {
        answer = input / 18;
      }

      return {
        tech_answer: answer,
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /** getCalculationCFUCalculator
   * POST: /api/calculators-lol/cfu-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCFUCalculator(body) {
    let {
      tech_nc: nc,
      tech_df: df,
      tech_volume: volume,
      tech_volume_units: volume_units,
    } = body;

    nc = Number(nc);
    df = Number(df);
    volume = Number(volume);

    if (!isNaN(nc) && !isNaN(df) && !isNaN(volume)) {
      if (volume_units) {
        if (volume_units === "mm³") {
          volume *= 0.000000001;
        } else if (volume_units === "cm³") {
          volume *= 0.000001;
        } else if (volume_units === "dm³") {
          volume *= 0.001;
        } else if (volume_units === "cu in") {
          volume *= 0.000016387;
        } else if (volume_units === "cu ft") {
          volume *= 0.028317;
        } else if (volume_units === "cu yd") {
          volume *= 0.7646;
        } else if (volume_units === "ml") {
          volume *= 0.000001;
        } else if (volume_units === "cl") {
          volume *= 0.00001;
        } else if (volume_units === "l") {
          volume *= 0.001;
        }
      }

      const res = nc * df;
      const cfu = res / volume;

      return {
        tech_nc: nc,
        tech_df: df,
        tech_volume: volume,
        tech_res: res,
        tech_cfu: cfu,
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /** getCalculationMlToMolesCalculator
   * POST: /api/calculators-lol/ml-to-moles-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMlToMolesCalculator(body) {
    let {
      tech_volume: volume,
      tech_volume_unit: volume_unit,
      tech_molarity: molarity,
      tech_molarity_unit: molarity_unit,
    } = body;

    volume = Number(volume);
    molarity = Number(molarity);
    let vol_u, mol_u, answer;
    // Convert unit names to identifiers
    if (volume_unit == "mL") {
      volume_unit = "1";
    } else if (volume_unit == "L") {
      volume_unit = "2";
    } else if (volume_unit == "uL") {
      volume_unit = "3";
    }

    if (molarity_unit == "M") {
      molarity_unit = "1";
    } else if (molarity_unit == "mM") {
      molarity_unit = "2";
    } else if (molarity_unit == "uM") {
      molarity_unit = "3";
    }

    // Unit conversion functions
    function volume_units(a, b) {
      if (b == "1") {
        vol_u = a / 1000;
      } else if (b == "2") {
        vol_u = a * 1;
      } else if (b == "3") {
        vol_u = a * 0.000001;
      }
      return vol_u;
    }
    function molarity_units(a, b) {
      if (b == "1") {
        mol_u = a * 1;
      } else if (b == "2") {
        mol_u = a / 1000;
      } else if (b == "3") {
        mol_u = a / 1000000;
      }
      return mol_u;
    }

    if (!isNaN(volume) && !isNaN(molarity)) {
      volume = volume_units(volume, volume_unit);
      molarity = molarity_units(molarity, molarity_unit);
      answer = volume * molarity;
      return {
        tech_answer: answer,
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /** getCalculationSTPCalculator
   * POST: /api/calculators-lol/stp-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSTPCalculator(body) {
    let {
      tech_volume: volume,
      tech_volume_units: volume_units,
      tech_temp: temp,
      tech_temp_units: temp_units,
      tech_pressure: pressure,
      tech_pressure_units: pressure_units,
    } = body;

    volume = Number(volume);
    temp = Number(temp);
    pressure = Number(pressure);

    if (!isNaN(volume) && !isNaN(temp) && !isNaN(pressure)) {
      // Volume unit conversion to dm³
      const volumeConversions = {
        "mm³": volume * 0.000001,
        "cm³": volume * 0.001,
        "dm³": volume * 1,
        "m³": volume * 1000,
        "cu in": volume * 0.016387,
        "cu ft": volume * 28.317,
        "cu yd": volume * 764.6,
        ml: volume * 0.001,
        cl: volume * 0.01,
      };
      if (volume_units in volumeConversions)
        volume = volumeConversions[volume_units];

      // Temperature conversion to Kelvin
      if (temp_units === "°F") {
        temp = ((temp - 32) * 5) / 9 + 273.15;
      } else if (temp_units === "°C") {
        temp += 273.15;
      }

      // Pressure conversion to mmHg
      const pressureConversions = {
        Pa: pressure * 0.0075,
        bar: pressure * 750,
        psi: pressure * 51.71,
        at: pressure * 735.6,
        atm: pressure * 760,
        hPa: pressure * 0.75,
        kPa: pressure * 7.5,
        MPa: pressure * 7500,
        GPa: pressure * 7500617,
        inHg: pressure * 25.4,
        mmHg: pressure,
      };
      if (pressure_units in pressureConversions)
        pressure = pressureConversions[pressure_units];

      // STP Calculations
      let t = 273.15 / temp;
      let v = volume * t;
      let p = pressure / 760;
      let vstp = v * p;
      let moles = vstp / 22.4;

      return {
        tech_vstp: vstp,
        tech_moles: moles,
        tech_volume: volume,
        tech_temp: temp,
        tech_pressure: pressure,
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /** getCalculationStoichiometryCalculator
   * POST: /api/calculators-lol/stoichiometry-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationStoichiometryCalculator(body) {
    let { tech_eq: eq } = body;
    eq = String(eq).trim();

    // Input validation
    const invalidPattern = /<|>|&|php|print_r|print|echo|script|%/i;
    if (invalidPattern.test(eq)) {
      return { error: "Please Enter Valid Input." };
    }

    if (!eq) {
      return { error: "Please! Check Your Input." };
    }

    try {
      let parem = eq
        .replace(/\s+/g, "")
        .replace(/%20/g, "")
        .replace(/\+/g, "plus")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**")
        .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

      let [r, p] = parem.split("=");
      let option = 2;

      const formData = qs.stringify({ r, p });

      const response = await axios.post(
        "http://167.172.134.148/stoichiometry",
        formData,
        {
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
          },
          timeout: 120000,
        }
      );

      const result = response.data.split("@@@");
      let inp = parem.replace(/plus/g, "+");

      return {
        tech_inp: inp,
        tech_be: result[0],
        tech_mols: result[1],
        tech_atoms: result[2],
        tech_chemical_equation: eq,
        tech_option: option,
      };
    } catch (err) {
      console.error(err.message);
      return { error: "Please enter any one value." };
    }
  }

  /** getCalculationEmpiricalFormulaCalculator
   * POST: /api/calculators-lol/empirical-formula-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationEmpiricalFormulaCalculator(body) {
    let e1 = body.tech_e1;
    let e2 = body.tech_e2;
    let e3 = body.tech_e3;
    let e4 = body.tech_e4;
    let e5 = body.tech_e5;
    let e6 = body.tech_e6;
    let m1 = body.tech_m1;
    let m2 = body.tech_m2;
    let m3 = body.tech_m3;
    let m4 = body.tech_m4;
    let m5 = body.tech_m5;
    let m6 = body.tech_m6;

    let periodicValues = {
      H: 1.008,
      He: 4.0026,
      Li: 6.94,
      Be: 9.0122,
      B: 10.81,
      C: 12.011,
      N: 14.007,
      O: 15.999,
      F: 18.998,
      Ne: 20.18,
      Na: 22.99,
      Mg: 24.305,
      Al: 26.982,
      Si: 28.085,
      P: 30.974,
      S: 32.06,
      Cl: 35.45,
      Ar: 39.948,
      K: 39.098,
      Ca: 40.078,
      Sc: 44.956,
      Ti: 47.867,
      V: 50.942,
      Cr: 51.996,
      Mn: 54.938,
      Fe: 55.845,
      Co: 58.933,
      Ni: 58.693,
      Cu: 63.546,
      Zn: 65.38,
      Ga: 69.723,
      Ge: 72.63,
      As: 74.922,
      Se: 78.971,
      Br: 79.904,
      Kr: 83.798,
      Rb: 85.468,
      Sr: 87.62,
      Y: 88.906,
      Zr: 91.224,
      Nb: 92.906,
      Mo: 95.95,
      Tc: 98,
      Ru: 101.07,
      Rh: 102.91,
      Pd: 106.42,
      Ag: 107.87,
      Cd: 112.41,
      In: 114.82,
      Sn: 118.71,
      Sb: 121.76,
      Te: 127.6,
      I: 126.9,
      Xe: 131.29,
      Cs: 132.91,
      Ba: 137.33,
      La: 138.91,
      Ce: 140.12,
      Pr: 140.91,
      Nd: 144.24,
      Pm: 145,
      Sm: 150.36,
      Eu: 151.96,
      Gd: 157.25,
      Tb: 158.93,
      Dy: 162.5,
      Ho: 164.93,
      Er: 167.26,
      Tm: 168.93,
      Yb: 173.05,
      Lu: 174.97,
      Hf: 178.49,
      Ta: 180.95,
      W: 183.84,
      Re: 186.21,
      Os: 190.23,
      Ir: 192.22,
      Pt: 195.08,
      Au: 196.97,
      Hg: 200.59,
      Tl: 204.38,
      Pb: 207.2,
      Bi: 208.98,
      Po: 209,
      At: 210,
      Rn: 222,
      Fr: 223,
      Ra: 226,
      Ac: 227,
      Th: 232.04,
      Pa: 231.04,
      U: 238.03,
      Np: 237,
      Pu: 244,
      Am: 243,
      Cm: 247,
      Bk: 247,
      Cf: 251,
      Es: 252,
      Fm: 257,
      Md: 258,
      No: 259,
      Lr: 266,
      Rf: 267,
      Db: 268,
      Sg: 269,
      Bh: 270,
      Hs: 277,
      Mt: 278,
      Ds: 281,
      Rg: 282,
      Cn: 285,
      Nh: 286,
      Fl: 289,
      Mc: 290,
      Lv: 293,
      Ts: 294,
      Og: 294,
    };

    let param = {};
    let check = true;
    let values = [];

    for (let i = 1; i <= 6; i++) {
      let e = body[`tech_e${i}`];
      let m = body[`tech_m${i}`];

      if (e && !isNaN(m)) {
        e = String(e).trim();
        values.push(`${e}-${m}`);
      } else if ((e && isNaN(m)) || (!e && m)) {
        check = false;
      }
    }

    let moles = [],
      s1 = "",
      s2 = "",
      s3 = "",
      s4 = "",
      s5 = "",
      s6 = "",
      res = [];

    if (check && values.length) {
      for (let val of values) {
        let [symbol, mass] = val.split("-");
        let el =
          symbol.trim().charAt(0).toUpperCase() +
          symbol.trim().slice(1).toLowerCase();

        s1 += `<td class='border-b p-2 text-[18px]'> ${el} </td>`;
        param.tech_s1 = s1;

        if (periodicValues[el]) {
          let mol = Number(mass) / periodicValues[el];
          moles.push(mol);
          s2 += `<td class='border-b p-2 text-[18px]'> ${mass}g </td>`;
          s3 += `<td class='border-b p-2 text-[22px]'>\\( \\frac {${mass}}{${periodicValues[el]}} \\)</td>`;
          param.tech_s2 = s2;
          param.tech_s3 = s3;
        } else {
          return { error: "Please! Check Your Input" };
        }
      }

      let minVal = Math.min(...moles);

      moles.forEach((mol, idx) => {
        let rounded = Math.round(mol);
        let ratio = Math.round(mol / minVal);
        s4 += `<td class='border-b p-2 text-[18px]'> ${rounded} </td>`;
        s5 += `<td class='border-b p-2 text-[22px]'>\\( \\frac {${rounded}}{${Math.round(
          minVal
        )}} \\)</td>`;
        s6 += `<td class='border-b p-2 text-[18px]'>${ratio}</td>`;
        res.push(ratio === 1 ? "" : ratio);
      });

      param.tech_s4 = s4;
      param.tech_s5 = s5;
      param.tech_s6 = s6;

      let formula = values
        .map((val, idx) => {
          let el = val.split("-")[0];
          let sym =
            el.trim().charAt(0).toUpperCase() +
            el.trim().slice(1).toLowerCase();
          return `${sym}<sub class='text-green'>${res[idx]}</sub>`;
        })
        .join("");

      param.tech_formula = formula;
      param.tech_count = values.length;
      return param;
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationPercentYieldCalculator
   * POST: /api/calculators-lol/percent-yield-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPercentYieldCalculator(body) {
    let method = body.tech_method;
    let x = body.tech_x;
    let y = body.tech_y;
    let z = body.tech_z;
    let unit_x = body.tech_unit_x;
    let unit_y = body.tech_unit_y;

    let result = {};

    // Convert unit values
    function convertToGrams(value, unit) {
      if (unit === "µg") return value / 1e6;
      if (unit === "mg") return value / 1000;
      if (unit === "kg") return value * 1000;
      if (unit === "lbs") return value * 454;
      return value;
    }

    if (method === "1") {
      if (!isNaN(x) && !isNaN(y)) {
        let actual = convertToGrams(parseFloat(y), unit_y);
        let ther = convertToGrams(parseFloat(x), unit_x);
        let ans = Math.round((actual / ther) * 100 * 100) / 100;
        result.tech_ans = ans;
      } else {
        result.error = "Please Fill All Fields.";
      }
    }

    if (method === "2") {
      if (!isNaN(z) && !isNaN(y)) {
        let actual = convertToGrams(parseFloat(y), unit_y);
        let ans = Math.round((actual / parseFloat(z)) * 100 * 100) / 100;
        result.tech_ans = ans;
      } else {
        result.error = "Please Fill All Fields.";
      }
    }

    if (method === "3") {
      if (!isNaN(z) && !isNaN(y)) {
        let actual = convertToGrams(parseFloat(y), unit_y);
        let ans = Math.round(((actual * parseFloat(z)) / 100) * 100) / 100;
        result.tech_ans = ans;
      } else {
        result.error = "Please Fill All Fields.";
      }
    }

    return result;
  }

  /** getCalculationPowerToWeightRatioCalculator
   * POST: /api/calculators-lol/power-to-weight-ratio-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPowerToWeightRatioCalculator(body) {
    let power = body.tech_power;
    let power_unit = body.tech_power_unit;
    let weight = body.tech_weight;
    let weight_unit = body.tech_weight_unit;

    let convert, convert2;
    function convert_power(a, b) {
      if ((a = "w")) {
        convert = b * 0.001;
      } else if ((a = "kw")) {
        convert = b * 1;
      } else if ((a = "hpl")) {
        convert = b * 0.7457;
      } else if ((a = "hpm")) {
        convert = b * 0.7355;
      } else if ((a = "js")) {
        convert = b * 0.001;
      } else if ((a = "kjs")) {
        convert = b * 1;
      } else if ((a = "nms")) {
        convert = b * 0.001;
      }
      return convert;
    }
    function convert_weight(c, d) {
      if (c == "kg") {
        convert2 = d * 1;
      } else if ((c = "g")) {
        convert2 = d * 0.001;
      } else if ((c = "t")) {
        convert2 = d * 1000;
      } else if ((c = "lb")) {
        convert2 = d * 0.4536;
      } else if ((c = "oz")) {
        convert2 = d * 0.02835;
      } else if ((c = "us")) {
        convert2 = d * 907.2;
      } else if ((c = "long")) {
        convert2 = d * 1016;
      } else if ((c = "mg")) {
        convert2 = d * 0.000001;
      } else if (c == "gr") {
        convert2 = d * 0.00006479891;
      }
      return convert2;
    }

    let result = {};

    if (!isNaN(power) && !isNaN(weight)) {
      let powerValue = convert_power(power_unit, power);
      let weightValue = convert_weight(weight_unit, weight);
      let ratio = powerValue / weightValue;

      result.tech_answer = ratio;
    } else {
      result.error = "Please fill all fields.";
    }

    return result;
  }

  /** getCalculationConstantOfProportionalityCalculator
   * POST: /api/calculators-lol/constant-of-proportionality-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationConstantOfProportionalityCalculator(body) {
    let y = typeof body.tech_y === "string" ? body.tech_y.trim() : body.tech_y;
    let x = typeof body.tech_x === "string" ? body.tech_x.trim() : body.tech_x;

    let result = {};

    if (!isNaN(y) && !isNaN(x)) {
      let answer = parseFloat(y) / parseFloat(x);
      result.tech_ans = parseFloat(answer.toFixed(5));
      result.tech_x = x;
      result.tech_y = y;
    } else {
      result.error = "Please fill all fields.";
    }

    return result;
  }

  /** getCalculationQuantmNumberCalculator
   * POST: /api/calculators-lol/quantum-number-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationQuantmNumberCalculator(body) {
    let type = body.tech_type;
    let value = parseInt(body.tech_value);
    let result = {};

    if (type === "principal") {
      if (!isNaN(value)) {
        let angular_momentum = "";
        for (let i = 0; i < value; i++) {
          angular_momentum += i.toString();
        }

        let table = `<table class='w-full text-[18px]'><tr><td class='py-2 border-b'><strong>Principal quantum number (𝑛)</strong></td><td class='py-2 border-b'><strong>Angular momentum quantum number (𝑙)</strong></td><td class='py-2 border-b'><strong>Magnetic quantum number (𝘮ₗ)</strong></td></tr>`;

        for (let i = 0; i < value; i++) {
          let inner = -i;
          for (let j = inner; j <= i; j++) {
            table += `<tr><td class="py-2 border-b">${value}</td><td class="py-2 border-b">${i}</td><td class="py-2 border-b">${j}</td></tr>`;
          }
        }

        table += "</table>";

        result.tech_table = table;
        result.tech_angular_momentum = angular_momentum;
        result.tech_value = value;
      } else {
        return { error: "Please fill all fields." };
      }
    } else if (type === "angular") {
      if (!isNaN(value)) {
        let resultString = "";
        for (let j = -value; j <= value; j++) {
          resultString += "," + j;
        }
        let magnetic = resultString.replace(/^,/, "");
        let num_orbital = 2 * value + 1;

        result.tech_magnetic = magnetic;
        result.tech_num_orbital = num_orbital;
      } else {
        return { error: "Please fill all fields." };
      }
    } else {
      return { error: "Please fill all fields." };
    }

    result.tech_type = type;
    return result;
  }

  /** getCalculationCcTohpCalculator
   * POST: /api/calculators-lol/cc-to-hp-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCcTohpCalculator(body) {
    let solve = body.tech_solve;
    let input = parseFloat(body.tech_input);
    let result = {};

    if (!isNaN(input)) {
      let answer;

      if (solve === "1") {
        // cc to hp
        answer = input / 15;
      } else {
        // hp to cc
        answer = input * 15;
      }

      result.tech_answer = answer;
    } else {
      result.error = "Please fill all fields.";
    }

    return result;
  }

  /** getCalculationCombinationCalculator
   * POST: /api/calculators-lol/combination-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCombinationCalculator(body) {
    const result = {};

    try {
      let n = BigInt(body.tech_n);
      let r = BigInt(body.tech_r);

      if (n > 999999n) {
        result.error = "n must be less than or equal to 999999";
        return result;
      }

      if (n < r) {
        result.error = "n must be greater than r";
        return result;
      }
      function factorial(n) {
        let result = 1n;
        for (let i = 2n; i <= n; i++) {
          result *= i;
        }
        return result;
      }
      const nMinusR = n - r;

      const factn = factorial(n);
      const factr = factorial(r);
      const factnr = factorial(nMinusR);

      const rnr = factr * factnr;
      const answer = factn / rnr;

      // Manually build all responses with string-safe versions
      result["tech_resans"] = answer.toString();
      result[
        "tech_step2res"
      ] = `= ${n.toString()}! / (${r.toString()}!(${nMinusR.toString()})!)`;
      result[
        "tech_step3res"
      ] = `= ${n.toString()}! / ${r.toString()}! x ${nMinusR.toString()}!`;
      result["tech_nans"] = n.toString();
      result["tech_rans"] = r.toString();

      return result;
    } catch (err) {
      return {
        error: "Invalid input or internal error.",
        details: err.message,
      };
    }
  }

  /** getCalculationCentralLimittheoremCalculator
   * POST: /api/calculators-lol/central-limit-theorem-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCentralLimittheoremCalculator(body) {
    const result = {};

    let u = parseFloat(body.tech_u);
    let o = parseFloat(body.tech_o);
    let n = parseFloat(body.tech_n);

    if (!isNaN(u) && !isNaN(o) && !isNaN(n)) {
      let s1 = Math.sqrt(n);
      let s = o / s1;
      let x = u;

      result.tech_s = s;
      result.tech_x = x;
      result.tech_s1 = s1;
      result.tech_o = o;
      result.tech_n = n;
      result.tech_u = u;
      return result;
    } else {
      return {
        error: "Please! Check Your Input",
      };
    }
  }

  /** getCalculationbinomialCoefficientCalculator
   * POST: /api/calculators-lol/binomial-coefficient-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationbinomialCoefficientCalculator(body) {
    const result = {};

    let n = parseInt(body.tech_n);
    let k = parseInt(body.tech_k);

    if (isNaN(n) || isNaN(k)) {
      return { error: "Please! Check Your Input" };
    }

    if (k > n) {
      return { error: "n must be larger than or equal to k" };
    }

    function factorial(x) {
      if (x <= 1) return 1n;
      let fact = 1n;
      for (let i = 2n; i <= BigInt(x); i++) {
        fact *= i;
      }
      return fact;
    }

    try {
      let nFact = factorial(n);
      let kFact = factorial(k);
      let nkFact = factorial(n - k);

      let ans = nFact / (kFact * nkFact);
      result.tech_ans = ans.toString();
      return result;
    } catch (err) {
      return { error: "Please! Try a small number" };
    }
  }

  /** getCalculationRowScoreCalculator
   * POST: /api/calculators-lol/raw-score-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRowScoreCalculator(body) {
    const result = {};

    let mean = parseFloat(body.tech_mean);
    let standardDeviation = parseFloat(body.tech_standard_daviation);
    let zScore = parseFloat(body.tech_z_score);
    let type = body.tech_type?.toString().trim();

    if (isNaN(mean) || isNaN(standardDeviation) || isNaN(zScore)) {
      return { error: "Please! Check Your Input" };
    }

    let res = mean + zScore * standardDeviation;

    result.tech_mean = mean;
    result.tech_standard_daviation = standardDeviation;
    result.tech_z_score = zScore;
    result.tech_res = res;
    result.tech_type = type;

    return result;
  }

  /** getCalculationEmpiricalProbabilityCalculator
   * POST: /api/calculators-lol/empirical-probability-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationEmpiricalProbabilityCalculator(body) {
    const result = {};

    let first = parseFloat(body.tech_first);
    let second = parseFloat(body.tech_second);

    if (isNaN(first) || isNaN(second) || second === 0) {
      return { error: "Please! Check Your Input" };
    }

    let answer = parseFloat((first / second).toFixed(2));

    result.tech_answer = answer;
    result.tech_first = first;
    result.tech_second = second;

    return result;
  }


    /** getCalculationRelativeRiskCalculator
   * POST: /api/calculators-lol/relative-risk-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

 async  getCalculationRelativeRiskCalculator(body) {
  const result = {};

  let e_disease = parseFloat(body.tech_e_disease);
  let e_no_disease = parseFloat(body.tech_e_no_disease);
  let c_disease = parseFloat(body.tech_c_disease);
  let c_no_disease = parseFloat(body.tech_c_no_disease);
  let confidenceLevel = body.tech_confidenceLevel; // Optional, not used in this logic
  let z_score = body.tech_z_score; // Optional, not used in this logic

  if (
    isNaN(e_disease) ||
    isNaN(e_no_disease) ||
    isNaN(c_disease) ||
    isNaN(c_no_disease)
  ) {
    return { error: "Please! Check Your Input" };
  }

  let riskExposed = e_disease / (e_disease + e_no_disease);
  let riskControl = c_disease / (c_disease + c_no_disease);
  let relative = riskExposed / riskControl;

  result.tech_relative = relative;
  result.tech_riskExposed = riskExposed;
  result.tech_riskControl = riskControl;

  return result;
}
    /** getCalculationChiSquareCalculator
   * POST: /api/calculators-lol/chi-square-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async  getCalculationChiSquareCalculator(body) {
    const result = {};

    let observed = parseFloat(body.tech_observed);
    let expected = parseFloat(body.tech_expected);

    if (isNaN(observed) || isNaN(expected)) {
      return { error: "Please! Check Your Input" };
    }

    let chiSquared = Math.pow(observed - expected, 2) / expected;

    result.tech_chiSquared = chiSquared;
    result.tech_observed = observed;
    result.tech_expected = expected;

    return result;
  }


    /** getCalculationPHapCalculator
   * POST: /api/calculators-lol/p-hat-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async  getCalculationPHapCalculator(body) {
    const result = {};

    let sample_size = parseFloat(body.tech_sample_size);
    let occurrences = parseFloat(body.tech_occurrences);

    if (isNaN(sample_size) || isNaN(occurrences)) {
      return { error: "Please! Check Your Input" };
    }

    let p_hat = occurrences / sample_size;

    result.tech_p_hat = p_hat;
    result.tech_sample_size = sample_size;
    result.tech_occurrences = occurrences;

    return result;
  }

      /** getCalculationStandardErrorCalculator
   * POST: /api/calculators-lol/standard-error-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async  getCalculationStandardErrorCalculator(body) {
    let form = body.tech_form;
    let x = body.tech_x;
    let pmvalue = body.tech_pmvalue;
    let psdvalue = body.tech_psdvalue;
    let deviation = body.tech_deviation;
    let sample = body.tech_sample;

    let param = {};

    if (form === 'raw') {
      let check = true;

      if (!x && !pmvalue && !psdvalue) {
        check = false;
      }

      if (x) {
        x = x.replace(/[\s,\n\r]+/g, ',');
        while (x.includes(',,')) {
          x = x.replace(',,', ',');
        }

        let numbers = x.split(',').map(s => s.trim()).filter(s => s !== '');

        for (let val of numbers) {
          if (isNaN(val)) {
            check = false;
            break;
          }
        }

        if (check) {
          numbers = numbers.map(Number);
          let count = numbers.length;
          let sum = numbers.reduce((a, b) => a + b, 0);
          let mean = sum / count;

          let arr1 = [];
          let v = '', v1 = '', v3 = '';

          for (let i = 0; i < numbers.length; i++) {
            let a = numbers[i] - mean;
            let b = Math.pow(a, 2);
            arr1.push(b);

            if (i !== numbers.length - 1) {
              v3 += ` ${b} +`;
              v1 += ` (${numbers[i]} - ${mean})² + `;
              v += ` (${a})² +`;
            } else {
              v3 += ` ${b} `;
              v1 += ` (${numbers[i]} - ${mean})² `;
              v += ` (${a})² `;
            }
          }

          let c = arr1.reduce((a, b) => a + b, 0);
          let v2 = count - 1;
          let v4 = 1 / v2;
          let v5 = v4 * c;
          let v6 = Math.sqrt(count);
          let d = Math.sqrt((1 / (count - 1)) * c);
          let e = Math.round(d * 10000) / 10000;
          let rv = Math.round(Math.sqrt(v5) * 10000) / 10000;
          let v7 = Math.round((e / v6) * 10000) / 10000;
          let se = Math.round((d / Math.sqrt(count)) * 10000) / 10000;

          param = {
            tech_count:count,
            tech_sum:sum,
            tech_mean:mean,
            tech_e:e,
            tech_se:se,
            tech_v:v,
            tech_v1:v1,
            tech_v2:v2,
            tech_v3:v3,
            tech_c:c,
            tech_v4:v4,
            tech_v5:v5,
            tech_rv:rv,
            tech_v6:v6,
            tech_v7:v7,
            tech_form:form,
          };
          return param;
        } else {
          return { error: 'Please Input Some Values.' };
        }
      }
    }

    if (form === 'summary') {
      if (!isNaN(deviation) && !isNaN(sample)) {
        let sn = Math.round(Math.sqrt(sample) * 10000) / 10000;
        let se = Math.round((deviation / sn) * 10000) / 10000;

        param = {
          tech_se:se,
          tech_sn:sn,
          tech_form:form,
        };
        return param;
      } else {
        return { error: 'Please! Check Your Input' };
      }
    }
  }

      /** getCalculationEmpiricalRuleCalculator
   * POST: /api/calculators-lol/empirical-rule-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationEmpiricalRuleCalculator(body) {
      let form = body.tech_form;
      let mean = body.tech_mean;
      let deviation = body.tech_deviation;
      let x = body.tech_x;
      let type_r = body.tech_type_r;

      let param = {};

      if (form === 'summary') {
        if (!isNaN(mean) && !isNaN(deviation)) {
          let first = `${(mean - deviation).toFixed(2)} & ${(mean + deviation).toFixed(2)}`;
          let second = `${(mean - 2 * deviation).toFixed(2)} & ${(mean + 2 * deviation).toFixed(2)}`;
          let third = `${(mean - 3 * deviation).toFixed(2)} & ${(mean + 3 * deviation).toFixed(2)}`;

          param = {
            tech_mean:mean,
            tech_devi: deviation,
            tech_first:first,
            tech_second:second,
            tech_third:third
          };
          return param;
        } else {
          return { error: "Please Fill All Fields" };
        }
      } else {
        if (x && typeof x === 'string') {
          let array = x.split(',').map(s => s.trim()).filter(s => s !== '');
          let numberCheck = array.every(val => !isNaN(val));
          let count = array.length;

          if (numberCheck) {
            let numbers = array.map(Number);
            let sum = numbers.reduce((a, b) => a + b, 0);
            let meanVal = parseFloat((sum / count).toFixed(3));

            let d = 0;
            for (let val of numbers) {
              d += Math.pow(val - meanVal, 2);
            }

            let devi;
            if (type_r === '2') {
              devi = parseFloat(Math.sqrt((1 / count) * d).toFixed(4));
            } else {
              devi = parseFloat(Math.sqrt((1 / (count - 1)) * d).toFixed(4));
            }

            let first = `${(meanVal - devi).toFixed(2)} & ${(meanVal + devi).toFixed(2)}`;
            let second = `${(meanVal - 2 * devi).toFixed(2)} & ${(meanVal + 2 * devi).toFixed(2)}`;
            let third = `${(meanVal - 3 * devi).toFixed(2)} & ${(meanVal + 3 * devi).toFixed(2)}`;

            param = {
              tech_count:count,
              tech_mean: meanVal,
              tech_devi:devi,
              tech_first:first,
              tech_second:second,
              tech_third:third
            };
            return param;
          } else {
            return { error: "Please Fill All Fields" };
          }
        } else {
          return { error: "Please Fill All Fields" };
        }
      }
    }

      /** getCalculationExpectedValueCalculator
   * POST: /api/calculators-lol/expected-value-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
 
      async  getCalculationExpectedValueCalculator(body) {
      let check = body.tech_check;
      let param = {};

      if (check === 'txtar') {
        let xx = body.tech_xx;
        let px = body.tech_px;

        let valid = true;

        if (!Array.isArray(xx) || !Array.isArray(px) || xx.length === 0 || px.length === 0) {
          valid = false;
        }

        if (valid) {
          for (let val of xx) {
            if (isNaN(val)) valid = false;
          }
          for (let val of px) {
            if (isNaN(val)) valid = false;
          }
        }

        if (!valid) {
          return { error: "Please fill all fields." };
        }

        let n = xx.length;
        let n1 = px.length;
        let pxSum = parseFloat(px.reduce((a, b) => a + parseFloat(b), 0).toFixed(1));

        if (n !== n1) {
          return { error: "X and P(X) must have same number of elements." };
        }
        if (pxSum !== 1) {
          return { error: "The sum of P(X) must be 1." };
        }

        let res = [];
        let show_res = '';
        let show_res1 = '';
        let txt = [];

        for (let i = 0; i < n; i++) {
          let val = parseFloat(xx[i]);
          let val1 = parseFloat(px[i]);
          let product = val * val1;
          res.push(product);

          let plus = i + 1 === n ? '' : '+';
          show_res += `( ${val} ) * ( ${val1} )${plus}`;
          show_res1 += `( ${product} )${plus}`;

          txt[i] = `
            <tr class='bg-white'>
              <td class='border p-2'>${val}</td>
              <td class='border p-2'>${val1}</td>
              <td class='border p-2'>${product}</td>
            </tr>
          `;
          param['show_val' + i] = txt[i];
        }

        let sum1 = xx.reduce((a, b) => a + parseFloat(b), 0);
        let sum2 = px.reduce((a, b) => a + parseFloat(b), 0);
        let ress = res.reduce((a, b) => a + b, 0);

        param['tech_show_res'] = show_res;
        param['tech_show_res1'] = show_res1;
        param['tech_sum1'] = sum1;
        param['tech_sum2'] = sum2;
        param['tech_ress'] = ress;

        return param;

      } else if (check === 'table') {
        let td_value = parseInt(body.tech_td_value);
        let numbers = [];
        let numbers1 = [];

        for (let i = 1; i < td_value; i++) {
          let aKey = `a${i}`;
          let bKey = `b${i}`;
          let aVal = parseFloat(body[aKey]);
          let bVal = parseFloat(body[bKey]);

          if (!isNaN(aVal)) numbers.push(aVal);
          if (!isNaN(bVal)) numbers1.push(bVal);
        }

        let n = numbers.length;
        let n1 = numbers1.length;

        if (n !== n1) {
          return { error: "X and P(X) must have same number of elements." };
        }

        let pxSum = numbers1.reduce((a, b) => a + b, 0);
        if (pxSum !== 1) {
          return { error: "The sum of P(X) must be 1." };
        }

        let res = [];
        let show_res = '';
        let show_res1 = '';
        let txt = [];

        for (let i = 0; i < n; i++) {
          let val = numbers[i];
          let val1 = numbers1[i];
          let product = val * val1;
          res.push(product);

          let plus = i + 1 === n ? '' : '+';
          show_res += `( ${val} ) * ( ${val1} )${plus}`;
          show_res1 += `( ${product} )${plus}`;

          txt[i] = `
            <tr class='bg-white'>
              <td class='border p-2'>${val}</td>
              <td class='border p-2'>${val1}</td>
              <td class='border p-2'>${product}</td>
            </tr>
          `;
          param['show_val' + i] = txt[i];
        }

        let sum1 = numbers.reduce((a, b) => a + b, 0);
        let sum2 = numbers1.reduce((a, b) => a + b, 0);
        let ress = res.reduce((a, b) => a + b, 0);

        param['tech_show_res'] = show_res;
        param['tech_show_res1'] = show_res1;
        param['tech_sum1'] = sum1;
        param['tech_sum2'] = sum2;
        param['tech_ress'] = ress;

        return param;
      } else {
        return { error: "Please fill all fields." };
      }
       }


     /** getCalculationMadCalculator
   * POST: /api/calculators-lol/mad-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
 
    async  getCalculationMadCalculator(body) {
      let x = body.tech_x;
      let method = parseInt(body.tech_method);
      let m = parseFloat(body.tech_m);
      let data = [];
      let response = {};

      if (x) {
          x = x.replace(/[\s,\n\r]+/g, ','); // Normalize to single commas
          while (x.includes(',,'))
              x = x.replace(',,', ',');
          data = x.split(',').map(s => s.trim()).filter(s => s !== '');

          if (!data.every(v => !isNaN(v))) {
              response.error = "Please! Check Your Input";
              return response;
          }

          data = data.map(Number);
          response.tech_x = x;
          response.tech_m = m;

          if (method === 0) {
              let sum = data.reduce((a, b) => a + b, 0);
              let n = data.length;
              let mean = sum / n;
              let diff = data.map(v => Math.abs(mean - v));
              let sum1 = diff.reduce((a, b) => a + b, 0);
              let mad = sum1 / n;

              response.tech_n = n;
              response.tech_diff = diff;
              response.tech_sum1 = sum1;
              response.tech_mean = mean;
              response.tech_method = method;
              response.tech_mad = parseFloat(mad.toFixed(1));
              return response;
          } else if (method === 1) {
              data.sort((a, b) => a - b);
              let n = data.length;
              let median = (n % 2 !== 0)
                  ? data[Math.floor(n / 2)]
                  : (data[n / 2] + data[n / 2 - 1]) / 2;

              response.tech_median = median;

              let diff = data.map(v => Math.abs(median - v));
              response.tech_diff = diff;

              diff.sort((a, b) => a - b);
              let n1 = diff.length;
              let median1 = (n1 % 2 !== 0)
                  ? diff[Math.floor(n1 / 2)]
                  : (diff[n1 / 2] + diff[n1 / 2 - 1]) / 2;

              response.tech_diff1 = diff;
              response.tech_mad = parseFloat(median1.toFixed(1));
              response.tech_method = method;
              return response;
          } else {
              let n = data.length;
              let diff = data.map(v => Math.abs(m - v));
              let sum = diff.reduce((a, b) => a + b, 0);
              let mad = sum / n;

              response.tech_diff = diff;
              response.tech_sum = sum;
              response.tech_mad = parseFloat(mad.toFixed(1));
              response.tech_method = method;
              return response;
          }
      } else {
          response.error = "Please! Check Your Input";
          return response;
      }
  }


     /** getCalculationPermutationCalculator
   * POST: /api/calculators-lol/permutation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationPermutationCalculator(body) {
        let n = parseInt(body.tech_n);
        let r = parseInt(body.tech_r);
        let find = body.tech_find;

        let response = {};

        if (!isNaN(n) && !isNaN(r)) {
            response.tech_n = n;
            response.tech_r = r;
            response.tech_find = find;

            if (r <= n) {
                let n_fact = factorial(n);
                let r_fact = factorial(r);
                let nr = n - r;
                let nr_fact = factorial(nr);
                let nr_fact_prod = r_fact * nr_fact;

                let nr1 = n + r - 1;
                let nr1_fact = factorial(nr1);
                let n1 = n - 1;
                let n1_fact = factorial(n1);
                let nr1_fact_prod = r_fact * n1_fact;

                let comb = n_fact / nr_fact_prod;
                let perm = n_fact / nr_fact;
                let comb_rep = nr1_fact / nr1_fact_prod;
                let perm_rep = Math.pow(n, r);

                if (find === '2') {
                    response.tech_perms = "perms";
                } else {
                    response.tech_p_w_r = "p_w_r";
                }

                // Step 1 string
                let s1 = Array.from({ length: n }, (_, i) => i + 1).join(' * ');

                // Step 2 string
                let s2 = Array.from({ length: nr }, (_, i) => i + 1).join(' * ');

                response.tech_comb = comb;
                response.tech_perm = perm;
                response.tech_s1 = s1;
                response.tech_s2 = s2;
                response.tech_nr = nr;
                response.tech_n_fact = n_fact;
                response.tech_r_fact = r_fact;
                response.tech_nr_fact = nr_fact;
                response.tech_comb_rep = comb_rep;
                response.tech_perm_rep = perm_rep;

                if (n < 101) {
                    response.tech_show_steps = "show_steps";
                }

                return response;
            } else {
                response.error = "r needs to be less than or equal to n";
                return response;
            }
        } else {
            response.error = "Please! Check Your Input";
            return response;
        }
    }


     /** getCalculationStandardDeviationCalculator
   * POST: /api/calculators-lol/standard-deviation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationStandardDeviationCalculator(body) {
      let stdv_txt = body.tech_stdv_txt;
      let stdv_rad = body.tech_stdv_rad;

      function sanitize(input) {
          return String(input).trim().replace(/</g, "&lt;").replace(/>/g, "&gt;");
      }

      stdv_txt = sanitize(stdv_txt);
      stdv_txt = stdv_txt.replace(/\s+/g, ' ');
      stdv_rad = sanitize(stdv_rad);

      let check = true;

      if (!stdv_txt) check = false;

      stdv_txt = stdv_txt.replace(/[ ,\n\r]+/g, ',');
      while (stdv_txt.includes(",,")) stdv_txt = stdv_txt.replace(/,,/g, ',');

      let dataArr = stdv_txt.split(',').map(s => s.trim()).filter(s => s !== '').map(Number);

      for (const value of dataArr) {
          if (isNaN(value)) check = false;
      }

      if (dataArr.length < 2) check = false;

      if (!check) {
          return { error: "Please! Check Your Input" };
      }

      const n = dataArr.length;
      const sum = dataArr.reduce((a, b) => a + b, 0);
      const mean = parseFloat((sum / n).toFixed(3));

      let sumSquaredDiff = 0;
      for (const value of dataArr) {
          sumSquaredDiff += Math.pow(value - mean, 2);
      }

      const mSym = stdv_rad === "population" ? "μ" : "x̄";
      const divisor = stdv_rad === "population" ? n : n - 1;
      const stdDev = parseFloat(Math.sqrt(sumSquaredDiff / divisor).toFixed(4));

      const variance = parseFloat(Math.pow(stdDev, 2).toFixed(2));
      const coefOfVar = parseFloat((stdDev / mean).toFixed(4));
      const stdErr = parseFloat((stdDev / Math.sqrt(n)).toFixed(4));

      let table = `<table class='w-full text-[18px]' style='border-collapse: collapse'><thead><tr class='bg-gray-100'><th class='border p-2 text-center text-blue'>xᵢ</th><th class='border p-2 text-center text-blue'>xᵢ - ${mSym}</th><th class='border p-2 text-center text-blue'>(xᵢ - ${mSym})²</th></tr></thead><tbody>`;
      let sumSq = 0;
      let frequencyMap = {};

      for (const val of dataArr) {
          const diff = val - mean;
          const squared = Math.pow(diff, 2);
          table += `<tr class='bg-white'><td class='border p-2 text-center'>${val}</td><td class='border p-2 text-center'>${diff.toFixed(3)}</td><td class='border p-2 text-center'>${squared.toFixed(3)}</td></tr>`;
          sumSq += squared;
          frequencyMap[val] = (frequencyMap[val] || 0) + 1;
      }

      table += `<tr class='bg-gray-100'><th class='border p-2 text-center text-blue'>Σxᵢ = ${sum}</th><th class='p-2 border'></th><th class='border p-2 text-center text-blue'>Σ(xᵢ - ${mSym})² = ${sumSq.toFixed(3)}</th></tr></tbody></table>`;

      let tablef = '';
      for (const [key, value] of Object.entries(frequencyMap)) {
          tablef += `<tr><td class='py-2 border-b'>${key}</td><td class='py-2 border-b'>${value} (${((100 / n) * value).toFixed(2)}%)</td></tr>`;
      }

      return {
          tech_put: (n / 100) * (1 - (n / 100)),
          tech_i: n,
          tech_mor: stdErr,
          tech_d: stdDev,
          tech_m: mean,
          tech_c: coefOfVar,
          tech_t_n: n,
          tech_v_2: variance,
          tech_sum: sum,
          tech_s_e: stdErr,
          tech_table: table,
          tech_tablef: tablef,
          tech_ar_sum: sumSq.toFixed(3),
          tech_stdv_rad: stdv_rad,
      };
  }

     /** getCalculationFiveNumberSummaryCalculator
   * POST: /api/calculators-lol/5-five-number-summary-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationFiveNumberSummaryCalculator(body) {
    let seprateby = body.tech_seprateby;
    let textarea = body.tech_textarea;

    if (!textarea || textarea.trim() === "") {
      return { error: "Please! Check Your Input" };
    }

    seprateby = seprateby === "space" ? " " : seprateby;
    let values = textarea.split(seprateby).map(v => v.trim()).filter(v => v !== "");

    let isNumeric = values.every(val => !isNaN(val));
    if (!isNumeric) {
      return { error: "Please! Check Your Input" };
    }

    values = values.map(Number).sort((a, b) => a - b);

    if (values.length < 2) {
      return { error: "Please! enter 2 or more numbers" };
    }

    let count = values.length;
    let a1 = values[0];
    let a2 = values[count - 1];

    const quartile = (arr) => {
      let sorted = [...arr].sort((a, b) => a - b);
      let mid = Math.floor((sorted.length - 1) / 2);
      if (sorted.length % 2) {
        return Number(sorted[mid].toFixed(1));
      } else {
        return Number(((sorted[mid] + sorted[mid + 1]) / 2).toFixed(1));
      }
    };

    let second = quartile(values);
    let tmp = { first: [], third: [] };
    values.forEach(val => {
      if (val < second) tmp.first.push(val);
      else if (val > second) tmp.third.push(val);
    });

    let first = quartile(tmp.first);
    let third = quartile(tmp.third);
    let min = Math.min(...values);
    let max = Math.max(...values);
    let iter = third - first;
    let sum = values.reduce((acc, cur) => acc + cur, 0);
    let average = Number((sum / count).toFixed(4));

    let median;
    if (count % 2 !== 0) {
      median = values[Math.floor(count / 2)];
    } else {
      median = (values[count / 2 - 1] + values[count / 2]) / 2;
    }

    let freqMap = {};
    values.forEach(val => {
      freqMap[val] = (freqMap[val] || 0) + 1;
    });

    let maxFreq = Math.max(...Object.values(freqMap));
    let mode = Object.keys(freqMap).filter(k => freqMap[k] === maxFreq).map(Number);

    let mean = sum / count;
    let d = values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0);
    let s_d_p = Math.sqrt(d / count).toFixed(4);
    let s_d_s = Math.sqrt(d / (count - 1)).toFixed(4);

    return {
      tech_a1:a1,
      tech_a2:a2,
      tech_min:min,
      tech_max:max,
      tech_first:first,
      tech_second:second,
      tech_third:third, 
      tech_iter:iter,
      tech_mode:mode,
      tech_s_d_p:s_d_p,
      tech_s_d_s:s_d_s,
      tech_median:median,
      tech_average:average,
      tech_count:count,
      tech_numbers: values,
      tech_desc: [...values].sort((a, b) => b - a),
    };
  }

    /** getCalculationConfidenceIntervalCalculator
   * POST: /api/calculators-lol/confidence-interval-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async getCalculationConfidenceIntervalCalculator(body) {
      let x = parseFloat(body.tech_x);
      let s = parseFloat(body.tech_s);
      let n = parseFloat(body.tech_n);
      let cl = parseFloat(body.tech_cl);
      let z = parseFloat(body.tech_z);

      if (
        !isNaN(x) &&
        !isNaN(s) &&
        !isNaN(n) &&
        !isNaN(cl) &&
        !isNaN(z)
      ) {
        if (n < 1 || cl < 0 || cl > 99.99) {
          return { error: "Please! Check Your Input" };
        }

        const sigFig = (value, digits) => {
          if (value === 0) return 0;
          const d = digits - Math.floor(Math.log10(Math.abs(value))) - 1;
          return Number(value.toFixed(d));
        };

        let se = s / Math.sqrt(n);
        let moe = z * se;
        let ci1 = x - moe;
        let ci2 = x + moe;
        let ci = `${x} ± ${sigFig(moe, 4)}`;
        let rtpv = ((100 - cl) / 2) / 100;

        return {
          tech_se: sigFig(se, 5),
          tech_ci: ci,
          tech_ci1: sigFig(ci1, 4),
          tech_ci2: sigFig(ci2, 4),
          tech_lb: sigFig(ci1, 6),
          tech_ub: sigFig(ci2, 6),
          tech_moe: sigFig(moe, 5),
          tech_rtpv: rtpv,
          tech_zscore: sigFig(z, 7),
        };
      } else {
        return { error: "Please! Fill All The Fields" };
      }
    }

    /** getCalculationVarianceCalculator
   * POST: /api/calculators-lol/variance-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async getCalculationVarianceCalculator(body) {
      let cal_meth = body.tech_cal_meth;
      let set = body.tech_set;

      if (!set || !cal_meth) {
        return { error: "Please check your input." };
      }

      let check = true;
      set = set.replace(/[\n\r\s]+/g, ",").replace(/,+/g, ",");
      let setArray = set.split(",").map(v => v.trim()).filter(v => v !== "").map(Number);

      if (setArray.length < 2 || setArray.some(isNaN)) {
        return { error: "Please check your input." };
      }

      setArray.sort((a, b) => a - b);
      let array_set = [...setArray];
      let i = setArray.length;
      let sum = setArray.reduce((a, b) => a + b, 0);
      let mean = parseFloat((sum / i).toFixed(3));
      let d = setArray.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0);

      let s_d, mSym;
      if (cal_meth === "population") {
        s_d = Math.sqrt(d / i);
        mSym = "μ";
      } else {
        s_d = Math.sqrt(d / (i - 1));
        mSym = "x̄";
      }

      s_d = parseFloat(s_d.toFixed(4));
      let variance = parseFloat((s_d ** 2).toFixed(2));
      let c_v = parseFloat((s_d / mean).toFixed(4));

      // Table creation (as HTML string)
      let ss = 0;
      let table = `<table class='w-full text-[18px]' style='border-collapse: collapse'><thead><tr class='bg-gray-100'><th class='border p-2 text-center text-blue'>xᵢ</th><th class='border p-2 text-center text-blue'>xᵢ - ${mSym}</th><th class='border p-2 text-center text-blue'>(xᵢ - ${mSym})²</th></tr></thead><tbody>`;

      for (let f = 0; f < i; f++) {
        let xi = setArray[f];
        let diff = xi - mean;
        let sq = Math.pow(diff, 2);
        ss += sq;
        table += `<tr class='bg-white'><td class='border p-2 text-center'>${xi}</td><td class='border p-2 text-center'>${diff.toFixed(3)}</td><td class='border p-2 text-center'>${sq.toFixed(3)}</td></tr>`;
      }

      table += `<tr class='bg-gray-100'><th class='border p-2 text-center text-blue'>Σxᵢ = ${sum}</th><th class='border p-2'></th><th class='border p-2 text-center text-blue'>Σ(xᵢ - ${mSym})² = ${ss.toFixed(3)}</th></tr></tbody></table>`;

      return {
        tech_var: variance,
        tech_mean: mean,
        tech_s_d: s_d,
        tech_c_v: c_v,
        tech_t_n: i,
        tech_sum: sum,
        tech_table: table,
        tech_ss: parseFloat(ss.toFixed(3)),
        tech_cal_meth: cal_meth,
        tech_set: setArray,
        tech_array_set: array_set,
      };
    }

     /** getCalculationCoefficientOfDeterminationCalculator
   * POST: /api/calculators-lol/coefficient-of-determination
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async getCalculationCoefficientOfDeterminationCalculator(body) {
        let x = body.tech_x;
          let y = body.tech_y;

      // Clean and normalize the input
      x = x.replace(/[\s,\n\r]+/g, ',').replace(/,+/g, ',').trim();
      y = y.replace(/[\s,\n\r]+/g, ',').replace(/,+/g, ',').trim();

      if (!x || !y) {
        return { error: 'Please check your input.' };
      }

      let set1 = x.split(',').map(v => v.trim()).filter(v => v !== '');
      let set2 = y.split(',').map(v => v.trim()).filter(v => v !== '');

      if (set1.some(isNaN) || set2.some(isNaN) || set1.length !== set2.length) {
        return { error: 'Please check your input.' };
      }

      set1 = set1.map(Number);
      set2 = set2.map(Number);

      const n = set1.length;
      const sumx = set1.reduce((a, b) => a + b, 0);
      const sumy = set2.reduce((a, b) => a + b, 0);

      let table = `<table class='w-full text-[18px]' style='border-collapse: collapse'><thead><tr class='bg-gray-100'><th class='border p-2 text-center text-blue'>Obs.</th><th class='border p-2 text-center text-blue'>X</th><th class='border p-2 text-center text-blue'>Y</th><th class='border p-2 text-center text-blue'>Xᵢ²</th><th class='border p-2 text-center text-blue'>Yᵢ²</th><th class='border p-2 text-center text-blue'>Xᵢ⋅Yᵢ</th></tr></thead><tbody>`;

      let sumxi = 0, sumyi = 0, sumxy = 0;
      for (let i = 0; i < n; i++) {
        const xi2 = Math.pow(set1[i], 2);
        const yi2 = Math.pow(set2[i], 2);
        const xyi = set1[i] * set2[i];
        sumxi += xi2;
        sumyi += yi2;
        sumxy += xyi;

        table += `<tr class='bg-white'><td class='border p-2 text-center'>${i + 1}</td><td class='border p-2 text-center'>${set1[i]}</td><td class='border p-2 text-center'>${set2[i]}</td><td class='border p-2 text-center'>${xi2}</td><td class='border p-2 text-center'>${yi2}</td><td class='border p-2 text-center'>${xyi}</td></tr>`;
      }
      table += `<tr class='bg-gray-100'><th class='border p-2 text-center text-blue'>Sum = </th><th class='border p-2 text-center text-blue'>${sumx}</th><th class='border p-2 text-center text-blue'>${sumy}</th><th class='border p-2 text-center text-blue'>${sumxi}</th><th class='border p-2 text-center text-blue'>${sumyi}</th><th class='border p-2 text-center text-blue'>${sumxy}</th></tr></tbody></table>`;

      const sumx2 = Math.pow(sumx, 2);
      const sumy2 = Math.pow(sumy, 2);

      const ssxx = sumxi - (1 / n) * sumx2;
      const ssyy = sumyi - (1 / n) * sumy2;
      const ssxy = sumxy - (1 / n) * sumx * sumy;
      const r = ssxy / Math.sqrt(ssxx * ssyy);
      const r2 = Math.pow(r, 2);

      const meanx = sumx / n;
      const meany = sumy / n;

      let s1 = '', s2 = '', s3 = '', s_d = 0, s_d1 = 0;
      for (let i = 0; i < n; i++) {
        const dx = set1[i] - meanx;
        const dy = set2[i] - meany;

        s1 += `(${set1[i]} - ${meanx.toFixed(4)})(${set2[i]} - ${meany.toFixed(4)})` + (i < n - 1 ? ' + ' : '');
        s2 += `(${dx.toFixed(4)}*${dy.toFixed(4)})` + (i < n - 1 ? ' + ' : '');
        s3 += `(${(dx * dy).toFixed(4)})` + (i < n - 1 ? ' + ' : '');

        s_d += dx * dx;
        s_d1 += dy * dy;
      }

      const stdx = Math.sqrt(s_d / (n - 1));
      const stdy = Math.sqrt(s_d1 / (n - 1));
      const s11 = (n - 1) * stdx * stdy;

      const delta = n * sumxi - sumx2;
      const a = (n * sumxy - sumx * sumy) / delta;
      const b = (sumxi * sumy - sumx * sumxy) / delta;

      let sst = 0, sst_table = `<table class='w-full text-[18px]' style='border-collapse: collapse'><thead><tr class='bg-gray-100'><th class='border p-2 text-center text-blue'>i</th><th class='border p-2 text-center text-blue'>yᵢ</th><th class='border p-2 text-center text-blue'>ȳ</th><th class='border p-2 text-center text-blue'>(yᵢ - ȳ)²</th></tr></thead><tbody>`;
      for (let i = 0; i < n; i++) {
        const diff = Math.pow(set2[i] - meany, 2);
        sst_table += `<tr class='bg-white'><td class='border p-2 text-center'>${i}</td><td class='border p-2 text-center'>${set2[i]}</td><td class='border p-2 text-center'>${meany.toFixed(4)}</td><td class='border p-2 text-center'>${diff.toFixed(4)}</td></tr>`;
        sst += diff;
      }
      sst_table += `</tbody></table>`;

      let ssr = 0, ssr_table = `<table class='w-full text-[18px]' style='border-collapse: collapse'><thead><tr class='bg-gray-100'><th class='border p-2 text-center text-blue'>i</th><th class='border p-2 text-center text-blue'>x̂ᵢ</th><th class='border p-2 text-center text-blue'>ȳ</th><th class='border p-2 text-center text-blue'>(x̂ᵢ - ȳ)²</th></tr></thead><tbody>`;
      for (let i = 0; i < n; i++) {
        const yhat = a * set1[i] + b;
        const diff = Math.pow(yhat - meany, 2);
        ssr_table += `<tr class='bg-white'><td class='border p-2 text-center'>${i}</td><td class='border p-2 text-center'>${yhat.toFixed(4)}</td><td class='border p-2 text-center'>${meany.toFixed(4)}</td><td class='border p-2 text-center'>${diff.toFixed(4)}</td></tr>`;
        ssr += diff;
      }
      ssr_table += `</tbody></table>`;

      let sse = 0, sse_table = `<table class='w-full text-[18px]' style='border-collapse: collapse'><thead><tr class='bg-gray-100'><th class='border p-2 text-center text-blue'>i</th><th class='border p-2 text-center text-blue'>yᵢ</th><th class='border p-2 text-center text-blue'>x̂ᵢ</th><th class='border p-2 text-center text-blue'>(yᵢ - x̂ᵢ)²</th></tr></thead><tbody>`;
      for (let i = 0; i < n; i++) {
        const yhat = a * set1[i] + b;
        const diff = Math.pow(set2[i] - yhat, 2);
        sse_table += `<tr class='bg-white'><td class='border p-2 text-center'>${i}</td><td class='border p-2 text-center'>${set2[i]}</td><td class='border p-2 text-center'>${yhat.toFixed(4)}</td><td class='border p-2 text-center'>${diff.toFixed(4)}</td></tr>`;
        sse += diff;
      }
      sse_table += `</tbody></table>`;

      return {
        tech_n:n,
        tech_r: r.toFixed(4),
        tech_r2: r2.toFixed(4),
        tech_sumx: sumx.toFixed(4),
        tech_sumy: sumy.toFixed(4),
        tech_sumxi: sumxi.toFixed(4),
        tech_sumyi: sumyi.toFixed(4),
        tech_sumxy: sumxy.toFixed(4),
        tech_sumx2: sumx2.toFixed(4),
        tech_sumy2: sumy2.toFixed(4),
        tech_ssxx: ssxx.toFixed(4),
        tech_ssyy: ssyy.toFixed(4),
        tech_ssxy: ssxy.toFixed(4),
        tech_s_d: stdx.toFixed(4),
        tech_s_d1: stdy.toFixed(4),
        tech_s1:s1,
        tech_s2:s2,
        tech_s3:s3,
        tech_s11: s11.toFixed(4),
        tech_meanx: meanx.toFixed(4),
        tech_meany: meany.toFixed(4),
        tech_table:table,
        tech_sst: sst.toFixed(4),
        tech_ssr: ssr.toFixed(4),
        tech_sse: sse.toFixed(4),
        tech_a: a.toFixed(2),
        tech_b: b.toFixed(2),
        tech_sst_table:sst_table,
        tech_ssr_table:ssr_table,
        tech_sse_table:sse_table,
      };
    }

      /** getCalculationPointEstimateCalculator
   * POST: /api/calculators-lol/point-estimate
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationPointEstimateCalculator(body) {
      let success = parseFloat(body.tech_success);
      let trials = parseFloat(body.tech_trials);
      let ci = parseFloat(body.tech_ci);
      let result = {};

      if (!isNaN(success) && !isNaN(trials) && !isNaN(ci)) {
        if (success <= trials) {
          const z_table = {
            "0.0": [0.50000, 0.50399, 0.50798, 0.51197, 0.51595, 0.51994, 0.52392, 0.52790, 0.53188, 0.53586],
            "0.1": [0.53980, 0.54380, 0.54776, 0.55172, 0.55567, 0.55966, 0.56360, 0.56749, 0.57142, 0.57535],
            "0.2": [0.57930, 0.58317, 0.58706, 0.59095, 0.59483, 0.59871, 0.60257, 0.60642, 0.61026, 0.61409],
            "0.3": [0.61791, 0.62172, 0.62552, 0.62930, 0.63307, 0.63683, 0.64058, 0.64431, 0.64803, 0.65173],
            "0.4": [0.65542, 0.65910, 0.66276, 0.66640, 0.67003, 0.67364, 0.67724, 0.68082, 0.68439, 0.68793],
            "0.5": [0.69146, 0.69497, 0.69847, 0.70194, 0.70540, 0.70884, 0.71226, 0.71566, 0.71904, 0.72240],
            "0.6": [0.72575, 0.72907, 0.73237, 0.73565, 0.73891, 0.74215, 0.74537, 0.74857, 0.75175, 0.75490],
            "0.7": [0.75804, 0.76115, 0.76424, 0.76730, 0.77035, 0.77337, 0.77637, 0.77935, 0.78230, 0.78524],
            "0.8": [0.78814, 0.79103, 0.79389, 0.79673, 0.79955, 0.80234, 0.80511, 0.80785, 0.81057, 0.81327],
            "0.9": [0.81594, 0.81859, 0.82121, 0.82381, 0.82639, 0.82894, 0.83147, 0.83398, 0.83646, 0.83891],
            "1.0": [0.84134, 0.84375, 0.84614, 0.84849, 0.85083, 0.85314, 0.85543, 0.85769, 0.85993, 0.86214],
            "1.1": [0.86433, 0.86650, 0.86864, 0.87076, 0.87286, 0.87493, 0.87698, 0.87900, 0.88100, 0.88298],
            "1.2": [0.88493, 0.88686, 0.88877, 0.89065, 0.89251, 0.89435, 0.89617, 0.89796, 0.89973, 0.90147],
            "1.3": [0.90320, 0.90490, 0.90658, 0.90824, 0.90988, 0.91149, 0.91308, 0.91466, 0.91621, 0.91774],
            "1.4": [0.91924, 0.92073, 0.92220, 0.92364, 0.92507, 0.92647, 0.92785, 0.92922, 0.93056, 0.93189],
            "1.5": [0.93319, 0.93448, 0.93574, 0.93699, 0.93822, 0.93943, 0.94062, 0.94179, 0.94295, 0.94408],
            "1.6": [0.94520, 0.94630, 0.94738, 0.94845, 0.94950, 0.95053, 0.95154, 0.95254, 0.95352, 0.95449],
            "1.7": [0.95543, 0.95637, 0.95728, 0.95818, 0.95907, 0.95994, 0.96080, 0.96164, 0.96246, 0.96327],
            "1.8": [0.96407, 0.96485, 0.96562, 0.96638, 0.96712, 0.96784, 0.96856, 0.96926, 0.96995, 0.97062],
            "1.9": [0.97128, 0.97193, 0.97257, 0.97320, 0.97381, 0.97441, 0.97500, 0.97558, 0.97615, 0.97670],
            "2.0": [0.97725, 0.97778, 0.97831, 0.97882, 0.97932, 0.97982, 0.98030, 0.98077, 0.98124, 0.98169],
            '2.1': [0.98214, 0.98257, 0.98300, 0.98341, 0.98382, 0.98422, 0.98461, 0.98500, 0.98537, 0.98574],
            '2.2': [0.98610, 0.98645, 0.98679, 0.98713, 0.98745, 0.98778, 0.98809, 0.98840, 0.98870, 0.98899],
            '2.3': [0.98928, 0.98956, 0.98983, 0.99010, 0.99036, 0.99061, 0.99086, 0.99111, 0.99134, 0.99158],
            '2.4': [0.99180, 0.99202, 0.99224, 0.99245, 0.99266, 0.99286, 0.99305, 0.99324, 0.99343, 0.99361],
            '2.5': [0.99379, 0.99396, 0.99413, 0.99430, 0.99446, 0.99461, 0.99477, 0.99492, 0.99506, 0.99520],
            '2.6': [0.99534, 0.99547, 0.99560, 0.99573, 0.99585, 0.99598, 0.99609, 0.99621, 0.99632, 0.99643],
            '2.7': [0.99653, 0.99664, 0.99674, 0.99683, 0.99693, 0.99702, 0.99711, 0.99720, 0.99728, 0.99736],
            '2.8': [0.99744, 0.99752, 0.99760, 0.99767, 0.99774, 0.99781, 0.99788, 0.99795, 0.99801, 0.99807],
            '2.9': [0.99813, 0.99819, 0.99825, 0.99831, 0.99836, 0.99841, 0.99846, 0.99851, 0.99856, 0.99861],
            '3.0': [0.99865, 0.99869, 0.99874, 0.99878, 0.99882, 0.99886, 0.99889, 0.99893, 0.99896, 0.99900],
            '3.1': [0.99903, 0.99906, 0.99910, 0.99913, 0.99916, 0.99918, 0.99921, 0.99924, 0.99926, 0.99929],
            '3.2': [0.99931, 0.99934, 0.99936, 0.99938, 0.99940, 0.99942, 0.99944, 0.99946, 0.99948, 0.99950],
            '3.3': [0.99952, 0.99953, 0.99955, 0.99957, 0.99958, 0.99960, 0.99961, 0.99962, 0.99964, 0.99965],
            '3.4': [0.99966, 0.99968, 0.99969, 0.99970, 0.99971, 0.99972, 0.99973, 0.99974, 0.99975, 0.99976],
            '3.5': [0.99977, 0.99978, 0.99978, 0.99979, 0.99980, 0.99981, 0.99981, 0.99982, 0.99983, 0.99983],
            '3.6': [0.99984, 0.99985, 0.99985, 0.99986, 0.99986, 0.99987, 0.99987, 0.99988, 0.99988, 0.99989],
            '3.7': [0.99989, 0.99990, 0.99990, 0.99990, 0.99991, 0.99991, 0.99992, 0.99992, 0.99992, 0.99992],
            '3.8': [0.99993, 0.99993, 0.99993, 0.99994, 0.99994, 0.99994, 0.99994, 0.99995, 0.99995, 0.99995],
            '3.9': [0.99995, 0.99995, 0.99996, 0.99996, 0.99996, 0.99996, 0.99996, 0.99996, 0.99997, 0.99997],
            '4.0': [0.99997, 0.99997, 0.99997, 0.99997, 0.99997, 0.99997, 0.99998, 0.99998, 0.99998, 0.99998]
          };

          function sigFig(value, digits) {
            if (value === 0) {
              return 0;
            }
            let decimalPlaces = digits - Math.floor(Math.log10(Math.abs(value))) - 1;
            return parseFloat(value.toFixed(decimalPlaces));
          }

          let z1 = (1 + (ci / 100)) / 2;
          let zz = z1.toString().split(".")[1]?.length || 0;
          let z = "";
          let old = 0.5;

          outer:
          for (let keys in z_table) {
            let values = z_table[keys];
            for (let key = 0; key < values.length; key++) {
              let value = values[key];
              if (key > 0) old = values[key - 1];
              if (z1 === value) {
                z = parseFloat(keys) + key / 100;
                break outer;
              } else if (key === 0 && value > z1) {
                z = parseFloat(keys) + key / 100;
                break outer;
              } else if (value > z1) {
                z = parseFloat(keys) + (key - 1) / 100;
                break outer;
              }
            }
          }

          let z_2 = Math.pow(z, 2);
          let mle = success / trials;
          let laplace = (success + 1) / (trials + 2);
          let jeffrey = (success + 0.5) / (trials + 1);
          let wilson = (success + (z_2 / 2)) / (trials + z_2);
          let pe;

          if (mle <= 0.5) {
            pe = wilson;
          } else if (mle > 0.5 && mle < 0.9) {
            pe = mle;
          } else if (mle >= 0.9 && mle < 1.0) {
            pe = jeffrey < laplace ? jeffrey : laplace;
          } else if (mle === 1.0) {
            pe = laplace;
          }

          if (ci > 0) {
            z = -z;
          }

          result.tech_pe = sigFig(pe, 4);
          result.tech_z = sigFig(z, 4);
          result.tech_mle = sigFig(mle, 4);
          result.tech_laplace = sigFig(laplace, 4);
          result.tech_jeffrey = sigFig(jeffrey, 4);
          result.tech_wilson = sigFig(wilson, 4);
        } else {
          result.error = "The number of trials must be greater than the number of successes";
        }
      } else {
        result.error = "Please check your input.";
      }

      return result;
    }


     /** getCalculationRelativeFrequencyCalculator
   * POST: /api/calculators-lol/relative-frequency
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationRelativeFrequencyCalculator(body) {
      let data = body.tech_data;
      let freq = body.tech_freq;
      let k = parseInt(body.tech_k);
      let st_val = parseFloat(body.tech_st_val);
      let param = {};

      if (data && data.trim() !== '') {
        let check = true;

        data = data.replace(/[ ,\n\r]+/g, ',');
        data = data.replace(/[a-zA-Z]/g, '');
        while (data.includes(',,')) {
          data = data.replace(/,,/g, ',');
        }

        let set = data.split(',').map(item => item.trim()).filter(item => item !== '').map(Number);

        for (let value of set) {
          if (isNaN(value)) {
            check = false;
          }
          if (freq === 'grp' && value < st_val) {
            param.error = "Number can't be less than the starting value of grouped data!";
            return param;
          }
        }

        if (freq === 'grp' && (!k || isNaN(k))) {
          check = false;
        }

        if (!check) {
          param.error = "Please check your input.";
          return param;
        }

        let count = {};
        set.forEach(val => count[val] = (count[val] || 0) + 1);
        let n = set.length;

        let table = '';
        let rf_values = [];
        let rf1_values = [];

        if (freq === 'ind') {
          table += `<table class='w-full text-[18px]' style='border-collapse: collapse'><thead><tr class='bg-gray-100'><th class='border p-2 text-center text-blue'>Element</th><th class='border p-2 text-center text-blue'>Frequency</th><th class='border p-2 text-center text-blue'>Relative Frequency</th><th class='border p-2 text-center text-blue'>Cumulative Relative Frequency</th></tr></thead><tbody>`;
          let cf = 0;
          let crf = 0;

          for (let key in count) {
            let f = count[key];
            cf += f;
            let rf = f / n;
            crf += rf;
            rf_values.push(rf);
            table += `<tr class='bg-white'><td class='border p-2 text-center'>${key}</td><td class='border p-2 text-center'>${f}</td><td class='border p-2 text-center'>${rf.toFixed(4)}</td><td class='border p-2 text-center'>${crf.toFixed(4)}</td></tr>`;
          }
          table += "</tbody></table>";
        }

        let ds = set.join(', ');
        set.sort((a, b) => a - b);
        let sum = set.reduce((a, b) => a + b, 0);
        let mean = sum / n;
        let average = parseFloat(mean.toFixed(4));
        let min = Math.min(...set);
        let max = Math.max(...set);
        let range = max - min;

        let median = (n % 2 !== 0) ? set[Math.floor(n / 2)] : (set[n / 2] + set[n / 2 - 1]) / 2;

        let m_max = Math.max(...Object.values(count));
        let mode = Object.keys(count).filter(k => count[k] === m_max);

        let ss = 0, hm_sum = 0, asum = 0;
        set.forEach(val => {
          ss += Math.pow(val - mean, 2);
          hm_sum += 1 / val;
          asum += Math.abs(val);
        });

        let hm = n / hm_sum;
        let s_d = Math.sqrt(ss / n);
        let s_d1 = Math.sqrt(ss / (n - 1));
        let variance = s_d * s_d;
        let c_v = s_d1 / mean;
        let gm = Math.pow(set.reduce((a, b) => a * b, 1), 1 / n);
        let snr = mean / s_d1;

        let ad = set.reduce((acc, val) => acc + Math.abs(val - mean), 0);
        let mad = ad / n;

        function quartile(arr, q) {
          let pos = (arr.length + 1) * q;
          let base = Math.floor(pos) - 1;
          let rest = pos - Math.floor(pos);
          if (arr[base + 1] !== undefined) {
            return arr[base] + rest * (arr[base + 1] - arr[base]);
          } else {
            return arr[base];
          }
        }

        let q1 = quartile(set, 0.25);
        let q2 = quartile(set, 0.5);
        let q3 = quartile(set, 0.75);
        let iqr = q3 - q1;
        let qd = iqr / 2;
        let cqd = iqr / (q3 + q1);
        let uf = q1 - (1.5 * iqr);
        let lf = q3 + (1.5 * iqr);

        let z = set.map(val => ((val - mean) / s_d).toFixed(4)).join(', ');
        let sds = set.join(', ');

        if (freq === 'grp') {
          let ci = Math.round(((max - min) / k) + 1);
          let x = st_val;
          let group = [];
          let group_count = [];

          for (let i = 0; i < k; i++) {
            let next = x + ci;
            if (next > 10000000) {
              param.error = "A number can't be Greater Than 10000000";
              return param;
            }
            group.push(`${x} to ${next}`);
            let count = set.filter(val => val >= x && val <= next).length;
            group_count.push(count);
            x = next + 1;
          }

          table = `<table class='w-full text-[18px]' style='border-collapse: collapse'><thead><tr class='bg-gray-100'><th class='border p-2 text-center text-blue'>Group</th><th class='border p-2 text-center text-blue'>Frequency</th><th class='border p-2 text-center text-blue'>Relative Frequency</th><th class='border p-2 text-center text-blue'>Cumulative Relative Frequency</th></tr></thead><tbody>`;
          let cf1 = 0, crf1 = 0;
          for (let i = 0; i < k; i++) {
            cf1 += group_count[i];
            let rf1 = group_count[i] / n;
            crf1 += rf1;
            rf1_values.push(rf1);
            table += `<tr class='bg-white'><td class='border p-2 text-center'>${group[i]}</td><td class='border p-2 text-center'>${group_count[i]}</td><td class='border p-2 text-center'>${rf1.toFixed(4)}</td><td class='border p-2 text-center'>${crf1.toFixed(4)}</td></tr>`;
          }
          table += "</tbody></table>";

          param.tech_group = group;
          param.tech_group_count = group_count;
        }

        Object.assign(param, {
                tech_table:table,
                tech_set:set,
                tech_ds:ds,
                tech_rf_values:rf_values,
                tech_rf1_values:rf1_values,
                tech_sds:sds,
                tech_n:n,
                tech_count:count, 
                tech_mean:mean,
                tech_median:median, 
                tech_mode:mode,
                tech_min:min,
                tech_max:max,
                tech_range:range, 
                tech_sum:sum, 
                tech_ss:ss, 
                tech_asum:asum,
                tech_s_d:s_d, 
                tech_s_d1:s_d1,
                tech_c_v:c_v,
                tech_snr:snr,
                tech_variance:variance, 
                tech_gm:gm, 
                tech_hm:hm, 
                tech_ad:ad, 
                tech_mad:mad, 
                tech_q1:q1,
                tech_q2:q2,
                tech_q3:q3,
                tech_iqr:iqr,
                tech_qd:qd, 
                tech_cqd:cqd, 
                tech_uf:uf, 
                tech_lf:lf, 
                tech_z:z,
        });

        return param;
      } else {
        return { error: "Please check your input." };
      }
    }


     /** getCalculationProbabilityCalculator
   * POST: /api/calculators-lol/probability-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
      async  getCalculationProbabilityCalculator(body) {
      let result = {};

      let option = body.tech_for;

      if (option === '1') {
        let nbr1 = Number(body.tech_nbr1);
        let event = Number(body.tech_event);

        if (!isNaN(nbr1) && !isNaN(event)) {
          let event_occur = +(event / nbr1).toFixed(3);
          let not_occur = +(1 - event_occur).toFixed(3);

          result.tech_event_occur = event_occur;
          result.tech_not_occur = not_occur;
          result.tech_Single = "active";
        } else {
          result.error = "Please fill All fields.";
        }

      } else if (option === '2') {
        let nbr2 = Number(body.tech_nbr2);
        let event_a = Number(body.tech_event_a);
        let event_b = Number(body.tech_event_b);

        if (!isNaN(nbr2) && !isNaN(event_a) && !isNaN(event_b)) {
          let event_a_occur = +(event_a / nbr2).toFixed(4);
          let not_a_occur = +(1 - event_a_occur).toFixed(4);
          let event_b_occur = +(event_b / nbr2).toFixed(4);
          let not_b_occur = +(1 - event_b_occur).toFixed(4);
          let both_events = +(event_a_occur * event_b_occur).toFixed(4);
          let either_events = +(event_a_occur + event_b_occur - both_events).toFixed(4);
          let conditional = +(both_events / event_b_occur).toFixed(4);

          result = {
            tech_event_a_occur:event_a_occur,
            tech_not_a_occur:not_a_occur,
            tech_event_b_occur:event_b_occur,
            tech_not_b_occur:not_b_occur,
            tech_both_events:both_events,
            tech_either_events:either_events,
            tech_conditional:conditional,
            tech_Multiple: "active",
          };
        } else {
          result.error = "Please fill All fields.";
        }

      } else if (option === '3') {
        let pro_a = Number(body.tech_pro_a);
        let pro_b = Number(body.tech_pro_b);
        let format = body.format;

        if (!isNaN(pro_a) && !isNaN(pro_b)) {
          if (format === '2') {
            pro_a = pro_a / 100;
            pro_b = pro_b / 100;
          }

          let not_a_occur = +(1 - pro_a).toFixed(4);
          let not_b_occur = +(1 - pro_b).toFixed(4);
          let both_events = +(pro_a * pro_b).toFixed(4);
          let either_events = +(pro_a + pro_b - both_events).toFixed(5);
          let conditional = +(both_events / pro_b).toFixed(4);
          let not_both = +(pro_a + pro_b - 2 * both_events).toFixed(5);
          let nor_both = +(1 - either_events).toFixed(5);
          let anotb = +(pro_a * (1 - pro_b)).toFixed(5);
          let bnota = +((1 - pro_a) * pro_b).toFixed(5);

          result = {
            tech_not_a_occur:not_a_occur,
            tech_not_b_occur:not_b_occur,
            tech_both_events:both_events,
            tech_either_events:either_events,
            tech_conditional:conditional,
            tech_not_both:not_both,
            tech_nor_both:nor_both,
            tech_anotb:anotb,
            tech_bnota:bnota,
            tech_pro_a:pro_a,
            tech_pro_b:pro_b,
            tech_Solver: "events",
          };
        } else {
          result.error = "Please fill All fields.";
        }

      } else if (option === '4') {
        let eve_a = Number(body.tech_eve_a);
        let rep_a = Number(body.tech_rep_a);
        let eve_b = Number(body.tech_eve_b);
        let rep_b = Number(body.tech_rep_b);

        if (!isNaN(eve_a) && !isNaN(rep_a) && !isNaN(eve_b) && !isNaN(rep_b)) {
          result = {
            tech_Events: "events",
          };
        } else {
          result.error = "Please fill All fields.";
        }

      } else if (option === '5') {
        let andb = Number(body.tech_andb);
        let prob_b = Number(body.tech_prob_b);

        if (!isNaN(andb) && !isNaN(prob_b)) {
          result.tech_condi = +(andb / prob_b).toFixed(4);
        } else {
          result.error = "Please fill All fields.";
        }
      }

      return result;
    }


     /** getCalculationCoefficientOfVariationCalculator
   * POST: /api/calculators-lol/coefficient-of-variation
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async  getCalculationCoefficientOfVariationCalculator(body) {
    let result = {};

    let x = body.tech_x;
    let type = body.tech_type_;

    if (x && x.trim() !== '') {
      let cleaned = x.replace(/[\n\r\s,]+/g, ',');
      while (cleaned.includes(',,'))
        cleaned = cleaned.replace(',,', ',');

      let array = cleaned.split(',').map(v => v.trim()).filter(v => v !== '');
      let count = array.length;
      let replace = cleaned.replace(/,/g, '+');

      let isAllNumbers = array.every(val => !isNaN(val));
      let numericArray = array.map(Number);

      result.tech_count = count;
      result.tech_arr = array;
      result.tech_replace = replace;

      if (isAllNumbers) {
        let sum = numericArray.reduce((a, b) => a + b, 0);
        let mean = +(sum / count).toFixed(3);

        let d = 0;
        for (let val of numericArray) {
          d += Math.pow(val - mean, 2);
        }

        let s_d = type === '2'
          ? Math.sqrt(d / count)
          : Math.sqrt(d / (count - 1));
        s_d = +s_d.toFixed(4);

        let c = +(s_d / mean).toFixed(4);

        result.tech_sum = sum;
        result.tech_m = mean;
        result.tech_d = s_d;
        result.tech_c = c;
        result.tech_t_n = count;
      } else {
        result.error = "Please Enter Valid Input.";
      }
    } else {
      result.error = "Please fill All fields.";
    }

    return result;
  }

     /** getCalculationCovarianceCalculator
   * POST: /api/calculators-lol/covariance-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

      async  getCalculationCovarianceCalculator(body) {
    let param = {};

    let set_x = body.tech_set_x;
    let set_y = body.tech_set_y;
    let formula = body.tech_formula;
    let between = Number(body.tech_between);
    let devi_x = Number(body.tech_devi_x);
    let devi_y = Number(body.tech_devi_y);
    let matrix = body.tech_matrix;

    if (formula === '1') {
      if (set_x && set_y) {
        // Normalize inputs: replace spaces/newlines etc with commas
        set_x = set_x.replace(/[\s,\n\r]+/g, ',');
        while (set_x.includes(',,')) set_x = set_x.replace(/,,/g, ',');

        set_y = set_y.replace(/[\s,\n\r]+/g, ',');
        while (set_y.includes(',,')) set_y = set_y.replace(/,,/g, ',');

        let arrayX = set_x.split(',').map(e => e.trim()).filter(e => e !== '');
        let arrayY = set_y.split(',').map(e => e.trim()).filter(e => e !== '');

        // Validate numeric and equal length
        let check = arrayX.length === arrayY.length &&
                    arrayX.every(val => !isNaN(Number(val))) &&
                    arrayY.every(val => !isNaN(Number(val)));

        if (check) {
          let nbr = arrayX.length;
          let numsX = arrayX.map(Number);
          let numsY = arrayY.map(Number);

          let sumX = numsX.reduce((a, b) => a + b, 0);
          let sumY = numsY.reduce((a, b) => a + b, 0);

          let meanX = +(sumX / nbr).toFixed(2);
          let meanY = +(sumY / nbr).toFixed(2);

          let total = 0;
          for (let i = 0; i < nbr; i++) {
            let X1 = numsX[i] - meanX;
            let Y1 = numsY[i] - meanY;
            total += X1 * Y1;
          }

          let sample = +(total / nbr).toFixed(2);
          let population = +(total / (nbr - 1)).toFixed(2);

          param.tech_nbr = nbr;
          param.tech_mean_x = meanX;
          param.tech_mean_y = meanY;
          param.tech_sample = sample;
          param.tech_population = population;
          param.tech_formula = formula;

          return param;
        } else {
          param.error = "Please Check Your Input";
          return param;
        }
      } else {
        param.error = "Please Enter all value";
        return param;
      }
    }

    if (formula === '2') {
      if (!isNaN(between) && !isNaN(devi_x) && !isNaN(devi_y)) {
        param.tech_ans_2 = +(between * devi_x * devi_y).toFixed(2);
        param.tech_formula = formula;
        return param;
      } else {
        param.error = "Please fill All fields.";
        return param;
      }
    }

    if (formula === '3') {
      if (matrix) {
        let check = true;
        // split matrix string on ']' to get rows
        let matrixRows = matrix.split(']');
        let rows = matrixRows.length;
        if (rows < 2) {
          param.error = "Please Enter Matrix";
          return param;
        }

        // Extract first row to get column count
        let firstRowStr = matrixRows[0].split('[')[1];
        if (!firstRowStr) {
          param.error = "Invalid Matrix Format";
          return param;
        }
        let firstRow = firstRowStr.split(',').map(e => e.trim()).filter(e => e !== '');
        let rowCount = firstRow.length;

        // Initialize arrays
        let arrayRow = new Array(rowCount).fill(0);
        let arrayAvg = new Array(rowCount).fill(0);

        for (let i = 0; i < rows - 1; i++) {
          let rowParts = matrixRows[i].split('[');
          if (rowParts.length < 2) {
            check = false;
            break;
          }
          let rowValues = rowParts[1].split(',').map(e => e.trim()).filter(e => e !== '');
          if (rowValues.length !== rowCount) {
            check = false;
            break;
          }

          for (let k = 0; k < rowCount; k++) {
            let val = Number(rowValues[k]);
            if (isNaN(val)) {
              check = false;
            } else {
              arrayRow[k] += val;
              arrayAvg[k] += val;
            }
          }
        }

        // Calculate averages
        for (let i = 0; i < rowCount; i++) {
          arrayAvg[i] = +(arrayAvg[i] / (rows - 1)).toFixed(2);
        }

        // Calculate final rows after subtracting averages
        let finalRows = Array(rows - 1).fill(0).map(() => new Array(rowCount).fill(0));

        for (let i = 0; i < rows - 1; i++) {
          let rowParts = matrixRows[i].split('[');
          let rowValues = rowParts[1].split(',').map(e => e.trim()).filter(e => e !== '');
          for (let j = 0; j < rowCount; j++) {
            finalRows[i][j] = Number(rowValues[j]) - arrayAvg[j];
          }
        }

        // Transpose rows
        let transRows = Array(rowCount).fill(0).map(() => new Array(rows - 1).fill(0));

        for (let i = 0; i < rowCount; i++) {
          for (let j = 0; j < rows - 1; j++) {
            transRows[i][j] = finalRows[j][i];
          }
        }

        // Multiply transRows and finalRows matrices
        let resultRows = Array(rowCount).fill(0).map(() => new Array(rowCount).fill(0));

        for (let i = 0; i < rowCount; i++) {
          for (let j = 0; j < rowCount; j++) {
            let sum = 0;
            for (let k = 0; k < rows - 1; k++) {
              sum += transRows[i][k] * finalRows[k][j];
            }
            resultRows[i][j] = sum;
          }
        }

        // Format output string
        let output = '';
        for (let i = 0; i < rowCount; i++) {
          output += '[ ';
          for (let j = 0; j < rowCount; j++) {
            let val = +(resultRows[i][j] / (rows - 1)).toFixed(5);
            output += (j === rowCount - 1) ? `${val} ] <br>` : `${val} , `;
          }
        }

        if (check) {
          param.tech_output = output;
          param.tech_formula = formula;
          return param;
        } else {
          param.error = "Please Check Your Input";
          return param;
        }
      } else {
        param.error = "Please Enter Matrix";
        return param;
      }
    }

    // If formula not matched
    param.error = "Invalid formula value";
    return param;
  }

   /** getCalculationMeanMedianModeRangeCalculator
   * POST: /api/calculators-lol/mean-median-mode-range
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async getCalculationMeanMedianModeRangeCalculator(body) {
      let x = body.tech_x;

      let result = {};
      let check = true;

      if (!x) {
          check = false;
      }

      x = x.replace(/[\s,\n\r]+/g, ',');
      while (x.includes(",,"))
          x = x.replace(",,", ",");

      let numbers = x.split(',').map(s => s.trim()).filter(s => s !== '').map(Number);

      for (let val of numbers) {
          if (isNaN(val)) {
              check = false;
              break;
          }
      }

      if (check) {
          numbers.sort((a, b) => a - b);
          let sum = numbers.reduce((a, b) => a + b, 0);
          let count = numbers.length;
          let average = +(sum / count).toFixed(4);

          // Median
          let median;
          if (count % 2 !== 0) {
              median = numbers[Math.floor(count / 2)];
          } else {
              let mid = count / 2;
              median = (numbers[mid] + numbers[mid - 1]) / 2;
          }

          function interpolate(array, position) {
              let floorIdx = Math.floor(position) - 1;
              let ceilIdx = Math.ceil(position) - 1;
              if (floorIdx === ceilIdx) {
                  return array[floorIdx];
              } else {
                  return array[floorIdx] + (position - Math.floor(position)) * (array[ceilIdx] - array[floorIdx]);
              }
          }

          // Q1 and Q3
          let Q1_pos = (count + 1) / 4;
          let Q3_pos = 3 * (count + 1) / 4;
          let Q1 = interpolate(numbers, Q1_pos);
          let Q3 = interpolate(numbers, Q3_pos);
          let IQR = Q3 - Q1;

          // Mode
          let freq = {};
          for (let n of numbers) {
              freq[n] = (freq[n] || 0) + 1;
          }

          let maxFreq = Math.max(...Object.values(freq));
          let mode = [];
          let hasRepeating = false;
          for (let key in freq) {
              if (freq[key] > 1 && freq[key] === maxFreq) {
                  mode.push(Number(key));
                  hasRepeating = true;
              }
          }

          if (!hasRepeating) {
              mode.push("No value appears more than once!");
          }

          result = {
              tech_Q1:Q1,
              tech_Q3:Q3,
              tech_IQR:IQR,
              tech_mode:mode,
              tech_median:median,
              tech_average:average,
              tech_count:count,
              tech_numbers:numbers,
          };
      } else {
          result.error = "Please enter numbers";
      }

      return result;
  }

    /** getCalculationQuartileCalculator
   * POST: /api/calculators-lol/quartile-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationQuartileCalculator(body) {
    let x = body.tech_x;
    let seprate = body.tech_seprate;

    let result = {}; 
    let check = true;

    if (!x || typeof x !== 'string' || x.trim() === '') {
        check = false;
    }

    if (!seprate || typeof seprate !== 'string') {
        seprate = ' ';
    }

    let values = x.split(seprate).map(v => v.trim()).filter(v => v !== '').map(Number);

    for (let val of values) {
        if (isNaN(val)) {
            check = false;
            break;
        }
    }

    if (check) {
        if (values.length < 4) {
            return { error: "Please! enter 4 or more numbers" };
        }

        values.sort((a, b) => a - b);

        let count = values.length;
        let a1 = values[0];
        let a2 = values[count - 1];

        function quartil(arr) {
            let c = arr.length;
            let middleval = Math.floor((c - 1) / 2);
            let median;
            if (c % 2 !== 0) {
                median = arr[middleval];
            } else {
                let low = arr[middleval];
                let high = arr[middleval + 1];
                median = (low + high) / 2;
            }
            return Number(median.toFixed(1));
        }

        let second = quartil(values);

        let tmp = { first: [], third: [] };
        for (let val of values) {
            if (val < second) {
                tmp.first.push(val);
            } else if (val > second) {
                tmp.third.push(val);
            }
        }

        let first = quartil(tmp.first);
        let third = quartil(tmp.third);

        let min = Math.min(...values);
        let max = Math.max(...values);
        let iter = third - first;

        let sum = values.reduce((a, b) => a + b, 0);
        let average = +(sum / count).toFixed(4);

        let median;
        if (count % 2 !== 0) {
            median = values[Math.floor(count / 2)];
        } else {
            let center = count / 2;
            median = (values[center] + values[center - 1]) / 2;
        }

        let freqMap = {};
        for (let val of values) {
            freqMap[val] = (freqMap[val] || 0) + 1;
        }

        let maxFreq = Math.max(...Object.values(freqMap));
        let mode = Object.keys(freqMap).filter(key => freqMap[key] === maxFreq).map(Number);

        let m = +(sum / count).toFixed(3);
        let d = values.reduce((acc, val) => acc + Math.pow(val - m, 2), 0);

        let s_d_p = +(Math.sqrt(d / count)).toFixed(4);
        let s_d_s = +(Math.sqrt(d / (count - 1))).toFixed(4);

        result = {
            tech_a1:a1,
            tech_a2:a2,
            tech_first:first,
            tech_second:second,
            tech_third:third,
            tech_iter:iter,
            tech_mode:mode,
            tech_s_d_p:s_d_p,
            tech_s_d_s:s_d_s,
            tech_median:median,
            tech_average:average,
            tech_count:count,
            tech_numbers: values,
        };
    } else {
        result.error = "Please! Check Your Input";
    }

    return result;
}
    /** getCalculationGeometricMeanCalculator
   * POST: /api/calculators-lol/geometric-mean-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

async getCalculationGeometricMeanCalculator(body) {
    let x = body.tech_x;
    let seprate = body.tech_seprate;

    let result = {};
    let check = true;

    if (!x || typeof x !== 'string' || x.trim() === '') {
        return { error: "Please Enter Your Values" };
    }

    if (!seprate || typeof seprate !== 'string') {
        seprate = ' ';
    }

    let cleaned_input = x.replace(/[^0-9.\-%]/g, ' ');
    let numbers = cleaned_input.trim().split(/\s+/);

    check = true;
    let type = 'number';

    for (let value of numbers) {
        let clean_value = value.replace('%', '');
        if (isNaN(clean_value)) {
            check = false;
            break;
        }
        if (value.includes('-') || value.includes('%')) {
            type = 'percentage';
        }
    }

    if (check) {
        numbers = numbers.map(val => val.includes('%') ? val : Number(val));
        numbers.sort((a, b) => parseFloat(a) - parseFloat(b));
        let last_index = numbers.length - 1;
        let sol = "(";

        if (type === 'number') {
            for (let i = 0; i < numbers.length; i++) {
                sol += ` ${numbers[i]}${i !== last_index ? ' x' : ' )'}`;
            }

            if (numbers.some(n => n < 0)) {
                return { error: "Please Check Your Input" };
            }
        } else {
            let sol1 = "( ";
            let pro = 1;
            for (let i = 0; i < numbers.length; i++) {
                let value = parseFloat(numbers[i].toString().replace('%', ''));
                let term = 1 + (value / 100);
                pro *= term;
                if (i !== last_index) {
                    sol += ` (1 + ${value}/100) x`;
                    sol1 += `${term} x `;
                } else {
                    sol += ` (1 + ${value}/100) )`;
                    sol1 += `${term} )`;
                }
            }
            let geo = +(((Math.pow(pro, 1 / numbers.length)) - 1) * 100).toFixed(4);

            result.tech_textline = "aa gai value";
            result.tech_sol1 = sol1;
            result.tech_pro = pro;
            result.tech_geo = `${geo}%`;
        }

        // For rest of calculations we convert all to numbers
        let numericValues = numbers.map(n => parseFloat(n));
        let sum = numericValues.reduce((a, b) => a + b, 0);
        let count = numericValues.length;
        let average = +(sum / count).toFixed(4);

        let median;
        if (count % 2 !== 0) {
            median = numericValues[Math.floor(count / 2)];
        } else {
            let center = count / 2;
            median = (numericValues[center] + numericValues[center - 1]) / 2;
        }

        let d = 1;
        for (let val of numericValues) {
            d *= val;
        }

        let freqMap = {};
        for (let val of numericValues) {
            freqMap[val] = (freqMap[val] || 0) + 1;
        }
        let maxFreq = Math.max(...Object.values(freqMap));
        let mode = Object.keys(freqMap).filter(k => freqMap[k] === maxFreq).map(Number);

        let m = +(sum / count).toFixed(3);

        result.tech_mode = mode;
        result.tech_sol = sol;
        result.tech_median = median;
        result.tech_average = average;
        result.tech_count = count;
        result.tech_tnumbers = numericValues;
        return result;

    } else {
        return { error: "Please Check Your Input" };
    }
}

    /** getCalculationHarmonicMeanCalculator
   * POST: /api/calculators-lol/harmonic-mean-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async getCalculationHarmonicMeanCalculator(body) {
    let x = body.tech_x;
    let seprateby = body.tech_seprateby;
    let seprate = body.tech_seprate;

    let result = {};
    let check = true;

    if (!x || typeof x !== 'string' || x.trim() === '') {
        return { error: "Please Enter Your Values" };
    }

    // Determine actual separator
    if (seprateby === 'space') {
        seprate = ' ';
    } else if (seprateby === ',') {
        seprate = ',';
    } else if (!seprate || typeof seprate !== 'string') {
        seprate = ' '; // default fallback
    }

    let numbers = x.split(seprate).map(v => v.trim()).filter(v => v !== '');

    for (let value of numbers) {
        if (isNaN(value)) {
            check = false;
            break;
        }
    }

    if (check) {
        numbers = numbers.map(Number);
        numbers.sort((a, b) => a - b);
        let last_index = numbers.length - 1;
        let sol = "(";
        let sol1 = "( ";
        let ans = 0;

        for (let i = 0; i < numbers.length; i++) {
            let value = numbers[i];
            let inv = 1 / value;
            ans += inv;

            if (i !== last_index) {
                sol += ` 1/${value} +`;
                sol1 += `${inv} + `;
            } else {
                sol += ` 1/${value} )`;
                sol1 += `${inv} )`;
            }
        }

        let sum = numbers.reduce((a, b) => a + b, 0);
        let count = numbers.length;
        let harmonicMean = +(count / ans).toFixed(5);
        let average = +(sum / count).toFixed(4);

        let median;
        if (count % 2 !== 0) {
            median = numbers[Math.floor(count / 2)];
        } else {
            let mid = count / 2;
            median = (numbers[mid] + numbers[mid - 1]) / 2;
        }

        let d = 1;
        for (let val of numbers) {
            d *= val;
        }

        let freqMap = {};
        for (let val of numbers) {
            freqMap[val] = (freqMap[val] || 0) + 1;
        }
        let maxFreq = Math.max(...Object.values(freqMap));
        let mode = Object.keys(freqMap).filter(k => freqMap[k] === maxFreq).map(Number);

        result.tech_mode = mode;
        result.tech_sol = sol;
        result.tech_sol1 = sol1;
        result.tech_ans = harmonicMean;
        result.tech_median = median;
        result.tech_average = average;
        result.tech_count = count;
        result.tech_numbers = numbers;
        return result;
    } else {
        return { error: "Please Check Your Input" };
    }
}


    /** getCalculationIQRCalculator
   * POST: /api/calculators-lol/interquartile-range-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async getCalculationIQRCalculator(body) {
      let x = body.tech_x;
      let seprateby = body.tech_seprateby;
      let seprate = body.tech_seprate;

      let result = {};
      let check = true;

      if (!x || typeof x !== 'string' || x.trim() === '') {
          return { error: "Please Enter Your Values" };
      }

      // Determine actual separator
      if (seprateby === 'space') {
          seprate = ' ';
      } else if (seprateby === ',') {
          seprate = ',';
      } else if (!seprate || typeof seprate !== 'string') {
          seprate = ' ';
      }

      let values = x.split(seprate).map(v => v.trim()).filter(v => v !== '');
      for (let v of values) {
          if (isNaN(v)) {
              check = false;
              break;
          }
      }

      if (!check) {
          return { error: "Please! Check Your Input" };
      }

      values = values.map(Number).sort((a, b) => a - b);
      if (values.length < 4) {
          return { error: "Please! enter 4 or more numbers" };
      }

      const quartil = (arr) => {
          const count = arr.length;
          const mid = Math.floor((count - 1) / 2);
          if (count % 2 === 1) {
              return +arr[mid].toFixed(1);
          } else {
              return +(((arr[mid] + arr[mid + 1]) / 2).toFixed(1));
          }
      };

      let count = values.length;
      let a1 = values[0];
      let a2 = values[count - 1];
      let second = quartil(values);

      let lowerHalf = values.filter(v => v < second);
      let upperHalf = values.filter(v => v > second);

      let first = quartil(lowerHalf);
      let third = quartil(upperHalf);

      let iter = +(third - first).toFixed(4);
      let sum = values.reduce((a, b) => a + b, 0);
      let average = +(sum / count).toFixed(4);

      let median;
      if (count % 2 !== 0) {
          median = values[Math.floor(count / 2)];
      } else {
          let mid = count / 2;
          median = (values[mid] + values[mid - 1]) / 2;
      }

      let freqMap = {};
      for (let v of values) {
          freqMap[v] = (freqMap[v] || 0) + 1;
      }
      let maxFreq = Math.max(...Object.values(freqMap));
      let mode = Object.keys(freqMap).filter(k => freqMap[k] === maxFreq).map(Number);

      let mean = +(sum / count).toFixed(3);
      let d = 0;
      for (let v of values) {
          d += Math.pow(v - mean, 2);
      }

      let s_d_p = +(Math.sqrt(d / count).toFixed(4));
      let s_d_s = +(Math.sqrt(d / (count - 1)).toFixed(4));

      result.tech_a1 = a1;
      result.tech_a2 = a2;
      result.tech_first = first;
      result.tech_second = second;
      result.tech_third = third;
      result.tech_iter = iter;
      result.tech_mode = mode;
      result.tech_s_d_p = s_d_p;
      result.tech_s_d_s = s_d_s;
      result.tech_median = median;
      result.tech_average = average;
      result.tech_count = count;
      result.tech_numbers = values;

      return result;
  }


    /** getCalculationSumOfSquaresCalculator
   * POST: /api/calculators-lol/sum-of-squares-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async getCalculationSumOfSquaresCalculator(body) {
      let x = body.tech_x;
      let seprateby = body.tech_seprateby;
      let seprate = body.tech_seprate;

      let result = {};
      let check = true;

      if (!x || typeof x !== 'string' || x.trim() === '') {
          return { error: "Please Enter Your Values" };
      }

      // Determine actual separator
      if (seprateby === 'space') {
          seprate = ' ';
      } else if (seprateby === ',') {
          seprate = ',';
      } else if (!seprate || typeof seprate !== 'string') {
          seprate = ' ';
      }

      let numbers = x.split(seprate).map(v => v.trim()).filter(v => v !== '');
      for (let v of numbers) {
          if (isNaN(v)) {
              check = false;
              break;
          }
      }

      if (!check) {
          return { error: "Please! Check Your Input" };
      }

      let ns = numbers.map(Number);
      let n = ns.length;
      let s = ns.reduce((a, b) => a + b, 0) / n;

      let ss = 0, su = 0, so = 0;
      for (let val of ns) {
          ss += Math.pow(val - s, 2);
          su += Math.pow(val, 2);
          so += val;
      }

      let sns = '', snns = '', soa = '', soas = '';
      ns.forEach((val, index) => {
          let diffSquared = Math.pow(val - s, 2);
          let square = Math.pow(val, 2);

          sns += `(${val} - ${s})<sup>2</sup>`;
          snns += `${diffSquared}`;
          soa += `(${val})<sup>2</sup>`;
          soas += `${square}`;

          if (index !== ns.length - 1) {
              sns += " + ";
              snns += " + ";
              soa += " + ";
              soas += " + ";
          }
      });

      result.tech_soas = soas;
      result.tech_soa = soa;
      result.tech_snns = snns;
      result.tech_sns = sns;
      result.tech_s = s;
      result.tech_so = so;
      result.tech_n = n;
      result.tech_su = su;
      result.tech_ss = ss;

      return result;
  }


    /** getCalculationPoissonDistributionCalculator
   * POST: /api/calculators-lol/poisson-distribution-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

async  getCalculationPoissonDistributionCalculator(body) {
      let x = body.tech_x;
      let mean = body.tech_mean;
      let con = body.tech_con;
    
    // Helper functions
    function isNumeric(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function factorial(n) {
        if (n < 0) return NaN;
        if (n <= 1) return 1;
        let res = 1;
        for (let i = 2; i <= n; i++) res *= i;
        return res;
    }

    function pow(base, exponent) {
        return Math.pow(base, exponent);
    }

    function exp(value) {
        return Math.exp(value);
    }

    function round(value, decimals) {
        return Number(Math.round(value + 'e' + decimals) + 'e-' + decimals);
    }



    const result = {
        param: {}
    };

    if (x < 0 || x > 440) {
        result.param.error = "This calculator is work with 0 to 440 for variable (x)";
        return result.param;
    }

    if (isNumeric(x) && isNumeric(mean) && isNumeric(con)) {
        let chart = '';
        let sum = '';
        let sumofex, power, expo, ans, factVal;

        if (con === '1') {
            factVal = factorial(x);
            expo = round(exp(-1 * (mean)), 4);
            power = pow(mean, x);
            sumofex = expo * power;
            ans = (exp(-1 * (mean)) * pow(mean, x)) / factVal;
            result.param.tech_fact = factVal;
        } else if (con === '2' || con === '5') {
            ans = 0;
            sum = '';
            result.param.tech_details = {};

            for (let i = 0; i < x; i++) {
                factVal = factorial(i);
                if (i == 0) {
                    result.param.tech_first = (exp(-1 * (mean)) * pow(mean, i)) / factVal;
                }
                if (i != (x - 1)) {
                    sum += (exp(-1 * (mean)) * pow(mean, i)) / factVal + ' + <br>';
                } else {
                    sum += (exp(-1 * (mean)) * pow(mean, i)) / factVal;
                }
                ans += (exp(-1 * (mean)) * pow(mean, i)) / factVal;
            }

            result.param.tech_ans = ans;
            result.param.tech_sum = sum;

            if (con == '2') {
                for (let currentX = 0; currentX < x; currentX++) {
                    factVal = factorial(currentX);
                    expo = round(exp(-1 * (mean)), 4);
                    power = pow(mean, currentX);
                    sumofex = expo * power;

                    result.param.tech_details[currentX] = {
                        fact: factVal,
                        sumofex: sumofex,
                        power: power,
                        expo: expo,
                        value: (exp(-1 * (mean)) * pow(mean, currentX)) / factVal,
                    };
                }
            } else if (con == '5') {
                for (let currentX = 0; currentX <= x - 1; currentX++) {
                    factVal = factorial(currentX);
                    expo = round(exp(-1 * (mean)), 4);
                    power = pow(mean, currentX);
                    sumofex = expo * power;

                    result.param.tech_details[currentX] = {
                        fact: factVal,
                        sumofex: sumofex,
                        power: power,
                        expo: expo,
                        value: (exp(-1 * (mean)) * pow(mean, currentX)) / factVal,
                    };
                }
            }
        } else if (con === '3' || con === '4') {
            ans = 0;
            sum = '';
            result.param.tech_details = {};

            for (let i = 0; i <= x; i++) {
                factVal = factorial(i);
                if (i == 0) {
                    result.param.tech_first = (exp(-1 * (mean)) * pow(mean, i)) / factVal;
                }
                if (i != x) {
                    sum += (exp(-1 * (mean)) * pow(mean, i)) / factVal + ' + <br>';
                } else {
                    sum += (exp(-1 * (mean)) * pow(mean, i)) / factVal;
                }
                ans += (exp(-1 * (mean)) * pow(mean, i)) / factVal;
            }

            result.param.tech_ans = ans;
            result.param.tech_sum = sum;

            if (con == '3') {
                for (let currentX = 0; currentX <= x; currentX++) {
                    factVal = factorial(currentX);
                    expo = round(exp(-1 * (mean)), 4);
                    power = pow(mean, currentX);
                    sumofex = expo * power;
                    result.param.tech_details[currentX] = {
                        fact: factVal,
                        sumofex: sumofex,
                        power: power,
                        expo: expo,
                        value: (exp(-1 * (mean)) * pow(mean, currentX)) / factVal,
                    };
                }
            } else {
                for (let currentX = 0; currentX <= x; currentX++) {
                    factVal = factorial(currentX);
                    expo = round(exp(-1 * (mean)), 4);
                    power = pow(mean, currentX);
                    sumofex = expo * power;
                    result.param.tech_details[currentX] = {
                        fact: factVal,
                        sumofex: sumofex,
                        power: power,
                        expo: expo,
                        value: (exp(-1 * (mean)) * pow(mean, currentX)) / factVal,
                    };
                }
            }

            result.param.tech_fact = factVal;
            result.param.tech_sum = sum;
        }

        for (let i = 0; i <= 15; i++) {
            factVal = factorial(i);
            chart += (exp(-1 * (mean)) * pow(mean, i)) / factVal + ',';
        }

        result.param.tech_sumofex = sumofex;
        result.param.tech_power = power;
        result.param.tech_expo = expo;
        result.param.tech_ans = ans;
        result.param.tech_chart = chart;
        return result.param;
    } else {
        result.param.error = "Please check your input.";
        return result.param;
    }
}

    /** getCalculationBinomialDistributionCalculator
   * POST: /api/calculators-lol/binomial-distribution-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationBinomialDistributionCalculator(body) {
          let x = body.tech_x;
          let n = body.tech_n;
          let con = body.tech_con;
          let p = body.tech_p;

        // Helper functions
    function isNumeric(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function factorial(num) {
        if (num < 0) return NaN;
        if (num <= 1) return 1;
        let result = 1;
        for (let i = 2; i <= num; i++) {
            result *= i;
        }
        return result;
    }


        const result = {
            param: {}
        };

        // Input validation
        if (n < 0 || n > 440) {
            result.param.error = "This calculator works with 0 to 440 for Trials (n)";
            return result.param;
        }
        if (p < 0 || p > 1) {
            result.param.error = "The probability must be between 0 and 1";
            return result.param;
        }
        if (x > n) {
            result.param.error = "The number of successes must be less than or equal to the number of trials";
            return result.param;
        }

        if (isNumeric(x) && isNumeric(n) && isNumeric(con) && isNumeric(p)) {
            let ans = 0;
            let table = [];

            // Helper function to calculate combination
            const combination = (n, k) => {
                return factorial(n) / (factorial(k) * factorial(n - k));
            };

            if (con === '1') {
                // Exactly x successes
                const nf = factorial(n);
                const xf = factorial(x);
                const nxf = factorial(n - x);
                ans = (nf / (xf * nxf)) * Math.pow(p, x) * Math.pow(1 - p, n - x);
                
                // Generate probability table
                for (let i = 0; i <= n; i++) {
                    const ifact = factorial(i);
                    const nifact = factorial(n - i);
                    table.push((factorial(n) / (ifact * nifact)) * Math.pow(p, i) * Math.pow(1 - p, n - i));
                }
            } 
            else if (con === '2') {
                // Fewer than x successes (x not included)
                for (let i = 0; i <= n; i++) {
                    const prob = combination(n, i) * Math.pow(p, i) * Math.pow(1 - p, n - i);
                    table.push(prob);
                    if (i < x) {
                        ans += prob;
                    }
                }
            } 
            else if (con === '3') {
                // x or fewer successes (x included)
                for (let i = 0; i <= n; i++) {
                    const prob = combination(n, i) * Math.pow(p, i) * Math.pow(1 - p, n - i);
                    table.push(prob);
                    if (i <= x) {
                        ans += prob;
                    }
                }
            } 
            else if (con === '4') {
                // More than x successes (x not included)
                // First generate full table
                for (let i = 0; i <= n; i++) {
                    const prob = combination(n, i) * Math.pow(p, i) * Math.pow(1 - p, n - i);
                    table.push(prob);
                }
                // Then sum probabilities after x
                for (let i = x + 1; i <= n; i++) {
                    ans += table[i];
                }
            } 
            else if (con === '5') {
                // x or more successes (x included)
                // First generate full table
                for (let i = 0; i <= n; i++) {
                    const prob = combination(n, i) * Math.pow(p, i) * Math.pow(1 - p, n - i);
                    table.push(prob);
                }
                // Then sum probabilities from x onward
                for (let i = x; i <= n; i++) {
                    ans += table[i];
                }
            }

            result.param.tech_ans = ans;
            result.param.tech_table = table;
            return result.param;
        } else {
            result.param.error = "Please check your input";
            return result.param;
        }
    }

    /** getCalculationInvnormCalculator
   * POST: /api/calculators-lol/invnorm-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async  getCalculationInvnormCalculator(body) {
    let sd = parseFloat(body.tech_sd);
    let mean = parseFloat(body.tech_mean);
    let p = parseFloat(body.tech_p);

    let param = {};

    if (p < 0 || p > 1) {
      param.error = "The probability must be between 0 and 1";
      return param;
    }

    if (isNaN(sd) || isNaN(mean) || isNaN(p)) {
      param.error = "Please check your input.";
      return param;
    }

    function zinv(p) {
      const a1 = -39.6968302866538;
      const a2 = 220.946098424521;
      const a3 = -275.928510446969;
      const a4 = 138.357751867269;
      const a5 = -30.6647980661472;
      const a6 = 2.50662827745924;

      const b1 = -54.4760987982241;
      const b2 = 161.585836858041;
      const b3 = -155.698979859887;
      const b4 = 66.8013118877197;
      const b5 = -13.2806815528857;

      const c1 = -0.00778489400243029;
      const c2 = -0.322396458041136;
      const c3 = -2.40075827716184;
      const c4 = -2.54973253934373;
      const c5 = 4.37466414146497;
      const c6 = 2.93816398269878;

      const d1 = 0.00778469570904146;
      const d2 = 0.32246712907004;
      const d3 = 2.445134137143;
      const d4 = 3.75440866190742;

      const p_low = 0.02425;
      const p_high = 1 - p_low;

      let q, r, retVal;

      if (p < 0 || p > 1) {
        return 0;
      } else if (p < p_low) {
        q = Math.sqrt(-2 * Math.log(p));
        retVal = (((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6) /
                ((((d1 * q + d2) * q + d3) * q + d4) * q + 1);
      } else if (p <= p_high) {
        q = p - 0.5;
        r = q * q;
        retVal = (((((a1 * r + a2) * r + a3) * r + a4) * r + a5) * r + a6) * q /
                (((((b1 * r + b2) * r + b3) * r + b4) * r + b5) * r + 1);
      } else {
        q = Math.sqrt(-2 * Math.log(1 - p));
        retVal = -(((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6) /
                  ((((d1 * q + d2) * q + d3) * q + d4) * q + 1);
      }

      return retVal;
    }

    // Main calculations
    let x1 = zinv(p);
    let ll = -1 * (-1 * mean + sd * x1);
    let above = Math.round(1000000 * ll) / 1000000;

    x1 = zinv(p);
    let ul = mean + sd * x1;
    let blow = Math.round(1000000 * ul) / 1000000;

    let p2 = p / 2;
    x1 = zinv(0.5 - p2);
    ll = x1;
    ul = -1 * x1;
    ll = Math.round((mean + sd * ll) * 1000000) / 1000000;
    ul = Math.round((mean + sd * ul) * 1000000) / 1000000;

    x1 = zinv(p2);
    let ll1 = x1;
    let ul1 = -1 * x1;
    ll1 = Math.round((mean + sd * ll1) * 1000000) / 1000000;
    ul1 = Math.round((mean + sd * ul1) * 1000000) / 1000000;

    param.tech_above = above;
    param.tech_blow = blow;
    param.tech_ll = ll;
    param.tech_ul = ul;
    param.tech_ll1 = ll1;
    param.tech_ul1 = ul1;

    return param;
  }

    /** getCalculationLinearRegressionCalculator
   * POST: /api/calculators-lol/linear-regression-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLinearRegressionCalculator(body) {
    let x = body.tech_x;
    let y = body.tech_y;
    let estimate = body.tech_estimate;

    x = x.replace(/[\s,\n\r]+/g, ',').replace(/,+/g, ',');
    y = y.replace(/[\s,\n\r]+/g, ',').replace(/,+/g, ',');

    let numbers = x.split(',').map(v => v.trim()).filter(v => v !== '');
    let numbersy = y.split(',').map(v => v.trim()).filter(v => v !== '');

    let check = numbers.every(v => !isNaN(v)) && numbersy.every(v => !isNaN(v));

    let estimateArr = [];
    let checkEstimate = false;
    if (estimate && estimate.trim() !== '') {
      estimateArr = estimate.split(',').map(v => v.trim());
      checkEstimate = estimateArr.every(v => !isNaN(v));
    }

    if (!check) {
      return { error: "Please! Check Your Input" };
    }

    if (numbers.length !== numbersy.length) {
      return { error: "Please! Enter same number of values for X and Y" };
    }

    if (numbers.length > 100) {
      return { error: "This calculator support up to 100 number of values" };
    }

    numbers = numbers.map(Number);
    numbersy = numbersy.map(Number);

    const meanx = numbers.reduce((a, b) => a + b, 0) / numbers.length;
    const meany = numbersy.reduce((a, b) => a + b, 0) / numbersy.length;

    let arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];

    for (let i = 0; i < numbers.length; i++) {
      let dx = numbers[i] - meanx;
      let dy = numbersy[i] - meany;
      arr1.push(Number(dx.toFixed(5)));
      arr2.push(Number((dx * dx).toFixed(5)));
      arr3.push(Number(dy.toFixed(5)));
      arr4.push(Number((dy * dy).toFixed(5)));
      arr5.push(Number((dx * dy).toFixed(5)));
    }

    const ssx = arr2.reduce((a, b) => a + b, 0);
    const sp = arr5.reduce((a, b) => a + b, 0);
    const b = sp / ssx;
    const a = meany - b * meanx;

    let linex = [], liney = [];
    for (let i = 0; i <= Math.max(...numbers) + 1; i += 0.1) {
      linex.push(i);
      liney.push(Number((b * i + a).toFixed(5)));
    }

    let result = {
      tech_a: Number(a.toFixed(5)),
      tech_b: Number(b.toFixed(5)),
      tech_meanx:meanx,
      tech_meany:meany,
      tech_arr1:arr1,
      tech_arr2:arr2,
      tech_arr3:arr3,
      tech_arr5:arr5,
      tech_ssx:ssx,
      tech_sp:sp,
      tech_numbers:numbers,
      tech_numbersy:numbersy,
    };

    if (checkEstimate) {
      result.tech_estimate = estimateArr;
    }

    return result;
  }


    /** getCalculationOutliercalculator
   * POST: /api/calculators-lol/outlier-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async getCalculationOutliercalculator(body) {
      let x = body.tech_x;

      x = x.replace(/[\s,\n\r]+/g, ',').replace(/,+/g, ',');
      let numbers = x.split(',').map(v => v.trim()).filter(v => v !== '');

      let check = numbers.every(v => !isNaN(v));
      let values = numbers.map(Number).filter(v => !isNaN(v));

      if (!check) {
        return { error: "Please! Check Your Input" };
      }

      if (values.length < 4) {
        return { error: "Please! enter 4 or more numbers" };
      }

      values.sort((a, b) => a - b);
      let count = values.length;
      let median;

      if (count % 2 !== 0) {
        let center = Math.floor(count / 2);
        median = values[center];
      } else {
        let center = count / 2;
        median = (values[center - 1] + values[center]) / 2;
      }

      function quartile(arr) {
        let count = arr.length;
        let mid = Math.floor((count - 1) / 2);
        if (count % 2 !== 0) {
          return arr[mid];
        } else {
          return (arr[mid] + arr[mid + 1]) / 2;
        }
      }

      let second = quartile(values);

      let lowerHalf = values.filter(v => v < second);
      let upperHalf = values.filter(v => v > second);

      let first = quartile(lowerHalf);
      let third = quartile(upperHalf);

      let inner = third - first;
      let in_f1 = first - 1.5 * inner;
      let in_f2 = third + 1.5 * inner;

      let out_f1 = first - 3 * inner;
      let out_f2 = third + 3 * inner;

      let outlier = values.filter(v => v < in_f1 || v > in_f2);
      let poutlier = values.filter(v => v < out_f1 || v > out_f2);

      return {
        tech_values:values,
        tech_first:first,
        tech_third:third,
        tech_inner:inner,
        tech_in_f1:in_f1,
        tech_in_f2:in_f2,
        tech_out_f1:out_f1,
        tech_out_f2:out_f2,
        tech_outlier:outlier,
        tech_poutlier:poutlier,
        tech_median:median,
      };
    }

    /** getCalculationQuadraticRegressioncalculator
   * POST: /api/calculators-lol/quadratic-regression-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async getCalculationQuadraticRegressioncalculator(body) {
      let x = body.tech_x;
      let y = body.tech_y;

      x = x.replace(/[\s,\n\r]+/g, ',').replace(/,+/g, ',');
      y = y.replace(/[\s,\n\r]+/g, ',').replace(/,+/g, ',');

      let numbersx = x.split(',').map(v => v.trim()).filter(v => v !== '');
      let numbersy = y.split(',').map(v => v.trim()).filter(v => v !== '');

      if (numbersx.length !== numbersy.length) {
        return { error: "Please! Enter same number of values for X and Y" };
      }

      let xvalues = [], yvalues = [], check = true;

      for (let val of numbersx) {
        if (isNaN(val)) check = false;
        xvalues.push(Number(val));
      }

      for (let val of numbersy) {
        if (isNaN(val)) check = false;
        yvalues.push(Number(val));
      }

      if (!check) {
        return { error: "Please! Check Your Input" };
      }

      let count = xvalues.length;
      let meanx = +(xvalues.reduce((a, b) => a + b, 0) / count).toFixed(3);
      let meany = +(yvalues.reduce((a, b) => a + b, 0) / count).toFixed(3);
      let x2 = xvalues.map(v => v * v);
      let meanx2 = +(x2.reduce((a, b) => a + b, 0) / count).toFixed(3);

      let Sxx = [], Sxy = [], Sxx2 = [], Sx2x2 = [], Sx2y = [];

      for (let i = 0; i < count; i++) {
        let xi = xvalues[i];
        let yi = yvalues[i];
        let xi2 = xi * xi;

        Sxx.push((xi - meanx) * (xi - meanx));
        Sxy.push((xi - meanx) * (yi - meany));
        Sxx2.push((xi - meanx) * (xi2 - meanx2));
        Sx2x2.push((xi2 - meanx2) * (xi2 - meanx2));
        Sx2y.push((xi2 - meanx2) * (yi - meany));
      }

      let sum = arr => arr.reduce((a, b) => a + b, 0);
      let denom = sum(Sxx) * sum(Sx2x2) - Math.pow(sum(Sxx2), 2);

      let b = (sum(Sxy) * sum(Sx2x2) - sum(Sx2y) * sum(Sxx2)) / denom;
      let c = (sum(Sx2y) * sum(Sxx) - sum(Sxy) * sum(Sxx2)) / denom;
      let a = meany - (b * meanx) - (c * meanx2);

      let SSE = [], SST = [];

      for (let i = 0; i < count; i++) {
        let xi = xvalues[i];
        let yi = yvalues[i];
        let predicted = a + b * xi + c * xi * xi;
        SSE.push((yi - predicted) ** 2);
        SST.push((yi - meany) ** 2);
      }

      let r2 = 1 - (sum(SSE) / sum(SST));

      return {
        tech_xvalues:xvalues,
        tech_yvalues:yvalues,
        tech_meanx:meanx,
        tech_meanx2:meanx2,
        tech_meany:meany,
        tech_Sxx:Sxx,
        tech_Sxy:Sxy,
        tech_Sxx2:Sxx2,
        tech_Sx2x2:Sx2x2,
        tech_Sx2y:Sx2y,
        tech_SSE:SSE,
        tech_SST:SST,
        tech_a:a,
        tech_b:b,
        tech_c:c,
        tech_r2:r2,
      };
    }


    /** getCalculationPercentilecalculator
   * POST: /api/calculators-lol/percentile-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async getCalculationPercentilecalculator(body) {
      let p = parseFloat(body.p);
      let x = body.x;
      let separate = body.seprate || ' ';
      let advancedcheck = body.advancedcheck || false;

      if (!x || typeof x !== 'string') {
        return { error: "Please provide input numbers as a string in 'x'" };
      }

      let numbers = x.split(separate).map(item => item.trim()).filter(item => item !== '' && !isNaN(item)).map(Number);
      let check = numbers.length > 0 && numbers.every(num => typeof num === 'number' && !isNaN(num));

      if (!check) {
        return { error: "Please check your input." };
      }

      numbers.sort((a, b) => a - b);

      if (numbers.length < 2) {
        return { error: "Please! enter 2 or more numbers" };
      }

      if (p < 0 || p > 100) {
        return { error: "Please! Check Your Percentile percentage" };
      }

      let n = numbers.length;
      let p_per = p / 100;

      // Method 1
      let ab = p_per * n;
      let final_ans11 = Math.ceil(ab);
      let xy = final_ans11 - 1;
      let final_ans1 = numbers[xy];

      // Method 2
      let n_sum_method2 = n - 1;
      let ans_method2 = (p_per * n_sum_method2) + 1;
      let final_ans2;
      let ans2_method2, ceil_ans2, floor_ans2, diff2, b2, ans_diff2;

      if (!Number.isInteger(ans_method2)) {
        let decimalPart = ans_method2 % 1;
        ceil_ans2 = Math.ceil(ans_method2) - 1;
        floor_ans2 = Math.floor(ans_method2) - 1;
        diff2 = numbers[ceil_ans2] - numbers[floor_ans2];
        b2 = numbers[floor_ans2];
        ans_diff2 = decimalPart * diff2;
        final_ans2 = b2 + ans_diff2;
        ans2_method2 = decimalPart;
      } else {
        final_ans2 = numbers[ans_method2 - 1];
        ans2_method2 = 0;
      }

      // Method 3
      let n_sum = n + 1;
      let ans = n_sum * p_per;
      let final_ans;
      let ans2, ceil_ans, floor_ans, diff, b, ans_diff;

      if (!Number.isInteger(ans)) {
        let decimalPart = ans % 1;
        ceil_ans = Math.ceil(ans) - 1;
        floor_ans = Math.floor(ans) - 1;
        if (ceil_ans >= n) ceil_ans = n - 1;
        if (floor_ans >= n) floor_ans = n - 1;
        diff = numbers[ceil_ans] - numbers[floor_ans];
        b = numbers[floor_ans];
        ans_diff = decimalPart * diff;
        final_ans = b + ans_diff;
        ans2 = decimalPart;
      } else {
        final_ans = numbers[ans - 1];
        ans2 = 0;
      }

      let final_ans3 = [];

      if (advancedcheck === true) {
        for (let i = 0; i <= 100; i += 5) {
          let p_per3 = i / 100;
          let n_sum_method3 = n - 1;
          let ans_method3 = (p_per3 * n_sum_method3) + 1;
          let decimalPart3 = ans_method3 % 1;
          let ceil_ans3 = Math.ceil(ans_method3) - 1;
          let floor_ans3 = Math.floor(ans_method3) - 1;
          let diff3 = numbers[ceil_ans3] - numbers[floor_ans3];
          let b3 = numbers[floor_ans3];
          let ans_diff3 = decimalPart3 * diff3;
          final_ans3.push(b3 + ans_diff3);
        }
      }

      return {
        tech_final_ans:final_ans,
        tech_final_ans2:final_ans2,
        tech_final_ans1:final_ans1,
        tech_p:p,
        tech_n:n,
        tech_b:b,
        tech_ans:ans,
        tech_ans2:ans2,
        tech_n_sum:n_sum,
        tech_p_per:p_per,
        tech_numbers:numbers,
        tech_diff:diff,
        tech_ans_diff:ans_diff,
        tech_n_sum_method2:n_sum_method2,
        tech_ans_method2:ans_method2,
        tech_ans2_method2:ans2_method2,
        tech_ans_diff2:ans_diff2,
        tech_ab:ab,
        tech_final_ans11:final_ans11,
        tech_final_ans3: final_ans3.length ? final_ans3 : undefined,
      };
    }


    /** getCalculationStemAndLeafPlotcalculator
   * POST: /api/calculators-lol/stem-leaf-plot-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async  getCalculationStemAndLeafPlotcalculator(body) {
    let x = body.tech_x;

    if (!x) {
      return { error: "Please check your input." };
    }

    x = x.replace(/[\s,\n\r]+/g, ",");
    while (x.includes(",,"))
      x = x.replace(",,", ",");

    let numbers = x.split(",").map(v => v.trim()).filter(v => v !== "");
    let values = [...numbers].map(Number).sort((a, b) => a - b);

    if (values.length > 1000) {
      return { error: "You can enter up to 1000 numbers" };
    }

    let newObj = {};
    for (let value of values) {
      if (isNaN(value)) {
        return { error: "Please! Enter Valid Input" };
      }
      if (value > 9999) {
        return { error: "Single data points limited to 4 digits. (from 1 to 9999)" };
      }

      const strVal = String(value);
      if (strVal.length === 1) {
        if (!newObj[0]) newObj[0] = [];
        newObj[0].push(strVal);
      } else {
        const stem = strVal.slice(0, -1);
        const leaf = strVal.slice(-1);
        if (!newObj[stem]) newObj[stem] = [];
        newObj[stem].push(leaf);
      }
    }

    const min = Math.min(...values);
    const max = Math.max(...values);
    const count = values.length;
    const sum = values.reduce((a, b) => a + b, 0);
    const range = max - min;
    const mean = Number((sum / count).toFixed(5));

    let median;
    if (count % 2 !== 0) {
      const center = Math.floor(count / 2);
      median = values[center];
    } else {
      const mid = count / 2;
      median = (values[mid - 1] + values[mid]) / 2;
    }

    const freqMap = {};
    for (let val of values) {
      freqMap[val] = (freqMap[val] || 0) + 1;
    }

    const maxFreq = Math.max(...Object.values(freqMap));
    const mode = Object.keys(freqMap).filter(k => freqMap[k] === maxFreq);

    const variance = values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / (count - 1);
    const SD = Math.sqrt(variance);

    return {
      tech_new: newObj,
      tech_min:min,
      tech_max:max,
      tech_count:count,
      tech_sum:sum,
      tech_range:range,
      tech_mean:mean,
      tech_median:median,
      tech_mode:mode,
      tech_SD:SD,
      tech_var: variance,
    };
  }

      /** getCalculationShannonDiversityIndexcalculator
   * POST: /api/calculators-lol/shannon-diversity-index-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async  getCalculationShannonDiversityIndexcalculator(body) {
    let x = body.tech_x;
    let seprate = body.tech_seprate;

    if (!x) {
      return { error: "Please! Check Your Input" };
    }

    if (!seprate || seprate === '') {
      seprate = ' ';
    }

    let numbers = x.split(seprate).map(v => v.trim()).filter(v => v !== "");
    let allNumeric = numbers.every(val => !isNaN(val));

    if (!allNumeric) {
      return { error: "Please! Check Your Input" };
    }

    numbers = numbers.map(Number);

    let sum = 0;
    let sum_of_squares = 0;
    let sum3 = 0;
    let sum2 = 0;
    let count_number = numbers.length;
    let array_sum = numbers.reduce((a, b) => a + b, 0);
    let array_sum2 = (array_sum * array_sum) - 1;
    let maximum = Math.max(...numbers);

    for (let i = 0; i < count_number; i++) {
      sum_of_squares = numbers[i] * (numbers[i] - 1);
      let ratio = numbers[i] / array_sum;
      let take_log = Math.log(ratio);
      let final_log = take_log * ratio;
      sum += final_log;
      sum2 += sum_of_squares;
      let calculate_d = (numbers[i] * numbers[i]) / (array_sum * array_sum);
      sum3 += calculate_d;
    }

    let simpson_index = sum2 / array_sum2;

    return {
      tech_shannon_diversity: sum,
      tech_count_elements: Math.log(count_number),
      tech_hitman: count_number,
      tech_sum: array_sum,
      tech_max: maximum,
      tech_simpson_index:simpson_index,
      tech_sum3:sum3,
    };
  }


      /** getCalculationDegreesOfFreedomcalculator
   * POST: /api/calculators-lol/degrees-of-freedom-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDegreesOfFreedomcalculator(body) {
      let sample_size = body.sample_size;
      let sample_size_one = body.sample_size_one;
      let sample_size_two = body.sample_size_two;
      let variance_one = body.variance_one;
      let variance_two = body.variance_two;
      let c1 = body.c1;
      let r1 = body.r1;
      let k1 = body.k1;
      let d1 = body.d1;
      let d2 = body.d2;
      let selection = body.selection;
      let h = body.h;
      let sample_mean = body.sample_mean;
      let standard_deviation_three = body.standard_deviation_three;

    let param = {};
    let degrees_of_freedom;

    switch (selection) {
      case "1":
        if (!isNaN(sample_size) && Number.isInteger(+sample_size) && sample_size > 0) {
          degrees_of_freedom = sample_size - 1;
        } else {
          return { error: "Please! Check Your Input" };
        }
        break;

      case "2":
        if (!isNaN(sample_size_one) && !isNaN(sample_size_two) && sample_size_one > 0 && sample_size_two > 0) {
          degrees_of_freedom = (sample_size_one + sample_size_two);
          degrees_of_freedom = degrees_of_freedom - 2;
          console.log(degrees_of_freedom)
        } else {
          return { error: "Please! Check Your Input" };
        }
        break;

      case "3":
        if (!isNaN(sample_size_one) && !isNaN(sample_size_two) && sample_size_one > 0 && sample_size_two > 0 &&
            !isNaN(variance_one) && !isNaN(variance_two)) {
          d1 = ((variance_one / sample_size_one) + (variance_two / sample_size_two));
          let d2_sq = Math.pow(d1, 2);
          let d3 = ((variance_one * variance_one) / (Math.pow(sample_size_one, 2) * (sample_size_one - 1)));
          let d4 = ((variance_two * variance_two) / (Math.pow(sample_size_two, 2) * (sample_size_two - 1)));
          degrees_of_freedom = d2_sq / (d3 + d4);
          param.tech_v1 = Math.sqrt(variance_one);
          param.tech_v2 = Math.sqrt(variance_two);
        } else {
          return { error: "Please! Check Your Input" };
        }
        break;

      case "4": // Chi-square
        if (!isNaN(r1) && !isNaN(c1) && r1 > 0 && c1 > 0) {
          degrees_of_freedom = (r1 - 1) * (c1 - 1);
          param.tech_degrees_of_freedom = degrees_of_freedom;
          return param;
        } else {
          return { error: "Please! Check Your Input" };
        }

      case "5":
        if (!isNaN(sample_size) && !isNaN(k1) && k1 > 0 && sample_size > 0) {
          let d3 = k1 - 1;
          let d2 = sample_size - k1;
          degrees_of_freedom = sample_size - 1;
          param.tech_d2 = d2;
          param.tech_d3 = d3;
        } else {
          return { error: "Please! Check Your Input" };
        }
        break;

      case "6":
        if (!isNaN(sample_size) && !isNaN(h) && !isNaN(sample_mean) &&
            !isNaN(standard_deviation_three) && sample_size > 0 && standard_deviation_three > 0) {
          let t_statistic = (sample_mean - h) / (standard_deviation_three / Math.sqrt(sample_size));
          param.tech_t_statistic = t_statistic;
          degrees_of_freedom = sample_size - 1;
        } else {
          return { error: "Please! Check Your Input" };
        }
        break;

      default:
        return { error: "Invalid selection value" };
    }

    param.tech_degrees_of_freedom = degrees_of_freedom;
    return param;
  }


      /** getCalculationMidrangecalculator
   * POST: /api/calculators-lol/midrange-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async  getCalculationMidrangecalculator(body) {
    let x = body.tech_x;

    if (!x || typeof x !== 'string') {
      return { error: "Please! Check Your Input" };
    }
  function isNumeric(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  }
    // Normalize input string
    x = x.replace(/[\s,\n\r]+/g, ',');
    while (x.includes(',,')) {
      x = x.replace(/,,/g, ',');
    }

    let numbers = x.split(',').map(str => str.trim()).filter(str => str !== '');

    for (let val of numbers) {
      if (!isNumeric(val)) {
        return { error: "Please! Check Your Input" };
      }
    }

    let values = numbers.map(Number);
    values.sort((a, b) => a - b);

    let min = Math.min(...values);
    let max = Math.max(...values);
    let count = values.length;
    let sum = values.reduce((acc, cur) => acc + cur, 0);
    let range = max - min;
    let mean = parseFloat((sum / count).toFixed(5));

    let median;
    if (count % 2 !== 0) {
      median = values[Math.floor(count / 2)];
    } else {
      median = (values[count / 2 - 1] + values[count / 2]) / 2;
    }

    // Mode
    let freq = {};
    let mode = [];
    let maxFreq = 0;

    for (let val of values) {
      freq[val] = (freq[val] || 0) + 1;
      if (freq[val] > maxFreq) {
        maxFreq = freq[val];
      }
    }

    for (let key in freq) {
      if (freq[key] === maxFreq) {
        mode.push(Number(key));
      }
    }

    // Variance and Standard Deviation
    let variance = values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / (count - 1);
    let SD = Math.sqrt(variance);
    let ans = (min + max) / 2;

    return {
      tech_ans:ans,
      tech_min:min,
      tech_max:max,
      tech_count:count,
      tech_sum:sum,
      tech_range:range,
      tech_mean:mean,
      tech_median:median,
      tech_mode:mode,
      tech_SD:SD,
      tech_var: variance,
    };
  }


      /** getCalculationRSDcalculator
   * POST: /api/calculators-lol/rsd-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationRSDcalculator(body) {
      let x = body.tech_x;
      let form = body.tech_form;
      let mean = body.tech_mean;
      let deviation = body.tech_deviation;
    // Helper function
    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }

      if (form === 'raw') {
        if (!x || typeof x !== 'string') {
          return { error: "Please! Check Your Input" };
        }

        // Normalize input
        x = x.replace(/[\s,\n\r]+/g, ',');
        while (x.includes(',,')) {
          x = x.replace(/,,/g, ',');
        }

        let numbers = x.split(',').map(str => str.trim()).filter(str => str !== '');

        for (let val of numbers) {
          if (!isNumeric(val)) {
            return { error: "Please! Check Your Input" };
          }
        }

        let values = numbers.map(Number).sort((a, b) => a - b);
        let min = Math.min(...values);
        let max = Math.max(...values);
        let count = values.length;
        let sum = values.reduce((a, b) => a + b, 0);
        let range = max - min;
        mean = parseFloat((sum / count).toFixed(5));

        let median;
        if (count % 2 !== 0) {
          median = values[Math.floor(count / 2)];
        } else {
          median = (values[count / 2 - 1] + values[count / 2]) / 2;
        }

        // Mode
        let freq = {};
        let mode = [];
        let maxFreq = 0;

        for (let val of values) {
          freq[val] = (freq[val] || 0) + 1;
          if (freq[val] > maxFreq) {
            maxFreq = freq[val];
          }
        }

        for (let key in freq) {
          if (freq[key] === maxFreq) {
            mode.push(Number(key));
          }
        }

        // Standard deviation, variance
        let d = values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0);
        let s_d = d / (count - 1);
        let psd = d / count;
        let SD = Math.sqrt(s_d);
        let PSD = Math.sqrt(psd);
        let rsd = (SD / mean) * 100;

        return {
          tech_rsd:rsd,
          tech_min:min,
          tech_max:max,
          tech_count:count,
          tech_sum:sum,
          tech_range:range,
          tech_mean:mean,
          tech_median:median,
          tech_mode:mode,
          tech_SD:SD,
          tech_PSD:PSD,
          tech_svar: s_d,
          tech_pvar: psd,
          tech_form:form,
        };
      } else {
        if (isNumeric(mean) && isNumeric(deviation)) {
        let rsd = (deviation / mean) * 100;
          return {
            tech_rsd:rsd,
            tech_form:form,
          };
        } else {
          return { error: "Please! Check Your Input" };
        }
      }
    }
      /** getCalculationChebyshevTheoremcalculator
   * POST: /api/calculators-lol/chebyshevs-theorem-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationChebyshevTheoremcalculator(body) {
    let operations = body.tech_operations;
    let first = body.tech_first;
    let second = body.tech_second;

    let result = {};
    let pehla, final_fans, final_sans;

    if (operations === 3) {
      if (first > 1) {
        if (second > 1) {
          let sq = Math.pow(first, 2);
          let f_ans = second / sq;
          final_fans = f_ans.toFixed(3);
          let s_ans = f_ans * 100;
          final_sans = s_ans >= 100 ? "100" : s_ans.toFixed(2);
          pehla = first;
        } else {
          return { error: "Please variance enter greater than 1" };
        }
      } else {
        return { error: "Please bound enter greater than 1." };
      }
    } else if (operations === 4) {
      if (first > 1) {
        if (second > 1) {
          let sq = Math.pow(first, 2);
          let f_ans = first * 4;
          let aja = 1 / sq;
          final_fans = aja.toFixed(3);
          let s_ans = aja * 100;
          final_sans = s_ans >= 100 ? "100" : s_ans.toFixed(2);
          pehla = f_ans;
        } else {
          return { error: "Please variance enter greater than 1" };
        }
      } else {
        return { error: "Please bound enter greater than 1." };
      }
    } else if (operations === 5) {
      if (first > 1) {
        pehla = Math.pow(first, 2);
        let aja = 1 / pehla;
        final_fans = aja.toFixed(3);
        final_sans = (1 - aja).toFixed(3);
      } else {
        return { error: "Please bound enter greater than 1." };
      }
    } else if (operations === 6) {
      if (first > 1) {
        pehla = 1 - first;
        let aja = 1 / pehla;
        final_fans = aja.toFixed(3);
        final_sans = aja >= 0 ? Math.sqrt(aja).toFixed(3) : "NaN";
      } else {
        return { error: "Please bound enter greater than 1." };
      }
    } else {
      return { error: "Invalid operation code" };
    }

    result.tech_operations = operations;
    result.tech_pehla = pehla;
    result.tech_final_fans = final_fans;
    result.tech_final_sans = final_sans;

    return result;
  }


      /** getCalculationBoxPlotcalculator
   * POST: /api/calculators-lol/box-plot-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationBoxPlotcalculator(body) {
      let x = body.tech_x;
      let seprate = body.tech_seprate;

      function quartil(arr) {
        let count = arr.length;
        let middleval = Math.floor((count - 1) / 2);
        let median;
        if (count % 2) {
          median = arr[middleval];
        } else {
          let low = arr[middleval];
          let high = arr[middleval + 1];
          median = (low + high) / 2;
        }
        return parseFloat(median.toFixed(1));
      }

      if (!x || x.trim() === "") {
        return { error: "Please! Check Your Input" };
      }

      if (!seprate) {
        seprate = " ";
      }

      let check = true;
      x = x.replace(/[\s,\n\r]+/g, ",");
      while (x.includes(",,"))
        x = x.replace(/,,/g, ",");

      let numbers = x.split(",").map(s => s.trim()).filter(s => s !== "");
      for (let value of numbers) {
        if (isNaN(value)) {
          check = false;
        }
      }

      if (!check) {
        return { error: "Please! Check Your Input" };
      }

      numbers = numbers.map(Number).sort((a, b) => a - b);

      if (numbers.length < 2) {
        return { error: "Please! enter 2 or more numbers" };
      }

      let maximum = Math.max(...numbers);
      let minimum = Math.min(...numbers);
      let second = quartil(numbers);

      let tmp = { first: [], third: [] };
      for (let val of numbers) {
        if (val > second) {
          tmp.third.push(val);
        } else if (val < second) {
          tmp.first.push(val);
        }
      }

      let first = quartil(tmp.first);
      let third = quartil(tmp.third);

      let count = numbers.length;
      let median;
      if (count % 2 !== 0) {
        let center = Math.floor(count / 2);
        median = numbers[center];
      } else {
        let center = count / 2;
        median = (numbers[center] + numbers[center - 1]) / 2;
      }

      return {
        tech_numbers: numbers,
        tech_count: count,
        tech_first: first,
        tech_third: third,
        tech_median: median,
        tech_maximum: maximum,
      };
    }


      /** getCalculationCoinFlipcalculator
   * POST: /api/calculators-lol/coin-flip-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

async  getCalculationCoinFlipcalculator(body) {
  let flips = Number(body.tech_flips);
  let heads = Number(body.tech_heads);
  let probablity = Number(body.tech_probablity);
  let type = body.tech_type;

  function factorial(num) {
    let result = 1;
    for (let i = num; i >= 1; i--) {
      result *= i;
    }
    return result;
  }

  function total_calculation(flips, heads, prob2) {
    let sub = flips - heads;
    let f4 = factorial(flips);
    let f5 = factorial(heads);
    let f6 = factorial(sub);
    let power = Math.pow(prob2, heads);
    let power2 = Math.pow(1 - prob2, sub);
    return (f4 / (f5 * f6)) * power * power2;
  }

  if (!["1", "2", "3"].includes(type) || isNaN(flips) || isNaN(heads) || isNaN(probablity)) {
    return { error: "Please! Check Your Input" };
  }

  if (flips < heads) {
    return { error: "The number of obtained heads cannot be greater than the number of tosses." };
  }

  if ((type === "1" && (flips <= 0 || heads <= 0)) || (type !== "1" && (flips < 0 || heads < 0))) {
    return { error: "Enter Value Greater than zero" };
  }

  if (probablity < 0 || probablity > 1) {
    return { error: "Probablity must be between 0 and 1 inclusive" };
  }

  let sub = flips - heads;
  let f1 = factorial(flips);
  let f2 = factorial(heads);
  let f3 = factorial(sub);
  let powerP = Math.pow(probablity, heads);
  let powerP2 = Math.pow(1 - probablity, sub);
  let ans = (f1 / (f2 * f3)) * powerP * powerP2;

  let param = {
    tech_type:type,
    tech_flips:flips,
    tech_heads:heads,
    tech_probablity:probablity,
    tech_ans:ans,
  };

  if (type === "2") {
    let awa = [];
    for (let i = heads + 1; i <= flips; i++) {
      awa.push(total_calculation(flips, i, probablity));
    }
    param.tech_array_awa = awa;
    param.tech_summer = awa.reduce((a, b) => a + b, 0);
  }

  if (type === "3") {
    let awa = [];
    for (let i = 0; i <= heads; i++) {
      awa.push(total_calculation(flips, i, probablity));
    }
    param.tech_array_awa = awa;
    param.tech_summer = awa.reduce((a, b) => a + b, 0);
  }

  return param;
}

      /** getCalculationPercentileRankcalculator
   * POST: /api/calculators-lol/percentile-rank-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationPercentileRankcalculator(body) {
      let x = body.tech_x;
      let find = Number(body.tech_find);
      let method = Number(body.tech_method);

      if (x && !isNaN(find)) {
        // Clean and normalize input string
        x = x.replace(/[\s,\n\r]+/g, ',');
        while (x.includes(',,')) {
          x = x.replace(/,,/g, ',');
        }

        // Parse numbers
        let numbers = x.split(',').map(item => item.trim()).filter(item => item !== '');
        let values = [];
        let isNum = true;

        for (let i = 0; i < numbers.length; i++) {
          if (!isNaN(numbers[i])) {
            values.push(Number(numbers[i]));
          } else {
            isNum = false;
            break;
          }
        }

        if (isNum) {
          values.sort((a, b) => a - b);
          let count = 0;
          let same = 0;

          for (let i = 0; i < values.length; i++) {
            if (values[i] <= find) count++;
            if (values[i] === find) same++;
          }

          let pr;
          if (method === 1) {
            pr = (count / values.length) * 100;
          } else {
            pr = ((count - 0.5 * same) / values.length) * 100;
          }

          return {
            tech_pr:pr,
            tech_same:same,
            tech_count:count,
            tech_find:find,
            tech_values:values,
          };
        } else {
          return { error: "Please! Enter only numbers" };
        }
      } else {
        return { error: "Please! Check Your Input" };
      }
    }


      /** getCalculationSSEcalculator
   * POST: /api/calculators-lol/sse-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationSSEcalculator(body) {
      let x = body.tech_x;
      let y = body.tech_y;

      function sigFig(value, digits) {
        if (value === '') return null;
        if (value === 0) {
          return 0;
        }
        const decimalPlaces = digits - Math.floor(Math.log10(Math.abs(value))) - 1;
        return parseFloat(value.toFixed(decimalPlaces));
      }

      if (!x || !y) {
        return { error: "Please! Check Your Input" };
      }

      x = x.split(',').map(val => val.trim()).filter(val => val !== '');
      y = y.split(',').map(val => val.trim()).filter(val => val !== '');
      const n = x.length;

      if (n !== y.length) {
        return { error: "The number of values should be same in both sample data inputs." };
      }

      let check = true;
      x = x.map((val, i) => {
        if (isNaN(val) || isNaN(y[i])) {
          check = false;
        }
        return Number(val);
      });
      y = y.map(Number);

      if (!check) {
        return { error: "Please! Check Your Input" };
      }

      let xi_sum = 0;
      let yi_sum = 0;
      let xy_sum = 0;

      for (let i = 0; i < n; i++) {
        xi_sum += x[i] ** 2;
        yi_sum += y[i] ** 2;
        xy_sum += x[i] * y[i];
      }

      const x_sum = x.reduce((a, b) => a + b, 0);
      const y_sum = y.reduce((a, b) => a + b, 0);

      const ss_xx = xi_sum - (x_sum ** 2 / n);
      const ss_yy = yi_sum - (y_sum ** 2 / n);
      const ss_xy = xy_sum - (x_sum * y_sum / n);
      const beta_1 = ss_xy / ss_xx;
      const beta_0 = (y_sum / n) - beta_1 * (x_sum / n);
      const ss_r = beta_1 * ss_xy;
      const ss_e = ss_yy - ss_r;

      return {
        tech_x:x,
        tech_y:y,
        tech_n:n,
        tech_x_sum:x_sum,
        tech_xi_sum:xi_sum,
        tech_y_sum:y_sum,
        tech_yi_sum:yi_sum,
        tech_xy_sum:xy_sum,
        tech_ss_xx:ss_xx,
        tech_ss_yy:ss_yy,
        tech_ss_xy:ss_xy,
        tech_beta_1:beta_1,
        tech_beta_0:beta_0,
        tech_ss_r:ss_r,
        tech_ss_e: sigFig(ss_e, 5),
      };
    }

      /** getCalculationPredictionIntervalcalculator
   * POST: /api/calculators-lol/prediction-interval-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async  getCalculationPredictionIntervalcalculator(body) {
    let x = body.tech_x;
    let y = body.tech_y;
    let confidence = parseFloat(body.tech_confidence);
    let prediction = parseFloat(body.tech_prediction);

    let number = true;
    let equal = false;
    let array_num = 0;
    let x_sqr = [];
    let y_sqr = [];
    let x_sqr_sum = 0;
    let y_sqr_sum = 0;
    let x_mul_y = [];
    let xy_sum = 0;
    let x_sum = 0;
    let y_sum = 0;

    x = x.replace(/[\s,\n\r]+/g, ",");
    y = y.replace(/[\s,\n\r]+/g, ",");

    let array_x = x.split(",").map(val => val.trim()).filter(val => val !== '');
    let array_y = y.split(",").map(val => val.trim()).filter(val => val !== '');

    let level = 1 - confidence;
    let confidence_per = (confidence * 100).toFixed(0) + "%";

    array_x.forEach(val => {
      if (isNaN(val)) number = false;
    });
    array_y.forEach(val => {
      if (isNaN(val)) number = false;
    });

    if (array_x.length === array_y.length) {
      equal = true;
    }

    if (number && equal && !isNaN(confidence) && !isNaN(prediction)) {
      array_x = array_x.map(Number);
      array_y = array_y.map(Number);
      array_num = array_x.length;
      x_sum = array_x.reduce((a, b) => a + b, 0);
      y_sum = array_y.reduce((a, b) => a + b, 0);

      x_sqr = array_x.map(n => n ** 2);
      y_sqr = array_y.map(n => n ** 2);

      x_sqr_sum = x_sqr.reduce((a, b) => a + b, 0);
      y_sqr_sum = y_sqr.reduce((a, b) => a + b, 0);

      for (let i = 0; i < array_num; i++) {
        x_mul_y[i] = array_x[i] * array_y[i];
      }

      xy_sum = x_mul_y.reduce((a, b) => a + b, 0);

      let ssxx = parseFloat((x_sqr_sum - (1 / array_num) * (x_sum ** 2)).toFixed(4));
      let ssyy = parseFloat((y_sqr_sum - (1 / array_num) * (y_sum ** 2)).toFixed(4));
      let ssxy = parseFloat((xy_sum - (1 / array_num) * x_sum * y_sum).toFixed(4));

      let mean_x = parseFloat((x_sum / array_num).toFixed(4));
      let mean_y = parseFloat((y_sum / array_num).toFixed(4));

      let b1 = parseFloat((ssxy / ssxx).toFixed(4));
      let b0 = parseFloat((mean_y - b1 * mean_x).toFixed(4));
      let Y = parseFloat((b0 + b1 * prediction).toFixed(4));

      let ssRegression = parseFloat((b1 * ssxy).toFixed(4));
      let ssError = parseFloat((ssyy - ssRegression).toFixed(4));
      let mse = parseFloat((ssError / (array_num - 2)).toFixed(4));
      let errorEst = parseFloat(Math.sqrt(mse).toFixed(4));

      let E = parseFloat(
        (2.16 * Math.sqrt(mse * (1 + (1 / array_num) + ((prediction - mean_x) ** 2 / ssxx)))).toFixed(4)
      );

      let piPov = Y - E;
      let piNeg = Y + E;

      return {
        tech_confidence_per:confidence_per,
        tech_level:level,
        tech_prediction:prediction,
        tech_array_num:array_num,
        tech_array_x:array_x,
        tech_array_y:array_y,
        tech_x_sum:x_sum,
        tech_y_sum:y_sum,
        tech_x_sqr:x_sqr,
        tech_y_sqr:y_sqr,
        tech_x_sqr_sum:x_sqr_sum,
        tech_y_sqr_sum:y_sqr_sum,
        tech_x_mul_y:x_mul_y,
        tech_xy_sum:xy_sum,
        tech_ssxx:ssxx,
        tech_ssyy:ssyy,
        tech_ssxy:ssxy,
        tech_mean_x:mean_x,
        tech_mean_y:mean_y,
        tech_b1:b1,
        tech_b0:b0,
        tech_Y:Y,
        tech_ssRegression:ssRegression,
        tech_ssError:ssError,
        tech_mse:mse,
        tech_errorEst:errorEst,
        tech_E:E,
        tech_piPov:piPov,
        tech_piNeg:piNeg,
      };
    } else {
      return { error: "Please! Check Your Input" };
    }
  }


      /** getCalculationScatterPlotMakercalculator
   * POST: /api/calculators-lol/scatter-plot-maker
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async  getCalculationScatterPlotMakercalculator(body) {
    let x = body.tech_x;
    let y = body.tech_y;
    let title = body.tech_title;
    let xaxis = body.tech_xaxis;
    let yaxis = body.tech_yaxis;
    let xmin = body.tech_xmin;
    let xmax = body.tech_xmax;
    let ymin = body.tech_ymin;
    let ymax = body.tech_ymax;
    let position = body.tech_position;
    let align = body.tech_align;

    if ((!x || x.trim() === "") && (!y || y.trim() === "")) {
      return { error: "Please! Check Your Input" };
    }

    x = x.replace(/[\s,\n\r]+/g, ",");
    y = y.replace(/[\s,\n\r]+/g, ",");

    let xArr = x.split(",").map(val => val.trim()).filter(val => val !== '');
    let yArr = y.split(",").map(val => val.trim()).filter(val => val !== '');

    let n = xArr.length;
    if (n !== yArr.length) {
      return {
        error: "The number of values should be same in both sample data inputs."
      };
    }

    let check = true;
    for (let i = 0; i < n; i++) {
      if (isNaN(xArr[i]) || isNaN(yArr[i])) {
        check = false;
      }
    }

    if (!check) {
      return { error: "Invalid numeric values in x or y array." };
    }

    if (!title || title.trim() === "") title = "Scatter Plot";
    if (!xaxis || xaxis.trim() === "") xaxis = "X";
    if (!yaxis || yaxis.trim() === "") yaxis = "Y";

    return {
      tech_x: xArr.map(Number),
      tech_y: yArr.map(Number),
      tech_title:title,
      tech_xaxis:xaxis,
      tech_yaxis:yaxis,
      tech_xmin:xmin,
      tech_xmax:xmax,
      tech_ymin:ymin,
      tech_ymax:ymax,
      tech_position:position,
      tech_align:align,
    };
  }


      /** getCalculationResidualcalculator
   * POST: /api/calculators-lol/residual-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationResidualcalculator(body) {
      let x = body.tech_x;
      let y = body.tech_y;

      if ((!x || x.trim() === "") && (!y || y.trim() === "")) {
        return { error: "Please! Check Your Input" };
      }

      let xArr = x.split(',').map(val => val.trim()).filter(val => val !== '');
      let yArr = y.split(',').map(val => val.trim()).filter(val => val !== '');

      let n = xArr.length;
      if (n !== yArr.length) {
        return {
          error: "The number of values should be same in both data inputs."
        };
      }

      let check = true;
      for (let i = 0; i < n; i++) {
        if (isNaN(xArr[i]) || isNaN(yArr[i])) {
          check = false;
          break;
        }
      }

      if (!check) {
        return { error: "Please! Check Your Input" };
      }

      xArr = xArr.map(Number);
      yArr = yArr.map(Number);

      let xi_sum = 0, yi_sum = 0, xy_sum = 0;
      let y_bar = [], yy_bar = [];

      for (let i = 0; i < n; i++) {
        xi_sum += xArr[i] ** 2;
        yi_sum += yArr[i] ** 2;
        xy_sum += xArr[i] * yArr[i];
      }

      let x_sum = xArr.reduce((a, b) => a + b, 0);
      let y_sum = yArr.reduce((a, b) => a + b, 0);

      let ss_xx = xi_sum - (x_sum ** 2 / n);
      let ss_yy = yi_sum - (y_sum ** 2 / n);
      let ss_xy = xy_sum - ((x_sum * y_sum) / n);

      let beta_1 = ss_xy / ss_xx;
      let beta_0 = (y_sum / n) - beta_1 * (x_sum / n);

      for (let i = 0; i < n; i++) {
        let predicted = beta_0 + beta_1 * xArr[i];
        y_bar.push(predicted);
        yy_bar.push(yArr[i] - predicted);
      }

      return {
        tech_x: xArr,
        tech_y: yArr,
        tech_n:n,
        tech_x_sum:x_sum,
        tech_xi_sum:xi_sum,
        tech_y_sum:y_sum,
        tech_yi_sum:yi_sum,
        tech_xy_sum:xy_sum,
        tech_ss_xx:ss_xx,
        tech_ss_yy:ss_yy,
        tech_ss_xy:ss_xy,
        tech_beta_1:beta_1,
        tech_beta_0:beta_0,
        tech_y_bar:y_bar,
        tech_yy_bar:yy_bar,
      };
    }


      /** getCalculationResidualPlotcalculator
   * POST: /api/calculators-lol/residual-plot-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async getCalculationResidualPlotcalculator(body) {
      let x = body.tech_x;
      let y = body.tech_y;

      if (!x || !y) {
        return { error: "Please! Check Your Input" };
      }

      let xArr = x.split(',').map(val => val.trim()).filter(val => val !== '');
      let yArr = y.split(',').map(val => val.trim()).filter(val => val !== '');

      let n = xArr.length;
      if (n !== yArr.length) {
        return {
          error: "The number of values should be same in both data inputs."
        };
      }

      let check = true;
      for (let i = 0; i < n; i++) {
        if (isNaN(xArr[i]) || isNaN(yArr[i])) {
          check = false;
          break;
        }
      }

      if (!check) {
        return { error: "Please! Check Your Input" };
      }

      // Convert strings to numbers
      let xNums = xArr.map(Number);
      let yNums = yArr.map(Number);

      let xi_sum = 0;
      let yi_sum = 0;
      let xy_sum = 0;

      for (let i = 0; i < n; i++) {
        xi_sum += xNums[i] ** 2;
        yi_sum += yNums[i] ** 2;
        xy_sum += xNums[i] * yNums[i];
      }

      let x_sum = xNums.reduce((a, b) => a + b, 0);
      let y_sum = yNums.reduce((a, b) => a + b, 0);

      let ss_xx = xi_sum - (x_sum ** 2) / n;
      let ss_yy = yi_sum - (y_sum ** 2) / n;
      let ss_xy = xy_sum - (x_sum * y_sum) / n;

      let beta_1 = ss_xy / ss_xx;
      let beta_0 = (y_sum / n) - beta_1 * (x_sum / n);

      let y_bar = [];
      let yy_bar = [];

      for (let i = 0; i < n; i++) {
        let predicted = beta_0 + beta_1 * xNums[i];
        y_bar.push(predicted);
        yy_bar.push(yNums[i] - predicted);
      }

      return {
        tech_x: xNums,
        tech_y: yNums,
        tech_n: n,
        tech_x_sum: x_sum,
        tech_y_sum: y_sum,
        tech_xi_sum: xi_sum,
        tech_yi_sum: yi_sum,
        tech_xy_sum: xy_sum,
        tech_ss_xx: ss_xx,
        tech_ss_yy: ss_yy,
        tech_ss_xy: ss_xy,
        tech_beta_0: beta_0,
        tech_beta_1: beta_1,
        tech_y_bar: y_bar,
        tech_yy_bar: yy_bar
      };
    }

     /** getCalculationErrorPropagationcalculator
   * POST: /api/calculators-lol/error-propagation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationErrorPropagationcalculator(body) {
    let x = parseFloat(body.tech_x);
    let y = parseFloat(body.tech_y);
    let delta_x = parseFloat(body.tech_delta_x);
    let delta_y = parseFloat(body.tech_delta_y);
    let optionSelect = body.tech_optionSelect;

    if (isNaN(x) || isNaN(y)) {
      return { error: "Please! Check Your Input" };
    }

    let z, delta_z;

    if (optionSelect) {
      if (optionSelect === 'addition') {
        z = x + y;
        delta_z = Math.sqrt(Math.pow(delta_x, 2) + Math.pow(delta_y, 2));
      } else if (optionSelect === 'subtraction') {
        z = x - y;
        delta_z = Math.sqrt(Math.pow(delta_x, 2) + Math.pow(delta_y, 2));
      } else if (optionSelect === 'multiplication') {
        z = x * y;
        delta_z = z * Math.sqrt(Math.pow((delta_x / x), 2) + Math.pow((delta_y / y), 2));
      } else if (optionSelect === 'division') {
        z = x / y;
        delta_z = z * Math.sqrt(Math.pow((delta_x / x), 2) + Math.pow((delta_y / y), 2));
      } else {
        return { error: "Invalid operation type" };
      }
    } else {
      return { error: "Option select is required" };
    }

    return {
      tech_z: z,
      tech_delta_z: delta_z,
    };
  }



     /** getCalculationPieChartcalculator
   * POST: /api/calculators-lol/pie-chart-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async getCalculationPieChartcalculator(body) {
      let choices = body.tech_choices;

      if (!Array.isArray(choices) || choices.length === 0 || isNaN(choices[0])) {
        return { error: "Please! Check Your Input" };
      }

      // Sum of all values
      let sum = choices.reduce((acc, val) => acc + Number(val), 0);

      // Percentages
      let percentage = choices.map(value => {
        return Math.round((value / sum) * 100 * 100) / 100;
      });

      // Angles in degrees
      let degree = percentage.map(per => {
        return Math.round((per / 100) * 360);
      });

      // Letters (A, B, C, ...)
      let letters = [];
      for (let i = 0; i < choices.length; i++) {
        letters.push(String.fromCharCode(65 + i));
      }

      // Combine data for charting
      let dataPoints = choices.map((val, i) => ({
        y: val,
        label: letters[i]
      }));

      return {
        tech_letters: letters,
        tech_values: choices,
        tech_percentage: percentage,
        tech_degree: degree,
        tech_new_combine: JSON.stringify(dataPoints),
      };
    }


     /** getCalculationAccuracycalculator
   * POST: /api/calculators-lol/accuracy-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async getCalculationAccuracycalculator(body) {
      let true_positive = body.tech_true_positive?.trim();
      let false_negative = body.tech_false_negative?.trim();
      let false_positive = body.tech_false_positive?.trim();
      let true_negative = body.tech_true_negative?.trim();
      let prevalence = body.tech_prevalence?.trim();
      let sensitivity = body.tech_sensitivity?.trim();
      let specificity = body.tech_specificity?.trim();
      let observed_value = body.tech_observed_value?.trim();
      let accepted_value = body.tech_accepted_value?.trim();
      let method_unit = body.tech_method_unit?.trim();

      // Utility to check numeric
    function isNumeric(val) {
      return !isNaN(parseFloat(val)) && isFinite(val);
    }


      let answer;

      if (method_unit === "Standard method") {
        if (
          isNumeric(true_positive) &&
          isNumeric(false_negative) &&
          isNumeric(false_positive) &&
          isNumeric(true_negative)
        ) {
          let accu_add_sec = Number(true_positive) + Number(true_negative);
          let accu_add_all = accu_add_sec + Number(false_positive) + Number(false_negative);
          let accu_div = accu_add_sec / accu_add_all;
          answer = accu_div * 100;
        } else {
          return { error: "Please! Check Your Input" };
        }
      } else if (method_unit === "Prevalence method") {
        if (isNumeric(prevalence) && isNumeric(sensitivity) && isNumeric(specificity)) {
          prevalence = Number(prevalence) / 100;
          let accu_se_pre = Number(sensitivity) * prevalence + Number(specificity) * (1 - prevalence);
          answer = accu_se_pre;
        } else {
          return { error: "Please! Check Your Input" };
        }
      } else {
        if (isNumeric(observed_value) && isNumeric(accepted_value)) {
          if (Number(accepted_value) === 0) {
            return { error: "Accepted value cannot be equal to zero." };
          }
          let per_error = Number(observed_value) - Number(accepted_value);
          let error_per = Math.abs(per_error) / Number(accepted_value);
          answer = error_per * 100;
        } else {
          return { error: "Please! Check Your Input" };
        }
      }

      return {
        tech_answer: answer,
        tech_method_unit: method_unit,
      };
      }



     /** getCalculationSampleSizecalculator
   * POST: /api/calculators-lol/sample-size-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async getCalculationSampleSizecalculator(body) {
      let population = body.tech_population?.trim();
      let given_unit = body.tech_given_unit?.trim();
      let confidence_unit = body.tech_confidence_unit?.trim();
      let margin = body.tech_margin?.trim();
      let standard = body.tech_standard?.trim();
      let proportion = body.tech_proportion?.trim();
      let n_finite = body.tech_n_finite?.trim();


      function isNumeric(value) {
      return !isNaN(parseFloat(value)) && isFinite(value);
    }

      let param = {};
      let answer;

      // Convert confidence level to Z-score
      const confidenceMap = {
        "70%": 1.04, "75%": 1.15, "80%": 1.28,
        "85%": 1.44, "90%": 1.65, "95%": 1.96,
        "98%": 2.33, "99%": 2.58, "99.9%": 3.29
      };
      confidence_unit = confidenceMap[confidence_unit] || 4.42;

      if (margin === "0" || proportion === "0") {
        return { error: "Accepted value cannot be equal to zero." };
      }

      if (population === "sample") {
        if (given_unit === "standard") {
          if (isNumeric(margin) && isNumeric(standard)) {
            margin = Number(margin) / 100;
            standard = Number(standard);
            let multiply = confidence_unit * standard;
            let divide = multiply / margin;
            let sub_answer = divide * divide;
            answer = Math.round(sub_answer);

            return {
                tech_margin:margin,
                tech_standard:standard,
                tech_confidence_unit:confidence_unit,
                tech_multiply:multiply,
                tech_divide:divide, 
                tech_sub_answer:sub_answer,
                tech_answer:answer
            };
          } else {
            return { error: "Please! Check Your Input" };
          }
        } else {
          if (isNumeric(margin) && isNumeric(proportion)) {
            margin = Number(margin) / 100;
            proportion = Number(proportion) / 100;
            let con_unit = confidence_unit ** 2;
            let minus = 1 - proportion;
            let marg = margin ** 2;
            let propro_sub = con_unit * proportion;
            let propro = propro_sub * minus;
            let propro_answer = propro / marg;
            answer = Math.round(propro_answer);

            return {
                tech_answer:answer,
                tech_confidence_unit:confidence_unit,
                tech_proportion:proportion,
                tech_margin:margin,
                tech_minus:minus,
                tech_marg:marg, 
                tech_con_unit:con_unit,
                tech_propro:propro,
                tech_propro_answer:propro_answer
            };
          } else {
            return { error: "Please! Check Your Input" };
          }
        }
      } else {
        if (given_unit === "standard") {
          if (isNumeric(margin) && isNumeric(standard) && isNumeric(n_finite)) {
            margin = Number(margin) / 100;
            standard = Number(standard);
            n_finite = Number(n_finite);

            let multiply = confidence_unit * standard;
            let divide = multiply / margin;
            let sub_answer = divide * divide;
            let n_answer = Math.round(sub_answer);
            let a_answer = n_answer * n_finite;
            let b_answer = n_answer + n_finite - 1;
            let answer_s = a_answer / b_answer;
            answer = Math.round(answer_s);

            return {
                tech_n_finite:n_finite,
                tech_margin:margin,
                tech_standard:standard,
                tech_confidence_unit:confidence_unit,
                tech_multiply:multiply,
                tech_divide:divide,
                tech_sub_answer:sub_answer, 
                tech_a_answer:a_answer, 
                tech_b_answer:b_answer,
                tech_answer:answer,
            };
          } else {
            return { error: "Please! Check Your Input" };
          }
        } else {
          if (isNumeric(margin) && isNumeric(proportion) && isNumeric(n_finite)) {
            margin = Number(margin) / 100;
            proportion = Number(proportion) / 100;
            n_finite = Number(n_finite);

            let con_unit = confidence_unit ** 2;
            let minus = 1 - proportion;
            let marg = margin ** 2;
            let propro_sub = con_unit * proportion;
            let propro = propro_sub * minus;
            let propro_answer = propro / marg;
            let sub_answer = Math.round(propro_answer);
            let a_answer = sub_answer * n_finite;
            let b_answer = sub_answer + n_finite - 1;
            let answer_s = a_answer / b_answer;
            answer = Math.round(answer_s);

            return {
                tech_n_finite:n_finite,
                tech_confidence_unit:confidence_unit,
                tech_proportion:proportion, 
                tech_margin:margin,
                tech_minus:minus,
                tech_marg:marg,
                tech_con_unit:con_unit,
                tech_propro:propro,
                tech_propro_answer:propro_answer,
                tech_sub_answer:sub_answer,
                tech_a_answer:a_answer,
                tech_b_answer:b_answer,
                tech_answer:answer, 
            };
          } else {
            return { error: "Please! Check Your Input" };
          }
        }
      }
    }


     /** getCalculationZScoreToPercentilecalculator
   * POST: /api/calculators-lol/z-score-to-percentile
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationZScoreToPercentilecalculator(body) {
    let z_score_table = {
      "-3.9": { 9: 0.00003, 8: 0.00003, 7: 0.00004, 6: 0.00004, 5: 0.00004, 4: 0.00004, 3: 0.00004, 2: 0.00004, 1: 0.00005, 0: 0.00005 },
      "-3.8": { 9: 0.00005, 8: 0.00005, 7: 0.00005, 6: 0.00006, 5: 0.00006, 4: 0.00006, 3: 0.00006, 2: 0.00007, 1: 0.00007, 0: 0.00007 },
      "-3.7": { 9: 0.00008, 8: 0.00008, 7: 0.00008, 6: 0.00008, 5: 0.00009, 4: 0.00009, 3: 0.00010, 2: 0.00010, 1: 0.00010, 0: 0.00011 },
      "-3.6": { 9: 0.00011, 8: 0.00012, 7: 0.00012, 6: 0.00013, 5: 0.00013, 4: 0.00014, 3: 0.00014, 2: 0.00015, 1: 0.00015, 0: 0.00016 },
      "-3.5": { 9: 0.00017, 8: 0.00017, 7: 0.00018, 6: 0.00019, 5: 0.00019, 4: 0.00020, 3: 0.00021, 2: 0.00022, 1: 0.00022, 0: 0.00023 },
      "-3.4": { 9: 0.00024, 8: 0.00025, 7: 0.00026, 6: 0.00027, 5: 0.00028, 4: 0.00029, 3: 0.00030, 2: 0.00031, 1: 0.00032, 0: 0.00034 },
      "-3.3": { 9: 0.00035, 8: 0.00036, 7: 0.00038, 6: 0.00039, 5: 0.00040, 4: 0.00042, 3: 0.00043, 2: 0.00045, 1: 0.00047, 0: 0.00048 },
      "-3.2": { 9: 0.00050, 8: 0.00052, 7: 0.00054, 6: 0.00056, 5: 0.00058, 4: 0.00060, 3: 0.00062, 2: 0.00064, 1: 0.00066, 0: 0.00069 },
      "-3.1": { 9: 0.00071, 8: 0.00074, 7: 0.00076, 6: 0.00079, 5: 0.00082, 4: 0.00084, 3: 0.00087, 2: 0.00090, 1: 0.00094, 0: 0.00097 },
      "-3.0": { 9: 0.00100, 8: 0.00104, 7: 0.00107, 6: 0.00111, 5: 0.00114, 4: 0.00118, 3: 0.00122, 2: 0.00126, 1: 0.00131, 0: 0.00135 },
      "-2.9": { 9: 0.00139, 8: 0.00144, 7: 0.00149, 6: 0.00154, 5: 0.00159, 4: 0.00164, 3: 0.00169, 2: 0.00175, 1: 0.00181, 0: 0.00187 },
      "-2.8": { 9: 0.00193, 8: 0.00199, 7: 0.00205, 6: 0.00212, 5: 0.00219, 4: 0.00226, 3: 0.00233, 2: 0.00240, 1: 0.00248, 0: 0.00256 },
      "-2.7": { 9: 0.00264, 8: 0.00272, 7: 0.00280, 6: 0.00289, 5: 0.00298, 4: 0.00307, 3: 0.00317, 2: 0.00326, 1: 0.00336, 0: 0.00347 },
      "-2.6": { 9: 0.00357, 8: 0.00368, 7: 0.00379, 6: 0.00391, 5: 0.00402, 4: 0.00415, 3: 0.00427, 2: 0.00440, 1: 0.00453, 0: 0.00466 },
      "-2.5": { 9: 0.00480, 8: 0.00494, 7: 0.00508, 6: 0.00523, 5: 0.00539, 4: 0.00554, 3: 0.00570, 2: 0.00587, 1: 0.00604, 0: 0.00621 },
      "-2.4": { 9: 0.00639, 8: 0.00657, 7: 0.00676, 6: 0.00695, 5: 0.00714, 4: 0.00734, 3: 0.00755, 2: 0.00776, 1: 0.00798, 0: 0.00820 },
      "-2.3": { 9: 0.00842, 8: 0.00866, 7: 0.00889, 6: 0.00914, 5: 0.00939, 4: 0.00964, 3: 0.00990, 2: 0.01017, 1: 0.01044, 0: 0.01072 },
      "-2.2": { 9: 0.01101, 8: 0.01130, 7: 0.01160, 6: 0.01191, 5: 0.01222, 4: 0.01255, 3: 0.01287, 2: 0.01321, 1: 0.01355, 0: 0.01390 },
      "-2.1": { 9: 0.01426, 8: 0.01463, 7: 0.01500, 6: 0.01539, 5: 0.01578, 4: 0.01618, 3: 0.01659, 2: 0.01700, 1: 0.01743, 0: 0.01786 },
      '-2.0': { 9: 0.01831, 8: 0.01876, 7: 0.01923, 6: 0.01970, 5: 0.02018, 4: 0.02068, 3: 0.02118, 2: 0.02169, 1: 0.02222, 0: 0.02275 },
      '-1.9': { 9: 0.02330, 8: 0.02385, 7: 0.02442, 6: 0.02500, 5: 0.02559, 4: 0.02619, 3: 0.02680, 2: 0.02743, 1: 0.02807, 0: 0.02872 },
      '-1.8': { 9: 0.02938, 8: 0.03005, 7: 0.03074, 6: 0.03144, 5: 0.03216, 4: 0.03288, 3: 0.03362, 2: 0.03438, 1: 0.03515, 0: 0.03593 },
      '-1.7': { 9: 0.03673, 8: 0.03754, 7: 0.03836, 6: 0.03920, 5: 0.04006, 4: 0.04093, 3: 0.04182, 2: 0.04272, 1: 0.04363, 0: 0.04457 },
      '-1.6': { 9: 0.04551, 8: 0.04648, 7: 0.04746, 6: 0.04846, 5: 0.04947, 4: 0.05050, 3: 0.05155, 2: 0.05262, 1: 0.05370, 0: 0.05480 },
      '-1.5': { 9: 0.0559, 8: 0.0571, 7: 0.0582, 6: 0.0594, 5: 0.0606, 4: 0.0618, 3: 0.0630, 2: 0.0643, 1: 0.0655, 0: 0.0668 },
      '-1.4': { 9: 0.0681, 8: 0.0694, 7: 0.0708, 6: 0.0721, 5: 0.0735, 4: 0.0749, 3: 0.0764, 2: 0.0778, 1: 0.0793, 0: 0.0808 },
      '-1.3': { 9: 0.0823, 8: 0.0838, 7: 0.0853, 6: 0.0869, 5: 0.0885, 4: 0.0901, 3: 0.0918, 2: 0.0934, 1: 0.0951, 0: 0.0968 },
      '-1.2': { 9: 0.0985, 8: 0.1003, 7: 0.1020, 6: 0.1038, 5: 0.1056, 4: 0.1075, 3: 0.1093, 2: 0.1112, 1: 0.1131, 0: 0.1151 },
      '-1.1': { 9: 0.1170, 8: 0.1190, 7: 0.1210, 6: 0.1230, 5: 0.1251, 4: 0.1271, 3: 0.1292, 2: 0.1314, 1: 0.1335, 0: 0.1357 },
      '-1.0': { 9: 0.1379, 8: 0.1401, 7: 0.1423, 6: 0.1446, 5: 0.1469, 4: 0.1492, 3: 0.1515, 2: 0.1539, 1: 0.1562, 0: 0.1587 },
      '-0.9': { 9: 0.1611, 8: 0.1635, 7: 0.1660, 6: 0.1685, 5: 0.1711, 4: 0.1736, 3: 0.1762, 2: 0.1788, 1: 0.1814, 0: 0.1841 },
      '-0.8': { 9: 0.1867, 8: 0.1894, 7: 0.1922, 6: 0.1949, 5: 0.1977, 4: 0.2005, 3: 0.2033, 2: 0.2061, 1: 0.2090, 0: 0.2119 },
      '-0.7': { 9: 0.2148, 8: 0.2177, 7: 0.2206, 6: 0.2236, 5: 0.2266, 4: 0.2296, 3: 0.2327, 2: 0.2358, 1: 0.2389, 0: 0.2420 },
      '-0.6': { 9: 0.2451, 8: 0.2483, 7: 0.2514, 6: 0.2546, 5: 0.2578, 4: 0.2611, 3: 0.2643, 2: 0.2676, 1: 0.2709, 0: 0.2743 },
      '-0.5': { 9: 0.2776, 8: 0.2810, 7: 0.2843, 6: 0.2877, 5: 0.2912, 4: 0.2946, 3: 0.2981, 2: 0.3015, 1: 0.3050, 0: 0.3085 },
      '-0.4': { 9: 0.3121, 8: 0.3156, 7: 0.3192, 6: 0.3228, 5: 0.3264, 4: 0.3300, 3: 0.3336, 2: 0.3372, 1: 0.3409, 0: 0.3446 },
      '-0.3': { 9: 0.3483, 8: 0.3520, 7: 0.3557, 6: 0.3594, 5: 0.3632, 4: 0.3669, 3: 0.3707, 2: 0.3745, 1: 0.3783, 0: 0.3821 },
      '-0.2': { 9: 0.3859, 8: 0.3897, 7: 0.3936, 6: 0.3974, 5: 0.4013, 4: 0.4052, 3: 0.4090, 2: 0.4129, 1: 0.4168, 0: 0.4207 },
      '-0.1': { 9: 0.4247, 8: 0.4286, 7: 0.4325, 6: 0.4364, 5: 0.4404, 4: 0.4443, 3: 0.4483, 2: 0.4522, 1: 0.4562, 0: 0.4602 },
      '-0.0': { 9: 0.4641, 8: 0.4681, 7: 0.4721, 6: 0.4761, 5: 0.4801, 4: 0.4840, 3: 0.4880, 2: 0.4920, 1: 0.4960, 0: 0.5000 },
      '0.0': { 0: 0.50000, 1: 0.50399, 2: 0.50798, 3: 0.51197, 4: 0.51595, 5: 0.51994, 6: 0.52392, 7: 0.52790, 8: 0.53188, 9: 0.53586 },
      '0.1': { 0: 0.53980, 1: 0.54380, 2: 0.54776, 3: 0.55172, 4: 0.55567, 5: 0.55966, 6: 0.56360, 7: 0.56749, 8: 0.57142, 9: 0.57535 },
      '0.2': { 0: 0.57930, 1: 0.58317, 2: 0.58706, 3: 0.59095, 4: 0.59483, 5: 0.59871, 6: 0.60257, 7: 0.60642, 8: 0.61026, 9: 0.61409 },
      '0.3': { 0: 0.61791, 1: 0.62172, 2: 0.62552, 3: 0.62930, 4: 0.63307, 5: 0.63683, 6: 0.64058, 7: 0.64431, 8: 0.64803, 9: 0.65173 },
      '0.4': { 0: 0.65542, 1: 0.65910, 2: 0.66276, 3: 0.66640, 4: 0.67003, 5: 0.67364, 6: 0.67724, 7: 0.68082, 8: 0.68439, 9: 0.68793 },
      '0.5': { 0: 0.69146, 1: 0.69497, 2: 0.69847, 3: 0.70194, 4: 0.70540, 5: 0.70884, 6: 0.71226, 7: 0.71566, 8: 0.71904, 9: 0.72240 },
      '0.6': { 0: 0.72575, 1: 0.72907, 2: 0.73237, 3: 0.73565, 4: 0.73891, 5: 0.74215, 6: 0.74537, 7: 0.74857, 8: 0.75175, 9: 0.75490 },
      '0.7': { 0: 0.75804, 1: 0.76115, 2: 0.76424, 3: 0.76730, 4: 0.77035, 5: 0.77337, 6: 0.77637, 7: 0.77935, 8: 0.78230, 9: 0.78524 },
      '0.8': { 0: 0.78814, 1: 0.79103, 2: 0.79389, 3: 0.79673, 4: 0.79955, 5: 0.80234, 6: 0.80511, 7: 0.80785, 8: 0.81057, 9: 0.81327 },
      '0.9': { 0: 0.81594, 1: 0.81859, 2: 0.82121, 3: 0.82381, 4: 0.82639, 5: 0.82894, 6: 0.83147, 7: 0.83398, 8: 0.83646, 9: 0.83891 },
      '1.0': { 0: 0.84134, 1: 0.84375, 2: 0.84614, 3: 0.84849, 4: 0.85083, 5: 0.85314, 6: 0.85543, 7: 0.85769, 8: 0.85993, 9: 0.86214 },
      '1.1': { 0: 0.86433, 1: 0.86650, 2: 0.86864, 3: 0.87076, 4: 0.87286, 5: 0.87493, 6: 0.87698, 7: 0.87900, 8: 0.88100, 9: 0.88298 },
      '1.2': { 0: 0.88493, 1: 0.88686, 2: 0.88877, 3: 0.89065, 4: 0.89251, 5: 0.89435, 6: 0.89617, 7: 0.89796, 8: 0.89973, 9: 0.90147 },
      '1.3': { 0: 0.90320, 1: 0.90490, 2: 0.90658, 3: 0.90824, 4: 0.90988, 5: 0.91149, 6: 0.91308, 7: 0.91466, 8: 0.91621, 9: 0.91774 },
      '1.4': { 0: 0.91924, 1: 0.92073, 2: 0.92220, 3: 0.92364, 4: 0.92507, 5: 0.92647, 6: 0.92785, 7: 0.92922, 8: 0.93056, 9: 0.93189 },
      '1.5': { 0: 0.93319, 1: 0.93448, 2: 0.93574, 3: 0.93699, 4: 0.93822, 5: 0.93943, 6: 0.94062, 7: 0.94179, 8: 0.94295, 9: 0.94408 },
      '1.6': { 0: 0.94520, 1: 0.94630, 2: 0.94738, 3: 0.94845, 4: 0.94950, 5: 0.95053, 6: 0.95154, 7: 0.95254, 8: 0.95352, 9: 0.95449 },
      '1.7': { 0: 0.95543, 1: 0.95637, 2: 0.95728, 3: 0.95818, 4: 0.95907, 5: 0.95994, 6: 0.96080, 7: 0.96164, 8: 0.96246, 9: 0.96327 },
      '1.8': { 0: 0.96407, 1: 0.96485, 2: 0.96562, 3: 0.96638, 4: 0.96712, 5: 0.96784, 6: 0.96856, 7: 0.96926, 8: 0.96995, 9: 0.97062 },
      '1.9': { 0: 0.97128, 1: 0.97193, 2: 0.97257, 3: 0.97320, 4: 0.97381, 5: 0.97441, 6: 0.97500, 7: 0.97558, 8: 0.97615, 9: 0.97670 },
      '2.0': { 0: 0.97725, 1: 0.97778, 2: 0.97831, 3: 0.97882, 4: 0.97932, 5: 0.97982, 6: 0.98030, 7: 0.98077, 8: 0.98124, 9: 0.98169 },
      '2.1': { 0: 0.98214, 1: 0.98257, 2: 0.98300, 3: 0.98341, 4: 0.98382, 5: 0.98422, 6: 0.98461, 7: 0.98500, 8: 0.98537, 9: 0.98574 },
      '2.2': { 0: 0.98610, 1: 0.98645, 2: 0.98679, 3: 0.98713, 4: 0.98745, 5: 0.98778, 6: 0.98809, 7: 0.98840, 8: 0.98870, 9: 0.98899 },
      '2.3': { 0: 0.98928, 1: 0.98956, 2: 0.98983, 3: 0.99010, 4: 0.99036, 5: 0.99061, 6: 0.99086, 7: 0.99111, 8: 0.99134, 9: 0.99158 },
      '2.4': { 0: 0.99180, 1: 0.99202, 2: 0.99224, 3: 0.99245, 4: 0.99266, 5: 0.99286, 6: 0.99305, 7: 0.99324, 8: 0.99343, 9: 0.99361 },
      '2.5': { 0: 0.99379, 1: 0.99396, 2: 0.99413, 3: 0.99430, 4: 0.99446, 5: 0.99461, 6: 0.99477, 7: 0.99492, 8: 0.99506, 9: 0.99520 },
      '2.6': { 0: 0.99534, 1: 0.99547, 2: 0.99560, 3: 0.99573, 4: 0.99585, 5: 0.99598, 6: 0.99609, 7: 0.99621, 8: 0.99632, 9: 0.99643 },
      '2.7': { 0: 0.99653, 1: 0.99664, 2: 0.99674, 3: 0.99683, 4: 0.99693, 5: 0.99702, 6: 0.99711, 7: 0.99720, 8: 0.99728, 9: 0.99736 },
      '2.8': { 0: 0.99744, 1: 0.99752, 2: 0.99760, 3: 0.99767, 4: 0.99774, 5: 0.99781, 6: 0.99788, 7: 0.99795, 8: 0.99801, 9: 0.99807 },
      '2.9': { 0: 0.99813, 1: 0.99819, 2: 0.99825, 3: 0.99831, 4: 0.99836, 5: 0.99841, 6: 0.99846, 7: 0.99851, 8: 0.99856, 9: 0.99861 },
      '3.0': { 0: 0.99865, 1: 0.99869, 2: 0.99874, 3: 0.99878, 4: 0.99882, 5: 0.99886, 6: 0.99889, 7: 0.99893, 8: 0.99896, 9: 0.99900 },
      '3.1': { 0: 0.99903, 1: 0.99906, 2: 0.99910, 3: 0.99913, 4: 0.99916, 5: 0.99918, 6: 0.99921, 7: 0.99924, 8: 0.99926, 9: 0.99929 },
      '3.2': { 0: 0.99931, 1: 0.99934, 2: 0.99936, 3: 0.99938, 4: 0.99940, 5: 0.99942, 6: 0.99944, 7: 0.99946, 8: 0.99948, 9: 0.99950 },
      '3.3': { 0: 0.99952, 1: 0.99953, 2: 0.99955, 3: 0.99957, 4: 0.99958, 5: 0.99960, 6: 0.99961, 7: 0.99962, 8: 0.99964, 9: 0.99965 },
      '3.4': { 0: 0.99966, 1: 0.99968, 2: 0.99969, 3: 0.99970, 4: 0.99971, 5: 0.99972, 6: 0.99973, 7: 0.99974, 8: 0.99975, 9: 0.99976 },
      '3.5': { 0: 0.99977, 1: 0.99978, 2: 0.99978, 3: 0.99979, 4: 0.99980, 5: 0.99981, 6: 0.99981, 7: 0.99982, 8: 0.99983, 9: 0.99983 },
      '3.6': { 0: 0.99984, 1: 0.99985, 2: 0.99985, 3: 0.99986, 4: 0.99986, 5: 0.99987, 6: 0.99987, 7: 0.99988, 8: 0.99988, 9: 0.99989 },
      '3.7': { 0: 0.99989, 1: 0.99990, 2: 0.99990, 3: 0.99990, 4: 0.99991, 5: 0.99991, 6: 0.99992, 7: 0.99992, 8: 0.99992, 9: 0.99992 },
      '3.8': { 0: 0.99993, 1: 0.99993, 2: 0.99993, 3: 0.99994, 4: 0.99994, 5: 0.99994, 6: 0.99994, 7: 0.99995, 8: 0.99995, 9: 0.99995 },
      '3.9': { 0: 0.99995, 1: 0.99995, 2: 0.99996, 3: 0.99996, 4: 0.99996, 5: 0.99996, 6: 0.99996, 7: 0.99996, 8: 0.99997, 9: 0.99997 },
      '4.0': { 0: 0.99997, 1: 0.99997, 2: 0.99997, 3: 0.99997, 4: 0.99997, 5: 0.99997, 6: 0.99998, 7: 0.99998, 8: 0.99998, 9: 0.99998 },
    };


      let result = {};
      let z_score = body.tech_z_score?.toString().trim();

      function isDecimal(val) {
        return !Number.isInteger(Number(val));
      }

      if (!isNaN(z_score)) {
        let score = Math.round(z_score * 10) / 10;
        let inner_score = Math.round(z_score * 100) / 100;
        let res_val;
        let img;

        if (isDecimal(inner_score)) {
          if (z_score >= -3.9 && z_score <= 4.0) {
            let parts = inner_score.toString().split(".");
            let main_jawab = parts[1]?.substring(1, 2) || "0";
            res_val = z_score_table[score.toFixed(1)]?.[main_jawab];
          } else {
            res_val = z_score < -3.9 ? "0" : "1";
          }
        } else {
          let z_score_str = parseFloat(z_score).toFixed(1);
          if (z_score >= -3.9 && z_score <= 4.0) {
            let parts = z_score_str.split(".");
            let main_jawab = parts[1]?.substring(1, 2) || "0";
            res_val = z_score_table[z_score_str]?.[main_jawab];
          } else {
            res_val = z_score < -3.9 ? "0" : "1";
          }
        }



        if (score <= -3.8) {
            img = "-3.5 equal & above.png";
          } else if (score == -3.7) {
            img = "-3.5 equal & above.png";
          } else if (score == -3.6) {

            img = "-3.5 equal & above.png";
          } else if (score == -3.5) {

            img = "-3.5 equal & above.png";
          } else if (score == -3.4) {

            img = "-3.4.png";
          } else if (score == -3.3) {

            img = "-3.3.png";
          } else if (score == -3.2) {

            img = "-3.2.png";
          } else if (score == -3.1) {

            img = "-3.1.png";
          } else if (score == -3) {

            img = "-3.0.png";
          } else if (score == -2.9) {

            img = "-2.9.png";
          } else if (score == -2.8) {

            img = "-2.8.png";
          } else if (score == -2.7) {

            img = "-2.7.png";
          } else if (score == -2.6) {

            img = "-2.6.png";
          } else if (score == -2.5) {

            img = "-2.5.png";
          } else if (score == -2.4) {

            img = "-2.4.png";
          } else if (score == -2.3) {

            img = "-2.3.png";
          } else if (score == -2.2) {

            img = "-2.2.png";
          } else if (score == -2.1) {

            img = "-2.1.png";
          } else if (score == -2) {

            img = "-2.0.png";
          } else if (score == -1.9) {

            img = "-1.9.png";
          } else if (score == -1.8) {

            img = "-1.8.png";
          } else if (score == -1.7) {

            img = "-1.7.png";
          } else if (score == -1.6) {

            img = "-1.6.png";
          } else if (score == -1.5) {

            img = "-1.5.png";
          } else if (score == -1.4) {

            img = "-1.4.png";
          } else if (score == -1.3) {

            img = "-1.3.png";
          } else if (score == -1.2) {

            img = "-1.2.png";
          } else if (score == -1.1) {

            img = "-1.1.png";
          } else if (score == -1) {

            img = "-1.0.png";
          } else if (score == -0.9) {

            img = "-0.9.png";
          } else if (score == -0.8) {

            img = "-0.8.png";
          } else if (score == -0.7) {

            img = "-0.7.png";
          } else if (score == -0.6) {

            img = "-0.6.png";
          } else if (score == -0.5) {

            img = "-0.5.png";
          } else if (score == -0.4) {

            img = "-0.4.png";
          } else if (score == -0.3) {

            img = "-0.3.png";
          } else if (score == -0.2) {

            img = "-0.2.png";
          } else if (score == -0.1) {

            img = "-0.1.png";
          } else if (score == -0) {

            img = "-0.png";
          } else if (score == 0) {

            img = "0.png";
          } else if (score == 0.1) {

            img = "0.1.png";
          } else if (score == 0.2) {

            img = "0.2.png";
          } else if (score == 0.3) {

            img = "0.3.png";
          } else if (score == 0.4) {

            img = "0.4.png";
          } else if (score == 0.5) {

            img = "0.5.png";
          } else if (score == 0.6) {

            img = "0.6.png";
          } else if (score == 0.7) {

            img = "0.7.png";
          } else if (score == 0.8) {

            img = "0.8.png";
          } else if (score == 0.9) {

            img = "0.9.png";
          } else if (score == 1) {

            img = "1.0.png";
          } else if (score == 1.1) {

            img = "1.1.png";
          } else if (score == 1.2) {

            img = "1.2.png";
          } else if (score == 1.3) {

            img = "1.3.png";
          } else if (score == 1.4) {

            img = "1.4.png";
          } else if (score == 1.5) {

            img = "1.5.png";
          } else if (score == 1.6) {

            img = "1.6.png";
          } else if (score == 1.7) {

            img = "1.7.png";
          } else if (score == 1.8) {

            img = "1.8.png";
          } else if (score == 1.9) {

            img = "1.9.png";
          } else if (score == 2) {

            img = "2.0.png";
          } else if (score == 2.1) {

            img = "2.1.png";
          } else if (score == 2.2) {

            img = "2.2.png";
          } else if (score == 2.3) {

            img = "2.3.png";
          } else if (score == 2.4) {

            img = "2.4.png";
          } else if (score == 2.5) {

            img = "2.5.png";
          } else if (score == 2.6) {

            img = "2.6.png";
          } else if (score == 2.7) {

            img = "2.7.png";
          } else if (score == 2.8) {

            img = "2.8.png";
          } else if (score == 2.9) {

            img = "2.9.png";
          } else if (score == 3) {

            img = "3.0.png";
          } else if (score == 3.1) {

            img = "3.1.png";
          } else if (score == 3.2) {

            img = "3.2.png";
          } else if (score == 3.3) {

            img = "3.3.png";
          } else if (score == 3.4) {

            img = "3.4.png";
          } else if (score == 3.5) {

            img = "3.5.png";
          } else if (score == 3.6) {

            img = "3.5.png";
          } else if (score == 3.7) {

            img = "3.5.png";
          } else if (score >= 3.8) {

            img = "3.5.png";
          }
        result.tech_z_score = z_score;
        result.tech_score = score;
        result.tech_res_val = res_val;
        result.tech_img = img;
      } else {
        result.error = "Please! Check Your Input";
      }

      return result;
    }


     /** getCalculationCrossProductcalculator
   * POST: /api/calculators-lol/cross-product-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCrossProductcalculator(body) {
  
        let a_rep = body.tech_a_rep;
      let ax = body.tech_ax;
      let ay = body.tech_ay;
      let az = body.tech_az;
      let a1 = body.tech_a1;
      let a2 = body.tech_a2;
      let a3 = body.tech_a3;
      let b1 = body.tech_b1;
      let b2 = body.tech_b2;
      let b3 = body.tech_b3;
      let b_rep = body.tech_b_rep;
      let bx = body.tech_bx;
      let by = body.tech_by;
      let bz = body.tech_bz;
      let aa1 = body.tech_aa1;
      let aa2 = body.tech_aa2;
      let aa3 = body.tech_aa3;
      let bb1 = body.tech_bb1;
      let bb2 = body.tech_bb2;
      let bb3 = body.tech_bb3;

  function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }
    let check = false;

    if (a_rep === 'coor') {
      if (isNumeric(ax) && isNumeric(ay) && isNumeric(az)) {
        check = true;
      } else {
        check = false;
      }
    } else {
      if (isNumeric(a1) && isNumeric(a2) && isNumeric(a3) && isNumeric(b1) && isNumeric(b2) && isNumeric(b3)) {
        check = true;
      } else {
        check = false;
      }
    }

    if (b_rep === 'coor') {
      if (isNumeric(bx) && isNumeric(by) && isNumeric(bz)) {
        check = true;
      } else {
        check = false;
      }
    } else {
      if (isNumeric(aa1) && isNumeric(aa2) && isNumeric(aa3) && isNumeric(bb1) && isNumeric(bb2) && isNumeric(bb3)) {
        check = true;
      } else {
        check = false;
      }
    }

    if (check === true) {
      return {
        tech_cross: "active",
      };
    } else {
      return {
        error: "Please fill all fields."
      };
    }

  
  }

       /** getCalculationInstantaneousVelocitycalculator
   * POST: /api/calculators-lol/instantaneous-velocity-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async getCalculationInstantaneousVelocitycalculator(body) {

        let i_d = body.tech_i_d;
        let i_d_unit = body.tech_i_d_unit;
        let f_d = body.tech_f_d;
        let f_d_unit = body.tech_f_d_unit;
        let i_tt = body.tech_i_tt;
        let i_tt_unit = body.tech_i_tt_unit;
        let f_tt = body.tech_f_tt;
        let f_tt_unit = body.tech_f_tt_unit;


      let result = {};

        function isNumeric(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
      }

      function round(n) {
        return Math.round(n * 100000) / 100000;
      }



      // Convert distances to meters
      if (isNumeric(i_d)) {
        i_d = parseFloat(i_d);
        if (i_d_unit === 'cm') i_d = i_d / 100;
        else if (i_d_unit === 'km') i_d = i_d / 0.001;
        else if (i_d_unit === 'in') i_d = i_d / 39.37;
        else if (i_d_unit === 'ft') i_d = i_d / 3.281;
        else if (i_d_unit === 'yd') i_d = i_d / 1.0936;
        else if (i_d_unit === 'mi') i_d = i_d / 0.0006214;
      }

      if (isNumeric(f_d)) {
        f_d = parseFloat(f_d);
        if (f_d_unit === 'cm') f_d = f_d / 100;
        else if (f_d_unit === 'km') f_d = f_d / 0.001;
        else if (f_d_unit === 'in') f_d = f_d / 39.37;
        else if (f_d_unit === 'ft') f_d = f_d / 3.281;
        else if (f_d_unit === 'yd') f_d = f_d / 1.0936;
        else if (f_d_unit === 'mi') f_d = f_d / 0.0006214;
      }

      // Convert time to seconds
      if (isNumeric(i_tt)) {
        i_tt = parseFloat(i_tt);
        if (i_tt_unit === 'min') i_tt = i_tt / 0.016667;
        else if (i_tt_unit === 'hrs') i_tt = i_tt / 0.0002778;
      }

      if (isNumeric(f_tt)) {
        f_tt = parseFloat(f_tt);
        if (f_tt_unit === 'min') f_tt = f_tt / 0.016667;
        else if (f_tt_unit === 'hrs') f_tt = f_tt / 0.0002778;
      }

      if (isNumeric(i_d) && isNumeric(f_d) && isNumeric(i_tt) && isNumeric(f_tt)) {
        let s1 = f_d - i_d;
        let s2 = f_tt - i_tt;
        let iv = s1 / s2;

        result.tech_method = 'iv';
        result.tech_iv = round(iv);
        result.tech_id = round(i_d);
        result.tech_fd = round(f_d);
        result.tech_itt = round(i_tt);
        result.tech_ftt = round(f_tt);
        result.tech_s1 = round(s1);
        result.tech_s2 = round(s2);
      } else {
        result.error = 'Please! Fill All The Fields!';
      }

      return result;


    }


    /** getCalculationPhotonEnergycalculator
   * POST: /api/calculators-lol/photon-energy-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPhotonEnergycalculator(body) {

    let wave = body.tech_wave;
  let freq = body.tech_freq;
  let unit_w = body.tech_unit_w;
  let unit_f = body.tech_unit_f;


    let result = {};
    const h = 6.6260695729e-34; // Planck's constant
    const c = 2.99792458e8; // Speed of light

      function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }

  function formatScientific(val) {
      const parts = val.toExponential().split('e');
      return `${parseFloat(parts[0]).toFixed(4)} x 10<sup>${parseInt(parts[1])}</sup>`;
    }


    // Check if wave is provided
    if (isNumeric(wave)) {
      wave = parseFloat(wave);
      switch (unit_w) {
        case 'Å': wave = wave / 1e10; break;
        case 'nm': wave = wave / 1e9; break;
        case 'μm': wave = wave / 1e6; break;
        case 'mm': wave = wave / 1000; break;
        case 'km': wave = wave * 1000; break;
      }

      let energy = (h * c) / wave;
      let frequency = energy / h;
      let en = energy;
      let energyFormatted = formatScientific(energy);

      result.tech_energy = energyFormatted;
      result.tech_en = en;
      result.tech_frequency = Math.round(frequency * 1000) / 1000;
      return result;

    } else if (isNumeric(freq)) {
      freq = parseFloat(freq);
      switch (unit_f) {
        case 'kHz': freq *= 1e3; break;
        case 'MHz': freq *= 1e6; break;
        case 'GHz': freq *= 1e9; break;
        case 'THz': freq *= 1e12; break;
        case 'RPM': freq /= 60; break;
      }

      let energy = h * freq;
      let wave = (h * c) / energy;
      let en = energy;
      let energyFormatted = formatScientific(energy);

      result.tech_energy = energyFormatted;
      result.tech_en = en;
      result.tech_wave = Math.round(wave * 1000) / 1000;
      return result;

    } else {
      result.error = 'Please fill all fields.';
      return result;
    }


  }

    /** getCalculationDotProductcalculator
   * POST: /api/calculators-lol/dot-product-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async  getCalculationDotProductcalculator(body) {
  let input1 = body.tech_input1;
  let input2 = body.tech_input2;

    let result = {};

    let components = input1.split(',').map(v => v.trim());
    let components2 = input2.split(',').map(v => v.trim());

    function isNumericArray(arr) {
      return arr.every(val => !isNaN(val));
    }

    if (!isNumericArray(components) || !isNumericArray(components2)) {
      result.error = 'Sets may contain only integers and decimals';
      return result;
    }

    if (components.length !== components2.length) {
      result.error = 'The input arrays must have the same length.';
      return result;
    }

    if (input1 && input2) {
      let a = components.map(Number);
      let b = components2.map(Number);

      let products = a.map((val, idx) => val * b[idx]);
      let prod = products.reduce((sum, val) => sum + val, 0);

      let sumSqA = a.reduce((sum, val) => sum + val ** 2, 0);
      let sumSqB = b.reduce((sum, val) => sum + val ** 2, 0);

      let mgntd_a = Math.sqrt(sumSqA);
      let mgntd_b = Math.sqrt(sumSqB);

      let angle = prod / (mgntd_a * mgntd_b);
      let theta = Math.acos(angle);
      let deg = theta * (180 / Math.PI);

      result.tech_components = a;
      result.tech_components2 = b;
      result.tech_mgntd_a = Math.round(mgntd_a * 100) / 100;
      result.tech_mgntd_b = Math.round(mgntd_b * 100) / 100;
      result.tech_prod = prod;
      result.tech_angle = Math.round(angle * 1e7) / 1e7;
      result.tech_deg = Math.round(deg * 1e5) / 1e5;
      return result;
    } else {
      result.error = 'Please Fill All The Fields';
      return result;
    }
  }


      /** getCalculationVectorMagnitudecalculator
   * POST: /api/calculators-lol/vector-magnitude-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async  getCalculationVectorMagnitudecalculator(body) {
    let result = {};


    let dem = body.tech_dem;
    let a_rep = body.tech_a_rep;
    let ax = body.tech_ax;
    let ay = body.tech_ay;
    let az = body.tech_az;
    let w = body.tech_w;
    let t = body.tech_t;
    let a1 = body.tech_a1;
    let a2 = body.tech_a2;
    let a3 = body.tech_a3;
    let a4 = body.tech_a4;
    let a5 = body.tech_a5;
    let b1 = body.tech_b1;
    let b2 = body.tech_b2;
    let b3 = body.tech_b3;
    let b4 = body.tech_b4;
    let b5 = body.tech_b5;



    dem = dem?.toString().trim();
    a_rep = a_rep?.toString().trim();
    ax = parseFloat(ax);
    ay = parseFloat(ay);
    az = parseFloat(az);
    w = parseFloat(w);
    t = parseFloat(t);
    a1 = parseFloat(a1);
    a2 = parseFloat(a2);
    a3 = parseFloat(a3);
    a4 = parseFloat(a4);
    a5 = parseFloat(a5);
    b1 = parseFloat(b1);
    b2 = parseFloat(b2);
    b3 = parseFloat(b3);
    b4 = parseFloat(b4);
    b5 = parseFloat(b5);

    function isNumeric(val) {
      return typeof val === 'number' && !isNaN(val);
    }

    if (a_rep === 'coor') {
      if (dem === '2') {
        if (isNumeric(ax) && isNumeric(ay)) {
          let mag = Math.sqrt(ax**2 + ay**2);
          result.tech_mag = +mag.toFixed(5);
          return result;
        }
      } else if (dem === '3') {
        if (isNumeric(ax) && isNumeric(ay) && isNumeric(az)) {
          let mag = Math.sqrt(ax**2 + ay**2 + az**2);
          result.tech_mag = +mag.toFixed(5);
          return result;
        }
      } else if (dem === '4') {
        if (isNumeric(ax) && isNumeric(ay) && isNumeric(az) && isNumeric(w)) {
          let mag = Math.sqrt(ax**2 + ay**2 + az**2 + w**2);
          result.tech_mag = +mag.toFixed(5);
          return result;
        }
      } else if (dem === '5') {
        if (isNumeric(ax) && isNumeric(ay) && isNumeric(az) && isNumeric(w) && isNumeric(t)) {
          let mag = Math.sqrt(ax**2 + ay**2 + az**2 + w**2 + t**2);
          result.tech_mag = +mag.toFixed(5);
          return result;
        }
      }
    } else {
      // when a_rep != 'coor', calculate vector difference between points a and b
      if (dem === '2') {
        if (isNumeric(a1) && isNumeric(a2) && isNumeric(b1) && isNumeric(b2)) {
          let dx = b1 - a1;
          let dy = b2 - a2;
          let mag = Math.sqrt(dx**2 + dy**2);
          result.tech_mag = +mag.toFixed(5);
          return result;
        }
      } else if (dem === '3') {
        if (isNumeric(a1) && isNumeric(a2) && isNumeric(a3) && isNumeric(b1) && isNumeric(b2) && isNumeric(b3)) {
          let dx = b1 - a1;
          let dy = b2 - a2;
          let dz = b3 - a3;
          let mag = Math.sqrt(dx**2 + dy**2 + dz**2);
          result.tech_mag = +mag.toFixed(5);
          return result;
        }
      } else if (dem === '4') {
        if (isNumeric(a1) && isNumeric(a2) && isNumeric(a3) && isNumeric(a4) && isNumeric(b1) && isNumeric(b2) && isNumeric(b3) && isNumeric(b4)) {
          let dx = b1 - a1;
          let dy = b2 - a2;
          let dz = b3 - a3;
          let dw = b4 - a4;
          let mag = Math.sqrt(dx**2 + dy**2 + dz**2 + dw**2);
          result.tech_mag = +mag.toFixed(5);
          return result;
        }
      } else if (dem === '5') {
        if (
          isNumeric(a1) && isNumeric(a2) && isNumeric(a3) && isNumeric(a4) && isNumeric(a5) &&
          isNumeric(b1) && isNumeric(b2) && isNumeric(b3) && isNumeric(b4) && isNumeric(b5)
        ) {
          let dx = b1 - a1;
          let dy = b2 - a2;
          let dz = b3 - a3;
          let dw = b4 - a4;
          let dt = b5 - a5;
          let mag = Math.sqrt(dx**2 + dy**2 + dz**2 + dw**2 + dt**2);
          result.tech_mag = +mag.toFixed(5);
          return result;
        }
      }
    }

    result.error = 'Please! Check Your Input';
    return result;
  }


      /** getCalculationProjectileMotioncalculator
   * POST: /api/calculators-lol/projectile-motion-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationProjectileMotioncalculator(body) {
      let method = body.tech_method?.trim();
      let a = parseFloat(body.tech_a);
      let a_unit = body.tech_a_unit?.trim();
      let h = parseFloat(body.tech_h);
      let h_unit = body.tech_h_unit?.trim();
      let v = parseFloat(body.tech_v);
      let v_unit = body.tech_v_unit?.trim();
      let g = parseFloat(body.tech_g);
      let g_unit = body.tech_g_unit?.trim();
      let t = parseFloat(body.tech_t);
      let t_unit = body.tech_t_unit?.trim();

      let param = {};

      const sigFig = (value, digits) => {
        if (value === 0) return 0;
        let d = digits - Math.floor(Math.log10(Math.abs(value))) - 1;
        let decimalPlaces = Math.max(0, Math.min(d, 100)); // Clamp between 0 and 100
        return parseFloat(value.toFixed(decimalPlaces));
      };

      if (
        isFinite(a) && isFinite(h) && isFinite(v) && isFinite(g) &&
        a_unit && h_unit && v_unit && g_unit
      ) {
        // Convert height
        if (h_unit === 'cm') {
          h = h / 100;
        } else if (h_unit === 'km') {
          h = h / 0.001;
        } else if (h_unit === 'in') {
          h = h / 39.37;
        } else if (h_unit === 'ft') {
          h = h / 3.281;
        } else if (h_unit === 'yd') {
          h = h / 1.0936;
        } else if (h_unit === 'mi') {
          h = h / 0.0006214;
        }

        // Convert velocity
        if (v_unit === 'kmh') {
          v = v / 3.6;
        } else if (v_unit === 'fts') {
          v = v / 3.28;
        } else if (v_unit === 'mph') {
          v = v / 2.237;
        }

        // Convert time
        if (isFinite(t)) {
          if (t_unit === 'min') {
            t = t * 60;
          } else if (t_unit === 'hrs') {
            t = t * 3600;
          }
        }

        // Calculate horizontal and vertical components
        let vx, vy;
        if (a_unit === 'deg') {
          vx = v * Math.cos((a * Math.PI) / 180);
          vy = v * Math.sin((a * Math.PI) / 180);
        } else {
          vx = v * Math.cos(a);
          vy = v * Math.sin(a);
        }

        // Convert gravity
        if (g_unit === 'g') {
          g = g * 9.807;
        }

        // Perform calculations
        if (method === 'tof') {
          let tof = h === 0
            ? (2 * vy) / g
            : (vy + Math.sqrt(Math.pow(vy, 2) + 2 * g * h)) / g;

          param.tech_check = 'tof';
          param.tech_tof = sigFig(tof, 4);
        } else if (method === 'range') {
          let r = h === 0
            ? (2 * vx * vy) / g
            : vx * ((vy + Math.sqrt(Math.pow(vy, 2) + 2 * g * h)) / g);

          param.tech_check = 'range';
          param.tech_r = sigFig(r, 4);
        } else if (method === 'mh') {
          let hmax = h === 0
            ? Math.pow(vy, 2) / (2 * g)
            : h + Math.pow(vy, 2) / (2 * g);

          param.tech_check = 'mh';
          param.tech_hmax = sigFig(hmax, 4);
        } else if (method === 'fp' && isFinite(t)) {
          let x = vx * t;
          let y = h + vy * t - (g * Math.pow(t, 2)) / 2;
          let hv = vx;
          let vv = vy - g * t;
          let vel = Math.sqrt(hv ** 2 + vv ** 2);

          param.tech_check = 'fp';
          param.tech_x = sigFig(x, 4);
          param.tech_y = sigFig(y, 4);
          param.tech_hv = sigFig(hv, 4);
          param.tech_vv = sigFig(vv, 4);
          param.tech_vel = sigFig(vel, 4);
        } else {
          return { error: 'Please fill all fields.' };
        }

        param.tech_g = sigFig(g, 4);
        param.tech_vx = sigFig(vx, 4);
        param.tech_vy = sigFig(vy, 4);
        return param;
      } else {
        return { error: 'Please fill all fields.' };
      }
    }

      /** getCalculationPotentialEnergycalculator
   * POST: /api/calculators-lol/potential-energy-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async  getCalculationPotentialEnergycalculator(body) {
    let cal = body.tech_cal?.trim();
    let mass = parseFloat(body.tech_mass);
    let mass_unit = body.tech_mass_unit?.trim();
    let gravity = parseFloat(body.tech_gravity);
    let gravity_unit = body.tech_gravity_unit?.trim();
    let height = parseFloat(body.tech_height);
    let height_unit = body.tech_height_unit?.trim();
    let pe = parseFloat(body.tech_pe);
    let pe_unit = body.tech_pe_unit?.trim();

    const sigFig = (value, digits) => {
      if (value === 0) return 0;
      let d = digits - Math.floor(Math.log10(Math.abs(value))) - 1;
      let decimalPlaces = Math.max(0, Math.min(d, 100));
      return parseFloat(value.toFixed(decimalPlaces));
    };

      if (isFinite(mass)) {
        if (mass_unit === 'ug') {
          mass = mass / 1000000000;
        } else if (mass_unit === 'mg') {
          mass = mass * 1000000;
        } else if (mass_unit === 'g') {
          mass = mass / 1000;
        } else if (mass_unit === 'dag') {
          mass = mass / 100;
        } else if (mass_unit === 't') {
          mass = mass / 0.001;
        } else if (mass_unit === 'gr') {
          mass = mass / 15432;
        } else if (mass_unit === 'dr') {
          mass = mass / 564.4;
        } else if (mass_unit === 'oz') {
          mass = mass / 35.274;
        } else if (mass_unit === 'lb') {
          mass = mass / 2.2046;
        } else if (mass_unit === 'stone') {
          mass = mass / 0.15747;
        } else if (mass_unit === 'us_ton') {
          mass = mass / 0.0011023;
        } else if (mass_unit === 'long_ton') {
          mass = mass / 0.0009842;
        } else if (mass_unit === 'earths') {
          mass = mass * 5972000000000000000000000;
        } else if (mass_unit === 'me') {
          mass = mass / 1097769122809886380500592292548;
        } else if (mass_unit === 'u') {
          mass = mass / 602214000000000000000000000;
        } else if (mass_unit === 'oz_t') {
          mass = mass / 32.15075;
        }
      }
      if (isFinite(gravity)) {
        if (gravity_unit === 'cm_s2') {
          gravity = gravity * 0.01;
        } else if (gravity_unit === 'in_s2') {
          gravity = gravity / 39.370078740157;
        } else if (gravity_unit === 'mi_h_s') {
          gravity = gravity / 2.24;
        } else if (gravity_unit === 'g') {
          gravity = gravity / 0.10193679918451;
        }
      }
      if (isFinite(height)) {
        if (height_unit === 'mm') {
          height = height / 1000;
        } else if (height_unit === 'cm') {
          height = height / 100;
        } else if (height_unit === 'km') {
          height = height / 0.001;
        } else if (height_unit === 'in') {
          height = height / 39.37;
        } else if (height_unit === 'ft') {
          height = height / 3.281;
        } else if (height_unit === 'yd') {
          height = height / 1.0936;
        } else if (height_unit === 'mi') {
          height = height / 0.0006214;
        } else if (height_unit === 'nmi') {
          height = height / 0.00054;
        }
      }


    let param = {};

    if (cal === 'mass' && isFinite(gravity) && isFinite(height) && isFinite(pe)) {
      console.log(gravity,height);
      mass = pe * (gravity * height);
      param.tech_ans = sigFig(mass, 4);
      param.tech_unit = 'kg';
      param.tech_g = gravity;
      param.tech_h = height;
      param.tech_pe = pe;
    } else if (cal === 'gravity' && isFinite(mass) && isFinite(height) && isFinite(pe)) {
      gravity = pe * (mass * height);
      param.tech_ans = sigFig(gravity, 4);
      param.tech_unit = 'm/s²';
      param.tech_m = mass;
      param.tech_h = height;
      param.tech_pe = pe;
    } else if (cal === 'height' && isFinite(mass) && isFinite(gravity) && isFinite(pe)) {
      height = pe * (mass * gravity);
      param.tech_ans = sigFig(height, 4);
      param.tech_unit = 'm';
      param.tech_m = mass;
      param.tech_g = gravity;
      param.tech_pe = pe;
    } else if (cal === 'pe' && isFinite(mass) && isFinite(gravity) && isFinite(height)) {
      pe = mass * gravity * height;
      param.tech_ans = sigFig(pe, 4);
      param.tech_unit = 'J';
      param.tech_m = mass;
      param.tech_g = gravity;
      param.tech_h = height;
    } else {
      param.error = 'Please fill all fields.';
      return param;
    }

    param.tech_cal = cal;
    param.tech_mass = sigFig(mass, 4);
    return param;
  }


      /** getCalculationWavelengthcalculator
   * POST: /api/calculators-lol/wavelength-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationWavelengthcalculator(body) {
    let find = body.tech_find?.trim();
    let velocity = parseFloat(body.tech_velocity);
    let velocity_unit = body.tech_velocity_unit?.trim();
    let frequency = parseFloat(body.tech_frequency);
    let frequency_unit = body.tech_frequency_unit?.trim();
    let wavelength = parseFloat(body.tech_wavelength);
    let wavelength_unit = body.tech_wavelength_unit?.trim();

    let result = {};

    if (!isNaN(wavelength)) {
        if (wavelength_unit === 'nm') {
          wavelength = wavelength / 1000000000;
        } else if (wavelength_unit === 'um') {
          wavelength = wavelength / 1000000;
        } else if (wavelength_unit === 'mm') {
          wavelength = wavelength / 1000;
        } else if (wavelength_unit === 'cm') {
          wavelength = wavelength / 100;
        } else if (wavelength_unit === 'km') {
          wavelength = wavelength / 0.001;
        } else if (wavelength_unit === 'in') {
          wavelength = wavelength / 39.3701;
        } else if (wavelength_unit === 'ft') {
          wavelength = wavelength / 3.28084;
        } else if (wavelength_unit === 'yd') {
          wavelength = wavelength / 1.093613;
        } else if (wavelength_unit === 'mi') {
          wavelength = wavelength / 0.000621371;
        }
      }
      if (!isNaN(frequency)) {
        if (frequency_unit === 'khz') {
          frequency = frequency / 0.001;
        } else if (frequency_unit === 'mhz') {
          frequency = frequency / 0.000001;
        } else if (frequency_unit === 'ghz') {
          frequency = frequency / 0.000000001;
        } else if (frequency_unit === 'thz') {
          frequency = frequency / 0.000000000001;
        }
      }
      if (!isNaN(velocity)) {
        if (velocity_unit === 'cms') {
          velocity = velocity / 100;
        } else if (velocity_unit === 'kmh') {
          velocity = velocity / 3.6;
        } else if (velocity_unit === 'fts') {
          velocity = velocity / 3.28084;
        } else if (velocity_unit === 'mph') {
          velocity = velocity / 2.236936;
        } else if (velocity_unit === 'knots') {
          velocity = velocity / 1.943844;
        } else if (velocity_unit === 'c') {
          velocity = velocity / 0.00000000333564;
        }
      }


    if (find === 'wavelength' && !isNaN(frequency) && !isNaN(velocity)) {
      wavelength = velocity / frequency;
      const wavenumber = frequency / velocity;
      result = {
        tech_unit: 'm',
        tech_ans: wavelength,
        tech_wn: wavenumber.toFixed(12),
        tech_wavelength:wavelength,
        tech_velocity:velocity,
        tech_find:find,
      };
    } else if (find === 'frequency' && !isNaN(wavelength) && !isNaN(velocity)) {
      frequency = velocity / wavelength;
      const wavenumber = frequency / velocity;
      result = {
        tech_unit: 'Hz',
        tech_ans: frequency,
        tech_wn: wavenumber.toFixed(12),
        tech_wavelength:wavelength,
        tech_velocity:velocity,
        tech_find:find,
      };
    } else if (find === 'velocity' && !isNaN(wavelength) && !isNaN(frequency)) {
      velocity = frequency * wavelength;
      const wavenumber = frequency / velocity;
      result = {
        tech_unit: 'm/s',
        tech_ans: velocity,
        tech_wn: wavenumber.toFixed(12),
        tech_wavelength:wavelength,
        tech_frequency:frequency,
        tech_find:find,
      };
    } else {
      result = {
        error: 'Please fill all fields.',
      };
    }

    return result;
  }


      /** getCalculationSpringConstantcalculator
   * POST: /api/calculators-lol/spring-constant-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async getCalculationSpringConstantcalculator(body) {
      let selection = body.tech_selection?.trim();
      let val1 = parseFloat(body.tech_spring_constant);
      let val2 = parseFloat(body.tech_spring_displacement);
      let val3 = parseFloat(body.tech_spring_force);
      let spring_displacement_unit = body.tech_spring_displacement_unit?.trim();

      let result = {};

      // Displacement unit conversion to meters
      const convertToMeters = (value, unit) => {
        if (unit === "m") return value;
        if (unit === "mm") return value / 1000;
        if (unit === "cm") return value / 100;
        if (unit === "inches") return value / 39.3701;
        if (unit === "feet") return value / 3.28084;
        if (unit === "yards") return value / 1.093613;
        return value;
      };

      // Displacement unit conversion from meters
      const convertFromMeters = (value, unit) => {
        if (unit === "m") return value;
        if (unit === "mm") return value * 1000;
        if (unit === "cm") return value * 100;
        if (unit === "inches") return value * 39.3701;
        if (unit === "feet") return value * 3.28084;
        if (unit === "yards") return value * 1.093613;
        return value;
      };

      if (selection === "1") {
        if (!isNaN(val1) && !isNaN(val2)) {
          let displacement = convertToMeters(val2, spring_displacement_unit);
          let force = -1 * displacement * val1;
          result.tech_fahad1 = force;
        } else {
          result.error = "Please fill all fields.";
        }

      } else if (selection === "2") {
        if (!isNaN(val2) && !isNaN(val3)) {
          let springConstant = val3 / val2;
          let converted = -1 * convertFromMeters(springConstant, spring_displacement_unit);
          result.tech_fahad2 = converted;
        } else {
          result.error = "Please fill all fields.";
        }

      } else if (selection === "3") {
        if (!isNaN(val1) && !isNaN(val3)) {
          let an = val3 / val1;
          result.tech_an = an;
          result.tech_ans = -1 * (an * 1000);       // mm
          result.tech_ans1 = -1 * (an * 100);        // cm
          result.tech_ans2 = -1 * (an * 39.3701);    // inches
          result.tech_ans3 = -1 * (an * 3.28084);    // feet
          result.tech_ans4 = -1 * (an * 1.093613);   // yards
        } else {
          result.error = "Please fill all fields.";
        }
      }

      return result;
    }


      /** getCalculationDewPointcalculator
   * POST: /api/calculators-lol/dew-point-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async getCalculationDewPointcalculator(body) {
      let to_cal = body.tech_to_cal;
      let temp = parseFloat(body.tech_temp);
      let temp_unit = body.tech_temp_unit;
      let hum = parseFloat(body.tech_hum);
      let dew = parseFloat(body.tech_dew);
      let dew_unit = body.tech_dew_unit;

      let result = {};
      const a = 17.62;
      const b = 243.12;

      // Convert units to °C
        if (temp_unit == "°C") {
            temp_unit = 1;
          } else if (temp_unit == "°F") {
            temp_unit = 2;
          } else if (temp_unit == "K") {
            temp_unit = 3;
          }

          if (dew_unit == "°C") {
            dew_unit = 1;
          } else if (dew_unit == "°F") {
            dew_unit = 2;
          } else if (dew_unit == "K") {
            dew_unit = 3;
          }


      if (to_cal === '1') {
        if (!isNaN(temp) && !isNaN(hum)) {
            if (temp_unit === '2') {
              temp = (temp - 32) * 5 / 9;
            } else if (temp_unit === '3') {
              temp = (temp) - 273.15;
            }


          if (temp < -45) {
            result.error = "Temperature should be greater than or equal to -45 °C (-49 °F)";
            return result;
          }

          let afun = Math.log(hum / 100) + (a * temp / (b + temp));
          let dp = (b * afun) / (a - afun);

          result.tech_dew = dp;
        } else {
          result.error = "Please fill all fields.";
        }

      } else if (to_cal === '2') {
        if (!isNaN(dew) && !isNaN(temp)) {

            if (temp_unit === '2') {
              temp = (temp - 32) * 5 / 9;
            } else if (temp_unit === '3') {
              temp = (temp) - 273.15;
            }
            if (dew_unit === '2') {
              dew = (dew - 32) * 5 / 9;
            } else if (dew_unit === '3') {
              dew = (dew) - 273.15;
            }
        
          if (temp < -45 || dew < -45) {
            result.error = "Temperature should be greater than or equal to -45 °C (-49 °F)";
            return result;
          }

          let rh_numer = 100.0 * Math.exp((a * dew) / (dew + b));
          let rh_denom = Math.exp((a * temp) / (temp + b));
          hum = rh_numer / rh_denom;

          result.tech_hum = hum;
        } else {
          result.error = "Please fill all fields.";
        }

      } else if (to_cal === '3') {
        if (!isNaN(hum) && !isNaN(dew)) {
        if (dew_unit === '2') {
              dew = (dew - 32) * 5 / 9;
            } else if (dew_unit === '3') {
              dew = (dew) - 273.15;
            }
          if (dew < -45) {
            result.error = "Temperature should be greater than or equal to -45 °C (-49 °F)";
            return result;
          }

          let gamma = (a * dew) / (b + dew);
          let temp_numer = b * (gamma - Math.log(hum / 100));
          let temp_denom = a + Math.log(hum / 100) - gamma;
          temp = temp_numer / temp_denom;

          result.tech_temp = temp;
        } else {
          result.error = "Please fill all fields.";
        }
      }

      return result;
    }



      /** getCalculationWetBulbcalculator
   * POST: /api/calculators-lol/wet-bulb-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
async getCalculationWetBulbcalculator(body) {
  let temp = parseFloat(body.tech_temp);
  let temp_unit = body.tech_temp_unit;
  let temp1 = parseFloat(body.tech_temp1);
  let temp1_unit = body.tech_temp1_unit;
  let hum = parseFloat(body.tech_hum);

  let result = {};

  // Convert units to °C
    if (temp_unit == "°C") {
        temp_unit = 1;
      } else if (temp_unit == "°F") {
        temp_unit = 2;
      } else if (temp_unit == "K") {
        temp_unit = 3;
      }

      if (temp1_unit == "°C") {
        temp1_unit = 1;
      } else if (temp1_unit == "°F") {
        temp1_unit = 2;
      } else if (temp1_unit == "K") {
        temp1_unit = 3;
      }

  if (!isNaN(temp) && !isNaN(hum)) {

    if (temp_unit == '2') {
				temp = (temp - 32) * 5 / 9;
			} else if (temp_unit == '3') {
				temp = (temp) - 273.15;
			}


    if (temp < -20 || temp > 50) {
      result.error = "This calculator only works for temperatures between -20 °C and 50 °C.";
      return result;
    }

    let ans = temp * Math.atan(0.151977 * Math.sqrt(hum + 8.313659)) +
              Math.atan(temp + hum) -
              Math.atan(hum - 1.676331) +
              0.00391838 * Math.pow(hum, 1.5) * Math.atan(0.023101 * hum) -
              4.686035;

    let indoor = 0.7 * ans + 0.3 * temp;
    result.tech_ans = ans;
    result.tech_indoor = indoor;

    if (!isNaN(temp1)) {
      if (temp1_unit === '2') {
					temp1 = (temp1 - 32) * 5 / 9;
				} else if (temp1_unit === '3') {
					temp1 = (temp1) - 273.15;
				}

      let outdoor = 0.7 * ans + 0.2 * temp1 + 0.1 * temp;
      result.tech_outdoor = outdoor;
    }

  } else {
    result.error = "Please fill all fields.";
  }

  return result;
}


        /** getCalculationTerminalVelocityCalculator
   * POST: /api/calculators-lol/terminal-velocity-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationTerminalVelocityCalculator(body) {
    let shapes = body.tech_shapes;
    let mass = body.tech_mass;
    let mass_unit = body.tech_mass_unit;
    let area = body.tech_area;
    let area_unit = body.tech_area_unit;
    let drag_coefficient = body.tech_drag_coefficient;
    let density = body.tech_density;
    let density_unit = body.tech_density_unit;
    let gravity = body.tech_gravity;
    let gravity_unit = body.tech_gravity_unit;

    function convertMass(value, unit) {
      switch (unit) {
        case "mg": return value * 0.000001;
        case "g": return value * 0.001;
        case "kg": return value * 1;
        case "t": return value * 1000;
        case "gr": return value * 0.0000648;
        case "oz": return value * 0.02835;
        case "lb": return value * 0.4536;
        default: return null;
      }
    }

    function convertArea(value, unit) {
      switch (unit) {
        case "mm²": return value * 0.000001;
        case "cm²": return value * 0.001;
        case "m²": return value * 1;
        case "in²": return value * 1000;
        case "yd²": return value * 0.0000648;
        default: return null;
      }
    }

    function convertDensity(value, unit) {
      switch (unit) {
        case "kg/m³": return value * 1;
        case "lb cu/ft": return value * 16.02;
        case "g/cm³": return value * 1000;
        case "kg/cm³": return value * 1000000;
        default: return null;
      }
    }

    function convertGravity(value, unit) {
      switch (unit) {
        case "m/s²": return value * 1;
        case "ft/s²": return value * 0.3048;
        default: return null;
      }
    }

    if (
      !isNaN(mass) && !isNaN(area) && !isNaN(drag_coefficient) &&
      !isNaN(density) && !isNaN(gravity) &&
      mass > 0 && area > 0 && drag_coefficient > 0 && density > 0 && gravity > 0
    ) {
      let m = convertMass(mass, mass_unit);
      let a = convertArea(area, area_unit);
      let f = convertDensity(density, density_unit);
      let d = convertGravity(gravity, gravity_unit);

      let terminal_velocity = Math.sqrt((2 * m * d) / (f * a * drag_coefficient));
      let drag_coefficient_area = a * drag_coefficient;

      return {
        tech_terminal_velocity: terminal_velocity,
        tech_drag_coefficient_area: drag_coefficient_area,
      };
    } else {
      return { error: "Please! Check Your Input" };
    }
  }


    /** getCalculationFrictionCalculator
   * POST: /api/calculators-lol/friction-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationFrictionCalculator(body) {
    let calculate = body.tech_calculate;
    let fr_co = body.tech_fr_co;
    let force = body.tech_force;
    let force_unit = body.tech_force_unit;
    let fr = body.tech_fr;
    let fr_unit = body.tech_fr_unit;
    let mass = body.tech_mass;
    let plane = body.tech_plane;
    let gravity = body.tech_gravity;

    function frictionUnit(unit, value) {
      switch (unit) {
        case "N": return value * 1;
        case "kN": return value * 1000;
        case "MN": return value * 1000000;
        case "GN": return value * 1000000000;
        case "TN": return value * 1000000000000;
        default: return null;
      }
    }

    let result = {};

    if (calculate === "1") { // Calculate Friction Coefficient
      if (!isNaN(force) && !isNaN(fr) && force > 0 && fr > 0) {
        let fr_value = frictionUnit(fr_unit, fr);
        let force_value = frictionUnit(force_unit, force);
        let friction_coefficient = fr_value / force_value;
        result.tech_friction_coefficient = friction_coefficient;
      } else {
        return { error: "Please fill all fields." };
      }

    } else if (calculate === "2") { // Calculate Normal Force
      if (!isNaN(fr) && !isNaN(fr_co) && fr > 0 && fr_co > 0) {
        let force_value = frictionUnit(fr_unit, fr);
        let calculate_force = force_value / fr_co;
        result.tech_calculate_force = calculate_force;
      } else {
        return { error: "Please fill all fields." };
      }

    } else if (calculate === "3") { // Friction
      if (!isNaN(force) && !isNaN(fr_co) && force > 0 && fr_co > 0) {
        let force_value = frictionUnit(force_unit, force);
        let friction = force_value * fr_co;
        result.tech_friction = friction;
      } else {
        return { error: "Please fill all fields." };
      }

    } else if (calculate === "4") { // Inclined Plane Friction
      if (!isNaN(mass) && !isNaN(plane) && !isNaN(fr_co) && !isNaN(gravity) && mass > 0) {
        if (fr_co > 0 && fr_co < 1) {
          let read = Math.cos((plane * Math.PI) / 180);
          let force_value = fr_co * mass * gravity * read;
          result.tech_friction2 = force_value;
        } else {
          return { error: "Please! Coefficient of friction should be in the range between 0 and 1" };
        }
      } else {
        return { error: "Please fill all fields." };
      }

    } else {
      return { error: "Invalid calculation option." };
    }

    return result;
  }


    /** getCalculationEscapeVelocityCalculator
   * POST: /api/calculators-lol/escape-velocity-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationEscapeVelocityCalculator(body) {
    let planet = body.tech_planet;
    let mass = body.tech_mass;
    let mass_unit = body.tech_mass_unit;
    let radius = body.tech_radius;
    let radius_unit = body.tech_radius_unit;
    let orbit = body.tech_orbit;
    let gravity = body.tech_gravity;
    let galaxy_mass = body.tech_galaxy_mass;
    let find = body.tech_find;
    let escape_velocity = body.tech_escape_velocity;
    let escape_unit = body.tech_escape_unit;

    function planetUnit(unit, value) {
      switch (unit) {
        case "kg": return value * 1;
        case "t": return value * 1000;
        case "lb": return value * 0.453592;
        case "oz": return value * 0.0283495;
        default: return null;
      }
    }

    function escapeUnit(unit2, value2) {
      switch (unit2) {
        case "m/s": return value2 * 1;
        case "km/h": return value2 * 0.277778;
        case "mph": return value2 * 0.44704;
        case "km/s": return value2 * 1000;
        default: return null;
      }
    }

    let result = {};

    if (find === "1") { // Find Escape Velocity
      if (
        !isNaN(mass) && !isNaN(radius) && !isNaN(orbit) &&
        !isNaN(gravity) && !isNaN(galaxy_mass)
      ) {
        let method = 1;
        let mass_value = planetUnit(mass_unit, mass);
        let first = (2 * gravity * mass_value) / radius;
        let escape_velocity = Math.sqrt(first / 1000) / 1000;
        let second = (gravity * mass_value) / radius;
        let first_cosmic_velocity = Math.sqrt(second / 1000) / 1000;
        let third = orbit * 1.496e11;
        let orbital_speed = Math.sqrt(gravity * galaxy_mass / third);
        let orbit_period = Math.sqrt(orbit * orbit * orbit);

        result.tech_escape_velocity = escape_velocity;
        result.tech_first_cosmic_velocity = first_cosmic_velocity;
        result.tech_orbital_speed = orbital_speed;
        result.tech_orbital_period = orbit_period;
        result.tech_method = method;
      } else {
        return { error: "Please fill all fields." };
      }

    } else if (find === "2") { // Find Mass
      if (
        !isNaN(escape_velocity) && !isNaN(radius) && !isNaN(orbit) &&
        !isNaN(gravity) && !isNaN(galaxy_mass)
      ) {
        let method = 2;
        let escape_value = escapeUnit(escape_unit, escape_velocity);
        let find_mass = (escape_value ** 2 * radius) / (2 * gravity);
        let first_cosmic_velocity = Math.sqrt(2) / escape_value;
        let third = orbit * 1.496e11;
        let orbital_speed = Math.sqrt(gravity * galaxy_mass / third);
        let orbit_period = Math.sqrt(orbit * orbit * orbit);

        result.tech_method = method;
        result.tech_escape_velocity = escape_velocity;
        result.tech_first_cosmic_velocity = first_cosmic_velocity;
        result.tech_orbital_speed = orbital_speed;
        result.tech_mass_value = find_mass;
        result.tech_orbital_period = orbit_period;
        return result;
      } else {
        return { error: "Please fill all fields." };
      }

    } else if (find === "3") { // Find Radius
      if (
        !isNaN(escape_velocity) && !isNaN(mass) && !isNaN(orbit) &&
        !isNaN(gravity) && !isNaN(galaxy_mass)
      ) {
        let method = 3;
        let escape_value = escapeUnit(escape_unit, escape_velocity);
        let mass_value = planetUnit(mass_unit, mass);
        let find_radius = (2 * gravity * mass_value) / (escape_value ** 2);
        let radius_value = find_radius / 1000;
        let first_cosmic_velocity = Math.sqrt(2) / escape_value;
        let third = orbit * 1.496e11;
        let orbital_speed = Math.sqrt(gravity * galaxy_mass / third);
        let orbit_period = Math.sqrt(orbit * orbit * orbit);

        result.tech_method = method;
        result.tech_escape_velocity = escape_velocity;
        result.tech_mass_value = radius_value;
        result.tech_first_cosmic_velocity = first_cosmic_velocity;
        result.tech_orbital_speed = orbital_speed;
        result.tech_orbital_period = orbit_period;
      } else {
        return { error: "Please fill all fields." };
      }
    }

    return result;
  }

    /** getCalculationGravityCalculator
   * POST: /api/calculators-lol/gravity-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationGravityCalculator(body) {
      let calculate = body.tech_calculate;
      let mass_one = body.tech_mass_one;
      let mass_one_unit = body.tech_mass_one_unit;
      let mass_two = body.tech_mass_two;
      let mass_two_unit = body.tech_mass_two_unit;
      let gravitational_force = body.tech_gravitational_force;
      let gravitational_force_unit = body.tech_gravitational_force_unit;
      let distance = body.tech_distance;
      let distance_unit = body.tech_distance_unit;
      let constant = body.tech_constant;
      let latitude = body.tech_latitude;
      let height = body.tech_height;
      let height_unit = body.tech_height_unit;

      const param = {};

      const distance_converts = (unit, value) => {
        const map = {
          "nm": value * 1e-9,
          "μm": value * 1e-6,
          "mm": value * 1e-3,
          "cm": value * 1e-2,
          "m": value,
          "km": value * 1e3,
          "in": value * 0.0254,
          "ft": value * 0.3048,
          "yd": value * 0.9144
        };
        return map[unit] ?? 0;
      };

      const mass_convert = (unit, value) => {
        const map = {
          "g": value * 1e-3,
          "kg": value,
          "t": value * 1e3,
          "oz": value * 0.0283495,
          "lb": value * 0.453592,
          "stone": value * 6.35029,
          "US ton": value * 907.185,
          "Long ton": value * 1016.047,
          "Earths": value * 5.9722e24,
          "Suns": value * 1.989e30,
          "me": 0,
          "mp": 0,
          "mn": 0
        };
        return map[unit] ?? 0;
      };

      const force_converts = (unit, value) => {
        const map = {
          "mN": value * 1e-3,
          "N": value,
          "kN": value * 1e3,
          "MN": value * 1e6,
          "GN": value * 1e9,
          "TN": value * 1e12,
          "pdl": value * 0.138255,
          "lbf": value * 4.44822
        };
        return map[unit] ?? 0;
      };


      const height_u = (unit, value) => {
        return unit === "m" ? value * 3.28084 : value;
      };

      let buttler = constant * 0.00000000001;

      if (calculate === "1") { // Gravitational Force
        if (mass_one > 0 && mass_two > 0 && distance > 0) {
          let m1 = mass_convert(mass_one_unit, mass_one);
          let m2 = mass_convert(mass_two_unit, mass_two);
          let d = distance_converts(distance_unit, distance);
          let force = (buttler * m1 * m2) / (d * d);
          param.tech_force = force;
        } else {
          return { error: "Please fill all fields." };
        }
      } else if (calculate === "2") { // Mass 1
        if (mass_two > 0 && distance > 0 && gravitational_force > 0) {
          let f = force_converts(gravitational_force_unit, gravitational_force);
          let m2 = mass_convert(mass_two_unit, mass_two);
          let d = distance_converts(distance_unit, distance);
          let m1 = (f * d * d) / (buttler * m2);
          param.tech_first_mass = m1;
        } else {
          return { error: "Please fill all fields." };
        }
      } else if (calculate === "3") { // Mass 2
        if (mass_one > 0 && distance > 0 && gravitational_force > 0) {
          let f = force_converts(gravitational_force_unit, gravitational_force);
          let m1 = mass_convert(mass_one_unit, mass_one);
          let d = distance_converts(distance_unit, distance);
          let m2 = (f * d * d) / (buttler * m1);
          param.tech_second_mass = m2;
        } else {
          return { error: "Please fill all fields." };
        }
      } else if (calculate === "4") { // Distance
        if (mass_one > 0 && mass_two > 0 && gravitational_force > 0) {
          let f = force_converts(gravitational_force_unit, gravitational_force);
          let m1 = mass_convert(mass_one_unit, mass_one);
          let m2 = mass_convert(mass_two_unit, mass_two);
          console.log(buttler,m1,m2,f);
          let d = (buttler * m1 * m2) / (f);
          param.tech_distance = d;
        } else {
          return { error: "Please fill all fields." };
        }
      } else if (calculate === "5") { // Gravity at latitude/height
        if (!isNaN(latitude) && !isNaN(height)) {
          let h = height_u(height_unit, height);
          let phi = latitude * (Math.PI / 180);
          let g = 9.780327 * (1 + 0.0053024 * Math.sin(phi) ** 2 - 0.0000058 * Math.sin(2 * phi) ** 2);
          g += -3.086e-6 * h;
          param.tech_g = g;
        } else {
          return { error: "Please fill all fields." };
        }
      }

      return param;
    }

    /** getCalculationArrowSpeedCalculator
   * POST: /api/calculators-lol/arrow-speed-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationArrowSpeedCalculator(body) {
      let first = body.tech_first;
      let units1 = body.tech_units1;
      let second = body.tech_second;
      let units2 = body.tech_units2;
      let third = body.tech_third;
      let units3 = body.tech_units3;
      let four = body.tech_four;
      let units4 = body.tech_units4;
      let five = body.tech_five;
      let units5 = body.tech_units5;

      function unit1(a, b) {
        if (a === "m/s") return b * 3.281;
        if (a === "km/h") return b / 1.097;
        if (a === "ft/s") return b;
        if (a === "mph") return b * 1.467;
        if (a === "knots") return b * 1.688;
      }

      function unit2(a, b) {
        if (a === "mm") return b / 25.4;
        if (a === "cm") return b / 2.54;
        if (a === "m") return b * 39.37;
        if (a === "km") return b * 39370;
        if (a === "in") return b;
        if (a === "ft") return b * 12;
        if (a === "yd") return b * 36;
        if (a === "mi") return b * 63360;
        if (a === "nmi") return b * 72910;
      }

      function unit3(a, b) {
        if (a === "g") return b / 453.6;
        if (a === "kg") return b * 2.205;
        if (a === "gr") return b / 7000;
        if (a === "oz") return b / 16;
        if (a === "lb") return b;
        if (a === "stone") return b * 14;
      }

      function unit4(a, b) {
        if (a === "mg") return b / 64.799;
        if (a === "g") return b * 15.432;
        if (a === "dag") return b * 154.3;
        if (a === "kg") return b * 15430;
        if (a === "gr") return b;
        if (a === "dr") return b * 60;
        if (a === "oz") return b * 437.5;
        if (a === "lb") return b * 7000;
        if (a === "stone") return b * 98000;
      }

      first = unit1(units1, first);
      second = unit2(units2, second);
      third = unit3(units3, third);
      four = unit4(units4, four);
      five = unit4(units5, five);

      if (
        isFinite(first) &&
        isFinite(second) &&
        isFinite(third) &&
        isFinite(four) &&
        isFinite(five)
      ) {
        let minus1 = second - 30;
        let mul1 = minus1 * 10;
        let div1 = five / 3;
        let part1 = first + mul1 - div1;

        let mul2 = 5 * third;
        let minus2 = four - mul2;
        let div2 = minus2 / 3;
        let minus_mul = div2 * -1;
        let part2 = Math.min(0, minus_mul);

        let speed = part1 + part2;
        let s_ms = speed / 3.281;
        let w_kg = four / 15430;
        let momentum = s_ms * w_kg;
        let sq_speed = Math.pow(s_ms, 2);
        let last_mul = w_kg * sq_speed;
        let k_energy = last_mul / 2;

        return {
          tech_speed:speed,
          tech_momentum:momentum,
          tech_k_energy:k_energy,
        };
      } else {
        return {
          error: "Please fill all fields.",
        };
      }
    }

    /** getCalculationElectricityCostCalculator
   * POST: /api/calculators-lol/electricity-cost-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationElectricityCostCalculator(body) {
    let type = body.tech_unit_type;

    let f_first = body.tech_f_first;
    let f_second = body.tech_f_second;
    let f_third = body.tech_f_third;

    let first = body.tech_first;
    let units1 = body.tech_units1;
    let second = body.tech_second;

    let third = body.tech_third;
    let units3 = body.tech_units3;

    function watt(a, b) {
      if (a === "mW") return b / 1000;
      if (a === "W") return b;
      if (a === "kW") return b * 1000;
      if (a === "MW") return b * 1000000;
      if (a === "GW") return b * 1000000000;
      if (a === "BTU") return b * 0.293071;
      if (a === "hp(l)") return b * 745.7;
    }

    function mont(a, b) {
      if (a === "days") return b * 30.4375;
      if (a === "wks") return b * 4.34821;
      if (a === "mons") return b;
      if (a === "yrs") return b * 0.0833333;
    }

    let answer, cost;

    if (type === "simple") {
      first = watt(units1, first);
      third = mont(units3, third);

      if (isFinite(first) && isFinite(second) && isFinite(third)) {
        let multiply = first * third;
        answer = multiply / 1000;
        cost = answer * second;
      } else {
        return { error: "Please fill all fields." };
      }

    } else if (type === "advance") {
      if (isFinite(f_first) && isFinite(f_second) && isFinite(f_third)) {
        let mul1 = f_second * 30;
        let mul2 = mul1 * f_first;
        answer = mul2 / 1000;
        cost = answer * f_third;
      } else {
        return { error: "Please fill all fields." };
      }
    }

    return {
      tech_answer:answer,
      tech_cost:cost
    };
    }

       /** getCalculationAirDensityCalculator
   * POST: /api/calculators-lol/air-density-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationAirDensityCalculator(body) {
    let first = body.tech_first;
    let unit1 = body.tech_unit1;
    let second = body.tech_second;
    let unit2 = body.tech_unit2;
    let operations1 = body.tech_operations1;
    let third = body.tech_third;


    let convert1,convert2;
    function pascal(a, b)
		{
			if (a = "Pa") {
				convert1 = b * 1;
			} else if (a = "mb") {
				convert1 = b * 100;
			} else if (a = "bar") {
				convert1 = b * 100000;
			} else if (a = "psi") {
				convert1 = b * 6895;
			} else if (a = "atm") {
				convert1 = b * 101325;
			} else if (a = "torr") {
				convert1 = b * 133.32;
			} else if (a = "hPa") {
				convert1 = b * 100;
			} else if (a = "kPa") {
				convert1 = b * 1000;
			} else if (a = "inHg") {
				convert1 = b * 3386.4;
			} else if (a = "mmHg") {
				convert1 = b * 133.32;
			}
			return convert1;
			
		}
		function kelvinC(a, b)
		{
			if (a = "°C") {
				convert2 = b * 1;
			} else if (a = "°F") {
				convert2 = (b - 32) * 0.55555555555555555555555555555556;
			} else if (a = "K") {
				convert2 = b - 273.15;
			}
			return convert2;
		}
		function kelvinK(a, b)
		{
			if (a = "°C") {
				convert2 = b + 274.15;
			} else if (a = "°F") {
				convert2 = (b - 32) * 0.55555555555555555555555555555556 + 273.15;
			} else if (a = "K") {
				convert2 = b * 1;
			}
			return convert2;
		}

  
  

  

    let result = { tech_operations1: operations1 };

    if (operations1 == "1") {
      first = pascal(unit1, first);
      // console.log(second,'ggg');
      second = kelvinK(unit2, second);
      
      if (isFinite(first) && isFinite(second)) {
        let mul = (second) * (287.05);
        console.log(first,mul);
        result.tech_air_density = first / mul;
      } else {
        return { error: "Please fill all fields." };
      }

    } else if (operations1 == "2") {
      first = pascal(unit1, first);
      second = kelvinC(unit2, second);

      if (isFinite(first) && isFinite(second) && isFinite(third)) {
        if (third > 0) {
          let P = first / 6895;
          let T = (second * 1.8 + 32) + 459.67;
          let psi = third / 100;
          let Md = 28.97;
          let Mw = 18.00;
          let Rbar = 1545;
          let ps = 0.08865 * Math.exp((-0.002369 * (T - 8375.65) * (T - 491.67)) / (T - 28.818));
          let air_density = (P * Md + psi * ps * (Mw - Md)) / Rbar / T / 12 / 32.174 * 12 * 12 * 12;

          let add = second + 237.3;
          let mul1 = 7.5 * second;
          let div = mul1 / add;
          let base = Math.pow(10, div);
          let p1 = base * 6.1078;
          let pv = p1 * third;
          let pd = first - pv;
          let d_mul1 = 287.058 * first;
          let d_mul2 = third * first;

          let l_div = d_mul1 === 0 ? 0 : pd / d_mul1;
          let r_div = d_mul2 === 0 ? 0 : pv / d_mul2;

          let p = l_div + r_div;
          let a_ln = Math.log10(third / 100);
          let a = a_ln + (17.62 * second) / (243.12 + second);
          let dp = 243.12 * a / (17.62 - a);

          result.tech_dp = dp;
          result.tech_pv = pv;
          result.tech_pd = pd;
          result.tech_air_density = air_density;
        } else {
          return { error: "Relative humidity must be greater than zero!" };
        }
      } else {
        return { error: "Please fill all fields." };
      }
    }

    return result;
  }

       /** getCalculationTimeofFlightCalculator
   * POST: /api/calculators-lol/time-of-flight-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async getCalculationTimeofFlightCalculator(body) {
      let a = parseFloat(body.tech_a);
      let a_unit = body.tech_a_unit?.trim();
      let h = parseFloat(body.tech_h);
      let h_unit = body.tech_h_unit?.trim();
      let v = parseFloat(body.tech_v);
      let v_unit = body.tech_v_unit?.trim();
      let g = parseFloat(body.tech_g);
      let g_unit = body.tech_g_unit?.trim();

      let param = {};

      function sigFig(value, digits) {
        if (value === 0) {
          return 0;
        }
        const decimalPlaces = digits - Math.floor(Math.log10(Math.abs(value))) - 1;
        return parseFloat(value.toFixed(decimalPlaces));
      }

      if (
        !isNaN(a) && !isNaN(h) && !isNaN(v) && !isNaN(g) &&
        a_unit && h_unit && v_unit && g_unit
      ) {
        // Convert height
        if (h_unit === 'cm') h /= 100;
        else if (h_unit === 'km') h /= 0.001;
        else if (h_unit === 'in') h /= 39.37;
        else if (h_unit === 'ft') h /= 3.281;
        else if (h_unit === 'yd') h /= 1.0936;
        else if (h_unit === 'mi') h /= 0.0006214;

        // Convert velocity
        if (v_unit === 'kmh') v /= 3.6;
        else if (v_unit === 'fts') v /= 3.28;
        else if (v_unit === 'mph') v /= 2.237;

        let vx, vy, sin;
        if (a_unit === 'deg') {
          vx = v * Math.cos(a * Math.PI / 180);
          sin = Math.sin(a * Math.PI / 180);
          vy = v * sin;
        } else {
          vx = v * Math.cos(a);
          sin = Math.sin(a);
          vy = v * sin;
        }

        // Convert gravity
        if (g_unit === 'g') {
          g = g * 9.807;
        }

        let tof;
        if (h === 0) {
          const res = 2 * vy;
          tof = 2 * vy / g;
          param['res'] = sigFig(res, 4);
        } else {
          const gh = 2 * g * h;
          const pvy = Math.pow(vy, 2);
          const vs2gh = pvy + gh;
          const sqrvs2gh = Math.sqrt(vs2gh);
          const vysqrt = vy + sqrvs2gh;
          tof = vysqrt / g;

          param['tech_pvy'] = pvy;
          param['tech_gh'] = gh;
          param['tech_vs2gh'] = vs2gh;
          param['tech_sqrvs2gh'] = sqrvs2gh;
          param['tech_vysqrt'] = sigFig(vysqrt, 4);
        }

        param['tech_h'] = h;
        param['tech_a'] = a;
        param['tech_sin'] = sigFig(sin, 4);
        param['tech_v'] = sigFig(v, 4);
        param['tech_tof'] = sigFig(tof, 4);
        param['tech_check'] = 'tof';
        param['tech_g'] = sigFig(g, 4);
        param['tech_vx'] = sigFig(vx, 4);
        param['tech_vy'] = sigFig(vy, 4);
        return param;
      } else {
        return { error: 'Please fill all fields.' };
      }
    }


       /** getCalculationFrictionalForceCalculator
   * POST: /api/calculators-lol/frictional-force-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
async getCalculationFrictionalForceCalculator(body) {
  let calculate = body.tech_calculate;
  let fr_co = parseFloat(body.tech_fr_co);
  let force = parseFloat(body.tech_force);
  let force_unit = body.tech_force_unit?.trim();
  let fr = parseFloat(body.tech_fr);
  let fr_unit = body.tech_fr_unit?.trim();
  let mass = parseFloat(body.tech_mass);
  let plane = parseFloat(body.tech_plane);
  let gravity = parseFloat(body.tech_gravity);
  
  let param = {};

  function frictional_unit(unit, value) {
    switch (unit) {
      case "N": return value * 1;
      case "kN": return value * 1000;
      case "MN": return value * 1000000;
      case "GN": return value * 1000000000;
      case "TN": return value * 1000000000000;
      default: return NaN;
    }
  }

  if (calculate === "1") { // Calculate Friction Coefficient
    if (!isNaN(force) && !isNaN(fr) && force > 0 && fr > 0) {
      const fr_value = frictional_unit(fr_unit, fr);
      const force_value = frictional_unit(force_unit, force);
      const friction_coefficient = fr_value / force_value;

      param['tech_friction_coefficient'] = friction_coefficient;
      param['tech_fr_value'] = fr_value;
      param['tech_force_value'] = force_value;
    } else {
      return { error: 'Please fill all fields.' };
    }

  } else if (calculate === "2") { // Calculate Normal Force
    if (!isNaN(fr) && !isNaN(fr_co) && fr > 0 && fr_co > 0) {
      const force_value = frictional_unit(fr_unit, fr);
      const calculate_force = force_value / fr_co;

      param['tech_calculate_force'] = calculate_force;
      param['tech_force_value'] = force_value;
      param['tech_fr_co'] = fr_co;
    } else {
      return { error: 'Please fill all fields.' };
    }

  } else if (calculate === "3") { // Friction Force
    if (!isNaN(force) && !isNaN(fr_co) && force > 0 && fr_co > 0) {
      const force_value = frictional_unit(force_unit, force);
      const friction = force_value * fr_co;

      param['tech_friction'] = friction;
      param['tech_force_value'] = force_value;
      param['tech_fr_co'] = fr_co;
    } else {
      return { error: 'Please fill all fields.' };
    }

  } else if (calculate === "4") { // Inclined Plane Friction
    if (!isNaN(mass) && !isNaN(plane) && !isNaN(fr_co) && !isNaN(gravity) && mass > 0) {
      if (fr_co > 0 && fr_co < 1) {
        const read = Math.cos(plane * Math.PI / 180);
        const force_value = fr_co * mass * gravity * read;

        param['tech_friction2'] = force_value;
        param['tech_mass'] = mass;
        param['tech_fr_co'] = fr_co;
        param['tech_plane'] = plane;
        param['tech_read'] = read;
        param['tech_gravity'] = gravity;
      } else {
        return { error: 'Please! Coefficient of friction should be between 0 and 1' };
      }
    } else {
      return { error: 'Please fill all fields.' };
    }
  }

  return param;
}


      /** getCalculationMechanicalEnergyCalculator
   * POST: /api/calculators-lol/mechanical-energy-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async  getCalculationMechanicalEnergyCalculator(body) {
    let mass = parseFloat(body.tech_mass);
    let mass_unit = body.tech_mass_unit?.trim();
    let velocity = parseFloat(body.tech_velocity);
    let velocity_unit = body.tech_velocity_unit?.trim();
    let height = parseFloat(body.tech_height);
    let height_unit = body.tech_height_unit?.trim();
    let engergyunit = body.tech_engergyunit?.trim();

    let param = {};

    function unit_kg(a, b) {
      switch (b) {
        case "kg": return a * 1;
        case "g": return a / 1000;
        case "mg": return a / 1000000;
        case "mu-gr": return a / 1000000000;
        case "ct": return a / 5000;
        case "lbs": return a / 2.205;
        case "troy": return a * 0.0311;
        case "ozm": return a * 0.02834952;
        case "slug": return a * 14.594;
        case "ton(short)": return a * 907.2;
        default: return NaN;
      }
    }

    function unit_ms(a, b) {
      switch (b) {
        case "m/s": return a * 1;
        case "ft/min": return a / 196.9;
        case "ft/s": return a / 3.281;
        case "km/hr": return a / 3.6;
        case "knot (int'l)": return a / 1.944;
        case "mph": return a / 2.237;
        case "miles/hr": return a / 1.151;
        case "miles/min": return a * 0.447 * 60;
        case "miles/s": return a / 1609;
        case "speed of light": return a * 299800000;
        default: return NaN;
      }
    }

    function unit_m(a, b) {
      switch (b) {
        case "m": return a * 1;
        case "AU": return a * 149600000000;
        case "cm": return a / 100;
        case "km": return a * 1000;
        case "ft": return a / 3.281;
        case "in": return a / 39.37;
        case "mil": return a / 39370;
        case "mm": return a / 1000;
        case "nm": return a / 1000000000;
        case "mile": return a * 1609;
        case "parsec": return a * 3.086e+16;
        case "pm": return a / 1000000000000;
        case "yd": return a / 1.094;
        default: return NaN;
      }
    }

    function energy_unit(a, b) {
      switch (b) {
        case "1": return a * 1;
        case "2": return a / 1055;
        case "3": return a / 1055;
        case "4": return a * 0.239006;
        case "5": return a * 6.242e+18;
        case "6": return a * 10000000;
        case "7": return a / 1.356;
        case "8": return a * 23.73036;
        case "9": return a * 0.0000003725061361;
        case "10": return a / 4184;
        case "11": return a / 3600000;
        case "12": return a / 4184000000;
        case "13": return a * 1;
        case "14": return a / 3600;
        case "15": return a * 1;
        default: return NaN;
      }
    }

    if (!isNaN(mass) && !isNaN(velocity) && !isNaN(height)) {
      mass = unit_kg(mass, mass_unit);
      velocity = unit_ms(velocity, velocity_unit);
      height = unit_m(height, height_unit);

      let kinatic_eng = 0.5 * mass * velocity ** 2;
      let potentional_eng = mass * 9.8 * height;
      let mechanical_eng = kinatic_eng + potentional_eng;

      let mechanical_energy = energy_unit(mechanical_eng, engergyunit);
      let kinatic_engrgy = energy_unit(kinatic_eng, engergyunit);
      let potentional_engergy = energy_unit(potentional_eng, engergyunit);

      param.tech_mass = mass;
      param.tech_velocity = velocity;
      param.tech_height = height;
      param.tech_kinatic_eng = kinatic_eng;
      param.tech_potentional_eng = potentional_eng;
      param.tech_mechanical_eng = mechanical_eng;
      param.tech_mechanical_energy = mechanical_energy;
      param.tech_kinatic_engrgy = kinatic_engrgy;
      param.tech_potentional_engergy = potentional_engergy;

    } else {
      return { error: 'Please fill all fields.' };
    }

    return param;
  }


      /** getCalculationIndexOfRefractionCalculation
   * POST: /api/calculators-lol/index-of-refraction-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
async  getCalculationIndexOfRefractionCalculation(body) {
  let selection = body.tech_selection?.trim();
  let medium_v = body.tech_medium_v?.trim();
  let medium_value = parseFloat(body.tech_medium_value);
  let medium_value_unit = body.tech_medium_value_unit?.trim();
  let medium_value_unit1 = body.tech_medium_value_unit1?.trim();
  let medium_v2 = body.tech_medium_v2?.trim();
  let medium_value2 = parseFloat(body.tech_medium_value2);

  let param = {};

  function speed_unit(a, b) {
    if (b == "m/s") {
      return a / 1000;
    } else if (b == "km/s") {
      return a * 1;
    } else if (b == "mi/s") {
      return a * 1.609;
    } else if (b == "c") {
      return a * 299800;
    } else {
      return NaN;
    }
  }
  if (selection === "1") {
    if (!isNaN(medium_value) && !isNaN(medium_value2)) {
      medium_value = speed_unit(medium_value, medium_value_unit);
      console.log(medium_value);
      let index_of_refraction = 299792.46 / medium_value;
      param.tech_index_of_refraction = index_of_refraction;
    } else {
      return { error: 'Please fill all fields.' };
    }
  } else if (selection === "2") {
    if (!isNaN(medium_value) && !isNaN(medium_value2)) {


      medium_value = speed_unit(medium_value, medium_value_unit);


      medium_value2 = speed_unit(medium_value2, medium_value_unit1);


      console.log(medium_value,medium_value2);




      let index_of_refraction = 299792.46 / medium_value;
      let index_of_refraction2 = 299792.46 / medium_value2;
      let reflective_index = index_of_refraction2 / index_of_refraction;
      param.tech_reflective_index = reflective_index;
    } else {
      return { error: 'Please fill all fields.' };
    }
  } else {
    return { error: 'Invalid selection value.' };
  }

  return param;
}

      /** getCalculationWHPtoHPCalculation
   * POST: /api/calculators-lol/whp-to-hp-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationWHPtoHPCalculation(body) {
    let submit = body.tech_type;
    let dt = parseFloat(body.tech_dt);
    let whp = parseFloat(body.tech_whp);
    let dtlf = parseFloat(body.tech_dtlf);
    let ehp = parseFloat(body.tech_ehp);

    let param = {};

    if (submit === 'whpToHp') {
      if (!isNaN(dt) && !isNaN(whp)) {
        let hp = whp / (1 - dt);
        param.tech_submit = submit;
        param.tech_whp = whp;
        param.tech_dt = dt;
        param.tech_hp = hp.toFixed(2);
      } else {
        param.error = 'Please! Check Your Input';
      }
    } else {
      if (!isNaN(dtlf) && !isNaN(ehp)) {
        whp = ehp / dtlf;
        param.tech_submit = submit;
        param.tech_ehp = ehp;
        param.tech_dtlf = dtlf;
        param.tech_whp = whp.toFixed(2);
      } else {
        param.error = 'Please! Check Your Input';
      }
    }

    return param;
  }


      /** getCalculationAverageSpeedCalculation
   * POST: /api/calculators-lol/average-speed-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async  getCalculationAverageSpeedCalculation(body) {
    let t_hours = parseFloat(body.tech_t_hours);
    let t_min = parseFloat(body.tech_t_min);
    let t_sec = parseFloat(body.tech_t_sec);
    let distance = parseFloat(body.tech_distance);
    let distance_unit = body.tech_distance_unit;

    let param = {};

    function speed_unitsadd(a, b) {
      if (b == "miles") {
        return a * 1609;
      } else if (b == "km") {
        return a * 1000;
      } else if (b == "yards") {
        return a / 1.094;
      } else if (b == "foot") {
        return a / 3.281;
      } else if (b == "meters") {
        return a;
      }
      return null;
    }

    if (!isNaN(t_hours) && !isNaN(t_min) && !isNaN(t_sec) && !isNaN(distance)) {
      let dis_val = speed_unitsadd(distance, distance_unit);
      console.log(dis_val);
      let total_seconds = (t_hours * 3600) + (t_min * 60) + t_sec;
      let ans_mps = dis_val / total_seconds;
      let ans_mphh = ans_mps * 3600;
      let ans_ydph = ans_mps * 3937;
      let ans_ftph = ans_mps * 11810;
      let ans_mph = ans_mps * 2.237;
      let ans_kmh = ans_mps * 3.6;

      param.tech_ans_mps = ans_mps;
      param.tech_ans_mph = ans_mph;
      param.tech_ans_kmh = ans_kmh;
      param.tech_ans_mphh = ans_mphh;
      param.tech_ans_ydph = ans_ydph;
      param.tech_ans_ftph = ans_ftph;
    } else {
      param.error = 'Please fill all fields.';
    }

    return param;
  }


      /** getCalculationdBmtoWattsCalculation
   * POST: /api/calculators-lol/dbm-to-watts
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationdBmtoWattsCalculation(body) {
      let calculation = String(body.tech_calculation).trim();
      let input = parseFloat(body.tech_input);
      let param = {};

      if (!isNaN(input)) {
        let answer;
        let unit;

        if (calculation === "1") {
          let divide = input / 10;
          let pow = Math.pow(10, divide);
          answer = pow / 1000;
          unit = "W";
        } else if (calculation === "2") {
          let divide = input / 10;
          let pow = Math.pow(10, divide);
          let watts = pow / 1000;
          answer = watts * 1000;
          unit = "mW";
        } else if (calculation === "3") {
          answer = (10 * Math.log10(input)) + 30;
          unit = "dBm";
        } else {
          let miliwatts = input * 1000;
          answer = 10 * Math.log10(miliwatts);
          unit = "dBm";
        }

        param.tech_unit = unit;
        param.tech_answer = answer;
      } else {
        param.error = 'Please! Check Your Input';
      }

      return param;
    }

      /** getCalculationdCapacitanceCalculation
   * POST: /api/calculators-lol/capacitance-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationdCapacitanceCalculation(body) {
      let area = parseFloat(body.tech_area);
      let area_unit = String(body.tech_area_unit).trim();
      let permittivity = parseFloat(body.tech_permittivity);
      let distance = parseFloat(body.tech_distance);
      let dis_unit = String(body.tech_dis_unit).trim();
      let param = {};

      function areaConvert(a, b) {
        switch (b) {
          case "mm²": return a * 1;
          case "cm²": return a * 100;
          case "m²": return a * 1000000;
          case "in²": return a * 645.16;
          case "ft²": return a * 92900;
          default: return a * 836100; // yd² or fallback
        }
      }

      function disConvert(a, b) {
        switch (b) {
          case "mm": return a * 1;
          case "cm": return a * 10;
          case "m": return a * 1000;
          case "in": return a * 25.4;
          case "ft": return a * 304.8;
          default: return a * 914.4; // yd or fallback
        }
      }

      area = areaConvert(area, area_unit);
      distance = disConvert(distance, dis_unit);

      if (!isNaN(area) && !isNaN(distance) && !isNaN(permittivity)) {
        if (permittivity <= 0) {
          param.error = 'Capacitance should be greater than 0';
          return param;
        }

        let mf_ans = (permittivity * area) / distance;
        let f_ans = 0.001 * mf_ans;
        let microf_ans = 1000 * mf_ans;
        let nf_ans = 1000000 * mf_ans;
        let pf_ans = 1000000000 * mf_ans;

        param.tech_mf_ans = mf_ans;
        param.tech_f_ans = f_ans;
        param.tech_microf_ans = microf_ans;
        param.tech_nf_ans = nf_ans;
        param.tech_pf_ans = pf_ans;
      } else {
        param.error = 'Please! Check Your Input';
      }

      return param;
    }


      /** getCalculationdAngleofDeviationCalculation
   * POST: /api/calculators-lol/angle-of-deviation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationdAngleofDeviationCalculation(body) {
      let incidence = parseFloat(body.tech_incidence);
      let incidence_unit = String(body.tech_incidence_unit).trim();
      let emergence = parseFloat(body.tech_emergence);
      let emergence_unit = String(body.tech_emergence_unit).trim();
      let prism = parseFloat(body.tech_prism);
      let prism_unit = String(body.tech_prism_unit).trim();
      let deviation_unit = String(body.tech_deviation_unit).trim(); // not used, but retained
      let param = {};

      function unitsOfDeviation(value, unit) {
        switch (unit) {
          case "circle": return value * 360;
          case "cycle": return value * 359.8981;
          case "degree": return value;
          case "gon": return value * 0.9;
          case "gradian": return value * 0.9;
          case "mil": return value * 0.05625;
          case "milliradian": return value * 0.057296;
          case "minute":  return value * 0.016667;
          case "minutes of arc": return value * 0.016667;
          case "point": return value * 11.25;
          case "quadrant": return value * 90;
          case "quartercircle": return value * 90;
          case "right angle": return value * 90;
          case "radian": return value * 57.29578;
          case "revolution": return value * 360;
          case "turn": return value * 360;
          case "second": return value * 0.000278;
          case "semicircle": return value * 180;
          case "sextant": return value * 60;
          case "sign": return value * 30;
          default: return NaN;
        }
      }

      if (!isNaN(incidence) && !isNaN(emergence) && !isNaN(prism)) {
        incidence = unitsOfDeviation(incidence, incidence_unit);
        emergence = unitsOfDeviation(emergence, emergence_unit);
        prism = unitsOfDeviation(prism, prism_unit);

        let deviation = incidence + emergence - prism;

        param.tech_deviation = deviation;
        param.tech_incidence = incidence;
        param.tech_emergence = emergence;
        param.tech_prism = prism;
      } else {
        param.error = 'Please! Check Your Input';
      }

      return param;
    }


      /** getCalculationdElectricPotentialCalculation
   * POST: /api/calculators-lol/electric-potential-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationdElectricPotentialCalculation(body) {
      let potential_type = body.tech_potential_type;
      let points = body.tech_points;
      let Q = body.tech_Q;
      let unit_Q = body.tech_unit_Q;
      let charge = body.tech_charge;
      let charge_unit = body.tech_charge_unit;
      let R = body.tech_R;
      let unit_R = body.tech_unit_R;
      let distance = body.tech_distance;
      let distance_unit = body.tech_distance_unit;
      let E = parseFloat(body.tech_E);
      let U = body.tech_U;
      let U_unit = body.tech_U_unit;

      let param = {};

      function convertToCoulomb(value, unit) {
        switch (unit) {
          case 'C': return value;
          case 'e': return value * 1.6022e-19;
          case 'mC': return value * 1e-3;
          case 'μC': return value * 1e-6;
          case 'nC': return value * 1e-9;
          case 'PC': return value * 1e-12;
          default: return NaN;
        }
      }

      function convertToMeter(value, unit) {
        switch (unit) {
          case 'm': return value;
          case 'cm': return value * 0.01;
          case 'mm': return value * 0.001;
          case 'μm': return value * 1e-6;
          case 'nm': return value * 1e-9;
          case 'in': return value * 0.0254;
          case 'ft': return value * 0.3048;
          case 'yd': return value * 0.9144;
          default: return NaN;
        }
      }

      function convertToJoules(value, unit) {
        switch (unit) {
          case 'J': return value;
          case 'kJ': return value * 1000;
          case 'MJ': return value * 1e6;
          case 'Wh': return value * 3600;
          case 'kWh': return value * 3.6e6;
          case 'kcal': return value * 4184;
          case 'eV': return value * 1.60218e-19;
          default: return NaN;
        }
      }

      let v;

      if (potential_type === 'single-point') {
        if (!isNaN(charge) && !isNaN(distance) && charge_unit && distance_unit && !isNaN(E)) {
          let coulombs = convertToCoulomb(parseFloat(charge), charge_unit);
          let meters = convertToMeter(parseFloat(distance), distance_unit);
          v = ((8.99e9 * coulombs) / meters) / E;
        } else {
          param.error = 'Please! Check Your Input';
          return param;
        }

      } else if (potential_type === 'multi-point') {
        if (Array.isArray(Q) && Array.isArray(R) && Array.isArray(unit_Q) && Array.isArray(unit_R) && !isNaN(points) && !isNaN(E)) {
          let QR = [];

          for (let i = 0; i < points; i++) {
            let coulombs = convertToCoulomb(parseFloat(Q[i]), unit_Q[i]);
            let meters = convertToMeter(parseFloat(R[i]), unit_R[i]);
            QR[i] = meters > 0 ? (coulombs / meters) : 0;
          }

          let QRSum = QR.reduce((sum, val) => sum + val, 0);
          v = (8.99e9 * QRSum) / E;
        } else {
          param.error = 'Please! Check Your Input';
          return param;
        }

      } else if (potential_type === 'difference') {
        if (!isNaN(U) && U_unit && !isNaN(charge) && charge_unit) {
          let coulombs = convertToCoulomb(parseFloat(charge), charge_unit);
          let joules = convertToJoules(parseFloat(U), U_unit);
          v = joules / coulombs;
        } else {
          param.error = 'Please! Check Your Input';
          return param;
        }

      } else {
        param.error = 'Invalid potential_type';
        return param;
      }

      let scientificNotation = v.toExponential(3);
      let [mantissa, exponent] = scientificNotation.split('e');
      let answer = `${mantissa} X 10<sup>${parseInt(exponent)}</sup>`;

      param.tech_answer = answer;
      return param;
    }


      /** getCalculationdWaveSpeedCalculation
   * POST: /api/calculators-lol/wave-speed-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationdWaveSpeedCalculation(body) {
      let frequency = parseFloat(body.tech_frequency);
      let f_unit = body.tech_f_unit;
      let wavelength = parseFloat(body.tech_wavelength);
      let w_units = body.tech_w_units;

      let param = {};

      if (!isNaN(frequency) && !isNaN(wavelength)) {
        // Frequency unit conversion
        switch (f_unit) {
          case 'kHz': frequency *= 1e3; break;
          case 'MHz': frequency *= 1e6; break;
          case 'GHz': frequency *= 1e9; break;
          case 'THz': frequency *= 1e12; break;
        }

        // Wavelength unit conversion
        switch (w_units) {
          case 'nm': wavelength *= 1e-9; break;
          case 'μm': wavelength *= 1e-6; break;
          case 'mm': wavelength *= 1e-3; break;
          case 'cm': wavelength *= 1e-2; break;
          case 'km': wavelength *= 1e3; break;
          case 'in': wavelength *= 0.0254; break;
          case 'ft': wavelength *= 0.3048; break;
          case 'yd': wavelength *= 0.9144; break;
          case 'mi': wavelength *= 1609.344; break;
        }

        let t = 1 / frequency;         // Period
        let vn = 1 / wavelength;       // Wavenumber
        let v = frequency * wavelength; // Wave speed

        param.tech_frequency = frequency;
        param.tech_wavelength = wavelength;
        param.tech_t = t;
        param.tech_vn = vn;
        param.tech_v = v;

        return param;
      } else {
        param.error = 'Please! Check Your Input';
        return param;
      }
    }


     /** getCalculationdElectricFluxCalculation
   * POST: /api/calculators-lol/electric-flux-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationdElectricFluxCalculation(body) {
      let electric = parseFloat(body.tech_electric?.toString().trim());
      let surface = parseFloat(body.tech_surface?.toString().trim());
      let degree = parseFloat(body.tech_degree?.toString().trim());
      let charge = parseFloat(body.tech_charge?.toString().trim());
      let unit = body.tech_unit?.toString().trim();
      let constant = parseFloat(body.tech_const?.toString().trim());
      let power = parseFloat(body.tech_power?.toString().trim());

      let param = {};

      function sigFig1(value, digits) {
        if (value === 0) return 0;
        let decimalPlaces = digits - Math.floor(Math.log10(Math.abs(value))) - 1;
        return Number(value.toFixed(decimalPlaces));
      }

      if (
        !isNaN(electric) &&
        !isNaN(surface) &&
        !isNaN(degree) &&
        !isNaN(charge) &&
        !isNaN(constant) &&
        !isNaN(power)
      ) {
        // Charge unit conversion
        switch (unit) {
          case 'picocoulomb': charge *= 0.001; break;
          case 'microcoulomb': charge *= 1000; break;
          case 'millicoulomb': charge *= 1e6; break;
          case 'coulomb': charge *= 1e9; break;
          case 'elementry': charge *= 1.602e-10; break;
          case 'ampere': charge *= 3.6e12; break;
          case 'milliampere': charge *= 3.6e9; break;
        }

        // Gauss Law calculation
        let total = constant * Math.pow(10, power);
        let flux = charge / total;

        // Inward flux
        let sum = 180 - degree;
        let cos = Math.cos(sum * Math.PI / 180);
        let inward = electric * surface * cos;

        // Outward flux
        let cosOutward = Math.cos(degree * Math.PI / 180);
        let outward = electric * surface * cosOutward;

        param.tech_flux = flux;
        param.tech_inward = sigFig1(inward, 6);
        param.tech_cosoutward = sigFig1(cosOutward, 5);
        param.tech_outward = sigFig1(outward, 6);
        param.tech_electric = electric;
        param.tech_surface = surface;
        param.tech_degree = degree;
        param.tech_charge = charge;
        param.tech_const = constant;
        param.tech_power = power;
        param.tech_cos = sigFig1(cos, 4);
        param.tech_sum = sum;
        return param;
      } else {
        param.error = 'Please! Check Your Input';
        return param;
      }
    }


    /** getCalculationdAmpstoWattsCalculation
   * POST: /api/calculators-lol/amps-to-watts-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async  getCalculationdAmpstoWattsCalculation(body) {
    let current_type = body.tech_current_type;
    let current = parseFloat(body.tech_current);
    let current_unit = body.tech_current_unit;
    let voltage_type = body.tech_voltage_type;
    let voltage = parseFloat(body.tech_voltage);
    let voltage_unit = body.tech_voltage_unit;
    let power = parseFloat(body.tech_power);

    let param = {};

    function convertVoltage(value, unit) {
      if (unit === "mV") return value / 1000;
      if (unit === "V") return value;
      return value * 1000; // Assume kV
    }

    function convertCurrent(value, unit) {
      if (unit === "mA") return value / 1000;
      if (unit === "A") return value;
      return value * 1000; // Assume kA
    }

    if (!isNaN(current) && !isNaN(voltage)) {
      current = convertCurrent(current, current_unit);
      voltage = convertVoltage(voltage, voltage_unit);

      let power_ans = 0;

      if (current_type === "DC") {
        power_ans = current * voltage;
      } else if (current_type === "AC") {
        if (!isNaN(power)) {
          power_ans = current * voltage * power;
        } else {
          param.error = "Please! Check Your Input";
          return param;
        }
      } else {
        if (!isNaN(power)) {
          if (voltage_type === "ltl") {
            power_ans = 1.7320508 * current * voltage * power;
          } else {
            power_ans = 3 * current * voltage * power;
          }
        } else {
          param.error = "Please! Check Your Input";
          return param;
        }
      }

      param.tech_power_ans = power_ans;
      return param;
    } else {
      param.error = "Please! Check Your Input";
      return param;
    }
  }


    /** getCalculationdWattstoAmpsCalculation
   * POST: /api/calculators-lol/amps-to-watts-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationdWattstoAmpsCalculation(body) {
      let current_type = body.tech_current_type;
      let power = parseFloat(body.tech_power);
      let power_unit = body.tech_power_unit;
      let voltage_type = body.tech_voltage_type;
      let voltage = parseFloat(body.tech_voltage);
      let voltage_unit = body.tech_voltage_unit;
      let power_factor = parseFloat(body.tech_power_factor);

      let param = {};

      function convert(value, unit) {
        if (unit === "mW" || unit === "mV") return value / 1000;
        if (unit === "W" || unit === "V") return value;
        return value * 1000; // Assume kW/kV
      }

      if (!isNaN(power) && !isNaN(voltage)) {
        power = convert(power, power_unit);
        voltage = convert(voltage, voltage_unit);

        let amps_ans = 0;

        if (current_type === "DC") {
          amps_ans = power / voltage;
        } else if (current_type === "AC") {
          if (!isNaN(power_factor)) {
            amps_ans = power / (voltage * power_factor);
          } else {
            param.error = "Please! Check Your Input";
            return param;
          }
        } else {
          if (!isNaN(power_factor)) {
            if (voltage_type === "ltl") {
              amps_ans = power / (1.7320508 * voltage * power_factor);
            } else {
              amps_ans = power / (3 * voltage * power_factor);
            }
          } else {
            param.error = "Please! Check Your Input";
            return param;
          }
        }

        param.tech_amps_ans = amps_ans;
        return param;
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }
    }

    /** getCalculationdResultantForceCalculation
   * POST: /api/calculators-lol/resultant-force-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationdResultantForceCalculation(body) {
    let forces = body.tech_force;
    let angles = body.tech_angle;

    let param = {};

    function degToRad(degrees) {
      return degrees * (Math.PI / 180);
    }

    function calculateResultantForce(forces, angles) {
      let Fx = 0;
      let Fy = 0;

      for (let i = 0; i < forces.length; i++) {
        Fx += forces[i] * Math.cos(degToRad(angles[i]));
        Fy += forces[i] * Math.sin(degToRad(angles[i]));
      }

      let magnitude = Math.sqrt(Fx ** 2 + Fy ** 2);
      let direction = Math.atan2(Fy, Fx) * (180 / Math.PI);

      return {
        Fx,
        Fy,
        magnitude,
        direction
      };
    }

    if (Array.isArray(forces) && Array.isArray(angles)) {
      if (forces.length !== angles.length) {
        param.error = 'Number of forces and angle must be the same.';
        return param;
      }

      const result = calculateResultantForce(forces, angles);

      param.tech_Horizontal = result.Fx;
      param.tech_Vertical = result.Fy;
      param.tech_Magnitude = result.magnitude;
      param.tech_Direction = result.direction;
      return param;
    } else {
      param.error = 'Please! Check Your Input';
      return param;
    }
  }

     /** getCalculationAverageVelocityCalculation
   * POST: /api/calculators-lol/average-velocity-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationAverageVelocityCalculation(body) {
    let x = body.tech_x;
    let y = body.tech_y;
    let ivUnit = body.tech_iv;
    let fvUnit = body.tech_fv;
    let method = body.tech_method;

    let param = {};

    if (isFinite(x) && isFinite(y)) {
      let velocityA = parseFloat(x);
      let velocityB = parseFloat(y);

      // Convert initial velocity to m/s
      if (ivUnit === 'ft/s') velocityA /= 3.281;
      else if (ivUnit === 'km/h') velocityA /= 3.6;
      else if (ivUnit === 'km/s') velocityA *= 1000;
      else if (ivUnit === 'mi/s') velocityA *= 1609.35;
      else if (ivUnit === 'mph') velocityA /= 2.237;

      // Convert final velocity to m/s
      if (fvUnit === 'ft/s') velocityB /= 3.281;
      else if (fvUnit === 'km/h') velocityB /= 3.6;
      else if (fvUnit === 'km/s') velocityB *= 1000;
      else if (fvUnit === 'mi/s') velocityB *= 1609.35;
      else if (fvUnit === 'mph') velocityB /= 2.237;

      let iv, fv, ave;

      if (method === '1') {
        iv = `${x} ${ivUnit}`;
        fv = `${y} ${fvUnit}`;
        ave = `${((velocityA + velocityB) / 2).toFixed(5)} m/s`;
      } else if (method === '2') {
        ave = `${x} ${ivUnit}`;
        fv = `${y} ${fvUnit}`;
        iv = `${((velocityA * 2) - velocityB).toFixed(5)} m/s`;
      } else if (method === '3') {
        ave = `${x} ${ivUnit}`;
        iv = `${y} ${fvUnit}`;
        fv = `${((velocityA * 2) - velocityB).toFixed(5)} m/s`;
      } else if (method === '4') {
        iv = `${x} ${ivUnit}`;
        fv = `${y} ${fvUnit}`;
        ave = `${((2 * velocityA * velocityB) / (velocityA + velocityB)).toFixed(5)} m/s`;
      }

      param.tech_iv = iv;
      param.tech_fv = fv;
      param.tech_ave = ave;
      return param;
    } else {
      param.error = 'Please fill all fields.';
      return param;
    }
  }

     /** getCalculationAmpHourCalculation
   * POST: /api/calculators-lol/amp-hour-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationAmpHourCalculation(body) {
    let find = body.tech_find;
    let vol = parseFloat(body.tech_vol);
    let bc = parseFloat(body.tech_bc);
    let bc_unit = body.tech_bc_unit;
    let wt_hour = parseFloat(body.tech_wt_hour);
    let wt_hour_unit = body.tech_wt_hour_unit;
    let c_rate = parseFloat(body.tech_c_rate);
    let type = body.tech_type;
    let load_size = parseFloat(body.tech_load_size);
    let load_duration = parseFloat(body.tech_load_duration);
    let tempchk = body.tech_temp_chk;
    let agechk = body.tech_age_chk;
    let batteries = body.tech_batteries;

    let param = {};
    let ans, dc;

    // Normalize units
    if (bc_unit === 'Ah') bc_unit = 1;
    else if (bc_unit === 'mAh') bc_unit = 0.001;

    if (wt_hour_unit === 'kJ') wt_hour_unit = 0.2778;
    else if (wt_hour_unit === 'MJ') wt_hour_unit = 277.8;
    else if (wt_hour_unit === 'Wh') wt_hour_unit = 1;
    else if (wt_hour_unit === 'kWh') wt_hour_unit = 1000;

    if (type === "first") {
      if (find === "1") {
        if (isFinite(vol) && isFinite(wt_hour) && isFinite(c_rate)) {
          let wt_val = wt_hour * wt_hour_unit;
          ans = wt_val / vol;
          let bc_val = ans;
          dc = c_rate * bc_val;
        } else {
          param.error = 'Please! Check Input';
          return param;
        }
      } else if (find === "2") {
        if (isFinite(bc) && isFinite(wt_hour) && isFinite(c_rate)) {
          let wt_val = wt_hour * wt_hour_unit;
          let bc_val = bc * bc_unit;
          ans = wt_val / bc_val;
          dc = c_rate * bc_val;
        } else {
          param.error = 'Please! Check Input';
          return param;
        }
      } else if (find === "3") {
        if (isFinite(bc) && isFinite(vol) && isFinite(c_rate)) {
          let bc_val = bc * bc_unit;
          ans = bc_val * vol;
          dc = c_rate * bc_val;
        } else {
          param.error = 'Please! Check Input';
          return param;
        }
      }
      param.tech_find = find;
      param.tech_dc = dc;
      param.tech_c_rate = c_rate;

    } else if (type === "second") {
      if (isFinite(load_size) && isFinite(load_duration)) {
        let E3 = load_size;
        let E4 = load_duration;
        let E9 = agechk === "checked" ? 0.05 : 0;
        let E14 = tempchk === "checked" ? 0.1 : 0;

        let typeValue = 1;
        if (batteries === "gel") typeValue = 1.15;
        else if (batteries === "agm") typeValue = 1.1;
        else if (batteries === "flooded") typeValue = 1.4;

        let E25 = E3 * 20;
        let E26 = E4 / 20;
        let E27 = E9 + E14 + typeValue;
        let E28 = Math.pow(E25, E27);
        let E29 = E28 * E26;
        let E30 = Math.log(E29);
        let E31 = E30 / E27;
        ans = Math.ceil(Math.exp(E31)) * 2;
      } else {
        param.error = 'Please! Check Input';
        return param;
      }
    }

    param.tech_type = type;
    param.tech_ans = ans;
    return param;
    }

     /** getCalculationParallelResistorCalculation
   * POST: /api/calculators-lol/parallel-resistor-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async  getCalculationParallelResistorCalculation(body) {
    let mode = body.tech_mode;
    let res_val = body.tech_res_val; // array of values
    let unit = body.tech_unit;       // array of corresponding unit multipliers
    let missing = body.tech_missing;
    let mis_unit = body.tech_mis_unit;

    let array = [];

    // Convert mis_unit
    // if (mis_unit === "nm") {
    //   mis_unit = 0.001;
    // } else if (mis_unit === "μm") {
    //   mis_unit = 1;
    // } else if (mis_unit === "mm") {
    //   mis_unit = 1000;
    // } else if (mis_unit === "cm") {
    //   mis_unit = 1000000;
    // }

    //  mΩ   Ω  kΩ  MΩ
    // Convert mis_unit
    if (mis_unit == "mΩ") {
      mis_unit = 0.001;
    } else if (mis_unit == "Ω") {
      mis_unit = 1;
    } else if (mis_unit == "kΩ") {
      mis_unit = 1000;
    } else if (mis_unit == "MΩ") {
      mis_unit = 1000000;
    } 




    // Validate and process resistors
    for (let y = 0; y < res_val.length; y++) {
      let val = parseFloat(res_val[y]);
      let scale = parseFloat(unit[y]);

      if (!isFinite(val) || !isFinite(scale)) {
        return { error: 'Please fill all fields.' };
      }

      if (val === 0) {
        return { error: 'Resistor value greater than zero.' };
      }

      array.push(1 / (val * scale));
    }

    let lcm = array.reduce((acc, val) => acc + val, 0);
    let main_ans;

    if (mode == "1") {
      main_ans = 1 / lcm;
    } else if (mode == "2") {
      let missingValue = parseFloat(missing) * mis_unit;
      
      if (!isFinite(missingValue)) {
        return { error: 'Please fill all fields.' };
      }

      if (missingValue < 0) {
        return { error: 'Desired Total Resistance cannot be negative..' };
      }

      main_ans = 1 / (1 / missingValue - lcm);
    }

    let answer, displayUnit;

    if (main_ans > 1000) {
      answer = main_ans / 1000;
      displayUnit = "kΩ";
    } else {
      answer = main_ans;
      displayUnit = "Ω";
    }

    return {
      tech_mode: mode,
      tech_answer: answer,
      tech_unit: displayUnit,
    };
  }

      /** getCalculationAngleofRefractionCalculation
   * POST: /api/calculators-lol/angle-of-refraction-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationAngleofRefractionCalculation(body) {
    let calculation = body.tech_calculation;
    let medium1 = body.tech_medium1;
    let n1 = parseFloat(body.tech_n1);
    let medium2 = body.tech_medium2;
    let n2 = parseFloat(body.tech_n2);
    let angle_first = parseFloat(body.tech_angle_first);
    let angle_f_unit = body.tech_angle_f_unit;
    let angle_second = parseFloat(body.tech_angle_second);
    let angle_s_unit = body.tech_angle_s_unit;

    function convertAngle(unit, value) {
      switch (unit) {
        case "deg":
          return value * 0.0174533;
        case "rad":
          return value * 1;
        case "gon":
          return value * 0.01570796;
        case "tr":
          return value * 6.28319;
        case "arcmin":
          return value * 0.000290888;
        case "arcsec":
          return value * 0.00000484814;
        case "mrad":
          return value * 0.001;
        case "μrad":
          return value * 0.000001;
        case "* π rad":
          return value * 3.14159;
        default:
          return NaN;
      }
    }

    angle_first = convertAngle(angle_f_unit, angle_first);
    angle_second = convertAngle(angle_s_unit, angle_second);

    let jawab;
    if (calculation === "from1") {
      if (
        medium2 &&
        !isNaN(n2) &&
        !isNaN(angle_first) &&
        angle_f_unit &&
        !isNaN(angle_second) &&
        angle_s_unit
      ) {
        jawab = (n2 * Math.sin(angle_second)) / Math.sin(angle_first);
      } else {
        return { error: "Please! Check Your Input" };
      }
    } else if (calculation === "from2") {
      if (
        medium1 &&
        !isNaN(n1) &&
        !isNaN(angle_first) &&
        angle_f_unit &&
        !isNaN(angle_second) &&
        angle_s_unit
      ) {
        jawab = (n1 * Math.sin(angle_first)) / Math.sin(angle_second);
      } else {
        return { error: "Please! Check Your Input" };
      }
    } else if (calculation === "from3") {
      if (
        medium1 &&
        !isNaN(n1) &&
        medium2 &&
        !isNaN(n2) &&
        !isNaN(angle_second) &&
        angle_s_unit
      ) {
        jawab = Math.asin((n2 * Math.sin(angle_second)) / n1);
      } else {
        return { error: "Please! Check Your Input" };
      }
    } else if (calculation === "from4") {
      if (
        medium1 &&
        !isNaN(n1) &&
        medium2 &&
        !isNaN(n2) &&
        !isNaN(angle_first) &&
        angle_f_unit
      ) {
        jawab = Math.asin((n1 * Math.sin(angle_first)) / n2);
      } else {
        return { error: "Please! Check Your Input" };
      }
    }

    return {
      tech_angle_first:angle_first,
      tech_angle_second:angle_second,
      tech_calculation:calculation,
      tech_jawab:jawab,
    };
  }


      /** getCalculationJouleCalculation
   * POST: /api/calculators-lol/joule-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async  getCalculationJouleCalculation(body) {
    let mass = parseFloat(body.tech_mass);
    let mass_unit = parseFloat(body.tech_mass_unit);
    let velocity = parseFloat(body.tech_velocity);
    let velocity_unit = parseFloat(body.tech_velocity_unit);
    let joule_unit_label = body.tech_joule_unit;

    let unit

      function convertJouleUnit(energy, joule_unit)
      {
        if (joule_unit == "Joule (J)") {
          unit = energy / 1;
        } else if (joule_unit == "BTU (mean)") {
          unit = energy / 1055.87;
        } else if (joule_unit == "BTU (thermochemical)") {
          unit = energy / 1054.35;
        } else if (joule_unit == "Calorie (SI) (cal)") {
          unit = energy / 4.1868;
        } else if (joule_unit == "Electron volt (eV)") {
          unit = energy / 0.000000000000000000160;
        } else if (joule_unit == "Erg (erg)") {
          unit = energy / 0.0000001;
        } else if (joule_unit == "Foot-pound force") {
          unit = energy / 1.355818;
        } else if (joule_unit == "Foot-poundal") {
          unit = energy / 0.0421;
        } else if (joule_unit == "Horsepower-hour") {
          unit = energy / 2684077.3;
        } else if (joule_unit == "Kilocalorie (SI)(kcal)") {
          unit = energy / 4186.8;
        } else if (joule_unit == "Kilowatt-hour (kW hr)") {
          unit = energy / 3600000;
        } else if (joule_unit == "Ton of TNT") {
          unit = energy / 4200000000;
        } else if (joule_unit == "Volt-coulomb (V Cb)") {
          unit = energy / 1;
        } else if (joule_unit == "Watt-hour (W hr)") {
          unit = energy / 3600;
        } else if (joule_unit == "Watt-second (W sec)") {
          unit = energy / 1;
        }
        return unit;
      }



    if (!isNaN(mass) && !isNaN(velocity)) {
      let massSI = mass * mass_unit;
      let velocitySI = velocity * velocity_unit;
      let velocitySquared = velocitySI * velocitySI;
      let energy = massSI * velocitySquared;
      let convertedEnergy = convertJouleUnit(energy, joule_unit_label);

      if (convertedEnergy === null) {
        return { error: "Unsupported unit type." };
      }

      let answer = 0.5 * convertedEnergy;

      return {
        tech_answer:answer,
      };
    } else {
      return { error: "Please! Check Your Input" };
    }
  }

      /** getCalculationEfficiencyCalculation
   * POST: /api/calculators-lol/efficiency-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async  getCalculationEfficiencyCalculation(body) {
    let solve = body.tech_solve;
    let en_ou = parseFloat(body.tech_en_ou);
    let en_ou_unit = body.tech_en_ou_unit;
    let en_in = parseFloat(body.tech_en_in);
    let en_in_unit = body.tech_en_in_unit;
    let en_ef = parseFloat(body.tech_en_ef);

    function en_convert(value, unit) {
      switch (unit) {
        case "J": return value;
        case "kJ": return value * 1000;
        case "MJ": return value * 1000000;
        case "Wh": return value * 3600;
        case "kWh": return value * 3600000;
        case "ft-lbs": return value * 1.3558;
        case "kcal": return value * 4184;
        default: return value / 6.242e+18; // fallback for unknown unit (e.g., eV)
      }
    }

    en_ou = en_convert(en_ou, en_ou_unit);
    en_in = en_convert(en_in, en_in_unit);

    let answer;

    if (solve === "1") {
      if (!isNaN(en_ou) && !isNaN(en_in)) {
        answer = (en_ou / en_in) * 100;
      } else {
        return { error: "Please! Check Your Input" };
      }
    } else if (solve === "2") {
      if (!isNaN(en_ou) && !isNaN(en_ef)) {
        answer = (en_ou * 100) / en_ef;
      } else {
        return { error: "Please! Check Your Input" };
      }
    } else {
      if (!isNaN(en_in) && !isNaN(en_ef)) {
        answer = (en_ef / 100) * en_in;
      } else {
        return { error: "Please! Check Your Input" };
      }
    }

    return {
      tech_answer:answer,
    };
  }

     /** getCalculationVoltsToJoulesCalculation
   * POST: /api/calculators-lol/volts-to-joules-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationVoltsToJoulesCalculation(body) {
      let volts = parseFloat(body.tech_volts);
      let coulombs = parseFloat(body.tech_coulombs);
      let joules = parseFloat(body.tech_joules);
      let Solve_unit = body.tech_Solve_unit;

      function solveValues(Solve_unit, volts, coulombs, joules) {
        if (Solve_unit === "Joules") {
          return volts * coulombs;
        } else if (Solve_unit === "Volts") {
          return joules / coulombs;
        } else if (Solve_unit === "Coulombs") {
          return joules / volts;
        }
        return null;
      }

      if (!isNaN(volts) && !isNaN(coulombs) && !isNaN(joules)) {
        let answer = solveValues(Solve_unit, volts, coulombs, joules);
        return { 
          tech_answer:answer,
          };
      } else {
        return { error: "Please! Check Your Input" };
      }
    }

   /** getCalculationBuoyancyCalculation
   * POST: /api/calculators-lol/buoyancy-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async  getCalculationBuoyancyCalculation(body) {
    let density = parseFloat(body.tech_density);
    let volume = parseFloat(body.tech_volume);
    let gravity = parseFloat(body.tech_gravity);

    if (!isNaN(density) && !isNaN(volume) && !isNaN(gravity)) {
      let answer = density * volume * gravity;
      return {
        tech_answer:answer,
      };
    } else {
      return {
        error: "Please! Check Your Input"
      };
    }
  }

   /** getCalculationFPECalculation
   * POST: /api/calculators-lol/fpe-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationFPECalculation(body) {
      let velocity = parseFloat(body.tech_velocity);
      let weight = parseFloat(body.tech_weight);

      if (!isNaN(velocity) && !isNaN(weight)) {
        let answer = (velocity * velocity * weight) / 450240;
        return {
          tech_answer:answer,
        };
      } else {
        return {
          error: "Please! Check Your Input"
        };
      }
    }

   /** getCalculationRelativeHumidityCalculation
   * POST: /api/calculators-lol/relative-humidity-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationRelativeHumidityCalculation(body) {
      let temperature = parseFloat(body.tech_temperature);
      let temperature_unit = body.tech_temperature_unit;
      let point = parseFloat(body.tech_point);
      let point_unit = body.tech_point_unit;


        function framing_units(value, unit)
        {
          if (unit === "°F") {
            value = (value - 32) * 5 / 9;
          } else if (unit === "K") {
            value = value - 273.15;
          } else {
            value = value;
          }
          return value;
        }



      if (temperature_unit === "°C" && temperature >= 61) {
        return { error: 'temperature should be 60 °C equal or lower' };
      } else if (temperature_unit === "°F" && temperature >= 141) {
        return { error: 'Temperature should be lower 140 °F equal or lower' };
      } else if (temperature_unit === "K" && temperature == 0) {
        return { error: 'Temperature should be 273.15 k equal or upper' };
      }

      if (!isNaN(temperature) && !isNaN(point)) {
        let tempC = framing_units(temperature, temperature_unit);
        let pointC = framing_units(point, point_unit);
        let Pws = 6.112 * Math.exp((17.67 * tempC) / (tempC + 243.5));
        let Pw = 6.112 * Math.exp((17.67 * pointC) / (pointC + 243.5));
        let answer = (Pw / Pws) * 100;

        return {
          tech_answer:answer,
        };
      } else {
        return { error: 'Please! Check Your Input' };
      }
    }


   /** getCalculationFrictionLossCalculation
   * POST: /api/calculators-lol/friction-loss-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationFrictionLossCalculation(body) {
      let pipe_diameter = parseFloat(body.tech_pipe_diameter);
      let pipe_diameter_unit = body.tech_pipe_diameter_unit;
      let pipe_length = parseFloat(body.tech_pipe_length);
      let pipe_length_unit = body.tech_pipe_length_unit;
      let volumetric = parseFloat(body.tech_volumetric);
      let volumetric_unit = body.tech_volumetric_unit;
      let material = parseFloat(body.tech_material);

    let pipe_ans,volumetric_ans;

        function pipeConvert(a, b)
        {
          if (b === "mm") {
            pipe_ans = a / 1000;
          } else if (b === "cm") {
            pipe_ans = a / 100;
          } else if (b === "m") {
            pipe_ans = a * 1;
          } else if (b === "in") {
            pipe_ans = a / 39.37;
          } else {
            pipe_ans = a / 3.281;
          }
          return pipe_ans;
        }

          function volumetricConvert(a, b)
        {
          if (b === "1") {
            volumetric_ans = a * 0.0037854;
          } else if (b === "2") {
            volumetric_ans = a * 0.00006309;
          } else if (b === "3") {
            volumetric_ans = a * 0.0000010515;
          } else if (b === "4") {
            volumetric_ans = a * 0.004546;
          } else if (b === "5") {
            volumetric_ans = a * 0.00007577;
          } else if (b === "6") {
            volumetric_ans = a * 0.0000012628;
          } else if (b === "7") {
            volumetric_ans = a * 0.028317;
          } else if (b === "8") {
            volumetric_ans = a * 0.00047195;
          } else if (b === "9") {
            volumetric_ans = a * 0.000007866;
          } else if (b === "10") {
            volumetric_ans = a * 1;
          } else if (b === "11") {
            volumetric_ans = a * 0.016667;
          } else if (b === "12") {
            volumetric_ans = a * 0.0002778;
          } else if (b === "13") {
            volumetric_ans = a * 0.001;
          } else if (b === "14") {
            volumetric_ans = a * 0.000016667;
          } else if (b === "15") {
            volumetric_ans = a * 0.0000002778;
          } else if (b === "16") {
            volumetric_ans = a * 0.000000016667;
          } else {
            volumetric_ans = a * 0.0000000002778;
          }
          return volumetric_ans;
        }

      if (isNaN(pipe_diameter) || isNaN(pipe_length) || isNaN(volumetric)) {
        return { error: "Please! Check Your Input" };
      }

      pipe_diameter = pipeConvert(pipe_diameter, pipe_diameter_unit);
      pipe_length = pipeConvert(pipe_length, pipe_length_unit);

      const unitNames = [
        "US gal/s", "US gal/min", "US gal/hr", "UK gal/s", "UK gal/min",
        "UK gal/hr", "ft³/s", "ft³/min", "ft³/hr", "m³/s", "m³/min",
        "m³/hr", "L/s", "L/min", "L/hr", "ml/min", "ml/hr"
      ];

      let volumetricIndex = unitNames.indexOf(volumetric_unit);
      volumetric = volumetricConvert(volumetric, volumetricIndex);
      console.log(volumetric,material);
      let up_div = Math.pow(volumetric / material, 1.852);
      let head_loss = (10.67 * pipe_length * up_div) / Math.pow(pipe_diameter, 4.87);
      let pressure_loss = (head_loss * 9810) / 100000;

      return {
        tech_head_loss:head_loss,
        tech_pressure_loss:pressure_loss,
        tech_material:material,
      };
    }


     /** getCalculationEnergyCostCalculation
   * POST: /api/calculators-lol/energy-cost-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async  getCalculationEnergyCostCalculation(body) {
    let hours_per_day = parseFloat(body.tech_hours_per_day);
    let power = parseFloat(body.tech_power);
    let power_units = body.tech_power_units;
    let cost = parseFloat(body.tech_cost);
    let cost_units = body.tech_cost_units;
    let currancy = body.tech_currancy;


    	if (power_units) {
			if (power_units == 'watts (W)') {
				power = power;
			} else if (power_units == 'kilowatts (kW)') {
				power = power * 1000;
			}
		}



    if (cost_units && currancy) {
      cost_units = cost_units.replace(currancy + '/', '');
      	if (cost_units) {
			if (cost_units == "/rupee") {
				cost = cost * 100;
			} else if (cost_units == "/peso") {
				cost = cost * 100;
			} else if (cost_units == "/pence") {
			cost = cost;
			} else if (cost_units == "/cent") {
				cost = cost;
			}
		}
     
      // if 'pence' or 'cent', cost stays the same
    }

    if (isNaN(hours_per_day) || isNaN(power) || isNaN(cost)) {
      return { error: 'Please! Check Your Input' };
    }

    if (power === 0 || hours_per_day === 0) {
      return { error: 'Value cannot be zero! Check Input' };
    }

    let energy_consumed_per_day = (power * hours_per_day) / 1000;
    let energy_cost_per_day = (energy_consumed_per_day * cost) / 100;
    let energy_cost_per_month = energy_cost_per_day * 30;
    let energy_cost_per_year = energy_cost_per_day * 365;

    return {
      tech_energy_cost_per_day:energy_cost_per_day,
      tech_energy_cost_per_month:energy_cost_per_month,
      tech_energy_cost_per_year:energy_cost_per_year,
    };
  }

    /** getCalculationNewtonLawofCoolingCalculation
   * POST: /api/calculators-lol/newtons-law-of-cooling-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationNewtonLawofCoolingCalculation(body) {
      let ambient = parseFloat(body.tech_ambient);
      let ambient_units = body.tech_ambient_units;
      let initial_temperature = parseFloat(body.tech_initial_temperature);
      let initial_temp_units = body.tech_initial_temp_units;
      let area = parseFloat(body.tech_area);
      let area_units = body.tech_area_units;
      let heat_capacity = parseFloat(body.tech_heat_capacity);
      let heat_capacity_units = body.tech_heat_capacity_units;
      let heat_transfer_co = parseFloat(body.tech_heat_transfer_co);
      let heat_transfer_co_units = body.tech_heat_transfer_co_units;
      let temp_after = parseFloat(body.tech_temp_after);
      let temp_after_units = body.tech_temp_after_units;

      if (ambient_units) {
          if (ambient_units == '°C') {
            ambient = ambient;
          } else if (ambient_units == '°F') {
            ambient = (ambient - 32) * 5 / 9;
          } else if (ambient_units == 'K') {
            ambient =  ambient - 273.15;
          }
        }
        if (initial_temp_units) {
          if (initial_temp_units == '°C') {
            initial_temperature = initial_temperature;
          } else if (initial_temp_units == '°F') {
            initial_temperature = (initial_temperature - 32) * 5 / 9;
          } else if (initial_temp_units == 'K') {
            initial_temperature =  initial_temperature - 273.15;
          }
        }
        if (heat_capacity_units) {
          if (heat_capacity_units == 'J/K') {
            heat_capacity = heat_capacity;
          } else if (heat_capacity_units == 'J/°C') {
            heat_capacity = heat_capacity;
          } else if (heat_capacity_units == 'BTU/°F') {
            heat_capacity =  heat_capacity / 0.0005266;
          }
        }
        if (temp_after_units) {
          if (temp_after_units == 'sec') {
            temp_after = temp_after;
          } else if (temp_after_units == 'min') {
            temp_after = temp_after * 60;
          } else if (temp_after_units == 'hrs') {
            temp_after =  temp_after * 3600;
          }
        }
        if (heat_transfer_co_units) {
          if (heat_transfer_co_units == 'W/(m²·K)') {
            heat_transfer_co = heat_transfer_co;
          } else if (heat_transfer_co_units == 'BTU/(h·ft²·°F)') {
            heat_transfer_co = heat_transfer_co * 0.1761;
          }
        }
        if (area_units) {
          if (area_units == 'mm²') {
            area = area / 1000000;
          } else if (area_units == 'cm²') {
            area = area / 10000;
          } else if (area_units == 'm²') {
            area = area;
          } else if (area_units == 'km²') {
            area = area * 1000000;
          } else if (area_units == 'in²') {
            area = area * 0.00064516;
          } else if (area_units == 'ft²') {
            area = area * 0.092903;
          } else if (area_units == 'yd²') {
            area = area * 0.836127;
          }
        }


      if (
        isFinite(ambient) &&
        isFinite(initial_temperature) &&
        isFinite(area) &&
        isFinite(heat_capacity) &&
        isFinite(heat_transfer_co) &&
        isFinite(temp_after)
      ) {
        let k = (heat_transfer_co * area) / heat_capacity;
        let temperature = ambient + (initial_temperature - ambient) * Math.exp(-k * temp_after);

        return {
          tech_k:k,
          tech_temperature:temperature,
        };
      } else {
        return {
          error: 'Please! Check Your Input'
        };
      }
    }


     /** getCalculationWattHourCalculation
   * POST: /api/calculators-lol/watt-hour-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationWattHourCalculation(body) {
      let volt = parseFloat(body.tech_volt);
      let volt_unit = body.tech_volt_unit;
      let charge = parseFloat(body.tech_charge);
      let charge_unit = body.tech_charge_unit;
      let power = parseFloat(body.tech_power);
      let power_unit = body.tech_power_unit;
      let hour = parseFloat(body.tech_hour);
      let hour_unit = body.tech_hour_unit;

      let convert
      function convertVolt(a, b)
        {
          if (b == "nv") {
            convert =  a * 0.000000001;
          } else if (b == "μV") {
            convert = a *  0.000001;
          } else if (b == "mV") {
            convert = a * 0.001;
          } else if (b == "kV") {
            convert = a * 0.001;
          } else if (b == "MV") {
            convert = a * 1000000;
          } else if (b == "V") {
            convert = a * 1;
          }
          return convert;
        }
        function convertWatt(a, b)
        {
          if (b == "mW") {
            convert =  a * 0.001;
          } else if (b == "W") {
            convert = a * 1;
          } else if (b == "kW") {
            convert = a * 1000;
          } else if (b == "MW") {
            convert = a * 1000000;
          } else if (b == "BTU/h") {
            convert = a * 0.293071;
          } else if (b == "hp(I)") {
            convert = a * 745.7;
          } else if (b == "hp(E)") {
            convert = a * 746;
          }
          return convert;
        }
        function convertHourToHrs(a, b)
        {
          // ["ms", "sec", "min","hrs","dys","wks","mns","yrs"];
          if (b == "ms") {
            convert =  a / 3600000;
          } else if (b == "sec") {
            convert = a / 3600;
          } else if (b == "min") {
            convert = a / 60;
          } else if (b == "hrs") {
            convert = a * 1;
          } else if (b == "dys") {
            convert = a * 24;
          } else if (b == "wks") {
            convert = a * 604800;
          } else if (b == "m") {
            convert = a * 2628000;
          } else if (b == "yrs") {
            convert = a * 31536000;
          }
          return convert;
        }
        function convertChargeToAh(a, b)
        {
          if (b == 'C') {
            convert = a / 3600;
          } else if (b == 'Ah') {
            convert = a * 1;
          } else if (b == 'mAh') {
            convert = a / 3600000;
          }

          return convert;
        }



      let response = {};

      if (!volt && !charge && !power && !hour) {
        response.error = 'Please! Check Your Input';
        return response;
      }

      if (!isNaN(volt) && !isNaN(charge)) {
        volt = convertVolt(volt, volt_unit);
        charge = convertChargeToAh(charge, charge_unit);
        let energy = volt * charge;
        let energy_k = energy / 1000;
        response.tech_type = "energy";
        response.tech_energy = energy;
        response.tech_energy_k = energy_k;
      }

      if (!isNaN(power) && !isNaN(hour)) {
        power = convertWatt(power, power_unit);
        hour = convertHourToHrs(hour, hour_unit);
        let watt_h = parseFloat((power * hour).toFixed(5));
        let watt_hk = parseFloat(((power * hour) / 1000).toFixed(5));
        response.tech_type2 = "watt";
        response.tech_watt_h = watt_h;
        response.tech_watt_hk = watt_hk;
      }

      return response;
    }

   /** getCalculationSpeedofSoundCalculation
   * POST: /api/calculators-lol/speed-of-sound-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationSpeedofSoundCalculation(body) {
      let temperature_air_units = body.tech_temperature_air_units;
      let temperature_air = parseFloat(body.tech_temperature_air);
      let select_unit = body.tech_select_unit; // Currently unused
      let f_values = body.tech_f_values;       // Currently unused
      let c_values = body.tech_c_values;       // Currently unused

      if (temperature_air_units) {
          if (temperature_air_units == '°C') {
            temperature_air = temperature_air * 1;
          } else if (temperature_air_units == '°F') {
            temperature_air = (temperature_air - 32) * 5 / 9;
          } else if (temperature_air_units == 'K') {
            temperature_air =  temperature_air - 273.15;
          }
        }


      let response = {};

      if (isNaN(temperature_air)) {
        response.error = 'Please! Check Your Input';
        return response;
      }

      let gamma = 1.4;
      let specificGasConstant = 287;
      let temperatureKelvin = temperature_air + 273.15;

      let speedOfSound = Math.sqrt(gamma * specificGasConstant * temperatureKelvin);

      response.tech_speedOfSound = speedOfSound.toFixed(2);
      return response;
    }

    /** getCalculationSpecificGravityCalculation
   * POST: /api/calculators-lol/specific-gravity-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async  getCalculationSpecificGravityCalculation(body) {
    let t_fluid = body.tech_t_fluid;
    let density = parseFloat(body.tech_density);
    let density_unit = body.tech_density_unit;

    let response = {};

        function central_unit(density, density_unit)
        {
          if (density_unit == "kg/m³") {
            density = density;
          } else if (density_unit == "lb/ft³") {
            density = density * 16.0185;
          } else if (density_unit == "lb/yd³") {
            density = density * 0.593276;
          } else if (density_unit == "g/cm³") {
            density = density * 1000;
          } else if (density_unit == "kg/cm³") {
            density = density / 1000000;
          } else if (density_unit == "mg/cm³") {
            density = density * 0.001;
          } else if (density_unit == "g/m³") {
            density = density * 1000;
          } else if (density_unit == "g/dm³") {
            density = density * 100;
          }
          return density;
        }


    if (isNaN(density) || !t_fluid || !density_unit) {
      response.error = "Please! Check Your Input";
      return response;
    }

    if (t_fluid === "ls") {
      let dens = central_unit(density, density_unit);
      if (isNaN(dens)) {
        response.error = "Please! Check Your Input";
        return response;
      }
      let gravity = parseFloat((dens / 1000).toFixed(5));
      response.tech_gravity = gravity;
    } else {
      let gs_gravity = parseFloat((density / 28.96469).toFixed(5));
      response.tech_gs_gravity = gs_gravity;
    }

    return response;
  }


      /** getCalculationScientificNotationCalculator
   * POST: /api/calculators-lol/scientific-notation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async getCalculationScientificNotationCalculator(body) {
        let type = body.tech_type;
        let nbr1 = body.tech_nbr1;
        let pwr1 = body.tech_pwr1;
        let nbr2 = body.tech_nbr2;
        let pwr2 = body.tech_pwr2;
        let opr = body.tech_opr;
        let nbr = body.tech_nbr;
        let pwr = body.tech_pwr;
        let decimal = body.tech_decimal;
        let e = body.tech_e;

        let result = {};

        if (type === 'calculator') {
            if (!isNaN(nbr1) && !isNaN(pwr1) && !isNaN(nbr2) && !isNaN(pwr2)) {
                let num1 = Number(`${nbr1}e${pwr1}`);
                let num2 = Number(`${nbr2}e${pwr2}`);
                let sol;

                if (opr === '+') sol = num1 + num2;
                else if (opr === '-') sol = num1 - num2;
                else if (opr === '*') sol = num1 * num2;
                else if (opr === '/') sol = num1 / num2;

                let e_ans = sol.toExponential(3);
                let [left, right] = sol.toExponential(3).toUpperCase().split('E');
                right = Math.abs(Number(right));

                let ee_ans = `${left[0]}${left[2]}${left[3]}${left[1]}${left[4]}`;
                let ee_p = right - 2;

                result = {
                    tech_ans: sol,
                    tech_left:left,
                    tech_right:right,
                    tech_e_ans:e_ans,
                    tech_ee_ans:ee_ans,
                    tech_ee_p:ee_p,
                };
            } else {
                result.error = 'Please Check Your Input.';
            }
        } else {
            if (!isNaN(nbr) && !isNaN(pwr)) {
                let sol = Number(`${nbr}e${pwr}`);
                let e_ans = sol.toExponential(3);
                let [left, right] = sol.toExponential(3).toUpperCase().split('E');
                right = Math.abs(Number(right));

                let ee_ans = `${left[0]}${left[2]}${left[3]}${left[1]}${left[4]}`;
                let ee_p = right - 2;

                result = {
                    tech_ans: sol,
                    tech_left:left,
                    tech_right:right,
                    tech_e_ans:e_ans,
                    tech_ee_ans:ee_ans,
                    tech_ee_p:ee_p,
                };
            } else if (decimal && typeof decimal === 'string') {
                let number = decimal.replace(/\s+/g, '')
                    .replace(/\*/g, 'x')
                    .replace(/x10\^/, 'e');

                let sol = parseFloat(number);

                if (!isNaN(sol) && sol !== 0) {
                    let e_ans = sol.toExponential(3);
                    let [left, right] = sol.toExponential(3).toUpperCase().split('E');
                    right = Math.abs(Number(right));

                    let ee_ans = `${left[0]}${left[2]}${left[3]}${left[1]}${left[4]}`;
                    let ee_p = right - 2;

                    result = {
                          tech_ans: sol,
                    tech_left:left,
                    tech_right:right,
                    tech_e_ans:e_ans,
                    tech_ee_ans:ee_ans,
                    tech_ee_p:ee_p,
                    };
                } else {
                    result.error = 'Please! Enter numbers, scientific notation or E notation.\nScientific Notation: 1.35 x 10^3 \nE Notation: 1.35e3';
                }
            } else if (!isNaN(e)) {
                let sol = Number(e);
                let e_ans = sol.toExponential(3);
                let [left, right] = sol.toExponential(3).toUpperCase().split('E');
                right = Math.abs(Number(right));

                let ee_ans = `${left[0]}${left[2]}${left[3]}${left[1]}${left[4]}`;
                let ee_p = right - 2;

                result = {
                    tech_ans: sol,
                    tech_left:left,
                    tech_right:right,
                    tech_e_ans:e_ans,
                    tech_ee_ans:ee_ans,
                    tech_ee_p:ee_p,
                };
            } else {
                result.error = 'Please Check Your Input.';
            }
        }

        return result;
    }

     /** getCalculationPrimeFactorizationCalculator
   * POST: /api/calculators-lol/prime-factorization-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationPrimeFactorizationCalculator(body) {
        let from = body.tech_from;
        let num = body.tech_num;
        let response = {};

        if (!isNaN(num)) {
            let newnum = Number(num);

            if (newnum > 1000000) {
                response.error = 'Number is too large.';
                return response;
            }

            if (from == 1) {
                let newtext = "";
                let csv = "";
                let chk = 2;
                let prime = 0;
                let original = newnum;

                while (chk * chk <= newnum) {
                    if (newnum % chk === 0) {
                        newtext += chk;
                        csv += chk;
                        newnum = newnum / chk;

                        if (newnum != 1) {
                            newtext += " × ";
                            csv += " , ";
                        }
                    } else {
                        chk++;
                    }
                }

                if (newnum != 1) {
                    newtext += newnum;
                    csv += newnum;
                }

                if (newtext == "" + num) {
                    newtext += " is a Prime number.";
                    prime = 1;
                }

                if (prime != 1) {
                    let number = num;
                    let divid = newtext.split(" × ");
                    let tree = `<tr><td class='py-2 text-center'>${number}</td><td class='py-2'>&nbsp;</td></tr>`;
                    for (let i = 0; i < divid.length; i++) {
                        let value = divid[i];
                        if (value != number) {
                            number = number / value;
                            tree += `<tr><td class='py-2'>| </td><td class='py-2'>\\ </td></tr><tr><td class='py-2'>${number}</td><td class='py-2'>${value}</td></tr>`;
                        }
                    }
                    response.tech_tree = tree;
                }

                response.tech_Factors = newtext;
                response.tech_csv = csv;
                response.tech_prime = prime;
                return response;

            } else if (from == 2) {
                let table = `<td class='py-2'><del class='text-danger'>1</del></td>`;
                let tr = 1;

                for (let i = 2; i <= num; i++) {
                    let mm = 0;
                    for (let j = 2; j <= i / 2; j++) {
                        if (i % j == 0) {
                            table += `<td class='py-2'><del class='text-danger'>${i}</del></td>`;
                            mm++;
                            break;
                        }
                    }
                    if (mm == 0) {
                        table += `<td class='py-2'>${i}</td>`;
                    }
                    if (tr % 10 == 0) {
                        table += `</tr><tr>`;
                    }
                    tr++;
                }

                response.tech_table = table;
                return response;

            } else if (from == 3 || from == 4) {
                let list = '';
                let total = 0;

                for (let i = 2; i <= num; i++) {
                    let mm = 0;
                    for (let j = 2; j <= i / 2; j++) {
                        if (i % j == 0) {
                            mm++;
                            break;
                        }
                    }
                    if (mm == 0) {
                        total++;
                        list += `${i},   `;
                    }
                }

                response.tech_list = list;
                response.tech_total = total;
                return response;

            } else if (from == 5) {
                function primeCheck(number) {
                    if (number == 1) return 0;
                    for (let i = 2; i <= number / 2; i++) {
                        if (number % i == 0) return 0;
                    }
                    return 1;
                }

                let prime_check = primeCheck(num);
                response.tech_prime_check = prime_check;
                return response;

            } else if (from == 6) {
                let next, prev;
                let i = num;
                let check_n = 0;

                while (i < 10000000 && check_n != 1) {
                    i++;
                    let mm = 0;
                    for (let j = 2; j <= i / 2; j++) {
                        if (i % j == 0) {
                            mm++;
                            break;
                        }
                    }
                    if (mm == 0) {
                        next = i;
                        check_n = 1;
                    }
                }

                i = num;
                check_n = 0;
                while (i > 2 && check_n != 1) {
                    i--;
                    let mm = 0;
                    for (let j = 2; j <= i / 2; j++) {
                        if (i % j == 0) {
                            mm++;
                            break;
                        }
                    }
                    if (mm == 0) {
                        prev = i;
                        check_n = 1;
                    }
                }

                response.tech_next = next;
                response.tech_prev = prev;
                return response;
            }
        } else {
            response.error = 'Please Check Your Input.';
            return response;
        }
    }


     /** getCalculationModuloCalculator
   * POST: /api/calculators-lol/modulo-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
async  getCalculationModuloCalculator(body) {
    let x = body.tech_x;
    let y = body.tech_y;
    let response = {};

    if (!isNaN(x) && !isNaN(y)) {
        let mod = x % y;
        response.tech_mod = mod;
        response.tech_agya = "chal thk a";
        return response;
    } else {
        response.error = 'Please Check Your Input.';
        return response;
    }
}



     /** getCalculationMidpointCalculator
   * POST: /api/calculators-lol/midpoint-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async  getCalculationMidpointCalculator(body) {
      let x1 = body.tech_x1;
      let x2 = body.tech_x2;
      let y1 = body.tech_y1;
      let y2 = body.tech_y2;

      let response = {};

      if (!isNaN(x1) && !isNaN(x2) && !isNaN(y1) && !isNaN(y2)) {
          let x = (Number(x1) + Number(x2)) / 2;
          let y = (Number(y1) + Number(y2)) / 2;
          let dis = Math.round(Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)) * 10000) / 10000;

          response.tech_x = x;
          response.tech_y = y;
          response.tech_x1 = x1;
          response.tech_x2 = x2;
          response.tech_y1 = y1;
          response.tech_y2 = y2;
          response.tech_dis = dis;
          return response;
      } else {
          response.error = 'Please Check Your Input.';
          return response;
      }
  }

     /** getCalculationSlopeCalculator
   * POST: /api/calculators-lol/slope-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationSlopeCalculator(body) {
    
      let type = body.tech_type;
    let x1 = body.tech_x1;
    let x2 = body.tech_x2;
    let y1 = body.tech_y1;
    let y2 = body.tech_y2;
    let dis = body.tech_dis;
    let m = body.tech_m;
    let angle = body.tech_angle;
    let x = body.tech_x;
    let y = body.tech_y;
    let b = body.tech_b;


      let result = {};

      x1 = parseFloat(x1);
      x2 = parseFloat(x2);
      y1 = parseFloat(y1);
      y2 = parseFloat(y2);
      dis = parseFloat(dis);
      m = m !== '' ? parseFloat(m) : '';
      angle = angle !== '' ? parseFloat(angle) : '';
      x = parseFloat(x);
      y = parseFloat(y);
      b = parseFloat(b);

      if (type === '2') {
        if (!isNaN(x1) && !isNaN(x2) && !isNaN(y1) && !isNaN(y2)) {
          x = x2 - x1;
          y = y2 - y1;
          let slope = +(y / x).toFixed(4);
          angle = +(Math.atan(slope) * (180 / Math.PI)).toFixed(4);
          let distance = +(Math.sqrt(x * x + y * y)).toFixed(4);
          b = +(y1 - (slope * x1)).toFixed(2);

          result = { 
                tech_x:x,
                tech_y:y,
                tech_b:b,
              tech_slope: slope,
                tech_angle: angle + " deg",
                tech_distance:distance, 
                };
        } else {
          result = { error: 'Please fill all fields.' };
        }
      } else if (type === '1') {
        if (!isNaN(x1) && !isNaN(y1) && !isNaN(dis)) {
          if (m === '' && angle === '') return { error: 'Please fill all fields.' };

          let slope;
          if (!isNaN(m)) {
            slope = m;
            let d = dis / Math.sqrt(1 + Math.pow(slope, 2));
            var x2r = +(x1 + d).toFixed(4);
            var y2r = +(y1 + slope * d).toFixed(4);
            var x2l = +(x1 - d).toFixed(4);
            var y2l = +(y1 - slope * d).toFixed(4);
            angle = +(Math.atan(slope) * (180 / Math.PI)).toFixed(4);
          } else {
            let a = (angle * Math.PI) / 180;
            slope = +(Math.tan(a)).toFixed(4);
            let d = dis / Math.sqrt(1 + Math.pow(slope, 2));
            var x2r = +(x1 + d).toFixed(4);
            var y2r = +(y1 + slope * d).toFixed(4);
            var x2l = +(x1 - d).toFixed(4);
            var y2l = +(y1 - slope * d).toFixed(4);
          }

          let xr = x2r - x1;
          let yr = y2r - y1;
          let xl = x2l - x1;
          let yl = y2l - y1;
          b = +(y1 - (slope * x1)).toFixed(2);

          result = {
              tech_xr:xr,
              tech_yr:yr,
              tech_xl:xl,
              tech_yl:yl,
              tech_x2r:x2r,
              tech_y2r:y2r,
              tech_x2l:x2l,
              tech_y2l:y2l,
              tech_b:b,
              tech_slope:slope,
              tech_angle: angle + " deg",
              tech_distance: dis,
              };
        } else {
          result = { error: 'Please fill all fields.' };
        }
      } else if (type === '3') {
        if (!isNaN(x1) && !isNaN(y1)) {
          if (m === '' && angle === '') return { error: 'Please fill all fields.' };
          if (x2 === '' && y2 === '') return { error: 'Please fill all fields.' };

          let slope;
          if (!isNaN(m)) {
            slope = m;
            angle = +(Math.atan(slope) * (180 / Math.PI)).toFixed(4);
          } else {
            let a = (angle * Math.PI) / 180;
            slope = +(Math.tan(a)).toFixed(4);
          }

          if (!isNaN(x2)) {
            x2 = parseFloat(x2);
            y2 = +((slope * (x2 - x1)) + y1).toFixed(4);
          } else {
            y2 = parseFloat(y2);
            x2 = +(((y2 - y1) / slope) + x1).toFixed(4);
          }

          x = x2 - x1;
          y = y2 - y1;
          let distance = +(Math.sqrt(x * x + y * y)).toFixed(4);
          b = +(y1 - (slope * x1)).toFixed(2);

          result = {
              tech_x:x,
              tech_y:y, 
              tech_x2:x2,
              tech_y2:y2,
              tech_b:b,
              tech_slope:slope,
              tech_angle: angle + " deg",
              tech_distance:distance,
          };
        } else {
          result = { error: 'Please fill all fields.' };
        }
      } else if (type === '4') {
        if (!isNaN(x1) && !isNaN(y1)) {
          if (m === '' && angle === '') return { error: 'Please fill all fields.' };

          let slope;
          if (!isNaN(m)) {
            slope = m;
            angle = +(Math.atan(slope) * (180 / Math.PI)).toFixed(4);
          } else {
            let a = (angle * Math.PI) / 180;
            slope = +(Math.tan(a)).toFixed(4);
          }

          b = +(y1 - (slope * x1)).toFixed(4);
          result = {
            tech_b:b, 
            tech_slope:slope, 
            tech_angle: angle + " deg",
            };
        } else {
          result = { error: 'Please fill all fields.' };
        }
      } else if (type === 'line') {
        if (!isNaN(x) && !isNaN(y) && !isNaN(b)) {
          x = x * -1;
          y = y * -1;
          let slope = +(x / y).toFixed(4);
          angle = +(Math.atan(slope) * (180 / Math.PI)).toFixed(4);
          b = +(b / y).toFixed(2);

          result = { 
                tech_b:b,
            tech_slope:slope, 
            tech_angle: angle + " deg",
          };
        } else {
          result = { error: 'Please fill all fields.' };
        }
      }

      return result;
    }

     /** getCalculationLongAdditionCalculator
   * POST: /api/calculators-lol/long-addition-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationLongAdditionCalculator(body) {
      let x = body.tech_x;
      let result = {};

      if (x && typeof x === 'string') {
        let array = x.split(',').map(item => item.trim());
        let number = true;
        let numbers = '';

        for (let value of array) {
          if (isNaN(value)) {
            number = false;
            break;
          }
          numbers += value + ', ';
        }

        if (number) {
          let numericArray = array.map(Number);
          let sum = numericArray.reduce((acc, val) => acc + val, 0);
          let total_nbr = numericArray.length;
          sum = sum.toFixed(2);

          result.tech_sum = sum;
          result.tech_numbers = numbers.trim();
          result.tech_total_nbr = total_nbr;
          result.tech_max = Math.max(...numericArray);
          result.tech_min = Math.min(...numericArray);
        } else {
          result.error = 'Please Enter Only Numbers.';
        }
      } else {
        result.error = 'Please Check Your Input.';
      }

      return result;
    }


     /** getCalculationStandardFormCalculator
   * POST: /api/calculators-lol/standard-form-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationStandardFormCalculator(body) {
      let x = body.tech_x;
      let result = {};

      if (!x || typeof x !== 'string') {
        result.error = 'Please Check Your Input.';
        return result;
      }

      // Clean up characters
      x = x.replace(/−/g, '-').replace(/×/g, '*');

      // Check for forbidden patterns
      const forbiddenPattern = /<|>|&|php|print_r|print|echo|script|≥|𝑥|•|,|g|y|m|=|%/i;
      if (forbiddenPattern.test(x)) {
        result.error = 'Please Check Your Input.';
        return result;
      }

      let number, real_num;

      if (!isNaN(x)) {
        number = parseFloat(x);
        real_num = 1;
      } else {
        let nbr = x.split(/x\s?10\^|x10\^|\*10\^|\* 10\^/i).map(s => s.trim()).filter(Boolean);

        if (nbr.length > 1) {
          number = parseFloat(nbr[0]) * Math.pow(10, parseFloat(nbr[1]));
          real_num = 0;
        } else {
          try {
            number = eval(x);
            real_num = 1;
          } catch (e) {
            result.error = 'Please Check Your Input.';
            return result;
          }
        }
      }

      if (typeof number === 'number' && !isNaN(number)) {
        let orderOfMagnitude = getOrderOfMagnitude(number);
        let e_ans = number.toExponential(3);
        let [left, right] = e_ans.toUpperCase().split('E');
        let ee_ans = `${left[0]}${left[2] ?? ''}${left[3] ?? ''}${left[1] ?? ''}${left[4] ?? ''}`;
        let ee_p = parseInt(right) - 2;

        result.tech_ans = `${left} ×10<sup>${right}</sup>`;
        result.tech_left = left;
        result.tech_right = right;
        result.tech_e_ans = e_ans;
        result.tech_ee_ans = ee_ans;
        result.tech_ee_p = ee_p;
        result.tech_number = number;
        result.tech_real_num = real_num;
      } else {
        result.error = 'Please Check Your Input.';
      }

      return result;

      function getOrderOfMagnitude(value) {
        if (value === 0) return null;
        let abs = Math.abs(value);
        let power = 0;
        while (abs >= 10) {
          abs /= 10;
          power++;
        }
        while (abs < 0.1) {
          abs *= 10;
          power--;
        }
        return power;
      }
    }


     /** getCalculationAverageCalculator
   * POST: /api/calculators-lol/average-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationAverageCalculator(body) {
      let x = body.tech_x;
      let more = body.tech_more;
      let seprate = body.tech_seprate;

      let result = {};
      let check = true;

      if (!x || x.trim() === '') {
        check = false;
      }

      // Determine the separator
      if (more === 'space') {
        seprate = ' ';
      } else if (more === ',') {
        seprate = ',';
      }

      if (!seprate) {
        seprate = ' ';
      }

      let numbers = x.split(seprate).map(s => s.trim()).filter(s => s !== '');

      for (let value of numbers) {
        if (isNaN(value)) {
          check = false;
          break;
        }
      }

      if (check) {
        numbers = numbers.map(Number).sort((a, b) => a - b);
        let sum = numbers.reduce((a, b) => a + b, 0);
        let count = numbers.length;
        let average = +(sum / count).toFixed(4);

        // Median
        let median;
        if (count % 2 !== 0) {
          median = numbers[Math.floor(count / 2)];
        } else {
          let mid1 = numbers[count / 2 - 1];
          let mid2 = numbers[count / 2];
          median = (mid1 + mid2) / 2;
        }

        // Mode and table
        let freqMap = {};
        let table = '';
        for (let val of numbers) {
          freqMap[val] = (freqMap[val] || 0) + 1;
        }

        let maxFreq = Math.max(...Object.values(freqMap));
        let mode = Object.keys(freqMap).filter(key => freqMap[key] === maxFreq);

        for (let key in freqMap) {
          table += `<tr><td class='py-2 border-b'>${key}</td><td class='py-2 border-b'>${freqMap[key]}</td><td class='py-2 border-b'>${key * freqMap[key]}</td></tr>`;
        }

        // Standard deviations
        let m = +(sum / count).toFixed(3);
        let d = 0;
        for (let value of numbers) {
          d += Math.pow(value - m, 2);
        }

        let s_d_p = +(Math.sqrt(d / count).toFixed(4));
        let s_d_s = +(Math.sqrt(d / (count - 1)).toFixed(4));

        result.tech_table = table;
        result.tech_mode = mode;
        result.tech_s_d_p = s_d_p;
        result.tech_s_d_s = s_d_s;
        result.tech_median = median;
        result.tech_average = average;
        result.tech_count = count;
        result.tech_d = d;
        result.tech_numbers = numbers;
      } else {
        result.error = 'Please Check Your Input.';
      }

      return result;
    }

     /** getCalculationLogAndAntilogCalculator
   * POST: /api/calculators-lol/log-antilog-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationLogAndAntilogCalculator(body) {
      let method = body.tech_method;
      let x = body.tech_x;
      let y = body.tech_y;

      let result = {};
      let check = true;

      if (isNaN(x)) {
        check = false;
      }

      if (check) {
        x = parseFloat(x);
        let base;

        if (method === 'log' || method === 'ln') {
          if (!isNaN(y)) {
            base = parseFloat(y);
          } else if (y === 'e') {
            base = 2.71828;
          } else {
            base = 2.71828;
          }

          let ans = +(Math.log(x) / Math.log(base)).toFixed(5);
          result.tech_ans = ans;
        } else if (method === 'anti') {
          if (!isNaN(y)) {
            base = parseFloat(y);
          } else if (y === 'e') {
            base = 2.71828;
          } else {
            base = 10;
          }

          let ans = +(Math.pow(base, x)).toFixed(5);
          result.tech_ans = ans;
        } else {
          result.error = 'Invalid method.';
        }
      } else {
        result.error = 'Please Check Your Input.';
      }

      return result;
    }

    /** getCalculationCentroidCalculator
   * POST: /api/calculators-lol/centroid-triangle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationCentroidCalculator(body) {
    let shap = body.tech_shap;
    let x1 = parseFloat(body.tech_x1);
    let y1 = parseFloat(body.tech_y1);
    let x2 = parseFloat(body.tech_x2);
    let y2 = parseFloat(body.tech_y2);
    let x3 = parseFloat(body.tech_x3);
    let y3 = parseFloat(body.tech_y3);
    let total = parseInt(body.tech_total);

    let result = {};

    if (
      !isNaN(x1) && !isNaN(y1) &&
      !isNaN(x2) && !isNaN(y2) &&
      !isNaN(x3) && !isNaN(y3)
    ) {
      if (shap === '3') {
        let x = +((x1 + x2 + x3) / 3).toFixed(3);
        let y = +((y1 + y2 + y3) / 3).toFixed(3);
        let ans = `${x} , ${y}`;

        result.tech_ans = ans;
        result.tech_x1 = x1;
        result.tech_x2 = x2;
        result.tech_x3 = x1 + x2 + x3;
        result.tech_y1 = y1;
        result.tech_y2 = y2;
        result.tech_y3 = y1 + y2 + y3;
        result.tech_n = 3;
      } else {
        if (!isNaN(total)) {
          let sumX = 0;
          let sumY = 0;
          let x1Expr = '';
          let x2Expr = '';
          let y1Expr = '';
          let y2Expr = '';

          for (let i = 1; i <= total; i++) {
            let xi = parseFloat(body[`tech_x${i}`]);
            let yi = parseFloat(body[`tech_y${i}`]);

            if (isNaN(xi) || isNaN(yi)) {
              result.error = 'Please! Check Your Input.';
              return result;
            }

            sumX += xi;
            sumY += yi;

            x1Expr += i !== total ? `x_${i} + ` : `x_${i}`;
            x2Expr += i !== total ? `${xi} + ` : `${xi}`;
            y1Expr += i !== total ? `y_${i} + ` : `y_${i}`;
            y2Expr += i !== total ? `${yi} + ` : `${yi}`;
          }

          let centroidX = +(sumX / total).toFixed(3);
          let centroidY = +(sumY / total).toFixed(3);
          let ans = `${centroidX} , ${centroidY}`;

          result.tech_x1 = x1Expr;
          result.tech_x2 = x2Expr;
          result.tech_x3 = sumX;
          result.tech_y1 = y1Expr;
          result.tech_y2 = y2Expr;
          result.tech_y3 = sumY;
          result.tech_n = total;
          result.tech_ans = ans;
        } else {
          result.error = 'Please! Check Your Input.';
        }
      }
    } else {
      result.error = 'Please! Check Your Input.';
    }

    return result;
  }

      /** getCalculationQuadraticFormulaCalculator
   * POST: /api/calculators-lol/quadratic-formula-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

      async getCalculationQuadraticFormulaCalculator(body) {
  let a = parseFloat(body.tech_a);
  let b = parseFloat(body.tech_b);
  let c = parseFloat(body.tech_c);
  let formula = body.tech_formula;
  let method = body.tech_method;
  let result = {};

  if (!isNaN(a) && !isNaN(b) && !isNaN(c)) {
    let A = a;
    let B, C;

    if (formula === '1') {
      B = b;
      C = c;
    } else if (formula === '2') {
      B = -2 * b * A;
      C = Math.pow(b, 2) * A + c;
    } else if (formula === '3') {
      B = (b + c) * A;
      C = b * c * A;
    }

    let firstx = +(B * -1 / (2 * A)).toFixed(3);
    let firstPart = Math.pow(firstx, 2) * A;
    let secondPart = B * firstx;

    let eq = `${firstPart}${secondPart < 0 ? " " : " + "}${secondPart}${C < 0 ? " " : " + "}${C}`;
    let yaxis = +(eval(eq)).toFixed(3);

    result.tech_vertex = `${A}(x ${firstx < 0 ? "+ " + (-firstx) : "- " + firstx} )^2 ${yaxis < 0 ? "- " + (-yaxis) : "+ " + yaxis}`;

    let x1, x2;

    if (method == 2) {
      let dis = Math.pow(B, 2) - 4 * A * C;
      result.tech_dis = dis;
      if (dis > 0) {
        x1 = +(((-B + Math.sqrt(dis)) / (2 * A)).toFixed(4));
        x2 = +(((-B - Math.sqrt(dis)) / (2 * A)).toFixed(4));
        result.tech_fact = `${A}(x ${x1 < 0 ? "+ " + (-x1) : "- " + x1} )(x ${x2 < 0 ? "+ " + (-x2) : "- " + x2} )`;
        result.tech_roots = `x₁ = ${x1} , x₂ = ${x2}`;
      } else if (dis < 0) {
        let real = +((-B) / (2 * A)).toFixed(4);
        let imag = +(Math.sqrt(-dis) / (2 * A)).toFixed(4);
        result.tech_fact = `${A}(x - (${real} + ${imag}i) )(x - (${real} - ${imag}i) )`;
        result.tech_roots = `x₁ = ${real} + ${imag}i<br> x₂ = ${real} - ${imag}i`;
      } else {
        x1 = +((-B) / (2 * A)).toFixed(4);
        result.tech_fact = `${A}(x ${x1 < 0 ? "+ " + (-x1) : "- " + x1})^2`;
        result.tech_roots = `x = ${x1}`;
      }
    } else if (method == 1) {
      let leftSide = B / A;
      let C_ = -C / A;
      let rightSide = C_ + (Math.pow(B, 2) / Math.pow(2 * A, 2));

      if (rightSide > 0) {
        x1 = +((-leftSide / 2 + Math.sqrt(rightSide)).toFixed(4));
        x2 = +((-leftSide / 2 - Math.sqrt(rightSide)).toFixed(4));
        result.tech_fact = `${A}(x ${x1 < 0 ? "+ " + (-x1) : "- " + x1} )(x ${x2 < 0 ? "+ " + (-x2) : "- " + x2} )`;
        result.tech_roots = `x₁ = ${x1} , x₂ = ${x2}`;
      } else if (rightSide < 0) {
        let real = +(-leftSide / 2).toFixed(4);
        let imag = +(Math.sqrt(-rightSide)).toFixed(4);
        result.tech_fact = `${A}(x - (${real} + ${imag}i) )(x - (${real} - ${imag}i) )`;
        result.tech_roots = `x₁ = ${real} + ${imag}i<br> x₂ = ${real} - ${imag}i`;
      } else {
        x1 = +(-leftSide / 2).toFixed(4);
        result.tech_fact = `${A}(x ${x1 < 0 ? "+ " + (-x1) : "- " + x1})^2`;
        result.tech_roots = `x = ${x1}`;
      }
      if (typeof x1 !== 'undefined') result.tech_x1 = x1;
      if (typeof x2 !== 'undefined') result.tech_x2 = x2;
    }


    result.tech_B = B;
    result.tech_C = C;
  } else {
    result.error = "Please fill all fields.";
  }

  return result;
    }


      /** getCalculationQuotientAndRemainderCalculator
   * POST: /api/calculators-lol/remainder-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async getCalculationQuotientAndRemainderCalculator(body) {
      let x = parseFloat(body.tech_x);
      let y = parseFloat(body.tech_y);
      let result = {};

      if (!isNaN(x) && !isNaN(y)) {
        let mod = x % y;
        let q = Math.floor(x / y);

        result.tech_r = mod;
        result.tech_q = q;
      } else {
        result.error = 'Please Check Your Input.';
      }

      return result;
    }

      /** getCalculationRoundingCalculator
   * POST: /api/calculators-lol/rounding-numbers-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRoundingCalculator(body) {
  let number = parseFloat(body.tech_number);
  let mode = body.tech_mode; // Currently unused but kept for consistency
  let per = parseInt(body.tech_per);
  let result = {};

  if (!isNaN(number)) {
    // Helper function for rounding with precision (simulating PHP_ROUND_HALF_UP)
    function roundTo(value, places) {
      let factor = Math.pow(10, places);
      return Math.round(value * factor) / factor;
    }

    let ans = roundTo(number, per);
    let one = roundTo(number, 0);
    let two = roundTo(number, -1);
    let three = roundTo(number, -2);
    let four = roundTo(number, -3);

    result.tech_ans = ans;
    result.tech_one = one;
    result.tech_two = two;
    result.tech_three = three;
    result.tech_four = four;
  } else {
    result.error = "Please Check Your Input.";
  }

  return result;
}


      /** getCalculationFractionToDecimalCalculator
   * POST: /api/calculators-lol/fraction-to-decimal-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async getCalculationFractionToDecimalCalculator(body) {
      let n1 = parseFloat(body.tech_n1); // whole number part (optional)
      let n2 = parseFloat(body.tech_n2); // numerator
      let d1 = parseFloat(body.tech_d1); // denominator
      let round = parseInt(body.tech_round);
      let result = {};

      if (!isNaN(n2) && !isNaN(d1)) {
        let totalN = n2;
        let totalD = d1;

        if (!isNaN(n1)) {
          if (n1 < 0 && totalN > 0) {
            totalN = -totalN;
          }
          totalN = totalD * n1 + totalN;
        }

        // GCD function
        function gcd(a, b) {
          a = Math.abs(a);
          b = Math.abs(b);
          if (a < b) [a, b] = [b, a];
          if (b === 0) return 1;
          let r = a % b;
          while (r > 0) {
            a = b;
            b = r;
            r = a % b;
          }
          return b;
        }

        // Reduce fraction
        function reduce(num, den) {
          let g = gcd(num, den);
          return [num / g, den / g];
        }

        let ans = +(totalN / totalD).toFixed(round);
        let g = gcd(totalN, totalD);
        let [upr, btm] = reduce(totalN, totalD);

        result.tech_ans = ans;
        result.tech_upr = upr;
        result.tech_totalN = totalN;
        result.tech_totalD = totalD;
        result.tech_g = g;
        result.tech_btm = btm;
      } else {
        result.error = "Please! Check Your Input.";
      }

      return result;
    }


      /** getCalculationDecimalToFractionCalculator
   * POST: /api/calculators-lol/decimal-to-fraction-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

 async getCalculationDecimalToFractionCalculator(body) {
  let dec = body.tech_dec;                // Input decimal number (e.g., "0.75" or "0.666")
  let repeat = parseInt(body.tech_repeat); // Number of repeating digits, if provided
  let result = {};

  // ✅ Input validation
  if (dec === undefined || isNaN(Number(dec))) {
    result.error = "Please! Check Your Input.";
    return result;
  }

  dec = dec.toString(); // Ensure it's a string for splitting
  if (!dec.includes(".")) {
    result.error = "Please provide a decimal number (e.g., 0.75).";
    return result;
  }

  let nbr = dec.split("."); // Split into integer and fractional parts

  if (!isNaN(repeat) && repeat > 0) {
    // 🔁 Handle repeating decimal
    let repeatDigits = nbr[1].slice(-repeat); // Get repeating part from right
    if (repeat > nbr[1].length) {
      result.error = "Please! Check Your Input.";
      return result;
    }

    let input = dec.split(repeatDigits)[0] + `bar(${repeatDigits})`; // Format input with bar notation
    let add = "1";
    let first = dec;
    for (let i = 1; i <= repeat; i++) {
      add += "0";       // Build multiplier like 10, 100, etc.
      first += repeatDigits; // Extend decimal
    }

    let second = Number(first) * Number(add);
    let third = second - Number(first);

    let totalLength = nbr[0].length + nbr[1].length;
    let thirdRounded = Number(third.toFixed(totalLength - Math.floor(second).toString().length));

    // Prepare numerator and denominator
    let numParts = thirdRounded.toString().split(".");
    let div = "1";
    if (numParts.length > 1) {
      for (let i = 1; i <= numParts[1].length; i++) div += "0";
    }

    let upr = thirdRounded * Number(div);
    let div_ = Number(div);
    let finalDiv = (Number(add) - 1) * Number(div);

    // Helper function: GCD
    function gcd(a, b) {
      a = Math.abs(a);
      b = Math.abs(b);
      while (b !== 0) {
        [a, b] = [b, a % b];
      }
      return a;
    }

    // Reduce fraction
    function reduce(num, den) {
      let g = gcd(num, den);
      return [num / g, den / g];
    }

    let g = gcd(upr, finalDiv);
    let [uper, btm] = reduce(upr, finalDiv);

    // Final result object
    result.tech_input = input;
    result.tech_last_n = repeatDigits;
    result.tech_second = second;
    result.tech_third = thirdRounded;
    result.tech_add = add;
    result.tech_upr = upr;
    result.tech_div = finalDiv;
    result.tech_div_ = div_;
    result.tech_uper = uper;
    result.tech_btm = btm;
    result.tech_g = g;
    return result;
  } else {
    // 🟡 Non-repeating decimal case
    let div = "1";
    if (nbr.length > 1) {
      for (let i = 1; i <= nbr[1].length; i++) div += "0"; // Build denominator (e.g., 100 for .75)
    }

    let upr = Number(nbr[0] + nbr[1]); // Join integer + fractional
    let finalDiv = Number(div);

    // GCD and reduce
    function gcd(a, b) {
      a = Math.abs(a);
      b = Math.abs(b);
      while (b !== 0) {
        [a, b] = [b, a % b];
      }
      return a;
    }

    function reduce(num, den) {
      let g = gcd(num, den);
      return [num / g, den / g];
    }

    let g = gcd(upr, finalDiv);
    let [uper, btm] = reduce(upr, finalDiv);

    // Final result object
    result.tech_upr = upr;
    result.tech_div = finalDiv;
    result.tech_uper = uper;
    result.tech_btm = btm;
    result.tech_g = g;
    return result;
  }
}



      /** getCalculationFractionToPercentCalculator
   * POST: /api/calculators-lol/fraction-to-percent-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async getCalculationFractionToPercentCalculator(body) {
      let n1 = parseFloat(body.tech_n1); // whole number part (optional)
      let n2 = parseFloat(body.tech_n2); // numerator
      let d1 = parseFloat(body.tech_d1); // denominator
      let round = parseInt(body.tech_round);
      let result = {};

      if (!isNaN(n2) && !isNaN(d1)) {
        let totalN = n2;
        let totalD = d1;

        if (!isNaN(n1)) {
          if (n1 < 0 && totalN > 0) {
            totalN = -totalN;
          }
          totalN = totalD * n1 + totalN;
        }

        // GCD function
        function gcd(a, b) {
          a = Math.abs(a);
          b = Math.abs(b);
          if (a < b) [a, b] = [b, a];
          if (b === 0) return 1;
          let r = a % b;
          while (r > 0) {
            a = b;
            b = r;
            r = a % b;
          }
          return b;
        }

        // Reduce fraction
        function reduce(num, den) {
          let g = gcd(num, den);
          return [num / g, den / g];
        }

        let ans = +(totalN / totalD).toFixed(round);
        let g = gcd(totalN, totalD);
        let [upr, btm] = reduce(totalN, totalD);

        result.tech_ans = ans;
        result.tech_upr = upr;
        result.tech_totalN = totalN;
        result.tech_totalD = totalD;
        result.tech_g = g;
        result.tech_btm = btm;
      } else {
        result.error = "Please! Check Your Input.";
      }

      return result;
    }


   /** getCalculationPercentToFractionCalculator
   * POST: /api/calculators-lol/percent-to-fraction-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

      async getCalculationPercentToFractionCalculator(body) {
      let percent = body.tech_percent; 
      let result = {};

      if (percent === undefined || isNaN(Number(percent))) {
        result.error = "Please! Check Your Input.";
        return result;
      }

      let decimal = Number(percent) / 100;
      let decimalStr = decimal.toString();

      let nbr = decimalStr.split(".");
      if (nbr.length < 2) {
        nbr.push("0"); // If no decimal, treat as ".0"
      }

      let div = "1";
      for (let i = 1; i <= nbr[1].length; i++) {
        div += "0";
      }

      let upr = Number(nbr[0] + nbr[1]);
      let den = Number(div);

      function gcd(a, b) {
        a = Math.abs(a);
        b = Math.abs(b);
        while (b !== 0) {
          [a, b] = [b, a % b];
        }
        return a;
      }

      function reduce(num, den) {
        let g = gcd(num, den);
        return [num / g, den / g];
      }

      let g = gcd(upr, den);
      let [uper, btm] = reduce(upr, den);

      result.tech_upr = upr;
      result.tech_div = den;
      result.tech_uper = uper;
      result.tech_btm = btm;
      result.tech_g = g;
      return result;
    }


       /** getCalculationMillionBillionLakhCalculator
   * POST: /api/calculators-lol/million-billion-lakh-crore
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationMillionBillionLakhCalculator(body) {
      let from_new = body.tech_from_new ?? false;
      let calFrom_new = body.tech_calFrom_new ?? false;
      let calto_new = body.tech_calto_new ?? false;

      let from = body.tech_from;
      let f_u = body.tech_calFrom;
      let t_u = body.tech_calto;

      if (from_new && !isNaN(from_new)) {
        from = from_new;
      }

      if (calFrom_new) {
        f_u = calFrom_new;
      }

      if (calto_new) {
        t_u = calto_new;
      }

      let result = {};

      if (!isNaN(from)) {
        let from_input = from;
        let f_u_input = f_u;
        let t_u_input = t_u;
        let to = from;
        let t1, t2, t3, t4, t5, t6, t7, t8;

        const unitMultipliers = {
          Hundred: 1,
          Thousand: 10,
          Lakh: 1000,
          Million: 10000,
          Crore: 100000,
          Billion: 10000000,
          Trillion: 10000000000,
          Arab: 10000000,
          Kharab: 1000000000,
        };

        if (f_u === t_u) {
          to = from;
        } else {
          if (unitMultipliers[f_u]) {
            from = from * unitMultipliers[f_u];
          }

          const conversions = {
            to,
            t1: from / 10 + ' Thousand',
            t2: from / 1000 + ' Lakh',
            t3: from / 10000 + ' Million',
            t4: from / 100000 + ' Crore',
            t5: from / 10000000 + ' Billion',
            t6: from / 10000000000 + ' Trillion',
            t7: from / 10000000 + ' Arab',
            t8: from / 1000000000 + ' Kharab',
          };

          to = unitMultipliers[t_u] ? from / unitMultipliers[t_u] : from;

          ({ t1, t2, t3, t4, t5, t6, t7, t8 } = conversions);
        }

        // Define dummy input arrays for table generation
        const input = [
          'Hundred', 'Thousand', 'Lakh', 'Million',
          'Crore', 'Billion', 'Trillion', 'Arab', 'Kharab'
        ];
        const numbers = [1, 10, 50, 100, 500, 1000];

        let table = '';
        for (let i = 0; i < 9; i++) {
          let rand1 = input[Math.floor(Math.random() * input.length)];
          let rand2 = input[Math.floor(Math.random() * input.length)];
          let nbr = numbers[Math.floor(Math.random() * numbers.length)];
          table += `<div class='col-span-6 md:col-span-4 lg:col-span-4'>
            <input type='submit' name='submit' class='rounded-lg hover:bg-[#99EA48] cursor-pointer' value='${nbr} ${rand1} to ${rand2}'>
          </div>`;
        }

        result.tech_to = to;
        result.tech_t1 = t1;
        result.tech_t2 = t2;
        result.tech_t3 = t3;
        result.tech_t4 = t4;
        result.tech_t5 = t5;
        result.tech_t6 = t6;
        result.tech_t7 = t7;
        result.tech_t8 = t8;
        result.tech_table = table;
        result.tech_from_input = from_input;
        result.tech_f_u_input = f_u_input;
        result.tech_t_u_input = t_u_input;

        return result;
      } else {
        return { error: 'Please Check Your Input.' };
      }
    }


      /** getCalculationPointSlopeFormCalculator
   * POST: /api/calculators-lol/point-slope-form-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationPointSlopeFormCalculator(body) {
      let point_unit = body.tech_point_unit;
      let x1 = body.tech_x1;
      let y1 = body.tech_y1;
      let m = body.tech_m;
      let sec_x1 = body.tech_sec_x1;
      let sec_y1 = body.tech_sec_y1;
      let sec_x2 = body.tech_sec_x2;
      let sec_y2 = body.tech_sec_y2;

      let result = {};

      if (point_unit === '1') {
        if (!isNaN(x1) && !isNaN(y1) && !isNaN(m)) {
          x1 = -x1;
          y1 = -y1;
          let mn = x1 * m;

          let s = `y ${y1 < 0 ? '- ' + Math.abs(y1) : '+ ' + y1} = ${m}(x ${x1 < 0 ? '- ' + Math.abs(x1) : '+ ' + x1})`;
          let s1 = `(y ${y1 < 0 ? '- ' + Math.abs(y1) : '+ ' + y1}) = ${m}x ${mn < 0 ? '- ' + Math.abs(mn) : '+ ' + mn}`;
          let s2 = `y = ${m}x ${mn < 0 ? '- ' + Math.abs(mn) : '+ ' + mn} ${y1 < 0 ? '+ ' + Math.abs(y1) : '- ' + y1}`;
          let val = mn + y1;
          let s3 = `y = ${m}x ${val < 0 ? '- ' + Math.abs(val) : '+ ' + val}`;
          let s4 = `${m}x - y ${val < 0 ? '- ' + Math.abs(val) : '+ ' + val} = 0`;

          result.tech_s = s;
          result.tech_s1 = s1;
          result.tech_s2 = s2;
          result.tech_s3 = s3;
          result.tech_s4 = s4;
        } else {
          return { error: 'Please! Check Your Input.' };
        }
      } else {
        if (!isNaN(sec_x1) && !isNaN(sec_y1) && !isNaN(sec_x2) && !isNaN(sec_y2)) {
          if (sec_x1 == sec_x2) {
            return { error: 'Please Check Your Input: x1 and x2 cannot be the same.' };
          }

          m = (sec_y2 - sec_y1) / (sec_x2 - sec_x1);
          let slope = m;

          sec_x1 = -sec_x1;
          sec_y1 = -sec_y1;
          let mn = sec_x1 * m;

          let s = `(y ${sec_y1 < 0 ? '- ' + Math.abs(sec_y1) : '+ ' + sec_y1}) = ${m}(x ${sec_x1 < 0 ? '- ' + Math.abs(sec_x1) : '+ ' + sec_x1})`;
          let s1 = `(y ${sec_y1 < 0 ? '- ' + Math.abs(sec_y1) : '+ ' + sec_y1}) = ${m}x ${mn < 0 ? '- ' + Math.abs(mn) : '+ ' + mn}`;
          let s2 = `y = ${m}x ${mn < 0 ? '- ' + Math.abs(mn) : '+ ' + mn} ${sec_y1 < 0 ? '+ ' + Math.abs(sec_y1) : '- ' + sec_y1}`;
          let val = mn + sec_y1;
          let s3 = `y = ${m}x ${val < 0 ? '- ' + Math.abs(val) : '+ ' + val}`;
          let s4 = `${m}x - y ${val < 0 ? '- ' + Math.abs(val) : '+ ' + val} = 0`;

          result.tech_s = s;
          result.tech_s1 = s1;
          result.tech_s2 = s2;
          result.tech_s3 = s3;
          result.tech_s4 = s4;
          result.tech_slope = slope;
        } else {
          return { error: 'Please! Check Your Input.' };
        }
      }

      return result;
    }


      /** getCalculationHemisphereCalculator
   * POST: /api/calculators-lol/hemisphere-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationHemisphereCalculator(body) {
      let to_calculate = body.tech_to_calculate;
      let val = parseFloat(body.tech_value);
      let unit = body.tech_unit;
      let rof = parseInt(body.tech_rof);
      let result = {};

      if (!isNaN(val)) {
        let r, c, v, a, b, tsa, pc, pv, pa, pb, ptsa;

        const π = Math.PI;

        if (to_calculate === 'rad') {
          r = val + " " + unit;
          c = (2 * π * val).toFixed(rof) + " " + unit;
          v = ((2 / 3) * π * Math.pow(val, 3)).toFixed(rof) + " " + unit + "<sup class='font-s-14'>3</sup>";
          a = (2 * π * Math.pow(val, 2)).toFixed(rof) + " " + unit + "<sup class='font-s-14'>2</sup>";
          b = (π * Math.pow(val, 2)).toFixed(rof) + " " + unit + "<sup class='font-s-14'>2</sup>";
          tsa = (3 * π * Math.pow(val, 2)).toFixed(rof) + " " + unit + "<sup class='font-s-14'>2</sup>";
          pc = (2 * val).toFixed(rof) + " π " + unit;
          pv = ((2 / 3) * Math.pow(val, 3)).toFixed(rof) + " π " + unit + "<sup class='font-s-14'>3</sup>";
          pa = (2 * Math.pow(val, 2)).toFixed(rof) + " π " + unit + "<sup class='font-s-14'>2</sup>";
          pb = Math.pow(val, 2).toFixed(rof) + " π " + unit + "<sup class='font-s-14'>2</sup>";
          ptsa = (3 * Math.pow(val, 2)).toFixed(rof) + " π " + unit + "<sup class='font-s-14'>2</sup>";
        } else if (to_calculate === 'vol') {
          r = Math.pow((3 * val) / (2 * π), 1 / 3).toFixed(rof);
          c = (2 * π * r).toFixed(rof) + " " + unit;
          v = val.toFixed(rof) + " " + unit + "<sup class='font-s-14'>3</sup>";
          a = (2 * π * Math.pow(r, 2)).toFixed(rof) + " " + unit + "<sup class='font-s-14'>2</sup>";
          b = (π * Math.pow(r, 2)).toFixed(rof) + " " + unit + "<sup class='font-s-14'>2</sup>";
          tsa = (3 * π * Math.pow(r, 2)).toFixed(rof) + " " + unit + "<sup class='font-s-14'>2</sup>";
          pc = (2 * r).toFixed(rof) + " π " + unit;
          pv = ((2 / 3) * Math.pow(r, 3)).toFixed(rof) + " π " + unit + "<sup class='font-s-14'>3</sup>";
          pa = (2 * Math.pow(r, 2)).toFixed(rof) + " π " + unit + "<sup class='font-s-14'>2</sup>";
          pb = Math.pow(r, 2).toFixed(rof) + " π " + unit + "<sup class='font-s-14'>2</sup>";
          ptsa = (3 * Math.pow(r, 2)).toFixed(rof) + " π " + unit + "<sup class='font-s-14'>2</sup>";
          r = r + " " + unit;
        } else if (to_calculate === 'tsa') {
          r = Math.sqrt(val / (3 * π)).toFixed(rof);
          c = (2 * π * r).toFixed(rof) + " " + unit;
          v = ((2 / 3) * π * Math.pow(r, 3)).toFixed(rof) + " " + unit + "<sup class='font-s-14'>3</sup>";
          a = (2 * π * Math.pow(r, 2)).toFixed(rof) + " " + unit + "<sup class='font-s-14'>2</sup>";
          b = (π * Math.pow(r, 2)).toFixed(rof) + " " + unit + "<sup class='font-s-14'>2</sup>";
          tsa = val.toFixed(rof) + " " + unit + "<sup class='font-s-14'>2</sup>";
          pc = (2 * r).toFixed(rof) + " π " + unit;
          pv = ((2 / 3) * Math.pow(r, 3)).toFixed(rof) + " π " + unit + "<sup class='font-s-14'>3</sup>";
          pa = (2 * Math.pow(r, 2)).toFixed(rof) + " π " + unit + "<sup class='font-s-14'>2</sup>";
          pb = Math.pow(r, 2).toFixed(rof) + " π " + unit + "<sup class='font-s-14'>2</sup>";
          ptsa = (3 * Math.pow(r, 2)).toFixed(rof) + " π " + unit + "<sup class='font-s-14'>2</sup>";
          r = r + " " + unit;
        } else if (to_calculate === 'csa') {
          r = Math.sqrt(val / (2 * π)).toFixed(rof);
          c = (2 * π * r).toFixed(rof) + " " + unit;
          v = ((2 / 3) * π * Math.pow(r, 3)).toFixed(rof) + " " + unit + "<sup class='font-s-14'>3</sup>";
          a = val.toFixed(rof) + " " + unit + "<sup class='font-s-14'>2</sup>";
          b = (π * Math.pow(r, 2)).toFixed(rof) + " " + unit + "<sup class='font-s-14'>2</sup>";
          tsa = (3 * π * Math.pow(r, 2)).toFixed(rof) + " " + unit + "<sup class='font-s-14'>2</sup>";
          pc = (2 * r).toFixed(rof) + " π " + unit;
          pv = ((2 / 3) * Math.pow(r, 3)).toFixed(rof) + " π " + unit + "<sup class='font-s-14'>3</sup>";
          pa = (2 * Math.pow(r, 2)).toFixed(rof) + " π " + unit + "<sup class='font-s-14'>2</sup>";
          pb = Math.pow(r, 2).toFixed(rof) + " π " + unit + "<sup class='font-s-14'>2</sup>";
          ptsa = (3 * Math.pow(r, 2)).toFixed(rof) + " π " + unit + "<sup class='font-s-14'>2</sup>";
          r = r + " " + unit;
        } else if (to_calculate === 'cf') {
          r = (val / (2 * π)).toFixed(rof);
          c = (2 * π * r).toFixed(rof) + " " + unit;
          v = ((2 / 3) * π * Math.pow(r, 3)).toFixed(rof) + " " + unit + "<sup class='font-s-14'>3</sup>";
          a = (2 * π * Math.pow(r, 2)).toFixed(rof) + " " + unit + "<sup class='font-s-14'>2</sup>";
          b = val.toFixed(rof) + " " + unit + "<sup class='font-s-14'>2</sup>";
          tsa = (3 * π * Math.pow(r, 2)).toFixed(rof) + " " + unit + "<sup class='font-s-14'>2</sup>";
          pc = (2 * r).toFixed(rof) + " π " + unit;
          pv = ((2 / 3) * Math.pow(r, 3)).toFixed(rof) + " π " + unit + "<sup class='font-s-14'>3</sup>";
          pa = (2 * Math.pow(r, 2)).toFixed(rof) + " π " + unit + "<sup class='font-s-14'>2</sup>";
          pb = Math.pow(r, 2).toFixed(rof) + " π " + unit + "<sup class='font-s-14'>2</sup>";
          ptsa = (3 * Math.pow(r, 2)).toFixed(rof) + " π " + unit + "<sup class='font-s-14'>2</sup>";
          r = r + " " + unit;
        }

        result = {
          tech_radi: r,
          tech_cs: c,
          tech_vs: v,
          tech_as: a,
          tech_bs: b,
          tech_tsas: tsa,
          tech_pcs: pc,
          tech_pvs: pv,
          tech_pas: pa,
          tech_pbs: pb,
          tech_ptsas: ptsa,
        };
      } else {
        result.error = "Please! Check Your Input.";
      }

      return result;
    }


      /** getCalculationDiscriminantCalculator
   * POST: /api/calculators-lol/discriminant-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDiscriminantCalculator(body) {
    let to_calculate = body.tech_to_calculate;
    let value = parseFloat(body.tech_value);
    let value1 = parseFloat(body.tech_value1);
    let value2 = parseFloat(body.tech_value2);
    let value3 = parseFloat(body.tech_value3);
    let value4 = parseFloat(body.tech_value4);

    let param = {};

    if (to_calculate === '2d') {
      if (!isNaN(value) && !isNaN(value1) && !isNaN(value2)) {
        let A = value;
        let B = value1;
        let C = value2;
        let ds = Math.pow(B, 2) - 4 * A * C;
        let nr = ds === 0
          ? "The polynomial has a double root."
          : ds > 0
          ? "The polynomial has two distinct real roots"
          : "The polynomial has a pair of conjugate complex roots";

        param.tech_sd = ds;
        param.tech_nrs = nr;
        return param;
      }
    } else if (to_calculate === '3d') {
      if (!isNaN(value) && !isNaN(value1) && !isNaN(value2) && !isNaN(value3)) {
        let A = value;
        let B = value1;
        let C = value2;
        let D = value3;
        let ds =
          Math.pow(B, 2) * Math.pow(C, 2) -
          4 * A * Math.pow(C, 3) -
          4 * Math.pow(B, 3) * D -
          27 * Math.pow(A, 2) * Math.pow(D, 2) +
          18 * A * B * C * D;
        let nr = ds === 0
          ? "At least two roots are equal (one root of multiplicity 3 or two distinct real roots) one of which is a double root"
          : ds > 0
          ? "The roots are three distinct real numbers"
          : "There is one real root and two complex conjugate roots";

        param.tech_sd = ds;
        param.tech_nrs = nr;
        return param;
      }
    } else if (to_calculate === '4d') {
      if (!isNaN(value) && !isNaN(value1) && !isNaN(value2) && !isNaN(value3) && !isNaN(value4)) {
        let A = value;
        let B = value1;
        let C = value2;
        let D = value3;
        let E = value4;
        let ds =
          256 * Math.pow(A, 3) * Math.pow(E, 3) -
          192 * Math.pow(A, 2) * B * D * Math.pow(E, 2) -
          128 * Math.pow(A, 2) * Math.pow(C, 2) * Math.pow(E, 2) +
          144 * Math.pow(A, 2) * C * Math.pow(D, 2) * E -
          27 * Math.pow(A, 2) * Math.pow(D, 4) +
          144 * A * Math.pow(B, 2) * C * Math.pow(E, 2) -
          6 * A * Math.pow(B, 2) * Math.pow(D, 2) * E -
          80 * A * B * Math.pow(C, 2) * D * E +
          18 * A * B * C * Math.pow(D, 3) +
          16 * A * Math.pow(C, 4) * E -
          4 * A * Math.pow(C, 3) * Math.pow(D, 2) -
          27 * Math.pow(B, 4) * Math.pow(E, 2) +
          18 * Math.pow(B, 3) * C * D * E -
          4 * Math.pow(B, 3) * Math.pow(D, 3) -
          4 * Math.pow(B, 2) * Math.pow(C, 3) * E +
          Math.pow(B, 2) * Math.pow(C, 2) * Math.pow(D, 2);
        let nr = ds === 0
          ? "There are two or more equal roots"
          : ds > 0
          ? "There are four distinct real roots or four distinct non-real roots"
          : "There are two distinct real roots and two distinct non-real roots";

        param.tech_sd = ds;
        param.tech_nrs = nr;
        return param;
      }
    }

    param.error = "Please! Check Your Input.";
    return param;
  }

      /** getCalculationEndpointCalculator
   * POST: /api/calculators-lol/endpoint-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async getCalculationEndpointCalculator(body) {
      let x1 = parseFloat(body.tech_x1);
      let y1 = parseFloat(body.tech_y1);
      let x = parseFloat(body.tech_x);
      let y = parseFloat(body.tech_y);

      let param = {};

      if (!isNaN(x1) && !isNaN(y1) && !isNaN(x) && !isNaN(y)) {
        let x2 = 2 * x - x1;
        let y2 = 2 * y - y1;
        let dis = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        dis = Math.round(dis * 10000) / 10000;

        param.tech_x2 = x2;
        param.tech_y2 = y2;
        param.tech_dis = dis;
        return param;
      } else {
        param.error = "Please! Check Your Input.";
        return param;
      }
    }


      /** getCalculationSlopeInterceptFormCalculator
   * POST: /api/calculators-lol/slope-intercept-form-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async getCalculationSlopeInterceptFormCalculator(body) {

      let type = body.tech_type;
      let x1 = parseFloat(body.tech_x1);
      let x2 = parseFloat(body.tech_x2);
      let y1 = parseFloat(body.tech_y1);
      let y2 = parseFloat(body.tech_y2);

      let param = {};

      if (type === '2') {
        if (!isNaN(x1) && !isNaN(x2) && !isNaN(y1) && !isNaN(y2)) {
          let x = x2 - x1;
          let y = y2 - y1;
          let slope = parseFloat((y / x).toFixed(4));
          let angle = parseFloat((Math.atan(slope) * (180 / Math.PI)).toFixed(4));
          let distance = parseFloat(Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)).toFixed(4));
          let b = parseFloat((y1 - slope * x1).toFixed(2));

          param.tech_x = x;
          param.tech_y = y;
          param.tech_slope = slope;
          param.tech_angle = `${angle} deg`;
          param.tech_distance = distance;
          param.tech_b = b;
        } else {
          param.error = "Please! Check Your Input.";
        }

      } else if (type === '1') {
        let slope = x2; // here x2 is passed as slope

        if (!isNaN(x1) && !isNaN(y1) && !isNaN(slope)) {
          let angle = parseFloat((Math.atan(slope) * (180 / Math.PI)).toFixed(4));
          let b = parseFloat((y1 - slope * x1).toFixed(4));

          param.tech_b = b;
          param.tech_slope = slope;
          param.tech_angle = `${angle} deg`;
        } else {
          param.error = "Please! Check Your Input.";
        }

      } else {
        let b = x1;
        let slope = x2;

        if (!isNaN(b) && !isNaN(slope)) {
          let angle = parseFloat((Math.atan(slope) * (180 / Math.PI)).toFixed(4));

          param.tech_b = b;
          param.tech_slope = slope;
          param.tech_angle = `${angle} deg`;
        } else {
          param.error = "Please! Check Your Input.";
        }
      }

      return param;
    }



     /** getCalculationFactorialCalculator
   * POST: /api/calculators-lol/exponent-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationExponentCalculator(body) {
      let b = body.tech_b;
      let x = body.tech_x;

      let param = {};

      const invalidPattern = /<|>|\&|php|print_r|print|echo|script|=|%/i;

      if (invalidPattern.test(b) || invalidPattern.test(x)) {
        param.error = 'Please Enter Valid Input.';
        return param;
      }

      if (b !== undefined && x !== undefined && b !== '' && x !== '') {
        if (b.toString().length <= 7) {
          let expVal = Number(x);
          if (expVal <= 2000) {
            try {
              let base = eval(b);
              let exponent = eval(x);
              let result = Math.pow(base, exponent);

              param.tech_result = result;
              param.tech_b = base;
              param.tech_x = exponent;
              return param;
            } catch (e) {
              param.error = 'Invalid expression.';
              return param;
            }
          } else {
            param.error = 'Use exponents less than 2000.';
            return param;
          }
        } else {
          param.error = 'Enter base less than 7 characters.';
          return param;
        }
      } else {
        param.error = 'Please Enter Numbers.';
        return param;
      }
    }


     /** getCalculationSquareRootCalculator
   * POST: /api/calculators-lol/square-root-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationSquareRootCalculator(body) {
      let n = body.tech_n;
      let n1 = body.tech_n1;
      let rt = body.tech_rt;
      let selection = body.tech_selection;

      let param = {};

      const invalidPattern = /<|>|&|php|print_r|print|echo|script|=|%/i;
      if (invalidPattern.test(n) || invalidPattern.test(n1) || invalidPattern.test(rt)) {
        param.error = 'Please Enter Valid Input.';
        return param;
      }

      let num;
      let result;

      if (selection === '1') {
        if (!n) {
          param.error = 'Please Enter Numbers';
          return param;
        }
        num = eval(n);
        if (num < 0) {
          num = Math.abs(num);
          param.tech_iota = 'iota';
        }
        result = Math.sqrt(num);
        param.tech_check = 'sr';

      } else if (selection === '2') {
        if (!n1 || !rt) {
          param.error = 'Please Enter Numbers';
          return param;
        }
        num = eval(n1);
        let root = eval(rt);

        if (num < 0 && root < 0) {
          param.error = 'Please Enter Positive Numbers';
          return param;
        } else if (num < 0 && root === 2) {
          num = Math.abs(num);
          param.tech_iota = 'iota';
        } else if (num < 0 && root % 2 === 0) {
          param.error = 'Please Enter Positive Numbers';
          return param;
        } else {
          num = Math.abs(num);
        }

        result = Math.pow(num, 1 / root);
        param.tech_check = 'gr';
        param.tech_root = root;

      } else {
        param.error = 'Invalid selection';
        return param;
      }

      // Factorization for simplifying roots
      const primeFactor = (n) => {
        let factors = [];
        for (let i = 2; i <= Math.sqrt(n); i++) {
          while (n % i === 0) {
            factors.push(i);
            n /= i;
          }
        }
        if (n > 1) factors.push(n);
        return factors;
      };

      const isPerfectSquare = (n) => Number.isInteger(Math.sqrt(n));

      let radicand = num;
      let factors = primeFactor(radicand);
      let counts = factors.reduce((a, b) => {
        a[b] = (a[b] || 0) + 1;
        return a;
      }, {});

      let final = [], product = 1, valShow = [];

      for (let [prime, count] of Object.entries(counts)) {
        count = +count;
        if (count === 1) {
          final.push(+prime);
        } else if (count % 2 === 0) {
          final.push(Math.pow(prime, count));
          valShow.push(Math.pow(prime, count));
        } else {
          final.push(Math.pow(prime, count - 1));
          final.push(+prime);
          valShow.push(Math.pow(prime, count - 1));
        }
      }

      for (let v of final) {
        if (!isPerfectSquare(v)) {
          product *= v;
        }
      }

      let sqrShow = valShow.map(v => Math.sqrt(v));

      // Build factor strings
      let factorArr = final.map(v => v.toString());
      let productArr = final.map(v => isPerfectSquare(v) ? Math.sqrt(v).toString() : '');
      let factor = factorArr.join(' * ');
      let factor1 = factorArr.map((v, i) => {
        let sq = productArr[i] ? '√' : '';
        return `${v} ${sq}`;
      }).join(' * ');

      param.tech_factor = factor;
      param.tech_factor1 = factor1;
      param.tech_product = product;
      param.tech_sqr_show = sqrShow;
      param.tech_result = result;
      param.tech_num = num;

      return param;
    }


     /** getCalculationBinaryCalculator
   * POST: /api/calculators-lol/binary-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationBinaryCalculator(body) {
      let bnr_tpe1 = body.tech_bnr_tpe1;
      let bnr_tpe2 = body.tech_bnr_tpe2;
      let bnr_frs = body.tech_bnr_frs;
      let bnr_sec = body.tech_bnr_sec;
      let bnr_slc = body.tech_bnr_slc;

      let param = {};

      function bnrType(nn, type) {
        if (type === "binary") {
          return parseInt(nn, 2);
        } else if (type === "decimal") {
          return parseInt(nn, 10);
        } else if (type === "hexadecimal") {
          return parseInt(nn, 16);
        } else if (type === "octal") {
          return parseInt(nn, 8);
        }
        return NaN;
      }

      let fN = bnrType(bnr_frs, bnr_tpe1);
      let sN = bnrType(bnr_sec, bnr_tpe2);

      function bnrCal(fN, sN, op) {
        let rN, dc, bn, hx, oc;

        if (op === "add") {
          rN = fN + sN;
        } else if (op === "sub") {
          rN = fN - sN;
        } else if (op === "mult") {
          rN = fN * sN;
        } else if (op === "divd") {
          rN = fN / sN;
        }

        dc = (op === "divd") ? Math.round(rN) : rN;
        const absDc = Math.abs(dc);
        const sign = dc < 0 ? "-" : "";

        bn = sign + absDc.toString(2);
        hx = sign + absDc.toString(16).toUpperCase();
        oc = sign + absDc.toString(8);

        return [bn, dc, hx, oc];
      }

      const [bn, dc, hx, oc] = bnrCal(fN, sN, bnr_slc);

      param.tech_bn = bn;
      param.tech_dc = dc;
      param.tech_hx = hx;
      param.tech_oc = oc;

      return param;
    }


     /** getCalculationProportionCalculator
   * POST: /api/calculators-lol/proportion-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationProportionCalculator(body) {
    let a = body.tech_a;
    let b = body.tech_b;
    let c = body.tech_c;
    let d = body.tech_d;

    let param = {};

    if (a && b && c && d) {
      const isNumeric = (n) => !isNaN(parseFloat(n)) && isFinite(n);
      const isAlpha = (v) => typeof v === 'string' && /^[a-zA-Z]+$/.test(v);

      if (isNumeric(a) && isNumeric(b) && isNumeric(c) && isNumeric(d)) {
        param.error = 'Please! Enter the 3 numbers & use any letter for 1 unknown variable.';
        return param;
      } else if (isAlpha(a) && isNumeric(b) && isNumeric(c) && isNumeric(d)) {
        let a_val = (b * c) / d;
        param.tech_a_val = a_val;
      } else if (isNumeric(a) && isAlpha(b) && isNumeric(c) && isNumeric(d)) {
        let b_val = (a * d) / c;
        param.tech_b_val = b_val;
      } else if (isNumeric(a) && isNumeric(b) && isAlpha(c) && isNumeric(d)) {
        let c_val = (a * d) / b;
        param.tech_c_val = c_val;
      } else if (isNumeric(a) && isNumeric(b) && isNumeric(c) && isAlpha(d)) {
        let d_val = (b * c) / a;
        param.tech_d_val = d_val;
      } else {
        param.error = 'Please! Check Your Input.';
        return param;
      }

      return param;
    } else {
      param.error = 'Please Fill All the Fields!';
      return param;
    }
  }

     /** getCalculationLinearInterpolationCalculator
   * POST: /api/calculators-lol/linear-interpolation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationLinearInterpolationCalculator(body) {
      let x1 = body.tech_x1;
      let y1 = body.tech_y1;
      let x2 = body.tech_x2;
      let y2 = body.tech_y2;
      let x3 = body.tech_x3;
      let y3 = body.tech_y3;

      let param = {};

      const isNumeric = (n) => !isNaN(parseFloat(n)) && isFinite(n);

      if (!x1 && isNumeric(y1) && isNumeric(x2) && isNumeric(y2) && isNumeric(x3) && isNumeric(y3)) {
        if (x2 != x3 && y1 != y2 && y2 != y3 && y1 != y3) {
          let s1 = y3 - y1;
          let s2 = x2 - x3;
          let s3 = y3 - y2;
          let s4 = s1 * s2;
          let s5 = s4 / s3;
          x1 = s5 + Number(x3);
          Object.assign(param, {
              tech_x1:x1,
              tech_s1:s1,
              tech_s2:s2,
              tech_s3:s3,
              tech_s4:s4,
              tech_s5:s5,
            });
        } else {
          param.error = '2 values should not be same.';
        }

      } else if (isNumeric(x1) && !y1 && isNumeric(x2) && isNumeric(y2) && isNumeric(x3) && isNumeric(y3)) {
        if (x1 != x2 && x2 != x3 && x1 != x3 && y2 != y3) {
          let s1 = x2 - x1;
          let s2 = y3 - y2;
          let s3 = x3 - x1;
          let s4 = s1 * s2;
          let s5 = s4 / s3;
          y1 = s5 + Number(y2);
          Object.assign(param, { 
            tech_y1:y1,
            tech_s1:s1, 
            tech_s2:s2,
            tech_s3:s3, 
            tech_s4:s4, 
            tech_s5:s5,
          });
        } else {
          param.error = '2 values should not be same.';
        }

      } else if (isNumeric(x1) && isNumeric(y1) && !x2 && isNumeric(y2) && isNumeric(x3) && isNumeric(y3)) {
        if (x1 != x3 && y1 != y2 && y2 != y3 && y1 != y3) {
          let s1 = y1 - y2;
          let s2 = x3 - x1;
          let s3 = y1 - y3;
          let s4 = s1 * s2;
          let s5 = s4 / s3;
          x2 = s5 + Number(x1);
          Object.assign(param, { 
                tech_x2:x2,
                tech_s1:s1,
                tech_s2:s2,
                tech_s3:s3,
                tech_s4:s4,
                tech_s5:s5, 
                });
        } else {

          param.error = '2 values should not be same.';
        }

      } else if (isNumeric(x1) && isNumeric(y1) && isNumeric(x2) && !y2 && isNumeric(x3) && isNumeric(y3)) {
        if (x1 != x2 && x2 != x3 && x1 != x3 && y1 != y3) {
          let s1 = x3 - x2;
          let s2 = y3 - y1;
          let s3 = x3 - x2;
          let s4 = s1 * s2;
          let s5 = s4 / s3;
          y2 = s5 + Number(y3);
          Object.assign(param, { 
            tech_y2:y2,
            tech_s1:s1,
            tech_s2:s2,
            tech_s3:s3,
            tech_s4:s4, 
            tech_s5:s5,
          });
        } else {
          param.error = '2 values should not be same.';
        }

      } else if (isNumeric(x1) && isNumeric(y1) && isNumeric(x2) && isNumeric(y2) && !x3 && isNumeric(y3)) {
        if (x1 != x2 && y1 != y2 && y2 != y3 && y1 != y3) {
          let s1 = y3 - y2;
          let s2 = x1 - x2;
          let s3 = y1 - y2;
          let s4 = s1 * s2;
          let s5 = s4 / s3;
          x3 = s5 + Number(x2);
          Object.assign(param, { 
              tech_x3:x3,
              tech_s1:s1, 
              tech_s2:s2,
              tech_s3:s3,
              tech_s4:s4,
              tech_s5:s5,
            });
        } else {
          param.error = '2 values should not be same.';
        }

      } else if (isNumeric(x1) && isNumeric(y1) && isNumeric(x2) && isNumeric(y2) && isNumeric(x3) && !y3) {
        if (x1 != x2 && x2 != x3 && x1 != x3 && y1 != y2) {
          let s1 = x3 - x1;
          let s2 = y2 - y1;
          let s3 = x2 - x1;
          let s4 = s1 * s2;
          let s5 = s4 / s3;
          y3 = s5 + Number(y1);
          Object.assign(param, { 
              tech_y3:y3,
              tech_s1:s1,
              tech_s2:s2, 
              tech_s3:s3, 
              tech_s4:s4, 
              tech_s5:s5, 
            });
        } else {
          param.error = '2 values should not be same.';
        }

      } else {
        param.error = 'Please! Check Your Input.';
      }

      return param;
    }


     /** getCalculationPythagoreanTheoremCalculator
   * POST: /api/calculators-lol/pythagorean-theorem-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationPythagoreanTheoremCalculator(body) {
      let one = body.tech_one;
      let two = body.tech_two;
      let forSide = body.tech_for; // renamed to avoid JS keyword `for`
      let nbr = body.tech_nbr;

      let param = {};

      const isNumeric = (n) => !isNaN(parseFloat(n)) && isFinite(n);

      if (isNumeric(one) && isNumeric(two) && isNumeric(nbr)) {
        one = parseFloat(one);
        two = parseFloat(two);
        nbr = parseInt(nbr);

        let a, b, c;

        if (forSide === 'a') {
          b = one;
          c = two;
          a = +(Math.sqrt(Math.pow(c, 2) - Math.pow(b, 2))).toFixed(nbr);
        } else if (forSide === 'b') {
          a = one;
          c = two;
          b = +(Math.sqrt(Math.pow(c, 2) - Math.pow(a, 2))).toFixed(nbr);
        } else if (forSide === 'c' || forSide === 'ar') {
          a = one;
          b = two;
          c = +(Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2))).toFixed(nbr);
        } else {
          param.error = 'Invalid "for" parameter.';
          return param;
        }

        let area = +(a * b / 2).toFixed(nbr);
        let peri = +(a + b + c).toFixed(nbr);
        let h = +(a * b / c).toFixed(nbr);
        let alfa = +(Math.asin(a / c)).toFixed(nbr);
        let a_deg = +(alfa * (180 / Math.PI)).toFixed(nbr);
        let beta = +(Math.asin(b / c)).toFixed(nbr);
        let b_deg = +(beta * (180 / Math.PI)).toFixed(nbr);

        Object.assign(param, {
            tech_a:a,
            tech_b:b,
            tech_c:c, 
            tech_area:area, 
            tech_peri:peri, 
            tech_h:h, 
            tech_alfa:alfa,
            tech_a_deg:a_deg,
            tech_beta:beta, 
            tech_b_deg:b_deg, 
        });

      } else {
        param.error = 'Please Check Your Input.';
      }

      return param;
    }

     /** getCalculationUnitCircleCalculator
   * POST: /api/calculators-lol/unit-circle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationUnitCircleCalculator(body) {
      let angle = body.tech_angle;
      let angle_unit = body.tech_angle_unit;

      let param = {};

      const isNumeric = (n) => !isNaN(parseFloat(n)) && isFinite(n);

      if (isNumeric(angle) && angle_unit) {
        angle = parseFloat(angle);

        if (angle_unit === 'rad') {
          angle = angle * (180 / Math.PI); // rad to deg
        } else if (angle_unit === 'pirad') {
          angle = angle * Math.PI;         // π*rad
          angle = angle * (180 / Math.PI); // to deg
        }

        const radians = angle * (Math.PI / 180); // deg to rad
        const sin = Math.sin(radians);
        const cos = Math.cos(radians);
        const tan = Math.tan(radians);

        param.tech_sin = +sin.toFixed(8);
        param.tech_cos = +cos.toFixed(8);
        param.tech_tan = +tan.toFixed(8);
      } else {
        param.error = 'Please! Check Your Input.';
      }

      return param;
    }


     /** getCalculationArcLengthCalculator
   * POST: /api/calculators-lol/arc-length-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async getCalculationArcLengthCalculator(body) {
    let find = body.tech_find;
    let angle = body.tech_angle;
    let angle_unit = body.tech_angle_unit;
    let rad = body.tech_rad;
    let rad_unit = body.tech_rad_unit;
    let diameter = body.tech_diameter;
    let diameter_unit = body.tech_diameter_unit;
    let area = body.tech_area;
    let area_unit = body.tech_area_unit;
    let chrd_len = body.tech_chrd_len;
    let chrd_len_unit = body.tech_chrd_len_unit;
    let seg_height = body.tech_seg_height;
    let seg_height_unit = body.tech_seg_height_unit;


      let param = {};

      function toRadians(degrees) {
        return degrees * (Math.PI / 180);
      }

      // Angle unit conversion
      if (!isNaN(angle)) {
        if (angle_unit === 'deg') angle = angle / 57.2958;
        else if (angle_unit === 'gon') angle = angle / 63.662;
        else if (angle_unit === 'tr') angle = angle / 0.159155;
        else if (angle_unit === 'arcmin') angle = angle / 3437.75;
        else if (angle_unit === 'arcsec') angle = angle / 206265;
        else if (angle_unit === 'mrad') angle = angle / 1000;
        else if (angle_unit === 'urad') angle = angle / 1000000;
        else if (angle_unit === 'pirad') angle = angle / 0.31831;
      }

      // Convert length units to meters
      function convertToMeters(value, unit) {
        if (isNaN(value)) return value;
        const conversions = {
          mm: 1 / 1000,
          cm: 1 / 100,
          km: 1000,
          in: 1 / 39.3701,
          ft: 1 / 3.28084,
          yd: 1 / 1.093613,
          mi: 1 / 0.000621371,
          nmi: 1 / 0.000539957,
        };
        return value * (conversions[unit] || 1);
      }

      rad = convertToMeters(rad, rad_unit);
      diameter = convertToMeters(diameter, diameter_unit);
      chrd_len = convertToMeters(chrd_len, chrd_len_unit);
      seg_height = convertToMeters(seg_height, seg_height_unit);

      // Area unit conversion to square meters
      if (!isNaN(area)) {
        const conversions = {
          mm2: 1 / 1e6,
          cm2: 1 / 1e4,
          dm2: 1 / 100,
          km2: 1e6,
          in2: 1 / 1550.003,
          ft2: 1 / 10.7639,
          yd2: 1 / 1.19599,
          mi2: 1 / 0.000000386102,
          a: 1 / 0.01,
          da: 1 / 0.001,
          ha: 1 / 0.0001,
          ac: 1 / 0.0002471054,
          s_f: 1 / 0.000140056,
        };
        area *= conversions[area_unit] || 1;
      }

      let arc_len;

      function round(val, dec) {
        return Math.round(val * Math.pow(10, dec)) / Math.pow(10, dec);
      }

      try {
        switch (find) {
          case '0':
            if (!isNaN(angle) && !isNaN(rad)) {
              diameter = rad * 2;
              area = Math.pow(rad, 2) * (angle / 2);
              arc_len = rad * angle;
              chrd_len = 2 * rad * Math.sin(angle / 2);
              Object.assign(param, {
                tech_arc_len: round(arc_len, 5),
                tech_diameter: round(diameter, 3),
                tech_area: round(area, 4),
                tech_chrd_len: round(chrd_len, 3),
              });
            } else throw 'Check Input';
            break;
          case '1':
            if (!isNaN(rad) && !isNaN(seg_height)) {
              if (rad < 10) throw 'Radius cannot be less than 10!';
              angle = 2 * Math.acos(1 - seg_height / rad);
              diameter = rad * 2;
              area = Math.pow(rad, 2) * (angle / 2);
              arc_len = rad * angle;
              Object.assign(param, {
                tech_arc_len: round(arc_len, 5),
                tech_angle: round(angle, 5),
                tech_diameter: round(diameter, 3),
                tech_area: round(area, 4),
                tech_chrd_len: round(chrd_len, 3),
              });
            } else throw 'Check Input';
            break;
          case '2':
            if (!isNaN(rad) && !isNaN(area)) {
              angle = (2 * area) / Math.pow(rad, 2);
              diameter = rad * 2;
              arc_len = rad * angle;
              chrd_len = 2 * rad * Math.sin(angle / 2);
              if (angle_unit === 'deg') angle *= 57.2958;
              area = Math.pow(rad, 2) * (angle / 2);
              Object.assign(param, {
                tech_arc_len: round(arc_len, 5),
                tech_angle: round(angle, 4),
                tech_diameter: round(diameter, 3),
                tech_chrd_len: round(chrd_len, 3),
                tech_area: round(area, 3),
              });
            } else throw 'Check Input';
            break;
          case '3':
            if (!isNaN(rad) && !isNaN(chrd_len)) {
              area = Math.pow(rad, 2) * (angle / 2);
              angle = (2 * area) / Math.pow(rad, 2);
              diameter = rad * 2;
              arc_len = rad * angle;
              if (angle_unit === 'deg') angle *= 57.2958;
              Object.assign(param, {
                tech_arc_len: round(arc_len, 5),
                tech_angle: round(angle, 4),
                tech_diameter: round(diameter, 3),
                tech_area: round(area, 4),
              });
            } else throw 'Check Input';
            break;
          case '4':
            if (!isNaN(angle) && !isNaN(diameter)) {
              rad = diameter / 2;
              area = Math.pow(rad, 2) * (angle / 2);
              arc_len = rad * angle;
              Object.assign(param, {
                tech_arc_len: round(arc_len, 5),
                tech_rad: round(rad, 4),
                tech_diameter: round(diameter, 3),
                tech_area: round(area, 4),
              });
            } else throw 'Check Input';
            break;
          case '5':
            if (!isNaN(angle) && !isNaN(area)) {
              rad = Math.sqrt((2 * area) / angle);
              diameter = rad * 2;
              arc_len = rad * angle;
              chrd_len = 2 * rad * Math.sin(angle / 2);
              Object.assign(param, {
                tech_arc_len: round(arc_len, 5),
                tech_rad: round(rad, 4),
                tech_diameter: round(diameter, 3),
                tech_chrd_len: round(chrd_len, 3),
              });
            } else throw 'Check Input';
            break;
          case '6':
            if (!isNaN(angle) && !isNaN(chrd_len)) {
              rad = chrd_len / (2 * Math.sin(angle / 2));
              diameter = rad * 2;
              area = Math.pow(rad, 2) * (angle / 2);
              arc_len = rad * angle;
              Object.assign(param, {
                tech_arc_len: round(arc_len, 5),
                tech_rad: round(rad, 4),
                tech_diameter: round(diameter, 3),
                tech_area: round(area, 4),
              });
            } else throw 'Check Input';
            break;
          default:
            if (!isNaN(chrd_len) && !isNaN(seg_height)) {
              rad = seg_height / 2 + Math.pow(chrd_len, 2) / (8 * seg_height);
              angle = 2 * Math.asin(chrd_len / (2 * rad));
              diameter = rad * 2;
              area = Math.pow(rad, 2) * (angle / 2);
              arc_len = rad * angle;
              Object.assign(param, {
                tech_arc_len: round(arc_len, 5),
                tech_angle: round(angle, 4),
                tech_rad: round(rad, 4),
                tech_diameter: round(diameter, 3),
                tech_area: round(area, 4),
              });
            } else throw 'Check Input';
        }

        return param;
      } catch (err) {
        return { error: err };
      }
    }


     /** getCalculationArcsinCalculator
   * POST: /api/calculators-lol/arcsin-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async getCalculationArcsinCalculator(body) {
      let arcsin = body.tech_arcsin;
      let round = body.tech_round;

      let param = {};

      function DDtoDMS(dec) {
        let [degPart, fracPart] = dec.toString().split(".");
        let deg = parseInt(degPart);
        let min = 0;
        let sec = 0;

        if (fracPart !== undefined) {
          let tempma = parseFloat("0." + fracPart) * 3600;
          min = Math.floor(tempma / 60);
          sec = Math.round(tempma - (min * 60) * 1000) / 1000;
        }

        return { deg, min, sec };
      }

      if (!isNaN(arcsin) && !isNaN(round)) {
        let rad = Math.asin(arcsin);
        let deg = rad * (180 / Math.PI);
        let gon = rad * 63.66;
        let tr = rad * 0.15915;
        let arcmin = rad * 3438;
        let arcsec = rad * 206265;
        let mrad = rad * 1000;
        let urad = rad * 1000000;
        let pirad = rad * 0.3183;

        let DMS = DDtoDMS(deg);
        let d = DMS.deg;
        let m = DMS.min;
        let s = DMS.sec;

        param.tech_angle = +deg.toFixed(1);
        param.tech_rad = +rad.toFixed(round);
        param.tech_gon = +gon.toFixed(round);
        param.tech_tr = +tr.toFixed(round);
        param.tech_arcmin = +arcmin.toFixed(round);
        param.tech_arcsec = +arcsec.toFixed(round);
        param.tech_mrad = +mrad.toFixed(round);
        param.tech_urad = +urad.toFixed(round);
        param.tech_pirad = +pirad.toFixed(round);
        param.tech_deg = +d.toFixed(round);
        param.tech_min = +m.toFixed(round);
        param.tech_sec = +s.toFixed(round);
      } else {
        param.error = 'Please! Check Your Input.';
      }

      return param;
    }


     /** getCalculationCosineCalculator
   * POST: /api/calculators-lol/cosine-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async getCalculationCosineCalculator(body) {
      let angle = body.tech_angle;
      let angle_unit = body.tech_angle_unit;

      let param = {};

      if (angle !== undefined && angle !== null && angle !== '') {
        let rad;

        if (angle_unit === 'deg') {
          rad = angle * (Math.PI / 180);
        } else if (angle_unit === 'pirad') {
          rad = angle * Math.PI;
        } else if (angle_unit === 'mrad') {
          rad = angle / 1000;
        } else {
          rad = angle; // assume already in radians
        }

        let cos = Math.cos(rad);

        param.tech_cos = +cos.toFixed(8);
      } else {
        param.error = 'Please! Check Your Input.';
      }

      return param;
    }

     /** getCalculationSineCalculator
   * POST: /api/calculators-lol/sine-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async getCalculationSineCalculator(body) {
      let angle = body.tech_angle;
      let angle_unit = body.tech_angle_unit;

      let param = {};

      if (!isNaN(angle)) {
        let rad;

        if (angle_unit === 'deg') {
          rad = angle * (Math.PI / 180);
        } else if (angle_unit === 'pirad') {
          rad = angle * Math.PI;
        } else {
          rad = angle; // assume already in radians
        }

        let sin = Math.sin(rad);

        param.tech_sin = +sin.toFixed(8);
      } else {
        param.error = 'Please! Check Your Input.';
      }

      return param;
    }

     /** getCalculationArccosCalculator
   * POST: /api/calculators-lol/arccos-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async getCalculationArccosCalculator(body) {
      let arccos = body.tech_arccos;
      let round = body.tech_round;

      let param = {};

      if (!isNaN(arccos) && !isNaN(round)) {
        function DDtoDMS(dec) {
          let parts = dec.toString().split(".");
          let deg = parseInt(parts[0]);
          let min = 0, sec = 0;

          if (parts.length > 1) {
            let fractional = parseFloat("0." + parts[1]);
            let totalSeconds = fractional * 3600;
            min = Math.floor(totalSeconds / 60);
            sec = +(totalSeconds - (min * 60)).toFixed(3);
          }

          return { deg, min, sec };
        }

        let rad = Math.acos(arccos);
        let deg = rad * (180 / Math.PI);
        let gon = rad * 63.66;
        let tr = rad * 0.15915;
        let arcmin = rad * 3438;
        let arcsec = rad * 206265;
        let mrad = rad * 1000;
        let urad = rad * 1000000;
        let pirad = rad * 0.3183;

        let DMS = DDtoDMS(deg);
        let d = DMS.deg;
        let m = DMS.min;
        let s = DMS.sec;

        param.tech_angle = +deg.toFixed(1);
        param.tech_rad = +rad.toFixed(round);
        param.tech_gon = +gon.toFixed(round);
        param.tech_tr = +tr.toFixed(round);
        param.tech_arcmin = +arcmin.toFixed(round);
        param.tech_arcsec = +arcsec.toFixed(round);
        param.tech_mrad = +mrad.toFixed(round);
        param.tech_urad = +urad.toFixed(round);
        param.tech_pirad = +pirad.toFixed(round);
        param.tech_deg = +d.toFixed(round);
        param.tech_min = +m.toFixed(round);
        param.tech_sec = +s.toFixed(round);
      } else {
        param.error = 'Please! Check Your Input.';
      }

      return param;
    }

     /** getCalculationArctanCalculator
   * POST: /api/calculators-lol/arccos-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async getCalculationArctanCalculator(body) {
    let arctan = body.tech_arctan;
    let round = body.tech_round;

    let param = {};

    if (!isNaN(arctan) && !isNaN(round)) {
      function DDtoDMS(dec) {
        let parts = dec.toString().split(".");
        let deg = parseInt(parts[0]);
        let min = 0, sec = 0;

        if (parts.length > 1) {
          let fractional = parseFloat("0." + parts[1]);
          let totalSeconds = fractional * 3600;
          min = Math.floor(totalSeconds / 60);
          sec = +(totalSeconds - (min * 60)).toFixed(3);
        }

        return { deg, min, sec };
      }

      let rad = Math.atan(arctan);
      let deg = rad * (180 / Math.PI);
      let gon = rad * 63.66;
      let tr = rad * 0.15915;
      let arcmin = rad * 3438;
      let arcsec = rad * 206265;
      let mrad = rad * 1000;
      let urad = rad * 1000000;
      let pirad = rad * 0.3183;

      let DMS = DDtoDMS(deg);
      let d = DMS.deg;
      let m = DMS.min;
      let s = DMS.sec;

      param.tech_angle = +deg.toFixed(round);
      param.tech_rad = +rad.toFixed(round);
      param.tech_gon = +gon.toFixed(round);
      param.tech_tr = +tr.toFixed(round);
      param.tech_arcmin = +arcmin.toFixed(round);
      param.tech_arcsec = +arcsec.toFixed(round);
      param.tech_mrad = +mrad.toFixed(round);
      param.tech_urad = +urad.toFixed(round);
      param.tech_pirad = +pirad.toFixed(round);
      param.tech_deg = +d.toFixed(round);
      param.tech_min = +m.toFixed(round);
      param.tech_sec = +s.toFixed(round);
    } else {
      param.error = 'Please! Check Your Input.';
    }

    return param;
  }


     /** getCalculationTangentCalculator
   * POST: /api/calculators-lol/tangent-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationTangentCalculator(body) {
    let angle = body.tech_angle;
    let angle_unit = body.tech_angle_unit;

    let param = {};

    if (!isNaN(angle)) {
      if (angle_unit === 'deg') {
        angle = angle * (Math.PI / 180); // convert to radians
      } else if (angle_unit === 'pirad') {
        angle = angle * Math.PI;
      } else if (angle_unit === 'mrad') {
        angle = angle / 1000;
      }

      let tan = Math.tan(angle);
      param.tech_tan = +tan.toFixed(8);
    } else {
      param.error = 'Please! Check Your Input.';
    }

    return param;
  }

     /** getCalculationSecantCalculator
   * POST: /api/calculators-lol/secant-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async getCalculationSecantCalculator(body) {
      let angle = body.tech_angle;
      let angle_unit = body.tech_angle_unit;

      let result = {};

      if (typeof angle === 'number') {
        let radian;

        if (angle_unit === 'deg') {
          radian = angle * (Math.PI / 180); // deg to rad
        } else if (angle_unit === 'pirad') {
          radian = angle * Math.PI;
        } else {
          radian = angle; // assume already in radians
        }

        let cosine = Math.cos(radian);
        let sec = 1 / cosine;

        // Handle Infinity or extremely large values
        sec = Math.abs(sec) > 1e10 ? Infinity : sec;

        result.tech_sec = Number(sec.toFixed(8));
      } else {
        result.error = 'Please! Check Your Input.';
      }

      return result;
    }



     /** getCalculationCscCalculator
   * POST: /api/calculators-lol/csc-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
      async  getCalculationCscCalculator(body) {
        let angle = body.tech_angle;
        let angle_unit = body.tech_angle_unit;

        let result = {};

        if (!isNaN(angle)) {
          let csc;

          if (angle_unit === 'deg') {
            csc = 1 / Math.sin((angle * Math.PI) / 180);
          } else if (angle_unit === 'pirad') {
            angle = angle * Math.PI;
            csc = 1 / Math.sin(angle);
          } else {
            csc = 1 / Math.sin(angle);
          }

          result.tech_csc = Number(csc.toFixed(8));
        } else {
          result.error = 'Please! Check Your Input.';
        }

        return result;
      }


     /** getCalculationCotangentCalculator
   * POST: /api/calculators-lol/cotangent-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationCotangentCalculator(body) {
      let angle = parseFloat(body.tech_angle);
      let angle_unit = body.tech_angle_unit;
      let result = {};

      if (!isNaN(angle)) {
        let cot;

        if (angle_unit === 'deg') {
          cot = 1 / Math.tan((angle * Math.PI) / 180);
        } else if (angle_unit === 'pirad') {
          angle = angle * Math.PI;
          cot = 1 / Math.tan(angle);
        } else if (angle_unit === 'mrad') {
          angle = angle / 1000;
          cot = 1 / Math.tan(angle);
        } else {
          cot = 1 / Math.tan(angle);
        }

        result.tech_cot = Number(cot.toFixed(8));
      } else {
        result.error = 'Please! Check Your Input.';
      }

      return result;
    }


     /** getCalculationECalculator
   * POST: /api/calculators-lol/e-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationECalculator(body) {
    let cal = body.tech_cal;
    let x = parseFloat(body.tech_x);
    let a = parseFloat(body.tech_a);
    let result = {};

    if (!isNaN(x)) {
      let exp;

      if (cal === 'ex') {
        exp = Math.exp(x);
      } else if (cal === '10x') {
        exp = Math.pow(10, x);
      } else if (cal === 'ax' && !isNaN(a)) {
        exp = Math.pow(a, x);
      } else {
        result.error = 'Please Check Your Input.';
        return result;
      }

      result.tech_exp = exp;
    } else {
      result.error = 'Please Check Your Input.';
    }

    return result;
  }



     /** getCalculationParallelAndPerpendicularlineCalculator
   * POST: /api/calculators-lol/parallel-and-perpendicular-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async  getCalculationParallelAndPerpendicularlineCalculator(body) {
  let a = parseFloat(body.tech_a);
  let b = parseFloat(body.tech_b);
  let c = parseFloat(body.tech_c);
  let form = body.tech_form;
  let method = body.tech_method;
  let p1 = parseFloat(body.tech_p1);
  let p2 = parseFloat(body.tech_p2);

  function new_gcd_(a, b) {
    a = Math.abs(a);
    b = Math.abs(b);
    if (a < b) [a, b] = [b, a];
    if (b === 0) return 1;
    let r = a % b;
    while (r > 0) {
      a = b;
      b = r;
      r = a % b;
    }
    return b;
  }

  function new_reduce(num, den) {
    let g = new_gcd_(num, den);
    return [num / g, den / g];
  }

  let result = {};

  if (!isNaN(a) && !isNaN(b) && !isNaN(p1) && !isNaN(p2)) {
    if (form === '1') {
      if (!isNaN(c)) {
        let y = method === '2' ? b : -b;
        let [upr, btm] = new_reduce(a, y);
        if (btm < 0) {
          btm = Math.abs(btm);
          upr = -upr;
        }

        if (method === '2') {
          let btm_ = upr;
          let upr_ = btm;
          result.upr_ = btm_;
          result.btm_ = upr_;
          btm = btm_;
          upr = upr_;
        }

        let [upr1, btm1] = new_reduce(c, -b);
        if (btm1 < 0) {
          btm1 = Math.abs(btm1);
          upr1 = -upr1;
        }

        let au = -upr * p1;
        let ab = btm * p2;
        au = ab + au;

        let [upr2, btm2] = new_reduce(au, btm);
        if (btm2 < 0) {
          btm2 = Math.abs(btm2);
          upr2 = -upr2;
        }

        Object.assign(result, {
          tech_upr:upr,
          tech_btm:btm,
          tech_upr1:upr1,
          tech_btm1:btm1,
          tech_upr2:upr2,
          tech_btm2:btm2,
          tech_form:form,
          tech_method:method,
          tech_a:a,
          tech_b:b,
          tech_c:c,
          tech_p1:p1,
          tech_p2:p2,
        });
        return result;
      } else {
        return { error: 'Please! Check Your Input.' };
      }
    } else {
      if (method === '1') {
        let au = -a * p1 + p2;
        Object.assign(result, {
          tech_au:au,
          tech_method:method,
          tech_form:form,
          tech_a:a,
          tech_b:b,
          tech_p1:p1,
          tech_p2:p2,
        });
        return result;
      } else {
        let upr = a < 0 ? 1 : -1;
        let au = Math.abs(a);
        let au1 = -upr * p1;
        let ab = au * p2;
        au1 = ab + au1;
        let [upr2, btm2] = new_reduce(au1, au);
        if (btm2 < 0) {
          btm2 = Math.abs(btm2);
          upr2 = -upr2;
        }
        Object.assign(result, {
          tech_upr:upr,
          tech_au:au,
          tech_form:form,
          tech_method:method,
          tech_upr2:upr2,
          tech_btm2:btm2,
          tech_a:a,
          tech_b:b,
          tech_p1:p1,
          tech_p2:p2,
        });
        return result;
      }
    }
  } else {
    return { error: 'Please! Check Your Input.' };
  }
}


     /** getCalculationCoterminalAngleCalculator
   * POST: /api/calculators-lol/coterminal-angle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationCoterminalAngleCalculator(body) {
      let want = parseInt(body.tech_want);
      let unit = parseInt(body.tech_unit);
      let angle = parseFloat(body.tech_angle);
      let angle2 = parseFloat(body.tech_angle2);

      function gcd(a, b) {
        a = Math.abs(a);
        b = Math.abs(b);
        if (a < b) [a, b] = [b, a];
        if (b === 0) return 1;
        let r = a % b;
        while (r > 0) {
          a = b;
          b = r;
          r = a % b;
        }
        return b;
      }

      function reduce(num, den) {
        let g = gcd(num, den);
        return [num / g, den / g];
      }

      let result = {};

      if (unit === 1 && want === 1) {
        let [upr, btm] = reduce(angle, 180);
        let rad = +(upr / btm).toFixed(3);
        result = { 
          tech_want:want, 
          tech_rad:rad, 
          tech_upr:upr, 
          tech_btm:btm, 
          tech_unit:unit, 
          tech_angle:angle, 
          tech_angle2:angle2
        };
      } else if (unit === 2 && want === 1) {
        let deg = +(angle * 180).toFixed(3);
        let two = angle;
        while (two >= 2) {
          two -= 2;
        }

        let pos, neg;
        if (angle >= 2) {
          pos = `${two} π,${two + 2} π,${two + 4} π,${two + 6} π,${two + 8} π .....`;
          neg = `${two - 2} π,${two - 4} π,${two - 6} π,${two - 8} π,${two - 10} π .....`;
        } else {
          pos = `${angle + 2} π,${angle + 4} π,${angle + 6} π,${angle + 8} π,${angle + 10} π .....`;
          neg = `${angle - 2} π,${angle - 4} π,${angle - 6} π,${angle - 8} π,${angle - 10} π .....`;
        }

        let rem = deg % 360;
        let q = '';
        if (rem > 0 && rem < 90) q = 'first quadrant';
        else if (rem === 90) q = 'positive y-axis';
        else if (rem > 90 && rem < 180) q = 'second quadrant';
        else if (rem === 180) q = 'negative x-axis';
        else if (rem > 180 && rem < 270) q = 'third quadrant';
        else if (rem === 270) q = 'negative y-axis';
        else if (rem > 270) q = 'fourth quadrant';
        else if (rem === 0) q = 'positive x-axis';

        result = { 
          tech_want:want, 
          tech_two:two, 
          tech_pos:pos, 
          tech_neg:neg, 
          tech_deg:deg, 
          tech_q:q, 
          tech_unit:unit, 
          tech_angle:angle, 
          tech_angle2:angle2
        };
      } else if (unit === 1 && want === 2) {
        let angle_ = angle % 360;
        let angle2_ = angle2 % 360;
        let check = angle_ === angle2_ ? 1 : 0;
        result = { 
          tech_check:check, 
          tech_want:want, 
          tech_unit:unit, 
          tech_angle:angle, 
          tech_angle2:angle2
        };
      } else if (unit === 2 && want === 2) {
        let angle11 = angle * 180;
        let angle22 = angle2 * 180;
        let angle_ = angle11 % 360;
        let angle2_ = angle22 % 360;
        let check = angle_ === angle2_ ? 1 : 0;
        result = {
          tech_check:check, 
          tech_want:want,
            tech_unit:unit, 
            tech_angle:angle, 
            tech_angle2:angle2 
          };
      }

      return result;
    }


     /** getCalculationArithmeticSequenceCalculator
   * POST: /api/calculators-lol/arithmetic-sequences-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationArithmeticSequenceCalculator(body) {
      let first = parseFloat(body.tech_first);
      let diff = parseFloat(body.tech_diff);
      let nth = parseInt(body.tech_nth);

      let result = {};

      if (!isNaN(first) && !isNaN(diff) && !isNaN(nth)) {
        let nth_v = first + ((nth - 1) * diff);
        let sum = first;
        let res = `${first}`;

        for (let i = 1; i < 10; i++) {
          sum += diff;
          if (i < 9) {
            res += `, ${sum}`;
          }
          if (i === 9) {
            res += ' ....';
          }
        }

        let total = (nth / 2) * ((2 * first) + ((nth - 1) * diff));

        result = {
          tech_first:first,
          tech_diff:diff,
          tech_nth:nth,
          tech_total:total,
          tech_res:res,
          tech_nth_v:nth_v,
        };
      } else {
        result = {
          error: "Please! Check Your Input."
        };
      }

      return result;
    }


     /** getCalculationDoubleAngleCalculator
   * POST: /api/calculators-lol/double-angle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationDoubleAngleCalculator(body) {
      let unit = body.tech_unit;
      let angle = body.tech_angle;

      let result = {};

      function sigFig(value, digits) {
        if (value === 0) {
          return 0;
        }
        const decimalPlaces = digits - Math.floor(Math.log10(Math.abs(value))) - 1;
        return +value.toFixed(decimalPlaces);
      }

      if (!isNaN(angle)) {
        angle = parseFloat(angle);
      } else if (typeof angle === 'string' && angle.includes('/')) {
        let parts = angle.split('/');
        if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
          angle = parseFloat(parts[0]) / parseFloat(parts[1]);
        } else {
          result.error = "Please! Check Your Input.";
          return result;
        }
      } else {
        result.error = "Please! Check Your Input.";
        return result;
      }

      let deg, red;
      let angle_ = angle;

      if (unit === '1') {
        deg = angle;
        red = angle * Math.PI / 180;
      } else if (unit === '2') {
        deg = +(angle * 180 / Math.PI).toFixed(2);
        red = angle;
      } else if (unit === '3') {
        deg = +(angle * 180).toFixed(2);
             result.tech_angle_ = angle_;
        red = (angle * 180) * Math.PI / 180;
      }

      let sin = 2 * (Math.sin(red).toFixed(5) * Math.cos(red).toFixed(5));
      let cos = 1 - 2 * Math.pow(Math.sin(red).toFixed(5), 2);

      let upper = 2 * Math.tan(red).toFixed(5);
      let bottom = 1 - Math.pow(Math.tan(red).toFixed(5), 2);

      let tan = 0;
      if (upper !== 0 && bottom !== 0) {
        tan = upper / bottom;
      }

      result.tech_sin = sigFig(sin, 6);
      result.tech_cos = sigFig(cos, 6);
      result.tech_tan = sigFig(tan, 6);
      result.tech_deg = deg;
      result.tech_red = red;
      result.tech_angle = angle;
      result.tech_unit = unit;

      return result;
    }


     /** getCalculationHalfAngleCalculator
   * POST: /api/calculators-lol/half-angle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

   async  getCalculationHalfAngleCalculator(body) {
      let cal = body.tech_cal;
      let angle = body.tech_angle;
      let angle_unit = body.tech_angle_unit;
      let func = body.tech_func;


    const result = {};

    // Helper functions
    function deg2rad(deg) {
        return deg * (Math.PI / 180);
    }

    function rad2deg(rad) {
        return rad * (180 / Math.PI);
    }

    function round(value, decimals) {
        return Number(Math.round(value + 'e' + decimals) + 'e-' + decimals);
    }

    function isNumeric(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }



    if (cal === 'angle') {
        if (isNumeric(angle) && angle_unit) {
            let angleInDeg;
            if (angle_unit === 'rad') {
                angleInDeg = rad2deg(angle);
                result.tech_angle_u = 'rad';
            } else if (angle_unit === 'pirad') {
                angleInDeg = rad2deg(angle * Math.PI);
                result.tech_angle_u = 'pirad';
            } else {
                angleInDeg = parseFloat(angle);
                result.tech_angle_u = 'deg';
            }

            const sinx = Math.sin(deg2rad(angleInDeg));
            const cosx = Math.cos(deg2rad(angleInDeg));
            const tanx = Math.tan(deg2rad(angleInDeg));
            const s1 = 1 - cosx;
            const s2 = s1 / 2;
            const c1 = 1 + cosx;
            const c2 = c1 / 2;
            const t1 = s1 / c1;
            const sinx2 = Math.sqrt(s2);
            const cosx2 = Math.sqrt(c2);
            const tanx2 = Math.sqrt(t1);

            result.tech_sinx = round(sinx, 4);
            result.tech_cosx = round(cosx, 4);
            result.tech_tanx = round(tanx, 4);
            result.tech_sinx2 = round(sinx2, 4);
            result.tech_cosx2 = round(cosx2, 4);
            result.tech_tanx2 = round(tanx2, 4);
            result.tech_s1 = round(s1, 4);
            result.tech_s2 = round(s2, 4);
            result.tech_c1 = round(c1, 4);
            result.tech_c2 = round(c2, 4);
            result.tech_t1 = round(t1, 4);
        } else {
            result.error = 'Please! Check Your Input.';
        }
    } else {
        if (isNumeric(func)) {
            let angleInDeg;
            if (cal === 'sinx') {
                angleInDeg = rad2deg(Math.asin(func));
            } else if (cal === 'cosx') {
                angleInDeg = rad2deg(Math.acos(func));
            } else if (cal === 'tanx') {
                angleInDeg = rad2deg(Math.atan(func));
            } else if (cal === 'sinx_2') {
                const sinx2 = parseFloat(func);
                const cosx = Math.abs(2 * Math.pow(sinx2, 2) - 1);
                angleInDeg = rad2deg(Math.acos(cosx));
            } else {
                // cosx_2
                const cosx2 = parseFloat(func);
                const cosx = 2 * Math.pow(cosx2, 2) - 1;
                angleInDeg = rad2deg(Math.acos(cosx));
            }

            const sinx = Math.sin(deg2rad(angleInDeg));
            const cosx = Math.cos(deg2rad(angleInDeg));
            const tanx = Math.tan(deg2rad(angleInDeg));
            const s1 = 1 - cosx;
            const s2 = s1 / 2;
            const c1 = 1 + cosx;
            const c2 = c1 / 2;
            const t1 = s1 / c1;
            const sinx2 = Math.sqrt(s2);
            const cosx2 = Math.sqrt(c2);
            const tanx2 = Math.sqrt(t1);
            const angle_rad = deg2rad(angleInDeg);
            const angle_pirad = angleInDeg * 0.005556;

            result.tech_angle_deg = round(angleInDeg, 4);
            result.tech_angle_rad = round(angle_rad, 4);
            result.tech_angle_pirad = round(angle_pirad, 4);
            result.tech_sinx = round(sinx, 4);
            result.tech_cosx = round(cosx, 4);
            result.tech_tanx = round(tanx, 4);
            result.tech_sinx2 = round(sinx2, 4);
            result.tech_cosx2 = round(cosx2, 4);
            result.tech_tanx2 = round(tanx2, 4);
            result.tech_s1 = round(s1, 4);
            result.tech_s2 = round(s2, 4);
            result.tech_c1 = round(c1, 4);
            result.tech_c2 = round(c2, 4);
            result.tech_t1 = round(t1, 4);
        } else {
            result.error = 'Please! Check Your Input.';
        }
    }

    return result;
};


     /** getCalculationPowerSetCalculator
   * POST: /api/calculators-lol/power-set-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationPowerSetCalculator(body) {
          let set = body.tech_set;

      let result = {};

      // Input validation
      if (/<|>|\&|\+|\-|\(|\)|\{|\}|\[|\]|\||php|print_r|print|echo|sin|cos|tan|arcsin|arccos|arctan|script|=|&|%/i.test(set)) {
        result.error = 'Please Enter Valid Input.';
        return result;
      }

      if (set && set.trim() !== "") {
        set = set.replace(/\s+/g, '').split(',');

        if (set.length >= 10) {
          result.error = 'Please Enter maximum 10 numbers.';
          return result;
        }

        // Powerset function
        function powerSet(array) {
          let results = [[]];
          array.forEach((value, key) => {
            results.forEach(subset => {
              results.push([...subset, value]);
            });
          });

          results.sort((a, b) => {
            if (a.length !== b.length) {
              return a.length - b.length;
            }
            return 0;
          });

          return results;
        }

        let size = set.length;
        let powset = powerSet(set);
        let count = powset.length;

        // Format powerset as string
        let powersetStr = powset
          .map(subset => `{${subset.join(',')}}`)
          .join(',');

        result.tech_size = size;
        result.tech_powerset = powersetStr;
        result.tech_subsets = count;
        result.tech_pro_subsets = count - 1;
        return result;
      } else {
        result.error = 'Please! Check Your Input.';
        return result;
      }
    }


     /** getCalculationVertexFormCalculator
   * POST: /api/calculators-lol/vertex-form-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async  getCalculationVertexFormCalculator(body) {
      let a1 = body.tech_a1;
      let b1 = body.tech_b1;
      let c1 = body.tech_c1;
      let a = body.tech_a;
      let b = body.tech_b;
      let c = body.tech_c;
      let submit = body.tech_type;


    let result = {};
    let A, B, C, variable_ans = "x", eq = "";

    if (submit === "standard") {
      if (!a1 || a1 == 0) {
        result.error = 'Enter a, In quadratic equation a is not equal 0';
        return result;
      }

      eq += `${a1}x^2`;

      if (b1 && b1 != 0) {
        eq += b1 > 0 ? ` + ${b1}x` : ` ${b1}x`;
      }

      if (c1 == null) c1 = 0;

      if (c1 && c1 != 0) {
        eq += c1 > 0 ? ` + ${c1}` : ` ${c1}`;
      }

      A = Number(a1);
      B = Number(b1) || 0;
      C = Number(c1) || 0;
    } else {
      if (c == null) c = 0;
      if (b == null) b = 0;

      if (!isNaN(a) && a !== "0" && !isNaN(b) && !isNaN(c)) {
        A = Number(a);
        C = (Math.pow(b, 2) * A) + Number(c);
        B = ((-1 * b) * 2) * A;
      } else {
        result.error = 'Please Check Your Input.';
        return result;
      }
    }

    let round3 = C.toString().includes('.') ? C.toString().split('.')[1].length : 0;
    let firstx = Number(((-1 * B) / (2 * A)).toFixed(3));
    let round1 = firstx.toString().includes('.') ? firstx.toString().split('.')[1].length : 0;

    let first_part = A * Math.pow(firstx, 2);
    let second_part = B * firstx;

    // Build evaluation string
    if (second_part < 0 && C < 0) {
      eq = `${first_part} ${second_part} ${C}`;
    } else if (second_part < 0 && C >= 0) {
      eq = `${first_part} ${second_part} + ${C}`;
    } else if (second_part >= 0 && C < 0) {
      eq = `${first_part} + ${second_part} ${C}`;
    } else {
      eq = `${first_part} + ${second_part} + ${C}`;
    }

    let yaxis;
    try {
      yaxis = eval(eq); // Safe in this controlled context
    } catch (e) {
      result.error = 'Evaluation Error';
      return result;
    }

    yaxis = Number(yaxis.toFixed(3));
    let round2 = yaxis.toString().includes('.') ? yaxis.toString().split('.')[1].length : 0;

    let vertexStr = `${A}(${variable_ans} ${firstx < 0 ? "+ " + (-firstx) : "- " + firstx})^2 ${yaxis < 0 ? "- " + (-yaxis) : "+ " + yaxis}`;

    result.tech_vertex = vertexStr;
    result.tech_A = A;
    result.tech_B = B;
    result.tech_C = C;
    result.tech_firstx = firstx;
    result.tech_yaxis = yaxis;
    result.tech_round1 = round1;
    result.tech_round2 = round2;
    result.tech_round3 = round3;
    result.tech_variable_ans = variable_ans;
    result.tech_submit = submit;

    return result;
  }


     /** getCalculationSubsetCalculator
   * POST: /api/calculators-lol/subset-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async  getCalculationSubsetCalculator(body) {

        let cal_by = body.tech_cal_by;
        let set = body.tech_set;
        let cardinal = body.tech_cardinal;

    let result = {};
    let check = false;
    let size, count, ne = [];

    // Validation regex
    const invalidPattern = /<|>|\&|\+|\-|\(|\)|\{|\}|\[|\]|\||php|print_r|print|echo|sin|cos|tan|arcsin|arccos|arctan|script|=|&|%/i;

    if (cal_by === 'elements') {
      if (!set || invalidPattern.test(set)) {
        result.error = 'Please Enter Valid Input.';
        return result;
      }

      check = true;
      set = set.replace(/\s/g, '').split(',');

      if (set.length > 10) {
        result.error = 'Number of Elements must be less than or equal to 10.';
        return result;
      }

      // Generate powerset
      function powerSet(array) {
        let results = [[]];
        for (let value of array) {
          let temp = [];
          for (let subset of results) {
            temp.push([...subset, value]);
          }
          results = results.concat(temp);
        }

        results.sort((a, b) => a.length - b.length);
        return results;
      }

      size = set.length;
      const powset = powerSet(set);
      count = powset.length;

      let arr = powset.map(sub => `{${sub.join(',')}}`).join(',');
      result.tech_pw = arr;

    } else if (cal_by === 'cardinality') {
      if (!isNaN(cardinal)) {
        check = true;
        if (cardinal > 100) {
          result.error = 'Elements must be less than or equal to 100.';
          return result;
        }

        size = Number(cardinal);
        count = Math.pow(2, size);
      } else {
        result.error = 'Please! Check Your Input.';
        return result;
      }
    }

    if (check) {
      function factorial(n) {
        let result = 1;
        for (let i = 2; i <= n; i++) {
          result *= i;
        }
        return result;
      }

      let size1 = size;
      for (let i = 0; i <= size; i++) {
        let value = factorial(size) / (factorial(i) * factorial(size1));
        ne.push(value);
        size1--;
      }

      result.tech_subsets = count;
      result.tech_pro_subsets = count - 1;
      result.tech_ne = ne;
      return result;
    } else {
      result.error = 'Please! Check Your Input.';
      return result;
    }
  }

     /** getCalculationHyperbolaCalculator
   * POST: /api/calculators-lol/hyperbola-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationHyperbolaCalculator(body) {
            let x = body.tech_x;
            let y = body.tech_y;
            let a = body.tech_a;
            let b = body.tech_b;

      let result = {};

      if (
        !isNaN(x) &&
        !isNaN(y) &&
        !isNaN(a) &&
        !isNaN(b)
      ) {
        x = Number(x);
        y = Number(y);
        a = Number(a);
        b = Number(b);

        // Perfect square check
        function isPerfectSquare(n) {
          let sqrt = Math.sqrt(n);
          if (Number.isInteger(sqrt)) {
            return sqrt;
          } else {
            return `\\sqrt{${n}}`;
          }
        }

        let c1 = x;
        let c2 = y;
        let as = Math.sqrt(a);
        let bs = Math.sqrt(b);

        let v1 = `${(c1 - as).toFixed(5)} , ${c2}`;
        let v2 = `${(c1 + as).toFixed(5)} , ${c2}`;
        let v21 = +(c2 - bs).toFixed(5);
        let v22 = +(c2 + bs).toFixed(5);

        let c = Math.sqrt(a + b);
        let f1 = `${(c1 - c).toFixed(5)} , ${c2}`;
        let f2 = `${(c1 + c).toFixed(5)} , ${c2}`;
        let ecc = +(c / as).toFixed(5);
        let fp = +(b / c).toFixed(5);

        let dir1 = +(c1 - ((a * c) / (a + b))).toFixed(5);
        let dir2 = +(c1 + ((a * c) / (a + b))).toFixed(5);
        let fl1 = +(c1 - c).toFixed(5);
        let fl2 = +(c1 + c).toFixed(5);

        let ashow = isPerfectSquare(a);
        let bshow = isPerfectSquare(b);
        let cshow = isPerfectSquare(a + b);

        result = {
          tech_as:as,
          tech_bs:bs,
          tech_v1:v1,
          tech_v2:v2,
          tech_v21:v21,
          tech_v22:v22,
          tech_f1:f1,
          tech_f2:f2,
          tech_ecc:ecc,
          tech_fp:fp,
          tech_dir1:dir1,
          tech_dir2:dir2,
          tech_fl1:fl1,
          tech_fl2:fl2,
          tech_c:c,
          tech_ashow:ashow,
          tech_bshow:bshow,
          tech_cshow:cshow,
        };
      } else {
        result.error = 'Please! Check Your Input.';
      }

      return result;
    }


     /** getCalculationGradientCalculator
   * POST: /api/calculators-lol/hyperbola-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */


async  getCalculationGradientCalculator(body) {
           let EnterEq = body.tech_EnterEq;
           let x = body.tech_x;
            let y = body.tech_y;
            let z = body.tech_z;
            let type = body.tech_type;


  let result = {};

  const invalidPattern = /<|>|\&|php|print_r|print|echo|script|=|&|%/i;

  if (!EnterEq || invalidPattern.test(EnterEq)) {
    return { error: "Please! Check Your Input." };
  }

  if (type === "two") {
    if (isNaN(x) || isNaN(y)) {
      return { error: "Please! Check Your Input." };
    }
  } else if (type === "three") {
    if (isNaN(x) || isNaN(y) || isNaN(z)) {
      return { error: "Please! Check Your Input." };
    }
  } else {
    return { error: "Please! Check Your Input." };
  }

  // Prepare and sanitize expression
  let expr = EnterEq
    .replace(/\s+|%20/g, "")
    .replace(/\+/g, "plus")
    .replace(/[{}]/g, "(")
    .replace(/}/g, ")")
    .replace(/e\^x/g, "exp(x)")
    .replace(/e\^y/g, "exp(y)")
    .replace(/e\^z/g, "exp(z)")
    .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
    .replace(/exp\^/g, "exp")
    .replace(/\^/g, "**");

  try {
    const params = { eq: expr, x, y, type };
    if (type === "three") params.z = z;

    const r = await axios.get("http://167.172.134.148/gradient", { params });
    const buf = r.data.split("@@@");

    if (type === "two") {
      const [difs1, difs2, x1, y1, enter, steps, steps1] = buf;
      Object.assign(result, {
        tech_difs1:difs1,
        tech_difs2:difs2,
        tech_x1: +parseFloat(x1).toFixed(5),
        tech_y1: +parseFloat(y1).toFixed(5),
        tech_enter:enter,
        tech_steps:steps,
        tech_steps1:steps1,
      });
    } else {
      const [difs1, difs2, difs3, x1, y1, z1, enter, steps, steps1, steps2] = buf;
      Object.assign(result, {
        tech_difs1:difs1,
        tech_difs2:difs2,
        tech_difs3:difs3,
        tech_x1: +parseFloat(x1).toFixed(5),
        tech_y1: +parseFloat(y1).toFixed(5),
        tech_z1: +parseFloat(z1).toFixed(5),
        tech_enter:enter,
        tech_steps:steps,
        tech_steps1:steps1,
        tech_steps2:steps2,
      });
    }

    return result;
  } catch (e) {
    return { error: "Please! Check Your Input." };
  }
}

     /** getCalculationMidpointRuleCalculator
   * POST: /api/calculators-lol/midpoint-rule-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationMidpointRuleCalculator(body) {
    
          let EnterEq = body.tech_EnterEq;
      let lb = body.tech_lb;
      let ub = body.tech_ub;
      let n = body.tech_n;
      let withVal = body.tech_with;


      let result = {};

      const invalidPattern = /<|>|\&|php|print_r|print|echo|script|=|&|%/i;

      if (!EnterEq || invalidPattern.test(EnterEq)) {
        return { error: "Please! Check Your Input." };
      }

      if (isNaN(lb) || isNaN(ub) || isNaN(n) || lb >= ub) {
        return {
          error: lb >= ub
            ? "The lower limit should be less than the upper limit."
            : "Please! Check Your Input.",
        };
      }

      let expr = EnterEq
        .replace(/\s+/g, '')
        .replace(/\+/g, 'plus')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/e\^sqrt\(x\)/g, 'exp(2*x)')
        .replace(/e\^/g, 'exp')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**');

      let diff = (ub - lb) / n;
      let final = parseFloat(lb);
      let limit_a = [final];
      let limit = `${final}`;

      while (final < ub) {
        final += diff;
        limit_a.push(final);
        limit += `, ${final}`;
      }

      try {
        const postData = qs.stringify({
          equ: expr,
          with: withVal,
          ub,
          lb,
          n,
          type: 3,
          diff,
        });

        const response = await axios.post(
          "http://167.172.134.148/new-riemann",
          postData,
          {
            headers: {
              "Content-Type": "application/x-www-form-urlencoded",
            },
            timeout: 120000,
          }
        );

        const buffer = response.data;
        const steps = buffer[0].split("HA");

        Object.assign(result, {
          tech_steps:steps,
          tech_res: buffer[1],
          tech_enter: buffer[2],
          tech_ub:ub,
          tech_lb:lb,
          tech_n:n,
          tech_diff:diff,
          tech_limit:limit,
          tech_limit_a:limit_a,
          tech_with: withVal,
        });

        return result;
      } catch (err) {
        console.error("Error during request:", err.message);
        return { error: "Please! Check Your Input.", detail: err.message };
      }
   }

     /** getCalculationMaclaurinSeriesCalculator
   * POST: /api/calculators-lol/maclaurin-series-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationMaclaurinSeriesCalculator(body) {

          let EnterEq = body.tech_EnterEq;
          let find = body.tech_find;
          let n = body.tech_n;
          let withVal = body.tech_with;


      let point = 0;
      let result = {};

      const invalidPattern = /<|>|\&|php|print_r|print|echo|script|=|&|%/i;

      if (!EnterEq || invalidPattern.test(EnterEq)) {
        return { error: "Please! Check Your Input." };
      }

      if (isNaN(n)) {
        return { error: "Please! Check Your Input." };
      }

      if (find == null) {
        find = "";
      }

      let expr = EnterEq
        .replace(/\s+/g, '')
        .replace(/\+/g, 'plus')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/e\^sqrt\(x\)/g, 'exp(2*x)')
        .replace(/e\^x/g, 'exp(x)')
        .replace(/e\^y/g, 'exp(y)')
        .replace(/e\^/g, 'exp')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**');

      try {
        const response = await axios.get('http://167.172.134.148/taylor', {
          params: {
            equ: expr,
            wrt: withVal,
            how: n,
            find: find,
            point: point
          },
          timeout: 120000
        });

        const buffer = response.data.split('@HA_');

        result.tech_eexe = buffer[0];
        result.tech_enter = buffer[1];
        result.tech_res = buffer[2];
        result.tech_series = buffer[3];

        if (!isNaN(find)) {
          result.tech_efun = buffer[4];
          result.tech_eser = buffer[5];
          result.tech_efv = buffer[6];
          result.tech_fsv = buffer[7];
          result.tech_err = buffer[8];
        }

        return result;
      } catch (err) {
        console.error("Request error:", err.message);
        return { error: "Please! Check Your Input." };
      }
    }



     /** getCalculationDifferenceQuotientCalculator
   * POST: /api/calculators-lol/difference-quotient-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationDifferenceQuotientCalculator(body) {

        let EnterEq = body.tech_EnterEq;
      let result = {};

      const invalidPattern = /<|>|\&|php|print_r|print|echo|script|=|%/i;
      if (!EnterEq || invalidPattern.test(EnterEq)) {
        return { error: "Please! Check Your Input." };
      }

      let parem = EnterEq.toLowerCase();

      // Clean and sanitize the input
      parem = parem.replace(/f\^-1\(x\)=?|f\(x\)=|y=|h\(x\)=|f-1\(2\)=|y=f\(x\)=|=y|∣|%20|\||f\s*\(\s*x\s*\)\s*=|=|f\(x\)|fx=|fx/g, '');

      // parem = parem.replace(/f\^-1\(x\)|f\(x\)=|y=|h\(x\)=|f-1\(2\)=|y=f\(x\)=|=y|∣|f\^-1\(x\)=|%20|\||f \( x \ ) =|=|f\(x\)|fx=|fx/g, '');

      const variableMatches = parem.match(/[a-zA-Z]+/g) || [];
      const filteredVars = variableMatches.filter(v => !['log', 'sin', 'cos', 'tan', 'exp', 'sqrt', 'e', 'arctan'].includes(v));
      const uniqueVars = [...new Set(filteredVars)];

      if (uniqueVars.length > 1) {
        return { error: "More than one variable found in the equation" };
      } else if (uniqueVars.length === 0) {
        return { error: "No variable found in the equation." };
      }

      const withVal = uniqueVars[0];

      // Additional formatting
      parem = parem
        .replace(/sqrt\(/gi, 'sqrt(')
        .replace(/arctan\(/gi, 'atan(')
        .replace(/e\^([a-z0-9\(\)\*\+]+)/gi, 'zain($1)')
        .replace(/\^/g, '**')
        .replace(/−/g, '-')
        .replace(/{/g, '(').replace(/}/g, ')')
        .replace(/\[/g, '(').replace(/\]/g, ')')
        .replace(/(\d)([a-z\(])/gi, '$1*$2');

      // f(x + h)
      let parem1 = parem.replace(new RegExp(withVal, 'g'), `(${withVal} + h)`);
      parem1 = parem1
        .replace(/sqrt\(/gi, 'sqrt(')
        .replace(/arctan\(/gi, 'atan(');

      let final = `((${parem1}) - (${parem}))/h`;

      try {
        const response = await axios.get('http://167.172.134.148/difference', {
          params: {
            equ: parem,
            wrt: withVal,
            equ1: parem1,
            final: final
          },
          timeout: 120000
        });

        const buffer = response.data.split('@@@');

        result.tech_with = withVal;
        result.tech_enter = buffer[0];
        result.tech_equ1 = buffer[1];
        result.tech_final = buffer[2];
        result.tech_res = buffer[3];

        return result;
      } catch (err) {
        console.error("Error:", err.message);
        return { error: "Please! Check Your Input." };
      }
    }


     /** getCalculationComplexNumberCalculator
   * POST: /api/calculators-lol/complex-number-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */


async  getCalculationComplexNumberCalculator(body) {
    let exp = body.tech_exp;
  let result = {};

  const invalidPattern = /<|>|&|php|print_r|print|echo|script|=|sin|cos|tan|arcsin|arccos|arctan|%/i;

  // Validation
  if (!exp || invalidPattern.test(exp)) {
    return { error: "Please Enter Valid Input." };
  }

  // Expression cleanup
  let parem = exp;
  parem = parem.replace(/\s+/g, '');
  parem = parem.replace(/%20/g, '');
  parem = parem.replace(/\+/g, 'plus');
  parem = parem.replace(/{/g, '(');
  parem = parem.replace(/}/g, ')');
  parem = parem.replace(/e\^sqrt\(x\)/g, 'exp(2*x)');
  parem = parem.replace(/e\^/g, 'exp');
  parem = parem.replace(/exp\^/g, 'exp');
  parem = parem.replace(/\^/g, '**');

  try {
    const response = await axios.get("http://167.172.134.148/complex_num", {
      params: {
        equ: parem,
      },
      timeout: 120000,
    });

    const buffer = response.data.split("@@@");

    result.tech_enter = buffer[0];
    result.tech_expand = buffer[1];
    result.tech_expand1 = buffer[2];
    result.tech_a = buffer[3];
    result.tech_b = buffer[4];
    result.tech_b1 = buffer[5];
    result.tech_r = buffer[6];
    result.tech_theta = buffer[7];
    result.tech_simp = buffer[8];

    return result;
  } catch (err) {
    return { error: "Please! Check Your Input." };
  }
}

     /** getCalculationWronskianCalculator
   * POST: /api/calculators-lol/wronskian-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async  getCalculationWronskianCalculator(body) {

      let EnterEq = body.tech_EnterEq;
      let wrt = body.tech_with;

    let result = {};

    const invalidPattern = /<|>|&|php|print_r|print|echo|script|=|%/i;

    if (!EnterEq || !wrt || invalidPattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    let parem = EnterEq;
    parem = parem.replace(/\s+/g, '');
    parem = parem.replace(/\+/g, 'plus');
    parem = parem.replace(/{/g, '(');
    parem = parem.replace(/}/g, ')');
    parem = parem.replace(/e\^sqrt\(x\)/g, 'exp(2*x)');
    parem = parem.replace(/e\^x/g, 'exp(x)');
    parem = parem.replace(/e\^y/g, 'exp(y)');
    parem = parem.replace(/e\^/g, 'exp');
    parem = parem.replace(/exp\^/g, 'exp');
    parem = parem.replace(/\^/g, '**');

    const funcCount = parem.split(',').length;

    if (funcCount < 2 || funcCount > 5) {
      return { error: 'The number of functions cannot be less than 2 or greater than 5.' };
    }

    try {
      const response = await axios.get("http://167.172.134.148/wronskian", {
        params: {
          equ: parem,
          wrt: wrt
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      result.tech_enter = buffer[0];
      result.tech_matrix = buffer[1];
      result.tech_res = buffer[2];

      return result;

    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }


     /** getCalculationInverseLaplaceTransformCalculator
   * POST: /api/calculators-lol/inverse-laplace-transform-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationInverseLaplaceTransformCalculator(body) {
      let EnterEq = body.tech_EnterEq;

      let result = {};
      const invalidPattern = /<|>|php|print_r|print|echo|script|=|%|&/i;

      if (!EnterEq || invalidPattern.test(EnterEq)) {
        return { error: "Please! Check Your Input." };
      }

      let parem = EnterEq;
      parem = parem.replace(/\s+/g, '');
      parem = parem.replace(/\+/g, 'plus');
      parem = parem.replace(/%20/g, '');
      parem = parem.replace(/{/g, '(');
      parem = parem.replace(/}/g, ')');
      parem = parem.replace(/e\^s/g, 'exp(s)');
      parem = parem.replace(/e\^sqrt\(x\)/g, 'exp(2*x)');
      parem = parem.replace(/e\^/g, 'exp');
      parem = parem.replace(/exp\^/g, 'exp');
      parem = parem.replace(/\^/g, '**');

      try {
        const response = await axios.get("http://167.172.134.148/inverse_lap", {
          params: {
            equ: parem
          },
          timeout: 120000
        });

        const buffer = response.data.split("@@@");

        result.tech_ans = buffer[0];
        result.tech_enter = buffer[1];

        return result;

      } catch (err) {
        return { error: "Please! Check Your Input." };
      }
    }

     /** getCalculationInverseLaplaceTransformCalculator
   * POST: /api/calculators-lol/summation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationSummationCalculator(body) {
      let cal_meth = body.tech_cal_meth;
      let nums = body.tech_nums;
      let eq = body.tech_eq;
      let x = body.tech_x;
      let n = body.tech_n;

      let result = {};
      const invalidPattern = /<|>|\&|\+|\-|\(|\)|\{|\}|\[|\]|\||php|print_r|print|echo|script|=|%|sin|cos|tan|arcsin|arccos|arctan/i;

      if (
        (nums && invalidPattern.test(nums)) ||
        (eq && invalidPattern.test(eq)) ||
        (x && invalidPattern.test(x)) ||
        (n && invalidPattern.test(n))
      ) {
        return { error: 'Please! Enter Valid Input.' };
      }

      if (cal_meth === 'simple_sum') {
        if (nums) {
          nums = nums.replace(/\s+/g, '');
          let numArr = nums.split(',').map(Number);
          let sum = numArr.reduce((acc, val) => acc + val, 0);
          let tn = numArr.length;

          result.tech_sum = sum;
          result.tech_tn = tn;
          return result;
        } else {
          return { error: 'Please! Check Your Input.' };
        }

      } else if (cal_meth === 'sigma_sum') {
        if (!eq || !x || !n) {
          return { error: 'Please! Check Your Input.' };
        }

        let parem = eq;
        parem = parem.replace(/\s+/g, '');
        parem = parem.replace(/%20/g, '');
        parem = parem.replace(/\+/g, 'plus');
        parem = parem.replace(/{/g, '(');
        parem = parem.replace(/}/g, ')');
        parem = parem.replace(/e\^sqrt\(x\)/g, 'exp(2*x)');
        parem = parem.replace(/e\^/g, 'exp');
        parem = parem.replace(/exp\^/g, 'exp');
        parem = parem.replace(/\^/g, '**');

        try {
          const response = await axios.get("http://167.172.134.148/summation", {
            params: {
              equ: parem,
              x: x,
              n: n
            },
            timeout: 120000
          });

          const buffer = response.data.split("@@@");

          if (buffer[0] === 'False') {
            result.tech_cnvrgnt = buffer[0];
            result.tech_enter = buffer[1];
          } else {
            result.tech_cnvrgnt = buffer[0];
            result.tech_enter = buffer[1];
            result.tech_sum = buffer[2];

            let solve = buffer[3].split("###");
            solve.pop();
            result.tech_solve = solve;
            result.tech_tn = solve.length;

            let i_n = buffer[4].split("###");
            i_n.pop();
            result.tech_i_n = i_n;
          }

          return result;

        } catch (err) {
          return { error: 'Please! Check Your Input.' };
        }
      } else {
        return { error: 'Invalid calculation method.' };
      }
    }

     /** getCalculationPolarCoordinatesCalculator
   * POST: /api/calculators-lol/polar-coordinates-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationPolarCoordinatesCalculator(body) {
      let x = body.tech_x1;
      let y = body.tech_x2;
      let chose = body.tech_chose;

      let result = {};

      if (x === undefined || y === undefined || x === '' || y === '') {
        return { error: "Please Check Your Input." };
      }

      try {
        const response = await axios.get('http://167.172.134.148/polar', {
          params: {
            x: x,
            y: y
          },
          timeout: 120000
        });

        const buffer = response.data.split("@@@");

        let angle = parseFloat(buffer[0]);
        let magnitude = parseFloat(buffer[4]);
        let atn = angle / magnitude;

        let one = Math.atan(atn);
        let two = one + Math.PI;

        let x1 = magnitude * Math.cos(angle);
        let y1 = magnitude * Math.sin(angle);

        result.tech_mag = buffer[1];
        result.tech_ex = buffer[2];
        result.tech_ey = buffer[3];
        result.tech_one = one;
        result.tech_x1 = x1;
        result.tech_y1 = y1;
        result.tech_chose = chose;
        result.tech_x = magnitude;
        result.tech_y = angle;
        result.tech_two = two;

        return result;

      } catch (err) {
        return { error: "Please! Check Your Input." };
      }
    }

     /** getCalculationConvolutionCalculator
   * POST: /api/calculators-lol/convolution-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationConvolutionCalculator(body) {
      let seq1 = body.tech_seq1;
      let seq2 = body.tech_seq2;

      if (!seq1 || !seq2) {
        return { error: "Please! Check Your Input." };
      }

      let set1 = seq1.split(',').map(s => s.trim()).filter(Boolean);
      let set2 = seq2.split(',').map(s => s.trim()).filter(Boolean);

      let isValid = set1.every(n => !isNaN(n)) && set2.every(n => !isNaN(n));

      if (!isValid) {
        return { error: "Please! Check Your Input." };
      }

      try {
        const response = await axios.get('http://167.172.134.148/convolution', {
          params: {
            seq1: seq1,
            seq2: seq2
          },
          timeout: 120000
        });

        const buffer = response.data;
        let conv = buffer.split('###');
        conv.pop(); // Remove last empty element

        return {
          tech_conv: conv,
        };

      } catch (err) {
        return { error: "Please! Check Your Input." };
      }
    }


        /** getCalculationConvolutionCalculator
   * POST: /api/calculators-lol/convolution-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationJacobianCalculator(body) {
      let xu = body.tech_xu;
      let xu_var = body.tech_xu_var;
      let yv = body.tech_yv;
      let yv_var = body.tech_yv_var;
      let zw = body.tech_zw;
      let zw_var = body.tech_zw_var;
      let submit = body.tech_type;

      // Input security check
      const invalidPattern = /<|>|\&|php|print_r|print|echo|script|=|&|%/i;
      if (invalidPattern.test(xu) || invalidPattern.test(yv) || invalidPattern.test(zw)) {
        return { error: 'Please Enter Valid Input.' };
      }

      if (!xu || !yv) {
        return { error: 'Please Check Your Input.' };
      }

      // Cleaning helper
      const clean = str =>
        str
          .replace(/ /g, '')
          .replace(/%20/g, '')
          .replace(/\+/g, 'plus')
          .replace(/{/g, '(')
          .replace(/}/g, ')')
          .replace(/e\^sqrt\(x\)/g, 'exp(2*x)')
          .replace(/e\^/g, 'exp')
          .replace(/exp\^/g, 'exp')
          .replace(/\^/g, '**');

      let parem = clean(xu);
      let parem1 = clean(yv);
      let parem2 = zw ? clean(zw) : null;

      try {
        let apiURL = 'http://167.172.134.148/jacobian';
        let params = {
          equ: parem,
          equ1: parem1,
          var: xu_var,
          var1: yv_var,
          check: submit,
        };

        if (submit === 'three' && parem2) {
          params.equ2 = parem2;
          params.var2 = zw_var;
        }

        const response = await axios.get(apiURL, {
          params,
          timeout: 120000,
        });

        const buffer = response.data.split('@@@');

        if (submit === 'three') {
          return {
            tech_enter: buffer[0],
            tech_enter1: buffer[1],
            tech_enter2: buffer[2],
            tech_jacob: buffer[3],
            tech_dtrmnt: buffer[4],
            tech_var: buffer[5],
            tech_var1: buffer[6],
            tech_var2: buffer[7],
            tech_check: submit,
          };
        } else {
          return {
            tech_enter: buffer[0],
            tech_enter1: buffer[1],
            tech_jacob: buffer[2],
            tech_dtrmnt: buffer[3],
            tech_var: buffer[4],
            tech_var1: buffer[5],
            tech_check: submit,
          };
        }
      } catch (err) {
        return { error: 'Please! Check Your Input.' };
      }
    }

        /** getCalculationWasherMethodCalculator
   * POST: /api/calculators-lol/convolution-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationWasherMethodCalculator(body) {
      let EnterEq = body.tech_EnterEq;
      let EnterEq1 = body.tech_EnterEq1;
      let ub = body.tech_ub;
      let lb = body.tech_lb;

      // Validation: Check required fields and prevent script injection
      const invalidPattern = /<|>|\&|php|print_r|print|echo|script|=|%/i;
      if (
        !EnterEq || !EnterEq1 ||
        invalidPattern.test(EnterEq) || invalidPattern.test(EnterEq1)
      ) {
        return { error: 'Please! Check Your Input.' };
      }

      if (!isFinite(ub) || !isFinite(lb)) {
        return { error: 'Please! Check Your Input.' };
      }

      // Function to clean expression
      const clean = str =>
        str
          .replace(/ /g, '')
          .replace(/\+/g, 'plus')
          .replace(/%20/g, '')
          .replace(/{/g, '(')
          .replace(/}/g, ')')
          .replace(/e\^sqrt\(x\)/g, 'exp(2*x)')
          .replace(/e\^x/g, 'exp(x)')
          .replace(/e\^/g, 'exp')
          .replace(/exp\^/g, 'exp')
          .replace(/\^/g, '**');

      let parem = clean(EnterEq);
      let parem1 = clean(EnterEq1);

      // Construct washer formula: (f(x))^2 - (g(x))^2
      let equ = `(${parem})**2-(${parem1})**2`;

      try {
        const response = await axios.get('http://167.172.134.148/washer', {
          params: {
            equ: equ,
            ub: ub,
            lb: lb,
          },
          timeout: 120000,
        });

        const buffer = response.data.split('@@@');

        return {
          tech_step: buffer[0],
          tech_res: buffer[1],
          tech_enter: buffer[2],
          tech_ress: buffer[3],
          tech_ress1: buffer[4],
        };
      } catch (err) {
        return { error: 'Please! Check Your Input.' };
      }
    }

     /** getCalculationShellMethodCalculator
   * POST: /api/calculators-lol/shell-method-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationShellMethodCalculator(body) {
      let EnterEq = body.tech_EnterEq;
      let ub = body.tech_ub;
      let lb = body.tech_lb;
      let withVar = body.tech_with;

      const invalidPattern = /<|>|\&|php|print_r|print|echo|script|=|%/i;
      if (!EnterEq || invalidPattern.test(EnterEq)) {
        return { error: 'Please! Check Your Input.' };
      }

      if (!isFinite(ub) || !isFinite(lb)) {
        return { error: 'Please! Check Your Input.' };
      }

      // Expression formatting
      const clean = str =>
        str
          .replace(/ /g, '')
          .replace(/\+/g, 'plus')
          .replace(/%20/g, '')
          .replace(/{/g, '(')
          .replace(/}/g, ')')
          .replace(/e\^sqrt\(x\)/g, 'exp(2*x)')
          .replace(/e\^x/g, 'exp(x)')
          .replace(/e\^/g, 'exp')
          .replace(/exp\^/g, 'exp')
          .replace(/\^/g, '**');

      let parem = clean(EnterEq);
      withVar = withVar?.trim() || '';

      let equ = `2*pi*${withVar}(${parem})`;

      try {
        const response = await axios.get('http://167.172.134.148/shell', {
          params: {
            equ: equ,
            ub: ub,
            lb: lb,
            with: withVar,
          },
          timeout: 120000,
        });

        const buffer = response.data.split('@@@');

        return {
          tech_step: buffer[0],
          tech_res: buffer[1],
          tech_enter: buffer[2],
          tech_ress: buffer[3],
          tech_ress1: buffer[4],
        };
      } catch (err) {
        return { error: 'Please! Check Your Input.' };
      }
    }


     /** getCalculationImplicitDifferentiationCalculator
   * POST: /api/calculators-lol/implicit-differentiation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationImplicitDifferentiationCalculator(body) {
      let EnterEq = body.tech_EnterEq;
      let EnterEq1 = body.tech_EnterEq1;
      let x = body.tech_x;
      let y = body.tech_y;
      let withVar = body.tech_with;

      const invalidPattern = /<|>|\&|php|print_r|print|echo|script|=|%/i;

      if (!EnterEq || !EnterEq1 || invalidPattern.test(EnterEq) || invalidPattern.test(EnterEq1)) {
        return { error: 'Please! Check Your Input.' };
      }

      if (!withVar) {
        return { error: 'Please! Check Your Input.' };
      }

      const clean = str =>
        str
          .replace(/ /g, '')
          .replace(/\+/g, 'plus')
          .replace(/%20/g, '')
          .replace(/{/g, '(')
          .replace(/}/g, ')')
          .replace(/e\^sqrt\(x\)/g, 'exp(2*x)')
          .replace(/e\^x/g, 'exp(x)')
          .replace(/e\^/g, 'exp')
          .replace(/exp\^/g, 'exp')
          .replace(/\^/g, '**');

      let parem = clean(EnterEq);
      let parem1 = clean(EnterEq1);
      let equ = `(${parem})-(${parem1})`;

      let params = {
        equ: parem,
        equ1: parem1,
        with: withVar,
        main: equ
      };

      if (!isNaN(x) && !isNaN(y)) {
        params.x = x;
        params.y = y;
      }

      try {
        const response = await axios.get('http://167.172.134.148/implicit', {
          params: params,
          timeout: 120000,
        });

        const buffer = response.data.split('@@@');

        let result = {
          tech_res: buffer[0],
          tech_enter: buffer[1],
          tech_enter1: buffer[2],
        };

        if (!isNaN(x) && !isNaN(y)) {
          result.tech_resf = buffer[3];
        }

        return result;
      } catch (err) {
        return { error: 'Please! Check Your Input.' };
      }
    }


     /** getCalculationCriticalPointCalculator
   * POST: /api/calculators-lol/critical-points-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationCriticalPointCalculator(body) {
      let EnterEq = body.tech_EnterEq;

      const invalidPattern = /<|>|\&|php|print_r|print|echo|script|=|%/i;
      if (!EnterEq || invalidPattern.test(EnterEq)) {
        return { error: 'Please Enter Valid Input.' };
      }

      const clean = str =>
        str
          .replace(/ /g, '')
          .replace(/\+/g, 'plus')
          .replace(/{/g, '(')
          .replace(/}/g, ')')
          .replace(/e\^sqrt\(x\)/g, 'exp(2*x)')
          .replace(/e\^x/g, 'exp(x)')
          .replace(/exp\^/g, 'exp')
          .replace(/e\^/g, 'exp')
          .replace(/\^/g, '**');

      let parem = clean(EnterEq);
      let wrt = /x/i.test(parem) && /y/i.test(parem) ? "xy" : "x";

      try {
        const response = await axios.get('http://167.172.134.148/critical', {
          params: {
            equ: parem,
            wrt: wrt
          },
          timeout: 120000,
        });

        const buffer = response.data.split("@@@");

        if (buffer[4] === '\\left[ \\right]') {
          return { error: 'No solution exists' };
        }

        let result = {
          tech_buffer: buffer[0],
          tech_ans: buffer[1],
          tech_enter: buffer[2],
          tech_simple: buffer[3],
          tech_root: buffer[4],
        };

        if (wrt === "xy") {
          result.tech_step = buffer[5];
          result.tech_ans1 = buffer[6];
          result.tech_wrt = "xy";
        } else {
          result.tech_mini = buffer[5];
          result.tech_maxi = buffer[6];
        }

        return result;

      } catch (err) {
        return { error: 'Please! Check Your Input.' };
      }
    }


     /** getCalculationPartialDerivativeCalculator
   * POST: /api/calculators-lol/partial-derivative-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationPartialDerivativeCalculator(body) {
      let EnterEq = body.tech_EnterEq;
      let withRespectTo = body.tech_with;
      let how = body.tech_how;

      const invalidPattern = /<|>|&|php|print_r|print|echo|script|=|%/i;
      if (!EnterEq || invalidPattern.test(EnterEq)) {
        return { error: 'Please! Check Your Input.' };
      }

      // Clean up the input expression
      let parem = EnterEq
        .replace(/ /g, '')
        .replace(/\+/g, 'plus')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/e\^sqrt\(x\)/g, 'exp(2*x)')
        .replace(/e\^x/g, 'exp(x)')
        .replace(/e\^y/g, 'exp(y)')
        .replace(/e\^/g, 'exp')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**');

      let wrt = (withRespectTo || "").trim();
      let howOrder = how;

      try {
        const response = await axios.get('http://167.172.134.148/derivative', {
          params: {
            equ: parem,
            wrt: wrt,
            how: howOrder
          },
          timeout: 120000
        });

        const buffer = response.data.split("@@@");

        if (howOrder > 1) {
          return {
            tech_enter: buffer[0],
            tech_final_res: buffer,
          };
        } else {
          return {
            tech_buffer: buffer[0],
            tech_ans: buffer[1],
            tech_enter: buffer[2],
            tech_simple: buffer[3],
          };
        }

      } catch (err) {
        return { error: 'Please! Check Your Input.' };
      }
    }

     /** getCalculationAbsoluteValueCalculator
   * POST: /api/calculators-lol/absolute-value-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationAbsoluteValueCalculator(body) {
      let eq = body.tech_eq;
      let n = body.tech_n;
      let n1 = body.tech_n1;
      let variable = body.tech_var;
      let type = body.tech_type;

      const invalidPattern = /<|>|&|php|print_r|print|echo|script|=|%/i;

      if (type === 'm1' && !isNaN(n)) {
        return {
          tech_res: Math.abs(Number(n)),
        };
      } else if (type === 'm2' && eq && n1) {
        if (invalidPattern.test(eq)) {
          return { error: 'Please Enter Valid Input.' };
        }

        const cleanExpression = (str) => {
          return str
            .replace(/ /g, '')
            .replace(/%20/g, '')
            .replace(/\+/g, 'plus')
            .replace(/{/g, '(')
            .replace(/}/g, ')')
            .replace(/e\^sqrt\(x\)/g, 'exp(2*x)')
            .replace(/e\^/g, 'exp')
            .replace(/exp\^/g, 'exp')
            .replace(/\^/g, '**');
        };

        let parem = cleanExpression(eq);
        let parem1 = cleanExpression(n1);

        let equ = `(${parem})-(${parem1})`;
        let equ1 = `(${parem})plus(${parem1})`;

        try {
          const response = await axios.get('http://167.172.134.148/absolute', {
            params: {
              eq: equ,
              eq1: equ1,
              var: variable,
              e1: parem,
              e2: parem1
            },
            timeout: 120000
          });

          const buffer = response.data.split("@@@");
          let [res, res1, check1, check11, check2, check22] = buffer;

          if (/\|/.test(eq)) {
            check1 = Math.abs(check1);
            check2 = Math.abs(check2);
          } else if (/\|/.test(n1)) {
            check11 = Math.abs(check11);
            check22 = Math.abs(check22);
          }

          return {
            tech_res:res,
            tech_res1:res1,
            tech_check1:check1,
            tech_check11:check11,
            tech_check2:check2,
            tech_check22:check22,
            tech_eq:eq,
            tech_n1:n1,
          };

        } catch (err) {
          return { error: 'Please! Check Your Input.' };
        }

      } else {
        return { error: 'Please Enter Valid Input.' };
      }
    }

     /** getCalculationAreaUnderTheCurveCalculator
   * POST: /api/calculators-lol/area-under-the-curve-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationAreaUnderTheCurveCalculator(body) {
      let enterEq1 = body.tech_EnterEq1;
      let withRespectTo = body.tech_with;
      let upper = body.tech_upper?.trim();
      let lower = body.tech_lower?.trim();

      if (!enterEq1) {
        return { error: 'Please enter any one value.' };
      }

      let parem = enterEq1
        .replace(/ /g, '')
        .replace(/\+/g, 'plus')
        .replace(/%20/g, '')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/e\^sqrt\(x\)/g, 'exp(2*x)')
        .replace(/e\^x/g, 'exp(x)')
        .replace(/e\^y/g, 'exp(y)')
        .replace(/e\^/g, 'exp')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**');

      const normalizeBound = (val) => {
        if (val === 'e') return 2.71828;
        return val.replace(/inf|∞/g, 'oo');
      };

      upper = normalizeBound(upper);
      lower = normalizeBound(lower);

      try {
        const response = await axios.post(
          'http://167.172.134.148/new-area',
          qs.stringify({
            equ: parem,
            wrt: withRespectTo,
            ub: upper,
            lb: lower
          }),
          {
            headers: {
              'Content-Type': 'application/x-www-form-urlencoded'
            },
            timeout: 120000
          }
        );

        const buffer = response.data;
        parem = parem.replace(/plus/g, '+');
        let readableEq = parem.replace(/\*\*/g, '^');

        return {
          tech_enter: readableEq,
          tech_with: withRespectTo,
          tech_ub: upper,
          tech_lb: lower,
          tech_ans: buffer[0],
          tech_ans1: buffer[1],
          tech_steps: buffer[2],
        };
      } catch (err) {
        return { error: 'Backend error: ' + err.message };
      }
    }

       /** getCalculationSecondDerivativeCalculator
   * POST: /api/calculators-lol/second-derivative-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationSecondDerivativeCalculator(body) {
      let enterEq = body.tech_EnterEq;
      let withRespectTo = body.tech_with;
      let how = 2;

      // Basic input validation
      if (!enterEq || /[<>&]|php|print_r|print|echo|script|=|%/i.test(enterEq)) {
        return { error: 'Please! Check Your Input.' };
      }

      let parem = enterEq
        .replace(/ /g, '')
        .replace(/\+/g, 'plus')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/e\^sqrt\(x\)/g, 'exp(2*x)')
        .replace(/e\^x/g, 'exp(x)')
        .replace(/e\^y/g, 'exp(y)')
        .replace(/e\^/g, 'exp')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**');

      try {
        const response = await axios.get('http://167.172.134.148/derivative', {
          params: {
            equ: parem,
            wrt: withRespectTo,
            how: how
          },
          timeout: 120000
        });

        const buffer = response.data.split('@@@');

        return {
          tech_enter: buffer[0],
          tech_final_res: buffer,
        };
      } catch (err) {
        return { error: 'Please! Check Your Input.' };
      }
    }

    /** getCalculationDoubleIntegralCalculator
   * POST: /api/calculators-lol/double-integral-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationDoubleIntegralCalculator(body) {
      let enterEq = body.tech_EnterEq;
      let withRespectTo = body.tech_with;
      let form = body.tech_form;
      let lbx = body.tech_lbx;
      let ubx = body.tech_ubx;
      let lby = body.tech_lby;
      let uby = body.tech_uby;

      // Basic validation
      if (!enterEq || /[<>&]|php|print_r|print|echo|script|=|%/i.test(enterEq)) {
        return { error: 'Please! Check Your Input.' };
      }

      if (form === 'def') {
        if (!ubx || !lbx || !uby || !lby) {
          return { error: 'Please! Check Your Input.' };
        }
      }

      let parem = enterEq
        .replace(/ /g, '')
        .replace(/\+/g, 'plus')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/e\^sqrt\(x\)/g, 'exp(2*x)')
        .replace(/e\^x/g, 'exp(x)')
        .replace(/e\^y/g, 'exp(y)')
        .replace(/e\^/g, 'exp')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**');

      let url = 'http://167.172.134.148/double_int';
      let params = {
        equ: parem,
        wrt: withRespectTo
      };

      if (form === 'def') {
        params.ubx = ubx.replace(/\+/g, 'plus');
        params.lbx = lbx.replace(/\+/g, 'plus');
        params.uby = uby.replace(/\+/g, 'plus');
        params.lby = lby.replace(/\+/g, 'plus');
      }

      try {
        const response = await axios.get(url, {
          params: params,
          timeout: 120000
        });

        const buffer = response.data.split('@@@');

        let result = {
          tech_def: form,
          tech_enter: buffer[0],
          tech_final: buffer[1],
          tech_en1: buffer[2],
          tech_en2: buffer[3],
          tech_step1: buffer[4],
          tech_step2: buffer[5],
        };

        if (form === 'def') {
          result.tech_finaln = buffer[6];
        }

        return result;
      } catch (err) {
        return { error: 'Please! Check Your Input.' };
      }
    }

     /** getCalculationTripleIntegralCalculator
   * POST: /api/calculators-lol/double-integral-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationTripleIntegralCalculator(body) {
      let enterEq = body.tech_EnterEq;
      let withRespectTo = body.tech_with;
      let form = body.tech_form;
      let lbx = body.tech_lbx;
      let ubx = body.tech_ubx;
      let lby = body.tech_lby;
      let uby = body.tech_uby;
      let lbz = body.tech_lbz;
      let ubz = body.tech_ubz;

      // Input validation
      if (!enterEq || /[<>&]|php|print_r|print|echo|script|=|%/i.test(enterEq)) {
        return { error: 'Please! Check Your Input.' };
      }

      if (form === 'def') {
        if (!ubx || !lbx || !uby || !lby || !ubz || !lbz) {
          return { error: 'Please! Check Your Input.' };
        }
      }

      // Equation cleanup
      let parem = enterEq
        .replace(/ /g, '')
        .replace(/\+/g, 'plus')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/e\^sqrt\(x\)/g, 'exp(2*x)')
        .replace(/e\^x/g, 'exp(x)')
        .replace(/e\^y/g, 'exp(y)')
        .replace(/e\^/g, 'exp')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**');

      let url = 'http://167.172.134.148/triple_int';
      let params = {
        equ: parem,
        wrt: withRespectTo
      };

      if (form === 'def') {
        params.ubx = ubx.replace(/\+/g, 'plus');
        params.lbx = lbx.replace(/\+/g, 'plus');
        params.uby = uby.replace(/\+/g, 'plus');
        params.lby = lby.replace(/\+/g, 'plus');
        params.ubz = ubz.replace(/\+/g, 'plus');
        params.lbz = lbz.replace(/\+/g, 'plus');
      }

      try {
        const response = await axios.get(url, {
          params: params,
          timeout: 120000
        });

        const buffer = response.data.split('@@@');

        let result = {
          tech_def: form,
          tech_enter: buffer[0],
          tech_final: buffer[1],
          tech_en1: buffer[2],
          tech_en2: buffer[3],
          tech_en3: buffer[4],
          tech_step1: buffer[5],
          tech_step2: buffer[6],
          tech_step3: buffer[7],
        };

        if (form === 'def') {
          result.tech_finaln = buffer[8];
        }

        return result;
      } catch (err) {
        return { error: 'Please! Check Your Input.' };
      }
    }

     /** getCalculationLimitCalculator
   * POST: /api/calculators-lol/limit-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationLimitCalculator(body) {
      let enterEq = body.tech_EnterEq;
      let how = body.tech_how;
      let withRespectTo = body.tech_with;
      let dir = body.tech_dir;

      // Validate input
      if (
        !enterEq ||
        /[<>&]|php|print_r|print|echo|script|=|%/i.test(enterEq)
      ) {
        return { error: 'Please! Check Your Input.' };
      }

      if (!withRespectTo || !dir) {
        return { error: 'Please! Check Your Input.' };
      }

      // Clean expression
      let parem = enterEq
        .replace(/ /g, '')
        .replace(/%20/g, '')
        .replace(/\+/g, 'plus')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/e\^sqrt\(x\)/g, 'exp(2*x)')
        .replace(/e\^/g, 'exp')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**');

      let parem2;
      if (!isNaN(how)) {
        parem2 = how;
      } else if (/inf|pi|e|∞/i.test(how)) {
        parem2 = how.replace(/inf|∞/gi, 'oo');
        how = parem2;
        if (parem2 === 'e') {
          parem2 = 2.71828;
        }
      } else {
        return { error: 'Please! Check Your Input.' };
      }

      let parem1 = withRespectTo.trim();
      let parem3 = dir.trim().replace(/\+/g, 'plus');

      let check2 = parem.split('/');
      let upr, btm;

      if (check2.length === 2) {
        upr = check2[0].replace(parem1, `(${parem2})`);
        btm = check2[1].replace(parem1, `(${parem2})`);
      }

      try {
        let postData = {
          equ: parem,
          wrt: parem1,
          lim: parem2,
          op: parem3
        };

        if (check2.length === 2) {
          postData.upr = upr;
          postData.btm = btm;
        }

        const response = await axios.post(
          'http://167.172.134.148/new-limit',
          new URLSearchParams(postData),
          { timeout: 120000 }
        );

        const buffer = response.data;

        let result = {
          tech_ans: buffer[0],
          tech_inf: how,
          tech_with: withRespectTo,
          tech_how: how,
          tech_dir: dir,
          tech_enter: buffer[1],
          tech_put: buffer[1].replace(withRespectTo, `(${how})`),
        };

        if (check2.length === 2) {
          let uprVal = buffer[2];
          let btmVal = buffer[3];
          if (!isNaN(uprVal) && !isNaN(btmVal) && btmVal != 1) {
            result.tech_upr = uprVal;
            result.tech_btm = btmVal;
            result.tech_ser = buffer[4];
          }
        } else {
          result.tech_ser = buffer[2];
        }

        return result;
      } catch (err) {
        return { error: 'Please! Check Your Input.' };
      }
    }


       /** getCalculationLaplaceTransformCalculator
   * POST: /api/calculators-lol/laplace-transform-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationLaplaceTransformCalculator(body) {
      let enterEq = body.tech_EnterEq;

      // Input validation
      if (
        !enterEq ||
        /[<>&]|php|print_r|print|echo|script|=|%/i.test(enterEq)
      ) {
        return { error: 'Please! Check Your Input.' };
      }

      // Prepare equation
      let parem = enterEq
        .replace(/ /g, '')
        .replace(/f\(t\)=/g, '')
        .replace(/\+/g, 'plus')
        .replace(/%20/g, '')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/e\^/g, 'exp')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**')
        .replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

      try {
        const response = await axios.post(
          'http://167.172.134.148/new-laplace',
          new URLSearchParams({ equ: parem }),
          { timeout: 120000 }
        );

        const buffer = response.data;

        return {
          tech_ans: buffer[0],
          tech_enter: buffer[1],
        };
      } catch (err) {
        return { error: 'Please! Check Your Input.' };
      }
    }

   /** getCalculationInflectionPointCalculator
   * POST: /api/calculators-lol/inflection-point-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationInflectionPointCalculator(body) {
      let eq = body.tech_eq;

      // Input validation
      if (
        !eq ||
        /[<>&]|php|print_r|print|echo|script|=|%/i.test(eq)
      ) {
        return { error: 'Please! Check Your Input.' };
      }

      // Prepare equation
      let parem = eq
        .replace(/ /g, '')
        .replace(/\+/g, 'plus')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/e\^/g, 'exp')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**')
        .replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

      try {
        const response = await axios.post(
          'http://167.172.134.148/new-inflection',
          new URLSearchParams({ equ: parem }),
          { timeout: 120000 }
        );

        const buffer = response.data;
        const result = {};

        if (buffer.length <= 1) {
          return { error: 'Please! Check Your Input.' };
        } else if (buffer.length <= 8) {
          result.no = 'no';
        } else if (buffer.length === 11) {
          result.tech_ip_1 = 'ip_1';
          result.tech_ip1 = parseFloat(buffer[7]).toFixed(3);
          result.tech_ip11 = parseFloat(buffer[8]).toFixed(3);
          result.tech_root = buffer[9];
          result.tech_iptype = buffer[10];
        } else {
          result.tech_ip1 = parseFloat(buffer[7]).toFixed(3);
          result.tech_ip11 = parseFloat(buffer[8]).toFixed(3);
          result.tech_ip2 = parseFloat(buffer[9]).toFixed(3);
          result.tech_ip22 = parseFloat(buffer[10]).toFixed(3);
          result.tech_root = buffer[11];
          result.tech_iptype = buffer[12];
        }

        result.tech_enter = buffer[0];
        result.tech_diff = buffer[1];
        result.tech_step = buffer[2];
        result.tech_diff1 = buffer[3];
        result.tech_step1 = buffer[4];
        result.tech_diff2 = buffer[5];
        result.tech_step2 = buffer[6];

        return result;
      } catch (err) {
        return { error: 'Please! Check Your Input.' };
      }
    }

   /** getCalculationBinomialTheoremCalculator
   * POST: /api/calculators-lol/binomial-theorem-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationBinomialTheoremCalculator(body) {
      let enterEq = body.tech_enter_eq;
      let x = body.tech_x;

      // Input validation
      if (
        !enterEq ||
        /[<>&]|php|print_r|print|echo|script|=|%/i.test(enterEq)
      ) {
        return { error: 'Please! Check Your Input.' };
      }

      if (!isFinite(x)) {
        return { error: 'Please! Check Your Input.' };
      }

      // Format equation
      let parem = enterEq
        .replace(/ /g, '')
        .replace(/\+/g, 'plus')
        .replace(/%20/g, '')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/e\^/g, 'exp')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**')
        .replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

      // Final binomial expression
      parem = `(${parem})**${x}`;

      try {
        const response = await axios.post(
          'http://167.172.134.148/new-binomial',
          new URLSearchParams({
            equ: parem,
            x: x
          }),
          { timeout: 120000 }
        );

        const buffer = response.data;

        return {
          tech_eq: buffer[1],
          tech_ans: buffer[0],
        };
      } catch (err) {
        return { error: 'Please! Check Your Input.' };
      }
    }

   /** getCalculationUnitTangentVectorCalculator
   * POST: /api/calculators-lol/unit-tangent-vector-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationUnitTangentVectorCalculator(body) {
      let x = body.tech_x;
      let y = body.tech_y;
      let z = body.tech_z;
      let t = body.tech_t;

      const isInvalid = (val) =>
        !val || /[<>&]|php|print_r|print|echo|script|=|%/i.test(val);

      if (isInvalid(x) || isInvalid(y) || isInvalid(z)) {
        return { error: 'Please! Check Your Input.' };
      }

      if (!isFinite(t)) {
        return { error: 'Please! Check Your Input.' };
      }

      const formatExpr = (expr) => {
        return expr
          .replace(/ /g, '')
          .replace(/\+/g, 'plus')
          .replace(/{/g, '(')
          .replace(/}/g, ')')
          .replace(/e\^/g, 'exp')
          .replace(/exp\^/g, 'exp')
          .replace(/\^/g, '**')
          .replace(/e\^sqrt\(x\)/g, 'exp(2*x)');
      };

      let parem = formatExpr(x);
      let parem1 = formatExpr(y);
      let parem2 = formatExpr(z);

      const containsTrig = (str) => /sin|cos|tan/i.test(str);
      const checkMethod = containsTrig(x) || containsTrig(y) || containsTrig(z)
        ? 'method1'
        : 'method2';

      try {
        const response = await axios.get('http://167.172.134.148/utvc', {
          timeout: 120000,
          params: {
            eq: parem,
            eq1: parem1,
            eq2: parem2,
            t: t,
            check: checkMethod
          }
        });

        const buffer = response.data.split('@@@');
        let result = { check: buffer[0] };

        if (buffer[0] === 'method1') {
          result.tech_enter = buffer[1];
          result.tech_enter1 = buffer[2];
          result.tech_enter2 = buffer[3];
          result.tech_deriv = buffer[4];
          result.tech_deriv1 = buffer[5];
          result.tech_deriv2 = buffer[6];
          result.tech_steps = buffer[7];
          result.tech_steps1 = buffer[8];
          result.tech_steps2 = buffer[9];
          result.tech_eq_len = buffer[10];
          result.tech_eq1_len = buffer[11];
          result.tech_eq2_len = buffer[12];
          result.tech_eq_solve = buffer[13];
          if (t) {
            result.tech_res = buffer[14];
            result.tech_res1 = buffer[15];
            result.tech_res2 = buffer[16];
          }
          result.t = t;
        } else if (buffer[0] === 'method2') {
          result.tech_enter = buffer[1];
          result.tech_enter1 = buffer[2];
          result.tech_enter2 = buffer[3];
          result.tech_deriv = buffer[4];
          result.tech_deriv1 = buffer[5];
          result.tech_deriv2 = buffer[6];
          result.tech_steps = buffer[7];
          result.tech_steps1 = buffer[8];
          result.tech_steps2 = buffer[9];
          result.tech_eq_len = buffer[10];
          result.tech_eq1_len = buffer[11];
          result.tech_eq2_len = buffer[12];
          result.tech_ans = buffer[13];
          result.tech_ans1 = buffer[14];
          result.tech_ans2 = buffer[15];
          result.tech_t = t;
        } else {
          return { error: 'Please! Check Your Input.' };
        }

        return result;
      } catch (error) {
        return { error: 'Please! Check Your Input.' };
      }
    }

   /** getCalculationRemainderTheoremCalculator
   * POST: /api/calculators-lol/remainder-theorem-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

      async  getCalculationRemainderTheoremCalculator(body) {
        let num = body.tech_num;
        let denom = body.tech_denom;

        const isInvalid = (val) =>
          !val || /[<>&]|php|print_r|print|echo|script|=|%/i.test(val);

        if (isInvalid(num) || isInvalid(denom)) {
          return { error: 'Please Enter Valid Input.' };
        }

        const formatExpr = (expr) => {
          return expr
            .replace(/ /g, '')
            .replace(/\+/g, 'plus')
            .replace(/{/g, '(')
            .replace(/}/g, ')')
            .replace(/e\^/g, 'exp')
            .replace(/exp\^/g, 'exp')
            .replace(/\^/g, '**')
            .replace(/e\^sqrt\(x\)/g, 'exp(2*x)');
        };

        let parem = formatExpr(num);
        let parem1 = formatExpr(denom);

        try {
          const response = await axios.get('http://167.172.134.148/r_t', {
            timeout: 120000,
            params: {
              eq: parem,
              eq1: parem1,
            },
          });

          const buffer = response.data.split('@@@');
          return {
            tech_enter: buffer[0],
            tech_enter1: buffer[1],
            tech_x: buffer[2],
            tech_ans: buffer[3],
          };
        } catch (error) {
          return { error: 'Please! Check Your Input.' };
        }
      }

       /** getCalculationFOILCalculator
   * POST: /api/calculators-lol/remainder-theorem-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationFOILCalculator(body) {
      let exp = body.tech_exp;

      if (
        /<|>|&|php|print_r|print|echo|script|=|sin|cos|tan|arcsin|arccos|arctan|%/i.test(exp)
      ) {
        return { error: 'Please Enter Valid Input.' };
      }

      if (!exp) {
        return { error: 'Please Check Your Input.' };
      }

      let parem = exp
        .replace(/ /g, '')
        .replace(/%20/g, '')
        .replace(/plus/g, '+')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/e\^/g, 'exp')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**')
        .replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

      try {
        if (/\*\*2|\*\*3/.test(parem)) {
          let s1 = parem.split('**');
          let opr, a, b;
          let s2 = s1[0].split('+');
          let s2_ = s1[0].split('-');

          if (s2.length === 2) {
            opr = '+';
            let s3 = s2[0].split('(');
            let s4 = s2[1].split(')');
            a = opr + s3[1];
            b = opr + s4[0];
          } else if (s2_.length === 2) {
            opr = '-';
            let s3 = s2_[0].split('(');
            let s4 = s2_[1].split(')');
            a = opr + s3[1];
            b = opr + s4[0];
          }

          let expnt = s1[1];
          let eq = s1[0];
          let par = parem.replace(/\+/g, 'plus');

          const response = await axios.get('http://167.172.134.148/foil', {
            timeout: 120000,
            params: {
              equ: par,
              a,
              opr,
              b,
              exp: expnt,
              eq,
            },
          });

          let buffer = response.data.split('@@@');
          return {
            tech_eq: buffer[0],
            tech_ans: buffer[1],
            tech_a: buffer[2],
            tech_b: buffer[3],
            tech_s1: buffer[4],
            tech_s2: buffer[5],
            tech_s3: buffer[6],
            tech_s4: buffer[7],
            tech_equ: buffer[8],
            tech_opr: buffer[9],
            tech_exp: buffer[10],
          };
        } else {
          let s1 = parem.split(')(');
          if (s1.length > 2) {
            return { error: 'Please Check Your Input.' };
          }

          let s2 = s1[0].split('(');
          let s3 = s1[1].split(')');
          let opr, a, b, opr1, c, d;

          let s4 = s2[1].split('+');
          let s4_ = s2[1].split('-');
          let s5 = s3[0].split('+');
          let s5_ = s3[0].split('-');

          if (s4.length === 2) {
            opr = 'plus';
            a = s4[0];
            b = opr + s4[1];
          } else if (s4_.length === 2) {
            opr = '-';
            a = s4_[0];
            b = opr + s4_[1];
          } else if (s4_.length === 3) {
            opr = '-';
            a = opr + s4_[1];
            b = opr + s4_[2];
          }

          if (s5.length === 2) {
            opr1 = 'plus';
            c = s5[0];
            d = opr1 + s5[1];
          } else if (s5_.length === 2) {
            opr1 = '-';
            c = s5_[0];
            d = opr1 + s5_[1];
          } else if (s5_.length === 3) {
            opr1 = '-';
            c = opr1 + s5_[1];
            d = opr1 + s5_[2];
          }

          let par = parem.replace(/\+/g, 'plus');

          const response = await axios.get('http://167.172.134.148/foil', {
            timeout: 120000,
            params: {
              equ: par,
              a,
              opr,
              b,
              c,
              opr1,
              d,
            },
          });

          let buffer = response.data.split('@@@');
          return {
            tech_eq: buffer[0],
            tech_ans: buffer[1],
            tech_a: buffer[2],
            tech_b: buffer[3],
            tech_c: buffer[4],
            tech_d: buffer[5],
            tech_s1: buffer[6],
            tech_s2: buffer[7],
            tech_s3: buffer[8],
            tech_s4: buffer[9],
            tech_opr: buffer[10],
            tech_opr1: buffer[11],
            tech_check: buffer[12],
          };
        }
      } catch (error) {
        return { error: 'Please! Check Your Input.' };
      }
    }
     /** getCalculationEulerMethodCalculator
   * POST: /api/calculators-lol/eulers-method-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationTrapezoidalRuleCalculator(body) {
        let EnterEq = body.tech_EnterEq;
      let lb = body.tech_lb;
      let ub = body.tech_ub;
      let n = body.tech_n;
      let _with = body.tech_with;


      let result = {};

      // Basic validation
      if (!EnterEq || /[<>&=]|php|print_r|print|echo|script|%/i.test(EnterEq)) {
        result.error = 'Please! Check Your Input.';
        return result;
      }

      // Check numeric values
      if (!isFinite(lb) || !isFinite(ub) || !isFinite(n)) {
        result.error = 'Please! Check Your Input.';
        return result;
      }

      lb = parseFloat(lb);
      ub = parseFloat(ub);
      n = parseInt(n);

      if (lb >= ub) {
        result.error = 'The lower limit should be less than the upper limit.';
        return result;
      }

      // Prepare expression
      let parem = EnterEq.replace(/\s+/g, '')
        .replace(/\+/g, 'plus')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/e\^/g, 'exp')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**')
        .replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

      let diff = (ub - lb) / n;
      let final = lb;
      let limit_a = [lb];
      let limit = `${final}`;

      while (final < ub) {
        final += diff;
        limit_a.push(final);
        limit += `, ${final}`;
      }

      try {
        const response = await axios.get('http://167.172.134.148/trap', {
          params: {
            equ: parem,
            with: _with,
            lb,
            ub,
            n,
            diff,
          },
          timeout: 120000,
        });

        let buffer = response.data.split('@@@');
        let steps = buffer[0].split('HA');

        result.tech_steps = steps;
        result.tech_res = buffer[1];
        result.tech_enter = buffer[2];
        result.tech_ub = ub;
        result.tech_lb = lb;
        result.tech_n = n;
        result.tech_diff = diff;
        result.tech_limit = limit;
        result.tech_limit_a = limit_a;
        result.tech_with = _with;
        return result;
      } catch (err) {
        result.error = 'Please! Check Your Input.';
        return result;
      }
    }

    /** getCalculationNewtonsMethodCalculator
   * POST: /api/calculators-lol/newtons-method-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationNewtonsMethodCalculator(body) {
      let fx = body.tech_fx;
      let fx1 = body.tech_fx1;
      let x0 = body.tech_x0;
      let iter = body.tech_iter;
      let round = body.tech_round;



      let result = {};

      // Validation
      const unsafePattern = /<|>|&|php|print_r|print|echo|script|=|%/i;
      if (!fx || unsafePattern.test(fx)) {
        result.error = 'Please Enter Valid Input.';
        return result;
      }

      if (!isFinite(round) || !isFinite(iter) || !isFinite(x0)) {
        result.error = 'Please! Check Your Input';
        return result;
      }

      // Clean and prepare fx
      let parem = fx
        .replace(/\s+/g, '')
        .replace(/\+/g, 'plus')
        .replace(/%20/g, '')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/e\^/g, 'exp')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**')
        .replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

      let parem1 = '0';
      if (fx1 && fx1 !== '') {
        if (unsafePattern.test(fx1)) {
          result.error = 'Please Enter Valid Input.';
          return result;
        }

        parem1 = fx1
          .replace(/\s+/g, '')
          .replace(/\+/g, 'plus')
          .replace(/%20/g, '')
          .replace(/{/g, '(')
          .replace(/}/g, ')')
          .replace(/e\^/g, 'exp')
          .replace(/exp\^/g, 'exp')
          .replace(/\^/g, '**')
          .replace(/e\^sqrt\(x\)/g, 'exp(2*x)');
      }

      // Default round if not numeric
      if (!isFinite(round)) {
        round = 4;
      }

      try {
        const response = await axios.post(
          'http://167.172.134.148/new-newtons',
          new URLSearchParams({
            equ: parem,
            equ1: parem1,
            x: x0,
            iter,
            round,
          }),
          { timeout: 120000 }
        );

        let buffer = response.data;

        if (Array.isArray(buffer)) {
          if (buffer.length === 6) {
            result.tech_enter = buffer[0];
            result.tech_enter1 = buffer[1];
            result.tech_steps = buffer[2];
            result.tech_fx = buffer[3];
            result.tech_fx1 = buffer[4];
            result.tech_res = buffer[5];
            result.tech_round = round;
          } else if (buffer.length === 1) {
            result.error = 'Please! Check Your Input.';
            return result;
          } else {
            result.tech_check = 'check';
            result.tech_enter = buffer[0];
            result.tech_enter1 = buffer[1];
            result.tech_fx = buffer[2];
            result.tech_fx1 = buffer[3];
            result.tech_res = buffer[4];
            result.tech_round = round;
          }
        } else {
          result.error = 'Unexpected response format.';
        }

        return result;
      } catch (error) {
        result.error = 'Please! Check Your Input.';
        return result;
      }
    }

      /** getCalculationMeanValueTheoremCalculator
   * POST: /api/calculators-lol/mean-value-theorem-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationMeanValueTheoremCalculator(body) {
        let EnterEq = body.tech_EnterEq;
        let lb = body.tech_lb;
        let ub = body.tech_ub;
        let withVar = body.tech_with;

      let result = {};
      const unsafePattern = /<|>|&|php|print_r|print|echo|script|=|%/i;

      if (!EnterEq || unsafePattern.test(EnterEq)) {
        result.error = 'Please! Check Your Input.';
        return result;
      }

      if (!isFinite(lb) || !isFinite(ub)) {
        result.error = 'Please! Check Your Input.';
        return result;
      }

      if (lb >= ub) {
        result.error = 'The start interval should be less than the end inverval.';
        return result;
      }

      // Prepare equations
      let parem = EnterEq
        .replace(/\s+/g, '')
        .replace(/\+/g, 'plus')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/e\^/g, 'exp')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**')
        .replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

      let parem1 = parem;
      if (withVar) {
        parem = parem.replace(new RegExp(withVar, 'g'), 'c');
      }

      try {
        const response = await axios.post(
          'http://167.172.134.148/new-mean',
          new URLSearchParams({
            equ: parem,
            equ1: parem1,
            lb,
            ub,
          }),
          { timeout: 120000 }
        );

        const buffer = response.data;
        const root = String(buffer[4]).replace('[', '').replace(']', '');

        result.tech_enter = buffer[0];
        result.tech_start = buffer[1];
        result.tech_end = buffer[2];
        result.tech_deri = buffer[3];
        result.tech_simple = buffer[5];
        result.tech_ub = ub;
        result.tech_lb = lb;
        result.tech_root = root;
        result.tech_with = withVar;
        return result;
      } catch (error) {
        result.error = 'Please! Check Your Input.';
        return result;
      }
    }

   /** getCalculationRiemannSumCalculator
   * POST: /api/calculators-lol/riemann-sum-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationRiemannSumCalculator(body) {
      let EnterEq = body.tech_EnterEq;
      let lb = body.tech_lb;
      let ub = body.tech_ub;
      let type = body.tech_type;
      let n = body.tech_n;
      let withVar = body.tech_with;


      let result = {};
      const unsafePattern = /<|>|&|php|print_r|print|echo|script|=|%/i;

      if (!EnterEq || unsafePattern.test(EnterEq)) {
        result.error = 'Please! Check Your Input.';
        return result;
      }

      if (!isFinite(lb) || !isFinite(ub) || !isFinite(n)) {
        result.error = 'Please! Check Your Input.';
        return result;
      }

      if (lb >= ub) {
        result.error = 'The lower limit should be less than the upper limit.';
        return result;
      }

      let parem = EnterEq
        .replace(/\s+/g, '')
        .replace(/\+/g, 'plus')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/e\^/g, 'exp')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**')
        .replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

      let diff = (ub - lb) / n;
      let final = lb;
      let limit = `${final}`;
      let limit_a = [];

      if (type !== '2') {
        limit_a.push(lb);
      }

      while (final < ub) {
        final += diff;
        limit_a.push(final);
        limit += `, ${final}`;
      }

      let lb_ = type === '2' ? lb + diff : lb;

      try {
        const response = await axios.post(
          'http://167.172.134.148/new-riemann',
          new URLSearchParams({
            equ: parem,
            with: withVar,
            ub,
            lb: lb_,
            n,
            type,
            diff
          }),
          { timeout: 120000 }
        );

        const buffer = response.data;
        const steps = buffer[0].split('HA');

        result.tech_steps = steps;
        result.tech_res = buffer[1];
        result.tech_enter = buffer[2];
        result.tech_ub = ub;
        result.tech_lb = lb;
        result.tech_n = n;
        result.tech_type = type;
        result.tech_diff = diff;
        result.tech_limit = limit;
        result.tech_limit_a = limit_a;
        result.tech_with = withVar;
        return result;
      } catch (err) {
        result.error = 'Please! Check Your Input.';
        return result;
      }
    }

   /** getCalculationInverseFunctionCalculator
   * POST: /api/calculators-lol/inverse-function-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationInverseFunctionCalculator(body) {
          let equ = body.tech_equ;

      let result = {};
      const unsafePattern = /<|>|&|php|print_r|print|echo|script|=|%/i;

      // Basic validation
      if (!equ || unsafePattern.test(equ)) {
        result.error = 'Please Enter Valid Input.';
        return result;
      }

      // Extra variable check (only allow x and sqrt)
      const check = equ.split('sqrt');
      if (check.length === 1 && /[a-df-wA-DF-Wyz%]/.test(equ)) {
        result.error = 'Equestion unacceptable variables.';
        return result;
      }

      // Format input
      let main = equ
        .replace(/x/g, 'y')
        .replace(/\s+/g, '')
        .replace(/\+/g, 'plus')
        .replace(/%20/g, '')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/e\^/g, 'exp')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**')
        .replace(/e\^sqrt\(y\)/g, 'exp(2*y)');

      equ = equ
        .replace(/\s+/g, '')
        .replace(/\+/g, 'plus')
        .replace(/%20/g, '')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/e\^/g, 'exp')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**')
        .replace(/e\^sqrt\(y\)/g, 'exp(2*y)');

      let main2 = main;
      main = `${main}-x`;

      try {
        const response = await axios.post(
          'http://167.172.134.148/new-inv_fun',
          new URLSearchParams({
            equ,
            main2,
            main
          }),
          { timeout: 120000 }
        );

        const buffer = response.data;
        let res = buffer[2].replace('\\left[', '').replace('\\right]', '');

        result.tech_enter = buffer[0];
        result.tech_enter2 = buffer[1];
        result.tech_res = res;
        return result;
      } catch (err) {
        result.error = 'Please! Check Your Input.';
        return result;
      }
    }

     /** getCalculationCompositeFunctionCalculator
   * POST: /api/calculators-lol/composite-function-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async  getCalculationCompositeFunctionCalculator(body) {
    let one = body.tech_one;
    let two = body.tech_two;
    let point = body.tech_point;

    let result = {};
    const unsafePattern = /<|>|&|php|print_r|print|echo|script|=|%/i;

    // Input validation
    if (!one || !two || isNaN(point) || unsafePattern.test(one) || unsafePattern.test(two)) {
      result.error = 'Please Enter Valid Input.';
      return result;
    }

    // Compose parem
    let one_ = one.replace(/x/g, '(x)').replace(/x/g, two);
    let parem = one_
      .replace(/\s+/g, '')
      .replace(/\+/g, 'plus')
      .replace(/%20/g, '')
      .replace(/{/g, '(')
      .replace(/}/g, ')')
      .replace(/e\^/g, 'exp')
      .replace(/exp\^/g, 'exp')
      .replace(/\^/g, '**')
      .replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

    // Compose parem1
    let two_ = two.replace(/x/g, '(x)').replace(/x/g, one);
    let parem1 = two_
      .replace(/\s+/g, '')
      .replace(/\+/g, 'plus')
      .replace(/%20/g, '')
      .replace(/{/g, '(')
      .replace(/}/g, ')')
      .replace(/e\^/g, 'exp')
      .replace(/exp\^/g, 'exp')
      .replace(/\^/g, '**')
      .replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

    try {
      const response = await axios.post(
        'http://167.172.134.148/new-composite',
        new URLSearchParams({
          equ: parem,
          equ1: parem1,
          lim: point.toString(),
        }),
        { timeout: 120000 }
      );

      const buffer = response.data;

      let penter = buffer[1].replace(/x/g, `(${point})`);
      let penter1 = buffer[3].replace(/x/g, `(${point})`);

      parem = parem.replace(/plus/g, '+').replace(/\*\*/g, '^').replace(/"/g, '');
      parem1 = parem1.replace(/plus/g, '+').replace(/\*\*/g, '^').replace(/"/g, '');

      result.tech_res = buffer[0];
      result.tech_enter = parem;
      result.tech_enter1 = parem1;
      result.tech_enter2 = buffer[1];
      result.tech_penter = penter;
      result.tech_penter1 = penter1;
      result.tech_res1 = buffer[2];
      result.tech_enter3 = buffer[3];
      result.tech_point = point;
      result.tech_one = one;
      result.tech_two = two;

      return result;
    } catch (error) {
      result.error = 'Please! Check Your Input.';
      return result;
    }
  }

     /** getCalculationAreaBetweenTwoCurvesCalculator
   * POST: /api/calculators-lol/area-between-two-curves-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationAreaBetweenTwoCurvesCalculator(body) {
      let EnterEq1 = body.tech_enter_eq1;
      let EnterEq2 = body.tech_enter_eq2;
      let wrt = body.tech_with;
      let ub = body.tech_upper;
      let lb = body.tech_lower;

      let result = {};
      const unsafePattern = /<|>|&|php|print_r|print|echo|script|=|%/i;

      // Input validation
      if (!EnterEq1 || !EnterEq2 || !lb || !ub || unsafePattern.test(EnterEq1) || unsafePattern.test(EnterEq2)) {
        result.error = 'Please! Check Your Input.';
        return result;
      }

      // Compose expression
      let parem = `(${EnterEq1})-(${EnterEq2})`
        .replace(/\s+/g, '')
        .replace(/\+/g, 'plus')
        .replace(/%20/g, '')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/e\^/g, 'exp')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**')
        .replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

      // Clean bounds
      ub = ub.toString().replace(/inf|∞/gi, 'oo');
      lb = lb.toString().replace(/inf|∞/gi, 'oo');
      if (ub === 'e') ub = '2.71828';
      if (lb === 'e') lb = '2.71828';

      try {
        const response = await axios.post(
          'http://167.172.134.148/new-area',
          new URLSearchParams({
            equ: parem,
            wrt: wrt,
            ub: ub,
            lb: lb,
          }),
          { timeout: 120000 }
        );

        const buffer = response.data;

        parem = parem.replace(/plus/g, '+').replace(/\*\*/g, '^').replace(/"/g, '');

        result.tech_enter = parem;
        result.tech_with = wrt;
        result.tech_ub = ub;
        result.tech_lb = lb;
        result.tech_ans = buffer[0];
        result.tech_ans1 = buffer[1];
        result.tech_steps = buffer[2];

        return result;
      } catch (error) {
        result.error = 'Please! Check Your Input.';
        return result;
      }
    }

     /** getCalculationZerosCalculator
   * POST: /api/calculators-lol/zeros-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationZerosCalculator(body) {
      let  eq = body.tech_eq;
      let param = {};

      // Validation
      let isInvalid = /<|>|&|php|print_r|print|echo|script|sin|cos|tan|arcsin|arccos|arctan|%/i;
      if (!eq || isInvalid.test(eq)) {
        return { error: 'Please Check Your Input!' };
      }

      // Sanitize input
      let parem = eq.replace(/\s+/g, '')
                    .replace(/%20/g, '')
                    .replace(/\+/g, 'plus')
                    .replace(/{/g, '(')
                    .replace(/}/g, ')')
                    .replace(/e\^/g, 'exp')
                    .replace(/exp\^/g, 'exp')
                    .replace(/\^/g, '**')
                    .replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

      // Handle equation formatting
      let splitEq = parem.split('=');
      if (splitEq.length === 2) {
        eq = `(${splitEq[0]})-(${splitEq[1]})`;
      } else {
        eq = splitEq[0];
      }

      try {
        const { data } = await axios.get('http://167.172.134.148/zeros', {
          params: { equ: eq },
          timeout: 120000
        });

        let buffer = data.split('@@@');
        param.tech_eq = buffer[0];
        param.tech_s2 = buffer[1];
        param.tech_sum = buffer[2];
        param.tech_prod = buffer[3];
        return param;
      } catch (error) {
        return { error: 'Please! Check Your Input.' };
      }
    }

    /** getCalculationGeometricSequenceCalculator
   * POST: /api/calculators-lol/geometric-sequence-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationGeometricSequenceCalculator(body) {
        let find = body.tech_find;
        let cw = body.tech_cw;
        let a1 = body.tech_a1;
        let r = body.tech_r;
        let n = body.tech_n;
        let an = body.tech_an;
        let sn = body.tech_sn;
        let n1 = body.tech_n1;
        let a_n = body.tech_a_n;


      // Helper to check if value is numeric
        function isNumeric(value) {
          return !isNaN(parseFloat(value)) && isFinite(value);
        }


      let param = {};

      if (find === 'gs' && isNumeric(a1) && isNumeric(r) && isNumeric(n)) {
        let an_val = a1 * Math.pow(r, n - 1);
        let sn_val = a1 * (1 - Math.pow(r, n)) / (1 - r);

        let seq = '';
        for (let i = 1; i <= 10; i++) {
          let sum = Math.pow(a1, i);
          seq += (i < 10) ? `${sum}, ` : `${sum} ....`;
        }

        param.tech_an_val = an_val;
        param.tech_sn_val = sn_val;
        param.tech_seq = seq;
      } else if (find === 'a1' && isNumeric(r) && isNumeric(n1) && isNumeric(a_n)) {
        let a1_val = a_n / Math.pow(r, n1 - 1);
        param.tech_a1_val = a1_val;
      } else if (find === 'r' && isNumeric(a1) && isNumeric(n1) && isNumeric(a_n)) {
        let r_val = Math.pow((a_n / a1), (1 / (n1 - 1)));
        param.tech_r_val = r_val;
      } else if (find === 'n' && isNumeric(a1) && isNumeric(r)) {
        if (cw === 'nth' && isNumeric(an)) {
          let n_val = (Math.log(an / a1) / Math.log(r)) + 1;
          param.tech_n_val = n_val;
        } else if (cw === 's_n' && isNumeric(sn)) {
          let numerator = (((sn / a1) * (1 - r)) - 1) * -1;
          let n_val = Math.log(numerator) / Math.log(r);
          param.tech_n_val = n_val;
        }
      } else {
        return { error: 'Please Check Your Input.' };
      }

      return param;
    }

     /** getCalculationTruthTableCalculator
   * POST: /api/calculators-lol/truth-table-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationTruthTableCalculator(body) {
      let eq = (body.tech_eq || '').trim();
      let submit = body.tech_submit;

      let param = {};

      // Input validation
      if (!eq || /php|print_r|print|echo|script|sin|cos|tan|arcsin|arccos|arctan|%/i.test(eq)) {
        return { error: 'Please Enter Valid Input.' };
      }

      if (submit) {
        param.tech_eq = eq;
        return param;
      } else {
        return { error: 'Please! Check Your Input' };
      }
    }

       /** getCalculationEvenOddFunctionCalculator
   * POST: /api/calculators-lol/even-odd-function-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */


    async  getCalculationEvenOddFunctionCalculator(body) {
      let EnterEq = body.tech_EnterEq;
      let withRespectTo = body.tech_with;

      // Input validation
      if (!EnterEq || /[<>&=]|php|print_r|print|echo|script|%/i.test(EnterEq)) {
        return { error: 'Please! Check Your Input.' };
      }

      // Count and remove '|' if more than one
      let abs = (EnterEq.match(/\|/g) || []).length;
      let mode = null;

      if (abs > 1) {
        EnterEq = EnterEq.replace(/\|/g, '');
        mode = withRespectTo;
      }

      // Equation cleanup
      let parem = EnterEq.trim()
        .replace(/\s+/g, '')
        .replace(/\+/g, 'plus')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/e\^x/g, 'exp(x)')
        .replace(/e\^y/g, 'exp(y)')
        .replace(/e\^/g, ' exp')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**')
        .replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

      // Replace exp with e, then do substitution for -x
      let newEq = parem.replace(/exp/g, 'e');
      let parem1 = newEq.replace(new RegExp(withRespectTo, 'g'), `(-${withRespectTo})`);
      parem1 = parem1.replace(/e/g, ' exp');

      try {
        const response = await axios.get('http://167.172.134.148/even', {
          params: {
            equ: parem,
            equ1: parem1,
            wrt: withRespectTo
          },
          timeout: 120000
        });

        const buffer = response.data.split('@@@');

        return {
          tech_ans: buffer[0],
          tech_enter: buffer[1],
          tech_with: withRespectTo,
          tech_mode: mode,
        };
      } catch (err) {
        return { error: 'Please! Check Your Input.' };
      }
    }

    /** getCalculationSyntheticDivisionCalculator
   * POST: /api/calculators-lol/synthetic-division-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationSyntheticDivisionCalculator(body) {
      let dividend = body.tech_dividend;
      let divisor = body.tech_divisor;

      // Input validation for security
      const unsafePattern = /<|>|&|php|print_r|print|echo|script|sin|cos|tan|arcsin|arccos|arctan|%/i;
      if (unsafePattern.test(dividend) || unsafePattern.test(divisor)) {
        return { error: "Please Enter Valid Input." };
      }

      // Divisor pattern check
      const pattern = /^\s*(\(?\s*-?\d+(\.\d+)?\s*\)?|)\s*\(?([a-zA-Z])\)?\s*([\+\-])\s*\(?-?\d+(\.\d+)?\)?\s*$/;
      const matches = divisor.match(pattern);
      if (matches) {
        if (!dividend.includes(matches[3])) {
          return { error: `Variable ${matches[3]} does not exist in the function` };
        }

        const uniqueVariables = [...new Set((dividend.match(/[a-zA-Z]/g) || []))];
        if (uniqueVariables.length > 1) {
          return { error: 'Dividend contains more than one variable' };
        }

        if (!dividend || !divisor) {
          return { error: 'Please! Check Your Input' };
        }

        // Clean and transform expressions
        const cleanup = str =>
          str
            .replace(/\s+/g, '')
            .replace(/%20/g, '')
            .replace(/\+/g, 'plus')
            .replace(/{/g, '(')
            .replace(/}/g, ')')
            .replace(/–/g, '-')
            .replace(/e\^/g, 'exp')
            .replace(/exp\^/g, 'exp')
            .replace(/\^/g, '**')
            .replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

        let parem = cleanup(dividend);
        let parem1 = cleanup(divisor);

        try {
          const response = await axios.get('http://167.172.134.148/synthetic', {
            params: {
              eq: parem,
              eq1: parem1
            },
            timeout: 120000
          });

          const buffer = response.data.split('@@@');
          const coeffs = buffer[2].split('###');
          const coeffs1 = buffer[7].split('###');

          return {
            tech_eq: buffer[0],
            tech_eq1: buffer[1],
            tech_coeffs: coeffs,
            tech_divby: buffer[3],
            tech_quot: buffer[4],
            tech_rmnd: buffer[5],
            tech_divby1: buffer[6],
            tech_coeffs1: coeffs1,
          };
        } catch (error) {
          return { error: 'Please! Check Your Input.' };
        }
      } else {
        return { error: 'Please! Check Your Input' };
      }
    }
     /** getCalculationProductRuleDerivativeCalculator
   * POST: /api/calculators-lol/product-rule-derivative-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */


    async  getCalculationProductRuleDerivativeCalculator(body) {
      let EnterEq = body.tech_enter_eq;
      let withRespectTo = body.tech_with;
      let how = body.tech_how;

      // Validation
      const unsafePattern = /<|>|&|php|print_r|print|echo|script|=|%/i;
      if (!EnterEq || unsafePattern.test(EnterEq)) {
        return { error: 'Please! Check Your Input.' };
      }

      // Clean and transform input
      let parem = EnterEq
        .replace(/\s+/g, '')
        .replace(/\+/g, 'plus')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/e\^/g, 'exp')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**')
        .replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

      let parem1 = withRespectTo;
      let parem2 = how;

      try {
        const response = await axios.get('http://167.172.134.148/derivative', {
          params: {
            equ: parem,
            wrt: parem1,
            how: parem2
          },
          timeout: 120000
        });

        const buffer = response.data.split('@@@');

        if (parseInt(how) > 1) {
          return {
            tech_enter: buffer[0],
            tech_final_res: buffer,
            RESULT: 1
          };
        } else {
          return {
            tech_buffer: buffer[0],
            tech_ans: buffer[1],
            tech_enter: buffer[2],
            tech_simple: buffer[3],
          };
        }
      } catch (error) {
        return { error: 'Please! Check Your Input.' };
      }
    }

     /** getCalculationOrthocenterCalculator
   * POST: /api/calculators-lol/orthocenter-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationOrthocenterCalculator(body) {
      let x1 = body.tech_x1;
        let y1 = body.tech_y1;
        let x2 = body.tech_x2;
        let y2 = body.tech_y2;
        let x3 = body.tech_x3;
        let y3 = body.tech_y3;


        const result = {};

        if (isNaN(x1) || isNaN(y1) || isNaN(x2) || isNaN(y2) || isNaN(x3) || isNaN(y3)) {
            result.error = 'Please! Check Your Input.';
            return result;
        }

        let ab1, ab2, bc1, bc2, ca1, ca2;
        let xx;

        const a = y2 - y1;
        const a1 = x2 - x1;
        if (a !== 0 && a1 !== 0) {
            const ab = a / a1;
            ab1 = -1 / ab;
            ab2 = y3 - (ab1 * x3);
            xx = `y=${ab1}x${ab2 >= 0 ? '+' + ab2 : ab2}`;
        }

        const b = y3 - y2;
        const b1 = x3 - x2;
        if (b !== 0 && b1 !== 0) {
            const bc = b / b1;
            bc1 = -1 / bc;
            bc2 = y1 - (bc1 * x1);
            xx = `y=${bc1}x${bc2 >= 0 ? '+' + bc2 : bc2}`;
        }

        const c = y3 - y1;
        const c1 = x3 - x1;
        if (c !== 0 && c1 !== 0) {
            const ca = c / c1;
            ca1 = -1 / ca;
            ca2 = y2 - (ca1 * x2);
            xx = `y=${ca1}x${ca2 >= 0 ? '+' + ca2 : ca2}`;
        }

        if (a !== 0 && a1 !== 0 && b !== 0 && b1 !== 0 && c !== 0 && c1 !== 0) {
            const con = -bc1;
            const con1 = -bc2;
            const ad = con + ab1;
            const ad1 = ab2 + con1;
            const di = ad1 / ad;
            const di1 = -di;
            const y8 = (bc1 * di1) + bc2;

            if (isNaN(di1) || isNaN(y8)) {
                result.error = 'Please! Check Your Input.';
                return result;
            } else {
                result.tech_x = Number.isInteger(di1) ? di1 : parseFloat(di1.toFixed(5));
                result.tech_y = Number.isInteger(y8) ? y8 : parseFloat(y8.toFixed(5));
            }
        } else if (a !== 0 && a1 !== 0 && b !== 0 && b1 !== 0) {
            const con = -bc1;
            const con1 = -bc2;
            const ad = con + ab1;
            const ad1 = ab2 + con1;
            const di = ad1 / ad;
            const di1 = -di;
            const y8 = (bc1 * di1) + bc2;

            if (isNaN(di1) || isNaN(y8)) {
                result.error = 'Please! Check Your Input.';
                return result;
            } else {
                result.tech_x = Number.isInteger(di1) ? di1 : parseFloat(di1.toFixed(5));
                result.tech_y = Number.isInteger(y8) ? y8 : parseFloat(y8.toFixed(5));
            }
        } else if (b !== 0 && b1 !== 0 && c !== 0 && c1 !== 0) {
            const con2 = -ca1;
            const con3 = -ca2;
            const ad2 = con2 + bc1;
            const ad3 = bc2 + con3;
            const di = ad3 / ad2;
            const di1 = -di;
            const y8 = (ca1 * di1) + ca2;

            if (isNaN(di1) || isNaN(y8)) {
                result.error = 'Please! Check Your Input.';
                return result;
            } else {
                result.tech_x = Number.isInteger(di1) ? di1 : parseFloat(di1.toFixed(5));
                result.tech_y = Number.isInteger(y8) ? y8 : parseFloat(y8.toFixed(5));
            }
        } else if (a !== 0 && a1 !== 0 && c !== 0 && c1 !== 0) {
            const con2 = -ab1;
            const con3 = -ab2;
            const ad2 = con2 + ca1;
            const ad3 = ca2 + con3;
            const di = ad3 / ad2;
            const di1 = -di;
            const y8 = (ab1 * di1) + ab2;

            if (isNaN(di1) || isNaN(y8)) {
                result.error = 'Please! Check Your Input.';
                return result;
            } else {
                result.tech_x = Number.isInteger(di1) ? di1 : parseFloat(di1.toFixed(5));
                result.tech_y = Number.isInteger(y8) ? y8 : parseFloat(y8.toFixed(5));
            }
        } else {
            result.error = 'Please! Check Your Input.';
            return result;
        }

        return result;
    }

    /** getCalculationPolynomialLongDivisionCalculator
   * POST: /api/calculators-lol/polynomial-long-division-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async  getCalculationPolynomialLongDivisionCalculator(body) {
    let dividend = body.tech_dividend;
  let divisor = body.tech_divisor;

      const result = {};
      
      // Input validation
      if (!dividend || !divisor) {
          result.error = 'Please Enter Valid Input.';
          return result;
      }

      // Check for forbidden characters
      const forbiddenPattern = /<|>|&|php|print_r|print|echo|script|sin|cos|tan|arcsin|arccos|arctan|&|%/i;
      if (forbiddenPattern.test(dividend) || forbiddenPattern.test(divisor)) {
          result.error = 'Please Enter Valid Input.';
          return result;
      }

      // Process dividend
      let processedDividend = dividend.replace(/\s+/g, '')
                                    .replace(/%20/g, '')
                                    .replace(/\+/g, 'plus')
                                    .replace(/{/g, '(')
                                    .replace(/}/g, ')')
                                    .replace(/e\^/g, 'exp')
                                    .replace(/exp\^/g, 'exp')
                                    .replace(/\^/g, '**')
                                    .replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

      // Process divisor
      let processedDivisor = divisor.replace(/\s+/g, '')
                                    .replace(/%20/g, '')
                                    .replace(/\+/g, 'plus')
                                    .replace(/{/g, '(')
                                    .replace(/}/g, ')')
                                    .replace(/e\^/g, 'exp')
                                    .replace(/exp\^/g, 'exp')
                                    .replace(/\^/g, '**')
                                    .replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

      // Check variable consistency
      if ((divisor.includes('x') && dividend.includes('y')) || 
          (divisor.includes('y') && dividend.includes('x'))) {
          result.error = 'The divisor and dividend have different variables.';
          return result;
      }

      // Determine variable check
      let check = "";
      if (divisor.includes('x') && divisor.includes('y')) {
          check = "xy";
      } else if (divisor.includes('x') && !divisor.includes('y')) {
          check = "x";
      } else if (divisor.includes('y') && !divisor.includes('x')) {
          check = "y";
      }

      try {
          // Make API request
          const response = await axios.get('http://167.172.134.148/polynomial', {
              params: {
                  eq: processedDividend,
                  eq1: processedDivisor,
                  check: check
              },
              timeout: 120000
          });

          const buffer = response.data.split('@@@');
          
          // Basic results
          result.tech_check = check;
          result.tech_eq = buffer[0];
          result.tech_eq1 = buffer[1];
          result.tech_quot = buffer[2];
          result.tech_rmnd = buffer[3];

          if (check !== "xy") {
              // Additional results for non-xy cases
              const quotient = buffer[4].split('###').filter(item => item);
              const multiplies = buffer[5].split('###').filter(item => item);
              const steps = buffer[6].split('###').filter(item => item);
              const divCoeff = buffer[7].split('###').filter(item => item);
              const leading_term = buffer[9].split('###').filter(item => item);

              result.tech_quotient = quotient;
              result.tech_multiplies = multiplies;
              result.tech_steps = steps;
              result.tech_divCoeff = divCoeff;
              result.tech_loop_len = buffer[8];
              result.tech_leading_term = leading_term;
              result.tech_divby_lt = buffer[10];
          }

          return result;

      } catch (error) {
          result.error = 'Please! Check Your Input.';
          return result;
      }
  }


    /** getCalculationRadiusOfConvergenceCalculator
   * POST: /api/calculators-lol/radius-of-convergence-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */


    async  getCalculationRadiusOfConvergenceCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let wrt = body.tech_with;


      // Trim and validate input
      EnterEq = EnterEq?.trim();
      wrt = wrt?.trim();

      const invalidPattern = /[<>&=]|php|print_r|print|echo|script|%/i;

      if (!EnterEq || invalidPattern.test(EnterEq)) {
        return { error: 'Please Enter Valid Input.' };
      }

      if (!wrt) {
        return { error: 'Please Enter Valid Input.' };
      }

      // Clean and transform the equation
      let parem = EnterEq
        .replace(/ /g, '')
        .replace(/%20/g, '')
        .replace(/\+/g, 'plus')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/e\^sqrt\(x\)/g, 'exp(2*x)')
        .replace(/e\^/g, 'exp')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**');

      let enter = parem;
      let upr = parem.replace(/n/g, '(nplus1)');
      parem = `(${upr})/(${parem})`;

      try {
        const response = await axios.get('http://167.172.134.148/radius', {
          params: {
            equ: parem,
            wrt,
            enter,
          },
          timeout: 120000,
        });

        if (!response || !response.data) {
          return { error: 'Please! Check Your Input.' };
        }

        let buffer = response.data.split('@@@');

        const result = {
          tech_enter: buffer[0],
          tech_ans: buffer[1],
          tech_equs: buffer[2],
          tech_shareURL: '', // optional: you can build shareURL here if needed
        };

        return result;
      } catch (err) {
        return { error: 'Please! Check Your Input.' };
      }
    }

        /** getCalculationPowerSeriesCalculator
   * POST: /api/calculators-lol/power-series-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationPowerSeriesCalculator(body) {
          let EnterEq = body.tech_EnterEq;
        let point = body.tech_point;
        let n = body.tech_n;
        let wrt = body.tech_with;


      EnterEq = EnterEq?.trim();
      point = point?.toString().trim();
      n = n?.toString().trim();
      wrt = wrt?.trim();

      const invalidPattern = /[<>&=]|php|print_r|print|echo|script|%/i;

      if (!EnterEq || invalidPattern.test(EnterEq)) {
        return { error: 'Please! Check Your Input.' };
      }

      if (!wrt || isNaN(n) || isNaN(point)) {
        return { error: 'Please! Check Your Input.' };
      }

      // Clean and process EnterEq
      let parem = EnterEq
        .replace(/ /g, '')
        .replace(/\+/g, 'plus')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/e\^sqrt\(x\)/g, 'exp(2*x)')
        .replace(/e\^x/g, 'exp(x)')
        .replace(/e\^y/g, 'exp(y)')
        .replace(/e\^/g, 'exp')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**');

      try {
        const response = await axios.get('http://167.172.134.148/power_ser', {
          params: {
            equ: parem,
            wrt,
            how: n,
            point,
          },
          timeout: 120000,
        });

        if (!response || !response.data) {
          return { error: 'Please! Check Your Input.' };
        }

        const buffer = response.data.split('@@@');

        return {
          tech_ans: buffer[0],
          tech_enter: buffer[1]
        };
      } catch (err) {
        return { error: 'Please! Check Your Input.' };
      }
    }

     /** getCalculationSimpsonRuleCalculator
   * POST: /api/calculators-lol/simpsons-rule-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationSimpsonRuleCalculator(body) {
        let EnterEq = body.tech_EnterEq;
        let lb = body.tech_lb;
        let ub = body.tech_ub;
        let n = body.tech_n;
        let wrt = body.tech_with;


      EnterEq = EnterEq?.toString().trim();
      lb = parseFloat(lb);
      ub = parseFloat(ub);
      n = parseInt(n);
      wrt = wrt?.toString().trim();

      const invalidPattern = /[<>&=]|php|print_r|print|echo|script|%/i;

      if (!EnterEq || invalidPattern.test(EnterEq)) {
        return { error: 'Please! Check Your Input.' };
      }

      if (isNaN(lb) || isNaN(ub) || isNaN(n) || n % 2 !== 0) {
        return { error: 'Number of rectangles should be even number.' };
      }

      if (lb >= ub) {
        return { error: 'The lower limit should be less than the upper limit.' };
      }

      // Process equation
      let parem = EnterEq
        .replace(/ /g, '')
        .replace(/\+/g, 'plus')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/e\^sqrt\(x\)/g, 'exp(2*x)')
        .replace(/e\^/g, 'exp')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**');

      let diff = (ub - lb) / n;
      let final = lb;
      let limitArray = [lb];
      let limitString = `${lb}`;

      while (final < ub) {
        final = parseFloat((final + diff).toFixed(10)); // avoid floating point issues
        limitArray.push(final);
        limitString += `, ${final}`;
      }

      try {
        const response = await axios.get('http://167.172.134.148/simpsons', {
          params: {
            equ: parem,
            with: wrt,
            lb,
            ub,
            n,
            diff,
          },
          timeout: 120000,
        });

        const buffer = response.data.split('@@@');

        const errorValue = Math.abs((buffer[4] - buffer[1]) / buffer[4]);
        const steps = buffer[0].split('HA');

        return {
          tech_steps:steps,
          tech_res: buffer[1],
          tech_enter: buffer[2],
          tech_int: buffer[3],
          tech_intv: buffer[4],
          tech_errorans: errorValue,
          tech_ub:ub,
          tech_lb:lb,
          tech_n:n,
          tech_diff:diff,
          tech_limit: limitString,
          tech_limit_a: limitArray,
          tech_with: wrt,
        };
      } catch (err) {
        return { error: 'Please! Check Your Input.' };
      }
    }

    /** getCalculationCurlCalculator
   * POST: /api/calculators-lol/curl-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationCurlCalculator(body) {
        let xeq = body.tech_xeq;
        let yeq = body.tech_yeq;
        let zeq = body.tech_zeq;
        let x = body.tech_x;
        let y = body.tech_y;
        let z = body.tech_z;


      xeq = xeq?.toString().trim();
      yeq = yeq?.toString().trim();
      zeq = zeq?.toString().trim();
      const invalidPattern = /[<>&=]|php|print_r|print|echo|script|%/i;

      if (!xeq || !yeq || !zeq || invalidPattern.test(xeq) || invalidPattern.test(yeq) || invalidPattern.test(zeq)) {
        return { error: 'Please! Check Your Input.' };
      }

      const sanitize = eq => eq
        .replace(/ /g, '')
        .replace(/\+/g, 'plus')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/e\^sqrt\(x\)/g, 'exp(2*x)')
        .replace(/e\^/g, 'exp')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**');

      xeq = sanitize(xeq);
      yeq = sanitize(yeq);
      zeq = sanitize(zeq);

      const isPointProvided = !isNaN(x) && !isNaN(y) && !isNaN(z);

      try {
        const params = isPointProvided
          ? { xeq, yeq, zeq, x, y, z }
          : { xeq, yeq, zeq };

        const response = await axios.get('http://167.172.134.148/curl', {
          params,
          timeout: 120000,
        });

        const buffer = response.data.split('@@@');

        const result = {
          tech_enx: buffer[0],
          tech_eny: buffer[1],
          tech_enz: buffer[2],
          tech_one: buffer[3],
          tech_two: buffer[4],
          tech_three: buffer[5],
          tech_four: buffer[6],
          tech_five: buffer[7],
          tech_six: buffer[8],
          tech_ans1: buffer[9],
          tech_ans2: buffer[10],
          tech_ans3: buffer[11],
        };

        if (isPointProvided) {
          result.tech_ev1 = buffer[12];
          result.tech_ev2 = buffer[13];
          result.tech_ev3 = buffer[14];
        }

        return result;
      } catch (err) {
        return { error: 'Please! Check Your Input.' };
      }
    }
    /** getCalculationSaddlePointCalculator
   * POST: /api/calculators-lol/saddle-point-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationSaddlePointCalculator(body) {
      let  EnterEq  = body.tech_EnterEq;

      EnterEq = EnterEq?.toString().trim();
      const invalidPattern = /[<>&=]|php|print_r|print|echo|script|%/i;

      if (!EnterEq || invalidPattern.test(EnterEq)) {
        return { error: 'Please! Check Your Input.' };
      }

      let parem = EnterEq
        .replace(/ /g, '')
        .replace(/\+/g, 'plus')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/e\^sqrt\(x\)/g, 'exp(2*x)')
        .replace(/e\^x/g, 'exp(x)')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**');

      const wrt = 'xy';

      try {
        const response = await axios.get('http://167.172.134.148/saddle', {
          params: {
            equ: parem,
            wrt: wrt
          },
          timeout: 120000
        });

        const buffer = response.data.split('@@@');

        if (buffer[4] === '\\left[ \\right]') {
          return { error: 'no solution exist.' };
        }

        return {
          tech_buffer: buffer[0],
          tech_ans: buffer[1],
          tech_enter: buffer[2],
          tech_simple: buffer[3],
          tech_root: buffer[4],
          tech_step: buffer[5],
          tech_ans1: buffer[6],
          tech_step1: buffer[7],
          tech_step2: buffer[8],
          tech_en1: buffer[9],
          tech_en2: buffer[10],
          tech_wrt: 'xy',
        };
      } catch (error) {
        return { error: 'Please! Check Your Input.' };
      }
    }

        /** getCalculationImproperIntegralCalculator
   * POST: /api/calculators-lol/improper-integral-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async  getCalculationImproperIntegralCalculator(body) {
      let EnterEq = body.tech_EnterEq;
      let ub = body.tech_ub;
      let lb = body.tech_lb;
      let wrt = body.tech_with;


    EnterEq = EnterEq?.toString().trim();
    const invalidPattern = /[<>&=]|php|print_r|print|echo|script|%/i;

    if (!EnterEq || invalidPattern.test(EnterEq)) {
      return { error: 'Please! Check Your Input.' };
    }

    if (!ub || !lb || !wrt) {
      return { error: 'Please! Check Your Input.' };
    }

    // Sanitize expression
    let parem = EnterEq
      .replace(/ /g, '')
      .replace(/\+/g, 'plus')
      .replace(/{/g, '(')
      .replace(/}/g, ')')
      .replace(/xe\^/g, 'x*e^')
      .replace(/ye\^/g, 'y*e^')
      .replace(/e\^sqrt\(x\)/g, 'exp(2*x)')
      .replace(/e\^/g, 'exp')
      .replace(/exp\^/g, 'exp')
      .replace(/\^/g, '**');

    let upper = ub.replace(/\+/g, 'plus').replace(/inf|∞/gi, 'oo');
    let lower = lb.replace(/\+/g, 'plus').replace(/inf|∞/gi, 'oo');
    let wrtVar = wrt.trim();

    try {
      const response = await axios.get('http://167.172.134.148/improper', {
        params: {
          equ: parem,
          wrt: wrtVar,
          ub: upper,
          lb: lower
        },
        timeout: 120000
      });

      const buffer = response.data.split('@@@');

      return {
        tech_enter: buffer[0],
        tech_int: buffer[1],
        tech_res: buffer[2],
        tech_ans: buffer[3],
        tech_first: buffer[4],
        tech_sec: buffer[5],
        tech_res1: buffer[6],
      };
    } catch (error) {
      return { error: 'Please! Check Your Input.' };
    }
  }
    /** getCalculationFourierSeriesCalculator
   * POST: /api/calculators-lol/fourier-series-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationFourierSeriesCalculator(body) {
        let EnterEq = body.tech_EnterEq;
        let ub = body.tech_ub;
        let lb = body.tech_lb;
        let wrt = body.tech_with;


      EnterEq = EnterEq?.toString().trim();
      const invalidPattern = /[<>&=]|php|print_r|print|echo|script|%/i;

      if (!EnterEq || invalidPattern.test(EnterEq)) {
        return { error: 'Please! Check Your Input.' };
      }

      if (!ub || !lb || !wrt) {
        return { error: 'Please! Check Your Input.' };
      }

      // Clean equation
      let parem = EnterEq
        .replace(/ /g, '')
        .replace(/\+/g, 'plus')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/xe\^/g, 'x*e^')
        .replace(/ye\^/g, 'y*e^')
        .replace(/e\^sqrt\(x\)/g, 'exp(2*x)')
        .replace(/e\^/g, 'exp')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**');

      // Bounds replacement
      let upper = ub.replace(/\+/g, 'plus').replace(/inf|∞/gi, 'oo');
      let lower = lb.replace(/\+/g, 'plus').replace(/inf|∞/gi, 'oo');
      let wrtVar = wrt.trim();

      try {
        const response = await axios.get('http://167.172.134.148/fourier', {
          params: {
            equ: parem,
            wrt: wrtVar,
            ub: upper,
            lb: lower
          },
          timeout: 120000
        });

        const buffer = response.data.split('@@@');

        return {
          tech_enter: buffer[0],
          tech_a0: buffer[1],
          tech_an: buffer[2],
          tech_bn: buffer[3],
          tech_res: buffer[4],
          tech_t1: buffer[5],
          tech_t2: buffer[6],
          tech_t: buffer[7],
        };
      } catch (error) {
        return { error: 'Please! Check Your Input.' };
      }
    }

      /** getCalculationDivergenceCalculator
   * POST: /api/calculators-lol/divergence-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */


    async  getCalculationDivergenceCalculator(body) {
        let xeq = body.tech_xeq;
        let yeq = body.tech_yeq;
        let zeq = body.tech_zeq;
        let x = body.tech_x;
        let y = body.tech_y;
        let z = body.tech_z;

      const invalidPattern = /[<>&=]|php|print_r|print|echo|script|%/i;

      // Validate inputs
      if (!xeq || !yeq || !zeq || invalidPattern.test(xeq) || invalidPattern.test(yeq) || invalidPattern.test(zeq)) {
        return { error: 'Please! Check Your Input.' };
      }

      const sanitize = (expr) =>
        expr
          .replace(/ /g, '')
          .replace(/\+/g, 'plus')
          .replace(/{/g, '(')
          .replace(/}/g, ')')
          .replace(/xe\^/g, 'x*e^')
          .replace(/ye\^/g, 'y*e^')
          .replace(/e\^sqrt\(x\)/g, 'exp(2*x)')
          .replace(/e\^/g, 'exp')
          .replace(/exp\^/g, 'exp')
          .replace(/\^/g, '**');

      xeq = sanitize(xeq);
      yeq = sanitize(yeq);
      zeq = sanitize(zeq);

      const isValidNumber = (val) => !isNaN(val) && val !== null && val !== '';

      const params = { xeq, yeq, zeq };

      if (isValidNumber(x) && isValidNumber(y) && isValidNumber(z)) {
        params.x = x;
        params.y = y;
        params.z = z;
      }

      try {
        const response = await axios.get('http://167.172.134.148/divergence', {
          params,
          timeout: 120000,
        });

        const buffer = response.data.split('@@@');
        const result = {
          tech_enx: buffer[0],
          tech_eny: buffer[1],
          tech_enz: buffer[2],
          tech_one: buffer[3],
          tech_two: buffer[4],
          tech_three: buffer[5],
        };

        if (isValidNumber(x) && isValidNumber(y) && isValidNumber(z)) {
          result.tech_ev1 = buffer[6];
          result.tech_ev2 = buffer[7];
          result.tech_ev3 = buffer[8];
        }

        return result;
      } catch (error) {
        return { error: 'Please! Check Your Input.' };
      }
    }
      /** getCalculationLeastToGreatestCalculator
   * POST: /api/calculators-lol/least-to-greatest-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationLeastToGreatestCalculator(body) {
              let x = body.tech_x;
            let order = body.tech_order;
        const result = {};

        // Input validation
        if (!x) {
            result.error = 'Please! Check Your Input.';
            return result;
        }

        // Check for forbidden characters
        const forbiddenPattern = /<|>|&|php|print_r|print|echo|script|=|[a-zA-Z]|&/i;
        if (forbiddenPattern.test(x)) {
            result.error = 'Please Enter Valid Input.';
            return result;
        }

        try {
            // Process input string
            const processedX = x.replace(/plus/g, '+');
            const input = processedX.split(',').map(item => item.trim());

            const filter = {};
            const filter1 = {};

            for (const value of input) {
                let ans;
                const index = value;

                // Check for fractions
                const chech_frac = value.split('/');
                if (chech_frac.length > 1) {
                    let up = chech_frac[0];
                    const btm = parseFloat(chech_frac[1]);

                    // Handle mixed numbers (e.g., "1 1/2")
                    const check_up = up.split(' ');
                    if (check_up.length > 1) {
                        const sahi = parseFloat(check_up[0]);
                        up = parseFloat(check_up[1]);

                        // Handle negative mixed numbers
                        if (sahi < 0 && up > 0) {
                            up = up * (-1);
                        }

                        ans = (btm * sahi + up) / btm;
                    } else {
                        ans = parseFloat(up) / btm;
                    }
                } else {
                    // Handle percentages and simple expressions
                    const processedValue = value.replace(/%/g, '/100').replace(/\s+/g, '+');
                    
                    // Use safe evaluation (in a real app, consider a more secure expression evaluator)
                    ans = eval(processedValue);
                }

                // Validate the result
                if (isNaN(ans)) {
                    result.error = 'Please Enter Valid Input.';
                    return result;
                }

                filter[index] = ans;
                filter1[ans.toString()] = index;
            }

            // Sort the results
            const sorted = { ...filter };
            const sortedArray = Object.entries(sorted);
            
            if (order === '1') {
                sortedArray.sort((a, b) => a[1] - b[1]);
            } else {
                sortedArray.sort((a, b) => b[1] - a[1]);
            }

            // Convert back to object
            const sortedResult = {};
            for (const [key, value] of sortedArray) {
                sortedResult[key] = value;
            }

            // Prepare response
            result.tech_solve = filter;
            result.tech_order = order;
            result.tech_ans = sortedResult;
            result.tech_filter1 = filter1;

            return result;

        } catch (error) {
            result.error = 'Please! Check Your Input.';
            return result;
        }
    }

    /** getCalculationAngleOfElevationCalculator
   * POST: /api/calculators-lol/angle-of-elevation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationAngleOfElevationCalculator(body) {
    let to_cal = body.tech_to_cal;
    let vertical = body.tech_vertical;
    let vertical_unit = body.tech_vertical_unit;
    let hori = body.tech_hori;
    let hori_unit = body.tech_hori_unit;
    let angle = body.tech_angle;
    let angle_unit = body.tech_angle_unit;


      function unitToMeter(value, unit) {
        const conversion = {
          cm: 0.01,
          km: 1000,
          in: 0.0254,
          ft: 0.3048,
          yd: 0.9144,
          mi: 1609.3,
        };
        return value * (conversion[unit] || 1);
      }

      const param = {};

      try {
        if (to_cal === "1") {
          if (isFinite(vertical) && isFinite(hori)) {
            vertical = unitToMeter(Number(vertical), vertical_unit);
            hori = unitToMeter(Number(hori), hori_unit);
            const angleRad = Math.atan(vertical / hori);
            const ang_deg = (angleRad * 180) / Math.PI;
            const grade = vertical / hori;
            const gradep = grade * 100;

            param.tech_angle = angleRad;
            param.tech_ang_deg = ang_deg;
            param.tech_grade = grade;
            param.tech_gradep = gradep;
          } else {
            param.error = 'Please! Check Your Input.';
          }
        } else if (to_cal === "2") {
          if (isFinite(angle) && isFinite(hori)) {
            hori = unitToMeter(Number(hori), hori_unit);
            const angleRad = angle_unit === "deg" ? (Number(angle) * Math.PI) / 180 : Number(angle);
            const vertical = hori * Math.tan(angleRad);
            const grade = vertical / hori;
            const gradep = grade * 100;

            param.tech_vertical = vertical.toFixed(4) + ' ' + hori_unit;
            param.tech_grade = grade;
            param.tech_gradep = gradep;
          } else {
            param.error = 'Please! Check Your Input.';
          }
        } else {
          if (isFinite(vertical) && isFinite(angle)) {
            vertical = unitToMeter(Number(vertical), vertical_unit);
            const angleRad = angle_unit === "deg" ? (Number(angle) * Math.PI) / 180 : Number(angle);
            const hori = vertical / Math.tan(angleRad);
            const grade = vertical / hori;
            const gradep = grade * 100;

            param.tech_hori = hori.toFixed(4) + ' ' + vertical_unit;
            param.tech_grade = grade;
            param.tech_gradep = gradep;
          } else {
            param.error = 'Please! Check Your Input.';
          }
        }
      } catch (e) {
        param.error = 'An error occurred during calculation.';
      }

      return param;
    }

  /** getCalculationDilationCalculator
   * POST: /api/calculators-lol/dilation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationDilationCalculator(body) {
          let nbr = body.tech_nbr;
          let dil = body.tech_dil;
          let a1 = body.tech_a1;
          let z1 = body.tech_z1;
          let a2 = body.tech_a2;
          let z2 = body.tech_z2;
          let a3 = body.tech_a3;
          let z3 = body.tech_z3;
          let a4 = body.tech_a4;
          let z4 = body.tech_z4;
          let a5 = body.tech_a5;
          let z5 = body.tech_z5;
          let a6 = body.tech_a6;
          let z6 = body.tech_z6;
          let a7 = body.tech_a7;
          let z7 = body.tech_z7;
          let a8 = body.tech_a8;
          let z8 = body.tech_z8;


      nbr = parseInt(nbr);
      dil = parseFloat(dil);

      const aValues = [a1, a2, a3, a4, a5, a6, a7, a8];
      const zValues = [z1, z2, z3, z4, z5, z6, z7, z8];
      const abc = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];

      const param = {};

      let checkInputs = true;

      for (let i = 0; i < nbr; i++) {
        const aVal = parseFloat(aValues[i]);
        const zVal = parseFloat(zValues[i]);

        if (!isFinite(aVal) || !isFinite(zVal)) {
          checkInputs = false;
          break;
        }
      }

      if (isFinite(dil) && checkInputs) {
        param.tech_aval = aValues;
        param.tech_zval = zValues;
        param.tech_abc = abc;
        param.tech_dil = dil;
      } else {
        param.error = 'Please! Check Your Input.';
      }

      return param;
    }

  /** getCalculationPercentageIncreaseCalculator
   * POST: /api/calculators-lol/percentage-increase-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationPercentageIncreaseCalculator(body) {
    let start = body.tech_start;
    let final = body.tech_final;


      start = parseFloat(start);
      final = parseFloat(final);

      const param = {};

      if (isFinite(start) && isFinite(final)) {
        let ans1 = (final - start) / Math.abs(start);
        let ans = ans1 * 100;
        let dif = final - start;

        param.tech_ans1 = parseFloat(ans1.toFixed(3));
        param.tech_ans = ans;
        param.tech_dif = dif;
      } else {
        param.error = 'Please! Check Your Input.';
      }

      return param;
    }

 /** getCalculationPercentageDecreaseCalculator
   * POST: /api/calculators-lol/percentage-decrease-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
   async  getCalculationPercentageDecreaseCalculator(body) {
    let start = body.tech_start;
    let final = body.tech_final;

  start = parseFloat(start);
  final = parseFloat(final);

  const param = {};

  if (isFinite(start) && isFinite(final)) {
    let ans = (final - start) / Math.abs(start);
    ans = ans * -100;
    let dif = final - start;

    param.tech_ans = ans;
    param.tech_dif = dif;
  } else {
    param.error = 'Please! Check Your Input.';
  }

  return param;
}


 /** getCalculationSphereCalculator
   * POST: /api/calculators-lol/sphere-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async  getCalculationSphereCalculator(body) {
    let slct1 = body.tech_slct1;
    let rad = body.tech_rad;
    let pi = body.tech_pi;

    let param = {};

    rad = parseFloat(rad);
    pi = parseFloat(pi);

    if (isFinite(rad) && isFinite(pi)) {
      let volume, surfacearea, circumference;
      let v1, c1, s1;

      if (slct1 === '1') {
        volume = (4 / 3) * pi * rad ** 3;
        surfacearea = pi * rad ** 2;
        circumference = 2 * pi * rad;
        v1 = (4 / 3) * rad ** 3;
        c1 = 2 * rad;
        s1 = c1 ** 2;
      } else if (slct1 === '2') {
        const originalVolume = rad; // input is volume
        rad = Math.cbrt((3 * originalVolume) / (4 * pi));
        volume = originalVolume;
        circumference = Math.pow(pi, 2 / 3) * Math.pow(6 * volume, 1 / 3);
        surfacearea = Math.pow(pi, 1 / 3) * Math.pow(6 * volume, 2 / 3);
        v1 = volume / pi;
        c1 = circumference / pi;
        s1 = surfacearea / pi;
      } else if (slct1 === '3') {
        const originalArea = rad; // input is surface area
        rad = Math.sqrt(originalArea / (4 * pi));
        surfacearea = originalArea;
        circumference = Math.sqrt(pi * surfacearea);
        volume = Math.pow(surfacearea, 1.5) / (6 * Math.sqrt(pi));
        v1 = volume / pi;
        c1 = circumference / pi;
        s1 = surfacearea / pi;
      } else if (slct1 === '4') {
        const originalCirc = rad; // input is circumference
        rad = originalCirc / (2 * pi);
        circumference = originalCirc;
        surfacearea = Math.pow(circumference, 2) / pi;
        volume = Math.pow(circumference, 3) / (6 * pi * pi);
        v1 = volume / pi;
        c1 = circumference / pi;
        s1 = surfacearea / pi;
      }

      param.tech_rad = +rad.toFixed(5);
      param.tech_vol = +volume.toFixed(5);
      param.tech_v1 = +v1.toFixed(5);
      param.tech_c1 = +c1.toFixed(5);
      param.tech_s1 = +s1.toFixed(5);
      param.tech_area = +surfacearea.toFixed(5);
      param.tech_c = +circumference.toFixed(5);
    } else {
      param.error = 'Please! Check Your Input.';
    }

    return param;
  }

 /** getCalculationPercentageDifferenceCalculator
   * POST: /api/calculators-lol/percentage-difference-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
async  getCalculationPercentageDifferenceCalculator(body) {
  let start = parseFloat(body.tech_start);
  let final = parseFloat(body.tech_final);

  let param = {};

  if (isFinite(start) && isFinite(final)) {
    let ans = (Math.abs(start - final) / ((start + final) / 2)) * 100;
    let dif = final - start;

    param.tech_ans = ans;
    param.tech_dif = dif;
  } else {
    param.error = 'Please! Check Your Input.';
  }

  return param;
}


 /** getCalculationStandardFormtoSlopeInterceptFormCalculator
   * POST: /api/calculators-lol/standard-form-to-slope-intercept-form
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async  getCalculationStandardFormtoSlopeInterceptFormCalculator(body) {
    let a = body.tech_a;
      let b = body.tech_b;
      let c = body.tech_c;
      let to = body.tech_to;

      const result = {};

      // Helper functions
      function gcd(a, b) {
          a = Math.abs(a);
          b = Math.abs(b);

          if (a < b) {
              [b, a] = [a, b];
          }
          if (b === 0) {
              return 1;
          }
          let r = a % b;
          while (r > 0) {
              a = b;
              b = r;
              r = a % b;
          }
          return b;
      }

      function reduce(num, den) {
          const g = gcd(num, den);
          return [num / g, den / g];
      }

      function toFrac(num) {
          const numStr = num.toString();
          const parts = numStr.split('.');
          let div = '1';
          let count = 0;
          
          if (parts.length > 1) {
              count = parts[1].length;
          }
          
          for (let i = 1; i <= count; i++) {
              div += '0';
          }
          
          const divNum = parseInt(div);
          let upr;
          
          if (parts.length > 1) {
              upr = parseInt(parts[0] + parts[1]);
          } else {
              upr = parseInt(numStr);
          }
          
          return reduce(upr, divNum);
      }

      function lcmofn(numbers, n) {
          let ans = numbers[0];
          for (let i = 1; i < n; i++) {
              ans = ((numbers[i] * ans) / (gcd(numbers[i], ans)));
          }
          return ans;
      }

      try {
          if (to == 1) {
              // Convert standard form to slope-intercept form
              let aNum = parseFloat(a);
              let bNum = parseFloat(b);
              let cNum = parseFloat(c);

              // Handle fractions
              const checkA = a.toString().split('/');
              if (checkA.length === 2) {
                  aNum = parseFloat(checkA[0]) / parseFloat(checkA[1]);
              }

              const checkB = b.toString().split('/');
              if (checkB.length === 2) {
                  bNum = parseFloat(checkB[0]) / parseFloat(checkB[1]);
              }

              const checkC = c.toString().split('/');
              if (checkC.length === 2) {
                  cNum = parseFloat(checkC[0]) / parseFloat(checkC[1]);
              }

              if (isNaN(aNum) || isNaN(bNum) || isNaN(cNum) || bNum === 0) {
                  result.error = 'Please! Check Your Input.';
                  return result;
              }

              const m = (-1 * aNum) / bNum;
              const nb = cNum / bNum;
              const angle = Math.round(Math.atan(m) * (180 / Math.PI) * 10000) / 10000;

              result.tech_m = Math.round(m * 100000) / 100000;
              result.tech_nb = Math.round(nb * 100000) / 100000;
              result.tech_angle = angle;
          } else {
              // Convert slope-intercept form to standard form
              let mNum = parseFloat(a);
              let cNum = parseFloat(b);

              // Handle fractions
              const checkA = a.toString().split('/');
              const checkB = b.toString().split('/');

              let upr, btm, upr1, btm1;
              let lcm;

              if (checkA.length === 1 && checkB.length === 1) {
                  [upr, btm] = toFrac(mNum);
                  [upr1, btm1] = toFrac(cNum);
                  lcm = lcmofn([btm, btm1], 2);
              } else if (checkA.length === 2 && checkB.length === 1) {
                  upr = parseFloat(checkA[0]);
                  btm = parseFloat(checkA[1]);
                  [upr1, btm1] = toFrac(cNum);
                  lcm = lcmofn([btm, btm1], 2);
              } else if (checkA.length === 1 && checkB.length === 2) {
                  [upr, btm] = toFrac(mNum);
                  upr1 = parseFloat(checkB[0]);
                  btm1 = parseFloat(checkB[1]);
                  lcm = lcmofn([btm, btm1], 2);
              } else if (checkA.length === 2 && checkB.length === 2) {
                  upr = parseFloat(checkA[0]);
                  btm = parseFloat(checkA[1]);
                  upr1 = parseFloat(checkB[0]);
                  btm1 = parseFloat(checkB[1]);
                  lcm = lcmofn([btm, btm1], 2);
              }

              const A = (-1) * upr * (lcm / btm);
              const B = 1 * (lcm / btm1);
              const C = upr1 * (lcm / btm1);

              result.tech_A = A;
              result.tech_B = B;
              result.tech_C = C;
          }

          return result;
      } catch (error) {
          result.error = 'Please! Check Your Input.';
          return result;
      }
  }


 /** getCalculationPolygonCalculator
   * POST: /api/calculators-lol/polygon-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationPolygonCalculator(body) {
        let num1 = body.tech_operations;
      let num2 = body.tech_npolygon;
      let num3 = body.tech_calculation;
      let Label = body.tech_labl;
      let pie = body.tech_pie;
      let unit = body.tech_units;

        const result = {};

        if (isNaN(Label) || isNaN(pie)) {
            result.error = 'Please Check Your Input';
            return result;
        }

        let nvalue = num1;
        
        if (nvalue == 15) {
            nvalue = num2;
            if (isNaN(nvalue) || nvalue <= 0) {
                result.error = 'Enter number of polygon:';
                return result;
            }
        }

        let side_a, inradius, circumradius, area, perimeter, interior, extrior;

        try {
            const pieValue = parseFloat(pie);
            const labelValue = parseFloat(Label);
            const nvalueNum = parseFloat(nvalue);

            switch (num3) {
                case '01':
                    const num01 = pieValue / nvalueNum;
                    const co = 1 / Math.tan(num01);
                    const res = 0.5 * labelValue;
                    inradius = res * co;
                    const se = 1 / Math.cos(num01);
                    circumradius = inradius * se;
                    const rr = inradius * inradius;
                    const nr = nvalueNum * rr;
                    const ta = Math.tan(num01);
                    area = nr * ta;
                    perimeter = nvalueNum * labelValue;
                    const sub = nvalueNum - 2;
                    const di = sub / nvalueNum;
                    interior = di * 180;
                    extrior = 360 / nvalueNum;
                    side_a = labelValue;
                    break;

                case '02':
                    const a2 = Math.tan(pieValue / nvalueNum);
                    const a0 = 2 * labelValue;
                    side_a = a2 * a0;
                    const r1 = 0.5 * side_a;
                    const r2 = 1 / a2;
                    inradius = r1 * r2;
                    const R1 = 1 / Math.cos(pieValue / nvalueNum);
                    circumradius = inradius * R1;
                    const A1 = inradius * inradius;
                    const A2 = nvalueNum * A1;
                    area = A2 * a2;
                    perimeter = nvalueNum * side_a;
                    const sub2 = nvalueNum - 2;
                    const di2 = sub2 / nvalueNum;
                    interior = di2 * 180;
                    extrior = 360 / nvalueNum;
                    break;

                case '03':
                    const Ra = 2 * labelValue;
                    const Ra1 = Math.sin(pieValue / nvalueNum);
                    side_a = Ra * Ra1;
                    inradius = labelValue * Math.cos(pieValue / nvalueNum);
                    const RR1 = 1 / Math.cos(pieValue / nvalueNum);
                    circumradius = inradius * RR1;
                    area = nvalueNum * Math.pow(inradius, 2) * Math.tan(pieValue / nvalueNum);
                    perimeter = nvalueNum * side_a;
                    const sub3 = nvalueNum - 2;
                    const di3 = sub3 / nvalueNum;
                    interior = di3 * 180;
                    extrior = 360 / nvalueNum;
                    break;

                case '04':
                    nvalue = num1;
                    const Aa1 = Math.tan(pieValue / nvalueNum);
                    const Aa2 = 4 * Aa1 * labelValue;
                    const Aa3 = Aa2 / nvalueNum;
                    side_a = Math.sqrt(Aa3);
                    const Ar1 = 1 / Math.tan(pieValue / nvalueNum);
                    inradius = 0.5 * side_a * Ar1;
                    const AR1 = 1 / Math.cos(pieValue / nvalueNum);
                    circumradius = inradius * AR1;
                    perimeter = nvalueNum * side_a;
                    const sub4 = nvalueNum - 2;
                    const di4 = sub4 / nvalueNum;
                    interior = di4 * 180;
                    extrior = 360 / nvalueNum;
                    area = labelValue;
                    break;

                case '05':
                    side_a = labelValue / nvalueNum;
                    const pr1 = 1 / Math.tan(pieValue / nvalueNum);
                    inradius = 0.5 * side_a * pr1;
                    const pR1 = 1 / Math.cos(pieValue / nvalueNum);
                    circumradius = inradius * pR1;
                    const pA1 = inradius * inradius;
                    const pA2 = nvalueNum * pA1;
                    const pA3 = Math.tan(pieValue / nvalueNum);
                    area = pA2 * pA3;
                    const sub5 = nvalueNum - 2;
                    const di5 = sub5 / nvalueNum;
                    interior = di5 * 180;
                    extrior = 360 / nvalueNum;
                    perimeter = labelValue;
                    break;

                default:
                    result.error = 'Invalid calculation type';
                    return result;
            }

            result.tech_nvalue = nvalue;
            result.tech_side_a = side_a;
            result.tech_inradius = inradius;
            result.tech_circumradius = circumradius;
            result.tech_area = area;
            result.tech_perimeter = perimeter;
            result.tech_interior = interior;
            result.tech_extrior = extrior;
            result.tech_unit = unit;

            return result;

        } catch (error) {
            result.error = 'Please Check Your Input';
            return result;
        }
    }

 /** getCalculationGoldenRatioCalculator
   * POST: /api/calculators-lol/golden-ratio-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationGoldenRatioCalculator(body) {
    let selection = body.tech_selection;
    let a = body.tech_a;
    let value = 1.6180339887498;
    let param = {};

    a = parseFloat(a);

    if (isFinite(a)) {
      let longer_section, shorter_section, sum;

      if (selection === '1') {
        longer_section = a;
        shorter_section = a / value;
        sum = shorter_section + a;
      }

      if (selection === '2') {
        shorter_section = a;
        longer_section = value * a;
        sum = longer_section + a;
      }

      if (selection === '3') {
        sum = a;
        longer_section = a / value;
        shorter_section = longer_section / value;
      }

      param.tech_value = value;
      param.tech_a = +a.toFixed(5);
      param.tech_sum = +sum.toFixed(5);
      param.tech_longer_section = +longer_section.toFixed(5);
      param.tech_shorter_section = +shorter_section.toFixed(5);
    } else {
      param.error = 'Please Check Your Input.';
    }

    return param;
  }


 /** getCalculationImproperFractionstoMixedNumbersCalculator
   * POST: /api/calculators-lol/improper-fractions-to-mixed-numbers
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async  getCalculationImproperFractionstoMixedNumbersCalculator(body) {
    let uper = body.tech_uper;
    let btm = body.tech_btm;
    let param = {};

    uper = parseFloat(uper);
    btm = parseFloat(btm);

    if (isFinite(uper) && isFinite(btm)) {
      if (uper >= btm) {
        let rem = uper % btm;
        let q = Math.floor(uper / btm);
        param.tech_q = q;
        param.tech_rem = rem;
      } else {
        param.RESULT = 1;
      }
    } else {
      param.error = "Please Check Your Input.";
    }

    return param;
  }

 /** getCalculationMixedNumberstoImproperFractionsCalculator
   * POST: /api/calculators-lol/mixed-numbers-to-improper-fractions
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async  getCalculationMixedNumberstoImproperFractionsCalculator(body) {
    let whole = body.tech_whole;
    let uper = body.tech_uper;
    let btm = body.tech_btm;

    let param = {};

    whole = parseFloat(whole);
    uper = parseFloat(uper);
    btm = parseFloat(btm);

    if (isFinite(uper) && isFinite(btm) && isFinite(whole)) {
      let multi = btm * whole;
      let plus = multi + uper;

      param.tech_multi = multi;
      param.tech_plus = plus;
    } else {
      param.error = "Please Check Your Input.";
    }

    return param;
  }

   /** getCalculationLocalMaximaandMinimaCalculator
   * POST: /api/calculators-lol/local-maxima-and-minima-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

async  getCalculationLocalMaximaandMinimaCalculator(body) {
  let EnterEq = body.tech_equation;

  let param = {};

  // Input validation
  if (
    !EnterEq ||
    typeof EnterEq !== 'string' ||
    /[<>&]|php|print_r|print|echo|script|=|%/i.test(EnterEq)
  ) {
    param.error = 'Please! Check Your Input.';
    return param;
  }

  // Cleaning and transforming the equation
  let parem = EnterEq.replace(/\s+/g, '')
    .replace(/\+/g, 'plus')
    .replace(/{/g, '(')
    .replace(/}/g, ')')
    .replace(/e\^x/g, 'exp(x)')
    .replace(/exp\^/g, 'exp')
    .replace(/\^/g, '**')
    .replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

  try {
    let wrt = /y/i.test(parem) && /x/i.test(parem) ? 'xy' : 'x';

    const response = await axios.get('http://167.172.134.148/local', {
      params: {
        equ: parem,
        wrt: wrt,
      },
      timeout: 120000, // 120 seconds
    });

    const buffer = response.data.split('@@@');

    if (buffer[4] === '\\left[ \\right]') {
      param.error = 'No solution exists';
      return param;
    }

    param.tech_buffer = buffer[0];
    param.tech_ans = buffer[1];
    param.tech_enter = buffer[2];
    param.tech_simple = buffer[3];
    param.tech_root = buffer[4];
    param.tech_fac = buffer[7];

    if (wrt === 'xy') {
      param.tech_step = buffer[5];
      param.tech_ans1 = buffer[6];
      param.tech_wrt = 'xy';
    } else {
      param.tech_mini = buffer[5];
      param.tech_maxi = buffer[6];
    }

    return param;
  } catch (err) {
    param.error = 'Please! Check Your Input.';
    return param;
  }
}

   /** getCalculationLCDCalculator
   * POST: /api/calculators-lol/lcd-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationLCDCalculator(body) {
        let x = body.tech_x;
        const result = {};

        if (!x || typeof x !== 'string') {
            result.error = 'Please! Check Your Input.';
            return result;
        }

        x = x.trim();
        const input = x.split(',');
        const upper = [];
        const btm = [];
        let check = true;

        for (let value of input) {
            value = value.trim();
            const fraction_check = value.split('/');
            if (fraction_check.length === 2) {
                const mixed_check = fraction_check[0].trim().split(' ');
                if (mixed_check.length === 2) {
                    const [whole, numerator] = mixed_check.map(Number);
                    const denominator = parseFloat(fraction_check[1]);

                    if (isNaN(whole) || isNaN(numerator) || isNaN(denominator)) {
                        check = false;
                        break;
                    }

                    const up = (whole * denominator) + numerator;
                    upper.push(up);
                    btm.push(denominator);
                } else if (mixed_check.length === 1) {
                    const num = parseFloat(fraction_check[0]);
                    const den = parseFloat(fraction_check[1]);
                    if (isNaN(num) || isNaN(den)) {
                        check = false;
                        break;
                    }
                    upper.push(num);
                    btm.push(den);
                } else {
                    check = false;
                    break;
                }
            } else if (fraction_check.length === 1) {
                const val = parseFloat(value);
                if (isNaN(val)) {
                    check = false;
                    break;
                }
                upper.push(val);
                btm.push(1);
            } else {
                check = false;
                break;
            }
        }

        if (!check) {
            result.error = 'Please! Check Your Input.';
            return result;
        }

        // GCD function
        function gcd(a, b) {
            return b === 0 ? a : gcd(b, a % b);
        }

        // LCM of array
        function lcmOfArray(arr) {
            return arr.reduce((a, b) => (a * b) / gcd(a, b));
        }

        const lcm = lcmOfArray(btm);
        const multiple = btm.map(den => lcm / den);

        result.tech_input = input;
        result.tech_upper = upper;
        result.tech_btm = btm;
        result.tech_multiple = multiple;
        result.tech_lcm = lcm;
        return result;
    }

   /** getCalculationUnitRateCalculator
   * POST: /api/calculators-lol/unit-rate-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationUnitRateCalculator(body) {
        let a = parseFloat(body.tech_a);
        let b = parseFloat(body.tech_b);
        let c = body.tech_c; // unused, but extracted for completeness
        let d = body.tech_d; // unused, but extracted for completeness

        const result = {};

        if (!isNaN(a) && !isNaN(b)) {
            if (b !== 0) {
                let ans = a / b;
                let ans2 = ans;
                let ans3 = ans;

                if (ans.toString().includes('.')) {
                    ans = ans.toFixed(2);
                    ans2 = ans2.toFixed(2);
                    ans3 = ans3.toFixed(2);
                }

                result.tech_ans = ans;
                result.tech_ans2 = ans2;
                result.tech_ans3 = ans3;
            } else {
                result.error = 'Denominator cannot be zero.';
            }
        } else {
            result.error = 'Please! Check Your Input.';
        }

        return result;
    } 

     /** getCalculationEquivalentFractionsCalculator
   * POST: /api/calculators-lol/equivalent-fractions-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationEquivalentFractionsCalculator(body) {
        let want_to = parseInt(body.tech_want_to);
        let is_frac = parseInt(body.tech_is_frac);
        let s1 = parseFloat(body.tech_s1);
        let n1 = parseFloat(body.tech_n1);
        let d1 = parseFloat(body.tech_d1);
        let s2 = parseFloat(body.tech_s2);
        let n2 = parseFloat(body.tech_n2);
        let d2 = parseFloat(body.tech_d2);
        let s3 = parseFloat(body.tech_s3);
        let n3 = parseFloat(body.tech_n3);
        let d3 = parseFloat(body.tech_d3);
        let no = parseInt(body.tech_no);

        const result = {};

        function gcd(a, b) {
            a = Math.abs(a);
            b = Math.abs(b);
            if (a < b) [a, b] = [b, a];
            if (b === 0) return 1;
            let r = a % b;
            while (r > 0) {
                a = b;
                b = r;
                r = a % b;
            }
            return b;
        }

        function reduce(num, den) {
            const g = gcd(num, den);
            return [num / g, den / g];
        }

        if (want_to === 1) {
            if (!isNaN(n1) && !isNaN(d1)) {
                let up;
                if (is_frac === 2 && !isNaN(s1)) {
                    if (n1 < 0) {
                        result.error = 'Numerator and denominator must be positive';
                        return result;
                    }
                    up = s1 < 1 ? (d1 * s1 - n1) : (d1 * s1 + n1);
                } else {
                    up = n1;
                }

                if (no > 100) no = 100;

                let upper = [];
                let bottom = [];

                for (let i = 1; i <= no; i++) {
                    upper.push(up * i);
                    bottom.push(d1 * i);
                }

                result.tech_upper = upper;
                result.tech_bottom = bottom;
                return result;
            } else {
                result.error = 'Please Check Your Input';
                return result;
            }
        } else {
            if (!isNaN(n2) && !isNaN(d2) && !isNaN(n3) && !isNaN(d3)) {
                let up1, up2, input1, input2;

                if (is_frac === 2 && !isNaN(s2)) {
                    if (n2 < 0) {
                        result.error = 'Numerator and denominator must be positive';
                        return result;
                    }
                    up1 = s2 < 1 ? (d2 * s2 - n2) : (d2 * s2 + n2);
                    input1 = `${s2} ${n2}/${d2}`;
                } else {
                    up1 = n2;
                    input1 = `${n2}/${d2}`;
                }

                if (is_frac === 2 && !isNaN(s3)) {
                    if (n3 < 0) {
                        result.error = 'Numerator and denominator must be positive';
                        return result;
                    }
                    up2 = s3 < 1 ? (d3 * s3 - n3) : (d3 * s3 + n3);
                    input2 = `${s3} ${n3}/${d3}`;
                } else {
                    up2 = n3;
                    input2 = `${n3}/${d3}`;
                }

                const [fupr, fbtm] = reduce(up1, d2);
                const [fupr1, fbtm1] = reduce(up2, d3);

                const same = (fupr === fupr1 && fbtm === fbtm1) ? 'yes' : 'no';
                const sign = same === 'yes' ? '=' : '≠';

                result.tech_same = same;
                result.tech_sign = sign;
                result.tech_input1 = input1;
                result.tech_input2 = input2;
                return result;
            } else {
                result.error = 'Please Check Your Input';
                return result;
            }
        }
    }

     /** getCalculationComparingFractionsCalculator
   * POST: /api/calculators-lol/comparing-fractions-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationComparingFractionsCalculator(body) {
      let first = body.tech_first;
      let second = body.tech_second;

      const result = {};

      if (!first || !second) {
        result.error = 'Please! Check Your Input.';
        return result;
      }

      function parseValue(value) {
        value = value.trim();
        if (value.includes('%')) {
          const num = parseFloat(value.replace('%', ''));
          if (!isNaN(num)) {
            return num / 100;
          } else {
            return null;
          }
        }

        const fracParts = value.split('/');
        if (fracParts.length === 2) {
          const mixedParts = fracParts[0].trim().split(' ');
          if (mixedParts.length === 2) {
            const [whole, numerator] = mixedParts.map(Number);
            const denominator = parseFloat(fracParts[1]);
            if (!isNaN(whole) && !isNaN(numerator) && !isNaN(denominator)) {
              return (whole * denominator + numerator) / denominator;
            } else {
              return null;
            }
          } else if (mixedParts.length === 1) {
            const numerator = parseFloat(fracParts[0]);
            const denominator = parseFloat(fracParts[1]);
            if (!isNaN(numerator) && !isNaN(denominator)) {
              return numerator / denominator;
            } else {
              return null;
            }
          } else {
            return null;
          }
        } else if (fracParts.length > 2) {
          return null;
        } else {
          const num = parseFloat(value);
          return !isNaN(num) ? num : null;
        }
      }

      const nbr1 = parseValue(first);
      const nbr2 = parseValue(second);

      if (nbr1 === null || nbr2 === null) {
        result.error = 'Please Enter Valid Input.';
        return result;
      }

      let sign = '=';
      if (nbr1 > nbr2) sign = '>';
      else if (nbr1 < nbr2) sign = '<';

      result.tech_nbr1 = nbr1;
      result.tech_nbr2 = nbr2;
      result.tech_sign = sign;
      return result;
    }


   /** getCalculationTimetoDecimalCalculator
   * POST: /api/calculators-lol/time-to-decimal-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationTimetoDecimalCalculator(body) {
    let hh = body.tech_hh;
    let mm = body.tech_mm;
    let ss = body.tech_ss;

    const result = {};

    if ((hh === undefined || hh === '') && (mm === undefined || mm === '') && (ss === undefined || ss === '')) {
      result.error = 'Please Check Your Input.';
      return result;
    }

    let hour = 0;
    let min = 0;
    let sec = 0;

    if (!isNaN(hh)) {
      hour = parseFloat(hh);
    }
    if (!isNaN(mm)) {
      min = parseFloat(mm);
    }
    if (!isNaN(ss)) {
      sec = parseFloat(ss);
    }

    let hours = hour + (min / 60) + (sec / 3600);
    let mins = (hour * 60) + min + (sec / 60);
    let secs = (hour * 3600) + (min * 60) + sec;

    result.tech_hour = hour.toString().padStart(2, '0');
    result.tech_min = min.toString().padStart(2, '0');
    result.tech_sec = sec.toString().padStart(2, '0');
    result.tech_hours = hours;
    result.tech_mins = mins;
    result.tech_secs = secs;

    return result;
  }


  /** getCalculationPercenttoDecimalCalculator
   * POST: /api/calculators-lol/percent-to-decimal-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

      async  getCalculationPercenttoDecimalCalculator(body) {
      let per = body.tech_per;

      const result = {};

      if (!isNaN(per)) {
        let ans = parseFloat(per) / 100;
        result.tech_ans = ans;
      } else {
        result.error = 'Please! Check Your Input.';
      }

      return result;
    }

  /** getCalculationDecimaltoPercentCalculator
   * POST: /api/calculators-lol/decimal-to-percent-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationDecimaltoPercentCalculator(body) {
      let per = body.tech_per;

      const result = {};

      if (!isNaN(per)) {
        let ans = parseFloat(per) * 100;
        result.tech_ans = ans;
      } else {
        result.error = 'Please! Check Your Input.';
      }

      return result;
    }


  /** getCalculationIntegerCalculator
   * POST: /api/calculators-lol/integer-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async  getCalculationIntegerCalculator(body) {
    let opr = body.tech_opr;
    let a = parseFloat(body.tech_a);
    let b = parseFloat(body.tech_b);

    const result = {};

    if (!isNaN(a) && !isNaN(b)) {
      let ansText = '';
      let ans = '';

      switch (parseInt(opr)) {
        case 1:
          ansText = 'a + b = ?';
          ans = `${a} + ${b} = ${a + b}`;
          break;
        case 2:
          ansText = 'a - b = ?';
          ans = `${a} - ${b} = ${a - b}`;
          break;
        case 3:
          ansText = 'a x b = ?';
          ans = `${a} x ${b} = ${a * b}`;
          break;
        case 4:
          ansText = 'a ÷ b = ?';
          ans = `${a} ÷ ${b} = ${b !== 0 ? (a / b).toFixed(5) : 'Infinity'}`;
          break;
        case 5:
          ansText = `a<sup class="font-s-14">b</sup> = ?`;
          ans = `${a}<sup class="font-s-14">${b}</sup> = ${Math.pow(a, b)}`;
          break;
        case 6:
          ansText = `<sup class="font-s-14">${b}</sup>√a = ?`;
          ans = `<sup class="font-s-14">${b}</sup>√${a} = ${Math.pow(a, 1 / b).toFixed(5)}`;
          break;
        case 7:
          ansText = `log<sub class="font-s-14">${a}</sub>${b} = ?`;
          ans = `log<sub class="font-s-14">${a}</sub>${b} = ${Math.log(b) / Math.log(a)}`;
          break;
        default:
          result.error = 'Invalid operation';
          return result;
      }

      result.tech_ansText = ansText;
      result.tech_ans = ans;
    } else {
      result.error = 'Please! Check Your Input.';
    }

    return result;
  }


  /** getCalculationMultiplicativeInverseCalculator
   * POST: /api/calculators-lol/multiplicative-inverse-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationMultiplicativeInverseCalculator(body) {
      let dec = body.tech_dec;
      let is_frac = parseInt(body.tech_is_frac);
      let s1 = parseFloat(body.tech_s1);
      let n1 = parseFloat(body.tech_n1);
      let d1 = parseFloat(body.tech_d1);

      let result = {};
      let check = true;
      let upr, btm;

      if (is_frac === 1) {
        if (!isNaN(dec)) {
          upr = parseFloat(dec);
          btm = 1;
        } else {
          check = false;
        }
      } else if (is_frac === 2) {
        if (!isNaN(n1) && !isNaN(d1)) {
          upr = n1;
          btm = d1;
        } else {
          check = false;
        }
      } else {
        if (!isNaN(s1) && !isNaN(n1) && !isNaN(d1)) {
          if (n1 < 0) {
            result.error = 'Numerator and denominator must be positive.';
            return result;
          }
          upr = s1 < 1 ? (d1 * s1) - n1 : (d1 * s1) + n1;
          btm = d1;
        } else {
          check = false;
        }
      }

      if (check) {
        result.tech_ans = parseFloat((btm / upr).toFixed(8));
        result.tech_upr = upr;
        result.tech_btm = btm;
      } else {
        result.error = 'Please Enter Valid Input.';
      }

      return result;
    }

  /** getCalculationInverseModuloCalculator
   * POST: /api/calculators-lol/inverse-modulo-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationInverseModuloCalculator(body) {
    let opr = body.tech_opr;
      let a = body.tech_a;
      let b = body.tech_b;


      a = Number(a);
      b = Number(b);
      opr = Number(opr);

      function xgcd(a, b) {
        let a1 = 1, b1 = 0, a2 = 0, b2 = 1;
        let aneg = 1, bneg = 1;
        let flag = false;
        let result = [];

        if (a < 0) { a = -a; aneg = -1; }
        if (b < 0) { b = -b; bneg = -1; }
        if (b > a) {
          [a, b] = [b, a];
          flag = true;
        }

        while (true) {
          let quot = Math.floor(a / b) * -1;
          a %= b;
          a1 += quot * a2;
          b1 += quot * b2;

          if (a === 0 && !flag) return [b * bneg, a2, b2];
          if (a === 0 && flag) return [b * bneg, b2, a2];

          quot = Math.floor(b / a) * -1;
          b %= a;
          a2 += quot * a1;
          b2 += quot * b1;

          if (b === 0 && !flag) return [a * aneg, a1, b1];
          if (b === 0 && flag) return [a * aneg, b1, a1];
        }
      }

      if (isFinite(a) && isFinite(b)) {
        let m = b;
        let res;

        if (opr === 1) {
          let [gcd, inv] = xgcd(a, m);
          if (Math.abs(gcd) === 1) {
            while (inv < 0) inv += m;
            res = inv;
          } else {
            res = 'no';
          }
        } else if (opr === 2) {
          let res1 = -a, res2 = -a;
          while ((res1 < 0 || res1 >= m) && (res2 < 0 || res2 >= m)) {
            res1 += m;
            res2 -= m;
          }
          res = (res1 >= 0 && res1 < m) ? res1 : res2;
        }

        return {
          tech_res:res,
        };
      } else {
        return {
          error: 'Please! Check Your Input.'
        };
      }
    }


    /** getCalculationEquationLineCalculatorCalculator
   * POST: /api/calculators-lol/equation-of-a-line-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationEquationLineCalculatorCalculator(body) {
      let type = body.tech_type;
      let x1 = body.tech_x1;
      let x2 = body.tech_x2;
      let y1 = body.tech_y1;
      let y2 = body.tech_y2;
      let x3 = body.tech_x3;
      let y3 = body.tech_y3;

      let result = {};

      if (type === '2') {
        if (!isNaN(x1) && !isNaN(x2) && !isNaN(y1) && !isNaN(y2)) {
          let x = x2 - x1;
          let y = y2 - y1;
          let slope = +(y / x).toFixed(4);
          let angle = +(Math.atan(slope) * (180 / Math.PI)).toFixed(4);
          let distance = +(Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2))).toFixed(4);
          let b = +(y1 - (slope * x1)).toFixed(2);

          result = {
            tech_type: type,
            tech_x: x,
            tech_y: y,
            tech_b: b,
            tech_slope: slope,
            tech_angle: `${angle} deg`,
            tech_distance: distance,
          };
        } else {
          return { error: 'Please Check Your Input.' };
        }

      } else if (type === '1') {
        let slope = x2;
        if (!isNaN(x1) && !isNaN(y1) && !isNaN(slope)) {
          let angle = +(Math.atan(slope) * (180 / Math.PI)).toFixed(4);
          let b = +(y1 - (slope * x1)).toFixed(4);

          result = {
            tech_type: type,
            tech_b: b,
            tech_slope: slope,
            tech_angle: `${angle} deg`,
          };
        } else {
          return { error: 'Please Check Your Input.' };
        }

      } else if (type === '3') {
        let b = x1;
        let slope = x2;
        if (!isNaN(b) && !isNaN(slope)) {
          let angle = +(Math.atan(slope) * (180 / Math.PI)).toFixed(4);

          result = {
            tech_type: type,
            tech_b: b,
            tech_slope: slope,
            tech_angle: `${angle} deg`,
          };
        } else {
          return { error: 'Please Check Your Input.' };
        }

      } else if (type === '4') {
        if (!isNaN(x1) && !isNaN(x2) && !isNaN(y1) && !isNaN(y2) && !isNaN(x3) && !isNaN(y3)) {
          let f_down = y1 - x1;
          let s_down = y2 - x2;
          let t_down = y3 - x3;

          result = {
            tech_type: type,
            tech_f_down: f_down,
            tech_s_down: s_down,
            tech_t_down: t_down,
          };
        } else {
          return { error: 'Please Check Your Input.' };
        }
      }

      return result;
    }


    /** getCalculationFractionExponentCalculator
   * POST: /api/calculators-lol/fraction-exponent-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationFractionExponentCalculator(body) {
      let x = body.tech_x;
      let n = body.tech_n;
      let d = body.tech_d;

      let result = {};

      if (!isNaN(x) && !isNaN(n) && !isNaN(d)) {
        if (d != 0) {
          if (Number.isInteger(n)) {
            let all_roots = [];
            let answer, a, ans_f;

            if (x >= 0) {
              a = Math.pow(x, n);
              ans_f = n / d;
              answer = Math.pow(x, ans_f);

              let z = x;
              let r_f = Math.pow(x, 2);
              let r = Math.sqrt(r_f);
              let theta = 0;
              let power = 1 / d;
              let r_pow = Math.pow(r, power);

              if (d < 0) d = -1 * d;

              for (let i = 0; i < d; i++) {
                let f_step = 2 * 180 * i;
                let uper_fstep = theta + f_step;
                let f_ans2 = uper_fstep / d;
                let cos_fans2 = Math.cos(f_ans2 * (Math.PI / 180));
                let sin_fans2 = Math.sin(f_ans2 * (Math.PI / 180));
                let cos_fans = +(r_pow * cos_fans2).toFixed(6);
                let sin_fans = +(r_pow * sin_fans2).toFixed(6);
                if (sin_fans < 0) {
                  sin_fans = -sin_fans;
                  all_roots.push(`${cos_fans}-${sin_fans}i`);
                } else {
                  all_roots.push(`${cos_fans}+${sin_fans}i`);
                }
              }

            } else {
              x = -1 * x;
              a = Math.pow(x, n);
              ans_f = n / d;
              answer = Math.pow(x, ans_f) + "i";

              let z = x;
              let r_f = Math.pow(x, 2);
              let r = Math.sqrt(r_f);
              let theta = 0;
              let power = 1 / d;
              let r_pow = Math.pow(r, power);

              for (let i = 0; i < d; i++) {
                let f_step = 2 * 180 * i;
                let uper_fstep = theta + f_step;
                let f_ans2 = uper_fstep / d;
                let cos_fans2 = Math.cos(f_ans2 * (Math.PI / 180));
                let sin_fans2 = Math.sin(f_ans2 * (Math.PI / 180));
                let cos_fans = +(r_pow * cos_fans2).toFixed(6);
                let sin_fans = +(r_pow * sin_fans2).toFixed(6);
                if (sin_fans < 0) {
                  sin_fans = -sin_fans;
                  all_roots.push(`${cos_fans}-${sin_fans}i`);
                } else {
                  all_roots.push(`${cos_fans}+${sin_fans}i`);
                }
              }
            }

            result = {
              tech_all_roots: all_roots,
              tech_a: a,
              tech_ans_f: ans_f,
              tech_answer: answer,
            };
          } else {
            return { error: 'Use only integers for the Numerator.' };
          }
        } else {
          return { error: 'Enter a non-zero Denominator.' };
        }
      } else {
        return { error: 'Please! Check Your Input.' };
      }

      return result;
    }


    /** getCalculationAmplitudeAndPeriodCalculator
   * POST: /api/calculators-lol/amplitude-and-period-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationAmplitudeAndPeriodCalculator(body) {
      let trigonometric_unit = body.tech_trigonometric_unit;
      let first_number = body.tech_first_number;
      let second_number = body.tech_second_number;
      let third_number = body.tech_third_number;
      let fourth_number = body.tech_fourth_number;

      let result = {};

      if (
        !isNaN(first_number) &&
        !isNaN(second_number) &&
        !isNaN(third_number) &&
        !isNaN(fourth_number)
      ) {
        if (first_number == 0) {
          return { error: "For A=0, this is not a trigonometric function!" };
        } else if (second_number == 0) {
          return { error: "For B=0, this is not a trigonometric function!" };
        } else {
          result.first_number = first_number;
          result.second_number = 2 / second_number;
          result.third_number = third_number / second_number;
          result.fourth_number = fourth_number;
          result.fifth_number = second_number;
          result.sixth_number = third_number;
          result.operation = trigonometric_unit;
          return result;
        }
      } else {
        return { error: "Please! Check Your Input." };
      }
    }

      /** getCalculationExponentialGrowthCalculator
   * POST: /api/calculators-lol/exponential-growth-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationExponentialGrowthCalculator(body) {
      let operations = body.tech_operations;
      let first = body.tech_first;
      let second = body.tech_second;
      let third = body.tech_third;
      let four = body.tech_four;
      let t_unit = body.tech_t_unit;

      let result = {};

      function timer(unit, value) {
        switch (unit) {
          case "sec": return value / 31540000;
          case "min": return value / 525600;
          case "hr": return value / 8760;
          case "days": return value / 365;
          case "wks": return value / 52.143;
          case "mon": return value / 12;
          default: return value;
        }
      }

      third = timer(t_unit, third);
      let final, jawab;

      if (operations === "1") {
        if (!isNaN(second) && !isNaN(third) && !isNaN(four)) {
          let divide = second / 100;
          let plus = 1 + divide;
          let power = Math.pow(plus, third);
          final = four / power;
          final = final.toFixed(4);
          jawab = "Initial Value (x₀)";
        } else {
          return { error: "Please! Check Your Input." };
        }
      } else if (operations === "2") {
        if (!isNaN(first) && !isNaN(third) && !isNaN(four)) {
          let divide1 = four / first;
          let log_div1 = Math.log(divide1);
          let divide2 = log_div1 / third;
          let antilog = Math.exp(divide2);
          let minus = antilog - 1;
          final = minus * 100;
          final = final.toFixed(4);
          jawab = "Rate of Change (r)";
        } else {
          return { error: "Please! Check Your Input." };
        }
      } else if (operations === "3") {
        if (!isNaN(first) && !isNaN(second) && !isNaN(four)) {
          let divide = four / first;
          let divide2 = second / 100;
          let plus = 1 + divide2;
          let log1 = Math.log(plus);
          let log2 = Math.log(divide);
          final = log2 / log1;
          final = final.toFixed(4);
          jawab = "Elapsed Time (t)";
        } else {
          return { error: "Please! Check Your Input." };
        }
      } else if (operations === "4") {
        if (!isNaN(first) && !isNaN(second) && !isNaN(third)) {
          let divide = second / 100;
          let plus = 1 + divide;
          let power = Math.pow(plus, third);
          final = first * power;
          final = final.toFixed(4);
          jawab = "Final Value x(t)";
        } else {
          return { error: "Please! Check Your Input." };
        }
      }

      result.final = final;
      result.operations = operations;
      result.jawab = jawab;
      return result;
    }


       /** getCalculationPerfectSquareTrinomialCalculator
   * POST: /api/calculators-lol/perfect-square-trinomial-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationPerfectSquareTrinomialCalculator(body) {
      let A = body.tech_A;
      let B = body.tech_B;
      let C = body.tech_C;

      let result = {};

      if (!isNaN(A) && !isNaN(B) && !isNaN(C)) {
        let ds = Math.pow(B, 2) - 4 * A * C;
        result.tech_sd = ds;
        return result;
      } else {
        return { error: "Please! Check Your Input." };
      }
    }

    /** getCalculationPowerReducingFormulaCalculator
   * POST: /api/calculators-lol/power-reducing-formula-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationPowerReducingFormulaCalculator(body) {
      let know = body.tech_know;
      let angle = body.tech_angle;
      let angle_unit = body.tech_angle_unit;
      let sinx = body.tech_sinx;
      let cosx = body.tech_cosx;
      let tanx = body.tech_tanx;
      let sin2x = body.tech_sin2x;
      let cos2x = body.tech_cos2x;
      let tan2x = body.tech_tan2x;

      let result = {};

      function degToRad(deg) {
        return (deg * Math.PI) / 180;
      }

      function radToDeg(rad) {
        return (rad * 180) / Math.PI;
      }

      if (know == 1) {
        if (!isNaN(angle)) {
          if (angle_unit === "rad") {
            angle = radToDeg(angle);
          }

          let sin = Math.sin(degToRad(angle));
          let cos = Math.cos(degToRad(angle));
          let tan = (angle == 90 || angle == 270) ? Infinity : Math.tan(degToRad(angle));
          let sin2 = (1 - Math.cos(2 * degToRad(angle))) / 2;
          let cos2 = (1 + Math.cos(2 * degToRad(angle))) / 2;
          let tan2 = sin2 / cos2;
          let sin3 = (3 * sin - Math.sin(3 * degToRad(angle))) / 4;
          let cos3 = (1 / 4) * Math.cos(3 * degToRad(angle)) + (3 / 4) * cos;
          let tan3 = sin3 / cos3;
          let sin4 = (3 - 4 * Math.cos(2 * degToRad(angle)) + Math.cos(4 * degToRad(angle))) / 8;
          let cos4 = (3 + 4 * Math.cos(2 * degToRad(angle)) + Math.cos(4 * degToRad(angle))) / 8;
          let tan4 = sin4 / cos4;

          Object.assign(result, {
              tech_sin:sin,
              tech_cos:cos,
              tech_tan:tan,
              tech_sin2:sin2,
              tech_cos2:cos2,
              tech_tan2:tan2,
              tech_sin3:sin3,
              tech_cos3:cos3,
              tech_tan3:tan3,
              tech_sin4:sin4, 
              tech_cos4:cos4,
              tech_tan4:tan4,
          });

          return result;
        } else {
          return { error: "Please Check Your Input." };
        }
      } else if (know == 2) {
        if (!isNaN(sinx) && !cosx && !tanx && !sin2x && !cos2x && !tan2x) {
          angle = Math.asin(sinx);
        } else if (!sinx && !isNaN(cosx) && !tanx && !sin2x && !cos2x && !tan2x) {
          angle = Math.acos(cosx);
        } else if (!sinx && !cosx && !isNaN(tanx) && !sin2x && !cos2x && !tan2x) {
          angle = Math.atan(tanx);
        } else if (!sinx && !cosx && !tanx && !isNaN(sin2x) && !cos2x && !tan2x) {
          angle = Math.asin(Math.sqrt(sin2x));
        } else if (!sinx && !cosx && !tanx && !sin2x && !isNaN(cos2x) && !tan2x) {
          angle = Math.acos(Math.sqrt(cos2x));
        } else if (!sinx && !cosx && !tanx && !sin2x && !cos2x && !isNaN(tan2x)) {
          angle = Math.atan(Math.sqrt(tan2x));
        } else {
          return { error: "Please Enter any one of the known function values." };
        }

        angle = radToDeg(angle);

        let sin = Math.sin(degToRad(angle));
        let cos = Math.cos(degToRad(angle));
        let tan = (angle == 90 || angle == 270) ? Infinity : Math.tan(degToRad(angle));
        let sin2 = (1 - Math.cos(2 * degToRad(angle))) / 2;
        let cos2 = (1 + Math.cos(2 * degToRad(angle))) / 2;
        let tan2 = sin2 / cos2;
        let sin3 = (3 * sin - Math.sin(3 * degToRad(angle))) / 4;
        let cos3 = (1 / 4) * Math.cos(3 * degToRad(angle)) + (3 / 4) * cos;
        let tan3 = sin3 / cos3;
        let sin4 = (3 - 4 * Math.cos(2 * degToRad(angle)) + Math.cos(4 * degToRad(angle))) / 8;
        let cos4 = (3 + 4 * Math.cos(2 * degToRad(angle)) + Math.cos(4 * degToRad(angle))) / 8;
        let tan4 = sin4 / cos4;

        Object.assign(result, {
          tech_angle:angle,
          tech_sin:sin, 
          tech_cos:cos, 
          tech_tan:tan,
          tech_sin2:sin2, 
          tech_cos2:cos2, 
          tech_tan2:tan2,
          tech_sin3:sin3, 
          tech_cos3:cos3, 
          tech_tan3:tan3,
          tech_sin4:sin4, 
          tech_cos4:cos4, 
          tech_tan4:tan4,
        });


        return result;
      }
    }


     /** getCalculationDiamondCalculator
   * POST: /api/calculators-lol/diamond-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationDiamondCalculator(body) {
      let factor_a = parseFloat(body.tech_factor_a);
      let factor_b = parseFloat(body.tech_factor_b);
      let product = parseFloat(body.tech_product);
      let sum = parseFloat(body.tech_sum);

      let result = {};
      let facta, factb, pro, su, met;

      if (!isNaN(factor_a) && !isNaN(factor_b) && isNaN(product) && isNaN(sum)) {
        facta = factor_a;
        factb = factor_b;
        pro = factor_a * factor_b;
        su = factor_a + factor_b;
        met = 1;
      } else if (!isNaN(factor_a) && !isNaN(product) && isNaN(factor_b) && isNaN(sum)) {
        facta = factor_a;
        factb = parseFloat((product / factor_a).toFixed(3));
        pro = product;
        su = facta + factb;
        met = 2;
      } else if (!isNaN(factor_a) && !isNaN(sum) && isNaN(factor_b) && isNaN(product)) {
        facta = factor_a;
        factb = sum - factor_a;
        su = sum;
        pro = facta * factb;
        met = 3;
      } else if (!isNaN(factor_b) && !isNaN(product) && isNaN(factor_a) && isNaN(sum)) {
        factb = factor_b;
        facta = parseFloat((product / factor_b).toFixed(2));
        pro = product;
        su = facta + factb;
        met = 4;
      } else if (!isNaN(factor_b) && !isNaN(sum) && isNaN(factor_a) && isNaN(product)) {
        factb = factor_b;
        facta = sum - factor_b;
        su = sum;
        pro = facta * factor_b;
        met = 5;
      } else if (!isNaN(product) && !isNaN(sum) && isNaN(factor_a) && isNaN(factor_b)) {
        let found = false;
        for (let i = 1; i * i <= product; i++) {
          if (product % i === 0) {
            let j = product / i;
            if (i + j === sum) {
              facta = i;
              factb = j;
              pro = product;
              su = sum;
              met = 6;
              found = true;
              break;
            }
          }
        }
        if (!found) {
          return {
            error: `Cannot find two factors of ${product} that sum equal to ${sum}`
          };
        }
      } else {
        return { error: "Please! Enter any two values." };
      }

      result.tech_facta = facta;
      result.tech_factb = factb;
      result.tech_pro = pro;
      result.tech_su = su;
      result.tech_met = met;

      return result;
    }


     /** getCalculationCrossMultiplyCalculator
   * POST: /api/calculators-lol/cross-multiply-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationCrossMultiplyCalculator(body) {
      let a = parseFloat(body.tech_a);
      let b = parseFloat(body.tech_b);
      let c = parseFloat(body.tech_c);
      let d = parseFloat(body.tech_d);

      let result = {};

      const isA = !isNaN(a);
      const isB = !isNaN(b);
      const isC = !isNaN(c);
      const isD = !isNaN(d);

      const totalInputs = [isA, isB, isC, isD].filter(Boolean).length;

      if (totalInputs === 4) {
        result.error = "Please Enter 3 numbers & leave 1 field empty!";
        return result;
      }

      if (!isA && isB && isC && isD) {
        result.tech_a_val = (b * c) / d;
      } else if (isA && !isB && isC && isD) {
        result.tech_b_val = (a * d) / c;
      } else if (isA && isB && !isC && isD) {
        result.tech_c_val = (a * d) / b;
      } else if (isA && isB && isC && !isD) {
        result.tech_d_val = (b * c) / a;
      } else {
        result.error = "Please! Check Your Input.";
        return result;
      }

      return result;
    }


       /** getCalculationAreaSemicircleCalculator
   * POST: /api/calculators-lol/area-of-a-semicircle
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationAreaSemicircleCalculator(body) {
      let radius = parseFloat(body.tech_radius);
      let selection = body.tech_selection;
      let pi = parseFloat(body.tech_pi);
      let units = body.tech_units;

      function convertToCm(unit, val) {
        if (unit === "cm") return val;
        if (unit === "m") return val * 100;
        if (unit === "in") return val * 2.54;
        if (unit === "ft") return val * 30.48;
        if (unit === "yd") return val * 91.44;
        return NaN;
      }

      let result = {};

      let rad, per, da, ac, a;

      if (["1", "2", "3", "4", "6"].includes(selection) && !isNaN(radius) && !isNaN(pi) && radius > 0) {
        let ans = convertToCm(units, radius);

        switch (selection) {
          case "1": // Given Radius
            rad = ans;
            da = rad * 2;
            a = (pi * rad * rad) / 2;
            per = (pi * rad) + (2 * rad);
            ac = 3.14 * rad;
            break;

          case "2": // Given Diameter
            da = ans;
            rad = da / 2;
            ac = rad * 3.14;
            per = (pi * rad) + (2 * rad);
            a = (pi * rad * rad) / 2;
            break;

          case "3": // Given Arc Length
            ac = ans;
            rad = ac / pi;
            da = rad * 2;
            per = (pi * rad) + (2 * rad);
            a = (pi * rad * rad) / 2;
            break;

          case "4": // Given Perimeter
            per = ans;
            rad = per / (pi + 2);
            da = rad * 2;
            ac = rad * pi;
            a = (pi * rad * rad) / 2;
            break;

          case "6": // Given Area
            a = ans;
            rad = Math.sqrt((2 * a) / pi);
            da = rad * 2;
            ac = rad * 3.14;
            per = (pi * rad) + (2 * rad);
            break;
        }

        result.tech_radius = parseFloat(rad.toFixed(3));
        result.tech_perimeter = parseFloat(per.toFixed(3));
        result.tech_diameter = parseFloat(da.toFixed(3));
        result.tech_arc_length = parseFloat(ac.toFixed(3));
        result.tech_area = parseFloat(a.toFixed(3));
        result.tech_unit = units;
        result.tech_pi = pi;
        result.tech_selection = selection;
        return result;
      } else {
        return { error: "Please! Check Your Input.111" };
      }
    }

      /** getCalculationAreaDegreeandLeadingCoefficientCalculator
   * POST: /api/calculators-lol/degree-and-leading-coefficient
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationAreaDegreeandLeadingCoefficientCalculator(body) {
    let equ = body.tech_equ;
    let vari = body.tech_vari;

      let range = [...'abcdefghijklmnopqrstuvwxyz'];

      if (equ && range.includes(vari.toLowerCase())) {
        let input = equ;
        input = input.replace(/ /g, '');
        input = input.replace(/\+/g, 'plus');
        input = input.replace(/{/g, '(');
        input = input.replace(/}/g, ')');
        input = input.replace(/xe\^/g, 'x*e^');
        input = input.replace(/ye\^/g, 'y*e^');
        input = input.replace(/e\^/g, 'exp');
        input = input.replace(/exp\^/g, 'exp');
        input = input.replace(/\^/g, '**');
        input = input.replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

        try {
          const response = await axios.post('http://167.172.134.148/degree', new URLSearchParams({ equ: input }), {
            timeout: 120000,
          });

          let buffer = response.data;
          input = buffer[1];

          let jawab = buffer[0].trim()
            .replace(/\\left\(/g, '')
            .replace(/\\right\)/g, '')
            .replace(/\\/g, '');

          let parts = jawab.split(',');
          let final = {};

          for (let value of parts) {
            if (value.toLowerCase().includes(vari.toLowerCase())) {
              let index = value.split(vari);
              if (index.length === 2) {
                let keyx = index[0].replace(/ /g, '');
                let valuex = index[1].replace(/[\^{\} ]/g, '');
                if (!valuex && !isNaN(keyx)) {
                  final[keyx] = 1;
                } else if (!isNaN(keyx) && !isNaN(valuex)) {
                  final[keyx] = parseFloat(valuex);
                }
              }
            }
          }

          if (Object.keys(final).length === 0) {
            return {
              status: 'error',
              error: 'Please! Check Your Input.',
            };
          } else {
            let degree = Math.max(...Object.values(final));
            let lead = Object.keys(final).find(key => final[key] === degree);

            return {
              tech_status: 'success',
              tech_input: input,
              tech_lead: lead,
              tech_degree: degree,
            };
          }
        } catch (err) {
          return {
            status: 'error',
            error: 'Please! Check Your Input.',
          };
        }
      } else {
        return {
          status: 'error',
          error: 'Please! Check Your Input.',
        };
      }
    }


      /** getCalculationEquivalentExpressionsCalculator
   * POST: /api/calculators-lol/equivalent-expressions-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationEquivalentExpressionsCalculator(body) {
      let  equ  = body.tech_equ;

      if (equ) {
        let input = equ;

        input = input.replace(/ /g, '');
        input = input.replace(/\+/g, 'plus');
        input = input.replace(/{/g, '(');
        input = input.replace(/}/g, ')');
        input = input.replace(/xe\^/g, 'x*e^');
        input = input.replace(/ye\^/g, 'y*e^');
        input = input.replace(/e\^/g, 'exp');
        input = input.replace(/exp\^/g, 'exp');
        input = input.replace(/\^/g, '**');
        input = input.replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

        try {
          const response = await axios.post('http://167.172.134.148/equ_exp', new URLSearchParams({ equ: input }), {
            timeout: 120000,
          });

          let buffer = response.data;

          return {
            tech_status: 'success',
            tech_ans: buffer[1],
          };
        } catch (err) {
          return {
            status: 'error',
            error: 'Please! Check Your Input.'
          };
        }
      } else {
        return {
          status: 'error',
          error: 'Please! Check Your Input.'
        };
      }
    }


     /** getCalculationDescartesRuleSignsCalculator
   * POST: /api/calculators-lol/descartes-rule-of-signs-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationDescartesRuleSignsCalculator(body) {
          let  equ  = body.tech_equ;
          let  vari  = body.tech_vari;

      let range = [...'abcdefghijklmnopqrstuvwxyz'];

      if (equ && range.includes(vari.toLowerCase())) {
        let input = equ;

        input = input.replace(/ /g, '');
        input = input.replace(/\+/g, 'plus');
        input = input.replace(/{/g, '(');
        input = input.replace(/}/g, ')');
        input = input.replace(/xe\^/g, 'x*e^');
        input = input.replace(/ye\^/g, 'y*e^');
        input = input.replace(/e\^/g, 'exp');
        input = input.replace(/exp\^/g, 'exp');
        input = input.replace(/\^/g, '**');
        input = input.replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

        let input1 = input.replace(new RegExp(vari, 'g'), `(-${vari})`);

        try {
          const response = await axios.post(
            'http://167.172.134.148/descartes',
            new URLSearchParams({
              equ: input,
              equ1: input1,
              wrt: vari
            }),
            { timeout: 120000 }
          );

          let buffer = response.data;
          let cof1 = buffer[2].split(',').filter(v => v.trim() !== '');
          let cof2 = buffer[3].split(',').filter(v => v.trim() !== '');

          let sign1 = [];
          for (let value of cof1) {
            let num = parseFloat(value.trim());
            if (!isNaN(num)) {
              sign1.push(num < 0 ? '-' : '+');
            } else {
              return {
                status: 'error',
                error: 'Please! Enter Univariate Polynomial'
              };
            }
          }

          let sign2 = [];
          for (let value of cof2) {
            let num = parseFloat(value.trim());
            if (!isNaN(num)) {
              sign2.push(num < 0 ? '-' : '+');
            } else {
              return {
                status: 'error',
                error: 'Please! Enter Univariate Polynomial'
              };
            }
          }

          let positive = 0;
          for (let i = 0; i < sign1.length - 1; i++) {
            if (sign1[i] !== sign1[i + 1]) {
              positive++;
            }
          }

          let negative = 0;
          for (let i = 0; i < sign2.length - 1; i++) {
            if (sign2[i] !== sign2[i + 1]) {
              negative++;
            }
          }

          return {
            tech_status: 'success',
            tech_input1: buffer[0],
            tech_input2: buffer[1],
            tech_positive:positive,
            tech_negative:negative,
            tech_cof1:cof1,
            tech_cof2:cof2,
          };
        } catch (err) {
          return {
            status: 'error',
            error: 'Please! Check Your Input.'
          };
        }
      } else {
        return {
          status: 'error',
          error: 'Please Check Your Input!'
        };
      }
    }


    /** getCalculationFunctionOperationsCalculator
   * POST: /api/calculators-lol/function-operations-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationFunctionOperationsCalculator(body) {
    let fx = body.tech_fx;
    let gx = body.tech_gx;
    let point = body.tech_point;
    let variable = body.tech_variable;


      if (fx && gx) {
        let parem = fx
          .replace(/ /g, '')
          .replace(/−/g, '-')
          .replace(/plus/g, '+')
          .replace(/{/g, '(')
          .replace(/}/g, ')')
          .replace(/e\^/g, 'exp')
          .replace(/exp\^/g, 'exp')
          .replace(/\^/g, '**');

        let parem1 = gx
          .replace(/ /g, '')
          .replace(/−/g, '-')
          .replace(/plus/g, '+')
          .replace(/{/g, '(')
          .replace(/}/g, ')')
          .replace(/e\^/g, 'exp')
          .replace(/exp\^/g, 'exp')
          .replace(/\^/g, '**');

        let postData = new URLSearchParams();
        postData.append('fx', parem);
        postData.append('gx', parem1);

        if (!isNaN(point)) {
          postData.append('x', variable);
          postData.append('point', point);
        }

        try {
          const response = await axios.post('http://167.172.134.148/fun-op', postData, {
            timeout: 120000
          });

          let buffer = response.data;

          let result = {
            tech_fox: buffer[0],
            tech_gox: buffer[1],
            tech_add: buffer[2],
            tech_sub: buffer[3],
            tech_mul: buffer[4],
            tech_div: buffer[5],
            tech_x: variable,
          };

          if (!isNaN(point)) {
            result.tech_add1 = buffer[6];
            result.tech_sub1 = buffer[7];
            result.tech_mul1 = buffer[8];
            result.tech_div1 = buffer[9];
            result.tech_point = point;
          }

          return result;
        } catch (error) {
          return {
            status: 'error',
            error: 'Please! Check Your Input.'
          };
        }
      } else {
        return {
          status: 'error',
          error: 'Please! Check Your Input.'
        };
      }
    }

    /** getCalculationMultiplyingPolynomialsCalculator
   * POST: /api/calculators-lol/function-operations-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationMultiplyingPolynomialsCalculator(body) {
    let first = body.tech_first;
    let second = body.tech_second;


      if (first && second) {
        let parem = first
          .replace(/ /g, '')
          .replace(/−/g, '-')
          .replace(/plus/g, '+')
          .replace(/{/g, '(')
          .replace(/}/g, ')')
          .replace(/e\^/g, 'exp')
          .replace(/exp\^/g, 'exp')
          .replace(/\^/g, '**');

        let parem1 = second
          .replace(/ /g, '')
          .replace(/−/g, '-')
          .replace(/plus/g, '+')
          .replace(/{/g, '(')
          .replace(/}/g, ')')
          .replace(/e\^/g, 'exp')
          .replace(/exp\^/g, 'exp')
          .replace(/\^/g, '**');

        try {
          const response = await axios.post('http://167.172.134.148/multiplying', new URLSearchParams({
            equ: parem,
            equ1: parem1
          }), { timeout: 120000 });

          let buffer = response.data;
          let input1 = buffer[0];
          let input2 = buffer[1];
          let ans = buffer[2];
          let left = buffer[3];
          let right = buffer[4];
          let nextstep = buffer[5];

          nextstep = nextstep
            .replace(/\\left\[/g, '')
            .replace(/\\right\]/g, '')
            .replace(/ /g, '')
            .replace(/\\/g, '')
            .replace(/frac/g, '\\dfrac')
            .replace(/sqrt/g, '\\sqrt')
            .split(',');

          let lefts = left
            .replace(/\\left\(/g, '')
            .replace(/\\right\)/g, '')
            .replace(/ /g, '')
            .replace(/\\/g, '')
            .replace(/frac/g, '\\dfrac')
            .replace(/sqrt/g, '\\sqrt')
            .split(',');

          let rights = right
            .replace(/\\left\(/g, '')
            .replace(/\\right\)/g, '')
            .replace(/ /g, '')
            .replace(/\\/g, '')
            .replace(/frac/g, '\\dfrac')
            .replace(/sqrt/g, '\\sqrt')
            .split(',');

          let step = '';
          let next = '';

          for (let value of lefts) {
            for (let value1 of rights) {
              step += step ? ` + (${value}) \\times (${value1})` : `(${value}) \\times (${value1})`;
            }
          }

          for (let value of nextstep) {
            next += next ? ` + ( ${value} )` : `( ${value} )`;
          }

          return {
            tech_input1:input1,
            tech_input2:input2,
            tech_step:step,
            tech_next:next,
            tech_ans:ans,
          };
        } catch (error) {
          return {
            error: 'Please! Check Your Input.'
          };
        }
      } else {
        return {
          error: '2 values should not be same.'
        };
      }
    }

      /** getCalculationInequalityCalculator
   * POST: /api/calculators-lol/inequality-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationInequalityCalculator(body) {
    let select = body.tech_select;
    let equ1 = body.tech_equ1;
    let con = body.tech_con;
    let equ2 = body.tech_equ2;

      let vari = 'x';

      if (!equ1) {
        return { error: 'Equation 1 is required.' };
      }

      equ1 = equ1.replace(/ /g, '');
      let greater_than_equal_count = (equ1.match(/>=/g) || []).length;
      let less_than_equal_count = (equ1.match(/<=/g) || []).length;
      let less_than_count = (equ1.match(/</g) || []).length - less_than_equal_count;
      let greater_than_count = (equ1.match(/>/g) || []).length - greater_than_equal_count;
      let equal_count = (equ1.match(/=/g) || []).length - greater_than_equal_count - less_than_equal_count;
      let all_count = greater_than_equal_count + less_than_equal_count + less_than_count + greater_than_count + equal_count;

      if (all_count > 1) {
        return { error: 'Equation has more than one symbol.' };
      }

      if (equ1.includes('>=')) equ1 = equ1.replace('>=', 'gtae');
      else if (equ1.includes('<=')) equ1 = equ1.replace('<=', 'ltae');
      else if (equ1.includes('<')) equ1 = equ1.replace('<', 'less');
      else if (equ1.includes('>')) equ1 = equ1.replace('>', 'greater');
      else if (equ1.includes('=')) equ1 = equ1.replace('=', 'equal');

      let parem = equ1
        .replace(/−/g, '-')
        .replace(/\+/g, 'plus')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/e\^/g, 'exp')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**')
        .replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

      let form_params = {
        select,
        vari,
        equ: parem
      };

      if (select === '1') {
        if (!equ2) {
          return { error: 'Please! Check Your Input.' };
        }

        equ2 = equ2.replace(/ /g, '');
        greater_than_equal_count = (equ2.match(/>=/g) || []).length;
        less_than_equal_count = (equ2.match(/<=/g) || []).length;
        less_than_count = (equ2.match(/</g) || []).length - less_than_equal_count;
        greater_than_count = (equ2.match(/>/g) || []).length - greater_than_equal_count;
        equal_count = (equ2.match(/=/g) || []).length - greater_than_equal_count - less_than_equal_count;
        all_count = greater_than_equal_count + less_than_equal_count + less_than_count + greater_than_count + equal_count;

        if (all_count > 1) {
          return { error: 'Second Equation has more than one symbol.' };
        }

        if (equ2.includes('>=')) equ2 = equ2.replace('>=', 'gtae');
        else if (equ2.includes('<=')) equ2 = equ2.replace('<=', 'ltae');
        else if (equ2.includes('<')) equ2 = equ2.replace('<', 'less');
        else if (equ2.includes('>')) equ2 = equ2.replace('>', 'greater');
        else if (equ2.includes('=')) equ2 = equ2.replace('=', 'equal');

        let parem2 = equ2
          .replace(/−/g, '-')
          .replace(/\+/g, 'plus')
          .replace(/{/g, '(')
          .replace(/}/g, ')')
          .replace(/e\^/g, 'exp')
          .replace(/exp\^/g, 'exp')
          .replace(/\^/g, '**')
          .replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

        form_params['equ1'] = parem2;
      }

      try {
        const response = await axios.post('http://167.172.134.148/compound', new URLSearchParams(form_params), {
          timeout: 120000
        });

        let buffer = response.data;

        let result = {
          tech_solution_inequality: buffer.latex_solution_eq,
          tech_steps: buffer.steps,
        };

        if (buffer.latex_solution_eq_sec) {
          result.tech_latex_solution_eq_sec = buffer.latex_solution_eq_sec;
        }

        if (buffer.steps_sec) {
          result.tech_steps_sec = buffer.steps_sec;
        }

        return result;
      } catch (error) {
        return { error: 'Please! Check Your Input.' };
      }
    }

     /** getCalculationSolveforxCalculator
   * POST: /api/calculators-lol/solve-for-x-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationSolveforxCalculator(body) {
    let input = body.tech_input;
    let is_equal = body.tech_is_equal;


      if (!input || isNaN(is_equal)) {
        return { error: 'Please Enter Valid Input.' };
      }

      if (!/x/i.test(input)) {
        return { error: 'x is not in the Equestion.' };
      }

      let parem = input
        .replace(/ /g, '')
        .replace(/−/g, '-')
        .replace(/plus/g, '+')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/e\^/g, 'exp')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**')
        .replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

      parem += `-(${is_equal})`;

      try {
        const response = await axios.post(
          'http://167.172.134.148/solve-x',
          new URLSearchParams({ equ: parem }),
          { timeout: 120000 }
        );

        let buffer = response.data;
        let ans = buffer[0];

        return {
          tech_ans:ans,
        };
      } catch (error) {
        return { error: 'Please! Check Your Input.' };
      }
    }

      /** getCalculationSolveforxCalculator
   * POST: /api/calculators-lol/combine-like-terms-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationCombiningLikeTermsCalculator(body) {
      let  input  = body.tech_input;

      if (!input) {
        return { error: 'Please Check Your Input' };
      }

      let parem = input
        .replace(/ /g, '')
        .replace(/x=/g, '')
        .replace(/y=/g, '')
        .replace(/−/g, '-')
        .replace(/plus/g, '+')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/e\^/g, 'exp')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**')
        .replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

      try {
        const response = await axios.post(
          'http://167.172.134.148/combine',
          new URLSearchParams({ equ: parem }),
          { timeout: 120000 }
        );

        const [enter, inputLatex, answer] = response.data;

        let like = inputLatex
          .replace(/\\left\(/g, '')
          .replace(/\\right\)/g, '')
          .replace(/ /g, '')
          .replace(/\\/g, '');
        let likes = like.split(',');

        let combine = {};
        likes.forEach((val) => {
          let lowerVal = val.toLowerCase();
          let matched = false;
          for (let ch = 97; ch <= 122; ch++) {
            let key = String.fromCharCode(ch);
            if (lowerVal.includes(key)) {
              combine[key] = combine[key] || [];
              combine[key].push(val);
              matched = true;
              break;
            }
          }
          if (!matched) {
            combine['zcon'] = combine['zcon'] || [];
            combine['zcon'].push(val);
          }
        });

        let powera = {};
        for (let key in combine) {
          combine[key].forEach((val) => {
            if (key !== 'zcon') {
              let parts = val.split(`${key}^{`);
              if (parts.length === 2) {
                let base = parts[0].trim() || '1';
                let exponent = parts[1].replace('}', '').trim();
                powera[`${key}^{${exponent}}`] = powera[`${key}^{${exponent}}`] || [];
                powera[`${key}^{${exponent}}`].push(base);
              } else {
                let base = val.replace(new RegExp(key, 'g'), '').trim() || '1';
                powera[key] = powera[key] || [];
                powera[key].push(base);
              }
            } else {
              powera['zcon'] = powera['zcon'] || [];
              powera['zcon'].push(val.trim());
            }
          });
        }

        let steps = [];
        let final = [];
        let finals = [];
        let ans = '';
        let i = 0;
        let j = 0;

        const sortedKeys = Object.keys(powera).sort();
        for (let key of sortedKeys) {
          let values = powera[key];
          if (!values) continue;

          let step = '';
          let plus = values.reduce((sum, val) => sum + Number(val), 0) > 0 ? ' + ' : '';

          if (key !== 'zcon') {
            finals.push(plus + (values.length > 1 || values[0] !== '1' ? values.reduce((sum, val) => sum + Number(val), 0) : '') + key);
          } else {
            finals.push(plus + values.reduce((sum, val) => sum + Number(val), 0));
          }

          if (values.length > 1) step = 'Combining like terms ';
          values.forEach((val, idx) => {
            if (values.length > 1) {
              step += idx === 0 ? `\\( ${(val !== '1' ? val : '')}${key} \\)` : ` and \\( ${(val !== '1' ? val : '')}${key} \\)`;
            }

            i++;
            let sign = Number(val) >= 0 && i > 1 ? ' + ' : i === 1 ? '' : ' ';
            let term = (val === '1' && key !== 'zcon') ? key : `${val}${key !== 'zcon' ? key : ''}`;
            ans += `${sign}${term}`;
            final[j] = (final[j] || '') + `${sign}${term}`;
          });

          steps.push(values.length > 1 ? step : '');
          j++;
        }

        return {
          tech_enter:enter,
          tech_input: inputLatex,
          tech_answer:answer,
          tech_powera:powera,
          tech_steps:steps,
          tech_final:final,
          tech_finals:finals,
          tech_ans:ans,
        };
      } catch (err) {
        return { error: 'Please! Check Your Input.' };
      }
    }

      /** getCalculationRotationCalculator
   * POST: /api/calculators-lol/rotation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationRotationCalculator(body) {
      let point_rotate_one = body.tech_point_rotate_one;
        let point_rotate_two = body.tech_point_rotate_two;
        let angle = body.tech_angle;
        let unit = body.tech_unit;
        let point_around_one = body.tech_point_around_one;
        let point_around_two = body.tech_point_around_two;
        let direction = body.tech_direction;

        // Helper function to check if a value is numeric
      function isNumeric(value) {
          return !isNaN(parseFloat(value)) && isFinite(value);
      }

        const result = {
            param: {}
        };

        if (unit === "radians") {
            if (isNumeric(point_rotate_one) && isNumeric(point_rotate_two) && isNumeric(angle) && 
                isNumeric(point_around_one) && isNumeric(point_around_two)) {
                if (direction === "anticlockwise" || direction === "clockwise") {
                    let rotationAngle = angle;
                    if (direction === "clockwise") {
                        rotationAngle = angle * (-1);
                    } else if (direction === "anticlockwise") {
                        rotationAngle = angle * (1);
                    }

                    const first_point = point_rotate_one - point_around_one;
                    const second_point = point_rotate_two - point_around_two;
                    const first_part = first_point * Math.cos(rotationAngle);
                    const second_part = second_point * Math.sin(rotationAngle);
                    const formula = (first_part - second_part) + point_around_one;
                    const third_part = first_point * Math.sin(rotationAngle);
                    const fourth_part = second_point * Math.cos(rotationAngle);
                    const formula2 = (third_part + fourth_part) + point_around_two;

                    result.param.tech_point_rotate_one = point_rotate_one;
                    result.param.tech_point_rotate_two = point_rotate_two;
                    result.param.tech_point_around_one = point_around_one;
                    result.param.tech_point_around_two = point_around_two;
                    result.param.tech_formula_one = formula;
                    result.param.tech_formula_two = formula2;
                    result.param.tech_angle = rotationAngle;
                    result.param.tech_angle2 = rotationAngle;
                    result.param.tech_unit = unit;
                    result.param.tech_direction = direction;
                }
            } else {
                result.param.error = 'Please! Check Your Input.';
                return result.param;
            }
        } else if (unit === "degrees") {
            if (isNumeric(point_rotate_one) && isNumeric(point_rotate_two) && isNumeric(angle) && 
                isNumeric(point_around_one) && isNumeric(point_around_two)) {
                if (direction === "anticlockwise" || direction === "clockwise") {
                    let rotationAngle = angle;
                    if (direction === "clockwise") {
                        rotationAngle = angle * (-1);
                    } else if (direction === "anticlockwise") {
                        rotationAngle = angle * (1);
                    }

                    const first_point = point_rotate_one - point_around_one;
                    const second_point = point_rotate_two - point_around_two;
                    const sp = rotationAngle * Math.PI / 180;
                    const first_part = first_point * Math.cos(sp);
                    const second_part = second_point * Math.sin(sp);
                    const formula = (first_part - second_part) + point_around_one;
                    const third_part = first_point * Math.sin(sp);
                    const fourth_part = second_point * Math.cos(sp);
                    const formula2 = (third_part + fourth_part) + point_around_two;

                    result.param.tech_point_rotate_one = point_rotate_one;
                    result.param.tech_point_rotate_two = point_rotate_two;
                    result.param.tech_point_around_one = point_around_one;
                    result.param.tech_point_around_two = point_around_two;
                    result.param.tech_formula_one = formula;
                    result.param.tech_formula_two = formula2;
                    result.param.tech_angle = sp;
                    result.param.tech_angle2 = rotationAngle;
                    result.param.tech_direction = direction;
                    result.param.tech_unit = unit;
                }
            } else {
                result.param.error = 'Please! Check Your Input.';
                return result.param;
            }
        }

        return result.param;
    }

    /** getCalculationReciprocalCalculator
   * POST: /api/calculators-lol/reciprocal-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

      async  getCalculationReciprocalCalculator(body) {
      let operations = body.tech_operations;
      let first = body.tech_first;
      let second = body.tech_second;
      let third = body.tech_third;

      let param = {};

      function gcd(a, b) {
        a = Math.abs(a);
        b = Math.abs(b);
        if (a < b) [a, b] = [b, a];
        if (b === 0) return 1;
        let r = a % b;
        while (r > 0) {
          a = b;
          b = r;
          r = a % b;
        }
        return b;
      }

      function reduce(num, den) {
        let g = gcd(num, den);
        return [num / g, den / g];
      }

      if (operations == 1) {
        if (!isNaN(second) && !isNaN(third)) {
          if (second != 0) {
            if (third != 0) {
              let answer = third / second;
              let totalN = second;
              let totalD = third;
              let g = gcd(totalN, totalD);
              let [upr, btm] = reduce(totalN, totalD);
              param.tech_upr = upr;
              param.tech_totalN = totalN;
              param.tech_totalD = totalD;
              param.tech_g = g;
              param.tech_btm = btm;
              param.tech_answer = answer;
            } else {
              param.error = 'Denominator cannot be zero.';
              return param;
            }
          } else {
            param.error = 'Numerator cannot be zero.';
            return param;
          }
        } else {
          param.error = 'Please Check Your Input';
          return param;
        }
      } else if (operations == 2) {
        if (!isNaN(first)) {
          if (first != 0) {
            let zz = first.toString().split('.');
            let answer = 1 / first;
            if (zz.length === 1) {
              param.tech_answer = answer;
            } else if (zz.length === 2) {
              let len = zz[1].length;
              let aja = '0'.repeat(len);
              let upper = parseInt("1" + aja);
              let lower = first * upper;
              let totalN = upper;
              let totalD = lower;
              let g = gcd(totalN, totalD);
              let [upr, btm] = reduce(totalN, totalD);
              param.tech_upr = upr;
              param.tech_totalN = totalN;
              param.tech_totalD = totalD;
              param.tech_g = g;
              param.tech_btm = btm;
              param.tech_answer = answer;
              param.tech_upper = upper;
              param.tech_lower = lower;
            }
          } else {
            param.error = 'The multiplicative inverse of 0 is undefined.';
            return param;
          }
        } else {
          param.error = 'Please Check Your Input';
          return param;
        }
      } else if (operations == 3) {
        if (!isNaN(first) && !isNaN(second) && !isNaN(third)) {
          if (third != 0) {
            let totalD = third;
            let val1 = first;
            let totalN = (totalD * val1) + second;
            let g = gcd(totalN, totalD);
            let [upr, btm] = reduce(totalN, totalD);
            param.tech_upr = upr;
            param.tech_totalN = totalN;
            param.tech_totalD = totalD;
            param.tech_g = g;
            param.tech_btm = btm;
          } else {
            param.error = 'Denominator cannot be zero.';
            return param;
          }
        } else {
          param.error = 'Please Check Your Input';
          return param;
        }
      }

      param.tech_operations = operations;
      return param;
    }

     /** getCalculationCofunctionCalculator
   * POST: /api/calculators-lol/cofunction-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationCofunctionCalculator(body) {
      let func = body.tech_func;
      let angle = body.tech_angle;
      let unit = body.tech_unit;

      let param = {};

      if (!isNaN(func) && !isNaN(angle)) {
        let ang = angle;

        if (unit === "rad") {
          angle = (angle * 180) / Math.PI;
        }

        if (angle < 0 || angle > 90) {
          param['error'] = 'Angle for cofunction identities is 0-90 degrees (or 0 - π/2 in radians).';
          return param;
        }

        let ang1 = 90 - angle;
        if (unit === "rad") {
          ang1 = (ang1 * Math.PI) / 180;
        }

        let ans, ans1;

        switch (parseInt(func)) {
          case 1: // sin
            ans = Math.sin((angle * Math.PI) / 180);
            if (angle == 30) ans1 = ' = 1/2';
            else if (angle == 45) ans1 = ' = √2/2';
            else if (angle == 60) ans1 = ' = √3/2';
            break;
          case 2: // cos
            ans = Math.cos((angle * Math.PI) / 180);
            if (angle == 30) ans1 = ' = √3/2';
            else if (angle == 45) ans1 = ' = √2/2';
            else if (angle == 60) ans1 = ' = 1/2';
            break;
          case 3: // tan
            ans = Math.tan((angle * Math.PI) / 180);
            if (angle == 30) ans1 = ' = 1/√3 = √3/3';
            else if (angle == 60) ans1 = ' = √3';
            break;
          case 4: // cot
            ans = 1 / Math.tan((angle * Math.PI) / 180);
            if (angle == 30) ans1 = ' = √3';
            else if (angle == 60) ans1 = ' = 1/√3 = √3/3';
            break;
          case 5: // sec
            ans = 1 / Math.cos((angle * Math.PI) / 180);
            if (angle == 30) ans1 = ' = 2√3/3';
            else if (angle == 45) ans1 = ' = √2';
            break;
          case 6: // csc
            ans = 1 / Math.sin((angle * Math.PI) / 180);
            if (angle == 45) ans1 = ' = √2';
            else if (angle == 60) ans1 = ' = 2√3/3';
            break;
          default:
            param['error'] = 'Invalid function selected.';
            return param;
        }

        param['tech_ans'] = Number(ans.toFixed(8));
        param['tech_ang'] = Number(ang.toFixed(8));
        param['tech_ang1'] = Number(ang1.toFixed(8));
        if (ans1) param['tech_ans1'] = ans1;

        return param;
      } else {
        param['error'] = 'Please Check Your Input.';
        return param;
      }
    }

    /** getCalculationAdditiveInverseCalculator
   * POST: /api/calculators-lol/additive-inverse-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationAdditiveInverseCalculator(body) {
      let  nbr  = body.tech_nbr;

      let param = {};

      if (!isNaN(nbr)) {
        let ans = -1 * nbr;
        param['tech_ans'] = ans;
        return param;
      } else {
        param['error'] = 'Please! Check Your Input.';
        return param;
      }
    }

      /** getCalculationMonomialCalculator
   * POST: /api/calculators-lol/monomial-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationMonomialCalculator(body) {
      let  equ  = body.tech_equ;
      let param = {};

      if (equ && equ.trim() !== '') {
        let parem = equ;

        parem = parem.replace(/ /g, '');
        parem = parem.replace(/\+/g, 'plus');
        parem = parem.replace(/{/g, '(');
        parem = parem.replace(/}/g, ')');
        parem = parem.replace(/e\^/g, 'exp');
        parem = parem.replace(/exp\^/g, 'exp');
        parem = parem.replace(/\^/g, '**');
        parem = parem.replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

        try {
          const response = await axios.post(
            'http://167.172.134.148/monomial',
            new URLSearchParams({ equ: parem }),
            { timeout: 120000 }
          );

          const buffer = response.data;

          param['tech_ans'] = buffer[1];
          return param;
        } catch (error) {
          param['error'] = 'Please! Check Your Input.';
          return param;
        }
      } else {
        param['error'] = 'Please! Check Your Input.';
        return param;
      }
    }
    /** getCalculationLongMultiplicationCalculator
   * POST: /api/calculators-lol/long-multiplication-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationLongMultiplicationCalculator(body) {
      let  first  = body.tech_first;
      let  second  = body.tech_second;
      let param = {};

      if (!isNaN(first) && !isNaN(second)) {
        let answer1 = first * second;
        let answer;

        let aa = answer1.toString().split(".");

        if (aa.length === 1) {
          answer = answer1.toString();
        } else if (aa.length === 2) {
          answer = aa[0] + aa[1];
        }

        let xx = first.toString().split(".");
        let yy = second.toString().split(".");
        let l1, l2, total;

        if (xx.length === 2) l1 = xx[1].length;
        if (yy.length === 2) l2 = yy[1].length;

        if (l1 && l2) {
          total = l1 + l2;
        } else {
          total = l1 || l2 || 0;
        }

        if (total > 0) {
          param['tech_line1'] = `The following decimals contain overall <b>${total}</b> decimal places`;
          param['tech_line2'] = `You just need to carry out long multiplication as you do with normal integers by ignoring the decimals.`;
          param['tech_line3'] = `In the final final, start from right to left and move up to <b>${total}</b> decimal places to insert the decimal. This is the final answer.`;
        }

        let firstClean = first.toString().replace('.', '');
        let secondClean = second.toString().replace('.', '');

        let absFirst = Math.abs(parseInt(firstClean));
        let absSecond = Math.abs(parseInt(secondClean));

        let answer2 = absFirst * absSecond;
        let f_len = absFirst.toString().length;
        let s_len = absSecond.toString().length;
        let col = answer.length;

        let f_array = absFirst.toString().split('');
        let s_array = absSecond.toString().split('');

        let arr_rev = [];
        let m_j = [];
        let upper, lower;

        if (f_len >= s_len) {
          let rev_array = [...s_array].reverse();
          arr_rev = rev_array;

          arr_rev.forEach(value => {
            m_j.push(parseInt(value) * absFirst);
          });

          upper = f_array;
          lower = s_array;
        } else {
          let rev_array = [...f_array].reverse();
          arr_rev = rev_array;

          arr_rev.forEach(value => {
            m_j.push(parseInt(value) * absSecond);
          });

          upper = s_array;
          lower = f_array;
        }

        let final = answer.split('');

        param['tech_upper'] = upper;
        param['tech_lower'] = lower;
        param['tech_col'] = col;
        param['tech_m_j'] = m_j;
        param['tech_final'] = final;
        param['tech_answer'] = answer;
        param['tech_answer1'] = answer1;

        return param;
      } else {
        param['error'] = 'Please Check Your Input.';
        return param;
      }
    }

      /** getCalculationDivisibleCalculator
   * POST: /api/calculators-lol/divisible-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationDivisibleCalculator(body) {
      let no  = body.tech_no;
      let divisible  = body.tech_divisible;
      let param = {};

      if (
        !isNaN(no) &&
        !isNaN(divisible) &&
        no > 0 &&
        divisible > 0 &&
        no >= divisible
      ) {
        no = parseInt(no);
        divisible = parseInt(divisible);

        let division = Math.floor(no / divisible);
        let modulus = no % divisible;

        let division_array = division.toString().split('');
        let divisible_array = divisible.toString().split('');
        let number_array = no.toString().split('');
        let counter = 1;
        let com = '';

        for (let i = 0; i < number_array.length; i++) {
          if (i === 0) {
            com = number_array[i];
          }
          if (parseInt(com) < divisible) {
            com = com + number_array[i + 1];
            counter += 1;
          }
        }

        let stokes = com;
        let com_array = com.toString().split('');

        let separate_values = [];
        for (let z = com_array.length; z < number_array.length; z++) {
          separate_values.push(number_array[z]);
        }

        let multiplication = [];
        let p_length = [];
        let tree = [];
        let read = [];
        let extra = [];

        for (let j = 0; j < division_array.length; j++) {
          let mult = divisible * parseInt(division_array[j]);
          multiplication.push(mult);
          let p = parseInt(com) - mult;
          p_length.push(p);
          tree.push(p);

          if (p < divisible) {
            if (typeof separate_values[j] !== 'undefined') {
              com = p.toString() + separate_values[j];
              extra.push(com);
            }
          }

          read.push(com);
        }

        param['tech_stokes'] = stokes;
        param['tech_divisible_array'] = divisible_array;
        param['tech_number_array'] = number_array;
        param['tech_number'] = no;
        param['tech_divisible'] = divisible;
        param['tech_division'] = division;
        param['tech_modulus'] = modulus;
        param['tech_multiply'] = multiplication;
        param['tech_read'] = read;
        param['tech_com'] = com;
        param['tech_p_length'] = p_length;
        param['tech_tree_array'] = tree;

        return param;
      } else {
        param['error'] = 'Please Enter Valid Input.';
        return param;
      }
    }


    /** getCalculationAverageValueFunctionCalculator
   * POST: /api/calculators-lol/average-value-of-function
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationAverageValueFunctionCalculator(body) {
          let fun  = body.tech_fun;
          let lb  = body.tech_lb;
          let ub  = body.tech_ub;

      let param = {};

      if (fun && !isNaN(lb) && !isNaN(ub)) {
        let vari = 0;
        let withVar = '';
        let value = fun.replace(/%20/g, '').replace(/ /g, '').replace(/plus/g, '+');

        // Detect the single variable used
        for (let char of 'abcdefghijklmnopqrstuvwxyz') {
          if (new RegExp(char, 'i').test(value)) {
            vari++;
            withVar = char;
          }
        }

        if (vari !== 1) {
          param['error'] = 'The function contains more than one variable.';
          return param;
        }

        if (Number(lb) > Number(ub)) {
          param['error'] = 'Upper Limit must be greater than Lower Limit.';
          return param;
        }

        let divide = ub - lb;

        // Format equation string
        let parem = fun;
        parem = parem.replace(/ /g, '');
        parem = parem.replace(/\+/g, 'plus');
        parem = parem.replace(/{/g, '(');
        parem = parem.replace(/}/g, ')');
        parem = parem.replace(/e\^/g, 'exp');
        parem = parem.replace(/exp\^/g, 'exp');
        parem = parem.replace(/\^/g, '**');
        parem = parem.replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

        try {
          const response = await axios.post(
            'http://167.172.134.148/avg_fun',
            new URLSearchParams({
              equ: parem,
              wrt: withVar,
              ub: ub,
              lb: lb,
              divide: divide
            }),
            { timeout: 120000 }
          );

          const buffer = response.data;

          param['tech_input'] = buffer[0];
          param['tech_sim'] = buffer[1];
          param['tech_ans'] = buffer[2];
          param['tech_with'] = withVar;
          param['tech_divide'] = divide;
          return param;
        } catch (err) {
          param['error'] = 'Please! Check Your Input.';
          return param;
        }
      } else {
        param['error'] = 'Please Check Your Input!';
        return param;
      }
    }

    /** getCalculationProductSumCalculator
   * POST: /api/calculators-lol/product-sum-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async  getCalculationProductSumCalculator(body) {
        let product  = body.tech_product;
        let sum  = body.tech_sum;
    let param = {};

    if (!isNaN(product) && !isNaN(sum)) {
      let A = 1;
      let B = -1 * sum;
      let C = product;

      let dis = Math.pow(B, 2) - 4 * A * C;

      if (dis > 0) {
        let x1 = Number(((-B + Math.sqrt(dis)) / (2 * A)).toFixed(4));
        let x2 = Number(((-B - Math.sqrt(dis)) / (2 * A)).toFixed(4));

        param['fact'] =
          `${A}(x ${x1 < 0 ? '+ ' + Math.abs(x1) : '- ' + x1} )` +
          `(x ${x2 < 0 ? '+ ' + Math.abs(x2) : '- ' + x2} )`;
        param['roots'] = `x₁ = ${x1} , x₂ = ${x2}`;
      } else if (dis < 0) {
        let real = Number((-B / (2 * A)).toFixed(4));
        let imag = Number((Math.sqrt(-dis) / (2 * A)).toFixed(4));

        let x1 = `${real} + ${imag}`;
        let x2 = `${real} - ${imag}`;

        param['tech_fact'] = `${A}(x - (${x1}\\,i) )(x - (${x2}\\,i) )`;
        param['tech_roots'] = `x₁ = ${x1} <i>i</i><br> x₂ = ${x2} <i>i</i>`;
      } else {
        let x1 = Number((-B / (2 * A)).toFixed(4));
        param['tech_fact'] = `${A}(x ${x1 < 0 ? '+ ' + Math.abs(x1) : '- ' + x1} )^2`;
        param['tech_roots'] = `x = ${x1}`;
      }

      param['tech_dis'] = dis;
      param['tech_a'] = A;
      param['tech_B'] = B;
      param['tech_C'] = C;
      return param;
    } else {
      param['error'] = 'Please Check Your Input!';
      return param;
    }
  }

   /** getCalculationPascalTriangleCalculator
   * POST: /api/calculators-lol/pascals-triangle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationPascalTriangleCalculator(body) {
      let method = body.tech_method;
      let row = body.tech_row;
      let to_row = body.tech_to_row;
      let column = body.tech_column;
      let param = {};

      if (method === "1") {
        if (!isNaN(row)) {
          row = parseInt(row);
          if (row >= 0) {
            if (row < 100) {
              param['row'] = row;
            } else {
              param['error'] = 'The row must be less than 100.';
              return param;
            }
          } else {
            param['error'] = 'The row must be non-negative.';
            return param;
          }
        } else {
          param['error'] = 'Please! Check Your Input.';
          return param;
        }

      } else if (method === "2") {
        if (!isNaN(row)) {
          row = parseInt(row);
          if (row >= 0) {
            if (row >= 100) {
              param['error'] = 'The row must be less than 100.';
              return param;
            }
          } else {
            param['error'] = 'The row must be non-negative.';
            return param;
          }
        } else {
          param['error'] = 'Please! Check Your Input.';
          return param;
        }

      } else if (method === "3") {
        if (!isNaN(row) && !isNaN(to_row)) {
          row = parseInt(row);
          to_row = parseInt(to_row);
          if (row >= 0 && to_row >= 0) {
            if (to_row >= row) {
              param['tech_col'] = to_row;
            } else {
              param['error'] = 'The end-row must be at least equal to the one we started with.';
              return param;
            }
          } else {
            param['error'] = 'The row must be non-negative.';
            return param;
          }
        } else {
          param['error'] = 'Please! Check Your Input.';
          return param;
        }

      } else if (method === "4") {
        if (!isNaN(row) && !isNaN(column)) {
          row = parseInt(row);
          column = parseInt(column);
          if (row >= column && row > 0 && column > 0) {
            param['tech_column'] = column;
          } else {
            param['error'] = 'Enter Row n ≥ Col k ≥ 0.';
            return param;
          }
        } else {
          param['error'] = 'Please! Check Your Input.';
          return param;
        }
      }

      param['tech_row'] = row;
      param['tech_method'] = method;
      return param;
    }
     /** getCalculationOrderOfOperationsCalculator
   * POST: /api/calculators-lol/order-of-operations-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationOrderOfOperationsCalculator(body) {
      let  expression  = body.tech_expression;

      let param = {};

      if (expression !== "") {
        let fixedstring = expression.replace(/ /g, "+");

        if (fixedstring) {
          param['tech_method'] = 1;
          param['tech_expression'] = fixedstring;
          return param;
        } else {
          param['error'] = 'Please! Check Input.';
          return param;
        }
      } else {
        param['error'] = 'Please! Check Input.';
        return param;
      }
    }
     /** getCalculationCharacteristicPolynomialCalculator
   * POST: /api/calculators-lol/characteristic-polynomial-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */


  async  getCalculationCharacteristicPolynomialCalculator(body) {
    let  matrix22  = body.tech_matrix22;

    let second_matrix = [];
    for (let i = 1; i <= matrix22; i++) {
      for (let j = 1; j <= matrix22; j++) {
        let key = `tech_matrix3${i}_${j}`;
        if (body.hasOwnProperty(key) && !isNaN(body[key])) {
          second_matrix.push(parseFloat(body[key]));
        }
      }
    }

    let mul = matrix22 * matrix22;
    if (mul !== second_matrix.length) {
      return { error: "Please! Check Your Input." };
    }

    let zain = [];
    for (let i = 0; i < matrix22; i++) {
      zain.push(second_matrix.slice(i * matrix22, (i + 1) * matrix22));
    }

    let advance = [];
    for (let i = 0; i < second_matrix.length; i++) {
      if (i % (matrix22 + 1) === 0) {
        advance.push(`${second_matrix[i]}-λ`);
      } else {
        advance.push(`${second_matrix[i]}`);
      }
    }

    let val_array = [];
    for (let i = 0; i < advance.length; i += matrix22) {
      val_array.push(advance.slice(i, i + matrix22));
    }

    let input = [];
    for (let rowIndex = 0; rowIndex < val_array.length; rowIndex++) {
      let row = val_array[rowIndex];
      for (let i = 0; i < row.length; i++) {
        input.push(row[i]);
        if (i < row.length - 1) {
          input.push(",");
        }
      }
      if (rowIndex < val_array.length - 1) {
        input.push("@@");
      }
    }

    let mat = input.join("");
    let param = {};

    try {
      const response = await axios.post(
        "http://167.172.134.148/characteristic",
        new URLSearchParams({ mat }),
        { timeout: 120000 }
      );

      let buffer = response.data.split("@@@");
      param["tech_answer"] = buffer[0];
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }

    param["tech_matrix"] = val_array;
    param["tech_input_ma"] = zain;
    return param;
  }

    /** getCalculationXAndYInterceptsCalculator
   * POST: /api/calculators-lol/intercepts-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationXAndYInterceptsCalculator(body) {
      let  EnterEq  = body.tech_EnterEq;

      // Basic validation
      if (!EnterEq || /<|>|&|php|print_r|print|echo|script|%/i.test(EnterEq)) {
        return { error: "Please Enter Valid Input." };
      }

      // Sanitize expression
      let parem = EnterEq
        .replace(/ /g, '')
        .replace(/\+/g, 'plus')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/e\^/g, 'exp')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**')
        .replace(/log/g, 'ln')
        .replace(/=/g, '-')
        .replace(/e\^sqrt\(x\)/g, 'exp(2*x)');

      let param = {};

      try {
        const response = await axios.post(
          "http://167.172.134.148/intercepts",
          new URLSearchParams({ equ: parem }),
          { timeout: 120000 }
        );

        const buffer = response.data;

        let equation = buffer[0];
        let xIntercepts = buffer[1].split(',').map(item => (item === '\\left[ \\right]' ? "0" : `${item},0`));
        let yIntercept = buffer[2] === '\\left[ \\right]' ? "0,0" : `0,${buffer[2]}`;
        yIntercept = yIntercept.replace(/\\left\[|\\right\]/g, '');

        param["tech_equation"] = equation;
        param["tech_buffer_zero"] = xIntercepts;
        param["tech_c"] = xIntercepts.length;
        param["tech_buffer_one"] = yIntercept;
        param["tech_method"] = buffer[3];

        return param;
      } catch (error) {
        return { error: "Please! Check Your Input." };
      }
    }

   /** getCalculationDomainAndRangeCalculator
   * POST: /api/calculators-lol/domain-and-range-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationDomainAndRangeCalculator(body) {
      let  eq  = body.tech_eq;

      if (!eq) {
        return { error: "Please Check Your Input." };
      }

      // Input validation
      const invalidPattern = /<|>|&|php|print_r|print|echo|script|=|sin|cos|tan|arcsin|arccos|arctan|%/i;
      if (invalidPattern.test(eq)) {
        return { error: "Please Enter Valid Input." };
      }

      // Sanitize equation
      let parem = eq
        .replace(/ /g, "")
        .replace(/\+/g, "plus")
        .replace(/%20/g, "")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**")
        .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

      try {
        const response = await axios.post(
          "http://167.172.134.148/domain",
          new URLSearchParams({ equ: parem }),
          { timeout: 120000 }
        );

        const buffer = response.data;

        return {
          tech_domain: buffer[0],
          tech_range: buffer[1],
        };
      } catch (error) {
        return { error: "Please! Check Your Input." };
      }
    }


  /** getCalculationDistanceBetweenTwoPointsCalculator
   * POST: /api/calculators-lol/distance-between-two-points-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationDistanceBetweenTwoPointsCalculator(body) {
      let x1 = body.tech_x1;
      let y1 = body.tech_y1;
      let x2 = body.tech_x2;
      let y2 = body.tech_y2;
      if (
        isNumeric(x1) &&
        isNumeric(y1) &&
        isNumeric(x2) &&
        isNumeric(y2)
      ) {
        let dx = x2 - x1;
        let dy = y2 - y1;
        let ans = Math.round(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)) * 10000) / 10000;

        return {
          tech_ans: ans,
        };
      } else {
        return {
          error: "Please Check Your Input.",
        };
      }

      function isNumeric(value) {
        return !isNaN(parseFloat(value)) && isFinite(value);
      }
    }

  /** getCalculationSASTriangleCalculator
   * POST: /api/calculators-lol/sas-triangle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationSASTriangleCalculator(body) {
      let first = body.tech_first;
      let unit1 = body.tech_unit1;
      let second = body.tech_second;
      let unit2 = body.tech_unit2;
      let third = body.tech_third;
      let unit3 = body.tech_unit3;


      function toCm(unit, value) {
        switch (unit) {
          case "mm": return value / 10;
          case "cm": return value;
          case "m": return value * 100;
          case "in": return value * 2.54;
          case "ft": return value * 30.48;
          default: return NaN;
        }
      }

      function toDeg(unit, value) {
        switch (unit) {
          case "pi": return value * 57.2958;
          case "deg": return value;
          default: return NaN;
        }
      }

      let a = toCm(unit1, first);
      let b = toCm(unit2, second);
      let C = toDeg(unit3, third);

      if ([a, b, C].every(x => typeof x === 'number' && !isNaN(x))) {
        let c = Math.sqrt(a ** 2 + b ** 2 - 2 * a * b * Math.cos((C * Math.PI) / 180));
        c = Math.round(c * 1000) / 1000;

        let p = a + b + c;
        let s = p / 2;
        let t = Math.sqrt(s * (s - a) * (s - b) * (s - c));
        t = Math.round(t * 10000) / 10000;

        let h_a = (2 * t) / a;
        let h_b = (2 * t) / b;
        let h_c = (2 * t) / c;

        let alpha = (Math.acos((b ** 2 + c ** 2 - a ** 2) / (2 * b * c)) * 180) / Math.PI;
        let beta = (Math.acos((a ** 2 + c ** 2 - b ** 2) / (2 * a * c)) * 180) / Math.PI;
        let gamma = 180 - alpha - beta;

        let r = t / s;
        let R = (a * b * c) / (4 * r * s);

        let m_a = Math.sqrt(2 * b ** 2 + 2 * c ** 2 - a ** 2) / 2;
        let m_b = Math.sqrt(2 * c ** 2 + 2 * a ** 2 - b ** 2) / 2;
        let m_c = Math.sqrt(2 * a ** 2 + 2 * b ** 2 - c ** 2) / 2;

        return {
          tech_a: a,
          tech_b: b,
          tech_c: c,
          tech_t: t,
          tech_s: s,
          tech_p: p,
          tech_alpha: alpha,
          tech_beta: beta,
          tech_gema: gamma,
          tech_h_a: h_a,
          tech_h_b: h_b,
          tech_h_c: h_c,
          tech_m_a: m_a,
          tech_m_b: m_b,
          tech_m_c: m_c,
          tech_r: r,
          tech_R: R,
        };
      } else {
        return { error: "Please Check Your Input." };
      }
    }

  /** getCalculationRadiusCircleCalculator
   * POST: /api/calculators-lol/radius-of-a-circle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
      async  getCalculationRadiusCircleCalculator(body) {
      let operations = body.tech_operations;
      let first = body.tech_first;
      let unit1 = body.tech_unit1;
      let second = body.tech_second;
      let unit2 = body.tech_unit2;
  
        let foot,centi;
        function conCm(a,b){
                if(a == "mm"){
                    centi = b / 10;
                } else if (a == "cm"){
                    centi = b * 1;
                } else if (a == "dm"){
                    centi = b * 10;
                } else if (a == "m"){
                    centi = b * 100;
                } else if (a == "km"){
                    centi = b * 100000;
                } else if (a == "in"){
                    centi = b * 2.54;
                } else if (a == "ft"){
                    centi = b * 30.48;
                } else if (a == "yd"){
                    centi = b * 91.44;
                } else if (a == "mi"){
                    centi = b * 160900;
                } else if (a == "nmi"){
                    centi = b * 185200;
                }
                return centi;
        }
        function conCmSq(a,b) {
            if(a == "mm²"){
                foot = b / 10;
            } else if (a == "cm²"){
                foot = b * 1;
            } else if (a == "dm²"){
                foot = b * 10;
            } else if (a == "m²"){
                foot = b * 100;
            } else if (a == "km²"){
                foot = b * 100000;
            } else if (a == "in²"){
                foot = b * 2.54;
            } else if (a == "ft²"){
                foot = b * 30.48;
            } else if (a == "yd²"){
                foot = b * 91.44;
            } else if (a == "mi²"){
                foot = b * 160900;
            } else if (a == "a"){
                foot = b * 1000000;
            } else if (a == "da"){
                foot = b * 1000;
            } else if (a == "ha"){
                foot = b * 100000000;
            } else if (a == "ac"){
                foot = b * 40468564.224;
            } else if (a == "sf"){
                foot = b * 71224673.03424;
            }
            return foot;
        }

    let radius, diameter, area, circum;

    if (operations === "1") {
      let converted = conCm(unit1, first);
      if (isFinite(converted)) {
        radius = converted / (2 * 3.14);
        diameter = 2 * radius;
        area = Math.pow(radius, 2) * 3.14;
        return {
          tech_diameter:diameter,
          tech_area:area,
          tech_radius:radius,
        };
      }
    } else if (operations === "2") {
      let converted = conCmSq(unit2, second);
      if (isFinite(converted)) {
        radius = Math.sqrt(converted / 3.14);
        diameter = 2 * radius;
        circum = 2 * 3.14 * radius;
        return {
          tech_diameter:diameter,
          tech_radius:radius,
          tech_circum:circum,
        };
      }
    } else if (operations === "3") {
      let converted = conCm(unit1, first);
      if (isFinite(converted)) {
        radius = converted / 2;
        circum = 2 * 3.14 * radius;
        area = Math.pow(radius, 2) * 3.14;
        return {
          tech_radius:radius,
          tech_circum:circum,
          tech_area:area,
        };
      }
    }

    return { error: "Please Check Your Input." };
  }

    /** getCalculationEquilateralTriangleCalculator
   * POST: /api/calculators-lol/equilateral-triangle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
 async  getCalculationEquilateralTriangleCalculator(body) {
    let operations = body.tech_operations;
    let first = body.tech_first;
    let unit1 = body.tech_unit1;
  let a, p, s, k, h;

  if (operations === "side" && isFinite(first)) {
    a = first;
    p = a * 3;
    s = (3 * a) / 2;
    k = (1 / 4) * Math.sqrt(3) * Math.pow(a, 2);
    h = (1 / 2) * Math.sqrt(3) * a;

  } else if (operations === "perimeter" && isFinite(first)) {
    a = first / 3;
    p = first;
    s = (3 * a) / 2;
    k = (1 / 4) * Math.sqrt(3) * Math.pow(a, 2);
    h = (1 / 2) * Math.sqrt(3) * a;

  } else if (operations === "semiperimeter" && isFinite(first)) {
    a = (first * 2) / 3;
    p = 3 * a;
    s = first;
    k = (1 / 4) * Math.sqrt(3) * Math.pow(a, 2);
    h = (1 / 2) * Math.sqrt(3) * a;

  } else if (operations === "area" && isFinite(first)) {
    a = 2 * Math.sqrt(first / Math.sqrt(3));
    p = 3 * a;
    s = (3 * a) / 2;
    k = first;
    h = (1 / 2) * Math.sqrt(3) * a;

  } else if (operations === "altitude" && isFinite(first)) {
    a = (2 * Math.sqrt(3)) * first;
    p = 3 * a;
    s = (3 * a) / 2;
    k = (1 / 4) * Math.sqrt(3) * Math.pow(a, 2);
    h = first;

  } else {
    return { error: "Please Check Your Input." };
  }

  return {
    tech_a:a,
    tech_k:k,
    tech_p:p,
    tech_s:s,
    tech_h:h,
    tech_unit: unit1,
  };
}

   /** getCalculationPointOfIntersectionCalculator
   * POST: /api/calculators-lol/point-of-intersection
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationPointOfIntersectionCalculator(body) {
      let x1 = parseFloat(body.tech_x1);
      let y1 = parseFloat(body.tech_y1);
      let c1 = parseFloat(body.tech_c1);
      let x2 = parseFloat(body.tech_x2);
      let y2 = parseFloat(body.tech_y2);
      let c2 = parseFloat(body.tech_c2);

      let result = {};

      if (
        !isNaN(x1) && !isNaN(y1) && !isNaN(c1) &&
        !isNaN(x2) && !isNaN(y2) && !isNaN(c2)
      ) {
        if ((x1 === x2 && y1 === y2) || (x1 === y1 && x2 === y2)) {
          result.x = "-Infinity";
          result.y = "Infinity";
          result.error = "Both Lines are Parallel.";
          return result;
        }

        c1 = -c1;
        c2 = -c2;
        let const1 = -c1;
        let const2 = -c2;

        let x = ((y1 * c2) - (y2 * c1)) / ((x1 * y2) - (x2 * y1));
        let y = ((x2 * c1) - (x1 * c2)) / ((x1 * y2) - (x2 * y1));

        let x1num = (y1 * c2) - (y2 * c1);
        let x1den = (x1 * y2) - (x2 * y1);
        let y1num = (x2 * c1) - (x1 * c2);
        let y1den = (x1 * y2) - (x2 * y1);

        let th = 0;
        let Line1 = {};
        let Line2 = {};

        let max = Math.max(Math.abs(x), Math.abs(y));
        th = Math.round(max) + 100;

        for (let i = -th; i < th; i++) {
          Line1[i] = (const1 / y1) - (x1 * i / y1);
          Line2[i] = (const2 / y2) - (x2 * i / y2);
        }

        result.tech_x = x;
        result.tech_y = y;
        result.tech_th = th;
        result.tech_x1num = x1num;
        result.tech_x1den = x1den;
        result.tech_y1num = y1num;
        result.tech_y1den = y1den;
        result.tech_Line1 = Line1;
        result.tech_Line2 = Line2;
        return result;
      } else {
        result.error = "Please! Check Your Input.";
        return result;
      }
    }

     /** getCalculationExponentialFunctionCalculator
   * POST: /api/calculators-lol/exponential-function-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationExponentialFunctionCalculator(body) {
      let t1 = parseFloat(body.tech_t1);
      let y1 = parseFloat(body.tech_y1);
      let t2 = parseFloat(body.tech_t2);
      let y2 = parseFloat(body.tech_y2);
      let point_optional = body.tech_point_optional !== undefined ? parseFloat(body.tech_point_optional) : null;

      let result = {};

      if (!isNaN(t1) && !isNaN(y1) && !isNaN(t2) && !isNaN(y2)) {
        if ((y1 !== y2 && t1 !== t2) && (y1 > 0 && y2 > 0)) {
          let y = y1 / y2;
          let natural_log = Math.log(y);
          let time_minus = t1 - t2;
          let time = 1 / time_minus;
          let k = parseFloat((time * natural_log).toFixed(4));

          let exp_power = -1 * k * t2;
          let e = Math.exp(exp_power);
          let A = parseFloat((y2 * e).toFixed(4));

          let exp_fun = point_optional !== null
            ? Math.exp(k * point_optional)
            : Math.exp(k * 2);

          let f = parseFloat((A * exp_fun).toFixed(4));

          result.tech_k = k;
          result.tech_A = A;
          result.tech_f = f;
          return result;
        } else {
          result.error = "Please! Check Your Input.";
          return result;
        }
      } else {
        result.error = "Please! Check Your Input.";
        return result;
      }
    }

   /** getCalculationPowerof10Calculator
   * POST: /api/calculators-lol/exponential-function-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationPowerof10Calculator(body) {
      let input = body.tech_input;

      let result = {};

      try {
        // Safely evaluate the input using Function constructor instead of eval
        let exp = Function('"use strict"; return (' + input + ')')();

        if (typeof exp === 'number' && !isNaN(exp)) {
          let output = Math.pow(10, exp);
          result.tech_result = output;
          result.tech_x = exp;
        } else {
          result.error = "Please! Check Your Input.";
        }
      } catch (e) {
        result.error = "Please! Check Your Input.";
      }

      return result;
    }

   /** getCalculationSlopePercentageCalculator
   * POST: /api/calculators-lol/slope-percentage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationSlopePercentageCalculator(body) {
      let rise = parseFloat(body.tech_rise);
      let run = parseFloat(body.tech_run);
      let rise_unit = body.tech_rise_unit;
      let run_unit = body.tech_run_unit;

      let result = {};

      // Unit conversion for rise
    if (rise_unit) {
          if (rise_unit == 'm') {
            rise = rise;
          } else if (rise_unit == 'mm') {
            rise = rise * 1000;
          } else if (rise_unit == 'cm') {
            rise = rise * 100;
          } else if (rise_unit == 'km') {
            rise = rise * 0.001;
          } else if (rise_unit == 'in') {
            rise = rise * 39.37;
          } else if (rise_unit == 'ft') {
            rise = rise * 3.281;
          }
        }
        if (run_unit) {
          if (run_unit == 'm') {
            run = run;
          } else if (run_unit == 'mm') {
            run = run * 1000;
          } else if (run_unit == 'cm') {
            run = run * 100;
          } else if (run_unit == 'km') {
            run = run * 0.001;
          } else if (run_unit == 'in') {
            run = run * 39.37;
          } else if (run_unit == 'ft') {
            run = run * 3.281;
          }
        }

      if (!isNaN(rise)) {
        if (run === 0) {
          result.error = "The run cannot be zero.";
          return result;
        }

        let slopePercentage = (rise / run) * 100;
        let slopeAngle = Math.atan(rise / run);
        let slopeAngleDegrees = slopeAngle * (180 / Math.PI);

        result.tech_slopeAngle = slopeAngle;
        result.tech_slopeAngleDegrees = slopeAngleDegrees;
        result.tech_slopePercentage = slopePercentage;
        return result;
      } else {
        result.error = "Please check your input.";
        return result;
      }
    }

   /** getCalculationChangeOfBaseFormulaCalculator
   * POST: /api/calculators-lol/change-of-base-formula-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationChangeOfBaseFormulaCalculator(body) {
      let x = parseFloat(body.tech_x);
      let a = parseFloat(body.tech_a);
      let b = parseFloat(body.tech_b);

      let result = {};

      if (!isNaN(x) && !isNaN(a) && !isNaN(b)) {
        if (a <= 0) {
          result.error = "Number of 'a' value cannot be equal to or less than zero.";
          return result;
        }

        if (b <= 0) {
          result.error = "Number of 'b' value cannot be equal to or less than zero.";
          return result;
        }

        let log_one = Math.log(x) / Math.log(a);  // log base a of x
        let log_two = Math.log(x) / Math.log(b);  // log base b of x
        let log_three = Math.log(a) / Math.log(b); // log base b of a

        if (log_three <= 0) {
          result.error = "Logarithm of a or b cannot be equal to or less than zero.";
          return result;
        }

        let answer = log_two / log_three;

        result.tech_answer = answer;
        result.tech_log_one = log_one;
        result.tech_log_two = log_two;
        result.tech_log_three = log_three;
        return result;
      } else {
        result.error = "Please Check Your Input.";
        return result;
      }
    }


   /** getCalculationCompletingTheSquareCalculator
   * POST: /api/calculators-lol/completing-the-square-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async  getCalculationCompletingTheSquareCalculator(body) {
    let A = parseFloat(body.tech_A);
    let B = parseFloat(body.tech_B);
    let C = parseFloat(body.tech_C);

    let result = {};

    if (!isNaN(A) && !isNaN(B) && !isNaN(C)) {
      if (A === 0) {
        result.error = "A cannot be zero.";
        return result;
      }

      let firstx = +( (-B) / (2 * A) ).toFixed(3);
      let first_part = A * Math.pow(firstx, 2);
      let second_part = B * firstx;

      let eq = "";
      if (second_part < 0 && C < 0) {
        eq = `${first_part} ${second_part} ${C}`;
      } else if (second_part < 0 && C >= 0) {
        eq = `${first_part} ${second_part} + ${C}`;
      } else if (second_part >= 0 && C < 0) {
        eq = `${first_part} + ${second_part} ${C}`;
      } else {
        eq = `${first_part} + ${second_part} + ${C}`;
      }

      let yaxis;
      try {
        yaxis = Function('"use strict"; return (' + eq + ')')();
        yaxis = +yaxis.toFixed(3);
      } catch (e) {
        result.error = "Invalid expression generated.";
        return result;
      }

      let left_side = B / A;
      let C_ = -C / A;
      let right_side = C_ + (Math.pow(B, 2) / Math.pow((2 * A), 2));

      let x1, x2;

      if (right_side > 0) {
        x1 = +(((-left_side / 2) + Math.sqrt(right_side)).toFixed(4));
        x2 = +(((-left_side / 2) - Math.sqrt(right_side)).toFixed(4));
        result.tech_fact = `${A}(x ${x1 < 0 ? '+ ' + (-x1) : '- ' + x1})` +
                      `(x ${x2 < 0 ? '+ ' + (-x2) : '- ' + x2})`;
        result.tech_roots = `x₁ = ${x1} , x₂ = ${x2}`;
      } else if (right_side < 0) {
        let imaginary = Math.sqrt(-right_side).toFixed(4);
        let base = (-left_side / 2).toFixed(4);
        x1 = `${base} + ${imaginary}`;
        x2 = `${base} - ${imaginary}`;
        result.tech_fact = `${A}(x - (${x1} i))(x - (${x2} i))`;
        result.tech_roots = `x₁ = ${x1} i<br> x₂ = ${x2} i`;
      } else {
        x1 = +((-left_side / 2).toFixed(4));
        result.tech_fact = `${A}(x ${x1 < 0 ? '+ ' + (-x1) : '- ' + x1})^2`;
        result.tech_roots = `x = ${x1}`;
      }

      result.tech_B = B;
      result.tech_C = C;
      result.tech_x1 = x1;
      result.tech_x2 = x2 || null;
      return result;

    } else {
      result.error = "Please Check Your Input.";
      return result;
    }
  }


   /** getCalculationCubeRootCalculator
   * POST: /api/calculators-lol/cube-root-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationCubeRootCalculator(body) {
      let number = parseFloat(body.tech_number);
      let result = {};

      if (!isNaN(number)) {
        let cube_root = Math.cbrt(number); // Handles negative numbers correctly
        result.tech_cube_root = cube_root;
        return result;
      } else {
        result.error = "Please! Check Your Input.";
        return result;
      }
    }

       /** getCalculationTruncatedPyramidCalculator
   * POST: /api/calculators-lol/truncated-pyramid-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
      async  getCalculationTruncatedPyramidCalculator(body) {
      let ubl = parseFloat(body.tech_ubl);
      let ubw = parseFloat(body.tech_ubw);
      let lbl = parseFloat(body.tech_lbl);
      let lbw = parseFloat(body.tech_lbw);
      let height = parseFloat(body.tech_height);

      let result = {};

      if (
        !isNaN(ubl) &&
        !isNaN(ubw) &&
        !isNaN(lbl) &&
        !isNaN(lbw) &&
        !isNaN(height)
      ) {
        let DL = +(Math.sqrt(Math.pow(lbl, 2) + Math.pow(lbw, 2))).toFixed(2);
        let DT = +(Math.sqrt(Math.pow(ubl, 2) + Math.pow(ubw, 2))).toFixed(2);
        let dia = (DL / 2) - (DT / 2);
        let HL = +(Math.sqrt(Math.pow(dia, 2) + Math.pow(height, 2))).toFixed(2);

        let sL = lbl / 2;
        let sW = lbw / 2;
        let si = ubl / 2;
        let sw = ubw / 2;

        let c1 = sW - sw;
        let c2 = sL - si;

        let slA = +(Math.sqrt(Math.pow(c1, 2) + Math.pow(height, 2))).toFixed(2);
        let slB = +(Math.sqrt(Math.pow(c2, 2) + Math.pow(height, 2))).toFixed(2);

        let a = +(Math.asin(height / HL) * (180 / Math.PI)).toFixed(2);
        let b = +(Math.atan(height / c1) * (180 / Math.PI)).toFixed(2);
        let c = +(Math.atan(height / c2) * (180 / Math.PI)).toFixed(2);

        result.tech_DL = DL;
        result.tech_DT = DT;
        result.tech_HL = HL;
        result.tech_slA = slA;
        result.tech_slB = slB;
        result.tech_a = a;
        result.tech_b = b;
        result.tech_c = c;
        return result;
      } else {
        result.error = "Please! Check Your Input.";
        return result;
      }
    }

     /** getCalculationMixedNumberCalculator
   * POST: /api/calculators-lol/mixed-number-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationMixedNumberCalculator(body) {
      let n1 = parseFloat(body.tech_n1);
      let d1 = parseFloat(body.tech_d1);
      let n2 = parseFloat(body.tech_n2);
      let d2 = parseFloat(body.tech_d2);
      let s1 = parseFloat(body.tech_s1);
      let s2 = parseFloat(body.tech_s2);
      let action = body.tech_action;

      let result = {};

      if (!isNaN(n1) && !isNaN(d1) && !isNaN(n2) && !isNaN(d2)) {
        // Convert to improper fractions if whole parts exist
        if (!isNaN(s1)) {
          if (s1 < 0 && n1 > 0) n1 *= -1;
          n1 = d1 * s1 + n1;
        }
        if (!isNaN(s2)) {
          if (s2 < 0 && n2 > 0) n2 *= -1;
          n2 = d2 * s2 + n2;
        }

        let totalN = 0, totalD = 0;

        switch (action) {
          case '+':
            totalN = n1 * d2 + n2 * d1;
            totalD = d1 * d2;
            break;
          case '-':
            totalN = n1 * d2 - n2 * d1;
            totalD = d1 * d2;
            break;
          case '×':
            totalN = n1 * n2;
            totalD = d1 * d2;
            break;
          case '÷':
            totalN = n1 * d2;
            totalD = n2 * d1;
            break;
          default:
            result.error = "Invalid operation";
            return result;
        }

        // GCD and Reduce
        function gcd(a, b) {
          a = Math.abs(a); b = Math.abs(b);
          if (b === 0) return 1;
          while (b !== 0) {
            [a, b] = [b, a % b];
          }
          return a;
        }

        function reduce(num, den) {
          let g = gcd(num, den);
          return [num / g, den / g];
        }

        let g = gcd(totalN, totalD);
        let [upr, btm] = reduce(totalN, totalD);

        result.tech_upr = upr;
        result.tech_btm = btm;
        result.tech_N1 = n1;
        result.tech_N2 = n2;
        result.tech_D1 = d1;
        result.tech_D2 = d2;
        result.tech_totalN = totalN;
        result.tech_totalD = totalD;
        result.tech_g = g;

        return result;
      } else {
        result.error = "Please fill all fields.";
        return result;
      }
    }

     /** getCalculationFractionSimplifierCalculator
   * POST: /api/calculators-lol/fraction-simplifier-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationFractionSimplifierCalculator(body) {
      let n1 = parseFloat(body.tech_n1); // Optional whole number
      let n2 = parseFloat(body.tech_n2); // Numerator
      let d1 = parseFloat(body.tech_d1); // Denominator

      let result = {};

      if (!isNaN(n2) && !isNaN(d1)) {
        let totalN = n2;
        let totalD = d1;

        if (!isNaN(n1)) {
          if (n1 < 0 && totalN > 0) {
            totalN *= -1;
          }
          totalN = totalD * n1 + totalN;
        }

        function gcd(a, b) {
          a = Math.abs(a);
          b = Math.abs(b);
          while (b !== 0) {
            [a, b] = [b, a % b];
          }
          return a || 1;
        }

        function reduce(num, den) {
          const g = gcd(num, den);
          return [num / g, den / g];
        }

        const g = gcd(totalN, totalD);
        const [upr, btm] = reduce(totalN, totalD);

        result.tech_upr = upr;
        result.tech_btm = btm;
        result.tech_totalN = totalN;
        result.tech_totalD = totalD;
        result.tech_g = g;
        return result;
      } else {
        result.error = "Please Check Your Input.";
        return result;
      }
    }

     /** getCalculationDeterminantCalculator
   * POST: /api/calculators-lol/determinant-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationDeterminantCalculator(body) {
      let det = 0;
      let check = true;

      let  dtrmn_slct_method  = body.tech_dtrmn_slct_method;

      dtrmn_slct_method = parseInt(dtrmn_slct_method);
      if (![2, 3, 4, 5].includes(dtrmn_slct_method)) {
        return { error: 'Matrix size not supported. Only 2x2 to 5x5 supported.' };
      }

      let matrix = [];

      for (let i = 0; i < dtrmn_slct_method; i++) {
        let row = [];
        for (let j = 0; j < dtrmn_slct_method; j++) {
          let key = `tech_dtrmn_${i}_${j}`;
          let val = parseFloat(body[key]);
          if (isNaN(val)) {
            return { error: 'Please Check Your Input.' };
          }
          row.push(val);
        }
        matrix.push(row);
      }

      try {
        det = math.round(math.det(matrix), 6);
        return { 
          tech_ans: det,
          };
      } catch (e) {
        return { error: 'Determinant could not be calculated.' };
      }
    }
     /** getCalculationEigenvectorCalculator
   * POST: /api/calculators-lol/eigenvectors-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
    async  getCalculationEigenvectorCalculator(body) {
        let matrix = body.tech_matrix;
        let matrix_0_0 = body.tech_matrix_0_0;
        let matrix_0_1 = body.tech_matrix_0_1;
        let matrix_0_2 = body.tech_matrix_0_2;
        let matrix_1_0 = body.tech_matrix_1_0;
        let matrix_1_1 = body.tech_matrix_1_1;
        let matrix_1_2 = body.tech_matrix_1_2;
        let matrix_2_0 = body.tech_matrix_2_0;
        let matrix_2_1 = body.tech_matrix_2_1;
        let matrix_2_2 = body.tech_matrix_2_2;


        function isNumeric(val) {
      return !isNaN(parseFloat(val)) && isFinite(val);
    }



      try {
        let params = {};
        if (matrix === '2' &&
            isNumeric(matrix_0_0) && isNumeric(matrix_0_1) &&
            isNumeric(matrix_1_0) && isNumeric(matrix_1_1)) {
          params = {
            matrix,
            matrix_0_0,
            matrix_0_1,
            matrix_1_0,
            matrix_1_1
          };
        } else if (matrix === '3' &&
            isNumeric(matrix_0_0) && isNumeric(matrix_0_1) && isNumeric(matrix_0_2) &&
            isNumeric(matrix_1_0) && isNumeric(matrix_1_1) && isNumeric(matrix_1_2) &&
            isNumeric(matrix_2_0) && isNumeric(matrix_2_1) && isNumeric(matrix_2_2)) {
          params = {
            matrix,
            matrix_0_0,
            matrix_0_1,
            matrix_0_2,
            matrix_1_0,
            matrix_1_1,
            matrix_1_2,
            matrix_2_0,
            matrix_2_1,
            matrix_2_2
          };
        } else {
          return { error: 'Please! Check Your Input.' };
        }

        const response = await axios.get('http://167.172.134.148/eigenvectors', { params });
        const buffer = response.data.split('@@@');

        if (matrix === '2') {
          return {
            tech_eigvecs: buffer[0],
            tech_d: buffer[1],
            tech_dtrmnt: buffer[2],
            tech_l1: buffer[3],
            tech_l2: buffer[4],
            tech_mul: buffer[5],
            tech_eigvals: buffer[6],
            tech_eigvals1: buffer[7],
            tech_eigvals2: buffer[8],
            tech_a: buffer[9],
            tech_eigvecs1: buffer[10],
            tech_eigvecs2: buffer[11],
            tech_b: buffer[12],
            tech_res1: buffer[13],
            tech_res2: buffer[14],
          };
        } else {
          return {
            tech_eigvecs: buffer[0],
            tech_d: buffer[1],
            tech_dtrmnt: buffer[2],
            tech_l1: buffer[3],
            tech_l2: buffer[4],
            tech_l3: buffer[5],
            tech_mul: buffer[6],
            tech_eigvals: buffer[7],
            tech_eigvals1: buffer[8],
            tech_eigvals2: buffer[9],
            tech_eigvals3: buffer[10],
            tech_a: buffer[11],
            tech_eigvecs1: buffer[12],
            tech_eigvecs2: buffer[13],
            tech_eigvecs3: buffer[14],
            tech_b: buffer[15],
            tech_res1: buffer[16],
            tech_res2: buffer[17],
            tech_res3: buffer[18],
            tech_c: buffer[19],
          };
        }
      } catch (err) {
        return { error: 'Please! Check Your Input.' };
      }
    }
     /** getCalculationNullSpaceCalculator
   * POST: /api/calculators-lol/null-space-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async getCalculationNullSpaceCalculator(body) {
      let row = body.tech_row;
      let colum = body.tech_colum;

      let input = '';

      for (let i = 0; i < row; i++) {
        for (let j = 0; j < colum; j++) {
          let key = `tech_matrix_${i}_${j}`;
          if (!isNumeric(body[key])) {
            return { error: 'Please enter only numeric values.' };
          }

          input += body[key];
          if (j !== colum - 1) input += ',';
        }
        if (i !== row - 1) input += '@@';
      }

      try {
        const response = await axios.get('http://167.172.134.148/null', {
          params: { mat: input },
          timeout: 120000
        });

        const buffer = response.data.split('@@@');
        let reff = buffer[0].replace('\\left( \\left[', '\\left[');
        reff = reff.split('\\left(')[0].split(',');

        return {
          tech_rref: reff[0],
          tech_null: buffer[1],
          tech_enter: buffer[2],
          tech_total: buffer[3],
          tech_input: input,
          tech_row: row,
          tech_colum: colum,
        };
      } catch (error) {
        return { error: 'Please! Check Your Input.' };
      }

      function isNumeric(val) {
        return !isNaN(parseFloat(val)) && isFinite(val);
      }
    }


    /** getCalculationMatrixMultiplicationCalculator
   * POST: /api/calculators-lol/matrix-multiplication-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationMatrixMultiplicationCalculator(body) {
      let rows1 = body.tech_rows1;
      let columns1 = body.tech_columns1;
      let matrix2 = body.tech_matrix2;
      let matrix22 = body.tech_matrix22;

      let r = [], m = [], l = [];

      function isNumeric(val) {
        return !isNaN(parseFloat(val)) && isFinite(val);
      }

      if (columns1 != matrix2) {
        return {
          error: 'The number of columns in the first matrix should be equal to the number of rows in the second.',
        };
      }

      // First matrix validation and flattening
      for (let i = 1; i <= rows1; i++) {
        for (let j = 1; j <= columns1; j++) {
          let key = `tech_matrix${i}_${j}`;
          if (body[key] !== undefined && isNumeric(body[key])) {
            r.push(parseFloat(body[key]));
          } else {
            return { error: 'Please! Check Your Input.111' };
          }
        }
      }

      // Second matrix validation and flattening
      for (let i = 1; i <= matrix2; i++) {
        for (let j = 1; j <= matrix22; j++) {
          let key = `tech_matrix3${i}_${j}`;
          if (body[key] !== undefined && isNumeric(body[key])) {
            m.push(parseFloat(body[key]));
          } else {
            return { error: 'Please! Check Your Input.2222' };
          }
        }
      }

      // Matrix multiplication
      let result = [];
      for (let i = 1; i <= rows1; i++) {
        result[i] = [];
        for (let j = 1; j <= matrix22; j++) {
          result[i][j] = 0;
          for (let k = 1; k <= matrix2; k++) {
            result[i][j] +=
              parseFloat(body[`tech_matrix${i}_${k}`]) *
              parseFloat(body[`tech_matrix3${k}_${j}`]);
          }
          l.push(result[i][j]);
        }
      }

      return {
        tech_r:r,
        tech_l:l,
      };
    }

    /** getCalculationSGPAToPercentageCalculator
   * POST: /api/calculators-lol/sgpa-to-percentage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationSGPAToPercentageCalculator(body) {
      let type = body.tech_type;
      let sgp = body.tech_sgp;
      let sgpa = body.tech_sgpa;
      let selection = body.tech_selection;
      let number_of_semesters = body.tech_number_of_semesters;
      let sum = body.tech_sum;

      function isNumeric(val) {
        return !isNaN(parseFloat(val)) && isFinite(val);
      }

      if (type === "first") {
        if (selection === "1") {
          if (isNumeric(sgp)) {
            let single_value = (sgp - 0.75) * 10;
            return {
              tech_final_gpa: single_value,
            };
          } else {
            return { error: "Please Check Your Input." };
          }
        } else if (selection === "2") {
          if (isNumeric(number_of_semesters) && isNumeric(sum)) {
            if (number_of_semesters > 0 && sum > 0) {
              if (number_of_semesters < 25) {
                let semester = number_of_semesters * 10;
                if (sum > semester) {
                  return {
                    error: `Sgpa should be within ${semester}`
                  };
                } else {
                  let final_result = sum / number_of_semesters;
                  return {
                    tech_final_result:final_result,
                  };
                }
              } else {
                return { error: "Enter number of semester below 25." };
              }
            } else {
              return { error: "Please! Enter Positive Number." };
            }
          } else {
            return { error: "Please Check Your Input." };
          }
        }
      } else if (type === "second") {
        if (!Array.isArray(sgpa)) {
          return { error: "Please provide SGPA as an array." };
        }

        let count = sgpa.length;
        let total = 0;

        for (let i = 0; i < count; i++) {
          if (isNumeric(sgpa[i])) {
            total += parseFloat(sgpa[i]);
          } else {
            return { error: "Please Check Your Input." };
          }
        }

        let percentage = total / count;
        let final_gpa = (percentage - 0.75) * 10;

        return {
          tech_final_gpa:final_gpa,
          tech_percentage:percentage,
          tech_sgpa:sgpa,
        };
      }

      return { error: "Invalid type." };
    }
     /** getCalculationHexCalculator
   * POST: /api/calculators-lol/hex-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationHexCalculator(body) {
      let type = body.tech_type;
      let bnr_frs = body.tech_bnr_frs;
      let bnr_sec = body.tech_bnr_sec;
      let bnr_slc = body.tech_bnr_slc;
      let options = body.tech_options;
      let nmbr = body.tech_nmbr;

      function bnrCal(fN, sN, op) {
        let rN, binary, decimal, hexa, octal, operate;

        if (op === "add") {
          rN = fN + sN;
          operate = "+";
        } else if (op === "sub") {
          rN = fN - sN;
          operate = "-";
        } else if (op === "mul") {
          rN = fN * sN;
          operate = "×";
        } else if (op === "divide") {
          rN = fN / sN;
          operate = "÷";
        } else {
          return null;
        }

        decimal = rN;
        const absVal = Math.abs(decimal);
        binary = (decimal < 0 ? "-" : "") + parseInt(absVal, 10).toString(2);
        hexa = (decimal < 0 ? "-" : "") + parseInt(absVal, 10).toString(16).toUpperCase();
        octal = (decimal < 0 ? "-" : "") + parseInt(absVal, 10).toString(8);

        return { binary, decimal, hexa, octal, operate };
      }

      if (type === "first") {
        if (!bnr_frs || !bnr_sec) {
          return { error: "Please! Check Your Input." };
        }

        let fN = parseInt(bnr_frs, 16);
        let sN = parseInt(bnr_sec, 16);
        let result = bnrCal(fN, sN, bnr_slc);

        if (!result) return { error: "Invalid operation." };

        return {
          tech_type:type,
          tech_first_ans1: bnr_frs,
          tech_second_ans1: bnr_sec,
          tech_first_ans: fN,
          tech_second_ans: sN,
          tech_bn: result.binary,
          tech_dc: result.decimal,
          tech_hx: result.hexa,
          tech_oc: result.octal,
          tech_op: result.operate,
        };
      }

      if (type === "second") {
        if (!nmbr) return { error: "Please! Check Your Input." };

        let answer, text;

        switch (options) {
          case "1":
            answer = parseInt(nmbr, 16).toString(10);
            text = "Decimal numeral";
            break;
          case "2":
            answer = parseInt(nmbr, 10).toString(16);
            text = "Hex numeral";
            break;
          case "3":
            answer = parseInt(nmbr, 16).toString(2);
            text = "Binary numeral";
            break;
          case "4":
            answer = parseInt(nmbr, 2).toString(16);
            text = "Hex numeral";
            break;
          default:
            return { error: "Invalid option." };
        }

        return {
          tech_type:type,
          tech_answer:answer,
          tech_text:text,
        };
      }

      return { error: "Please! Check Your Input." };
    }

       /** getCalculationMatrixTransposeCalculator
   * POST: /api/calculators-lol/matrix-transpose-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationMatrixTransposeCalculator(body) {
      let matrix2 = parseInt(body.tech_matrix2);
      let matrix22 = parseInt(body.tech_matrix22);
      let second_matrix = [];
      let chuti = [];

      for (let i = 1; i <= matrix2; i++) {
        for (let j = 1; j <= matrix22; j++) {
          const key = `tech_matrix3${i}_${j}`;
          const val = body[key];

          if (val !== undefined && !isNaN(val)) {
            second_matrix.push(Number(val));
            chuti.push(`&${key}=`);
          } else {
            return { error: "Please! Check Your Input." };
          }
        }
      }

      function transpose(A) {
        let rows = A.length;
        if (rows === 0) return A;
        let cols = A[0].length;
        let result = [];

        for (let j = 0; j < cols; j++) {
          result[j] = [];
          for (let i = 0; i < rows; i++) {
            result[j][i] = A[i][j];
          }
        }

        return result;
      }

      const mul = matrix2 * matrix22;

      if (mul === second_matrix.length) {
        const zain = [];
        for (let i = 0; i < matrix2; i++) {
          zain.push(second_matrix.slice(i * matrix22, (i + 1) * matrix22));
        }
        const jawab = transpose(zain);

        return {
          tech_zain:zain,
          tech_jawab:jawab,
          tech_chuti:chuti,
          tech_second_matrix:second_matrix,
        };
      } else {
        return { error: "Please! Check Your Input." };
      }
    }


     /** getCalculationWeightedAverageCalculator
   * POST: /api/calculators-lol/weighted-average-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationWeightedAverageCalculator(body) {
      let weight = body.tech_weight;
      let value = body.tech_value;

      if (!Array.isArray(weight) || !Array.isArray(value)) {
        return { error: "Input must be arrays of numbers." };
      }

      let i = 0;
      let weight_sum = 0;
      let weighted_average = 0;

      while (i < weight.length && i < value.length) {
        let w = parseFloat(weight[i]);
        let v = parseFloat(value[i]);

        if (!isFinite(w) || !isFinite(v)) {
          return { error: "Please! Check Your Input." };
        }

        weight_sum += w;
        weighted_average += w * v;
        i++;
      }

      if (weight_sum === 0) {
        return { error: "Total weight cannot be zero." };
      }

      let final_ans = weighted_average / weight_sum;

      return {
        tech_weight_sum:weight_sum,
        tech_weighted_average: final_ans,
        tech_wv: weight.length,
        tech_v: value.length,
        tech_values: value,
        tech_weights: weight,
      };
    }


    /** getCalculationTestGradeCalculator
   * POST: /api/calculators-lol/test-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationTestGradeCalculator(body) {
        let grades = body.tech_grades;
        let first = body.tech_first;
        let second = body.tech_second;
        let increment = body.tech_increment;
        let aplus = body.tech_aplus;
        let a = body.tech_a;
        let aminus = body.tech_aminus;
        let bplus = body.tech_bplus;
        let b = body.tech_b;
        let bminus = body.tech_bminus;
        let cplus = body.tech_cplus;
        let c = body.tech_c;
        let cminus = body.tech_cminus;
        let dplus = body.tech_dplus;
        let d = body.tech_d;
        let dminus = body.tech_dminus;


      first = parseFloat(first);
      second = parseFloat(second);
      increment = Math.floor(parseFloat(increment));

      if (
        isNaN(first) ||
        isNaN(second) ||
        isNaN(increment) ||
        increment <= 0
      ) {
        return { error: 'Please Check Your Input.' };
      }

      let q_array = [], i_array = [], g_array = [], l_array = [], letter_ans = '', lettertbl = [], percenttbl = [];

      for (let j = first; j >= 0; j -= increment) {
        q_array.push(j);
      }

      for (let i = 0; i <= first; i += increment) {
        i_array.push(i);
      }

      let correct = first - second;
      let per = Math.round((100 * correct) / first);

      if (parseInt(grades) === 1) {
        a = parseFloat(a);
        b = parseFloat(b);
        c = parseFloat(c);
        d = parseFloat(d);

        if ([a, b, c, d].some(isNaN)) {
          return { error: 'Please Check Your Input.' };
        }
        if (a < b || b < c || c < d) {
          return { error: 'Grade limits are not in correct descending order.' };
        }

        lettertbl = ['A', 'B', 'C', 'D', 'F'];
        percenttbl = [a, b, c, d, 0];

      } else if (parseInt(grades) === 2) {
        aplus = parseFloat(aplus);
        a = parseFloat(a);
        aminus = parseFloat(aminus);
        bplus = parseFloat(bplus);
        b = parseFloat(b);
        bminus = parseFloat(bminus);
        cplus = parseFloat(cplus);
        c = parseFloat(c);
        cminus = parseFloat(cminus);
        dplus = parseFloat(dplus);
        d = parseFloat(d);
        dminus = parseFloat(dminus);

        let limits = [aplus, a, aminus, bplus, b, bminus, cplus, c, cminus, dplus, d, dminus];

        if (limits.some(isNaN)) {
          return { error: 'Please Check Your Input.' };
        }

        for (let i = 0; i < limits.length - 1; i++) {
          if (limits[i] < limits[i + 1]) {
            return { error: 'Grade limits are not in correct descending order.' };
          }
        }

        lettertbl = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'D+', 'D', 'D-', 'F'];
        percenttbl = [...limits, 0];
      }

      for (let i = 0; i < percenttbl.length; i++) {
        if (per >= percenttbl[i]) {
          letter_ans = lettertbl[i];
          break;
        }
      }

      for (let k = 0; k < q_array.length; k++) {
        let grade = Math.round((100 * q_array[k]) / first);
        for (let i = 0; i < percenttbl.length; i++) {
          if (grade >= percenttbl[i]) {
            l_array.push(lettertbl[i]);
            break;
          }
        }
        g_array.push(grade);
      }

      return {
        tech_first:first,
        tech_correct:correct,
        tech_per:per,
        tech_letter_ans:letter_ans,
        tech_q_array:q_array,
        tech_i_array:i_array,
        tech_g_array:g_array,
        tech_l_array:l_array,
      };
    }


      /** getCalculationMarksPercentageCalculator
   * POST: /api/calculators-lol/marks-percentage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationMarksPercentageCalculator(body) {
      let type = body.tech_type;
      let first = body.tech_first;
      let second = body.tech_second;
      let sub_name = body.tech_sub_name; // array
      let s_marks = body.tech_s_marks;   // array
      let a_marks = body.tech_a_marks;   // array

      let result = {};

      if (type === "first") {
        if (isNumeric(first) && isNumeric(second)) {
          if (parseFloat(first) <= parseFloat(second)) {
            let percent = (parseFloat(first) / parseFloat(second)) * 100;
            result.tech_type = type;
            result.tech_percent = percent;
            return result;
          } else {
            return { error: 'Total scored marks should be less than out of marks.' };
          }
        } else {
          return { error: 'Please! Check Your Input' };
        }
      } else if (type === "second") {
        let name_array = [];
        let s_array = [];
        let a_array = [];

        if (
          Array.isArray(sub_name) &&
          Array.isArray(s_marks) &&
          Array.isArray(a_marks)
        ) {
          let y = 0;
          while (y < sub_name.length && y < s_marks.length && y < a_marks.length) {
            if (
              sub_name[y] &&
              isNumeric(s_marks[y]) &&
              isNumeric(a_marks[y])
            ) {
              name_array.push(sub_name[y]);
              s_array.push(parseFloat(s_marks[y]));
              a_array.push(parseFloat(a_marks[y]));
            } else {
              return { error: 'Please! Check Your Input' };
            }
            y++;
          }

          let total_scored = s_array.reduce((a, b) => a + b, 0);
          let total_marks = a_array.reduce((a, b) => a + b, 0);
          let percent = (total_scored / total_marks) * 100;

          result.tech_name_array = name_array;
          result.tech_s_array = s_array;
          result.tech_a_array = a_array;
          result.tech_total_scored = total_scored;
          result.tech_total_marks = total_marks;
          result.tech_type = type;
          result.tech_percent = percent;
          return result;
        } else {
          return { error: 'Invalid input arrays.' };
        }
      }

      function isNumeric(val) {
        return !isNaN(parseFloat(val)) && isFinite(val);
      }
    }


      /** getCalculationDecimalCalculator
   * POST: /api/calculators-lol/decimal-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationDecimalCalculator(body) {
      let method = body.tech_method;
      let rounding = body.tech_rounding;
      let a = body.tech_a;
      let b = body.tech_b;

      let result = {};

      if (isNumeric(a) && isNumeric(b)) {
        a = parseFloat(a);
        b = parseFloat(b);
        let ans;
        let res = "";

        switch (method) {
          case "1":
            ans = a + b;
            res = `<p class='mt-2'>a + b = ?</p> <p class='mt-2'>${a} + ${b} = ${ans}</p>`;
            break;
          case "2":
            ans = a - b;
            res = `<p class='mt-2'>a - b = ?</p> <p class='mt-2'>${a} - ${b} = ${ans}</p>`;
            break;
          case "3":
            ans = a * b;
            res = `<p class='mt-2'>a x b = ?</p> <p class='mt-2'>${a} x ${b} = ${ans}</p>`;
            break;
          case "4":
            ans = a / b;
            res = `<p class='mt-2'>a ÷ b = ?</p> <p class='mt-2'>${a} ÷ ${b} = ${ans}</p>`;
            break;
          case "5":
            // Optional decimal adjustment logic (preserved for parity with PHP)
            ans = Math.pow(a, b);
            res = `a<sup class='font-s-14'>b</sup> = ?`;
            break;
          case "6":
            ans = Math.pow(a, 1 / b);
            res = `<sup class='font-s-14'>b</sup>√a = ?`;
            break;
          case "7":
            ans = Math.log(b) / Math.log(a);
            res = `log<sub class='font-s-14'>a</sub>b = ?`;
            break;
          default:
            return { error: "Invalid method selected." };
        }

        if (rounding !== "not" && isNumeric(rounding)) {
          result.round_ans = parseFloat(ans.toFixed(parseInt(rounding)));
        }

        result.tech_ans = ans;
        result.tech_res = res;
        return result;
      } else {
        return { error: "Please! Check Your Input." };
      }

      function isNumeric(val) {
        return !isNaN(parseFloat(val)) && isFinite(val);
      }
    }


     /** getCalculationVennDiagramCalculator
   * POST: /api/calculators-lol/venn-diagram-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationVennDiagramCalculator(body) {
      let submit = (body.tech_selection || '').trim();
      let venn_name = (body.tech_venn_name || '').trim();
      let ta = (body.tech_ta || '').trim();
      let tb = (body.tech_tb || '').trim();
      let a = (body.tech_a || '').trim();
      let b = (body.tech_b || '').trim();
      let u = (body.tech_u || '').trim();
      let c = (body.tech_c || '').trim();
      let venn_name3 = (body.tech_venn_name3 || '').trim();
      let ta3 = (body.tech_ta3 || '').trim();
      let tb3 = (body.tech_tb3 || '').trim();
      let tc3 = (body.tech_tc3 || '').trim();
      let a3 = (body.tech_a3 || '').trim();
      let b3 = (body.tech_b3 || '').trim();
      let c3 = (body.tech_c3 || '').trim();
      let u3 = (body.tech_u3 || '').trim();
      let anb3 = (body.tech_anb3 || '').trim();
      let bnc3 = (body.tech_bnc3 || '').trim();
      let cna3 = (body.tech_cna3 || '').trim();
      let anbnc = (body.tech_anbnc || '').trim();

      let param = {};

      if (submit === 'twoset') {
        if (venn_name && ta && tb && isNumeric(a) && isNumeric(b) && isNumeric(u) && isNumeric(c)) {
          a = parseFloat(a);
          b = parseFloat(b);
          u = parseFloat(u);
          c = parseFloat(c);

          let a_only = a - c;
          let b_only = b - c;
          let res = a_only + b_only + c;
          let res2set = u - res;

          param = {
            tech_res2set:res2set,
            tech_a:a,
            tech_b:b,
            tech_c:c,
            tech_u:u,
            tech_venn_name:venn_name,
            tech_ta:ta,
            tech_tb:tb,
            tech_res:res,
          };
        } else {
          return { error: 'Please! Check Your Input' };
        }
      } else if (submit === 'threeset') {
        if (
          venn_name3 && ta3 && tb3 && tc3 &&
          isNumeric(a3) && isNumeric(b3) && isNumeric(c3) &&
          isNumeric(u3) && isNumeric(anb3) &&
          isNumeric(bnc3) && isNumeric(cna3) && isNumeric(anbnc)
        ) {
          a3 = parseFloat(a3);
          b3 = parseFloat(b3);
          c3 = parseFloat(c3);
          u3 = parseFloat(u3);
          anb3 = parseFloat(anb3);
          bnc3 = parseFloat(bnc3);
          cna3 = parseFloat(cna3);
          anbnc = parseFloat(anbnc);

          let ab = anb3 - anbnc;
          let bc = bnc3 - anbnc;
          let ca = cna3 - anbnc;

          let a_only = a3 - (ab + anbnc + ca);
          let b_only = b3 - (bc + anbnc + ab);
          let c_only = c3 - (bc + anbnc + ca);
          let res = a_only + b_only + c_only + ab + bc + ca + anbnc;
          let d = u3 - res;

          param = {
            tech_venn_name3:venn_name3,
            tech_ta3:ta3,
            tech_tb3:tb3,
            tech_tc3:tc3,
            tech_a3:a3,
            tech_b3:b3,
            tech_c3:c3,
            tech_u3:u3,
            tech_anb3:anb3,
            tech_bnc3:bnc3,
            tech_cna3:cna3,
            tech_anbnc:anbnc,
            tech_a_only:a_only,
            tech_b_only:b_only,
            tech_c_only:c_only,
            tech_ab:ab,
            tech_bc:bc,
            tech_ca:ca,
            tech_d:d,
            tech_res:res,
          };
        } else {
          return { error: 'Please! Check Your Input' };
        }
      } else {
        return { error: 'Please! Check Your Input' };
      }

      return param;

      function isNumeric(val) {
        return !isNaN(parseFloat(val)) && isFinite(val);
      }
    }

     /** getCalculationFundamentalCountingPrincipleCalculator
   * POST: /api/calculators-lol/fundamental-counting-principle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationFundamentalCountingPrincipleCalculator(body) {
      let choices = body.tech_choices; // should be an array

      let result = {};

      if (Array.isArray(choices) && choices.length > 0 && isNumeric(choices[0])) {
        let answer = 1;

        for (let value of choices) {
          if (!isNumeric(value)) {
            return { error: 'Please! Check Your Input.' };
          }
          answer *= parseFloat(value);
        }

        result.tech_answer = answer;
        result.tech_choices = choices;
        return result;
      } else {
        return { error: 'Please! Check Your Input.' };
      }

      function isNumeric(val) {
        return !isNaN(parseFloat(val)) && isFinite(val);
      }
    }

     /** getCalculationAveragePercentageCalculator
   * POST: /api/calculators-lol/average-percentage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationAveragePercentageCalculator(body) {
      let same_sample = body.tech_same_sample;
      let percentage = body.tech_percentage;
      let sample = body.tech_sample;

      let result = {};
      let check = true;

      // Ensure arrays are filtered for non-empty values
      percentage = Array.isArray(percentage)
        ? percentage.filter(val => val !== '' && val !== null && val !== undefined)
        : [];
      sample = Array.isArray(sample)
        ? sample.filter(val => val !== '' && val !== null && val !== undefined)
        : [];

      if (same_sample === 'yes') {
        if (percentage.length < 2) check = false;
      } else {
        if (percentage.length < 2 || sample.length < 2) check = false;
      }

      if (!check) {
        return { error: 'Please! Check Your Input.111' };
      }

      let percents_sum, samples_sum, resultValue;

      if (same_sample === 'yes') {
        percents_sum = percentage.reduce((sum, val) => sum + parseFloat(val), 0);
        samples_sum = percentage.length;
      } else {
        let percents = [];
        let percents_show = '';
        let percents_show1 = '';

        for (let i = 0; i < percentage.length; i++) {
          let p = parseFloat(percentage[i]);
          let s = parseFloat(sample[i]);
          let product = p * s;
          percents.push(product);

          let plus = i + 1 !== percentage.length ? ' + ' : '';
          percents_show += `${p}\\% * ${s}${plus}`;
          percents_show1 += `${product}\\%${plus}`;
        }

        percents_sum = percents.reduce((sum, val) => sum + val, 0);
        samples_sum = sample.reduce((sum, val) => sum + parseFloat(val), 0);

        result.tech_percents_show = percents_show;
        result.tech_percents_show1 = percents_show1;
      }

      result.tech_percentage = percentage;
      result.tech_sample = sample;
      result.tech_percents_sum = percents_sum;
      result.tech_samples_sum = samples_sum;
      result.tech_same_sample = same_sample;
      result.tech_result = percents_sum / samples_sum;

      return result;
    }


     /** getCalculationLinearIndependenceCalculator
   * POST: /api/calculators-lol/linear-independence-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationLinearIndependenceCalculator(body) {
      let row = body.tech_row;
      let colum = body.tech_colum;

      let check = true;

      for (let i = 0; i < row; i++) {
        for (let j = 0; j < colum; j++) {
          let key = `tech_matrix_${i}_${j}`;
          if (!isNumeric(body[key])) {
            check = false;
          }
        }
      }

      if (check) {
        return {
          tech_row: row,
          tech_colum: colum
        };
      } else {
        return {
          error: 'Please! Check Your Input.'
        };
      }

      function isNumeric(val) {
        return !isNaN(parseFloat(val)) && isFinite(val);
      }
    }


     /** getCalculationPercentChangeCalculator
   * POST: /api/calculators-lol/percentage-change-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationPercentChangeCalculator(body) {
      let initial_value = body.tech_initial_value;
      let final_value = body.tech_final_value;

      let result = {};

      if (isNumeric(initial_value) && isNumeric(final_value)) {
        initial_value = parseFloat(initial_value);
        final_value = parseFloat(final_value);

        let difference = final_value - initial_value;
        let answer = ((difference) / Math.abs(initial_value)) * 100;

        result.tech_answer = answer;
        result.tech_difference = difference;
        return result;
      } else {
        return {
          error: 'Please provide both the initial and final values to proceed.'
        };
      }

      function isNumeric(val) {
        return !isNaN(parseFloat(val)) && isFinite(val);
      }
    }

     /** getCalculationTaylorSeriesCalculator
   * POST: /api/calculators-lol/taylor-series-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async  getCalculationTaylorSeriesCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let point = body.tech_point;
    let find = body.tech_find ?? '';
    let n = body.tech_n;
    let withVar = body.tech_with;

    let result = {};

    // Input validation
    const unsafePattern = /[<>&]|php|print_r|print|echo|script|=|%/i;
    if (!EnterEq || unsafePattern.test(EnterEq)) {
      return { error: 'Please! Check Your Input.' };
    }

    if (EnterEq.indexOf(withVar) === -1) {
      return { error: `Variable ${withVar} does not exist in the function` };
    }

    if (!isNumeric(point) || !isNumeric(n)) {
      return { error: 'Please! Check Your Input.' };
    }

    // Sanitizing the equation
    let parem = EnterEq.replace(/\s+/g, '')
      .replace(/\+/g, 'plus')
      .replace(/{/g, '(')
      .replace(/}/g, ')')
      .replace(/e\^sqrt\(x\)/g, 'exp(2*x)')
      .replace(/e\^x/g, 'exp(x)')
      .replace(/e\^y/g, 'exp(y)')
      .replace(/e\^/g, 'exp')
      .replace(/exp\^/g, 'exp')
      .replace(/\^/g, '**');

    try {
      const response = await axios.get('http://167.172.134.148/taylor', {
        timeout: 120000,
        params: {
          equ: parem,
          wrt: withVar,
          how: n,
          find: find,
          point: point
        }
      });

      const buffer = response.data.split('@HA_');

      result.tech_eexe = buffer[0];
      result.tech_enter = buffer[1];
      result.tech_res = buffer[2];
      result.tech_series = buffer[3];

      if (isNumeric(find)) {
        result.tech_efun = buffer[4];
        result.tech_eser = buffer[5];
        result.tech_efv = buffer[6];
        result.tech_fsv = buffer[7];
        result.tech_err = buffer[8];
      }

      return result;
    } catch (err) {
      return { error: 'Please! Check Your Input.' };
    }

    function isNumeric(val) {
      return !isNaN(parseFloat(val)) && isFinite(val);
    }
  }

     /** getCalculationDerivativeCalculator
   * POST: /api/calculators-lol/derivative-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationDerivativeCalculator(body) {
      let EnterEq = body.tech_EnterEq;
      let withVar = body.tech_with;
      let how = body.tech_how;

      let result = {};

      // Input validation
      const unsafePattern = /[<>&]|php|print_r|print|echo|script|=|%/i;
      if (!EnterEq || unsafePattern.test(EnterEq)) {
        return { error: 'Please! Check Your Input.' };
      }

      if (!EnterEq || !withVar || !how) {
        return { error: 'Please! Check Your Input.' };
      }

      // Equation sanitization
      let parem = EnterEq.replace(/\s+/g, '')
        .replace(/\+/g, 'plus')
        .replace(/{/g, '(')
        .replace(/}/g, ')')
        .replace(/e\^sqrt\(x\)/g, 'exp(2*x)')
        .replace(/e\^x/g, 'exp(x)')
        .replace(/e\^/g, 'exp')
        .replace(/exp\^/g, 'exp')
        .replace(/\^/g, '**');

      try {
        const response = await axios.get('http://167.172.134.148/derivative', {
          timeout: 120000,
          params: {
            equ: parem,
            wrt: withVar,
            how: how
          }
        });

        const buffer = response.data.split('@@@');

        if (parseInt(how) > 1) {
          result.tech_enter = buffer[0];
          result.tech_final_res = buffer;
        } else {
          result.tech_buffer = buffer[0];
          result.tech_ans = buffer[1];
          result.tech_enter = buffer[2];
          result.tech_simple = buffer[3];
        }

        return result;
      } catch (err) {
        return { error: 'Please! Check Your Input.' };
      }
    }

     /** getCalculationCircumcenterCalculator
   * POST: /api/calculators-lol/circumcenter-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

    async  getCalculationCircumcenterCalculator(body) {
      let x1 = body.tech_x1;
      let y1 = body.tech_y1;
      let x2 = body.tech_x2;
      let y2 = body.tech_y2;
      let x3 = body.tech_x3;
      let y3 = body.tech_y3;

      let result = {};

      function isNumeric(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
      }

      if (
        isNumeric(x1) && isNumeric(y1) &&
        isNumeric(x2) && isNumeric(y2) &&
        isNumeric(x3) && isNumeric(y3)
      ) {
        x1 = +x1; y1 = +y1;
        x2 = +x2; y2 = +y2;
        x3 = +x3; y3 = +y3;

        // Midpoints and slopes for AB, BC, CA
        let m1x = (x1 + x2) / 2;
        let m1y = (y1 + y2) / 2;
        let m2x = (x2 + x3) / 2;
        let m2y = (y2 + y3) / 2;
        let m3x = (x3 + x1) / 2;
        let m3y = (y3 + y1) / 2;

        let slopeAB = (y2 - y1) / (x2 - x1);
        let slopeBC = (y3 - y2) / (x3 - x2);
        let slopeCA = (y3 - y1) / (x3 - x1);

        let perpAB = -1 / slopeAB;
        let perpBC = -1 / slopeBC;
        let perpCA = -1 / slopeCA;

        let x, y;

        if (isFinite(perpAB) && isFinite(perpBC)) {
          let b1 = m1y - perpAB * m1x;
          let b2 = m2y - perpBC * m2x;
          x = (b2 - b1) / (perpAB - perpBC);
          y = perpAB * x + b1;
        } else if (isFinite(perpBC) && isFinite(perpCA)) {
          let b2 = m2y - perpBC * m2x;
          let b3 = m3y - perpCA * m3x;
          x = (b3 - b2) / (perpBC - perpCA);
          y = perpBC * x + b2;
        } else if (isFinite(perpAB) && isFinite(perpCA)) {
          let b1 = m1y - perpAB * m1x;
          let b3 = m3y - perpCA * m3x;
          x = (b3 - b1) / (perpAB - perpCA);
          y = perpAB * x + b1;
        } else {
          return { error: "Cannot calculate circumcenter due to degenerate triangle." };
        }

        result.tech_x = x;
        result.tech_y = y;
        return result;
      } else {
        return { error: 'Please! Check Your Input.' };
      }
    }

      async getCalculationRoofPitchCalculator(body) {
      try {
          let submit = body.tech_submit;
          let x = body.tech_x;
          let y = body.tech_y;
          let unit = body.tech_unit;
          let unit_r = body.tech_unit_r;
          let unit_a = body.tech_unit_a;
          let from = body.tech_from;

          let rise = parseFloat(x);
          let run = parseFloat(y);
          
          // Validate numeric inputs
          if (isNaN(rise) || isNaN(run)) {
              return {
                  error: 'Please! Fill all the Input Fields',
              };
          }

          let pitch, rafter, angle, xValue, P;

          // Helper function to convert to meters
          const convertToMeters = (value, unitType) => {
              switch (unitType) {
                  case 'ft':
                      return value / 3.281;
                  case 'in':
                      return value / 39.37;
                  case 'yd':
                      return value / 1.094;
                  default:
                      return value;
              }
          };

          // Case 1: Rise and Run provided
          if (from === '1') {
              rise = convertToMeters(rise, unit);
              run = convertToMeters(run, unit_r);
              
              P = `${Math.round(rise * 3.281)}/${Math.round(run * 3.281 * 2)}`;
              pitch = Math.round((rise / run) * 100 * 100) / 100;
              rafter = Math.round(Math.sqrt(rise * rise + run * run) * 100) / 100;
              angle = Math.round(Math.atan(pitch / 100) * (180 / Math.PI) * 100) / 100;
              xValue = Math.round((pitch / 100) * 12 * 100) / 100;
          }
          
          // Case 2: Rise and Rafter provided
          else if (from === '2') {
              rafter = parseFloat(y);
              rise = convertToMeters(rise, unit);
              rafter = convertToMeters(rafter, unit_r);
              
              run = Math.round(Math.sqrt(rafter * rafter - rise * rise) * 100) / 100;
              P = `${Math.round(rise * 3.281)}/${Math.round(run * 3.281 * 2)}`;
              pitch = Math.round((rise / run) * 100 * 100) / 100;
              angle = Math.round(Math.atan(pitch / 100) * (180 / Math.PI) * 100) / 100;
              xValue = Math.round((pitch / 100) * 12 * 100) / 100;
          }
          
          // Case 3: Run and Rafter provided
          else if (from === '3') {
              run = parseFloat(x);
              rafter = parseFloat(y);
              run = convertToMeters(run, unit);
              rafter = convertToMeters(rafter, unit_r);
              
              rise = Math.round(Math.sqrt(rafter * rafter - run * run) * 100) / 100;
              P = `${Math.round(rise * 3.281)}/${Math.round(run * 3.281 * 2)}`;
              pitch = Math.round((rise / run) * 100 * 100) / 100;
              angle = Math.round(Math.atan(pitch / 100) * (180 / Math.PI) * 100) / 100;
              xValue = Math.round((pitch / 100) * 12 * 100) / 100;
          }
          
          // Case 4: Rise and Pitch provided
          else if (from === '4') {
              pitch = parseFloat(y);
              rise = convertToMeters(rise, unit);
              
              run = Math.round((rise / pitch) * 100 * 100) / 100;
              P = `${Math.round(rise * 3.281)}/${Math.round(run * 3.281 * 2)}`;
              rafter = Math.round(Math.sqrt(rise * rise + run * run) * 100) / 100;
              angle = Math.round(Math.atan(pitch / 100) * (180 / Math.PI) * 100) / 100;
              xValue = Math.round((pitch / 100) * 12 * 100) / 100;
          }
          
          // Case 5: Rise and Angle provided
          else if (from === '5') {
              angle = parseFloat(y);
              rise = convertToMeters(rise, unit);
              
              // Convert angle to radians if in degrees
              if (unit_a === 'deg') {
                  angle = (angle * Math.PI) / 180;
              }
              
              pitch = Math.round(Math.tan(angle) * 100 * 100) / 100;
              run = Math.round((rise / pitch) * 100 * 100) / 100;
              P = `${Math.round(rise * 3.281)}/${Math.round(run * 3.281 * 2)}`;
              rafter = Math.round(Math.sqrt(rise * rise + run * run) * 100) / 100;
              xValue = Math.round((pitch / 100) * 12 * 100) / 100;
              angle = (angle * 180) / Math.PI; // Convert back to degrees
          }
          
          // Case 6: Rise and X (rise per foot) provided
          else if (from === '6') {
              xValue = parseFloat(y);
              rise = convertToMeters(rise, unit);
              
              pitch = Math.round((xValue * 100) / 12 * 100) / 100;
              run = Math.round((rise / pitch) * 100 * 100) / 100;
              P = `${Math.round(rise * 3.281)}/${Math.round(run * 3.281 * 2)}`;
              rafter = Math.round(Math.sqrt(rise * rise + run * run) * 100) / 100;
              angle = Math.round(Math.atan(pitch / 100) * (180 / Math.PI) * 100) / 100;
          }
          
          // Case 7: Run and Pitch provided
          else if (from === '7') {
              run = parseFloat(x);
              pitch = parseFloat(y);
              run = convertToMeters(run, unit);
              
              rise = Math.round((run * pitch) / 100 * 100) / 100;
              P = `${Math.round(rise * 3.281)}/${Math.round(run * 3.281 * 2)}`;
              rafter = Math.round(Math.sqrt(rise * rise + run * run) * 100) / 100;
              angle = Math.round(Math.atan(pitch / 100) * (180 / Math.PI) * 100) / 100;
              xValue = Math.round((pitch / 100) * 12 * 100) / 100;
          }
          
          // Case 8: Run and Angle provided
          else if (from === '8') {
              run = parseFloat(x);
              angle = parseFloat(y);
              run = convertToMeters(run, unit);
              
              // Convert angle to radians if in degrees
              if (unit_a === 'deg') {
                  angle = (angle * Math.PI) / 180;
              }
              
              pitch = Math.round(Math.tan(angle) * 100 * 100) / 100;
              rise = Math.round((run * pitch) / 100 * 100) / 100;
              P = `${Math.round(rise * 3.281)}/${Math.round(run * 3.281 * 2)}`;
              rafter = Math.round(Math.sqrt(rise * rise + run * run) * 100) / 100;
              xValue = Math.round((pitch / 100) * 12 * 100) / 100;
              angle = (angle * 180) / Math.PI; // Convert back to degrees
          }
          
          // Case 9: Run and X (rise per foot) provided
          else if (from === '9') {
              run = parseFloat(x);
              xValue = parseFloat(y);
              run = convertToMeters(run, unit);
              
              pitch = Math.round((xValue * 100) / 12 * 100) / 100;
              rise = Math.round((run * pitch) / 100 * 100) / 100;
              P = `${Math.round(rise * 3.281)}/${Math.round(run * 3.281 * 2)}`;
              rafter = Math.round(Math.sqrt(rise * rise + run * run) * 100) / 100;
              angle = Math.round(Math.atan(pitch / 100) * (180 / Math.PI) * 100) / 100;
          }
          
          // Case 10: Rafter and Pitch provided
          else if (from === '10') {
              rafter = parseFloat(x);
              pitch = parseFloat(y);
              rafter = convertToMeters(rafter, unit);
              
              // Note: Original code had error - calculating rise from run which wasn't defined
              // Correcting: rafter^2 = rise^2 + run^2 and pitch = rise/run
              // So: rise = rafter * sin(atan(pitch/100))
              const pitchAngle = Math.atan(pitch / 100);
              rise = Math.round(rafter * Math.sin(pitchAngle) * 100) / 100;
              run = Math.round(rafter * Math.cos(pitchAngle) * 100) / 100;
              
              P = `${Math.round(rise * 3.281)}/${Math.round(run * 3.281 * 2)}`;
              angle = Math.round(pitchAngle * (180 / Math.PI) * 100) / 100;
              xValue = Math.round((pitch / 100) * 12 * 100) / 100;
          }
          
          // Return calculated values
          return {
              tech_pitch: pitch,
              tech_rise: Math.round(rise * 100) / 100,
              tech_run: Math.round(run * 100) / 100,
              tech_rafter: rafter,
              tech_angle: angle,
              tech_x: xValue,
              tech_P: P,
          };
          
      } catch (error) {
          console.error('Calculation Error:', error);
          return {
              error: 'An error occurred during calculation',
          };
      }
  }



  async  getCalculationCubicFeetCalculator(body) {
    try {
     let length = body.tech_length;
      let width = body.tech_width;
      let height = body.tech_height;

      let length_unit = body.tech_length_unit;
      let width_unit = body.tech_width_unit;
      let height_unit = body.tech_height_unit;

      let weight = body.tech_weight;
      let weight_unit = body.tech_weight_unit;

      let quantity = body.tech_quantity;
      let price = body.tech_price;
      let price_unit = body.tech_price_unit;

      let room_unit = body.tech_room_unit;

      let area = body.tech_area;
      let area_unit = body.tech_area_unit;


      const param = {};

      // ========== ROOM UNIT 1 ========== //
      if (room_unit === "1") {
        if (isNumeric(length) && isNumeric(width) && isNumeric(height)) {
          // Helper conversion functions
          function calculate(a, b) {
            switch (b) {
              case "ft": return a * 1;
              case "in": return a * 0.0833333;
              case "yd": return a * 3;
              case "cm": return a * 0.0328084;
              case "m": return a * 3.28084;
              case "mm": return a * 0.003281;
              case "km": return a * 3281;
              case "mi": return a * 5280;
              case "nmi": return a * 6076;
              default: return a;
            }
          }

          function calculate2(a, b) {
            return calculate(a, b);
          }

          function converting(a, b) {
            switch (b) {
              case "cm": return a * 1;
              case "ft": return a * 30.48;
              case "m": return a * 100;
              case "in": return a * 2.54;
              case "yd": return a * 91.44;
              case "km": return a * 100000;
              case "mm": return a * 0.1;
              case "mi": return a * 160934;
              case "nmi": return a * 185200;
              default: return a;
            }
          }

          const l = calculate(length, length_unit);
          const w = calculate(width, width_unit);
          const h = calculate(height, height_unit);
          let volume = l * w * h;

          const calculate_meter_cube = volume / 35.3147;
          const calculate_cubic_yards = volume * 0.03704;
          const calculate_cubic_inches = volume / 0.0005787;
          const calculate_cubic_centimeters = volume * 28317;

          const v1 = converting(length, length_unit);
          const v2 = converting(width, width_unit);
          const v3 = converting(height, height_unit);
          const volumetric_weight = (v1 * v2 * v3) / 5000;
          const volumetric_weight2 = volumetric_weight * 2.205;

          const v4 = calculate2(length, length_unit);
          const v5 = calculate2(width, width_unit);
          const v6 = calculate2(height, height_unit);

          const twenty_ft = 1165 / (v4 * v5 * v6);
          const fourty_ft = 2350 / (v4 * v5 * v6);
          const fourty_high_cube = 2694 / (v4 * v5 * v6);

          // Quantity
          if (quantity && quantity != 0) {
            volume = volume * quantity;
          }

          // Weight
          if (weight && weight != 0) {
            if (weight_unit == "lbs") {
              param.tech_weight_unit = weight_unit;
              const weight_convert = weight * 0.454;
              param.tech_weight = weight;
              param.tech_weight_convert = weight_convert;
            } else if (weight_unit == "kg") {
              param.tech_weight_unit = weight_unit;
              const weight_convert = weight * 2.205;
              param.tech_weight = weight;
              param.tech_weight_convert = weight_convert;
            }
          }

          // Price
          if (price && price != 0 && weight != "") {
            switch (price_unit) {
              case "ft³": price = price * 1; break;
              case "yd³": price = price * 0.04; break;
              case "m³": price = price * 0.03; break;
              case "cm³": price = price * 28316.85; break;
              case "in³": price = price * 1.728; break;
            }
            volume = volume * price;
            param.tech_estimated_price = price;
          }

          param.tech_volume = volume;
          param.tech_cubic_meter = calculate_meter_cube;
          param.tech_cubic_yards = calculate_cubic_yards;
          param.tech_cubic_inches = calculate_cubic_inches;
          param.tech_cubic_centimeters = calculate_cubic_centimeters;
          param.tech_weight = weight;
          param.tech_volumetric_weight = volumetric_weight;
          param.tech_volumetric_weight2 = volumetric_weight2;
          param.tech_twenty_ft = twenty_ft;
          param.tech_fourty_ft = fourty_ft;
          param.tech_fourty_high_cube = fourty_high_cube;
          param.tech_l = l;
          param.tech_w = w;
          param.tech_h = h;
          return param;
        } else {
          return { error: "Please! Check Your Input" };
        }
      }

      // ========== ROOM UNIT 2 ========== //
      else if (room_unit === "2") {
        if (isNumeric(area) && isNumeric(height)) {
          let convert13;
          switch (area_unit) {
            case "ft": convert13 = area * 1; break;
            case "in": convert13 = area * 0.00694444; break;
            case "yd": convert13 = area * 9; break;
            case "cm": convert13 = area * 0.00107639; break;
            case "m": convert13 = area * 10.7639; break;
            default: convert13 = area;
          }

          function calculate_three(a, b) {
            switch (b) {
              case "ft": return a * 1;
              case "in": return a * 0.0833333;
              case "yd": return a * 3;
              case "cm": return a * 0.0328084;
              case "m": return a * 3.28084;
              case "mm": return a * 0.003281;
              case "km": return a * 3281;
              case "mi": return a * 5280;
              case "nmi": return a * 6076.12;
              default: return a;
            }
          }

          const h1 = calculate_three(height, height_unit);
          let volume = convert13 * h1;
          let estimated_price = 0;

          if (price && price != 0) {
            switch (price_unit) {
              case "ft³": price = price * 1; break;
              case "yd³": price = price * 0.04; break;
              case "m³": price = price * 0.03; break;
              case "cm³": price = price * 28316.85; break;
              case "in³": price = price * 1728; break;
            }
            estimated_price = volume * price;
          }

          if (quantity && quantity != 0) {
            volume = volume * quantity;
          }

          param.tech_volume = volume;
          const calculate_meter_cube = volume / 35.3147;
          const calculate_cubic_yards = volume * 27;
          const calculate_cubic_inches = volume / 0.0005787;
          const calculate_cubic_centimeters = volume * 28317;

          param.tech_cubic_meter = calculate_meter_cube;
          param.tech_cubic_yards = calculate_cubic_yards;
          param.tech_cubic_inches = calculate_cubic_inches;
          param.tech_cubic_centimeters = calculate_cubic_centimeters;
          param.tech_estimated_price = estimated_price;
          param.tech_h1 = h1;
          param.tech_convert13 = convert13;

          return param;
        } else {
          return { error: "Please! Check Your Input" };
        }
      }

      // Default case
      return { error: "Invalid room_unit" };

    } catch (error) {
      console.error(error);
      return { error: "Server error occurred" };
    }
    // Helper: check numeric
    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }
  }



    async getCalculationFeetAndInchesCalculator(body) {
    // Extract inputs (Laravel-style converted to JS)
    let feet1 = body.tech_feet1;
    let inches1 = body.tech_inches1;
    let operations = body.tech_operations;
    let feet2 = body.tech_feet2;
    let inches2 = body.tech_inches2;

    const ft_unit = "ft";
    const in_unit = "in";
    const baran = 12;

    let result = {};

    // Helper: convert "2 1/2" or "3/4" etc to decimal
    function calculation(inches) {
      let intPart = 0;
      let fracPart = 0;
      const parts = inches.toString().trim().split(" ");
      if (parts.length >= 1) {
        intPart = parseFloat(parts[0]);
      }
      if (parts.length >= 2) {
        const [top, bottom] = parts[1].split("/");
        fracPart = parseFloat(top) / parseFloat(bottom);
      }
      return intPart + fracPart;
    }

    // Helper: convert "1/2" to decimal
    function convertToDecimal(inches) {
      const [num, den] = inches.split("/");
      return Math.round((parseFloat(num) / parseFloat(den)) * 1e6) / 1e6;
    }

    // Helper: convert float back to fraction string
    function float2rat(n, tolerance = 1e-6) {
      let h1 = 1, h2 = 0, k1 = 0, k2 = 1;
      let b = 1 / n;
      do {
        b = 1 / b;
        let a = Math.floor(b);
        let aux = h1; h1 = a * h1 + h2; h2 = aux;
        aux = k1; k1 = a * k1 + k2; k2 = aux;
        b = b - a;
      } while (Math.abs(n - h1 / k1) > n * tolerance);

      if (k1 >= 2) {
        const div = h1 / k1;
        const intPart = Math.floor(div);
        const mod = h1 % k1;
        if (intPart >= 1) {
          return `${intPart} ${mod}/${k1}`;
        } else {
          return `${h1}/${k1}`;
        }
      } else if (k1 <= 1) {
        return `${h1}`;
      }
    }

    // --- Validation check ---
    if (
      !isNaN(feet1) &&
      !isNaN(feet2) &&
      inches1 !== "" &&
      inches2 !== ""
    ) {
      // Convert fractional or mixed inputs
      const fractionPattern = /^(?:\d+\/\d+)$/;
      const mixedPattern = /^(\d+(?: \d+\/\d+)?)$/;

      if (fractionPattern.test(inches1) && fractionPattern.test(inches2)) {
        inches1 = convertToDecimal(inches1);
        inches2 = convertToDecimal(inches2);
      } else if (mixedPattern.test(inches1) && mixedPattern.test(inches2)) {
        inches1 = calculation(inches1);
        inches2 = calculation(inches2);
      } else if (mixedPattern.test(inches1) && fractionPattern.test(inches2)) {
        inches1 = calculation(inches1);
        inches2 = convertToDecimal(inches2);
      } else if (fractionPattern.test(inches1) && mixedPattern.test(inches2)) {
        inches1 = convertToDecimal(inches1);
        inches2 = calculation(inches2);
      }

      let ft, in_, ft2, in2, ft_div;

      // --- Operation 1: Addition ---
      if (operations === "1") {
        in_ = parseFloat(inches1) + parseFloat(inches2);
        ft = parseFloat(feet1) + parseFloat(feet2);
        in_ = in_ / baran;
        if (!in_.toString().includes(".")) {
          ft = ft + in_;
        } else {
          const [f, i] = in_.toString().split(".");
          const b = parseFloat("0." + i);
          ft = ft + parseFloat(f);
          in_ = b * baran;
          in_ = float2rat(in_);
        }
      }

      // --- Operation 2: Subtraction ---
      else if (operations === "2") {
        if (feet1 >= feet2 && inches1 >= inches2) {
          in_ = inches1 - inches2;
          ft = feet1 - feet2;
          in_ = in_ / baran;
          if (!in_.toString().includes(".")) {
            ft = ft + in_;
          } else {
            const [f, i] = in_.toString().split(".");
            const b = parseFloat("0." + i);
            ft = ft + parseFloat(f);
            in_ = b * baran;
            in_ = float2rat(in_);
          }
        } else if (feet1 <= feet2 && inches1 <= inches2) {
          in_ = inches1 - inches2;
          ft = feet1 - feet2;
          in_ = in_ / baran;
          if (!in_.toString().includes(".")) {
            ft = ft + in_;
          } else {
            const [f, i] = in_.toString().split(".");
            const b = parseFloat("0." + i);
            ft = ft + parseFloat(f);
            in_ = b * baran;
            in_ = float2rat(in_);
          }
        } else if (feet1 >= feet2 && inches1 <= inches2) {
          while (inches1 < inches2) {
            inches2 -= baran;
            feet2 += 1;
          }
          in_ = inches1 - inches2;
          ft = feet1 - feet2;
          in_ = in_ / baran;
          if (!in_.toString().includes(".")) {
            ft = ft + in_;
          } else {
            const [f, i] = in_.toString().split(".");
            const b = parseFloat("0." + i);
            ft = ft + parseFloat(f);
            in_ = b * baran;
            in_ = float2rat(in_);
          }
        } else if (feet1 <= feet2 && inches1 >= inches2) {
          while (inches1 > inches2) {
            inches1 -= baran;
            feet1 += 1;
          }
          while (inches1 < inches2) {
            inches2 -= baran;
            feet2 += 1;
          }
          in_ = inches1 - inches2;
          ft = feet1 - feet2;
          in_ = in_ / baran;
          if (!in_.toString().includes(".")) {
            ft = ft + in_;
          } else {
            const [f, i] = in_.toString().split(".");
            const b = parseFloat("0." + i);
            ft = ft + parseFloat(f);
            in_ = b * baran;
            in_ = float2rat(in_);
          }
        }
      }

      // --- Operation 3: Multiplication ---
      else if (operations === "3") {
        const ft1 = feet1 * baran;
        const ft2_ = feet2 * baran;
        const fot1 = ft1 + inches1;
        const fot2 = ft2_ + inches2;
        ft2 = fot1 * fot2;
        const in1 = inches1 / baran;
        const in2_ = inches2 / baran;
        const inc1 = in1 + Number(feet1);
        const inc2 = in2_ + Number(feet2);
        const c = inc1 * inc2;
        in2 = Number(c).toFixed(4);
      }

      // --- Operation 4: Division ---
      else if (operations === "4") {
        const ft1 = feet1 * baran;
        const ft21 = feet2 * baran;
        const fot1 = ft1 + inches1;
        const fot2 = ft21 + inches2;
        const a = fot1 / fot2;
        ft_div = Number(a).toFixed(4);
      }

      // Prepare result
      result.tech_ft_unit = ft_unit;
      result.tech_in_unit = in_unit;
      if (ft !== undefined) result.tech_ft = ft;
      if (in_ !== undefined) result.tech_in = in_;
      if (ft2 !== undefined) result.tech_ft2 = ft2;
      if (in2 !== undefined) result.tech_in2 = in2;
      if (ft_div !== undefined) result.tech_ft_div = ft_div;
    } else {
      result.error = "Please! Check Your Inputs";
    }

    return result;
  }


  async getCalculationAcreageCalculator(body) {
    try {
      let to_cal = Number(body.tech_to_cal);
      let length = Number(body.tech_length);
      let length_unit = body.tech_length_unit;
      let width = Number(body.tech_width);
      let width_unit = body.tech_width_unit;
      let area = Number(body.tech_area);
      let area_unit = body.tech_area_unit;
      let price = Number(body.tech_price);
      let price_unit = body.tech_price_unit;
      let currancy = body.tech_currancy;

      let result = {};

      // Calculate Area (when length and width are given)
      if (to_cal === 1) {
        if (!isNaN(length) && !isNaN(width)) {
          // Convert width to meters
          if (width_unit === 'cm') {
            width = width * 0.01;
          } else if (width_unit === 'in') {
            width = width * 0.0254;
          } else if (width_unit === 'ft') {
            width = width * 0.3048;
          } else if (width_unit === 'yd') {
            width = width * 0.9144;
          } else if (width_unit === 'mm') {
            width = width * 0.001;
          }

          area = Number(width) * Number(length);
          let perimeter = Number((Number(width) * 2) + (Number(length) * 2));
          console.log(area,width,length);
          // Calculate price if provided
          if (!isNaN(price) && price > 0) {
            let ans = 0;
            if (price_unit === '/mm²') {
              ans = area * 1000000;
            } else if (price_unit === '/cm²') {
              ans = area * 10000;
            } else if (price_unit === '/m²') {
              ans = area * 1;
            } else if (price_unit === '/in²') {
              ans = area * 1550.003;
            } else if (price_unit === '/ft²') {
              ans = area * 10.7639;
            } else if (price_unit === '/yd²') {
              ans = area * 1.19599;
            } else if (price_unit === '/ac') {
              ans = area * 0.0002471054;
            } else if (price_unit === '/ha') {
              ans = area * 0.0001;
            }
            let final_price = Number(ans) * Number(price);
            result.tech_final_price = final_price;
          }

          result.tech_area = area;
          result.tech_perimeter = perimeter;
          return result;
        } else {
          result.error = 'Please! Check Your Inputs';
          return result;
        }
      }
      
      // Calculate Length (when width and area are given)
      else if (to_cal === 2) {
        if (!isNaN(width) && !isNaN(area)) {
          // Convert width to meters
          if (width_unit === 'cm') {
            width = width * 0.01;
          } else if (width_unit === 'in') {
            width = width * 0.0254;
          } else if (width_unit === 'ft') {
            width = width * 0.3048;
          } else if (width_unit === 'yd') {
            width = width * 0.9144;
          } else if (width_unit === 'mm') {
            width = width * 0.001;
          }

          // Convert area to square meters
          if (area_unit === 'mm²') {
            area = area * 0.000001;
          } else if (area_unit === 'cm²') {
            area = area * 0.0001;
          } else if (area_unit === 'm²') {
            area = area * 1;
          } else if (area_unit === 'in²') {
            area = area * 0.00064516;
          } else if (area_unit === 'ft²') {
            area = area * 0.092903;
          } else if (area_unit === 'yd²') {
            area = area * 0.836127;
          } else if (area_unit === 'ac') {
            area = area * 4046.86;
          } else if (area_unit === 'ha') {
            area = area * 10000;
          }

          length = Number(area) / Number(width);
          let perimeter = Number((Number(width) * 2) + (Number(length) * 2));

          // Calculate price if provided
          if (!isNaN(price) && price > 0) {
            let ans = 0;
            if (price_unit === '/mm²') {
              ans = area * 1000000;
            } else if (price_unit === '/cm²') {
              ans = area * 10000;
            } else if (price_unit === '/m²') {
              ans = area * 1;
            } else if (price_unit === '/in²') {
              ans = area * 1550.003;
            } else if (price_unit === '/ft²') {
              ans = area * 10.7639;
            } else if (price_unit === '/yd²') {
              ans = area * 1.19599;
            } else if (price_unit === '/ac') {
              ans = area * 0.0002471054;
            } else if (price_unit === '/ha') {
              ans = area * 0.0001;
            }
            let final_price = Number(ans) * Number(price);
            result.tech_final_price = final_price;
          }

          result.tech_length = length;
          result.tech_perimeter = perimeter;
          return result;
        } else {
          result.error = 'Please! Check Your Inputs';
          return result;
        }
      }
      
      // Calculate Width (when length and area are given)
      else if (to_cal === 3) {
        if (!isNaN(length) && !isNaN(area)) {
          // Convert length to meters
          if (length_unit === 'cm') {
            length = length * 0.01;
          } else if (length_unit === 'in') {
            length = length * 0.0254;
          } else if (length_unit === 'ft') {
            length = length * 0.3048;
          } else if (length_unit === 'yd') {
            length = length * 0.9144;
          } else if (length_unit === 'mm') {
            length = length * 0.001;
          }

          // Convert area to square meters
          if (area_unit === 'mm²') {
            area = area * 0.000001;
          } else if (area_unit === 'cm²') {
            area = area * 0.0001;
          } else if (area_unit === 'm²') {
            area = area * 1;
          } else if (area_unit === 'in²') {
            area = area * 0.00064516;
          } else if (area_unit === 'ft²') {
            area = area * 0.092903;
          } else if (area_unit === 'yd²') {
            area = area * 0.836127;
          } else if (area_unit === 'ac') {
            area = area * 4046.86;
          } else if (area_unit === 'ha') {
            area = area * 10000;
          }

          width = Number(area) / Number(length);
          let perimeter = Number((Number(width) * 2) + (Number(length) * 2));

          // Calculate price if provided
          if (!isNaN(price) && price > 0) {
            let ans = 0;
            if (price_unit === '/mm²') {
              ans = area * 1000000;
            } else if (price_unit === '/cm²') {
              ans = area * 10000;
            } else if (price_unit === '/m²') {
              ans = area * 1;
            } else if (price_unit === '/in²') {
              ans = area * 1550.003;
            } else if (price_unit === '/ft²') {
              ans = area * 10.7639;
            } else if (price_unit === '/yd²') {
              ans = area * 1.19599;
            } else if (price_unit === '/ac') {
              ans = area * 0.0002471054;
            } else if (price_unit === '/ha') {
              ans = area * 0.0001;
            }
            let final_price = Number(ans) * Number(price);
            result.tech_final_price = final_price;
          }

          result.tech_width = width;
          result.tech_perimeter = perimeter;
          return result;
        } else {
          result.error = 'Please! Check Your Inputs';
          return result;
        }
      }

    } catch (error) {
      console.error('Error in getCalculationAcreageCalculator:', error);
      return { error: 'An error occurred during calculation' };
    }
  }



    async getCalculationRebarCalculator(body) {
    try {
      // Extract all input values from body
      let {
        tech_first,
        tech_units1,
        tech_second,
        tech_units2,
        tech_third,
        tech_units3,
        tech_four,
        tech_units4,
        tech_five,
        tech_units5,
        tech_six,
        tech_units6,
        tech_currancy
      } = body;

      let param = {};
      let convert,convert2,convert3;
      // 🧩 Remove currency prefix if present
      if (tech_units5 && tech_currancy) {
        tech_units5 = tech_units5.replace(tech_currancy + " ", "");
      }

      // ✅ Helper Functions (Converted from PHP)

      function cm_unit(a,b){
        if(a == "cm"){
          convert = b * 1;
        }else if (a == "m") {
          convert = b * 100;
        }else if (a == "km") {
          convert = b * 100000;
        }else if (a == "in") {
          convert = b *  2.54;
        }else if (a == "ft") {
          convert = b * 30.48;
        }else if (a == "yd") {
          convert = b * 91.44;
        }else if (a == "mi") {
          convert = b * 30.48;
        }
        return convert;
      }
      function cm_unit2(a,b){
        if(a == "mm"){
          convert2 = b / 10;
        }else if (a == "cm") {
          convert2 = b * 1;
        }else if (a == "m") {
          convert2 = b * 100;
        }else if (a == "in") {
          convert2 = b *  2.54;
        }else if (a == "ft") {
          convert2 = b * 30.48;
        }else if (a == "yd") {
          convert2 = b * 91.44;
        }
        return convert2;
      }
      function cm_unit3(a,b){
        if(a == "cm"){
          convert3 = b * 1;
        }else if (a == "m") {
          convert3 = b * 100;
        }else if (a == "in") {
          convert3 = b * 2.54;
        }else if (a == "ft") {
          convert3 = b *  30.48;
        }else if (a == "yd") {
          convert3 = b * 91.44;
        }
        return convert3;
      }

      

      // ✅ Validate numeric inputs
      if (
        !isNaN(tech_first) &&
        !isNaN(tech_second) &&
        !isNaN(tech_third) &&
        !isNaN(tech_four) &&
        !isNaN(tech_five) &&
        !isNaN(tech_six)
      ) {
        // Convert all to cm
        let first = cm_unit(tech_units1, Number(tech_first));
        let second = cm_unit(tech_units2, Number(tech_second));
        let third = cm_unit2(tech_units3, Number(tech_third));
        let four = cm_unit2(tech_units4, Number(tech_four));
        let five = cm_unit3(tech_units5, Number(tech_five));
        let six = cm_unit3(tech_units6, Number(tech_six));

        // Main calculations
        const mul1 = 2 * four;
        const grid_len = first - mul1;
        const grid_wid = second - mul1;

        const rebar_col = grid_len / third;
        const rebar_row = grid_wid / third;
        const part1 = rebar_col * grid_wid;
        const part2 = rebar_row * grid_len;
        const trl = part1 + part2;

        const price_s = five * six;
        const rebar_pie = trl / six;
        const cost = Math.round(rebar_pie) * price_s;

        // ✅ Return structured result
        param.tech_grid_len = grid_len;
        param.tech_grid_wid = grid_wid;
        param.tech_trl = trl;
        param.tech_rebar_pie = rebar_pie;
        param.tech_cost = cost;
        param.tech_price_s = price_s;
        return param;
      } else {
        return { error: "Please check your input" };
      }
    } catch (err) {
      return { error: err.message || "Something went wrong!" };
    }
  }


  async getCalculationPipeVolumeCalculator(body) {
    try {
      // Extract input values
      let {
        tech_inner_diameter,
        tech_inner_diameter_unit,
        tech_length,
        tech_length_unit,
        tech_density,
        tech_density_unit
      } = body;

      let param = {};
      let val1,val2;
      function convert_inches2(unit, value)
      {
        if (unit == "cm") {
          val1 = value * 0.393701;
        } else if (unit == "m") {
          val1 = value * 39.3701;
        } else if (unit == "in") {
          val1 = value * 1;
        } else if (unit == "ft") {
          val1 = value * 12;
        } else if (unit == "yd") {
          val1 = value * 36;
        } else if (unit == "mm") {
          val1 = value * 0.0393701;
        }
        return val1;
      }
      function convert_unit2(unit2, value2)
      {
        if (unit2 == "kg/m³") {
          val2 = value2 * 0.000036127;
        } else if (unit2 == "kg/dm³") {
          val2 = value2 * 0.036127;
        } else if (unit2 == "kg/L") {
          val2 = value2 * 0.036127292;
        } else if (unit2 == "g/mL") {
          val2 = value2 * 0.036127292;
        } else if (unit2 == "g/cm³") {
          val2 = value2 * 0.036127292;
        } else if (unit2 == "oz/cu in") {
          val2 = value2 * 0.0625;
        } else if (unit2 == "lb/cu in") {
          val2 = value2 * 1;
        } else if (unit2 == "lb/cu ft") {
          val2 = value2 * 0.000578703704;
        } else if (unit2 == "lb/US gal") {
          val2 = value2 * 0.00432900433;
        } else if (unit2 == "g/L") {
          val2 = value2 * 0.00003612729;
        } else if (unit2 == "g/dL") {
          val2 = value2 * 0.00036127292;
        } else if (unit2 == "mg/L") {
          val2 = value2 * 3.6127292e-8;
        }
        return val2;
      }

      // ✅ Validation
      if (
        !isNaN(tech_inner_diameter) &&
        !isNaN(tech_length) &&
        !isNaN(tech_density)
      ) {
        if (tech_inner_diameter > 0 && tech_length > 0) {
          // Convert to inches
          const inv = convert_inches2(tech_inner_diameter_unit, Number(tech_inner_diameter));
          const lnv = convert_inches2(tech_length_unit, Number(tech_length));

          // Compute volume and weight
          const k = inv / 2;
          const volume = 3.14159265 * k * k * lnv; // cubic inches
          const wv = convert_unit2(tech_density_unit, Number(tech_density));
          const weight = volume * wv;

          // ✅ Return structured response
          param.tech_volume = volume;
          param.tech_weight = weight;
          return param;
        } else {
          return { error: "Please! Enter Positive Value" };
        }
      } else {
        return { error: "Please! Check Your Input" };
      }

    } catch (err) {
      return { error: err.message || "Something went wrong!" };
    }
  }


    async getCalculationMsPlateWeightCalculator(body) {
    try {
            // Shape properties
        let st_type = body.tech_st_type;
        let st_shape = body.tech_st_shape;
        let quantity = body.tech_quantity;

        // Dimension properties
        let length = body.tech_length;
        let length_unit = body.tech_length_unit;
        let width = body.tech_width;
        let width_unit = body.tech_width_unit;
        let thickness = body.tech_thickness;
        let thickness_unit = body.tech_thickness_unit;
        let side = body.tech_side;
        let side_unit = body.tech_side_unit;
        let diameter = body.tech_diameter;
        let diameter_unit = body.tech_diameter_unit;

        // Area properties
        let area = body.tech_area;
        let area_unit = body.tech_area_unit;

      let param = {};
      let val3,ans;
      // ✅ Helper functions
    function centi(unit3, value3)
      {
        if (unit3 == "mm²") {
          val3 = value3 * 0.01;
        } else if (unit3 == "cm²") {
          val3 = value3 * 1;
        } else if (unit3 == "m²") {
          val3 = value3 * 10000;
        } else if (unit3 == "km²") {
          val3 = value3 * 10000000000;
        } else if (unit3 == "in²") {
          val3 = value3 * 6.452;
        } else if (unit3 == "ft²") {
          val3 = value3 * 929;
        } else if (unit3 == "yd²") {
          val3 = value3 * 8361;
        } else if (unit3 == "mi²") {
          val3 = value3 * 25899881103;
        }
        return val3;
      }
      function convert_to_cmeter(value, unit)
      {
        if (unit == "cm") {
          ans = value * 1;
        } else if (unit == "mm") {
          ans = value * 0.1;
        } else if (unit == "in") {
          ans = value * 2.54;
        } else if (unit == "ft") {
          ans = value * 30.58;
        } else if (unit == "yd") {
          ans = value * 91.44;
        } else if (unit == "m") {
          ans = value * 100;
        }
        return ans;
      }

      // ✅ Convert numeric safely
      const n = (v) => (isNaN(Number(v)) ? null : Number(v));

      // Assign numeric values
      const _st_type = n(st_type);
      const _st_shape = String(st_shape);
      const _length = n(length);
      const _width = n(width);
      const _thickness = n(thickness);
      const _side = n(side);
      const _diameter = n(diameter);
      const _area = n(area);
      const _quantity = n(quantity);

      let areaResult = 0,
        volume = 0,
        weight = 0;

      // ✅ Shape conditions
      if (_st_shape == "1") {
        if (
          _length > 0 &&
          _width > 0 &&
          _thickness > 0 &&
          _quantity > 0
        ) {
          const lv = convert_to_cmeter(_length, length_unit);
          const wv = convert_to_cmeter(_width, width_unit);
          const thv = convert_to_cmeter(_thickness, thickness_unit);
          areaResult = lv * wv;
          volume = thv * areaResult;
          weight = _quantity * _st_type * volume;
        } else {
          return { error: "Please! Enter Positive Value" };
        }
      } else if (_st_shape == "2") {
        if (_thickness > 0 && _side > 0 && _quantity > 0) {
          const areaValue = convert_to_cmeter(_side, side_unit) ** 2;
          const thv = convert_to_cmeter(_thickness, thickness_unit);
          volume = thv * areaValue;
          weight = _quantity * _st_type * volume;
          areaResult = areaValue;
        } else {
          return { error: "Please! Enter Positive Value" };
        }
      } else if (_st_shape == "3") {
        if (_thickness > 0 && _diameter > 0 && _quantity > 0) {
          const dv = convert_to_cmeter(_diameter, diameter_unit);
          const div = (dv / 2) ** 2;
          areaResult = div * 3.141592653;
          const thv = convert_to_cmeter(_thickness, thickness_unit);
          volume = thv * areaResult;
          weight = _quantity * _st_type * volume;
        } else {
          return { error: "Please! Enter Positive Value" };
        }
      } else if (_st_shape == "4") {
        if (_area > 0 && _thickness > 0 && _quantity > 0) {
          const areaValue = centi(area_unit, _area);
          const thv = convert_to_cmeter(_thickness, thickness_unit);
          volume = thv * areaValue;
          weight = _quantity * _st_type * volume;
          areaResult = areaValue;
        } else {
          return { error: "Please! Enter Positive Value" };
        }
      } else {
        return { error: "Invalid st_shape option" };
      }

      param.tech_area = areaResult;
      param.tech_volume = volume;
      param.tech_weight = weight;

      return { status: "success", payload: param };
    } catch (err) {
      return { status: "error", payload: { error: err.message } };
    }
  }

  async getCalculationPricePerSquareFootCalculator(body) {
    let calculate = body.tech_calculate;
    let pp = Number(body.tech_pp);
    let area_measure = Number(body.tech_area_measure);
    let area_measure_unit = body.tech_area_measure_unit;
    let pp1 = Number(body.tech_pp1);
    let area_measure1 = Number(body.tech_area_measure1);
    let area_measure_unit1 = body.tech_area_measure_unit1;
    let pp2 = Number(body.tech_pp2);
    let area_measure2 = Number(body.tech_area_measure2);
    let area_measure_unit2 = body.tech_area_measure_unit2;
    let compare = body.tech_compare;
    let compare2 = body.tech_compare2;
    let pp_unit = body.tech_pp_unit;
    let pp1_unit = body.tech_pp1_unit;
    let pp2_unit = body.tech_pp2_unit;

    // helper function for area conversion
    function unitconver(val1, val2) {
      if (val2 === "ft²") return val1 * 1;
      else if (val2 === "m²") return val1 * 10.764;
      else if (val2 === "in²") return val1 * 0.006944;
      else return val1 * 9; // default case
    }

    let param = {};

    try {
      let res, res1, res2;

      // Base calculation
      if (["1", "2", "3"].includes(calculate)) {
        if (!isNaN(pp) && !isNaN(area_measure)) {
          if (area_measure > 0) {
            let am = unitconver(area_measure, area_measure_unit);
            if (calculate === "1" || calculate === "2") res = pp / am;
            else if (calculate === "3") res = pp * am;

            param.tech_pp_unit = pp_unit;
          } else {
            param.error = "Square Footage must be greater than zero";
            return param;
          }
        } else {
          param.error = "Please! Check Input";
          return param;
        }
      }

      // Comparison 1
      if (compare === "2") {
        if (["1", "2", "3"].includes(calculate)) {
          if (!isNaN(pp1) && !isNaN(area_measure1)) {
            if (area_measure1 > 0) {
              let am1 = unitconver(area_measure1, area_measure_unit1);
              if (calculate === "1" || calculate === "2") res1 = pp1 / am1;
              else if (calculate === "3") res1 = pp1 * am1;

              param.tech_pp1_unit = pp1_unit;
              param.tech_res1 = res1;
              param.tech_compare = compare;
            } else {
              param.error = "Square Footage must be greater than zero";
              return param;
            }
          } else {
            param.error = "Please! Check Input";
            return param;
          }
        }
      }

      // Comparison 2
      if (compare2 === "2") {
        if (["1", "2", "3"].includes(calculate)) {
          if (!isNaN(pp2) && !isNaN(area_measure2)) {
            if (area_measure2 > 0) {
              let am2 = unitconver(area_measure2, area_measure_unit2);
              if (calculate === "1" || calculate === "2") res2 = pp2 / am2;
              else if (calculate === "3") res2 = pp2 * am2;

              param.tech_pp2_unit = pp2_unit;
              param.tech_res2 = res2;
              param.tech_compare2 = compare2;
            } else {
              param.error = "Square Footage must be greater than zero";
              return param;
            }
          } else {
            param.error = "Please! Check Input";
            return param;
          }
        }
      }

      param.tech_res = res;
      param.tech_calculate = calculate;
      return param;

    } catch (err) {
      return { error: err.message || "Unexpected Error" };
    }
  }

    async getCalculationMaterialCalculator(body) {
      const operations = body.tech_operations;
      const ex_drop = body.tech_ex_drop;
      const first = body.tech_first;
      const units1 = body.tech_units1;
      const second = body.tech_second;
      const units2 = body.tech_units2;
      const third = body.tech_third;
      const units3 = body.tech_units3;
      const four = body.tech_four;
      const units4 = body.tech_units4;
      const five = body.tech_five;
      const units5 = body.tech_units5;
      const six = body.tech_six;
      const units6 = body.tech_units6;
      const seven = body.tech_seven;
      const units7 = body.tech_units7;
      const currancy = body.tech_currancy;

    const param = {};
    let convert1;
   function feet(unit, value){
			if (unit == "in") {
				return value; // Already in inches
			} else if (unit == "ft") {
				return value * 12; // Convert feet to inches
			} else if (unit == "cm") {
				return value * 0.39370; // Convert centimeters to inches
			} else if (unit == "m") {
				return value * 39.3701; // Convert meters to inches
			} else if (unit == "yd") {
				return value * 36; // Convert yards to inches
			} else {
				return "Invalid unit";
			}
		}
		function feet2(unit, value){
			if (unit == "in³") {
				return value; // Already in inches
			} else if (unit == "ft³") {
				return value * 12; // Convert feet to inches
			} else if (unit == "cm³") {
				return value * 0.39370; // Convert centimeters to inches
			} else if (unit == "m³") {
				return value * 39.3701; // Convert meters to inches
			} else if (unit == "yd³") {
				return value * 36; // Convert yards to inches
			} else {
				return "Invalid unit";
			}
		}
		function lb(a,b){
			if(a == "lb"){
				// dd(a,b);
				convert1 = b * 1;
			}else if (a == "t"){
				convert1 = b * 2000;
			}else if (a == "long t"){
				convert1 = b * 2240;
			}else if (a == "kg"){
				convert1 = b * 2.205;
			}
			return convert1;
		}

    // Clean currency symbols
    const cleanUnit6 = units6?.replace(currancy + " ", "");
    const cleanUnit7 = units7?.replace(currancy + " ", "");

    let area, volume, weight;

    // 🔹 Operation 1
    if (operations === "1") {
      if (!isNaN(first) && !isNaN(second) && !isNaN(third)) {
        const f1 = feet(units1, Number(first));
        const f2 = feet(units2, Number(second));
        const f3 = feet(units3, Number(third));

        area = f1 * f2;
        volume = area * f3;
        weight = ex_drop * (volume / 1728);

        param.tech_area = area;
        param.tech_volume = volume;
      } else {
        return { error: "Please! Check Your Input" };
      }
    }

    // 🔹 Operation 2
    else if (operations === "2") {
      if (!isNaN(third) && !isNaN(four)) {
        const f3 = feet(units3, Number(third));
        const f4 = feet(units4, Number(four));

        volume = f4 * f3;
        weight = ex_drop * (volume / 1728);

        param.tech_volume = volume;
      } else {
        return { error: "Please! Check Your Input" };
      }
    }

    // 🔹 Operation 3
    else if (operations === "3") {
      if (!isNaN(five)) {
        const f5 = feet2(units5, Number(five));
        volume = f5;
        weight = ex_drop * (volume / 1728);
       
      } else {
        return { error: "Please! Check Your Input" };
      }
    }

    // 🔹 Cost Mass Calculation
    if (!isNaN(six)) {
      const s6 = lb(cleanUnit6, Number(six));
       console.log(s6);
      param.tech_cost_mass = s6 * weight;
    }

    // 🔹 Cost Volume Calculation
    if (!isNaN(seven)) {
      const s7 = feet2(cleanUnit7, Number(seven));
      param.tech_cost_volume = volume * s7;
    }

    param.tech_weight = weight;

    return param;
  }

    async getCalculationRetainingWallCalculator(body) {
    let wall_length = body.tech_wall_length;
    let wall_length_unit = body.tech_wall_length_unit;
    let wall_height = body.tech_wall_height;
    let wall_height_unit = body.tech_wall_height_unit;
    let block_height = body.tech_block_height;
    let block_height_unit = body.tech_block_height_unit;
    let block_length = body.tech_block_length;
    let block_length_unit = body.tech_block_length_unit;
    let wall_block_price = body.tech_wall_block_price;
    let cap_height = body.tech_cap_height;
    let cap_height_unit = body.tech_cap_height_unit;
    let cap_length = body.tech_cap_length;
    let cap_length_unit = body.tech_cap_length_unit;
    let cap_block_price = body.tech_cap_block_price;
    let backfill_thickness = body.tech_backfill_thickness;
    let backfill_thickness_unit = body.tech_backfill_thickness_unit;
    let backfill_length = body.tech_backfill_length;
    let backfill_length_unit = body.tech_backfill_length_unit;
    let backfill_height = body.tech_backfill_height;
    let backfill_height_unit = body.tech_backfill_height_unit;
    let backfill_price = body.tech_backfill_price;
    let backfill_price_unit = body.tech_backfill_price_unit;
    let currancy = body.tech_currancy;

    const param = {};

    // Remove currency symbol
    const clean_backfill_price_unit = backfill_price_unit?.replace(currancy + " ", "");

    // 🔹 Convert to meter
    function convert_to_meter(unit, value) {
      let ans = 0;
      if (unit == "cm") ans = value / 100;
      else if (unit == "m") ans = value;
      else if (unit == "in") ans = value / 39.37;
      else if (unit == "ft") ans = value / 3.281;
      else if (unit == "yd") ans = value / 1.094;
      else if (unit == "dm") ans = value / 10;
      return ans;
    }

    // 🔹 Convert to price unit (same as Laravel)
    function convert_to_price_unit(unit, value) {
      let ans = 0;
      if (unit == "dag") ans = value * 100;
      else if (unit == "lb") ans = value * 2.205;
      else if (unit == "kg") ans = value;
      else if (unit == "t") ans = value / 1000;
      else if (unit == "oz") ans = value * 35.274;
      else if (unit == "stone") ans = value / 6.35;
      else if (unit == "Us ton") ans = value / 907.2;
      else if (unit == "Long ton") ans = value / 1016;
      // ⚠️ Laravel returns nothing if unit doesn't match — we replicate that:
      else ans = 0;
      return ans;
    }

    if (
      !isNaN(wall_height) &&
      !isNaN(block_height) &&
      !isNaN(cap_length) &&
      !isNaN(backfill_thickness) &&
      !isNaN(backfill_height) &&
      !isNaN(backfill_length) &&
      !isNaN(backfill_price) &&
      !isNaN(block_length) &&
      !isNaN(cap_block_price) &&
      !isNaN(wall_block_price) &&
      !isNaN(wall_length)
    ) {
      const wall_height_m = convert_to_meter(wall_height_unit, Number(wall_height));
      const block_height_m = convert_to_meter(block_height_unit, Number(block_height));
      const wall_length_m = convert_to_meter(wall_length_unit, Number(wall_length));
      const block_length_m = convert_to_meter(block_length_unit, Number(block_length));
      const cap_length_m = convert_to_meter(cap_length_unit, Number(cap_length));
      const backfill_thickness_m = convert_to_meter(backfill_thickness_unit, Number(backfill_thickness));
      const backfill_length_m = convert_to_meter(backfill_length_unit, Number(backfill_length));
      const backfill_height_m = convert_to_meter(backfill_height_unit, Number(backfill_height));

      const block_rows = Math.ceil(wall_height_m / block_height_m);
      const block_columns = Math.ceil(wall_length_m / block_length_m);
      const blocks = block_columns * (block_rows - 1);
      const blocks_price = blocks * wall_block_price;

      const caps = wall_length_m / cap_length_m;
      const caps_price = caps * cap_block_price;

      const backfill_volume = backfill_thickness_m * backfill_length_m * backfill_height_m;
      const backfill_weight = 1346 * backfill_volume;

      // ✅ Match Laravel: invalid unit should make price 0
      const backfill_weight_unit = convert_to_price_unit(clean_backfill_price_unit, backfill_weight);
      const backfill_total_price =
        backfill_weight_unit > 0 ? backfill_weight_unit * backfill_price : 0;

      const total_cost = backfill_total_price + blocks_price + caps_price;

      param.tech_blocks = Math.ceil(blocks);
      param.tech_blocks_price = Math.ceil(blocks_price);
      param.tech_caps = Math.ceil(caps);
      param.tech_caps_price = Math.ceil(caps_price);
      param.tech_backfill_volume = Number(backfill_volume.toFixed(3));
      param.tech_backfill_weight = Math.ceil(backfill_weight);
      param.tech_backfill_total_price = Math.ceil(backfill_total_price);
      param.tech_total_cost = Math.ceil(total_cost);

      return param;
    } else {
      return { error: "Please! Check Your Input" };
    }
  }

  async getCalculationSquareyardsCalculator(body) {
    let first = body.tech_first;
    let unit1 = body.tech_unit1;
    let second = body.tech_second;
    let unit2 = body.tech_unit2;
    let third = body.tech_third;
    let unit3 = body.tech_unit3;
    let currancy = body.tech_currancy;

    const param = {};

    // Remove currency symbol (like "$ " etc.)
    unit3 = unit3?.replace(currancy + " ", "");

    // --- Convert length to centimeters ---
    function con_cm(a, b) {
      if (a === "mm") {
        return b / 10;
      } else if (a === "cm") {
        return b * 1;
      } else if (a === "m") {
        return b * 100;
      } else if (a === "in") {
        return b * 2.54;
      } else if (a === "ft") {
        return b * 30.48;
      } else if (a === "yd") {
        return b * 91.44;
      }
      return b;
    }

    // --- Convert area to square centimeters ---
    function con_cm_sq(a, b) {
      if (a === "mm²") {
        return b / 10;
      } else if (a === "cm²") {
        return b * 1;
      } else if (a === "dm") {
        return b * 10;
      } else if (a === "m²") {
        return b * 100;
      } else if (a === "km²") {
        return b * 100000;
      } else if (a === "in²") {
        return b * 2.54;
      } else if (a === "ft²") {
        return b * 30.48;
      } else if (a === "yd²") {
        return b * 91.44;
      } else if (a === "a") {
        return b * 1000000;
      } else if (a === "da") {
        return b * 1000;
      } else if (a === "ha") {
        return b * 100000000;
      } else if (a === "ac") {
        return b * 40468564.224;
      }
      return b;
    }

    // --- Validate numeric inputs ---
    if (!isNaN(first) && !isNaN(second) && !isNaN(third)) {
      first = con_cm(unit1, Number(first));
      second = con_cm(unit2, Number(second));
      third = con_cm_sq(unit3, Number(third));

      const yd_ans = first * second;
      const price = yd_ans * third;

      param.tech_yd_ans = yd_ans;
      param.tech_price = price;

    return param;
  } else {
    return { error: "Please! Check Your Input" };
  }
}

    async getCalculationBrickCalculator(body) {
    const param = {};

    // Extract inputs
    let wall_type = body.tech_wall_type?.trim();
    let wall_length = Number(body.tech_wall_length);
    let wall_length_unit = body.tech_wall_length_unit?.trim();
    let wall_width = Number(body.tech_wall_width);
    let wall_width_unit = body.tech_wall_width_unit?.trim();
    let wall_height = Number(body.tech_wall_height);
    let wall_height_unit = body.tech_wall_height_unit?.trim();

    // Brick Fields
    let brick_type = body.tech_brick_type?.trim();
    let brick_wastage = Number(body.tech_brick_wastage);
    let mortar_joint_thickness = Number(body.tech_mortar_joint_thickness);
    let mortar_joint_thickness_unit = body.tech_mortar_joint_thickness_unit?.trim();
    let brick_length = Number(body.tech_brick_length);
    let brick_length_unit = body.tech_brick_length_unit?.trim();
    let brick_width = Number(body.tech_brick_width);
    let brick_width_unit = body.tech_brick_width_unit?.trim();
    let brick_height = Number(body.tech_brick_height);
    let brick_height_unit = body.tech_brick_height_unit?.trim();

    // Mortar Fields
    let with_motar = body.tech_with_motar?.trim();
    let wet_volume = Number(body.tech_wet_volume);
    let wet_volume_unit = body.tech_wet_volume_unit?.trim();
    let mortar_wastage = Number(body.tech_mortar_wastage);
    let mortar_ratio = body.tech_mortar_ratio?.trim();
    let bag_size = Number(body.tech_bag_size);
    let bag_size_unit = body.tech_bag_size_unit?.trim();

    // Cost Fields
    let price_per_brick = Number(body.tech_price_per_brick);
    let price_of_cement = Number(body.tech_price_of_cement);
    let price_sand_per_volume = Number(body.tech_price_sand_per_volume);
    let price_sand_volume_unit = body.tech_price_sand_volume_unit?.trim();
    let currancy = body.tech_currancy;

    // Remove currency symbol
    price_sand_volume_unit = price_sand_volume_unit?.replace(currancy + " ", "");
    let ans;
    // ---------------------- Conversion Functions ----------------------
      function convert_to_meter(unit, value){
            if (unit == 'cm') {
              ans = value / 100;
            }else if (unit == 'm') {
              ans = value;
            }else if (unit == 'in') {
              ans = value / 39.37;
            }else if (unit == 'ft') {
              ans = value /  3.281;
            }else if (unit == 'yd') {
              ans = value /  1.094;
            }else if (unit == 'dm') {
              ans = value / 10;
            }else if (unit == 'mm') {
              ans = value / 1000;
            }
            return ans;
          }
          function convert_to_millimeter(unit,value){
            if(unit == 'cm'){
              ans = value * 10;
            }else if(unit == 'm'){
              ans = value * 1000;
            }else if(unit == 'in'){
              ans = value * 25.4;
            }else if(unit == 'ft'){
              ans = value * 304.8;
            }else if (unit == 'yd') {
              ans = value * 914.4;
            }else if (unit == 'dm') {
              ans = value * 100;
            }else if (unit == 'mm') {
              ans = value;
            }
            return ans;
          }
          function convert_to_kilo(unit,value){
            if(unit == 'g'){
              ans = value / 1000;
            }else if(unit == 'lb'){
              ans = value / 2.205;
            }else if(unit == 't'){
              ans = value * 1000;
            }else if(unit == 'stone'){
              ans = value * 6.35029;
            }else if(unit == 'kg'){
              ans = value;
            }
            return ans;
          }
          function convert_to_meter_cube(unit,value){
            if(unit == 'cm³'){
              ans = value / 1000000;
            }else if(unit == 'cu_ft'){
              ans = value / 35.315;
            }else if(unit == 'cu_yd'){
              ans = value / 1.308;
            }else if(unit == 'm³'){
              ans = value;
            }
            return ans;
          }

    // ---------------------- Validation ----------------------
    if (
      !isNaN(wall_width) &&
      !isNaN(mortar_joint_thickness) &&
      !isNaN(brick_width)
    ) {
      if (
        wall_length >= 0 &&
        wall_width >= 0 &&
        wall_height >= 0 &&
        mortar_joint_thickness >= 0 &&
        brick_wastage >= 0 &&
        brick_length >= 0 &&
        brick_width >= 0 &&
        brick_height >= 0 &&
        price_per_brick >= 0
      ) {
        // Convert wall & brick dimensions
        wall_length = convert_to_meter(wall_length_unit, wall_length);
        wall_width = convert_to_meter(wall_width_unit, wall_width);
        wall_height = convert_to_meter(wall_height_unit, wall_height);
        mortar_joint_thickness = convert_to_meter(
          mortar_joint_thickness_unit,
          mortar_joint_thickness
        );

        // Wall area
        const wall_area = wall_length * wall_height;

        // Brick conversion
        if (brick_type === "1" || brick_type === 1) {
          brick_length = convert_to_meter(brick_length_unit, brick_length);
          brick_height = convert_to_meter(brick_height_unit, brick_height);
          brick_width = convert_to_meter(brick_width_unit, brick_width);
        } else {
          const brick_array = brick_type.split("x");
          brick_length = convert_to_meter("in", Number(brick_array[0]));
          brick_height = convert_to_meter("in", Number(brick_array[1]));
        }

        // Brick area
        const brick_sum =
          (brick_length + mortar_joint_thickness) *
          (brick_height + mortar_joint_thickness);
        let no_of_bricks = Math.ceil(wall_area / brick_sum);
        const wastage = Math.ceil((brick_wastage * no_of_bricks) / 100);
        let no_of_bricks_with_wastage = Math.round(no_of_bricks + wastage);

        if (wall_type === "double") {
          no_of_bricks *= 2;
          no_of_bricks_with_wastage *= 2;
        }

        // Cost of bricks
        const cost_of_bricks = price_per_brick * no_of_bricks_with_wastage;

        // Without mortar
        if (with_motar === "no") {
          param.tech_wall_area = wall_area;
          param.tech_no_of_bricks = no_of_bricks;
          param.tech_no_of_bricks_with_wastage = no_of_bricks_with_wastage;
          param.tech_cost_of_bricks = cost_of_bricks;
          return param;
        }

        // With mortar
        else if (with_motar === "yes") {
          if (
            !isNaN(wet_volume) &&
            !isNaN(mortar_wastage) &&
            !isNaN(bag_size) &&
            !isNaN(price_of_cement) &&
            !isNaN(price_sand_per_volume)
          ) {
            if (
              wet_volume >= 0 &&
              mortar_wastage >= 0 &&
              bag_size >= 0 &&
              price_of_cement >= 0 &&
              price_sand_per_volume >= 0
            ) {
              // Mortar calculations
              wet_volume = convert_to_meter_cube(wet_volume_unit, wet_volume);
              const dry_volume = wet_volume + (52 * wet_volume) / 100;
              const dry_volume_wastage = (mortar_wastage * dry_volume) / 100;
              const dry_volume_with_wastage =
                dry_volume + dry_volume_wastage;

              // Mortar ratio
              const ratio = mortar_ratio.split(":").map(Number);
              const cement_ratio = ratio[0];
              const sand_ratio = ratio[1];
              const total_ratio = cement_ratio + sand_ratio;

              const volume_of_cement = Number(
                ((dry_volume_with_wastage * cement_ratio) / total_ratio).toFixed(4)
              );
              const weight_of_cement = volume_of_cement * 1440;
              bag_size = convert_to_kilo(bag_size_unit, bag_size);
              const number_of_bags = Math.ceil(weight_of_cement / bag_size);

              const volume_of_sand = Number(
                ((dry_volume_with_wastage * sand_ratio) / total_ratio).toFixed(4)
              );

              const sand_vol_converted = convert_to_meter_cube(
                price_sand_volume_unit,
                price_sand_per_volume
              );
              const price_of_sand = sand_vol_converted * volume_of_sand;
              const price_for_cement = number_of_bags * price_of_cement;
              const mortar_cost = price_for_cement + price_of_sand;

              const total_cost = cost_of_bricks + mortar_cost;

              // Results
              param.tech_wall_area = wall_area;
              param.tech_no_of_bricks = no_of_bricks;
              param.tech_no_of_bricks_with_wastage = no_of_bricks_with_wastage;
              param.tech_cost_of_bricks = cost_of_bricks;
              param.tech_dry_volume = dry_volume;
              param.tech_dry_volume_with_wastage = dry_volume_with_wastage;
              param.tech_volume_of_cement = volume_of_cement;
              param.tech_number_of_bags = number_of_bags;
              param.tech_volume_of_sand = volume_of_sand;
              param.tech_mortar_cost = mortar_cost;
              param.tech_total_cost = total_cost;

              return param;
            } else {
              return { error: "Please! Enter Positive Values" };
            }
          } else {
            return { error: "Please! Check Your Input" };
          }
        }
      } else {
        return { error: "Please! Enter Positive Values" };
      }
    } else {
      return { error: "Please! Check Your Input" };
    }
  }


  async getCalculationMetalRoofCostCalculator(body) {
    try {
        let type = body.tech_type;
        let r_length = body.tech_r_length;
        let rl_units = body.tech_rl_units;
        let r_width = body.tech_r_width;
        let rw_units = body.tech_rw_units;
        let roof_pitch = body.tech_roof_pitch;
        let p_length = body.tech_p_length;
        let pl_units = body.tech_pl_units;
        let p_width = body.tech_p_width;
        let pw_units = body.tech_pw_units;
        let cost = body.tech_cost;

      // Roof pitch conversion table
      const roofPitch = {
        "1:12": { value: 1.003 }, "2:12": { value: 1.014 }, "3:12": { value: 1.031 },
        "4:12": { value: 1.054 }, "5:12": { value: 1.083 }, "6:12": { value: 1.118 },
        "7:12": { value: 1.158 }, "8:12": { value: 1.202 }, "9:12": { value: 1.25 },
        "10:12": { value: 1.302 }, "11:12": { value: 1.357 }, "12:12": { value: 1.414 },
        "13:12": { value: 1.474 }, "14:12": { value: 1.537 }, "15:12": { value: 1.601 },
        "16:12": { value: 1.667 }, "17:12": { value: 1.734 }, "18:12": { value: 1.803 },
        "19:12": { value: 1.873 }, "20:12": { value: 1.944 }, "21:12": { value: 2.016 },
        "22:12": { value: 2.088 }, "23:12": { value: 2.162 }, "24:12": { value: 2.236 },
        "25:12": { value: 2.311 }, "26:12": { value: 2.386 }, "27:12": { value: 2.462 },
        "28:12": { value: 2.539 }, "29:12": { value: 2.615 }, "30:12": { value: 2.693 },
      };

      // Convert to feet based on unit
      const roofUnit = (input, unit) => {
        if (unit == "cm") return input * 0.03281;
        if (unit == "dm") return input * 0.3281;
        if (unit == "m") return input * 3.281;
        if (unit == "in") return input * 0.08333;
        if (unit == "yd") return input * 3;
        return input; // default case (already feet)
      };

      // Ensure numeric input
      if (
        !isNaN(r_length) && !isNaN(r_width) &&
        !isNaN(p_length) && !isNaN(p_width) &&
        !isNaN(cost)
      ) {
        // Convert all lengths/widths to feet
        if (rl_units) r_length = roofUnit(Number(r_length), rl_units);
        if (rw_units) r_width = roofUnit(Number(r_width), rw_units);
        if (pl_units) p_length = roofUnit(Number(p_length), pl_units);
        if (pw_units) p_width = roofUnit(Number(p_width), pw_units);

        let r_area, p_area, panel, expense, value;

        if (type == "yes") {
          // Without roof pitch
          r_area = r_length * r_width;
          p_area = p_length * p_width;
          panel = Math.round(r_area / p_area);
          expense = cost * panel;
        } else if (type === "no") {
          // With roof pitch
          const Detail = roofPitch[roof_pitch];
          if (!Detail) {
            return { error: "Invalid roof pitch option" };
          }
          value = Detail.value;
          r_area = r_length * r_width * value;
          p_area = p_length * p_width;
          panel = Math.round(r_area / p_area);
          expense = cost * panel;
        } else {
          return { error: "Invalid type value" };
        }

        // ✅ Final structured response
        const result = {
          tech_type:type,
          tech_r_length:r_length,
          tech_r_width:r_width,
          tech_p_length:p_length,
          tech_p_width:p_width,
          tech_cost:cost,
          tech_r_area:r_area,
          tech_p_area:p_area,
          tech_panel:panel,
          tech_expense:expense,
        };

        if (type == "no") {
          result.tech_roof_pitch = roof_pitch;
          result.tech_value = value;
        }

        return result;
      } else {
        return { error: "Please! Check Your Input" };
      }
    } catch (err) {
      return { error: "An unexpected error occurred", details: err.message };
    }
  }

  async getCalculationRoofReplacementCostCalculator(body) {
    try {
        const size1 = body.tech_size1;
        const size2 = body.tech_size2;
        const slop = body.tech_slop;
        const difficulty = body.tech_difficulty;
        const existing = body.tech_existing;
        const floor = body.tech_floor;
        const material = body.tech_material;
        const region = body.tech_region;

      // ✅ Validate numeric input
      if (isNaN(size1) || isNaN(size2)) {
        return { error: "Please! Check Your Inputs" };
      }

      // ✅ Prepare form data
      const formData = new URLSearchParams();
      formData.append("size1", size1);
      formData.append("device", "desk");
      formData.append("size2", size2);
      formData.append("material", material);
      formData.append("slop", slop);
      formData.append("difficulty", difficulty);
      formData.append("sky", "");
      formData.append("ridge", "");
      formData.append("floor", floor);
      formData.append("existing", existing);
      formData.append("region", region);

      // ✅ Make POST request with axios
      const response = await axios.post(
        "https://www.roofcalc.org/scripts/calc-widget-test.php",
        formData,
        {
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
            Cookie: "PHPSESSID=9886c1db5ddcc7f383052a97e803ef26",
          },
          httpsAgent: new (await import("https")).Agent({
            rejectUnauthorized: false, // ⚠️ Disable SSL verification like in PHP
          }),
          timeout: 10000, // 10 seconds timeout
        }
      );

      const data = response.data;

      // ✅ Extract all $ amounts using regex (like preg_match_all)
      const matches = data.match(/\$[0-9,]+/g);
      const result = matches || [];

      // ✅ Return structured output
      return {
        tech_result:result,
      };

    } catch (error) {
      // ✅ Error handling
      return {
        error: error.response
          ? `API Error: ${error.response.statusText}`
          : `Request Error: ${error.message}`,
      };
    }
  }

    async getCalculationSquareInchesCalculator(body) {
          let length = body.tech_length;
          let l_units = body.tech_l_units;
          let width = body.tech_width;
          let w_units = body.tech_w_units;
          let price = body.tech_price;

      // Convert to numbers where needed
      length = Number(length);
      width = Number(width);
      price = Number(price);

      // Helper function to convert to inches
      function squareToInches(value, unit) {
        if (unit == "ft") return value * 12;
        if (unit == "in") return value * 1;
        if (unit == "yd") return value * 36;
        if (unit == "cm") return value / 2.54;
        if (unit == "m") return value * 39.37;
        if (unit == "mi") return value / 1000;
        if (unit == "km") return value * 39370;
        if (unit == "mm") return value / 25.4; // Added mm conversion
        return NaN;
    }


      const param = {};

      if (!isNaN(length) && !isNaN(width)) {
        const lengthInches = squareToInches(length, l_units);
        const widthInches = squareToInches(width, w_units);

        if (isNaN(lengthInches) || isNaN(widthInches)) {
          param.error = "Invalid unit type";
          return param;
        }

        const square_inches = lengthInches * widthInches;
        param.tech_square_inches = square_inches;

        if (!isNaN(price)) {
          param.tech_cost = square_inches * price;
        }

        return param;
      } else {
        param.error = "Please! Check Your Inputs";
        return param;
      }
    }


      async  getCalculationSodCalculator(body) {
          const method = body.tech_method;
        const length = body.tech_length;
        const length_unit = body.tech_length_unit;
        const width = body.tech_width;
        const width_unit = body.tech_width_unit;
        const area = body.tech_area;
        const area_unit = body.tech_area_unit;
        const price = body.tech_price;

    let param = {};

    // Helper function to round to significant figures
    function sigFig3(value, digits) {
      if (value === 0) return 0;
      const decimalPlaces = digits - Math.floor(Math.log10(Math.abs(value))) - 1;
      return Number(value.toFixed(decimalPlaces));
    }

    let total_area, rolls, pallets, acres;

    if (method === "lw" && !isNaN(length) && !isNaN(width)) {
      let l = Number(length);
      let w = Number(width);

      // ✅ Convert length units to feet
      if (length_unit == "cm") l = l / 30.48;
      else if (length_unit == "m") l = l / 0.3048;
      else if (length_unit == "km") l = l / 0.0003048;
      else if (length_unit == "in") l = l / 12;
      else if (length_unit == "yd") l = l / 0.33333;
      else if (length_unit == "mi") l = l / 0.0001894;

      // ✅ Convert width units to feet
      if (width_unit == "cm") w = w / 30.48;
      else if (width_unit == "m") w = w / 0.3048;
      else if (width_unit == "km") w = w / 0.0003048;
      else if (width_unit == "in") w = w / 12;
      else if (width_unit == "yd") w = w / 0.33333;
      else if (width_unit == "mi") w = w / 0.0001894;

      if (length_unit === "m" && width_unit === "m") {
        l = l * 0.3048;
        w = w * 0.3048;

        total_area = l * w;
        rolls = total_area + 1;
        pallets = total_area / 40;
        acres = total_area * 0.0001;
        param["tech_meter"] = "meter";
      } else {
        total_area = l * w;
        rolls = total_area / 10;
        pallets = total_area / 450;
        acres = total_area * 0.000022957;
      }

    } else if (method === "area" && !isNaN(area)) {
      let a = Number(area);

      // ✅ Area conversion to square feet
      if (area_unit == "km²") a = a / 0.0000000929;
      else if (area_unit == "yd²") a = a / 0.1111;
      else if (area_unit == "mi²") a = a / 0.00000003587;
      else if (area_unit == "a") a = a / 0.000929;
      else if (area_unit == "da") a = a / 0.0000929;
      else if (area_unit == "ha") a = a / 0.0001;
      else if (area_unit == "ac") a = a / 0.000022957;
      else if (area_unit == "soccer fields") a = a / 0.000013012;

      if (area_unit === "m²" || area_unit === "ha") {
        total_area = a;
        rolls = total_area;
        pallets = total_area / 40;
        acres = total_area * 0.0001;
        param["tech_meter"] = "meter";
      } else {
        total_area = a;
        rolls = total_area / 10;
        pallets = total_area / 450;
        acres = total_area * 0.000022957;
      }

    } else {
      param["error"] = "Please! Check Your Input";
      return param;
    }

    // ✅ Cost calculation
    if (!isNaN(price)) {
      const cost = price * rolls;
      const cost_ft2 = cost / total_area;
      param["tech_cost"] = cost.toFixed(2);
      param["tech_cost_ft2"] = cost_ft2.toFixed(2);
    }

    // ✅ Final results
    param["tech_total_area"] = Number(total_area).toLocaleString();
    param["tech_rolls"] = Number(rolls).toLocaleString();
    param["tech_pallets"] = pallets.toFixed(2);
    param["tech_acres"] = acres.toFixed(3);

    return param;
  }


  async  getCalculationConcreteBlockCalculator(body) {
    const width = body.tech_width;
    const height = body.tech_height;
    const width_unit = body.tech_width_unit;
    const height_unit = body.tech_height_unit;
    const block_size = body.tech_block_size;
    const block_price = body.tech_block_price;

    let param = {};

    let w = Number(width);
    let h = Number(height);
    let price = Number(block_price);

    // ✅ Unit conversion for height
    if (height_unit) {
      if (height_unit == "cm") {
        h = h * 0.3937;
      } else if (height_unit == "mm") {
        h = h * 0.03937;
      } else if (height_unit == "m") {
        h = h * 39.37;
      } else if (height_unit == "in") {
        // Already inches
      } else if (height_unit == "ft") {
        h = h * 12;
      }
    }

    // ✅ Unit conversion for width
    if (width_unit) {
      if (width_unit == "cm") {
        w = w * 0.3937;
      } else if (width_unit == "mm") {
        w = w * 0.03937;
      } else if (width_unit == "m") {
        w = w * 39.37;
      } else if (width_unit == "in") {
        // Already inches
      } else if (width_unit == "ft") {
        w = w * 12;
      }
    }

    // ✅ Validation
    if (!isNaN(w) && !isNaN(h) && !isNaN(price)) {
      const wall_area = w * h;
      let block_area = 0;

      // ✅ Block size mapping
      if (block_size == "16x8") {
        block_area = 16 * 8;
      } else if (block_size == "8x8") {
        block_area = 8 * 8;
      } else if (block_size == "12x8") {
        block_area = 12 * 8;
      } else if (block_size == "8x4") {
        block_area = 8 * 4;
      } else if (block_size == "12x4") {
        block_area = 12 * 4;
      } else if (block_size == "16x4") {
        block_area = 16 * 4;
      } else {
        param["error"] = "Invalid block size.";
        return param;
      }

      // ✅ Calculations
      const blocks_needed = Math.round(wall_area / block_area);
      const total_block_cost = blocks_needed * price;
      const mortar_estimation = Math.ceil(blocks_needed / 100) * 3;

      // ✅ Assign results
      param["tech_wall_area"] = wall_area;
      param["tech_blocks_needed"] = blocks_needed;
      param["tech_total_block_cost"] = total_block_cost;
      param["tech_mortar_estimation"] = mortar_estimation;
    } else {
      param["error"] = "Please check input.";
      return param;
    }

    return param;
  }

      async  getCalculationCarpetCalculator(body) {
          const shape = body.tech_shape;
        const length = body.tech_length;
        const length_unit = body.tech_length_unit;
        const width = body.tech_width;
        const width_unit = body.tech_width_unit;
        const radius = body.tech_radius;
        const radius_unit = body.tech_radius_unit;
        const axis_a = body.tech_axis_a;
        const axis_a_unit = body.tech_axis_a_unit;
        const axis_b = body.tech_axis_b;
        const axis_b_unit = body.tech_axis_b_unit;
        const side = body.tech_side;
        const side_unit = body.tech_side_unit;
        const sides = body.tech_sides;
        const sides_unit = body.tech_sides_unit;
        const carpet = body.tech_carpet;
        const carpet_unit = body.tech_carpet_unit;
        const price = body.tech_price;
        const price_unit = body.tech_price_unit;
        const currancy = body.tech_currancy;

      let param = {};

      // 🔹 Clean values
      let l = Number(length);
      let w = Number(width);
      let r = Number(radius);
      let a = Number(axis_a);
      let b = Number(axis_b);
      let s = Number(side);
      let ss = Number(sides);
      let c = Number(carpet);
      let p = Number(price);

      // 🔹 Remove currency symbol from price_unit
      let cleanPriceUnit = price_unit ? price_unit.replace(currancy + " ", "") : "";

      // 🔹 Unit conversion for carpet dimensions
      function carpetUnits(value, unit) {
        if (unit === "cm") {
          return value / 100;
        } else if (unit === "dm") {
          return value / 10;
        } else if (unit === "in") {
          return value * 0.0254;
        } else if (unit === "ft") {
          return value * 0.3048;
        } else if (unit === "yd") {
          return value * 0.9144;
        } else {
          return value; // assume meters
        }
      }

      // 🔹 Unit conversion for price
      function priceUnits(value, unit) {
        if (unit === "cm²") {
          return value / 10000;
        } else if (unit === "dm²") {
          return value / 100;
        } else if (unit === "in²") {
          return value / 1550.0031;
        } else if (unit === "ft²") {
          return value / 10.7639;
        } else if (unit === "yd²") {
          return value / 1.19599;
        } else {
          return value; // assume m²
        }
      }

      let answer = null;
      let sub_answer = null;

      // 🔹 Shape-based logic
      if (shape === "Rectangle") {
        if (isFinite(l) && isFinite(w) && isFinite(p)) {
          l = carpetUnits(l, length_unit);
          w = carpetUnits(w, width_unit);
          answer = l * w;
          sub_answer = answer * p;
        } else {
          param["error"] = "Please! Check Your Input";
          return param;
        }
      } else if (shape === "Circle") {
        if (isFinite(r) && isFinite(p)) {
          r = carpetUnits(r, radius_unit);
          answer = Math.PI * Math.pow(r, 2);
          sub_answer = answer * p;
        } else {
          param["error"] = "Please! Check Your Input";
          return param;
        }
      } else if (shape === "Ellipse") {
        if (isFinite(a) && isFinite(b) && isFinite(p)) {
          a = carpetUnits(a, axis_a_unit);
          b = carpetUnits(b, axis_b_unit);
          answer = a * b * Math.PI;
          sub_answer = answer * p;
        } else {
          param["error"] = "Please! Check Your Input";
          return param;
        }
      } else if (shape === "Pentagon") {
        if (isFinite(s) && isFinite(p)) {
          s = carpetUnits(s, side_unit);
          answer = (s * s * Math.sqrt(25 + 10 * Math.sqrt(5))) / 4;
          sub_answer = answer * p;
        } else {
          param["error"] = "Please! Check Your Input";
          return param;
        }
      } else if (shape === "Hexagon") {
        if (isFinite(ss) && isFinite(p)) {
          ss = carpetUnits(ss, sides_unit);
          answer = (3 / 2) * Math.sqrt(3) * Math.pow(ss, 2);
          sub_answer = answer * p;
        } else {
          param["error"] = "Please! Check Your Input";
          return param;
        }
      } else {
        if (isFinite(c) && isFinite(p)) {
          answer = priceUnits(c, carpet_unit);
          sub_answer = answer * p;
        } else {
          param["error"] = "Please! Check Your Input";
          return param;
        }
      }

      // ✅ Final response
      param["tech_answer"] = answer;
      param["tech_sub_answer"] = sub_answer;

      return param;
    }

    async getCalculationCylinderVolumeCalculator(body) {
      try {
      let f_height = body.tech_f_height;
      let f_height_units = body.tech_f_height_units;
      let f_radius = body.tech_f_radius;
      let f_radius_units = body.tech_f_radius_units;
      let s_height = body.tech_s_height;
      let s_height_units = body.tech_s_height_units;
      let external = body.tech_external;
      let external_units = body.tech_external_units;
      let internal = body.tech_internal;
      let internal_units = body.tech_internal_units;

        // Helper function: convert all to centimeters
        function convert_unit(unit, value) {
          if (!unit) return value;
          value = Number(value);

          switch (unit) {
            case "cm":
              return value;
            case "mm":
              return value / 0.1;
            case "m":
              return value * 100;
            case "km":
              return value * 100000;
            case "in":
              return value * 2.54;
            case "ft":
              return value * 30.48;
            case "yd":
              return value * 91.44;
            case "mi":
              return value * 160934.4;
            default:
              return value;
          }
        }

        // Validate all numeric inputs
        if (
          isNaN(f_height) ||
          isNaN(f_radius) ||
          isNaN(s_height) ||
          isNaN(external) ||
          isNaN(internal)
        ) {
          return { error: "Please! Check Your Input" };
        }

        // Convert units
        f_height = convert_unit(f_height_units, f_height);
        f_radius = convert_unit(f_radius_units, f_radius);
        s_height = convert_unit(s_height_units, s_height);
        external = convert_unit(external_units, external);
        internal = convert_unit(internal_units, internal);

        // Calculate volumes
        const vol1 = Math.PI * Math.pow(f_radius, 2) * f_height;
        const vol2 = (Math.PI * s_height * (Math.pow(external, 2) - Math.pow(internal, 2))) / 4;

        return {
          tech_vol1:vol1,
          tech_vol2:vol2
        };
      } catch (err) {
        return { error: "Server error occurred" };
      }
    }


  async getCalculationFramingCalculator(body) {
    try {
     let wall = body.tech_wall;
    let wall_unit = body.tech_wall_unit;
    let spacing = body.tech_spacing;
    let spacing_unit = body.tech_spacing_unit;
    let price = body.tech_price;
    let estimated = body.tech_estimated;

      // Helper function to convert to meters
      function framing_units(value, unit) {
        value = Number(value);
        switch (unit) {
          case "cm":
            return value / 100;
          case "dm":
            return value / 10;
          case "in":
            return value * 0.0254;
          case "ft":
            return value * 0.3048;
          case "yd":
            return value * 0.9144;
          case "m":
          default:
            return value;
        }
      }

      // Validate numeric inputs
      if (
        isNaN(wall) ||
        isNaN(spacing) ||
        isNaN(price) ||
        isNaN(estimated)
      ) {
        return { error: "Please! Check Your Input" };
      }

      // Convert units
      wall = framing_units(wall, wall_unit);
      spacing = framing_units(spacing, spacing_unit);

      // Prevent divide-by-zero
      if (spacing == 0) {
        return { error: "oc spacing cannot be equal to zero" };
      }

      // Calculations
      const answer = wall / spacing + 1; // number of studs
      const wastages = answer * (estimated / 100);
      const wastage = wastages * price;
      const studs = price * answer;
      const sub_answer = studs + wastage; // total cost including wastage

      return {
        tech_answer:answer,
        tech_sub_answer:sub_answer
      };
    } catch (err) {
      return { error: "Server error occurred" };
    }
  }

    async getCalculationRoofingCalculator(body) {
    try {
      let length = body.tech_length;
      let length_units = body.tech_length_units;
      let width = body.tech_width;
      let width_units = body.tech_width_units;
      let pitch = body.tech_pitch;
      let price = body.tech_price;
      let price_units = body.tech_price_units;

      // Convert value to meters
      function conversion(unit, value) {
        value = Number(value);
        switch (unit) {
          case "cm":
            return value / 100;
          case "m":
            return value;
          case "in":
            return value * 0.0254;
          case "ft":
            return value * 0.3048;
          case "yd":
            return value * 0.9144;
          default:
            return value;
        }
      }

      // Convert price per area to price per m²
      if (price_units) {
        price = Number(price);
        switch (price_units) {
          case "m²":
            price = price;
            break;
          case "mm²":
            price /= 0.000001;
            break;
          case "cm²":
            price /= 0.0001;
            break;
          case "in²":
            price /= 0.00064516;
            break;
          case "ft²":
            price /= 0.09290304;
            break;
          case "yd²":
            price /= 0.83612736;
            break;
        }
      }

      // Validate inputs
      if (
        isNaN(length) ||
        isNaN(width) ||
        isNaN(pitch) ||
        isNaN(price)
      ) {
        return { error: "Please check input." };
      }

      // Convert units to meters
      length = conversion(length_units, length);
      width = conversion(width_units, width);

      // Core calculations
      const house_area = length * width;
      const slop = (pitch * 12) / 100;
      const pitch_rad = Math.atan(pitch / 100);
      const pitch_deg = (pitch_rad * 180) / Math.PI;
      const roof_area = house_area / Math.cos((pitch_deg * Math.PI) / 180);
      const cost = roof_area * price;

      // Return results
      return {
        tech_house_area:house_area,
        tech_slop:slop,
        tech_pitch_deg:pitch_deg,
        tech_roof_area:roof_area,
        tech_cost:cost
      };
    } catch (err) {
      return { error: "Server error occurred" };
    }
  }

  async getCalculationDeckingCalculator(body) {
      let deck_length = body.tech_deck_length;
      let deck_length_unit = body.tech_deck_length_unit;
      let deck_width = body.tech_deck_width;
      let deck_width_unit = body.tech_deck_width_unit;
      let board_length = body.tech_board_length;
      let board_length_unit = body.tech_board_length_unit;
      let board_width = body.tech_board_width;
      let board_width_unit = body.tech_board_width_unit;
      let material = body.tech_material;
      let price = body.tech_price;
      let Cost = body.tech_Cost;

      // Trim all string inputs
      deck_length = deck_length?.toString().trim();
      deck_length_unit = deck_length_unit?.toString().trim();
      deck_width = deck_width?.toString().trim();
      deck_width_unit = deck_width_unit?.toString().trim();
      board_length = board_length?.toString().trim();
      board_length_unit = board_length_unit?.toString().trim();
      board_width = board_width?.toString().trim();
      board_width_unit = board_width_unit?.toString().trim();
      material = material?.toString().trim();
      price = price?.toString().trim();
      Cost = Cost?.toString().trim();

      // Convert to numbers
      deck_length = Number(deck_length);
      deck_width = Number(deck_width);
      board_length = Number(board_length);
      board_width = Number(board_width);
      price = Number(price);
      Cost = Number(Cost);

      // Helper function for unit conversion
      function unit_change(value, unit) {
        if (unit == "cm") {
          return value * 30.48;
        } else if (unit == "m") {
          return value / 3.28084;
        } else if (unit == "in") {
          return value * 12;
        } else if (unit == "ft") {
          return value;
        }
        return value;
      }

      const result = {};

      // Validate numeric inputs
      if (
        !isFinite(deck_length) ||
        !isFinite(deck_width) ||
        !isFinite(board_length) ||
        !isFinite(board_width) ||
        !isFinite(price) ||
        !isFinite(Cost)
      ) {
        result.error = "Please check your input";
        return result;
      }

      // Zero-value validations
      if (deck_length == 0) {
        result.error = "length value cannot be equal to zero";
        return result;
      }
      if (deck_width == 0) {
        result.error = "width value cannot be equal to zero";
        return result;
      }
      if (board_length == 0) {
        result.error = "length value cannot be equal to zero";
        return result;
      }
      if (board_width == 0) {
        result.error = "width value cannot be equal to zero";
        return result;
      }
      if (price == 0) {
        result.error = "price per board value cannot be equal to zero";
        return result;
      }
      if (Cost == 0) {
        result.error = "cost of fasteners value cannot be equal to zero";
        return result;
      }

      // Unit conversions
      deck_length = unit_change(deck_length, deck_length_unit);
      deck_width = unit_change(deck_width, deck_width_unit);
      board_length = unit_change(board_length, board_length_unit);
      board_width = unit_change(board_width, board_width_unit);

      // Calculations
      const size_deck = deck_length * deck_width; // ans 1
      const size_board = board_length * board_width; // ans 2
      const numbers = Math.round((size_deck / size_board) * 1.1); // ans 3
      const materialValue = size_deck / 100;
      const nails = materialValue * 350; // ans 4
      const clips = nails / 2; // ans 5
      const price_boards = numbers * price; // ans 6
      const Cost_boards = price_boards + Cost; // ans 7

      // Build response
      result.tech_size_deck = size_deck;
      result.tech_size_board = size_board;
      result.tech_numbers = numbers;
      result.tech_nails = nails;
      result.tech_clips = clips;
      result.tech_price_boards = price_boards;
      result.tech_Cost_boards = Cost_boards;

      return result;
    }

  async getCalculationSonotubeCalculator(body) {
      let size_unit = body.tech_size_unit;
      let height = body.tech_height;
      let height_unit = body.tech_height_unit;
      let quantity = body.tech_quantity;
      let concerete_mix_unit = body.tech_concerete_mix_unit;
      let density = body.tech_density;
      let density_unit = body.tech_density_unit;
      let concrete_ratio_unit = body.tech_concrete_ratio_unit;
      let bag_size = body.tech_bag_size;
      let bag_size_unit = body.tech_bag_size_unit;
      let waste = body.tech_waste;
      let Cost_bag_mix = body.tech_Cost_bag_mix;
      let Cost_of_cement = body.tech_Cost_of_cement;
      let Cost_of_cement_unit = body.tech_Cost_of_cement_unit;
      let Cost_of_sand = body.tech_Cost_of_sand;
      let Cost_of_sand_unit = body.tech_Cost_of_sand_unit;
      let Cost_of_gravel = body.tech_Cost_of_gravel;
      let Cost_of_gravel_unit = body.tech_Cost_of_gravel_unit;

    // Trim all inputs
    const trimVal = (v) => (typeof v === "string" ? v.trim() : v);
    size_unit = trimVal(size_unit);
    height = Number(trimVal(height));
    height_unit = trimVal(height_unit);
    quantity = Number(trimVal(quantity));
    concerete_mix_unit = trimVal(concerete_mix_unit);
    density = Number(trimVal(density));
    density_unit = trimVal(density_unit);
    concrete_ratio_unit = trimVal(concrete_ratio_unit);
    bag_size = Number(trimVal(bag_size));
    bag_size_unit = trimVal(bag_size_unit);
    waste = Number(trimVal(waste));
    Cost_bag_mix = Number(trimVal(Cost_bag_mix));
    Cost_of_cement = Number(trimVal(Cost_of_cement));
    Cost_of_cement_unit = trimVal(Cost_of_cement_unit);
    Cost_of_sand = Number(trimVal(Cost_of_sand));
    Cost_of_sand_unit = trimVal(Cost_of_sand_unit);
    Cost_of_gravel = Number(trimVal(Cost_of_gravel));
    Cost_of_gravel_unit = trimVal(Cost_of_gravel_unit);

    const result = {};

    // Size mapping
    const sizeMap = {
      "6 (15.24 cm)": 6 / 2,
      "8 (20.32 cm)": 8 / 2,
      "10 (25.40 cm)": 10 / 2,
      "12 (30.48 cm)": 12 / 2,
      "14 (35.56 cm)": 14 / 2,
      "16 (40.64 cm)": 16 / 2,
      "18 (45.72 cm)": 18 / 2,
      "20 (50.80 cm)": 20 / 2,
      "22 (55.88 cm)": 22 / 2,
      "24 (60.96 cm)": 24 / 2,
      "26 (66.04 cm)": 26 / 2,
      "28 (71.12 cm)": 28 / 2,
      "30 (76.20 cm)": 30 / 2,
      "32 (81.28 cm)": 32 / 2,
      "34 (86.36 cm)": 34 / 2,
      "36 (91.44 cm)": 36 / 2,
      "40 (101.60 cm)": 40 / 2,
      "42 (106.68 cm)": 42 / 2,
      "48 (121.91 cm)": 48 / 2,
      "54 (137.16 cm)": 54 / 2,
      "60 (152.40 cm)": 60 / 2,
    };
    const size = sizeMap[size_unit] ?? 0;

    // Helper conversions
    const section_height = (val, unit) => {
      if (unit === "cm") return val * 2.54;
      if (unit === "m") return val / 39.37;
      if (unit === "in") return val;
      if (unit === "ft") return val / 12;
      if (unit === "yd") return val / 36;
      return val;
    };

    const section_density = (val, unit) => {
      if (unit === "kg/m³") return val * 16.01846;
      if (unit === "lb/cu ft") return val;
      if (unit === "lb/cu yd") return val * 27;
      if (unit === "g/cm³") return val * 0.01601846;
      return val;
    };

    const section_bag_size = (val, unit) => {
      if (unit === "kg") return val;
      if (unit === "lb") return val * 2.205;
      return val;
    };

    const section_two = (val, unit) => {
      if (unit === "cm³") return val * 28320;
      if (unit === "m³") return val / 35.315;
      if (unit === "cu ft") return val;
      if (unit === "cu yd") return val / 27;
      return val;
    };

    // Input validation
    if (!isFinite(height) || !isFinite(quantity)) {
      return { error: "Please! Check Your Input" };
    }

    if (height === 0) return { error: "height value cannot be equal to zero" };
    if (quantity === 0) return { error: "quantity value cannot be equal to zero" };

    // Volume calculation
    const heightIn = section_height(height, height_unit);
    const radius = size * size;
    const volume = (Math.round(3.1415 * radius * heightIn) / 1728) * quantity;

    // CASE 1: Pre-mixed concrete bags
    if (concerete_mix_unit === "I'll get pre-mixed concrete bags") {
      if (!isFinite(density) || !isFinite(bag_size) || !isFinite(waste) || !isFinite(Cost_bag_mix)) {
        return { error: "Please! Check Your Input" };
      }
      if (density === 0) return { error: "concrete density value cannot be equal to zero" };
      if (bag_size === 0) return { error: "bag size value cannot be equal to zero" };
      if (waste === 0) return { error: "waste value cannot be equal to zero" };
      if (Cost_bag_mix === 0)
        return { error: "Cost of each bag of pre-mix concrete value cannot be equal to zero" };

      const densityz = section_density(density, density_unit);
      const weight = volume * densityz;
      const bagSize = section_bag_size(bag_size, bag_size_unit);
      const bagEffective = bagSize * (1 - waste / 100);
      const bags = Math.round((weight / 2.205) / bagEffective);
      const costTotal = Cost_bag_mix * bags;
      const perUnit = Number((costTotal / volume).toFixed(2));
      const costPerColumn = perUnit * volume;

      result.tech_weghits = weight;
      result.tech_bagsz = bags;
      result.tech_per_units = perUnit;
      result.tech_cost_per_colums = costPerColumn;
      result.tech_total_costz = costPerColumn;
    }

    // CASE 2: Manual concrete mix
    else {
      if (
        !isFinite(waste) ||
        !isFinite(Cost_of_cement) ||
        !isFinite(Cost_of_sand) ||
        !isFinite(Cost_of_gravel)
      ) {
        return { error: "Please! Check Your Input" };
      }

      if (waste === 0) return { error: "waste value cannot be equal to zero" };
      if (Cost_of_cement === 0)
        return { error: "cost of cement per volume value cannot be equal to zero" };
      if (Cost_of_sand === 0)
        return { error: "cost of sand per volume value cannot be equal to zero" };
      if (Cost_of_gravel === 0)
        return { error: "cost of gravel per volume value cannot be equal to zero" };

      const total_volume = volume * (1 + waste / 100);
      const value_cement = total_volume * 1 / (size * 2);

      let ratio_of_sand = 0;
      let ratio_of_gravel = 0;

      if (concrete_ratio_unit === "1:5:10 (5.0 MPa or 725 psi)") {
        ratio_of_sand = 5; ratio_of_gravel = 10;
      } else if (concrete_ratio_unit === "1:4:8 (7.5 MPa or 1085 psi)") {
        ratio_of_sand = 4; ratio_of_gravel = 8;
      } else if (concrete_ratio_unit === "1:3:6 (10.0 MPa or 1450 psi)") {
        ratio_of_sand = 3; ratio_of_gravel = 6;
      } else if (concrete_ratio_unit === "1:2:4 (15.0 MPa or 2175 psi)") {
        ratio_of_sand = 2; ratio_of_gravel = 4;
      } else if (concrete_ratio_unit === "1:1.5:3 (20.0 MPa or 2900 psi)") {
        ratio_of_sand = 1.5; ratio_of_gravel = 3;
      }

      const value_sand = total_volume * ratio_of_sand / (size * 2);
      const value_gravel = total_volume * ratio_of_gravel / (size * 2);

      const cementCost = section_two(Cost_of_cement, Cost_of_cement_unit) * value_cement;
      const sandCost = section_two(Cost_of_sand, Cost_of_sand_unit) * value_sand;
      const gravelCost = section_two(Cost_of_gravel, Cost_of_gravel_unit) * value_gravel;
      const total_cost = cementCost + sandCost + gravelCost;

      result.tech_total_volume = total_volume;
      result.tech_value_cement = value_cement;
      result.tech_value_sand = value_sand;
      result.tech_value_gravel = value_gravel;
      result.tech_total_costszz = total_cost;
    }

    // Final output
    result.tech_volume = volume;
    return result;
  }

    async getCalculationGravelCalculator(body) {
      try {
      let from = body.tech_from;
      let to_calculate = body.tech_to_calculate;
      let length = body.tech_length;
      let l_unit = body.tech_l_unit;
      let volume = body.tech_volume;
      let v_unit = body.tech_v_unit;
      let width = body.tech_width;
      let w_unit = body.tech_w_unit;
      let area = body.tech_area;
      let a_unit = body.tech_a_unit;
      let depth = body.tech_depth;
      let d_unit = body.tech_d_unit;
      let density = body.tech_density;
      let dn_unit = body.tech_dn_unit;
      let price = body.tech_price;
      let p_unit = body.tech_p_unit;
      let currancy = body.tech_currancy;
      let diameter = body.tech_diameter;
      let dia_unit = body.tech_dia_unit;

        const param = {};

        // Clean price unit
        if (p_unit) p_unit = p_unit.replace(`${currancy} `, "");

        // ✅ Helper function for unit conversions
        const convertToFeet = (value, unit) => {
          if (unit === "in") return value / 12;
          if (unit === "yd") return value * 3;
          if (unit === "cm") return value / 30.48;
          if (unit === "m") return value * 3.28084;
          return value;
        };

        const convertDensity = (value, unit) => {
          if (unit === "lb/yd³") return value / 27;
          if (unit === "t/yd³") return value / 74.074;
          if (unit === "kg/m³") return value / 16.018;
          return value;
        };

        const convertPriceWeight = (weight, priceUnit) => {
          if (priceUnit === "kg") return weight / 2.205;
          if (priceUnit === "g") return weight * 453.59;
          if (priceUnit === "t") return weight / 2205;
          return weight;
        };

        // ===============================
        // 🟢 RECTANGULAR SECTION
        // ===============================
        if (from == "rec") {
          // ---- CASE 1: Length, Width, Depth ----
          if (to_calculate == "1") {
            if (
              isNaN(length) ||
              isNaN(width) ||
              isNaN(depth) ||
              isNaN(density)
            ) {
              param.error = "Please! Check Your Input";
              return param;
            }

            length = convertToFeet(length, l_unit);
            width = convertToFeet(width, w_unit);
            depth = convertToFeet(depth, d_unit);
            density = convertDensity(density, dn_unit);

            const area = +(length * width).toFixed(3);
            const volume = +(depth * area).toFixed(3);
            const weight = +(density * volume).toFixed(3);

            if (price) {
              let p_weight = convertPriceWeight(weight, p_unit);
              param.tech_price = +(p_weight * price).toFixed(3);
            }

            Object.assign(param, {
             tech_area:area, 
             tech_weight:weight, 
             tech_volume:volume, 
             });
            return param;
          }

          // ---- CASE 2: Area, Depth ----
          if (to_calculate == "2") {
            if (isNaN(area) || isNaN(depth) || isNaN(density)) {
              param.error = "Please! Check Your Input";
              return param;
            }

            if (a_unit === "m²") area = area * 10.764;
            else if (a_unit === "yd²") area = area * 9;

            depth = convertToFeet(depth, d_unit);
            density = convertDensity(density, dn_unit);

            const volume = +(depth * area).toFixed(3);
            const weight = +(density * volume).toFixed(3);

            if (price) {
              let p_weight = convertPriceWeight(weight, p_unit);
              param.tech_price = +(p_weight * price).toFixed(3);
            }

            Object.assign(param, { 
              tech_area:area, 
              tech_weight:weight,
              tech_volume:volume,
              });
            return param;
          }

          // ---- CASE 3: Volume ----
          if (to_calculate == "3") {
            if (isNaN(volume) || isNaN(density)) {
              param.error = "Please! Check Your Input";
              return param;
            }

            if (v_unit === "m³") volume = volume * 35.315;
            else if (v_unit === "yd³") volume = volume * 27;

            density = convertDensity(density, dn_unit);
            const weight = +(density * volume).toFixed(3);

            if (price) {
              let p_weight = convertPriceWeight(weight, p_unit);
              param.tech_price = +(p_weight * price).toFixed(3);
            }

            Object.assign(param, { 
              tech_weight:weight,
              tech_volume:volume,
               });
            return param;
          }
        }

        // ===============================
        // 🟢 CIRCULAR SECTION
        // ===============================
        else {
          if (isNaN(diameter) || isNaN(density)) {
            param.error = "Please! Check Your Input";
            return param;
          }

          diameter = convertToFeet(diameter, dia_unit);
          depth = convertToFeet(depth, d_unit);
          density = convertDensity(density, dn_unit);

          const area = Math.PI * Math.pow(diameter / 2, 2);
          const volume = +(depth * area).toFixed(3);
          const weight = +(density * volume).toFixed(3);

          if (price) {
            let p_weight = convertPriceWeight(weight, p_unit);
            param.tech_price = +(p_weight * price).toFixed(3);
          }

          Object.assign(param, { 
          tech_area:area,
          tech_weight:weight,
          tech_volume:volume,
             });
          return param;
        }
      } catch (error) {
        return { error: "An unexpected error occurred", message: error.message };
      }
    }

    async  getCalculationMulchCalculator(body) {
      try {
        const param = {};
        
        // Extract all values from body
        const m_shape = body["tech_m-shape"];
        const length = parseFloat(body.tech_length);
        const length_unit = body.tech_length1;
        const width = parseFloat(body.tech_width);
        const width_unit = body.tech_width1;
        const area = parseFloat(body["tech_sqr-ft"]);
        const area_unit = body["tech_sqr-ft1"];
        const depth = parseFloat(body.tech_depth);
        const depth_unit = body.tech_depth1;
        const bag_size = parseFloat(body.tech_bag_size);
        const bag_size1 = body.tech_bag_size1;
        const price_bag = parseFloat(body.tech_price_bag);
        const m_type = body["tech_m-type"];
        const check = body.tech_check;
        const g = body.tech_g;
        const diameter = parseFloat(body.tech_diameter);
        const diameter_unit = body.tech_diameter1;
        const side1 = parseFloat(body.tech_side1);
        const side1_unit = body.tech_side11;
        const side2 = parseFloat(body.tech_side2);
        const side2_unit = body.tech_side21;
          // Helper functions
          function isNumeric(value) {
            return !isNaN(parseFloat(value)) && isFinite(value);
          }

          function round(value, decimals) {
            return Number(Math.round(value + 'e' + decimals) + 'e-' + decimals);
          }

          function convertToFeet(value, unit) {
            switch (unit) {
              case 'in':
                return value / 12;
              case 'yd':
                return value * 3;
              case 'cm':
                return value / 30.48;
              case 'm':
                return value * 3.281;
              case 'ft':
              default:
                return value;
            }
          }

          function convertToInches(value, unit) {
            switch (unit) {
              case 'ft':
                return value * 12;
              case 'yd':
                return value * 36;
              case 'cm':
                return value / 2.54;
              case 'm':
                return value * 39.37;
              case 'in':
              default:
                return value;
            }
          }

          function convertBagSize(bagSize, unit) {
            switch (unit) {
              case 'm³':
                return bagSize * 35.315;
              case 'cu yd':
                return bagSize * 27;
              case 'liters':
                return bagSize / 28.317;
              case 'cu ft':
              default:
                return bagSize;
            }
          }

        // Rectangle/Square shape
        if (m_shape === '0') {
          // Using length and width
          if (check === 'g1_value' || g === 'g1') {
            if (isNumeric(length) && isNumeric(width) && isNumeric(depth)) {
              let convertedLength = convertToFeet(length, length_unit);
              let convertedWidth = convertToFeet(width, width_unit);
              let convertedDepth = convertToInches(depth, depth_unit);

              const garden_size = convertedLength * convertedWidth;
              const cubic_yards = (convertedLength * convertedWidth * convertedDepth) / 324;
              const cubic_ft = cubic_yards * 27;
              const cubic_meters = cubic_yards / 1.308;
              const liters = cubic_meters * 1000;

              // Calculate bags needed
              if (isNumeric(bag_size)) {
                let convertedBagSize = convertBagSize(bag_size, bag_size1);
                const size = cubic_ft / convertedBagSize;
                param.tech_size = round(size, 2);

                if (isNumeric(price_bag)) {
                  const total_cost = price_bag * size;
                  param.tech_total_cost = round(total_cost, 2);
                }
              }

              // Calculate based on mulch type
              if (m_type === '6') {
                const size1 = garden_size / 235 * convertedDepth * 2;
                param.tech_size1 = round(size1, 2);
                if (isNumeric(price_bag)) {
                  const total_cost1 = price_bag * size1;
                  param.tech_total_cost1 = round(total_cost1, 2);
                }
              }

              if (m_type === '10') {
                const size1 = garden_size / 235 * convertedDepth;
                param.tech_size1 = round(size1, 2);
                if (isNumeric(price_bag)) {
                  const total_cost1 = price_bag * size1;
                  param.tech_total_cost1 = round(total_cost1, 2);
                }
              }

              param.tech_garden_size = round(garden_size, 2);
              param.tech_cubic_yards = round(cubic_yards, 2);
              param.tech_cubic_ft = round(cubic_ft, 2);
              param.tech_cubic_meters = round(cubic_meters, 2);
              param.tech_liters = round(liters, 2);

              return param;
            } else {
              param.error = 'Please! Check Your Input';
              return param;
            }
          } 
          // Using area directly
          else {
            if (isNumeric(area) && isNumeric(depth)) {
              let convertedArea = area;

              if (area_unit === 'acres') {
                area = area * 43560;
              }

              let convertedDepth = depth;

              const cubic_yards = (convertedArea * convertedDepth) / 324;
              const cubic_ft = cubic_yards * 27;
              const cubic_meters = cubic_yards / 1.308;
              const liters = cubic_meters * 1000;

              // Calculate bags needed
              if (isNumeric(bag_size)) {
                let convertedBagSize = convertBagSize(bag_size, bag_size1);
                const size = cubic_ft / convertedBagSize;
                param.tech_size = round(size, 2);

                if (isNumeric(price_bag)) {
                  const total_cost = price_bag * size;
                  param.tech_total_cost = round(total_cost, 2);
                }
              }

              // Calculate based on mulch type
              if (m_type === '6') {
                const size1 = convertedArea / 235 * convertedDepth * 2;
                param.tech_size1 = round(size1, 2);
                if (isNumeric(price_bag)) {
                  const total_cost1 = price_bag * size1;
                  param.tech_total_cost1 = round(total_cost1, 2);
                }
              }

              if (m_type === '10') {
                const size1 = convertedArea / 235 * convertedDepth;
                param.tech_size1 = round(size1, 2);
                if (isNumeric(price_bag)) {
                  const total_cost1 = price_bag * size1;
                  param.tech_total_cost1 = round(total_cost1, 2);
                }
              }

              param.tech_garden_size = round(convertedArea, 2);
              param.tech_cubic_yards = round(cubic_yards, 2);
              param.tech_cubic_ft = round(cubic_ft, 2);
              param.tech_cubic_meters = round(cubic_meters, 2);
              param.tech_liters = round(liters, 2);
              return param;
            } else {
              param.error = 'Please! Check Your Input';
              return param;
            }
          }
        } 
        // Circle shape
        else if (m_shape === '1') {
          if (isNumeric(diameter) && isNumeric(depth)) {
            let convertedDiameter = convertToFeet(diameter, diameter_unit);
            let convertedDepth = convertToInches(depth, depth_unit);

            const radius = convertedDiameter * 0.5;
            const garden_size = (radius * radius) * 3.1452;
            const cubic_yards = ((convertedDepth / 12) * garden_size) / 27;
            const cubic_ft = cubic_yards * 27;
            const cubic_meters = cubic_yards / 1.308;
            const liters = cubic_meters * 1000;

            // Calculate bags needed
            if (isNumeric(bag_size)) {
              let convertedBagSize = convertBagSize(bag_size, bag_size1);
              const size = cubic_ft / convertedBagSize;
              param.tech_size = round(size, 2);

              if (isNumeric(price_bag)) {
                const total_cost = price_bag * size;
                param.tech_total_cost = round(total_cost, 2);
              }
            }

            // Calculate based on mulch type
            if (m_type === '6') {
              const size1 = garden_size / 235 * convertedDepth * 2;
              param.size1 = round(size1, 2);
              if (isNumeric(price_bag)) {
                const total_cost1 = price_bag * size1;
                param.tech_total_cost1 = round(total_cost1, 2);
              }
            }

            if (m_type === '10') {
              const size1 = garden_size / 235 * convertedDepth;
              param.tech_size1 = round(size1, 2);
              if (isNumeric(price_bag)) {
                const total_cost1 = price_bag * size1;
                param.tech_total_cost1 = round(total_cost1, 2);
              }
            }

            param.tech_garden_size = round(garden_size, 0);
            param.tech_cubic_yards = round(cubic_yards, 2);
            param.tech_cubic_ft = round(cubic_ft, 2);
            param.tech_cubic_meters = round(cubic_meters, 2);
            param.tech_liters = round(liters, 2);
            return param;
          } else {
            param.error = 'Please! Check Your Input';
            return param;
          }
        } 
        // Triangle shape
        else if (m_shape === '2') {
          if (isNumeric(side1) && isNumeric(side2) && isNumeric(depth)) {
            let convertedSide1 = convertToFeet(side1, side1_unit);
            let convertedSide2 = convertToFeet(side2, side2_unit);
            let convertedDepth = convertToInches(depth, depth_unit);

            const garden_size = convertedSide1 * convertedSide2 * 0.5;
            const cubic_yards = ((convertedDepth / 12) * garden_size) / 27;
            const cubic_ft = cubic_yards * 27;
            const cubic_meters = cubic_yards / 1.308;
            const liters = cubic_meters * 1000;

            // Calculate bags needed
            if (isNumeric(bag_size)) {
              let convertedBagSize = convertBagSize(bag_size, bag_size1);
              const size = cubic_ft / convertedBagSize;
              param.tech_size = round(size, 2);

              if (isNumeric(price_bag)) {
                const total_cost = price_bag * size;
                param.tech_total_cost = round(total_cost, 2);
              }
            }

            // Calculate based on mulch type
            if (m_type === '6') {
              const size1 = garden_size / 235 * convertedDepth * 2;
              param.tech_size1 = round(size1, 2);
              if (isNumeric(price_bag)) {
                const total_cost1 = price_bag * size1;
                param.tech_total_cost1 = round(total_cost1, 2);
              }
            }

            if (m_type === '10') {
              const size1 = garden_size / 235 * convertedDepth;
              param.tech_size1 = round(size1, 2);
              if (isNumeric(price_bag)) {
                const total_cost1 = price_bag * size1;
                param.tech_total_cost1 = round(total_cost1, 2);
              }
            }

            param.tech_garden_size = round(garden_size, 2);
            param.tech_cubic_yards = round(cubic_yards, 2);
            param.tech_cubic_ft = round(cubic_ft, 2);
            param.tech_cubic_meters = round(cubic_meters, 2);
            param.tech_liters = round(liters, 2);

            return param;   
          } else {
            param.error = 'Please! Check Your Input';
            return param;
          }
        }

        param.error = 'Invalid shape selected';
        return param;

      } catch (error) {
        console.error('Error in mulch calculation:', error);
        return { error: 'An error occurred during calculation' };
      }
    }


  async getCalculationSandCalculator(body) {
      let length = parseFloat(body.tech_length);
      let length_unit = body.tech_length_unit;
      let width = parseFloat(body.tech_width);
      let width_unit = body.tech_width_unit;
      let area = parseFloat(body.tech_area);
      let area_unit = body.tech_area_unit;
      let depth = parseFloat(body.tech_depth);
      let depth_unit = body.tech_depth_unit;
      let volume = parseFloat(body.tech_volume);
      let volume_unit = body.tech_volume_unit;
      let density = parseFloat(body.tech_density);
      let density_unit = body.tech_density_unit;
      let mass_price = parseFloat(body.tech_mass_price);
      let mass_price_unit = body.tech_mass_price_unit;
      let volume_price = parseFloat(body.tech_volume_price);
      let volume_price_unit = body.tech_volume_price_unit;
      const shape = body.tech_shape;
      let g = body.tech_g;
      let diameter = parseFloat(body.tech_diameter);
      let diameter_unit = body.tech_diameter_unit;
      let c_price = parseFloat(body.tech_c_price);
      const hiddencurrancy = body.tech_hiddencurrancy || '';

      let param = {};

      // Area unit conversions
      if (area_unit === 'mm²') {
          area_unit = 'mm2';
      } else if (area_unit === 'cm²') {
          area_unit = 'cm2';
      } else if (area_unit === 'm²') {
          area_unit = 'm2';
      } else if (area_unit === 'in²') {
          area_unit = 'in2';
      } else if (area_unit === 'ft²') {
          area_unit = 'ft2';
      } else if (area_unit === 'yd²') {
          area_unit = 'yd2';
      } else if (area_unit === 'hectares') {
          area_unit = 'ha';
      } else if (area_unit === 'acres') {
          area_unit = 'ac';
      } else if (area_unit === 'soccer fields') {
          area_unit = 'sf';
      }

      // Volume unit conversions
      if (volume_unit === 'mm³') {
          volume_unit = 'mm3';
      } else if (volume_unit === 'cm³') {
          volume_unit = 'cm3';
      } else if (volume_unit === 'm³') {
          volume_unit = 'm3';
      } else if (volume_unit === 'in³') {
          volume_unit = 'in3';
      } else if (volume_unit === 'ft³') {
          volume_unit = 'ft3';
      } else if (volume_unit === 'yd³') {
          volume_unit = 'yd3';
      }

      // Density unit conversions
      if (density_unit === 'kg/m³') {
          density_unit = 'kg_m3';
      } else if (density_unit === 't/m³') {
          density_unit = 't_m3';
      } else if (density_unit === 'g/cm³') {
          density_unit = 'g_cm3';
      } else if (density_unit === 'oz/in³') {
          density_unit = 'oz_in3';
      } else if (density_unit === 'lb/in³') {
          density_unit = 'lb_in3';
      } else if (density_unit === 'lb/ft³') {
          density_unit = 'lb_ft3';
      } else if (density_unit === 'lb/yd³') {
          density_unit = 'lb_yd3';
      }

      // Mass price unit conversions
      if (mass_price_unit === hiddencurrancy + 'µg') {
          mass_price_unit = 'ug';
      } else if (mass_price_unit === hiddencurrancy + 'mg') {
          mass_price_unit = 'mg';
      } else if (mass_price_unit === hiddencurrancy + 'g') {
          mass_price_unit = 'g';
      } else if (mass_price_unit === hiddencurrancy + 'kg') {
          mass_price_unit = 'kg';
      } else if (mass_price_unit === hiddencurrancy + 't') {
          mass_price_unit = 't';
      } else if (mass_price_unit === hiddencurrancy + 'lb') {
          mass_price_unit = 'lb';
      } else if (mass_price_unit === hiddencurrancy + 'stone') {
          mass_price_unit = 'stone';
      } else if (mass_price_unit === hiddencurrancy + 'US ton') {
          mass_price_unit = 'us_ton';
      } else if (mass_price_unit === hiddencurrancy + 'Long ton') {
          mass_price_unit = 'long_ton';
      }

      // Volume price unit conversions
      if (volume_price_unit === hiddencurrancy + 'mm³') {
          volume_price_unit = 'mm3';
      } else if (volume_price_unit === hiddencurrancy + 'cm³') {
          volume_price_unit = 'cm3';
      } else if (volume_price_unit === hiddencurrancy + 'm³') {
          volume_price_unit = 'm3';
      } else if (volume_price_unit === hiddencurrancy + 'in³') {
          volume_price_unit = 'in3';
      } else if (volume_price_unit === hiddencurrancy + 'ft³') {
          volume_price_unit = 'ft3';
      } else if (volume_price_unit === hiddencurrancy + 'yd³') {
          volume_price_unit = 'yd3';
      }

      // Rectangle Shape
      if (shape === '0') {
          // Method 1
          if (g === 'g1') {
              if (!isNaN(length) && !isNaN(width) && !isNaN(depth) && !isNaN(density)) {
                  // Conversion of length units in feet
                  if (length_unit === 'mm') {
                      length = length / 305;
                  }
                  if (length_unit === 'cm') {
                      length = length / 30.48;
                  }
                  if (length_unit === 'm') {
                      length = length * 3.281;
                  }
                  if (length_unit === 'in') {
                      length = length / 12;
                  }
                  if (length_unit === 'yd') {
                      length = length * 3;
                  }

                  // Conversion of width units in feet
                  if (width_unit === 'mm') {
                      width = width / 305;
                  }
                  if (width_unit === 'cm') {
                      width = width / 30.48;
                  }
                  if (width_unit === 'm') {
                      width = width * 3.281;
                  }
                  if (width_unit === 'in') {
                      width = width / 12;
                  }
                  if (width_unit === 'yd') {
                      width = width * 3;
                  }

                  // Conversion of depth units in feet
                  if (depth_unit === 'in') {
                      depth = depth / 12;
                  }
                  if (depth_unit === 'yd') {
                      depth = depth * 3;
                  }
                  if (depth_unit === 'cm') {
                      depth = depth / 30.48;
                  }
                  if (depth_unit === 'm') {
                      depth = depth * 3.281;
                  }

                  // Conversion of density units in pound/cubic feet
                  if (density_unit === 'kg_m3') {
                      density = density * 0.062428;
                  }
                  if (density_unit === 't_m3' || density_unit === 'g_cm3') {
                      density = density * 62.428;
                  }
                  if (density_unit === 'oz_in3') {
                      density = density * 108;
                  }
                  if (density_unit === 'lb_in3') {
                      density = density * 1728;
                  }
                  if (density_unit === 'lb_yd3') {
                      density = density * 0.037037;
                  }

                  // Calculation
                  area = length * width;
                  volume = area * depth;
                  let weight = volume * density;
                  weight = weight * 0.000453592;

                  // Conversion of volume units for display
                  const mm3 = volume * 28316847;
                  const cm3 = volume * 28316.85;
                  const m3 = volume * 0.02831685;
                  const in3 = volume * 1728;
                  const yd3 = volume * 0.037037;

                  // Conversion of weight units for display
                  const grams = weight * 1000000;
                  const kg = weight * 1000;
                  const oz = weight * 35273.96;
                  const lb = weight * 2204.623;
                  const stone = weight * 157.473;
                  const us_ton = weight * 1.102311;
                  const long_ton = weight * 0.984207;

                  param = {
                      tech_mm3: Math.round(mm3 * 100) / 100,
                      tech_cm3: Math.round(cm3 * 100) / 100,
                      tech_m3: Math.round(m3 * 100) / 100,
                      tech_in3: Math.round(in3 * 100) / 100,
                      tech_yd3: Math.round(yd3 * 100) / 100,
                      tech_g: Math.round(grams * 100) / 100,
                      tech_kg: Math.round(kg * 100) / 100,
                      tech_oz: Math.round(oz * 100) / 100,
                      tech_lb: Math.round(lb * 100) / 100,
                      tech_stone: Math.round(stone * 100) / 100,
                      tech_us_ton: Math.round(us_ton * 100) / 100,
                      tech_long_ton: Math.round(long_ton * 100) / 100,
                      tech_volume: Math.round(volume * 10000) / 10000,
                      tech_weight: Math.round(weight * 10000) / 10000,
                  };

                  if (!isNaN(mass_price) && mass_price > 0) {
                      let adjusted_mass_price = mass_price;
                      
                      if (mass_price_unit === 'ug') {
                          adjusted_mass_price = mass_price * 1000000000000;
                      }
                      if (mass_price_unit === 'mg') {
                          adjusted_mass_price = mass_price * 1000000000;
                      }
                      if (mass_price_unit === 'g') {
                          adjusted_mass_price = mass_price * 1000000;
                      }
                      if (mass_price_unit === 'dag') {
                          adjusted_mass_price = mass_price * 100000;
                      }
                      if (mass_price_unit === 'kg') {
                          adjusted_mass_price = mass_price * 1000;
                      }
                      if (mass_price_unit === 'gr') {
                          adjusted_mass_price = mass_price * 15432358.35;
                      }
                      if (mass_price_unit === 'dr') {
                          adjusted_mass_price = mass_price * 564383.39;
                      }
                      if (mass_price_unit === 'oz') {
                          adjusted_mass_price = mass_price * 35273.96;
                      }
                      if (mass_price_unit === 'lb') {
                          adjusted_mass_price = mass_price * 2204.62;
                      }
                      if (mass_price_unit === 'stone') {
                          adjusted_mass_price = mass_price * 157.47;
                      }
                      if (mass_price_unit === 'us_ton') {
                          adjusted_mass_price = mass_price * 1.10;
                      }
                      if (mass_price_unit === 'long_ton') {
                          adjusted_mass_price = mass_price / 0.98;
                      }

                      const cost = adjusted_mass_price * weight;
                      param.tech_cost = Math.round(cost * 100) / 100;
                  }

                  // Conversion of volume price units in feet
                  if (!isNaN(volume_price) && volume_price > 0) {
                      let adjusted_volume_price = volume_price;
                      
                      if (volume_price_unit === 'mm3') {
                          adjusted_volume_price = volume_price * 764554857.98;
                      }
                      if (volume_price_unit === 'cm3') {
                          adjusted_volume_price = volume_price * 764554.86;
                      }
                      if (volume_price_unit === 'm3') {
                          adjusted_volume_price = volume_price * 0.76;
                      }
                      if (volume_price_unit === 'in3') {
                          adjusted_volume_price = volume_price * 46656;
                      }
                      if (volume_price_unit === 'yd3') {
                          adjusted_volume_price = volume_price * 27;
                      }

                      const adjusted_weight = weight / 1.22;
                      const cost = adjusted_volume_price * adjusted_weight;
                      param.tech_cost = Math.round(cost * 100) / 100;
                  }

                  console.log(param);
                  return param;
              } else {
                  param.error = 'please check your inputs...';
                  return param;
              }
          }
          // Method 2
          else if (g === 'g2') {
              if (!isNaN(area) && !isNaN(depth) && !isNaN(density)) {
                  // Conversion of area units in square feet
                  if (area_unit === 'mm2') {
                      area = area * 0.0000107639;
                  }
                  if (area_unit === 'cm2') {
                      area = area * 0.00107639;
                  }
                  if (area_unit === 'm2') {
                      area = area * 10.7639;
                  }
                  if (area_unit === 'in2') {
                      area = area * 0.00694444;
                  }
                  if (area_unit === 'yd2') {
                      area = area * 9;
                  }
                  if (area_unit === 'ha') {
                      area = area * 107639;
                  }
                  if (area_unit === 'ac') {
                      area = area * 43560;
                  }
                  if (area_unit === 'sf') {
                      area = area * 76854.3;
                  }

                  // Conversion of depth units in feet
                  if (depth_unit === 'in') {
                      depth = depth / 12;
                  }
                  if (depth_unit === 'yd') {
                      depth = depth * 3;
                  }
                  if (depth_unit === 'cm') {
                      depth = depth / 30.48;
                  }
                  if (depth_unit === 'm') {
                      depth = depth * 3.281;
                  }

                  // Conversion of density units in pound/cubic feet
                  if (density_unit === 'kg_m3') {
                      density = density * 0.062428;
                  }
                  if (density_unit === 't_m3' || density_unit === 'g_cm3') {
                      density = density * 62.428;
                  }
                  if (density_unit === 'oz_in3') {
                      density = density * 108;
                  }
                  if (density_unit === 'lb_in3') {
                      density = density * 1728;
                  }
                  if (density_unit === 'lb_yd3') {
                      density = density * 0.037037;
                  }

                  // Calculation
                  volume = area * depth;
                  let weight = volume * density;
                  weight = weight * 0.000453592;

                  // Conversion of volume units for display
                  const mm3 = volume * 28316847;
                  const cm3 = volume * 28316.85;
                  const m3 = volume * 0.02831685;
                  const in3 = volume * 1728;
                  const yd3 = volume * 0.037037;

                  // Conversion of weight units for display
                  const grams = weight * 1000000;
                  const kg = weight * 1000;
                  const oz = weight * 35273.96;
                  const lb = weight * 2204.623;
                  const stone = weight * 157.473;
                  const us_ton = weight * 1.102311;
                  const long_ton = weight * 0.984207;

                  param = {
                      tech_mm3: Math.round(mm3 * 100) / 100,
                      tech_cm3: Math.round(cm3 * 100) / 100,
                      tech_m3: Math.round(m3 * 100) / 100,
                      tech_in3: Math.round(in3 * 100) / 100,
                      tech_yd3: Math.round(yd3 * 100) / 100,
                      tech_g: Math.round(grams * 100) / 100,
                      tech_kg: Math.round(kg * 100) / 100,
                      tech_oz: Math.round(oz * 100) / 100,
                      tech_lb: Math.round(lb * 100) / 100,
                      tech_stone: Math.round(stone * 100) / 100,
                      tech_us_ton: Math.round(us_ton * 100) / 100,
                      tech_long_ton: Math.round(long_ton * 100) / 100,
                      tech_volume: Math.round(volume * 10000) / 10000,
                      tech_weight: Math.round(weight * 10000) / 10000,
                  };

                  if (!isNaN(mass_price) && mass_price > 0) {
                      let adjusted_mass_price = mass_price;
                      
                      if (mass_price_unit === 'ug') {
                          adjusted_mass_price = mass_price * 1000000000000;
                      }
                      if (mass_price_unit === 'mg') {
                          adjusted_mass_price = mass_price * 1000000000;
                      }
                      if (mass_price_unit === 'g') {
                          adjusted_mass_price = mass_price * 1000000;
                      }
                      if (mass_price_unit === 'dag') {
                          adjusted_mass_price = mass_price * 100000;
                      }
                      if (mass_price_unit === 'kg') {
                          adjusted_mass_price = mass_price * 1000;
                      }
                      if (mass_price_unit === 'gr') {
                          adjusted_mass_price = mass_price * 15432358.35;
                      }
                      if (mass_price_unit === 'dr') {
                          adjusted_mass_price = mass_price * 564383.39;
                      }
                      if (mass_price_unit === 'oz') {
                          adjusted_mass_price = mass_price * 35273.96;
                      }
                      if (mass_price_unit === 'lb') {
                          adjusted_mass_price = mass_price * 2204.62;
                      }
                      if (mass_price_unit === 'stone') {
                          adjusted_mass_price = mass_price * 157.47;
                      }
                      if (mass_price_unit === 'us_ton') {
                          adjusted_mass_price = mass_price * 1.10;
                      }
                      if (mass_price_unit === 'long_ton') {
                          adjusted_mass_price = mass_price / 0.98;
                      }

                      const cost = adjusted_mass_price * weight;
                      param.tech_cost = Math.round(cost * 100) / 100;
                  }

                  // Conversion of volume price units in feet
                  if (!isNaN(volume_price) && volume_price > 0) {
                      let adjusted_volume_price = volume_price;
                      
                      if (volume_price_unit === 'mm3') {
                          adjusted_volume_price = volume_price * 764554857.98;
                      }
                      if (volume_price_unit === 'cm3') {
                          adjusted_volume_price = volume_price * 764554.86;
                      }
                      if (volume_price_unit === 'm3') {
                          adjusted_volume_price = volume_price * 0.76;
                      }
                      if (volume_price_unit === 'in3') {
                          adjusted_volume_price = volume_price * 46656;
                      }
                      if (volume_price_unit === 'yd3') {
                          adjusted_volume_price = volume_price * 27;
                      }

                      const adjusted_weight = weight / 1.22;
                      const cost = adjusted_volume_price * adjusted_weight;
                      param.tech_cost = Math.round(cost * 100) / 100;
                  }

                  console.log(param);
                  return param;
              } else {
                  param.error = 'please check your inputs...';
                  return param;
              }
          }
          // Method 3
          else {
              if (!isNaN(volume) && !isNaN(density)) {
                  // Conversion of volume units in cubic feet
                  if (volume_unit === 'mm3') {
                      volume = volume * 0.0000000353147;
                  }
                  if (volume_unit === 'cm3') {
                      volume = volume * 0.0000353147;
                  }
                  if (volume_unit === 'm3') {
                      volume = volume * 35.3147;
                  }
                  if (volume_unit === 'in3') {
                      volume = volume * 0.000578704;
                  }
                  if (volume_unit === 'yd3') {
                      volume = volume * 27;
                  }

                  // Conversion of density units in pound/cubic feet
                  if (density_unit === 'kg_m3') {
                      density = density * 0.062428;
                  }
                  if (density_unit === 't_m3' || density_unit === 'g_cm3') {
                      density = density * 62.428;
                  }
                  if (density_unit === 'oz_in3') {
                      density = density * 108;
                  }
                  if (density_unit === 'lb_in3') {
                      density = density * 1728;
                  }
                  if (density_unit === 'lb_yd3') {
                      density = density * 0.037037;
                  }

                  // Calculation
                  let weight = volume * density;
                  weight = weight * 0.000453592;

                  // Conversion of weight units for display
                  const grams = weight * 1000000;
                  const kg = weight * 1000;
                  const oz = weight * 35273.96;
                  const lb = weight * 2204.623;
                  const stone = weight * 157.473;
                  const us_ton = weight * 1.102311;
                  const long_ton = weight * 0.984207;

                  param = {
                      tech_: Math.round(grams * 100) / 100,
                      tech_kg: Math.round(kg * 100) / 100,
                      tech_oz: Math.round(oz * 100) / 100,
                      tech_lb: Math.round(lb * 100) / 100,
                      tech_stone: Math.round(stone * 100) / 100,
                      tech_us_ton: Math.round(us_ton * 100) / 100,
                      tech_long_ton: Math.round(long_ton * 100) / 100,
                      tech_weight: Math.round(weight * 10000) / 10000,
                  };

                  if (!isNaN(mass_price) && mass_price > 0) {
                      let adjusted_mass_price = mass_price;
                      
                      if (mass_price_unit === 'ug') {
                          adjusted_mass_price = mass_price * 1000000000000;
                      }
                      if (mass_price_unit === 'mg') {
                          adjusted_mass_price = mass_price * 1000000000;
                      }
                      if (mass_price_unit === 'g') {
                          adjusted_mass_price = mass_price * 1000000;
                      }
                      if (mass_price_unit === 'dag') {
                          adjusted_mass_price = mass_price * 100000;
                      }
                      if (mass_price_unit === 'kg') {
                          adjusted_mass_price = mass_price * 1000;
                      }
                      if (mass_price_unit === 'gr') {
                          adjusted_mass_price = mass_price * 15432358.35;
                      }
                      if (mass_price_unit === 'dr') {
                          adjusted_mass_price = mass_price * 564383.39;
                      }
                      if (mass_price_unit === 'oz') {
                          adjusted_mass_price = mass_price * 35273.96;
                      }
                      if (mass_price_unit === 'lb') {
                          adjusted_mass_price = mass_price * 2204.62;
                      }
                      if (mass_price_unit === 'stone') {
                          adjusted_mass_price = mass_price * 157.47;
                      }
                      if (mass_price_unit === 'us_ton') {
                          adjusted_mass_price = mass_price * 1.10;
                      }
                      if (mass_price_unit === 'long_ton') {
                          adjusted_mass_price = mass_price / 0.98;
                      }

                      const cost = adjusted_mass_price * weight;
                      param.tech_cost = Math.round(cost * 100) / 100;
                  }

                  // Conversion of volume in required units
                  if (!isNaN(volume_price) && volume_price > 0) {
                      let converted_volume = volume;
                      
                      if (volume_price_unit === 'mm3') {
                          converted_volume = volume * 28316847;
                      }
                      if (volume_price_unit === 'cm3') {
                          converted_volume = volume * 28316.85;
                      }
                      if (volume_price_unit === 'm3') {
                          converted_volume = volume * 0.02831685;
                      }
                      if (volume_price_unit === 'in3') {
                          converted_volume = volume * 1728;
                      }
                      if (volume_price_unit === 'yd3') {
                          converted_volume = volume * 0.037037;
                      }

                      const cost = volume_price * converted_volume;
                      param.tech_cost = Math.round(cost * 100) / 100;
                  }

                  console.log(param);
                  return param;
              } else {
                  param.error = 'please check your inputs...';
                  return param;
              }
          }
      }

      // Circle Shape
      if (shape === '1') {
          if (!isNaN(diameter) && !isNaN(depth)) {
              // Conversion of diameter units in feet
              if (diameter_unit === 'in') {
                  diameter = diameter / 12;
              }
              if (diameter_unit === 'yd') {
                  diameter = diameter * 3;
              }
              if (diameter_unit === 'cm') {
                  diameter = diameter / 30.48;
              }
              if (diameter_unit === 'm') {
                  diameter = diameter * 3.281;
              }

              // Conversion of depth units in feet
              if (depth_unit === 'in') {
                  depth = depth * 0.0833333;
              }
              if (depth_unit === 'yd') {
                  depth = depth * 3;
              }
              if (depth_unit === 'cm') {
                  depth = depth * 0.0328084;
              }
              if (depth_unit === 'm') {
                  depth = depth * 3.28084;
              }

              // Calculation
              const radius = diameter / 2;
              const circle_area = Math.PI * Math.pow(radius, 2);
              volume = circle_area * depth;
              let weight = volume * 100;
              weight = weight * 0.000453592;

              // Conversion of volume units for display
              const mm3 = volume * 28316847;
              const cm3 = volume * 28316.85;
              const m3 = volume * 0.02831685;
              const in3 = volume * 1728;
              const yd3 = volume * 0.037037;

              // Conversion of weight units for display
              const grams = weight * 1000000;
              const kg = weight * 1000;
              const oz = weight * 35274;
              const lb = weight * 2204.62;
              const stone = weight * 157.473;
              const us_ton = weight * 1.10231;
              const long_ton = weight * 0.984207;

              param = {
                  tech_mm3: Math.round(mm3 * 10000) / 10000,
                  tech_cm3: Math.round(cm3 * 10000) / 10000,
                  tech_m3: Math.round(m3 * 10000) / 10000,
                  tech_in3: Math.round(in3 * 10000) / 10000,
                  tech_yd3: Math.round(yd3 * 10000) / 10000,
                  tech_g: Math.round(grams * 100) / 100,
                  tech_kg: Math.round(kg * 100) / 100,
                  tech_oz: Math.round(oz * 100) / 100,
                  tech_lb: Math.round(lb * 100) / 100,
                  tech_stone: Math.round(stone * 100) / 100,
                  tech_us_ton: Math.round(us_ton * 100) / 100,
                  tech_long_ton: Math.round(long_ton * 100) / 100,
                  tech_volume: Math.round(volume * 10000) / 10000,
                  tech_weight: Math.round(weight * 10000) / 10000,
              };

              // Calculation of price unit
              if (!isNaN(c_price) && c_price > 0) {
                  const cost = c_price * weight;
                  param.tech_cost = Math.round(cost * 100) / 100;
              }
              return param;
          } else {
              param.error = 'please check your inputs...';
              return param;
          }
      }

      // If no valid shape
      param.error = 'Invalid shape value';
      return param;
  }



async getCalculationAsphaltCalculator(body) {
  try {
      const submit = body.tech_submit;
      const cal = body.tech_cal;
      const length = body.tech_length;
      const length_unit = body.tech_length_unit;
      const width = body.tech_width;
      const width_unit = body.tech_width_unit;
      const area = body.tech_area;
      const area_unit = body.tech_area_unit;
      const depth = body.tech_depth;
      const depth_unit = body.tech_depth_unit;
      const volume = body.tech_volume;
      const volume_unit = body.tech_volume_unit;
      const density = body.tech_density;
      const density_unit = body.tech_density_unit;
      const cs_depth = body.tech_cs_depth;
      const cs_depth_unit = body.tech_cs_depth_unit;
      const depth_dr = body.tech_depth_dr;
      const depth_dr_unit = body.tech_depth_dr_unit;
      const cost = body.tech_cost;
      const cost_unit = body.tech_cost_unit;

    let result = {};

    if (!submit) {
      return { error: "Please! Check Your Input" };
    }

    let l = parseFloat(length);
    let w = parseFloat(width);
    let a = parseFloat(area);
    let d = parseFloat(depth);
    let v = parseFloat(volume);
    let den = parseFloat(density);
    let csd = parseFloat(cs_depth);
    let ddr = parseFloat(depth_dr);
    let c = parseFloat(cost);

    // --- Length ---
    if (!isNaN(l)) {
      if (length_unit == "km") l = l / 0.001;
      else if (length_unit == "ft") l = l / 3.281;
      else if (length_unit == "yd") l = l / 1.0936;
      else if (length_unit == "mi") l = l / 0.0006214;
    }

    // --- Width ---
    if (!isNaN(w)) {
      if (width_unit == "km") w = w / 0.001;
      else if (width_unit == "ft") w = w / 3.281;
      else if (width_unit == "yd") w = w / 1.0936;
      else if (width_unit == "mi") w = w / 0.0006214;
    }

    // --- Area ---
    if (!isNaN(a)) {
      if (area_unit == "km2") a = a / 0.000001;
      else if (area_unit == "in2") a = a / 1550;
      else if (area_unit == "ft2") a = a / 10.764;
    }

    // --- Depth ---
    if (!isNaN(d)) {
      if (depth_unit == "mm") d = d / 10;
      else if (depth_unit == "m") d = d / 0.01;
      else if (depth_unit == "in") d = d / 0.3937;
      else if (depth_unit == "ft") d = d / 0.03281;
    }

    // --- Volume ---
    if (!isNaN(v)) {
      if (volume_unit == "cu_ft") v = v / 35.315;
      else if (volume_unit == "us_gal") v = v / 264.17;
      else if (volume_unit == "uk_gal") v = v / 219.97;
    }

    // --- Density ---
    if (!isNaN(den)) {
      if (density_unit == "lb_cu_ft") den = den / 0.06243;
    }

    // --- Compacted stone depth ---
    if (!isNaN(csd)) {
      if (cs_depth_unit == "mm")
       csd = csd / 25.4;
      else if (cs_depth_unit == "cm")
       csd = csd / 2.54;
      else if (cs_depth_unit == "m") 
      csd = csd / 0.0254;
      else if (cs_depth_unit == "ft") 
      csd = csd / 0.08333;
    }
      

    // --- Depth dirt removal ---
    if (!isNaN(ddr)) {
      if (depth_dr_unit == "mm") ddr = ddr / 25.4;
      else if (depth_dr_unit == "cm") ddr = ddr / 2.54;
      else if (depth_dr_unit == "m") ddr = ddr / 0.0254;
      else if (depth_dr_unit == "ft") ddr = ddr / 0.08333;
    }

    // --- Cost ---
    if (!isNaN(c)) {
      if (cost_unit == "kg") c = c * 1000;
      else if (cost_unit == "lb") c = c * 2204.62;
      else if (cost_unit == "us_ton") c = c * 1.10;
      else if (cost_unit == "long_ton") c = c * 0.98;
    }

    let asphalt, volumeCalc, kg, lb, us_ton, long_ton, total_cost;

    // -----------------------------
    // 🧮 Main Calculations
    // -----------------------------
    if (cal === "lwt" && !isNaN(l) && !isNaN(w) && !isNaN(d) && !isNaN(den)) {
      let areaCalc = l * w;
      volumeCalc = (areaCalc * d) / 100;
      asphalt = (volumeCalc * den) * 0.001;
      kg = asphalt * 1000;
      lb = asphalt * 2204.6;
      us_ton = asphalt * 1.1023;
      long_ton = asphalt * 0.9842;
      if (!isNaN(c)) total_cost = c * asphalt;
      result = { asphalt: +asphalt.toFixed(5), area: areaCalc, volume: volumeCalc, kg, lb, us_ton, long_ton, total_cost };

    } else if (cal === "at" && !isNaN(a) && !isNaN(d) && !isNaN(den)) {
      volumeCalc = (a * d) / 100;
      asphalt = (volumeCalc * den) * 0.001;
      kg = asphalt * 1000;
      lb = asphalt * 2204.6;
      us_ton = asphalt * 1.1023;
      long_ton = asphalt * 0.9842;
      if (!isNaN(c)) total_cost = c * asphalt;
      result = { asphalt: +asphalt.toFixed(5), volume: volumeCalc, kg, lb, us_ton, long_ton, total_cost };

    } else if (cal === "vad" && !isNaN(v) && !isNaN(den)) {
      asphalt = (v * den) * 0.001;
      kg = asphalt * 1000;
      lb = asphalt * 2204.6;
      us_ton = asphalt * 1.1023;
      long_ton = asphalt * 0.9842;
      if (!isNaN(c)) total_cost = c * asphalt;
      result = { asphalt: +asphalt.toFixed(5), kg, lb, us_ton, long_ton, total_cost };

    } else if (cal === "csn" && !isNaN(a) && !isNaN(d) && !isNaN(csd)) {
      volumeCalc = (a * d) / 100;
      asphalt = (volumeCalc * 2400) * 0.001;
      let areaFeet = a / 0.0929;
      let stone = (areaFeet * csd) / 180;
      console.log(csd)
      // console.log(areaFeet,csd,stone);
      kg = asphalt * 1000;
      lb = asphalt * 2204.6;
      us_ton = asphalt * 1.1023;
      long_ton = asphalt * 0.9842;
      if (!isNaN(c)) total_cost = c * asphalt;
      result = { asphalt: +asphalt.toFixed(5), stone: +stone.toFixed(5), kg, lb, us_ton, long_ton, total_cost };

    } else if (cal === "dtbr" && !isNaN(a) && !isNaN(d) && !isNaN(ddr)) {
      volumeCalc = (a * d) / 100;
      asphalt = (volumeCalc * den) * 0.001;
      console.log(volumeCalc,den,asphalt);
      let areaFeet = a / 0.0929;
      let dirt = (areaFeet * ddr) / 320;
      kg = asphalt * 1000;
      lb = asphalt * 2204.6;
      us_ton = asphalt * 1.1023;
      long_ton = asphalt * 0.9842;
      if (!isNaN(c)) total_cost = c * asphalt;
      result = { asphalt: +asphalt.toFixed(5), dirt: +dirt.toFixed(5), kg, lb, us_ton, long_ton, total_cost };

    } else {
      return { error: "Please! Check Your Input" };
    }

    return { status: "success", payload: { RESULT: 1, ...result } };

  } catch (err) {
    return { status: "error", message: err.message };
  }
}



  }

module.exports = new CalculatorsServices();

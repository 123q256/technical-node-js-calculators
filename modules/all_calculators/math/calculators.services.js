const { Op, col } = require("sequelize");
const db = require("../../models");
const HttpCodes = require("http-codes");
const { ApiError } = require("../../middlewares/ApiError");
const dayjs = require("dayjs");
const isoWeek = require("dayjs/plugin/isoWeek");
const dayOfYear = require("dayjs/plugin/dayOfYear");
const isLeapYear = require("dayjs/plugin/isLeapYear");

dayjs.extend(isoWeek);
dayjs.extend(dayOfYear);
dayjs.extend(isLeapYear);
const utc = require("dayjs/plugin/utc");
dayjs.extend(utc);
const localizedFormat = require("dayjs/plugin/localizedFormat");
dayjs.extend(localizedFormat);

const moment = require("moment");
const momenttimezone = require("moment-timezone");
const customParseFormat = require("dayjs/plugin/customParseFormat");
const duration = require("dayjs/plugin/duration");
dayjs.extend(customParseFormat);
dayjs.extend(duration);
const sprintf = require("sprintf-js").sprintf;
const isSameOrBefore = require("dayjs/plugin/isSameOrBefore");
dayjs.extend(isSameOrBefore);

const weekday = require("dayjs/plugin/weekday");
dayjs.extend(weekday);

const weekOfYear = require("dayjs/plugin/weekOfYear");
dayjs.extend(weekOfYear);

const advancedFormat = require("dayjs/plugin/advancedFormat");
dayjs.extend(advancedFormat);

require("moment-duration-format");

require("moment-precise-range-plugin");
const math = require("mathjs");
const momentBase = require("moment");
const axios = require("axios");
const qs = require("qs");
const { factorial } = require("mathjs"); // Ensure mathjs is installed
const { DateTime } = require("luxon"); // use luxon or native Date for date handling

class AgeCalculator {
  constructor() {
    this.age = 0;
  }

  calculateAge(timestamp) {
    const birthDate = new Date(timestamp);
    const today = new Date();

    let age = today.getFullYear() - birthDate.getFullYear();
    const monthDiff = today.getMonth() - birthDate.getMonth();
    const dayDiff = today.getDate() - birthDate.getDate();

    if (monthDiff < 0 || (monthDiff === 0 && dayDiff < 0)) {
      age--;
    }

    this.age = age;
  }

  getAge() {
    return this.age;
  }

  getRank(age) {
    return age + 1; // Example rank logic
  }
}

class CalculatorsServices {
  /** getCalculationScientificNotationCalculator
   * POST: /api/calculators-lol/scientific-notation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationScientificNotationCalculator(body) {
    let type = body.tech_type;
    let nbr1 = body.tech_nbr1;
    let pwr1 = body.tech_pwr1;
    let nbr2 = body.tech_nbr2;
    let pwr2 = body.tech_pwr2;
    let opr = body.tech_opr;
    let nbr = body.tech_nbr;
    let pwr = body.tech_pwr;
    let decimal = body.tech_decimal;
    let e = body.tech_e;

    let result = {};

    if (type === "calculator") {
      if (!isNaN(nbr1) && !isNaN(pwr1) && !isNaN(nbr2) && !isNaN(pwr2)) {
        let num1 = Number(`${nbr1}e${pwr1}`);
        let num2 = Number(`${nbr2}e${pwr2}`);
        let sol;

        if (opr === "+") sol = num1 + num2;
        else if (opr === "-") sol = num1 - num2;
        else if (opr === "*") sol = num1 * num2;
        else if (opr === "/") sol = num1 / num2;

        let e_ans = sol.toExponential(3);
        let [left, right] = sol.toExponential(3).toUpperCase().split("E");
        right = Math.abs(Number(right));

        let ee_ans = `${left[0]}${left[2]}${left[3]}${left[1]}${left[4]}`;
        let ee_p = right - 2;

        result = {
          tech_ans: sol,
          tech_left: left,
          tech_right: right,
          tech_e_ans: e_ans,
          tech_ee_ans: ee_ans,
          tech_ee_p: ee_p,
        };
      } else {
        result.error = "Please Check Your Input.";
      }
    } else {
      if (!isNaN(nbr) && !isNaN(pwr)) {
        let sol = Number(`${nbr}e${pwr}`);
        let e_ans = sol.toExponential(3);
        let [left, right] = sol.toExponential(3).toUpperCase().split("E");
        right = Math.abs(Number(right));

        let ee_ans = `${left[0]}${left[2]}${left[3]}${left[1]}${left[4]}`;
        let ee_p = right - 2;

        result = {
          tech_ans: sol,
          tech_left: left,
          tech_right: right,
          tech_e_ans: e_ans,
          tech_ee_ans: ee_ans,
          tech_ee_p: ee_p,
        };
      } else if (decimal && typeof decimal === "string") {
        let number = decimal
          .replace(/\s+/g, "")
          .replace(/\*/g, "x")
          .replace(/x10\^/, "e");

        let sol = parseFloat(number);

        if (!isNaN(sol) && sol !== 0) {
          let e_ans = sol.toExponential(3);
          let [left, right] = sol.toExponential(3).toUpperCase().split("E");
          right = Math.abs(Number(right));

          let ee_ans = `${left[0]}${left[2]}${left[3]}${left[1]}${left[4]}`;
          let ee_p = right - 2;

          result = {
            tech_ans: sol,
            tech_left: left,
            tech_right: right,
            tech_e_ans: e_ans,
            tech_ee_ans: ee_ans,
            tech_ee_p: ee_p,
          };
        } else {
          result.error =
            "Please! Enter numbers, scientific notation or E notation.\nScientific Notation: 1.35 x 10^3 \nE Notation: 1.35e3";
        }
      } else if (!isNaN(e)) {
        let sol = Number(e);
        let e_ans = sol.toExponential(3);
        let [left, right] = sol.toExponential(3).toUpperCase().split("E");
        right = Math.abs(Number(right));

        let ee_ans = `${left[0]}${left[2]}${left[3]}${left[1]}${left[4]}`;
        let ee_p = right - 2;

        result = {
          tech_ans: sol,
          tech_left: left,
          tech_right: right,
          tech_e_ans: e_ans,
          tech_ee_ans: ee_ans,
          tech_ee_p: ee_p,
        };
      } else {
        result.error = "Please Check Your Input.";
      }
    }

    return result;
  }

  /**
   * getCalculationPercentageCalculator: Service Method
   * POST: /api/calculators-lol/percentage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPercentageCalculator(body) {
    const result = {};

    // Check locale (assuming you have a way to get locale in your app)
    const locale = body.tech_locale || "en"; // default to 'en' if not provided

    if (locale == "id") {
      // Indonesian locale calculations
      const angka_1 = body.tech_angka_1;
      const angka_2 = body.tech_angka_2;
      const angka_3 = body.tech_angka_3;
      const angka_4 = body.tech_angka_4;
      const pembilang_1 = body.tech_pembilang_1;
      const penyebut_1 = body.tech_penyebut_1;
      const perubahan_1 = body.tech_perubahan_1;
      const perubahan_2 = body.tech_perubahan_2;
      const calc_type = body.tech_submit;

      let hasil_1, hasil_2, hasil_3, hasil_4;

      if (calc_type == "1") {
        if (!isNaN(angka_1) && !isNaN(angka_2)) {
          hasil_1 = (angka_1 / 100) * angka_2;
        } else {
          result.error = "Please! Fill both input fields.";
          return result;
        }
      } else if (calc_type == "2") {
        if (!isNaN(pembilang_1) && !isNaN(penyebut_1)) {
          hasil_2 = (pembilang_1 / penyebut_1) * 100;
        } else {
          result.error = "Please! Fill both input fields.";
          return result;
        }
      } else if (calc_type == "3") {
        if (!isNaN(angka_3) && !isNaN(angka_4)) {
          hasil_3 = (angka_3 / angka_4) * 100;
        } else {
          result.error = "Please! Fill both input fields.";
          return result;
        }
      } else if (calc_type == "4") {
        if (!isNaN(perubahan_1) && !isNaN(perubahan_2)) {
          hasil_4 = ((perubahan_2 - perubahan_1) / perubahan_1) * 100;
        } else {
          result.error = "Please! Fill both input fields.";
          return result;
        }
      }

      result.tech_hasil_1 = hasil_1;
      result.tech_hasil_2 = hasil_2;
      result.tech_hasil_3 = hasil_3;
      result.tech_hasil_4 = hasil_4;
      result.tech_disable = "zain";
      return result;
    } else {
      // English locale calculations
      const method = body.tech_method;
      const p = parseFloat(body.tech_p);
      const x = parseFloat(body.tech_x);

      if (method == "1") {
        if (!isNaN(p) && !isNaN(x)) {
          result.tech_ans = Math.round((p / 100) * x * 100) / 100;
          return result;
        } else {
          result.error = "Please! Check Your Input.";
          return result;
        }
      } else if (method == "2") {
        if (!isNaN(p) && !isNaN(x)) {
          result.tech_ans = Math.round((p / x) * 100 * 100) / 100 + "%";
          return result;
        } else {
          result.error = "Please! Check Your Input.";
          return result;
        }
      } else if (method == "3") {
        if (!isNaN(p) && !isNaN(x)) {
          result.tech_ans = Math.round((p / (x / 100)) * 100) / 100;
          return result;
        } else {
          result.error = "Please! Check Your Input.";
          return result;
        }
      } else if (method == "4") {
        if (!isNaN(x) && !isNaN(p)) {
          result.tech_ans = Math.round((x / p) * 100 * 100) / 100 + "%";
          return result;
        } else {
          result.error = "Please! Check Your Input.";
          return result;
        }
      } else if (method == "5") {
        if (!isNaN(p) && !isNaN(x)) {
          result.tech_ans = Math.round((x / (p / 100)) * 100) / 100;
          return result;
        } else {
          result.error = "Please! Check Your Input.";
          return result;
        }
      } else if (method == "6") {
        if (!isNaN(p) && !isNaN(x)) {
          result.tech_ans = Math.round((p / 100) * x * 100) / 100;
          return result;
        } else {
          result.error = "Please! Check Your Input.";
          return result;
        }
      } else if (method == "7") {
        if (!isNaN(p) && !isNaN(x)) {
          result.tech_ans = Math.round((p / (x / 100)) * 100) / 100;
          return result;
        } else {
          result.error = "Please! Check Your Input.";
          return result;
        }
      } else if (method == "8") {
        if (!isNaN(p) && !isNaN(x)) {
          result.tech_ans = Math.round((x / 100) * p * 100) / 100;
          return result;
        } else {
          result.error = "Please! Check Your Input.";
          return result;
        }
      } else if (method == "9") {
        if (!isNaN(x) && !isNaN(p)) {
          result.tech_ans = Math.round((p / x) * 100 * 100) / 100 + "%";
          return result;
        } else {
          result.error = "Please! Check Your Input.";
          return result;
        }
      } else if (method == "10") {
        if (!isNaN(p) && !isNaN(x)) {
          result.tech_ans = Math.round(p * (1 + x / 100) * 100) / 100;
          return result;
        } else {
          result.error = "Please! Check Your Input.";
          return result;
        }
      } else if (method == "11") {
        if (!isNaN(p) && !isNaN(x)) {
          result.tech_ans = Math.round((x / p - 1) * 100 * 100) / 100 + "%";
          return result;
        } else {
          result.error = "Please! Check Your Input.";
          return result;
        }
      } else if (method == "12") {
        if (!isNaN(p) && !isNaN(x)) {
          result.tech_ans = Math.round((x / (1 + p / 100)) * 100) / 100;
          return result;
        } else {
          result.error = "Please! Check Your Input.";
          return result;
        }
      } else if (method == "13") {
        if (!isNaN(p) && !isNaN(x)) {
          result.tech_ans = Math.round(p * (1 - x / 100) * 100) / 100;
          return result;
        } else {
          result.error = "Please! Check Your Input.";
          return result;
        }
      } else if (method == "14") {
        if (!isNaN(p) && !isNaN(x)) {
          result.tech_ans = Math.round((1 - x / p) * 100 * 100) / 100 + "%";
          return result;
        } else {
          result.error = "Please! Check Your Input.";
          return result;
        }
      } else if (method == "15") {
        if (!isNaN(p) && !isNaN(x)) {
          result.tech_ans = Math.round((x / (1 - p / 100)) * 100) / 100;
          return result;
        } else {
          result.error = "Please! Check Your Input.";
          return result;
        }
      }
    }

    return result;
  }

  /**
   * getCalculationFractionCalculator: Service Method
   * POST: /api/calculators-lol/fraction-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationFractionCalculator(body) {
    const param = {};
    const request = body;
    const calculate_type = request.tech_calculate_type;

    // Helper Functions
    function gcd(a, b) {
      a = Math.abs(a);
      b = Math.abs(b);

      if (a < b) {
        [a, b] = [b, a];
      }
      if (b === 0) {
        return 1;
      }
      let r = a % b;
      while (r > 0) {
        a = b;
        b = r;
        r = a % b;
      }
      return b;
    }

    function lcmofn(numbers, n) {
      let ans = numbers[0];
      for (let i = 1; i < n; i++) {
        ans = (numbers[i] * ans) / gcd(numbers[i], ans);
      }
      return ans;
    }

    function reduce(num, den) {
      const g = gcd(num, den);
      return [num / g, den / g];
    }

    if (calculate_type == "fraction_type") {
      const fraction_types = request.tech_fraction_types;
      let a1 = request.tech_a1;
      let b1 = request.tech_b1;
      let N1 = request.tech_N1;
      let N2 = request.tech_N2;
      let N3 = request.tech_N3;
      let N4 = request.tech_N4;
      let D1 = request.tech_D1;
      let D2 = request.tech_D2;
      let D3 = request.tech_D3;
      let D4 = request.tech_D4;
      const action = request.tech_action;
      const action1 = request.tech_action1;
      const action2 = request.tech_action2;

      if (fraction_types == "simple_frac") {
        if (D1 == 0 || D2 == 0) {
          param.error = "Denominator can not be 0.";
          return param;
        }
        if (!isNaN(N1) && !isNaN(D1) && !isNaN(N2) && !isNaN(D2)) {
          if (N1 == 0 || N2 == 0) {
            param.error = "Please provide none zero numbers.";
            return param;
          }
          if (D1 == 0 || D2 == 0) {
            param.error = "Denominator can not be 0";
            return param;
          }

          let totalN, totalD;
          if (action == "+") {
            totalN = N1 * D2 + N2 * D1;
            totalD = D1 * D2;
          } else if (action == "-") {
            totalN = N1 * D2 - N2 * D1;
            totalD = D1 * D2;
          } else if (action == "÷") {
            totalN = N1 * D2;
            totalD = N2 * D1;
          } else if (action == "×" || action == "of") {
            totalN = N1 * N2;
            totalD = D1 * D2;
          } else if (action == "^") {
            totalN = Math.pow(N1, N2 / D2);
            totalD = Math.pow(D1, N2 / D2);
          }

          const g = gcd(totalN, totalD);
          const [upr, btm] = reduce(totalN, totalD);
          const lcd = lcmofn([D1, D2], 2);

          param.tech_lcd = lcd;
          param.tech_upr = upr;
          param.tech_btm = btm;
          param.tech_totalN = totalN;
          param.tech_totalD = totalD;
          param.tech_g = g;
          return param;
        } else {
          param.error = "Please! Enter valid Input.";
          return param;
        }
      } else if (fraction_types == "three_frac") {
        if (D1 == 0 || D2 == 0 || D3 == 0) {
          param.error = "Denominator can not be 0.";
          return param;
        }
        if (
          !isNaN(N1) &&
          !isNaN(D1) &&
          !isNaN(N2) &&
          !isNaN(D2) &&
          !isNaN(N3) &&
          !isNaN(D3) &&
          D1 !== 0 &&
          D2 !== 0 &&
          D3 !== 0
        ) {
          if (N1 == 0 || N2 == 0 || N3 == 0) {
            param.error = "Please provide none zero numbers.";
            return param;
          }
          if (D1 == 0 || D2 == 0 || D3 == 0) {
            param.error = "Denominator can not be 0";
            return param;
          }

          let totalN, totalD;
          if (
            (action == "+" || action == "-") &&
            (action1 == "+" || action1 == "-")
          ) {
            const arr = [D1, D2, D3];
            const lcm = lcmofn(arr, 3);
            let first =
              action == "+"
                ? N1 * (lcm / D1) + N2 * (lcm / D2)
                : N1 * (lcm / D1) - N2 * (lcm / D2);
            let second =
              action1 == "+"
                ? first + N3 * (lcm / D3)
                : first - N3 * (lcm / D3);
            totalN = second;
            totalD = lcm;
          } else if (
            (action == "÷" || action == "×") &&
            (action1 == "÷" || action1 == "×")
          ) {
            if (action == "÷") {
              [N2, D2] = [D2, N2];
            }
            if (action1 == "÷") {
              [N3, D3] = [D3, N3];
            }
            totalN = N1 * N2 * N3;
            totalD = D1 * D2 * D3;
          } else if (
            (action == "÷" || action == "×") &&
            (action1 == "+" || action1 == "-")
          ) {
            if (action == "÷") {
              [N2, D2] = [D2, N2];
            }
            N2 = N1 * N2;
            D2 = D1 * D2;
            if (action1 == "+") {
              totalN = N2 * D3 + N3 * D2;
              totalD = D2 * D3;
            } else if (action1 == "-") {
              totalN = N2 * D3 - N3 * D2;
              totalD = D2 * D3;
            }
          } else if (
            (action1 == "÷" || action1 == "×") &&
            (action == "+" || action == "-")
          ) {
            if (action1 == "÷") {
              [N3, D3] = [D3, N3];
            }
            N2 = N3 * N2;
            D2 = D3 * D2;
            if (action == "+") {
              totalN = N2 * D1 + N1 * D2;
              totalD = D2 * D1;
            } else if (action == "-") {
              totalN = N2 * D1 - N1 * D2;
              totalD = D2 * D1;
            }
          }

          const g = gcd(totalN, totalD);
          const [upr, btm] = reduce(totalN, totalD);
          const lcd = lcmofn([D1, D2, D3], 3);

          param.tech_lcd = lcd;
          param.tech_upr = upr;
          param.tech_btm = btm;
          param.tech_totalN = totalN;
          param.tech_totalD = totalD;
          param.tech_g = g;
          return param;
        } else {
          param.error = "Please! Enter valid Input.";
          return param;
        }
      } else if (fraction_types == "four_frac") {
        if (D1 == 0 || D2 == 0 || D3 == 0 || D4 == 0) {
          param.error = "Denominator can not be 0.";
          return param;
        }
        if (
          !isNaN(N1) &&
          !isNaN(D1) &&
          !isNaN(N2) &&
          !isNaN(D2) &&
          !isNaN(N3) &&
          !isNaN(D3) &&
          !isNaN(N4) &&
          !isNaN(D4) &&
          D1 !== 0 &&
          D2 !== 0 &&
          D3 !== 0 &&
          D4 !== 0
        ) {
          if (N1 == 0 || N2 == 0 || N3 == 0 || N4 == 0) {
            param.error = "Please provide none zero numbers.";
            return param;
          }
          if (D1 == 0 || D2 == 0 || D3 == 0 || D4 == 0) {
            param.error = "Denominator can not be 0";
            return param;
          }

          let totalN, totalD;
          if (
            (action == "+" || action == "-") &&
            (action1 == "+" || action1 == "-") &&
            (action2 == "+" || action2 == "-")
          ) {
            const arr = [D1, D2, D3, D4];
            const lcm = lcmofn(arr, 4);
            let first =
              action == "+"
                ? N1 * (lcm / D1) + N2 * (lcm / D2)
                : N1 * (lcm / D1) - N2 * (lcm / D2);
            let second =
              action1 == "+"
                ? first + N3 * (lcm / D3)
                : first - N3 * (lcm / D3);
            let third =
              action2 == "+"
                ? second + N4 * (lcm / D4)
                : second - N4 * (lcm / D4);
            totalN = third;
            totalD = lcm;
          } else if (
            (action == "÷" || action == "×") &&
            (action1 == "÷" || action1 == "×") &&
            (action2 == "÷" || action2 == "×")
          ) {
            if (action === "÷") {
              [N2, D2] = [D2, N2];
            }
            if (action1 === "÷") {
              [N3, D3] = [D3, N3];
            }
            if (action2 === "÷") {
              [N4, D4] = [D4, N4];
            }
            totalN = N1 * N2 * N3 * N4;
            totalD = D1 * D2 * D3 * D4;
          } else if (
            (action == "÷" || action == "×") &&
            (action1 == "+" || action1 == "-") &&
            (action2 == "+" || action2 == "-")
          ) {
            if (action == "÷") {
              [N2, D2] = [D2, N2];
            }
            N2 = N1 * N2;
            D2 = D1 * D2;
            if (action1 == "+") {
              N3 = N2 * D3 + N3 * D2;
              D3 = D2 * D3;
            } else if (action1 == "-") {
              N3 = N2 * D3 - N3 * D2;
              D3 = D2 * D3;
            }
            if (action2 == "+") {
              totalN = N3 * D4 + N4 * D3;
              totalD = D3 * D4;
            } else if (action2 == "-") {
              totalN = N3 * D4 - N4 * D3;
              totalD = D3 * D4;
            }
          } else if (
            (action == "+" || action == "-") &&
            (action1 == "÷" || action1 == "×") &&
            (action2 == "+" || action2 == "-")
          ) {
            if (action1 == "÷") {
              [N3, D3] = [D3, N3];
            }
            N3 = N3 * N2;
            D3 = D3 * D2;
            if (action == "+") {
              N3 = N1 * D3 + N3 * D1;
              D3 = D3 * D1;
            } else if (action == "-") {
              N3 = N1 * D3 - N3 * D1;
              D3 = D3 * D1;
            }
            if (action2 == "+") {
              totalN = N3 * D4 + N4 * D3;
              totalD = D3 * D4;
            } else if (action2 == "-") {
              totalN = N3 * D4 - N4 * D3;
              totalD = D3 * D4;
            }
          } else if (
            (action == "+" || action == "-") &&
            (action1 == "+" || action1 == "-") &&
            (action2 == "÷" || action2 == "×")
          ) {
            if (action2 == "÷") {
              [N4, D4] = [D4, N4];
            }
            N3 = N3 * N4;
            D3 = D3 * D4;
            if (action == "+") {
              N2 = N1 * D2 + N2 * D1;
              D2 = D1 * D2;
            } else if (action == "-") {
              N2 = N1 * D2 - N2 * D1;
              D2 = D1 * D2;
            }
            if (action1 == "+") {
              totalN = N2 * D3 + N3 * D2;
              totalD = D2 * D3;
            } else if (action1 == "-") {
              totalN = N2 * D3 - N3 * D2;
              totalD = D2 * D3;
            }
          } else if (
            (action == "÷" || action == "×") &&
            (action1 == "÷" || action1 == "×") &&
            (action2 == "+" || action2 == "-")
          ) {
            if (action1 == "÷") {
              [N3, D3] = [D3, N3];
            }
            N2 = N2 * N3;
            D2 = D2 * D3;
            if (action == "÷") {
              [N2, D2] = [D2, N2];
            }
            N1 = N1 * N2;
            D1 = D1 * D2;
            if (action2 == "+") {
              totalN = N1 * D4 + N4 * D1;
              totalD = D1 * D4;
            } else if (action2 == "-") {
              totalN = N1 * D4 - N4 * D1;
              totalD = D1 * D4;
            }
          } else if (
            (action == "÷" || action == "×") &&
            (action1 == "+" || action1 == "-") &&
            (action2 == "÷" || action2 == "×")
          ) {
            if (action == "÷") {
              [N2, D2] = [D2, N2];
            }
            N2 = N1 * N2;
            D2 = D1 * D2;
            if (action2 == "÷") {
              [N4, D4] = [D4, N4];
            }
            N3 = N3 * N4;
            D3 = D3 * D4;
            if (action1 == "+") {
              totalN = N2 * D3 + N3 * D2;
              totalD = D2 * D3;
            } else if (action1 == "-") {
              totalN = N2 * D3 - N3 * D2;
              totalD = D2 * D3;
            }
          } else if (
            (action == "+" || action == "-") &&
            (action1 == "÷" || action1 == "×") &&
            (action2 == "÷" || action2 == "×")
          ) {
            if (action1 == "÷") {
              [N3, D3] = [D3, N3];
            }
            if (action2 == "÷") {
              [N4, D4] = [D4, N4];
            }
            N3 = N3 * N4;
            D3 = D3 * D4;
            N2 = N2 * N3;
            D2 = D2 * D3;
            if (action == "+") {
              totalN = N1 * D2 + N2 * D1;
              totalD = D1 * D2;
            } else if (action == "-") {
              totalN = N1 * D2 - N2 * D1;
              totalD = D1 * D2;
            }
          }

          const g = gcd(totalN, totalD);
          const [upr, btm] = reduce(totalN, totalD);
          const lcd = lcmofn([D1, D2, D3, D4], 4);

          param.tech_lcd = lcd;
          param.tech_upr = upr;
          param.tech_btm = btm;
          param.tech_totalN = totalN;
          param.tech_totalD = totalD;
          param.tech_g = g;
          return param;
        } else {
          param.error = "Please! Enter valid Input.";
          return param;
        }
      } else {
        if (parseFloat(request.tech_du1) == 0) {
          param.error = "Denominator can not be 0.";
          return param;
        }
        if (!isNaN(request.tech_neo2) && !isNaN(request.tech_du1)) {
          let totalN = parseFloat(request.tech_neo2);
          let totalD = parseFloat(request.tech_du1);
          if (!isNaN(request.tech_ne1)) {
            const val1 = parseFloat(request.tech_ne1);
            if (val1 < 0 && totalN > 0) {
              totalN = totalN * -1;
            }
            totalN = totalD * val1 + totalN;
          }

          const g = gcd(totalN, totalD);
          const [upr, btm] = reduce(totalN, totalD);
          param.tech_upr = upr;
          param.tech_totalN = totalN;
          param.tech_totalD = totalD;
          param.tech_g = g;
          param.tech_btm = btm;
          return param;
        }
      }
    } else {
      if (
        !isNaN(request.tech_nu1) &&
        !isNaN(request.tech_de1) &&
        !isNaN(request.tech_nu2) &&
        !isNaN(request.tech_de2)
      ) {
        let N1 = parseFloat(request.tech_nu1);
        let D1 = parseFloat(request.tech_de1);
        let N2 = parseFloat(request.tech_nu2);
        let D2 = parseFloat(request.tech_de2);

        if (D1 == 0 || D2 == 0) {
          param.error = "Denominator can not be 0";
          return param;
        }

        if (!isNaN(request.tech_s1)) {
          const val1 = parseFloat(request.tech_s1);
          if (val1 < 0 && N1 > 0) {
            N1 = N1 * -1;
          }
          N1 = D1 * val1 + N1;
        }
        if (!isNaN(request.tech_s2)) {
          const val2 = parseFloat(request.tech_s2);
          if (val2 < 0 && N2 > 0) {
            N2 = N2 * -1;
          }
          N2 = D2 * val2 + N2;
        }

        const action = request.tech_actions;
        let totalN, totalD;

        if (action == "+") {
          totalN = N1 * D2 + N2 * D1;
          totalD = D1 * D2;
        } else if (action == "-") {
          totalN = N1 * D2 - N2 * D1;
          totalD = D1 * D2;
        } else if (action == "÷") {
          totalN = N1 * D2;
          totalD = N2 * D1;
        } else if (action == "×") {
          totalN = N1 * N2;
          totalD = D1 * D2;
        }

        const g = gcd(totalN, totalD);
        const [upr, btm] = reduce(totalN, totalD);
        const lcd = lcmofn([D1, D2], 2);

        param.tech_upr = upr;
        param.tech_N1 = N1;
        param.tech_N2 = N2;
        param.tech_D1 = D1;
        param.tech_D2 = D2;
        param.tech_totalN = totalN;
        param.tech_totalD = totalD;
        param.tech_g = g;
        param.tech_btm = btm;
        param.tech_lcd = lcd;
        return param;
      } else {
        param.error = "Please fill all fields.";
        return param;
      }
    }
  }

  /**
   * getCalculationIntegralCalculator: Service Method
   * POST: /api/calculators-lol/integral-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationIntegralCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let ub = body.tech_ub;
    let lb = body.tech_lb;
    let form = body.tech_form;
    let wrt = body.tech_with;

    const param = {};

    // Input validation
    if (!EnterEq) {
      param.error = "Please! Check Your Input.";
      return param;
    }

    // Regex validation
    const invalidPattern = /[<>&]/i;
    if (invalidPattern.test(EnterEq)) {
      param.error = "Please! Check Your Input.";
      return param;
    }

    // Additional security validation
    const securityPattern = /\<|\>|\&|php|print_r|print|echo|script|=|&|%/i;
    if (securityPattern.test(EnterEq)) {
      param.error = "Please! Check Your Input.";
      return param;
    }

    // Check for definite integral bounds
    if (form === "def") {
      if (!ub || !lb) {
        param.error = "Please! Check Your Input.";
        return param;
      }
    }

    // Process equation
    let parem = EnterEq;
    parem = parem.replace(/ /g, "");
    parem = parem.replace(/\+/g, "plus");
    parem = parem.replace(/{/g, "(");
    parem = parem.replace(/}/g, ")");
    parem = parem.replace(/e\^/g, "exp");
    parem = parem.replace(/exp\^/g, "exp");
    parem = parem.replace(/\^/g, "**");
    parem = parem.replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    const parem1 = wrt ? wrt.trim() : "";

    try {
      const axios = require("axios");
      let formData;

      if (form === "def") {
        const ubProcessed = ub.replace(/\+/g, "plus");
        const lbProcessed = lb.replace(/\+/g, "plus");

        formData = {
          equ: parem,
          wrt: parem1,
          ub: ubProcessed,
          lb: lbProcessed,
        };
      } else {
        formData = {
          equ: parem,
          wrt: parem1,
        };
      }

      const response = await axios.post(
        "http://167.172.134.148/new-integral",
        formData,
        {
          timeout: 120000,
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
          },
        }
      );

      const buffer = response.data;

      param.tech_buffer = buffer[0];
      param.tech_ans = buffer[1];
      param.tech_enter = buffer[2];
      if (form === "def") {
        param.tech_defi = buffer[3];
      }

      return param;
    } catch (error) {
      param.error = "Please! Check Your Input.";
      return param;
    }
  }

  /** getCalculationLimitCalculator
   * POST: /api/calculators-lol/limit-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLimitCalculator(body) {
    let enterEq = body.tech_EnterEq;
    let how = body.tech_how;
    let withRespectTo = body.tech_with;
    let dir = body.tech_dir;

    // Validate input
    if (!enterEq || /[<>&]|php|print_r|print|echo|script|=|%/i.test(enterEq)) {
      return { error: "Please! Check Your Input." };
    }

    if (!withRespectTo || !dir) {
      return { error: "Please! Check Your Input." };
    }

    // Clean expression
    let parem = enterEq
      .replace(/ /g, "")
      .replace(/%20/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    let parem2;
    if (!isNaN(how)) {
      parem2 = how;
    } else if (/inf|pi|e|∞/i.test(how)) {
      parem2 = how.replace(/inf|∞/gi, "oo");
      how = parem2;
      if (parem2 === "e") {
        parem2 = 2.71828;
      }
    } else {
      return { error: "Please! Check Your Input." };
    }

    let parem1 = withRespectTo.trim();
    let parem3 = dir.trim().replace(/\+/g, "plus");

    let check2 = parem.split("/");
    let upr, btm;

    if (check2.length === 2) {
      upr = check2[0].replace(parem1, `(${parem2})`);
      btm = check2[1].replace(parem1, `(${parem2})`);
    }

    try {
      let postData = {
        equ: parem,
        wrt: parem1,
        lim: parem2,
        op: parem3,
      };

      if (check2.length === 2) {
        postData.upr = upr;
        postData.btm = btm;
      }

      const response = await axios.post(
        "http://167.172.134.148/new-limit",
        new URLSearchParams(postData),
        { timeout: 120000 }
      );

      const buffer = response.data;

      let result = {
        tech_ans: buffer[0],
        tech_inf: how,
        tech_with: withRespectTo,
        tech_how: how,
        tech_dir: dir,
        tech_enter: buffer[1],
        tech_put: buffer[1].replace(withRespectTo, `(${how})`),
      };

      if (check2.length === 2) {
        let uprVal = buffer[2];
        let btmVal = buffer[3];
        if (!isNaN(uprVal) && !isNaN(btmVal) && btmVal != 1) {
          result.tech_upr = uprVal;
          result.tech_btm = btmVal;
          result.tech_ser = buffer[4];
        }
      } else {
        result.tech_ser = buffer[2];
      }

      return result;
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationPrimeFactorizationCalculator
   * POST: /api/calculators-lol/prime-factorization-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPrimeFactorizationCalculator(body) {
    let from = body.tech_from;
    let num = body.tech_num;
    let response = {};

    if (!isNaN(num)) {
      let newnum = Number(num);

      if (newnum > 1000000) {
        response.error = "Number is too large.";
        return response;
      }

      if (from == 1) {
        let newtext = "";
        let csv = "";
        let chk = 2;
        let prime = 0;
        let original = newnum;

        while (chk * chk <= newnum) {
          if (newnum % chk === 0) {
            newtext += chk;
            csv += chk;
            newnum = newnum / chk;

            if (newnum != 1) {
              newtext += " × ";
              csv += " , ";
            }
          } else {
            chk++;
          }
        }

        if (newnum != 1) {
          newtext += newnum;
          csv += newnum;
        }

        if (newtext == "" + num) {
          newtext += " is a Prime number.";
          prime = 1;
        }

        if (prime != 1) {
          let number = num;
          let divid = newtext.split(" × ");
          let tree = `<tr><td class='py-2 text-center'>${number}</td><td class='py-2'>&nbsp;</td></tr>`;
          for (let i = 0; i < divid.length; i++) {
            let value = divid[i];
            if (value != number) {
              number = number / value;
              tree += `<tr><td class='py-2'>| </td><td class='py-2'>\\ </td></tr><tr><td class='py-2'>${number}</td><td class='py-2'>${value}</td></tr>`;
            }
          }
          response.tech_tree = tree;
        }

        response.tech_Factors = newtext;
        response.tech_csv = csv;
        response.tech_prime = prime;
        return response;
      } else if (from == 2) {
        let table = `<td class='py-2'><del class='text-danger'>1</del></td>`;
        let tr = 1;

        for (let i = 2; i <= num; i++) {
          let mm = 0;
          for (let j = 2; j <= i / 2; j++) {
            if (i % j == 0) {
              table += `<td class='py-2'><del class='text-danger'>${i}</del></td>`;
              mm++;
              break;
            }
          }
          if (mm == 0) {
            table += `<td class='py-2'>${i}</td>`;
          }
          if (tr % 10 == 0) {
            table += `</tr><tr>`;
          }
          tr++;
        }

        response.tech_table = table;
        return response;
      } else if (from == 3 || from == 4) {
        let list = "";
        let total = 0;

        for (let i = 2; i <= num; i++) {
          let mm = 0;
          for (let j = 2; j <= i / 2; j++) {
            if (i % j == 0) {
              mm++;
              break;
            }
          }
          if (mm == 0) {
            total++;
            list += `${i},   `;
          }
        }

        response.tech_list = list;
        response.tech_total = total;
        return response;
      } else if (from == 5) {
        function primeCheck(number) {
          if (number == 1) return 0;
          for (let i = 2; i <= number / 2; i++) {
            if (number % i == 0) return 0;
          }
          return 1;
        }

        let prime_check = primeCheck(num);
        response.tech_prime_check = prime_check;
        return response;
      } else if (from == 6) {
        let next, prev;
        let i = num;
        let check_n = 0;

        while (i < 10000000 && check_n != 1) {
          i++;
          let mm = 0;
          for (let j = 2; j <= i / 2; j++) {
            if (i % j == 0) {
              mm++;
              break;
            }
          }
          if (mm == 0) {
            next = i;
            check_n = 1;
          }
        }

        i = num;
        check_n = 0;
        while (i > 2 && check_n != 1) {
          i--;
          let mm = 0;
          for (let j = 2; j <= i / 2; j++) {
            if (i % j == 0) {
              mm++;
              break;
            }
          }
          if (mm == 0) {
            prev = i;
            check_n = 1;
          }
        }

        response.tech_next = next;
        response.tech_prev = prev;
        return response;
      }
    } else {
      response.error = "Please Check Your Input.";
      return response;
    }
  }

  /**
   * getCalculationPercentErrorCalculator: Service Method
   * POST: /api/calculators-lol/percent-error-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPercentErrorCalculator(body) {
    // Extract values from the body
    const actualValue = parseFloat(body.actualValue); // Renaming 'av' to 'actualValue'
    const originalValue = parseFloat(body.originalValue); // Renaming 'ov' to 'originalValue'

    // Initialize an object to hold the response
    let result = {};

    // Check if both values are valid numbers
    if (!isNaN(originalValue) && !isNaN(actualValue)) {
      // Calculate the percent error
      const percentError = ((originalValue - actualValue) / actualValue) * 100;
      console.log(percentError);
      // Round the result to two decimal places
      result.errorPercentage = percentError.toFixed(2); // Renaming 'own_error' to match the original logic
      result.status = 1;
    } else {
      // If either value is not a valid number, set an error message
      result.error = "Please Check Your Input.";
    }

    // Return the result object
    return result;
  }

  /** getCalculationModuloCalculator
   * POST: /api/calculators-lol/modulo-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationModuloCalculator(body) {
    let x = body.tech_x;
    let y = body.tech_y;
    let response = {};

    if (!isNaN(x) && !isNaN(y)) {
      let mod = x % y;
      response.tech_mod = mod;
      response.tech_agya = "chal thk a";
      return response;
    } else {
      response.error = "Please Check Your Input.";
      return response;
    }
  }

  /**
   * getCalculationCircumferenceCalculator: Service Method
   * POST: /api/calculators-lol/circumference-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCircumferenceCalculator(body) {
    // Helper function to check if value is numeric
    const isNumeric = (value) => {
      if (value == null || value == undefined || value == "") {
        return false;
      }
      return !isNaN(parseFloat(value)) && isFinite(value);
    };

    // Helper function to round numbers
    const round = (value, decimals) => {
      return Number(Math.round(value + "e" + decimals) + "e-" + decimals);
    };

    let radius = body.tech_radius;
    let diameter = body.tech_diameter;
    let circumference = body.tech_circumference;
    let area = body.tech_area;
    let s_area = body.tech_s_area;
    let vol = body.tech_vol;
    let unit_r = body.tech_unit_r;
    let unit_d = body.tech_unit_d;
    let unit_c = body.tech_unit_c;
    let unit_a = body.tech_unit_a;
    let unit_sa = body.tech_unit_sa;
    let unit_v = body.tech_unit_v;

    const param = {};

    // Check if at least one numeric value is provided
    if (
      !isNumeric(radius) &&
      !isNumeric(diameter) &&
      !isNumeric(circumference) &&
      !isNumeric(area) &&
      !isNumeric(s_area) &&
      !isNumeric(vol)
    ) {
      param.error = "Please enter any one value.";
      return param;
    }

    // Process Radius
    if (isNumeric(radius)) {
      if (!diameter && !circumference && !area && !s_area && !vol) {
        let Radius = parseFloat(radius);

        // Unit conversion for radius
        if (unit_r == "mm") Radius = Radius / 10;
        if (unit_r == "m") Radius = Radius * 100;
        if (unit_r == "ft") Radius = Radius * 30.48;
        if (unit_r == "in") Radius = Radius * 2.54;
        if (unit_r == "km") Radius = Radius * 100000;
        if (unit_r == "yd") Radius = Radius * 91.44;
        if (unit_r == "mi") Radius = Radius * 160934;

        const Diameter = 2 * Radius;
        const Circumference = 2 * 3.14159 * Radius;
        const Area = 3.14159 * Math.pow(Radius, 2);

        param.tech_Radius = round(Radius, 5);
        param.tech_Diameter = round(Diameter, 5);
        param.tech_Circumference = round(Circumference, 5);
        param.tech_Area = round(Area, 5);
        return param;
      } else {
        param.error = "You can enter only one value.";
        return param;
      }
    }

    // Process Diameter
    if (isNumeric(diameter)) {
      if (!radius && !circumference && !area && !s_area && !vol) {
        let Diameter = parseFloat(diameter);

        // Unit conversion for diameter
        if (unit_d == "mm") Diameter = Diameter / 10;
        if (unit_d == "m") Diameter = Diameter * 100;
        if (unit_d == "ft") Diameter = Diameter * 30.48;
        if (unit_d == "in") Diameter = Diameter * 2.54;
        if (unit_d == "km") Diameter = Diameter * 100000;
        if (unit_d == "yd") Diameter = Diameter * 91.44;
        if (unit_d == "mi") Diameter = Diameter * 160934;

        const Radius = Diameter / 2;
        const Circumference = 2 * 3.14159 * Radius;
        const Area = 3.14159 * Math.pow(Radius, 2);

        param.tech_Radius = round(Radius, 5);
        param.tech_Diameter = round(Diameter, 5);
        param.tech_Circumference = round(Circumference, 5);
        param.tech_Area = round(Area, 5);
        return param;
      } else {
        param.error = "You can enter only one value.";
        return param;
      }
    }

    // Process Circumference
    if (isNumeric(circumference)) {
      if (!radius && !diameter && !area && !s_area && !vol) {
        let Circumference = parseFloat(circumference);

        // Unit conversion for circumference
        if (unit_c == "mm") Circumference = Circumference / 10;
        if (unit_c == "m") Circumference = Circumference * 100;
        if (unit_c == "ft") Circumference = Circumference * 30.48;
        if (unit_c == "in") Circumference = Circumference * 2.54;
        if (unit_c == "km") Circumference = Circumference * 100000;
        if (unit_c == "yd") Circumference = Circumference * 91.44;
        if (unit_c == "mi") Circumference = Circumference * 160934;

        const Radius = Circumference / (2 * 3.14159);
        const Diameter = 2 * Radius;
        const Area = 3.14159 * Math.pow(Radius, 2);

        param.tech_Radius = round(Radius, 5);
        param.tech_Diameter = round(Diameter, 5);
        param.tech_Circumference = round(Circumference, 5);
        param.tech_Area = round(Area, 5);
        return param;
      } else {
        param.error = "You can enter only one value.";
        return param;
      }
    }

    // Process Area
    if (isNumeric(area)) {
      if (!radius && !diameter && !circumference && !s_area && !vol) {
        let Area = parseFloat(area);

        // Unit conversion for area
        if (unit_a == "mm²") Area = Area / 100;
        if (unit_a == "m²") Area = Area * 10000;
        if (unit_a == "ft²") Area = Area * 929.03;
        if (unit_a == "km²") Area = Area * 1e10;
        if (unit_a == "in²") Area = Area * 6.452;
        if (unit_a == "mi²") Area = Area * 2.59e10;
        if (unit_a == "yd²") Area = Area * 8361.27;

        const Radius = Math.sqrt(Area / 3.14159);
        const Diameter = 2 * Radius;
        const Circumference = 2 * 3.14159 * Radius;

        param.tech_Radius = round(Radius, 5);
        param.tech_Diameter = round(Diameter, 5);
        param.tech_Circumference = round(Circumference, 5);
        param.tech_Area = round(Area, 5);
        return param;
      } else {
        param.error = "You can enter only one value.";
        return param;
      }
    }

    // Process Surface Area
    if (isNumeric(s_area)) {
      if (!radius && !diameter && !circumference && !area && !vol) {
        let S_Area = parseFloat(s_area);

        // Unit conversion for surface area
        if (unit_sa == "mm²") S_Area = S_Area / 100;
        if (unit_sa == "m²") S_Area = S_Area * 10000;
        if (unit_sa == "ft²") S_Area = S_Area * 929.03;
        if (unit_sa == "km²") S_Area = S_Area * 1e10;
        if (unit_sa == "in²") S_Area = S_Area * 6.452;
        if (unit_sa == "mi²") S_Area = S_Area * 2.59e10;
        if (unit_sa == "yd²") S_Area = S_Area * 8361.27;

        const Radius = Math.sqrt(S_Area / (4 * 3.14159));

        param.tech_Radius = round(Radius, 5);
        return param;
      } else {
        param.error = "You can enter only one value.";
        return param;
      }
    }

    // Process Volume
    if (isNumeric(vol)) {
      if (!radius && !diameter && !circumference && !area && !s_area) {
        let Vol = parseFloat(vol);

        // Unit conversion for volume
        if (unit_v == "m³") Vol = Vol * 1e6;
        if (unit_v == "ft³") Vol = Vol * 28316.8;
        if (unit_v == "in³") Vol = Vol * 16.387;
        if (unit_v == "km³") Vol = Vol * 1000000000000000;
        if (unit_v == "yd³") Vol = Vol * 764555;
        if (unit_v == "mi³") Vol = Vol * 4168181818124979;

        const Radius = Math.pow((Vol * 3) / (4 * 3.14159), 1 / 3);

        param.tech_Radius = round(Radius, 5);
        return param;
      } else {
        param.error = "You can enter only one value.";
        return param;
      }
    }

    param.error = "Please enter any one value.";
    return param;
  }

  /** getCalculationMidpointCalculator
   * POST: /api/calculators-lol/midpoint-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMidpointCalculator(body) {
    let x1 = body.tech_x1;
    let x2 = body.tech_x2;
    let y1 = body.tech_y1;
    let y2 = body.tech_y2;

    let response = {};

    if (!isNaN(x1) && !isNaN(x2) && !isNaN(y1) && !isNaN(y2)) {
      let x = (Number(x1) + Number(x2)) / 2;
      let y = (Number(y1) + Number(y2)) / 2;
      let dis =
        Math.round(
          Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)) * 10000
        ) / 10000;

      response.tech_x = x;
      response.tech_y = y;
      response.tech_x1 = x1;
      response.tech_x2 = x2;
      response.tech_y1 = y1;
      response.tech_y2 = y2;
      response.tech_dis = dis;
      return response;
    } else {
      response.error = "Please Check Your Input.";
      return response;
    }
  }

  /** getCalculationSlopeCalculator
   * POST: /api/calculators-lol/slope-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationSlopeCalculator(body) {
    let type = body.tech_type;
    let x1 = body.tech_x1;
    let x2 = body.tech_x2;
    let y1 = body.tech_y1;
    let y2 = body.tech_y2;
    let dis = body.tech_dis;
    let m = body.tech_m;
    let angle = body.tech_angle;
    let x = body.tech_x;
    let y = body.tech_y;
    let b = body.tech_b;

    let result = {};

    x1 = parseFloat(x1);
    x2 = parseFloat(x2);
    y1 = parseFloat(y1);
    y2 = parseFloat(y2);
    dis = parseFloat(dis);
    m = m !== "" ? parseFloat(m) : "";
    angle = angle !== "" ? parseFloat(angle) : "";
    x = parseFloat(x);
    y = parseFloat(y);
    b = parseFloat(b);

    if (type === "2") {
      if (!isNaN(x1) && !isNaN(x2) && !isNaN(y1) && !isNaN(y2)) {
        x = x2 - x1;
        y = y2 - y1;
        let slope = +(y / x).toFixed(4);
        angle = +(Math.atan(slope) * (180 / Math.PI)).toFixed(4);
        let distance = +Math.sqrt(x * x + y * y).toFixed(4);
        b = +(y1 - slope * x1).toFixed(2);

        result = {
          tech_x: x,
          tech_y: y,
          tech_b: b,
          tech_slope: slope,
          tech_angle: angle + " deg",
          tech_distance: distance,
        };
      } else {
        result = { error: "Please fill all fields." };
      }
    } else if (type === "1") {
      if (!isNaN(x1) && !isNaN(y1) && !isNaN(dis)) {
        if (m === "" && angle === "")
          return { error: "Please fill all fields." };

        let slope;
        if (!isNaN(m)) {
          slope = m;
          let d = dis / Math.sqrt(1 + Math.pow(slope, 2));
          var x2r = +(x1 + d).toFixed(4);
          var y2r = +(y1 + slope * d).toFixed(4);
          var x2l = +(x1 - d).toFixed(4);
          var y2l = +(y1 - slope * d).toFixed(4);
          angle = +(Math.atan(slope) * (180 / Math.PI)).toFixed(4);
        } else {
          let a = (angle * Math.PI) / 180;
          slope = +Math.tan(a).toFixed(4);
          let d = dis / Math.sqrt(1 + Math.pow(slope, 2));
          var x2r = +(x1 + d).toFixed(4);
          var y2r = +(y1 + slope * d).toFixed(4);
          var x2l = +(x1 - d).toFixed(4);
          var y2l = +(y1 - slope * d).toFixed(4);
        }

        let xr = x2r - x1;
        let yr = y2r - y1;
        let xl = x2l - x1;
        let yl = y2l - y1;
        b = +(y1 - slope * x1).toFixed(2);

        result = {
          tech_xr: xr,
          tech_yr: yr,
          tech_xl: xl,
          tech_yl: yl,
          tech_x2r: x2r,
          tech_y2r: y2r,
          tech_x2l: x2l,
          tech_y2l: y2l,
          tech_b: b,
          tech_slope: slope,
          tech_angle: angle + " deg",
          tech_distance: dis,
        };
      } else {
        result = { error: "Please fill all fields." };
      }
    } else if (type === "3") {
      if (!isNaN(x1) && !isNaN(y1)) {
        if (m === "" && angle === "")
          return { error: "Please fill all fields." };
        if (x2 === "" && y2 === "") return { error: "Please fill all fields." };

        let slope;
        if (!isNaN(m)) {
          slope = m;
          angle = +(Math.atan(slope) * (180 / Math.PI)).toFixed(4);
        } else {
          let a = (angle * Math.PI) / 180;
          slope = +Math.tan(a).toFixed(4);
        }

        if (!isNaN(x2)) {
          x2 = parseFloat(x2);
          y2 = +(slope * (x2 - x1) + y1).toFixed(4);
        } else {
          y2 = parseFloat(y2);
          x2 = +((y2 - y1) / slope + x1).toFixed(4);
        }

        x = x2 - x1;
        y = y2 - y1;
        let distance = +Math.sqrt(x * x + y * y).toFixed(4);
        b = +(y1 - slope * x1).toFixed(2);

        result = {
          tech_x: x,
          tech_y: y,
          tech_x2: x2,
          tech_y2: y2,
          tech_b: b,
          tech_slope: slope,
          tech_angle: angle + " deg",
          tech_distance: distance,
        };
      } else {
        result = { error: "Please fill all fields." };
      }
    } else if (type === "4") {
      if (!isNaN(x1) && !isNaN(y1)) {
        if (m === "" && angle === "")
          return { error: "Please fill all fields." };

        let slope;
        if (!isNaN(m)) {
          slope = m;
          angle = +(Math.atan(slope) * (180 / Math.PI)).toFixed(4);
        } else {
          let a = (angle * Math.PI) / 180;
          slope = +Math.tan(a).toFixed(4);
        }

        b = +(y1 - slope * x1).toFixed(4);
        result = {
          tech_b: b,
          tech_slope: slope,
          tech_angle: angle + " deg",
        };
      } else {
        result = { error: "Please fill all fields." };
      }
    } else if (type === "line") {
      if (!isNaN(x) && !isNaN(y) && !isNaN(b)) {
        x = x * -1;
        y = y * -1;
        let slope = +(x / y).toFixed(4);
        angle = +(Math.atan(slope) * (180 / Math.PI)).toFixed(4);
        b = +(b / y).toFixed(2);

        result = {
          tech_b: b,
          tech_slope: slope,
          tech_angle: angle + " deg",
        };
      } else {
        result = { error: "Please fill all fields." };
      }
    }

    return result;
  }

  /** getCalculationLongAdditionCalculator
   * POST: /api/calculators-lol/long-addition-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationLongAdditionCalculator(body) {
    let x = body.tech_x;
    let result = {};

    if (x && typeof x === "string") {
      let array = x.split(",").map((item) => item.trim());
      let number = true;
      let numbers = "";

      for (let value of array) {
        if (isNaN(value)) {
          number = false;
          break;
        }
        numbers += value + ", ";
      }

      if (number) {
        let numericArray = array.map(Number);
        let sum = numericArray.reduce((acc, val) => acc + val, 0);
        let total_nbr = numericArray.length;
        sum = sum.toFixed(2);

        result.tech_sum = sum;
        result.tech_numbers = numbers.trim();
        result.tech_total_nbr = total_nbr;
        result.tech_max = Math.max(...numericArray);
        result.tech_min = Math.min(...numericArray);
      } else {
        result.error = "Please Enter Only Numbers.";
      }
    } else {
      result.error = "Please Check Your Input.";
    }

    return result;
  }

  /** getCalculationStandardFormCalculator
   * POST: /api/calculators-lol/standard-form-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationStandardFormCalculator(body) {
    let x = body.tech_x;
    let result = {};

    if (!x || typeof x !== "string") {
      result.error = "Please Check Your Input.";
      return result;
    }

    // Clean up characters
    x = x.replace(/−/g, "-").replace(/×/g, "*");

    // Check for forbidden patterns
    const forbiddenPattern =
      /<|>|&|php|print_r|print|echo|script|≥|𝑥|•|,|g|y|m|=|%/i;
    if (forbiddenPattern.test(x)) {
      result.error = "Please Check Your Input.";
      return result;
    }

    let number, real_num;

    if (!isNaN(x)) {
      number = parseFloat(x);
      real_num = 1;
    } else {
      let nbr = x
        .split(/x\s?10\^|x10\^|\*10\^|\* 10\^/i)
        .map((s) => s.trim())
        .filter(Boolean);

      if (nbr.length > 1) {
        number = parseFloat(nbr[0]) * Math.pow(10, parseFloat(nbr[1]));
        real_num = 0;
      } else {
        try {
          number = eval(x);
          real_num = 1;
        } catch (e) {
          result.error = "Please Check Your Input.";
          return result;
        }
      }
    }

    if (typeof number === "number" && !isNaN(number)) {
      let orderOfMagnitude = getOrderOfMagnitude(number);
      let e_ans = number.toExponential(3);
      let [left, right] = e_ans.toUpperCase().split("E");
      let ee_ans = `${left[0]}${left[2] ?? ""}${left[3] ?? ""}${left[1] ?? ""}${
        left[4] ?? ""
      }`;
      let ee_p = parseInt(right) - 2;

      result.tech_ans = `${left} ×10<sup>${right}</sup>`;
      result.tech_left = left;
      result.tech_right = right;
      result.tech_e_ans = e_ans;
      result.tech_ee_ans = ee_ans;
      result.tech_ee_p = ee_p;
      result.tech_number = number;
      result.tech_real_num = real_num;
    } else {
      result.error = "Please Check Your Input.";
    }

    return result;

    function getOrderOfMagnitude(value) {
      if (value === 0) return null;
      let abs = Math.abs(value);
      let power = 0;
      while (abs >= 10) {
        abs /= 10;
        power++;
      }
      while (abs < 0.1) {
        abs *= 10;
        power--;
      }
      return power;
    }
  }

  /** getCalculationAverageCalculator
   * POST: /api/calculators-lol/average-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationAverageCalculator(body) {
    let x = body.tech_x;
    let more = body.tech_more;
    let seprate = body.tech_seprate;

    let result = {};
    let check = true;

    if (!x || x.trim() === "") {
      check = false;
    }

    // Determine the separator
    if (more === "space") {
      seprate = " ";
    } else if (more === ",") {
      seprate = ",";
    }

    if (!seprate) {
      seprate = " ";
    }

    let numbers = x
      .split(seprate)
      .map((s) => s.trim())
      .filter((s) => s !== "");

    for (let value of numbers) {
      if (isNaN(value)) {
        check = false;
        break;
      }
    }

    if (check) {
      numbers = numbers.map(Number).sort((a, b) => a - b);
      let sum = numbers.reduce((a, b) => a + b, 0);
      let count = numbers.length;
      let average = +(sum / count).toFixed(4);

      // Median
      let median;
      if (count % 2 !== 0) {
        median = numbers[Math.floor(count / 2)];
      } else {
        let mid1 = numbers[count / 2 - 1];
        let mid2 = numbers[count / 2];
        median = (mid1 + mid2) / 2;
      }

      // Mode and table
      let freqMap = {};
      let table = "";
      for (let val of numbers) {
        freqMap[val] = (freqMap[val] || 0) + 1;
      }

      let maxFreq = Math.max(...Object.values(freqMap));
      let mode = Object.keys(freqMap).filter((key) => freqMap[key] === maxFreq);

      for (let key in freqMap) {
        table += `<tr><td class='py-2 border-b'>${key}</td><td class='py-2 border-b'>${
          freqMap[key]
        }</td><td class='py-2 border-b'>${key * freqMap[key]}</td></tr>`;
      }

      // Standard deviations
      let m = +(sum / count).toFixed(3);
      let d = 0;
      for (let value of numbers) {
        d += Math.pow(value - m, 2);
      }

      let s_d_p = +Math.sqrt(d / count).toFixed(4);
      let s_d_s = +Math.sqrt(d / (count - 1)).toFixed(4);

      result.tech_table = table;
      result.tech_mode = mode;
      result.tech_s_d_p = s_d_p;
      result.tech_s_d_s = s_d_s;
      result.tech_median = median;
      result.tech_average = average;
      result.tech_count = count;
      result.tech_d = d;
      result.tech_numbers = numbers;
    } else {
      result.error = "Please Check Your Input.";
    }

    return result;
  }

  /** getCalculationLogAndAntilogCalculator
   * POST: /api/calculators-lol/log-antilog-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationLogAndAntilogCalculator(body) {
    let method = body.tech_method;
    let x = body.tech_x;
    let y = body.tech_y;

    let result = {};
    let check = true;

    if (isNaN(x)) {
      check = false;
    }

    if (check) {
      x = parseFloat(x);
      let base;

      if (method === "log" || method === "ln") {
        if (!isNaN(y)) {
          base = parseFloat(y);
        } else if (y === "e") {
          base = 2.71828;
        } else {
          base = 2.71828;
        }

        let ans = +(Math.log(x) / Math.log(base)).toFixed(5);
        result.tech_ans = ans;
      } else if (method === "anti") {
        if (!isNaN(y)) {
          base = parseFloat(y);
        } else if (y === "e") {
          base = 2.71828;
        } else {
          base = 10;
        }

        let ans = +Math.pow(base, x).toFixed(5);
        result.tech_ans = ans;
      } else {
        result.error = "Invalid method.";
      }
    } else {
      result.error = "Please Check Your Input.";
    }

    return result;
  }

  /** getCalculationCentroidCalculator
   * POST: /api/calculators-lol/centroid-triangle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCentroidCalculator(body) {
    let shap = body.tech_shap;
    let x1 = parseFloat(body.tech_x1);
    let y1 = parseFloat(body.tech_y1);
    let x2 = parseFloat(body.tech_x2);
    let y2 = parseFloat(body.tech_y2);
    let x3 = parseFloat(body.tech_x3);
    let y3 = parseFloat(body.tech_y3);
    let total = parseInt(body.tech_total);

    let result = {};

    if (
      !isNaN(x1) &&
      !isNaN(y1) &&
      !isNaN(x2) &&
      !isNaN(y2) &&
      !isNaN(x3) &&
      !isNaN(y3)
    ) {
      if (shap === "3") {
        let x = +((x1 + x2 + x3) / 3).toFixed(3);
        let y = +((y1 + y2 + y3) / 3).toFixed(3);
        let ans = `${x} , ${y}`;

        result.tech_ans = ans;
        result.tech_x1 = x1;
        result.tech_x2 = x2;
        result.tech_x3 = x1 + x2 + x3;
        result.tech_y1 = y1;
        result.tech_y2 = y2;
        result.tech_y3 = y1 + y2 + y3;
        result.tech_n = 3;
      } else {
        if (!isNaN(total)) {
          let sumX = 0;
          let sumY = 0;
          let x1Expr = "";
          let x2Expr = "";
          let y1Expr = "";
          let y2Expr = "";

          for (let i = 1; i <= total; i++) {
            let xi = parseFloat(body[`tech_x${i}`]);
            let yi = parseFloat(body[`tech_y${i}`]);

            if (isNaN(xi) || isNaN(yi)) {
              result.error = "Please! Check Your Input.";
              return result;
            }

            sumX += xi;
            sumY += yi;

            x1Expr += i !== total ? `x_${i} + ` : `x_${i}`;
            x2Expr += i !== total ? `${xi} + ` : `${xi}`;
            y1Expr += i !== total ? `y_${i} + ` : `y_${i}`;
            y2Expr += i !== total ? `${yi} + ` : `${yi}`;
          }

          let centroidX = +(sumX / total).toFixed(3);
          let centroidY = +(sumY / total).toFixed(3);
          let ans = `${centroidX} , ${centroidY}`;

          result.tech_x1 = x1Expr;
          result.tech_x2 = x2Expr;
          result.tech_x3 = sumX;
          result.tech_y1 = y1Expr;
          result.tech_y2 = y2Expr;
          result.tech_y3 = sumY;
          result.tech_n = total;
          result.tech_ans = ans;
        } else {
          result.error = "Please! Check Your Input.";
        }
      }
    } else {
      result.error = "Please! Check Your Input.";
    }

    return result;
  }

  /** getCalculationQuadraticFormulaCalculator
   * POST: /api/calculators-lol/quadratic-formula-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationQuadraticFormulaCalculator(body) {
    let a = parseFloat(body.tech_a);
    let b = parseFloat(body.tech_b);
    let c = parseFloat(body.tech_c);
    let formula = body.tech_formula;
    let method = body.tech_method;
    let result = {};

    if (!isNaN(a) && !isNaN(b) && !isNaN(c)) {
      let A = a;
      let B, C;

      if (formula === "1") {
        B = b;
        C = c;
      } else if (formula === "2") {
        B = -2 * b * A;
        C = Math.pow(b, 2) * A + c;
      } else if (formula === "3") {
        B = (b + c) * A;
        C = b * c * A;
      }

      let firstx = +((B * -1) / (2 * A)).toFixed(3);
      let firstPart = Math.pow(firstx, 2) * A;
      let secondPart = B * firstx;

      let eq = `${firstPart}${secondPart < 0 ? " " : " + "}${secondPart}${
        C < 0 ? " " : " + "
      }${C}`;
      let yaxis = +eval(eq).toFixed(3);

      result.tech_vertex = `${A}(x ${
        firstx < 0 ? "+ " + -firstx : "- " + firstx
      } )^2 ${yaxis < 0 ? "- " + -yaxis : "+ " + yaxis}`;

      let x1, x2;

      if (method == 2) {
        let dis = Math.pow(B, 2) - 4 * A * C;
        result.tech_dis = dis;
        if (dis > 0) {
          x1 = +((-B + Math.sqrt(dis)) / (2 * A)).toFixed(4);
          x2 = +((-B - Math.sqrt(dis)) / (2 * A)).toFixed(4);
          result.tech_fact = `${A}(x ${x1 < 0 ? "+ " + -x1 : "- " + x1} )(x ${
            x2 < 0 ? "+ " + -x2 : "- " + x2
          } )`;
          result.tech_roots = `x₁ = ${x1} , x₂ = ${x2}`;
        } else if (dis < 0) {
          let real = +(-B / (2 * A)).toFixed(4);
          let imag = +(Math.sqrt(-dis) / (2 * A)).toFixed(4);
          result.tech_fact = `${A}(x - (${real} + ${imag}i) )(x - (${real} - ${imag}i) )`;
          result.tech_roots = `x₁ = ${real} + ${imag}i<br> x₂ = ${real} - ${imag}i`;
        } else {
          x1 = +(-B / (2 * A)).toFixed(4);
          result.tech_fact = `${A}(x ${x1 < 0 ? "+ " + -x1 : "- " + x1})^2`;
          result.tech_roots = `x = ${x1}`;
        }
      } else if (method == 1) {
        let leftSide = B / A;
        let C_ = -C / A;
        let rightSide = C_ + Math.pow(B, 2) / Math.pow(2 * A, 2);

        if (rightSide > 0) {
          x1 = +(-leftSide / 2 + Math.sqrt(rightSide)).toFixed(4);
          x2 = +(-leftSide / 2 - Math.sqrt(rightSide)).toFixed(4);
          result.tech_fact = `${A}(x ${x1 < 0 ? "+ " + -x1 : "- " + x1} )(x ${
            x2 < 0 ? "+ " + -x2 : "- " + x2
          } )`;
          result.tech_roots = `x₁ = ${x1} , x₂ = ${x2}`;
        } else if (rightSide < 0) {
          let real = +(-leftSide / 2).toFixed(4);
          let imag = +Math.sqrt(-rightSide).toFixed(4);
          result.tech_fact = `${A}(x - (${real} + ${imag}i) )(x - (${real} - ${imag}i) )`;
          result.tech_roots = `x₁ = ${real} + ${imag}i<br> x₂ = ${real} - ${imag}i`;
        } else {
          x1 = +(-leftSide / 2).toFixed(4);
          result.tech_fact = `${A}(x ${x1 < 0 ? "+ " + -x1 : "- " + x1})^2`;
          result.tech_roots = `x = ${x1}`;
        }
        if (typeof x1 !== "undefined") result.tech_x1 = x1;
        if (typeof x2 !== "undefined") result.tech_x2 = x2;
      }

      result.tech_B = B;
      result.tech_C = C;
    } else {
      result.error = "Please fill all fields.";
    }

    return result;
  }

  /** getCalculationQuotientAndRemainderCalculator
   * POST: /api/calculators-lol/remainder-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationQuotientAndRemainderCalculator(body) {
    let x = parseFloat(body.tech_x);
    let y = parseFloat(body.tech_y);
    let result = {};

    if (!isNaN(x) && !isNaN(y)) {
      let mod = x % y;
      let q = Math.floor(x / y);

      result.tech_r = mod;
      result.tech_q = q;
    } else {
      result.error = "Please Check Your Input.";
    }

    return result;
  }

  /** getCalculationRoundingCalculator
   * POST: /api/calculators-lol/rounding-numbers-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRoundingCalculator(body) {
    let number = parseFloat(body.tech_number);
    let mode = body.tech_mode; // Currently unused but kept for consistency
    let per = parseInt(body.tech_per);
    let result = {};

    if (!isNaN(number)) {
      // Helper function for rounding with precision (simulating PHP_ROUND_HALF_UP)
      function roundTo(value, places) {
        let factor = Math.pow(10, places);
        return Math.round(value * factor) / factor;
      }

      let ans = roundTo(number, per);
      let one = roundTo(number, 0);
      let two = roundTo(number, -1);
      let three = roundTo(number, -2);
      let four = roundTo(number, -3);

      result.tech_ans = ans;
      result.tech_one = one;
      result.tech_two = two;
      result.tech_three = three;
      result.tech_four = four;
    } else {
      result.error = "Please Check Your Input.";
    }

    return result;
  }

  /** getCalculationFractionToDecimalCalculator
   * POST: /api/calculators-lol/fraction-to-decimal-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationFractionToDecimalCalculator(body) {
    let n1 = parseFloat(body.tech_n1); // whole number part (optional)
    let n2 = parseFloat(body.tech_n2); // numerator
    let d1 = parseFloat(body.tech_d1); // denominator
    let round = parseInt(body.tech_round);
    let result = {};

    if (!isNaN(n2) && !isNaN(d1)) {
      let totalN = n2;
      let totalD = d1;

      if (!isNaN(n1)) {
        if (n1 < 0 && totalN > 0) {
          totalN = -totalN;
        }
        totalN = totalD * n1 + totalN;
      }

      // GCD function
      function gcd(a, b) {
        a = Math.abs(a);
        b = Math.abs(b);
        if (a < b) [a, b] = [b, a];
        if (b === 0) return 1;
        let r = a % b;
        while (r > 0) {
          a = b;
          b = r;
          r = a % b;
        }
        return b;
      }

      // Reduce fraction
      function reduce(num, den) {
        let g = gcd(num, den);
        return [num / g, den / g];
      }

      let ans = +(totalN / totalD).toFixed(round);
      let g = gcd(totalN, totalD);
      let [upr, btm] = reduce(totalN, totalD);

      result.tech_ans = ans;
      result.tech_upr = upr;
      result.tech_totalN = totalN;
      result.tech_totalD = totalD;
      result.tech_g = g;
      result.tech_btm = btm;
    } else {
      result.error = "Please! Check Your Input.";
    }

    return result;
  }

  /** getCalculationDecimalToFractionCalculator
   * POST: /api/calculators-lol/decimal-to-fraction-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDecimalToFractionCalculator(body) {
    let dec = body.tech_dec; // Input decimal number (e.g., "0.75" or "0.666")
    let repeat = parseInt(body.tech_repeat); // Number of repeating digits, if provided
    let result = {};

    // ✅ Input validation
    if (dec === undefined || isNaN(Number(dec))) {
      result.error = "Please! Check Your Input.";
      return result;
    }

    dec = dec.toString(); // Ensure it's a string for splitting
    if (!dec.includes(".")) {
      result.error = "Please provide a decimal number (e.g., 0.75).";
      return result;
    }

    let nbr = dec.split("."); // Split into integer and fractional parts

    if (!isNaN(repeat) && repeat > 0) {
      // 🔁 Handle repeating decimal
      let repeatDigits = nbr[1].slice(-repeat); // Get repeating part from right
      if (repeat > nbr[1].length) {
        result.error = "Please! Check Your Input.";
        return result;
      }

      let input = dec.split(repeatDigits)[0] + `bar(${repeatDigits})`; // Format input with bar notation
      let add = "1";
      let first = dec;
      for (let i = 1; i <= repeat; i++) {
        add += "0"; // Build multiplier like 10, 100, etc.
        first += repeatDigits; // Extend decimal
      }

      let second = Number(first) * Number(add);
      let third = second - Number(first);

      let totalLength = nbr[0].length + nbr[1].length;
      let thirdRounded = Number(
        third.toFixed(totalLength - Math.floor(second).toString().length)
      );

      // Prepare numerator and denominator
      let numParts = thirdRounded.toString().split(".");
      let div = "1";
      if (numParts.length > 1) {
        for (let i = 1; i <= numParts[1].length; i++) div += "0";
      }

      let upr = thirdRounded * Number(div);
      let div_ = Number(div);
      let finalDiv = (Number(add) - 1) * Number(div);

      // Helper function: GCD
      function gcd(a, b) {
        a = Math.abs(a);
        b = Math.abs(b);
        while (b !== 0) {
          [a, b] = [b, a % b];
        }
        return a;
      }

      // Reduce fraction
      function reduce(num, den) {
        let g = gcd(num, den);
        return [num / g, den / g];
      }

      let g = gcd(upr, finalDiv);
      let [uper, btm] = reduce(upr, finalDiv);

      // Final result object
      result.tech_input = input;
      result.tech_last_n = repeatDigits;
      result.tech_second = second;
      result.tech_third = thirdRounded;
      result.tech_add = add;
      result.tech_upr = upr;
      result.tech_div = finalDiv;
      result.tech_div_ = div_;
      result.tech_uper = uper;
      result.tech_btm = btm;
      result.tech_g = g;
      return result;
    } else {
      // 🟡 Non-repeating decimal case
      let div = "1";
      if (nbr.length > 1) {
        for (let i = 1; i <= nbr[1].length; i++) div += "0"; // Build denominator (e.g., 100 for .75)
      }

      let upr = Number(nbr[0] + nbr[1]); // Join integer + fractional
      let finalDiv = Number(div);

      // GCD and reduce
      function gcd(a, b) {
        a = Math.abs(a);
        b = Math.abs(b);
        while (b !== 0) {
          [a, b] = [b, a % b];
        }
        return a;
      }

      function reduce(num, den) {
        let g = gcd(num, den);
        return [num / g, den / g];
      }

      let g = gcd(upr, finalDiv);
      let [uper, btm] = reduce(upr, finalDiv);

      // Final result object
      result.tech_upr = upr;
      result.tech_div = finalDiv;
      result.tech_uper = uper;
      result.tech_btm = btm;
      result.tech_g = g;
      return result;
    }
  }

  /** getCalculationFractionToPercentCalculator
   * POST: /api/calculators-lol/fraction-to-percent-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationFractionToPercentCalculator(body) {
    let n1 = parseFloat(body.tech_n1); // whole number part (optional)
    let n2 = parseFloat(body.tech_n2); // numerator
    let d1 = parseFloat(body.tech_d1); // denominator
    let round = parseInt(body.tech_round);
    let result = {};

    if (!isNaN(n2) && !isNaN(d1)) {
      let totalN = n2;
      let totalD = d1;

      if (!isNaN(n1)) {
        if (n1 < 0 && totalN > 0) {
          totalN = -totalN;
        }
        totalN = totalD * n1 + totalN;
      }

      // GCD function
      function gcd(a, b) {
        a = Math.abs(a);
        b = Math.abs(b);
        if (a < b) [a, b] = [b, a];
        if (b === 0) return 1;
        let r = a % b;
        while (r > 0) {
          a = b;
          b = r;
          r = a % b;
        }
        return b;
      }

      // Reduce fraction
      function reduce(num, den) {
        let g = gcd(num, den);
        return [num / g, den / g];
      }

      let ans = +(totalN / totalD).toFixed(round);
      let g = gcd(totalN, totalD);
      let [upr, btm] = reduce(totalN, totalD);

      result.tech_ans = ans;
      result.tech_upr = upr;
      result.tech_totalN = totalN;
      result.tech_totalD = totalD;
      result.tech_g = g;
      result.tech_btm = btm;
    } else {
      result.error = "Please! Check Your Input.";
    }

    return result;
  }

  /** getCalculationPercentToFractionCalculator
   * POST: /api/calculators-lol/percent-to-fraction-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPercentToFractionCalculator(body) {
    let percent = body.tech_percent;
    let result = {};

    if (percent === undefined || isNaN(Number(percent))) {
      result.error = "Please! Check Your Input.";
      return result;
    }

    let decimal = Number(percent) / 100;
    let decimalStr = decimal.toString();

    let nbr = decimalStr.split(".");
    if (nbr.length < 2) {
      nbr.push("0"); // If no decimal, treat as ".0"
    }

    let div = "1";
    for (let i = 1; i <= nbr[1].length; i++) {
      div += "0";
    }

    let upr = Number(nbr[0] + nbr[1]);
    let den = Number(div);

    function gcd(a, b) {
      a = Math.abs(a);
      b = Math.abs(b);
      while (b !== 0) {
        [a, b] = [b, a % b];
      }
      return a;
    }

    function reduce(num, den) {
      let g = gcd(num, den);
      return [num / g, den / g];
    }

    let g = gcd(upr, den);
    let [uper, btm] = reduce(upr, den);

    result.tech_upr = upr;
    result.tech_div = den;
    result.tech_uper = uper;
    result.tech_btm = btm;
    result.tech_g = g;
    return result;
  }

  /** getCalculationMillionBillionLakhCalculator
   * POST: /api/calculators-lol/million-billion-lakh-crore
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMillionBillionLakhCalculator(body) {
    let from_new = body.tech_from_new ?? false;
    let calFrom_new = body.tech_calFrom_new ?? false;
    let calto_new = body.tech_calto_new ?? false;

    let from = body.tech_from;
    let f_u = body.tech_calFrom;
    let t_u = body.tech_calto;

    if (from_new && !isNaN(from_new)) {
      from = from_new;
    }

    if (calFrom_new) {
      f_u = calFrom_new;
    }

    if (calto_new) {
      t_u = calto_new;
    }

    let result = {};

    if (!isNaN(from)) {
      let from_input = from;
      let f_u_input = f_u;
      let t_u_input = t_u;
      let to = from;
      let t1, t2, t3, t4, t5, t6, t7, t8;

      const unitMultipliers = {
        Hundred: 1,
        Thousand: 10,
        Lakh: 1000,
        Million: 10000,
        Crore: 100000,
        Billion: 10000000,
        Trillion: 10000000000,
        Arab: 10000000,
        Kharab: 1000000000,
      };

      if (f_u === t_u) {
        to = from;
      } else {
        if (unitMultipliers[f_u]) {
          from = from * unitMultipliers[f_u];
        }

        const conversions = {
          to,
          t1: from / 10 + " Thousand",
          t2: from / 1000 + " Lakh",
          t3: from / 10000 + " Million",
          t4: from / 100000 + " Crore",
          t5: from / 10000000 + " Billion",
          t6: from / 10000000000 + " Trillion",
          t7: from / 10000000 + " Arab",
          t8: from / 1000000000 + " Kharab",
        };

        to = unitMultipliers[t_u] ? from / unitMultipliers[t_u] : from;

        ({ t1, t2, t3, t4, t5, t6, t7, t8 } = conversions);
      }

      // Define dummy input arrays for table generation
      const input = [
        "Hundred",
        "Thousand",
        "Lakh",
        "Million",
        "Crore",
        "Billion",
        "Trillion",
        "Arab",
        "Kharab",
      ];
      const numbers = [1, 10, 50, 100, 500, 1000];

      let table = "";
      for (let i = 0; i < 9; i++) {
        let rand1 = input[Math.floor(Math.random() * input.length)];
        let rand2 = input[Math.floor(Math.random() * input.length)];
        let nbr = numbers[Math.floor(Math.random() * numbers.length)];
        table += `<div class='col-span-6 md:col-span-4 lg:col-span-4'>
            <input type='submit' name='submit' class='rounded-lg hover:bg-[#99EA48] cursor-pointer' value='${nbr} ${rand1} to ${rand2}'>
          </div>`;
      }

      result.tech_to = to;
      result.tech_t1 = t1;
      result.tech_t2 = t2;
      result.tech_t3 = t3;
      result.tech_t4 = t4;
      result.tech_t5 = t5;
      result.tech_t6 = t6;
      result.tech_t7 = t7;
      result.tech_t8 = t8;
      result.tech_table = table;
      result.tech_from_input = from_input;
      result.tech_f_u_input = f_u_input;
      result.tech_t_u_input = t_u_input;

      return result;
    } else {
      return { error: "Please Check Your Input." };
    }
  }

  /** getCalculationPointSlopeFormCalculator
   * POST: /api/calculators-lol/point-slope-form-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPointSlopeFormCalculator(body) {
    let point_unit = body.tech_point_unit;
    let x1 = body.tech_x1;
    let y1 = body.tech_y1;
    let m = body.tech_m;
    let sec_x1 = body.tech_sec_x1;
    let sec_y1 = body.tech_sec_y1;
    let sec_x2 = body.tech_sec_x2;
    let sec_y2 = body.tech_sec_y2;

    let result = {};

    if (point_unit === "1") {
      if (!isNaN(x1) && !isNaN(y1) && !isNaN(m)) {
        x1 = -x1;
        y1 = -y1;
        let mn = x1 * m;

        let s = `y ${y1 < 0 ? "- " + Math.abs(y1) : "+ " + y1} = ${m}(x ${
          x1 < 0 ? "- " + Math.abs(x1) : "+ " + x1
        })`;
        let s1 = `(y ${y1 < 0 ? "- " + Math.abs(y1) : "+ " + y1}) = ${m}x ${
          mn < 0 ? "- " + Math.abs(mn) : "+ " + mn
        }`;
        let s2 = `y = ${m}x ${mn < 0 ? "- " + Math.abs(mn) : "+ " + mn} ${
          y1 < 0 ? "+ " + Math.abs(y1) : "- " + y1
        }`;
        let val = mn + y1;
        let s3 = `y = ${m}x ${val < 0 ? "- " + Math.abs(val) : "+ " + val}`;
        let s4 = `${m}x - y ${val < 0 ? "- " + Math.abs(val) : "+ " + val} = 0`;

        result.tech_s = s;
        result.tech_s1 = s1;
        result.tech_s2 = s2;
        result.tech_s3 = s3;
        result.tech_s4 = s4;
      } else {
        return { error: "Please! Check Your Input." };
      }
    } else {
      if (
        !isNaN(sec_x1) &&
        !isNaN(sec_y1) &&
        !isNaN(sec_x2) &&
        !isNaN(sec_y2)
      ) {
        if (sec_x1 == sec_x2) {
          return {
            error: "Please Check Your Input: x1 and x2 cannot be the same.",
          };
        }

        m = (sec_y2 - sec_y1) / (sec_x2 - sec_x1);
        let slope = m;

        sec_x1 = -sec_x1;
        sec_y1 = -sec_y1;
        let mn = sec_x1 * m;

        let s = `(y ${
          sec_y1 < 0 ? "- " + Math.abs(sec_y1) : "+ " + sec_y1
        }) = ${m}(x ${sec_x1 < 0 ? "- " + Math.abs(sec_x1) : "+ " + sec_x1})`;
        let s1 = `(y ${
          sec_y1 < 0 ? "- " + Math.abs(sec_y1) : "+ " + sec_y1
        }) = ${m}x ${mn < 0 ? "- " + Math.abs(mn) : "+ " + mn}`;
        let s2 = `y = ${m}x ${mn < 0 ? "- " + Math.abs(mn) : "+ " + mn} ${
          sec_y1 < 0 ? "+ " + Math.abs(sec_y1) : "- " + sec_y1
        }`;
        let val = mn + sec_y1;
        let s3 = `y = ${m}x ${val < 0 ? "- " + Math.abs(val) : "+ " + val}`;
        let s4 = `${m}x - y ${val < 0 ? "- " + Math.abs(val) : "+ " + val} = 0`;

        result.tech_s = s;
        result.tech_s1 = s1;
        result.tech_s2 = s2;
        result.tech_s3 = s3;
        result.tech_s4 = s4;
        result.tech_slope = slope;
      } else {
        return { error: "Please! Check Your Input." };
      }
    }

    return result;
  }

  /** getCalculationHemisphereCalculator
   * POST: /api/calculators-lol/hemisphere-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationHemisphereCalculator(body) {
    let to_calculate = body.tech_to_calculate;
    let val = parseFloat(body.tech_value);
    let unit = body.tech_unit;
    let rof = parseInt(body.tech_rof);
    let result = {};

    if (!isNaN(val)) {
      let r, c, v, a, b, tsa, pc, pv, pa, pb, ptsa;

      const π = Math.PI;

      if (to_calculate === "rad") {
        r = val + " " + unit;
        c = (2 * π * val).toFixed(rof) + " " + unit;
        v =
          ((2 / 3) * π * Math.pow(val, 3)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>3</sup>";
        a =
          (2 * π * Math.pow(val, 2)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        b =
          (π * Math.pow(val, 2)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        tsa =
          (3 * π * Math.pow(val, 2)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        pc = (2 * val).toFixed(rof) + " π " + unit;
        pv =
          ((2 / 3) * Math.pow(val, 3)).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>3</sup>";
        pa =
          (2 * Math.pow(val, 2)).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        pb =
          Math.pow(val, 2).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        ptsa =
          (3 * Math.pow(val, 2)).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>2</sup>";
      } else if (to_calculate === "vol") {
        r = Math.pow((3 * val) / (2 * π), 1 / 3).toFixed(rof);
        c = (2 * π * r).toFixed(rof) + " " + unit;
        v = val.toFixed(rof) + " " + unit + "<sup class='font-s-14'>3</sup>";
        a =
          (2 * π * Math.pow(r, 2)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        b =
          (π * Math.pow(r, 2)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        tsa =
          (3 * π * Math.pow(r, 2)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        pc = (2 * r).toFixed(rof) + " π " + unit;
        pv =
          ((2 / 3) * Math.pow(r, 3)).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>3</sup>";
        pa =
          (2 * Math.pow(r, 2)).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        pb =
          Math.pow(r, 2).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        ptsa =
          (3 * Math.pow(r, 2)).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        r = r + " " + unit;
      } else if (to_calculate === "tsa") {
        r = Math.sqrt(val / (3 * π)).toFixed(rof);
        c = (2 * π * r).toFixed(rof) + " " + unit;
        v =
          ((2 / 3) * π * Math.pow(r, 3)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>3</sup>";
        a =
          (2 * π * Math.pow(r, 2)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        b =
          (π * Math.pow(r, 2)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        tsa = val.toFixed(rof) + " " + unit + "<sup class='font-s-14'>2</sup>";
        pc = (2 * r).toFixed(rof) + " π " + unit;
        pv =
          ((2 / 3) * Math.pow(r, 3)).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>3</sup>";
        pa =
          (2 * Math.pow(r, 2)).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        pb =
          Math.pow(r, 2).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        ptsa =
          (3 * Math.pow(r, 2)).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        r = r + " " + unit;
      } else if (to_calculate === "csa") {
        r = Math.sqrt(val / (2 * π)).toFixed(rof);
        c = (2 * π * r).toFixed(rof) + " " + unit;
        v =
          ((2 / 3) * π * Math.pow(r, 3)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>3</sup>";
        a = val.toFixed(rof) + " " + unit + "<sup class='font-s-14'>2</sup>";
        b =
          (π * Math.pow(r, 2)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        tsa =
          (3 * π * Math.pow(r, 2)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        pc = (2 * r).toFixed(rof) + " π " + unit;
        pv =
          ((2 / 3) * Math.pow(r, 3)).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>3</sup>";
        pa =
          (2 * Math.pow(r, 2)).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        pb =
          Math.pow(r, 2).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        ptsa =
          (3 * Math.pow(r, 2)).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        r = r + " " + unit;
      } else if (to_calculate === "cf") {
        r = (val / (2 * π)).toFixed(rof);
        c = (2 * π * r).toFixed(rof) + " " + unit;
        v =
          ((2 / 3) * π * Math.pow(r, 3)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>3</sup>";
        a =
          (2 * π * Math.pow(r, 2)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        b = val.toFixed(rof) + " " + unit + "<sup class='font-s-14'>2</sup>";
        tsa =
          (3 * π * Math.pow(r, 2)).toFixed(rof) +
          " " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        pc = (2 * r).toFixed(rof) + " π " + unit;
        pv =
          ((2 / 3) * Math.pow(r, 3)).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>3</sup>";
        pa =
          (2 * Math.pow(r, 2)).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        pb =
          Math.pow(r, 2).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        ptsa =
          (3 * Math.pow(r, 2)).toFixed(rof) +
          " π " +
          unit +
          "<sup class='font-s-14'>2</sup>";
        r = r + " " + unit;
      }

      result = {
        tech_radi: r,
        tech_cs: c,
        tech_vs: v,
        tech_as: a,
        tech_bs: b,
        tech_tsas: tsa,
        tech_pcs: pc,
        tech_pvs: pv,
        tech_pas: pa,
        tech_pbs: pb,
        tech_ptsas: ptsa,
      };
    } else {
      result.error = "Please! Check Your Input.";
    }

    return result;
  }

  /** getCalculationDiscriminantCalculator
   * POST: /api/calculators-lol/discriminant-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDiscriminantCalculator(body) {
    let to_calculate = body.tech_to_calculate;
    let value = parseFloat(body.tech_value);
    let value1 = parseFloat(body.tech_value1);
    let value2 = parseFloat(body.tech_value2);
    let value3 = parseFloat(body.tech_value3);
    let value4 = parseFloat(body.tech_value4);

    let param = {};

    if (to_calculate === "2d") {
      if (!isNaN(value) && !isNaN(value1) && !isNaN(value2)) {
        let A = value;
        let B = value1;
        let C = value2;
        let ds = Math.pow(B, 2) - 4 * A * C;
        let nr =
          ds === 0
            ? "The polynomial has a double root."
            : ds > 0
            ? "The polynomial has two distinct real roots"
            : "The polynomial has a pair of conjugate complex roots";

        param.tech_sd = ds;
        param.tech_nrs = nr;
        return param;
      }
    } else if (to_calculate === "3d") {
      if (!isNaN(value) && !isNaN(value1) && !isNaN(value2) && !isNaN(value3)) {
        let A = value;
        let B = value1;
        let C = value2;
        let D = value3;
        let ds =
          Math.pow(B, 2) * Math.pow(C, 2) -
          4 * A * Math.pow(C, 3) -
          4 * Math.pow(B, 3) * D -
          27 * Math.pow(A, 2) * Math.pow(D, 2) +
          18 * A * B * C * D;
        let nr =
          ds === 0
            ? "At least two roots are equal (one root of multiplicity 3 or two distinct real roots) one of which is a double root"
            : ds > 0
            ? "The roots are three distinct real numbers"
            : "There is one real root and two complex conjugate roots";

        param.tech_sd = ds;
        param.tech_nrs = nr;
        return param;
      }
    } else if (to_calculate === "4d") {
      if (
        !isNaN(value) &&
        !isNaN(value1) &&
        !isNaN(value2) &&
        !isNaN(value3) &&
        !isNaN(value4)
      ) {
        let A = value;
        let B = value1;
        let C = value2;
        let D = value3;
        let E = value4;
        let ds =
          256 * Math.pow(A, 3) * Math.pow(E, 3) -
          192 * Math.pow(A, 2) * B * D * Math.pow(E, 2) -
          128 * Math.pow(A, 2) * Math.pow(C, 2) * Math.pow(E, 2) +
          144 * Math.pow(A, 2) * C * Math.pow(D, 2) * E -
          27 * Math.pow(A, 2) * Math.pow(D, 4) +
          144 * A * Math.pow(B, 2) * C * Math.pow(E, 2) -
          6 * A * Math.pow(B, 2) * Math.pow(D, 2) * E -
          80 * A * B * Math.pow(C, 2) * D * E +
          18 * A * B * C * Math.pow(D, 3) +
          16 * A * Math.pow(C, 4) * E -
          4 * A * Math.pow(C, 3) * Math.pow(D, 2) -
          27 * Math.pow(B, 4) * Math.pow(E, 2) +
          18 * Math.pow(B, 3) * C * D * E -
          4 * Math.pow(B, 3) * Math.pow(D, 3) -
          4 * Math.pow(B, 2) * Math.pow(C, 3) * E +
          Math.pow(B, 2) * Math.pow(C, 2) * Math.pow(D, 2);
        let nr =
          ds === 0
            ? "There are two or more equal roots"
            : ds > 0
            ? "There are four distinct real roots or four distinct non-real roots"
            : "There are two distinct real roots and two distinct non-real roots";

        param.tech_sd = ds;
        param.tech_nrs = nr;
        return param;
      }
    }

    param.error = "Please! Check Your Input.";
    return param;
  }

  /** getCalculationEndpointCalculator
   * POST: /api/calculators-lol/endpoint-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationEndpointCalculator(body) {
    let x1 = parseFloat(body.tech_x1);
    let y1 = parseFloat(body.tech_y1);
    let x = parseFloat(body.tech_x);
    let y = parseFloat(body.tech_y);

    let param = {};

    if (!isNaN(x1) && !isNaN(y1) && !isNaN(x) && !isNaN(y)) {
      let x2 = 2 * x - x1;
      let y2 = 2 * y - y1;
      let dis = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
      dis = Math.round(dis * 10000) / 10000;

      param.tech_x2 = x2;
      param.tech_y2 = y2;
      param.tech_dis = dis;
      return param;
    } else {
      param.error = "Please! Check Your Input.";
      return param;
    }
  }

  /** getCalculationSlopeInterceptFormCalculator
   * POST: /api/calculators-lol/slope-intercept-form-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSlopeInterceptFormCalculator(body) {
    let type = body.tech_type;
    let x1 = parseFloat(body.tech_x1);
    let x2 = parseFloat(body.tech_x2);
    let y1 = parseFloat(body.tech_y1);
    let y2 = parseFloat(body.tech_y2);

    let param = {};

    if (type === "2") {
      if (!isNaN(x1) && !isNaN(x2) && !isNaN(y1) && !isNaN(y2)) {
        let x = x2 - x1;
        let y = y2 - y1;
        let slope = parseFloat((y / x).toFixed(4));
        let angle = parseFloat((Math.atan(slope) * (180 / Math.PI)).toFixed(4));
        let distance = parseFloat(
          Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)).toFixed(4)
        );
        let b = parseFloat((y1 - slope * x1).toFixed(2));

        param.tech_x = x;
        param.tech_y = y;
        param.tech_slope = slope;
        param.tech_angle = `${angle} deg`;
        param.tech_distance = distance;
        param.tech_b = b;
      } else {
        param.error = "Please! Check Your Input.";
      }
    } else if (type === "1") {
      let slope = x2; // here x2 is passed as slope

      if (!isNaN(x1) && !isNaN(y1) && !isNaN(slope)) {
        let angle = parseFloat((Math.atan(slope) * (180 / Math.PI)).toFixed(4));
        let b = parseFloat((y1 - slope * x1).toFixed(4));

        param.tech_b = b;
        param.tech_slope = slope;
        param.tech_angle = `${angle} deg`;
      } else {
        param.error = "Please! Check Your Input.";
      }
    } else {
      let b = x1;
      let slope = x2;

      if (!isNaN(b) && !isNaN(slope)) {
        let angle = parseFloat((Math.atan(slope) * (180 / Math.PI)).toFixed(4));

        param.tech_b = b;
        param.tech_slope = slope;
        param.tech_angle = `${angle} deg`;
      } else {
        param.error = "Please! Check Your Input.";
      }
    }

    return param;
  }

  /**
   * getCalculationLCMCalculator: Service Method
   * POST: /api/calculators-lol/lcm-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLCMCalculator(body) {
    // Helper function to calculate GCD
    const gcd = (a, b) => {
      if (b == 0) return a;
      return gcd(b, a % b);
    };

    // Helper function to calculate LCM of array
    const lcmOfArray = (numbers) => {
      let ans = numbers[0];
      for (let i = 1; i < numbers.length; i++) {
        ans = (numbers[i] * ans) / gcd(numbers[i], ans);
      }
      return ans;
    };

    // Helper function for conditional plural
    const condPlural = (word, count) => {
      return count > 1 ? word + "s" : word;
    };

    let x = body.tech_x;
    let method = body.tech_method;
    const param = {};
    let check = true;

    // Check if x is empty
    if (!x) {
      check = false;
    }

    // Parse and validate numbers
    const numbers = x
      .split(",")
      .map((n) => n.trim())
      .filter((n) => n !== "")
      .map((n) => parseFloat(n));

    // Validation checks
    for (let value of numbers) {
      // Check for decimal numbers
      const list = value.toString().split(".");
      if (list.length === 2 && list[1] !== "0") {
        param.error = "Please! Enter numeric values.";
        return param;
      }

      // Check if number is greater than 100000
      if (value > 100000) {
        param.error = "A number can't be greater than 100000.";
        return param;
      }

      // Check for negative numbers
      if (value < 0) {
        param.error = "Please! Enter Only Positive Numbers.";
        return param;
      }
    }

    // Check maximum 15 numbers
    if (numbers.length > 15) {
      param.error = "Please! Enter 15 numbers at most.";
      return param;
    }

    if (!check) {
      param.error = "Please fill all fields.";
      return param;
    }

    const n = numbers.length;
    const lcm = lcmOfArray(numbers);

    // Method: none (just calculate LCM)
    if (method == "none") {
      param.tech_lcm = lcm;
      return param;
    }

    // Method: lm (Listing Multiples)
    if (method == "lm") {
      const bruteForce = (newNumberList, lcm, decimalLength) => {
        let stepSolution = "";

        if (decimalLength > 0) {
          stepSolution +=
            "<i> • As not all of your numbers are integers, you first need to shift the decimal " +
            decimalLength +
            condPlural(" place", decimalLength) +
            " to the right. This means we'll search for the LCM of the positive integers:<br></i>LCM(" +
            newNumberList.join(", ") +
            "),<i><br> and, at the end, we'll move the decimal point of the result " +
            decimalLength +
            condPlural(" place", decimalLength) +
            " to the left.</i><br>";
        }

        const lcmLong = lcm * Math.pow(10, decimalLength);

        for (let i = 0; i < newNumberList.length; i++) {
          stepSolution +=
            "• <b>Multiples of " +
            newNumberList[i].toFixed(decimalLength) +
            ": </b>";

          if (lcmLong / newNumberList[i] + 4 < 100) {
            for (let j = 1; j < lcmLong / newNumberList[i] + 4; j++) {
              if (newNumberList[i] * j == lcmLong) {
                stepSolution +=
                  "<b>" +
                  (newNumberList[i] * j).toFixed(decimalLength) +
                  "</b>, ";
              } else if (j == lcmLong / newNumberList[i] + 3) {
                stepSolution +=
                  (newNumberList[i] * j).toFixed(decimalLength) + " ...";
              } else {
                stepSolution +=
                  (newNumberList[i] * j).toFixed(decimalLength) + ", ";
              }
            }
          } else {
            const N_numbers = 10; // must be even

            for (let j = 1; j < N_numbers; j++) {
              if (j == N_numbers - 1) {
                stepSolution +=
                  (newNumberList[i] * j).toFixed(decimalLength) + ", ..., ";
              } else {
                stepSolution +=
                  (newNumberList[i] * j).toFixed(decimalLength) + ", ";
              }
            }

            for (
              let j =
                Math.round(lcmLong / newNumberList[i] / 2) - N_numbers / 2;
              j < lcmLong / newNumberList[i] / 2 + Math.round(N_numbers / 2);
              j++
            ) {
              if (
                j ==
                Math.round(lcmLong / newNumberList[i] / 2) + (N_numbers / 2 - 1)
              ) {
                stepSolution +=
                  (newNumberList[i] * j).toFixed(decimalLength) + ", ..., ";
              } else {
                stepSolution +=
                  (newNumberList[i] * j).toFixed(decimalLength) + ", ";
              }
            }

            for (
              let j = lcmLong / newNumberList[i] - Math.round(N_numbers / 2);
              j < lcmLong / newNumberList[i] + Math.round(N_numbers / 2);
              j++
            ) {
              if (newNumberList[i] * j == lcmLong) {
                stepSolution +=
                  "<b>" +
                  (newNumberList[i] * j).toFixed(decimalLength) +
                  "</b>, ";
              } else if (
                j ==
                lcmLong / newNumberList[i] + Math.round(N_numbers / 2 - 1)
              ) {
                stepSolution +=
                  (newNumberList[i] * j).toFixed(decimalLength) + " ...";
              } else {
                stepSolution +=
                  (newNumberList[i] * j).toFixed(decimalLength) + ", ";
              }
            }
          }
          stepSolution += "<br><br>";
        }

        if (decimalLength > 0) {
          stepSolution +=
            "Thus, <br><br><b>LCM(" +
            newNumberList.join(", ") +
            ") = " +
            lcm +
            "</b>";
        }

        return stepSolution;
      };

      const sl = bruteForce(numbers, lcm, 0);
      param.tech_sl = sl;
      param.tech_lcm = lcm;
      return param;
    }

    // Method: Pf (Prime Factorization)
    if (method == "Pf") {
      let sl = "";
      let ss = "";

      // Prime factorization for each number
      for (let value of numbers) {
        let x = value;
        sl += "<p class='mt-2'> Prime Factors of " + value + " = ";
        const arr = [];

        for (let i = 2; x > 1; i++) {
          while (x % i === 0) {
            x = x / i;
            arr.push(i);
          }
        }

        for (let j = 0; j < arr.length; j++) {
          if (j !== arr.length - 1) {
            sl += arr[j] + " x ";
          } else {
            sl += arr[j] + " </p>";
          }
        }
      }

      // Prime factorization of LCM
      let s = lcm;
      const arr1 = [];

      for (let i = 2; s > 1; i++) {
        while (s % i === 0) {
          s = s / i;
          arr1.push(i);
        }
      }

      for (let j = 0; j < arr1.length; j++) {
        if (j !== arr1.length - 1) {
          ss += arr1[j] + " x ";
        } else {
          ss += arr1[j];
        }
      }

      param.tech_lcm = lcm;
      param.tech_sl = sl;
      param.tech_ss = ss;
      return param;
    }

    // Method: gcf (Greatest Common Factor Method)
    if (method == "gcf") {
      let lce = "";

      for (let i = 0; i < numbers.length - 1; i++) {
        if (i === 0) {
          const a = numbers[0];
          const b = numbers[1];
          lce += "LCM of (" + a + "," + b + ") = ";
          const lc = (a * b) / gcd(a, b);
          lce += " " + lc + " ";
        } else {
          const a = lcm;
          const b = numbers[i + 1];
          lce += "<p class='mt-2'>LCM of (" + a + "," + b + ") = ";
          const lc = (a * b) / gcd(a, b);
          lce += " " + lc + " </p>";
        }
      }

      param.tech_lcm = lcm;
      param.tech_lce = lce;
      return param;
    }

    // Method: cl or dm (Cake/Ladder Method and Division Method)
    if (method == "cl" || method == "dm") {
      let sl = "";
      const sd = [];
      const fd = [];
      const ev = [...numbers];
      let arr = [...numbers];

      const final_arr = new Array(numbers.length).fill(1);
      let final_arr_c = [...arr];

      while (JSON.stringify(final_arr) !== JSON.stringify(final_arr_c)) {
        let arr1 = [];
        let p = 2;

        // Try dividing by p
        for (let value of arr) {
          if (value % p === 0) {
            arr1.push(value / p);
          } else {
            arr1.push(value);
          }
        }

        final_arr_c = [...arr1];

        // Find next prime that divides at least one number
        while (JSON.stringify(arr) === JSON.stringify(arr1)) {
          arr1 = [];
          p++;
          for (let value of arr) {
            if (value % p === 0) {
              arr1.push(value / p);
            } else {
              arr1.push(value);
            }
          }
        }

        if (JSON.stringify(arr) !== JSON.stringify(arr1)) {
          arr = [...arr1];
          fd.push(p);
          sl += " (" + p + ") ";
          for (let value1 of arr1) {
            sd.push(value1);
          }
        }

        final_arr_c = [...arr1];
      }

      param.tech_lcm = lcm;
      param.tech_sd = sd;
      param.tech_fd = fd;
      param.tech_sl = sl;
      param.tech_ev = ev;
      return param;
    }

    param.error = "Please fill all fields.";
    return param;
  }

  /**
   * getCalculationGCFCalculator: Service Method
   * POST: /api/calculators-lol/gcf-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationGCFCalculator(body) {
    // Helper function to calculate GCD
    const gcd = (a, b) => {
      if (a == 0) return b;
      return gcd(b % a, a);
    };

    // Helper function to find GCD of array
    const findGCD = (arr) => {
      let result = arr[0];

      for (let i = 1; i < arr.length; i++) {
        result = gcd(arr[i], result);

        if (result === 1) {
          return 1;
        }
      }
      return result;
    };

    let x = body.tech_x;
    let method = body.tech_method;
    const param = {};
    let check = true;

    // Check if x is empty
    if (!x) {
      check = false;
    }

    // Parse and validate numbers
    const numbers = x
      .split(",")
      .map((n) => n.trim())
      .filter((n) => n != "")
      .map((n) => parseFloat(n));

    // Validation checks
    for (let value of numbers) {
      if (isNaN(value)) {
        check = false;
      } else {
        if (value > 1000000) {
          param.error = "Number must be less than or equal to 1000000.";
          return param;
        }
      }
    }

    if (!check) {
      param.error = "Please! Check Your Input.";
      return param;
    }

    // Check minimum 2 numbers
    if (numbers.length == 1) {
      param.error = "Please! Enter at least two numbers.";
      return param;
    }

    // Check maximum 15 numbers
    if (numbers.length > 15) {
      param.error = "You can enter up to 15 numbers.";
      return param;
    }

    const arr = numbers;
    const n = arr.length;
    const gcf = findGCD(arr);

    // Method: none (just calculate GCF)
    if (method == "none") {
      param.tech_gcf = gcf;
      return param;
    }

    // Method: lm (Listing Multiples/Factors)
    if (method == "lm") {
      let sl = "";
      let bl = "";

      // List factors for each number
      for (let value of arr) {
        sl += "<p class='mt-2'> Multiples of " + value + " = ";

        for (let i = 1; i <= value; i++) {
          if (value % i === 0) {
            if (i !== value) {
              sl += i + ", ";
            } else {
              sl += i;
              sl += "</p>";
            }
          }
        }
      }

      // List factors of GCF
      for (let j = 1; j <= gcf; j++) {
        if (gcf % j === 0) {
          if (j !== gcf) {
            bl += j + ", ";
          } else {
            bl += j;
          }
        }
      }

      param.tech_gcf = gcf;
      param.tech_sl = sl;
      param.tech_bl = bl;
      return param;
    }

    // Method: Pf (Prime Factorization)
    if (method == "Pf") {
      let al = "";
      let ss = "";
      let se = "";

      // Prime factorization for each number
      for (let value of arr) {
        let x = value;
        al += "<p class='mt-2'>Prime Factors of " + x + " = ";
        const primeFactors = [];

        for (let i = 2; x > 1; i++) {
          while (x % i === 0) {
            x = x / i;
            primeFactors.push(i);
          }
        }

        for (let j = 0; j < primeFactors.length; j++) {
          if (j !== primeFactors.length - 1) {
            al += " " + primeFactors[j] + " x ";
          } else {
            al += " " + primeFactors[j] + " </p>";
          }
        }
      }

      // Prime factorization of GCF
      if (gcf == 1) {
        se =
          " There is No Common prime factorization . This means that the only common factor is 1 ";
      } else {
        let s = gcf;
        const arr1 = [];

        for (let i = 2; s > 1; i++) {
          while (s % i === 0) {
            s = s / i;
            arr1.push(i);
          }
        }

        for (let j = 0; j < arr1.length; j++) {
          if (j !== arr1.length - 1) {
            ss += arr1[j] + " x ";
          } else {
            ss += arr1[j];
          }
        }
      }

      param.tech_gcf = gcf;
      param.tech_al = al;
      param.tech_se = se;
      param.tech_ss = ss;
      return param;
    }

    // Method: ea (Euclidean Algorithm)
    if (method == "ea") {
      let sg = "";
      let i = "";
      let mi = "";
      let l = "";
      let j = 0;
      let k = 0;
      const arr1 = [];
      const arr2 = [];

      // Sort array
      const sortedArr = [...arr].sort((a, b) => a - b);

      for (let value of sortedArr) {
        sg += value + "  ";
      }

      const sm = Math.min(...sortedArr);

      // First iteration
      for (let value of sortedArr) {
        if (value !== sm) {
          let x = value;
          j = x % sm;
          i +=
            "<p class='mt-2'> => " + x + " mod of " + sm + " = " + j + " </p>";
          arr1.push(j);
        }
        mi += " " + j + " ";
      }

      let si = "";
      if (j == 0) {
        si = gcf.toString();
      } else {
        si = mi + sm;
      }

      // Second iteration
      if (j != 0 && arr1.length > 0) {
        const smi = Math.min(...arr1);

        for (let value1 of arr1) {
          if (value1 !== smi) {
            let x = value1;
            k = x % smi;
            l += "<br/> => " + x + " mod of " + smi + " = " + k;
            arr2.push(k);
          } else {
            let x = sm;
            k = x % smi;
            l += "<br/> => " + x + " mod of " + smi + " = " + k;
          }
        }
      }

      // Third iteration if needed
      if (k != 0 && arr2.length > 0) {
        const smi = Math.min(...arr2);

        for (let value2 of arr2) {
          if (value2 !== smi) {
            let x = value2;
            k = x % smi;
            l += "<br/> => " + x + " mod of " + smi + " = " + k;
            arr2.push(k);
          } else {
            let x = sm;
            k = x % smi;
            l += "<br/> => " + x + " mod of " + smi + " = " + k;
          }
        }
      }

      param.tech_gcf = gcf;
      param.tech_sg = sg;
      param.tech_sm = sm;
      param.tech_i = i;
      param.tech_mi = mi;
      param.tech_si = si;
      param.tech_l = l;
      return param;
    }

    // Method: bs (Basic/Binary Search)
    if (method == "bs") {
      param.tech_numbers = numbers;
      param.tech_gcf = gcf;
      return param;
    }

    param.error = "Please! Check Your Input.";
    return param;
  }

  /**
   * getCalculationFactorialCalculator: Service Method
   * POST: /api/calculators-lol/factorial-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationFactorialCalculator(body) {
    let to_calculate = body.tech_to_calculate;
    let nvalue = body.tech_nvalue;
    let mvalue = body.tech_mvalue;
    const result = {};

    // Factorial calculation helper function
    function calculateFactorial(number) {
      let factorial = 1;
      for (let i = 1; i <= number; i++) {
        factorial = factorial * i;
      }
      return factorial;
    }

    // Generate factorial string representation
    function generateFactorialString(n) {
      let str = "";
      for (let i = 1; i <= n; i++) {
        if (i !== n) {
          str += ` ${i} *`;
        } else {
          str += ` ${i} `;
        }
      }
      return str;
    }

    // Check if number is too large
    function isInfinite(num) {
      return !isFinite(num);
    }

    // Single Factorial (f)
    if (to_calculate == "f") {
      if (!isNaN(nvalue) && nvalue !== null && nvalue !== "") {
        const n = Number(nvalue);

        if (n > 170) {
          result.error =
            "The factorial for a given number is too large, so try another value.";
          return result;
        }

        const fa = calculateFactorial(n);
        const a = generateFactorialString(n);

        if (isInfinite(fa)) {
          result.error =
            "The factorial for a given number is too large, so try another value.";
          return result;
        }

        result.tech_fa = fa;
        result.tech_a = a;
        return result;
      } else {
        result.error = "Please! Check Your Input.";
        return result;
      }
    }

    // Addition of Factorials (af)
    if (to_calculate == "af") {
      if (
        !isNaN(nvalue) &&
        !isNaN(mvalue) &&
        nvalue !== null &&
        mvalue !== null
      ) {
        const n = Number(nvalue);
        const m = Number(mvalue);

        if (n > 170 || m > 170) {
          result.error =
            "The factorial for a given number is too large, so try another value.";
          return result;
        }

        const fa = calculateFactorial(n);
        const fam = calculateFactorial(m);
        const a = generateFactorialString(n);
        const b = generateFactorialString(m);

        if (isInfinite(fa) || isInfinite(fam)) {
          result.error =
            "The factorial for a given number is too large, so try another value.";
          return result;
        }

        const add = fa + fam;
        result.tech_fa = fa;
        result.tech_fam = fam;
        result.tech_a = a;
        result.tech_b = b;
        result.tech_add = add;
        return result;
      } else {
        result.error = "Please! Check Your Input.";
        return result;
      }
    }

    // Subtraction of Factorials (sf)
    if (to_calculate == "sf") {
      if (
        !isNaN(nvalue) &&
        !isNaN(mvalue) &&
        nvalue !== null &&
        mvalue !== null
      ) {
        const n = Number(nvalue);
        const m = Number(mvalue);

        if (n > 170 || m > 170) {
          result.error =
            "The factorial for a given number is too large, so try another value.";
          return result;
        }

        const fa = calculateFactorial(n);
        const fam = calculateFactorial(m);
        const a = generateFactorialString(n);
        const b = generateFactorialString(m);

        if (isInfinite(fa) || isInfinite(fam)) {
          result.error =
            "The factorial for a given number is too large, so try another value.";
          return result;
        }

        const sub = fa - fam;
        result.tech_fa = fa;
        result.tech_fam = fam;
        result.tech_a = a;
        result.tech_b = b;
        result.tech_sub = sub;
        return result;
      } else {
        result.error = "Please! Check Your Input.";
        return result;
      }
    }

    // Multiplication of Factorials (mf)
    if (to_calculate == "mf") {
      if (
        !isNaN(nvalue) &&
        !isNaN(mvalue) &&
        nvalue !== null &&
        mvalue !== null
      ) {
        const n = Number(nvalue);
        const m = Number(mvalue);

        if (n > 170 || m > 170) {
          result.error =
            "The factorial for a given number is too large, so try another value.";
          return result;
        }

        const fa = calculateFactorial(n);
        const fam = calculateFactorial(m);
        const a = generateFactorialString(n);
        const b = generateFactorialString(m);

        if (isInfinite(fa) || isInfinite(fam)) {
          result.error =
            "The factorial for a given number is too large, so try another value.";
          return result;
        }

        const mul = fa * fam;
        result.tech_fa = fa;
        result.tech_fam = fam;
        result.tech_a = a;
        result.tech_b = b;
        result.tech_mul = mul;
        return result;
      } else {
        result.error = "Please! Check Your Input.";
        return result;
      }
    }

    // Division of Factorials (df)
    if (to_calculate == "df") {
      if (
        !isNaN(nvalue) &&
        !isNaN(mvalue) &&
        nvalue !== null &&
        mvalue !== null
      ) {
        const n = Number(nvalue);
        const m = Number(mvalue);

        if (n > 170 || m > 170) {
          result.error =
            "The factorial for a given number is too large, so try another value.";
          return result;
        }

        const fa = calculateFactorial(n);
        const fam = calculateFactorial(m);
        const a = generateFactorialString(n);
        const b = generateFactorialString(m);

        if (isInfinite(fa) || isInfinite(fam)) {
          result.error =
            "The factorial for a given number is too large, so try another value.";
          return result;
        }

        const div = fa / fam;
        result.tech_fa = fa;
        result.tech_fam = fam;
        result.tech_a = a;
        result.tech_b = b;
        result.tech_div = div;
        return result;
      } else {
        result.error = "Please! Check Your Input.";
        return result;
      }
    }

    // If no valid operation is found
    result.error = "Invalid operation type.";
    return result;
  }

  /** getCalculationFactorialCalculator
   * POST: /api/calculators-lol/exponent-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationExponentCalculator(body) {
    let b = body.tech_b;
    let x = body.tech_x;

    let param = {};

    const invalidPattern = /<|>|\&|php|print_r|print|echo|script|=|%/i;

    if (invalidPattern.test(b) || invalidPattern.test(x)) {
      param.error = "Please Enter Valid Input.";
      return param;
    }

    if (b !== undefined && x !== undefined && b !== "" && x !== "") {
      if (b.toString().length <= 7) {
        let expVal = Number(x);
        if (expVal <= 2000) {
          try {
            let base = eval(b);
            let exponent = eval(x);
            let result = Math.pow(base, exponent);

            param.tech_result = result;
            param.tech_b = base;
            param.tech_x = exponent;
            return param;
          } catch (e) {
            param.error = "Invalid expression.";
            return param;
          }
        } else {
          param.error = "Use exponents less than 2000.";
          return param;
        }
      } else {
        param.error = "Enter base less than 7 characters.";
        return param;
      }
    } else {
      param.error = "Please Enter Numbers.";
      return param;
    }
  }

  /** getCalculationSquareRootCalculator
   * POST: /api/calculators-lol/square-root-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSquareRootCalculator(body) {
    let n = body.tech_n;
    let n1 = body.tech_n1;
    let rt = body.tech_rt;
    let selection = body.tech_selection;

    let param = {};

    const invalidPattern = /<|>|&|php|print_r|print|echo|script|=|%/i;
    if (
      invalidPattern.test(n) ||
      invalidPattern.test(n1) ||
      invalidPattern.test(rt)
    ) {
      param.error = "Please Enter Valid Input.";
      return param;
    }

    let num;
    let result;

    if (selection === "1") {
      if (!n) {
        param.error = "Please Enter Numbers";
        return param;
      }
      num = eval(n);
      if (num < 0) {
        num = Math.abs(num);
        param.tech_iota = "iota";
      }
      result = Math.sqrt(num);
      param.tech_check = "sr";
    } else if (selection === "2") {
      if (!n1 || !rt) {
        param.error = "Please Enter Numbers";
        return param;
      }
      num = eval(n1);
      let root = eval(rt);

      if (num < 0 && root < 0) {
        param.error = "Please Enter Positive Numbers";
        return param;
      } else if (num < 0 && root === 2) {
        num = Math.abs(num);
        param.tech_iota = "iota";
      } else if (num < 0 && root % 2 === 0) {
        param.error = "Please Enter Positive Numbers";
        return param;
      } else {
        num = Math.abs(num);
      }

      result = Math.pow(num, 1 / root);
      param.tech_check = "gr";
      param.tech_root = root;
    } else {
      param.error = "Invalid selection";
      return param;
    }

    // Factorization for simplifying roots
    const primeFactor = (n) => {
      let factors = [];
      for (let i = 2; i <= Math.sqrt(n); i++) {
        while (n % i === 0) {
          factors.push(i);
          n /= i;
        }
      }
      if (n > 1) factors.push(n);
      return factors;
    };

    const isPerfectSquare = (n) => Number.isInteger(Math.sqrt(n));

    let radicand = num;
    let factors = primeFactor(radicand);
    let counts = factors.reduce((a, b) => {
      a[b] = (a[b] || 0) + 1;
      return a;
    }, {});

    let final = [],
      product = 1,
      valShow = [];

    for (let [prime, count] of Object.entries(counts)) {
      count = +count;
      if (count === 1) {
        final.push(+prime);
      } else if (count % 2 === 0) {
        final.push(Math.pow(prime, count));
        valShow.push(Math.pow(prime, count));
      } else {
        final.push(Math.pow(prime, count - 1));
        final.push(+prime);
        valShow.push(Math.pow(prime, count - 1));
      }
    }

    for (let v of final) {
      if (!isPerfectSquare(v)) {
        product *= v;
      }
    }

    let sqrShow = valShow.map((v) => Math.sqrt(v));

    // Build factor strings
    let factorArr = final.map((v) => v.toString());
    let productArr = final.map((v) =>
      isPerfectSquare(v) ? Math.sqrt(v).toString() : ""
    );
    let factor = factorArr.join(" * ");
    let factor1 = factorArr
      .map((v, i) => {
        let sq = productArr[i] ? "√" : "";
        return `${v} ${sq}`;
      })
      .join(" * ");

    param.tech_factor = factor;
    param.tech_factor1 = factor1;
    param.tech_product = product;
    param.tech_sqr_show = sqrShow;
    param.tech_result = result;
    param.tech_num = num;

    return param;
  }

  /** getCalculationBinaryCalculator
   * POST: /api/calculators-lol/binary-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationBinaryCalculator(body) {
    let bnr_tpe1 = body.tech_bnr_tpe1;
    let bnr_tpe2 = body.tech_bnr_tpe2;
    let bnr_frs = body.tech_bnr_frs;
    let bnr_sec = body.tech_bnr_sec;
    let bnr_slc = body.tech_bnr_slc;

    let param = {};

    function bnrType(nn, type) {
      if (type === "binary") {
        return parseInt(nn, 2);
      } else if (type === "decimal") {
        return parseInt(nn, 10);
      } else if (type === "hexadecimal") {
        return parseInt(nn, 16);
      } else if (type === "octal") {
        return parseInt(nn, 8);
      }
      return NaN;
    }

    let fN = bnrType(bnr_frs, bnr_tpe1);
    let sN = bnrType(bnr_sec, bnr_tpe2);

    function bnrCal(fN, sN, op) {
      let rN, dc, bn, hx, oc;

      if (op === "add") {
        rN = fN + sN;
      } else if (op === "sub") {
        rN = fN - sN;
      } else if (op === "mult") {
        rN = fN * sN;
      } else if (op === "divd") {
        rN = fN / sN;
      }

      dc = op === "divd" ? Math.round(rN) : rN;
      const absDc = Math.abs(dc);
      const sign = dc < 0 ? "-" : "";

      bn = sign + absDc.toString(2);
      hx = sign + absDc.toString(16).toUpperCase();
      oc = sign + absDc.toString(8);

      return [bn, dc, hx, oc];
    }

    const [bn, dc, hx, oc] = bnrCal(fN, sN, bnr_slc);

    param.tech_bn = bn;
    param.tech_dc = dc;
    param.tech_hx = hx;
    param.tech_oc = oc;

    return param;
  }

  /** getCalculationProportionCalculator
   * POST: /api/calculators-lol/proportion-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationProportionCalculator(body) {
    let a = body.tech_a;
    let b = body.tech_b;
    let c = body.tech_c;
    let d = body.tech_d;

    let param = {};

    if (a && b && c && d) {
      const isNumeric = (n) => !isNaN(parseFloat(n)) && isFinite(n);
      const isAlpha = (v) => typeof v === "string" && /^[a-zA-Z]+$/.test(v);

      if (isNumeric(a) && isNumeric(b) && isNumeric(c) && isNumeric(d)) {
        param.error =
          "Please! Enter the 3 numbers & use any letter for 1 unknown variable.";
        return param;
      } else if (isAlpha(a) && isNumeric(b) && isNumeric(c) && isNumeric(d)) {
        let a_val = (b * c) / d;
        param.tech_a_val = a_val;
      } else if (isNumeric(a) && isAlpha(b) && isNumeric(c) && isNumeric(d)) {
        let b_val = (a * d) / c;
        param.tech_b_val = b_val;
      } else if (isNumeric(a) && isNumeric(b) && isAlpha(c) && isNumeric(d)) {
        let c_val = (a * d) / b;
        param.tech_c_val = c_val;
      } else if (isNumeric(a) && isNumeric(b) && isNumeric(c) && isAlpha(d)) {
        let d_val = (b * c) / a;
        param.tech_d_val = d_val;
      } else {
        param.error = "Please! Check Your Input.";
        return param;
      }

      return param;
    } else {
      param.error = "Please Fill All the Fields!";
      return param;
    }
  }

  /**
   * getCalculationRatioCalculator: Service Method
   * POST: /api/calculators-lol/ratio-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRatioCalculator(body) {
    // Extract and trim input values
    const a = body.tech_a ? String(body.tech_a).trim() : "";
    const b = body.tech_b ? String(body.tech_b).trim() : "";
    const c = body.tech_c ? String(body.tech_c).trim() : "";
    const c1 = body.tech_c1 ? String(body.tech_c1).trim() : "";
    const d = body.tech_d ? String(body.tech_d).trim() : "";
    const e = body.tech_e ? String(body.tech_e).trim() : "";
    const f = body.tech_f ? String(body.tech_f).trim() : "";
    const i = body.tech_i ? String(body.tech_i).trim() : "";
    const ratio_of = body.tech_ratio_of
      ? String(body.tech_ratio_of).trim()
      : "";
    const method = body.tech_method ? String(body.tech_method).trim() : "";
    const method1 = body.tech_method1 ? String(body.tech_method1).trim() : "";

    const result = {};

    // Helper function to check if value is numeric
    function isNumeric(value) {
      return value != "" && value !== null && !isNaN(value);
    }

    // Helper function to check if value is empty
    function isEmpty(value) {
      return value == "" || value == null || value == undefined;
    }

    // Helper function to check if value is double/float
    function isDouble(value) {
      return typeof value == "number" && !Number.isInteger(value);
    }

    // GCD function for two numbers
    function gcd(a, b) {
      return b ? gcd(b, a % b) : a;
    }

    // GCD function for array of numbers
    function gcdArray(arr) {
      return arr.reduce((carry, item) => {
        return item ? gcd(item, carry % item) : carry;
      }, arr[0]);
    }

    // Ratio of 2 numbers (r2)
    if (method == "0" && ratio_of == "r2") {
      if (isNumeric(a) && isNumeric(b) && isNumeric(c) && isNumeric(d)) {
        result.error = "Please Enter 3 numbers & left 1 field empty!";
        return result;
      } else if (isEmpty(a) && isNumeric(b) && isNumeric(c) && isNumeric(d)) {
        const a_val = (Number(b) * Number(c)) / Number(d);
        result.tech_a_val = a_val;
      } else if (isNumeric(a) && isEmpty(b) && isNumeric(c) && isNumeric(d)) {
        const b_val = (Number(a) * Number(d)) / Number(c);
        result.tech_b_val = b_val;
      } else if (isNumeric(a) && isNumeric(b) && isEmpty(c) && isNumeric(d)) {
        const c_val = (Number(a) * Number(d)) / Number(b);
        result.tech_c_val = c_val;
      } else if (isNumeric(a) && isNumeric(b) && isNumeric(c) && isEmpty(d)) {
        const d_val = (Number(b) * Number(c)) / Number(a);
        result.tech_d_val = d_val;
      } else {
        result.error = "Please Check Input!";
        return result;
      }
      result.tech_r2 = "r2";
      return result;
    } else if (method == "1" && ratio_of == "r2") {
      if (isNumeric(a) && isNumeric(b) && isNumeric(i)) {
        const a_val1 = Number(a) * Number(i);
        const b_val1 = Number(b) * Number(i);
        result.tech_a_val1 = a_val1;
        result.tech_b_val1 = b_val1;
      } else {
        result.error = "Please Fill All The Fields!";
        return result;
      }
      result.tech_r2 = "r2";
      return result;
    } else if (method == "2" && ratio_of == "r2") {
      if (isNumeric(a) && isNumeric(b) && isNumeric(i)) {
        const a_val2 = Number(a) / Number(i);
        const b_val2 = Number(b) / Number(i);
        result.tech_a_val2 = a_val2;
        result.tech_b_val2 = b_val2;
      } else {
        result.error = "Please Fill All The Fields!";
        return result;
      }
      result.tech_r2 = "r2";
      return result;
    } else if (method == "3" && ratio_of == "r2") {
      if (isNumeric(a) && isNumeric(b)) {
        const gcf = gcd(Number(a), Number(b));
        const a_val3 = Number(a) / gcf;
        const b_val3 = Number(b) / gcf;

        if (gcf == 1) {
          result.tech_gcf = "gcf";
        }
        result.tech_a_val3 = a_val3;
        result.tech_b_val3 = b_val3;
      } else {
        result.error = "Please Fill All The Fields!";
        return result;
      }
      result.tech_r2 = "r2";
      return result;
    } else if (method == "4" && ratio_of == "r2") {
      if (isNumeric(a) && isNumeric(b)) {
        const a_val4 = Number(a) / Number(a);
        const b_val4 = Number(b) / Number(a);
        result.tech_a_val4 = a_val4;
        result.tech_b_val4 = b_val4;
      } else {
        result.error = "Please Fill All The Fields!";
        return result;
      }
      result.tech_r2 = "r2";
      return result;
    } else if (method == "5" && ratio_of == "r2") {
      if (isNumeric(a) && isNumeric(b)) {
        const a_val5 = Number(a) / Number(b);
        const b_val5 = Number(b) / Number(b);
        result.tech_a_val5 = a_val5;
        result.tech_b_val5 = b_val5;
      } else {
        result.error = "Please Fill All The Fields!";
        return result;
      }
      result.tech_r2 = "r2";
      return result;
    }

    // Ratio of 3 numbers (r3)
    else if (method1 == "0" && ratio_of == "r3") {
      if (
        (isNumeric(a) &&
          isNumeric(b) &&
          isNumeric(c1) &&
          isNumeric(d) &&
          isNumeric(e) &&
          isNumeric(f)) ||
        (isNumeric(a) &&
          isNumeric(b) &&
          isNumeric(c1) &&
          isNumeric(d) &&
          isNumeric(e)) ||
        (isNumeric(a) &&
          isNumeric(b) &&
          isNumeric(c1) &&
          isNumeric(d) &&
          isNumeric(f)) ||
        (isNumeric(a) &&
          isNumeric(b) &&
          isNumeric(c1) &&
          isNumeric(e) &&
          isNumeric(f))
      ) {
        result.error = "Please Check Input!";
        return result;
      } else if (
        isNumeric(a) &&
        isNumeric(b) &&
        isNumeric(c1) &&
        isNumeric(d)
      ) {
        const x = Number(d) / Number(a);
        const e_val = Number(b) * x;
        const f_val = Number(c1) * x;

        if (isDouble(e_val) || isDouble(f_val)) {
          result.tech_dbl = "dbl";
        }
        result.tech_r3 = "r3";
        result.tech_e_val = Math.round(e_val * 100000) / 100000; // round to 5 decimal places
        result.tech_f_val = Math.round(f_val * 100000) / 100000;
        return result;
      } else {
        result.error = "Please Check Input!";
        return result;
      }
    } else if (method1 == "1" && ratio_of == "r3") {
      if (isNumeric(a) && isNumeric(b) && isNumeric(c1) && isNumeric(i)) {
        const a_val1 = Number(a) * Number(i);
        const b_val1 = Number(b) * Number(i);
        const c_val1 = Number(c1) * Number(i);

        if (isDouble(a_val1) || isDouble(b_val1) || isDouble(c_val1)) {
          result.tech_dbl = "dbl";
        }
        result.tech_a_val1 = a_val1;
        result.tech_b_val1 = b_val1;
        result.tech_c_val1 = c_val1;
      } else {
        result.error = "Please Fill All The Fields!";
        return result;
      }
      result.tech_r3 = "r3";
      return result;
    } else if (method1 == "2" && ratio_of == "r3") {
      if (isNumeric(a) && isNumeric(b) && isNumeric(c1) && isNumeric(i)) {
        const a_val2 = Number(a) / Number(i);
        const b_val2 = Number(b) / Number(i);
        const c_val2 = Number(c1) / Number(i);

        if (isDouble(a_val2) || isDouble(b_val2) || isDouble(c_val2)) {
          result.tech_dbl = "dbl";
        }
        result.tech_a_val2 = a_val2;
        result.tech_b_val2 = b_val2;
        result.tech_c_val2 = c_val2;
      } else {
        result.error = "Please Fill All The Fields!";
        return result;
      }
      result.tech_r3 = "r3";
      return result;
    } else if (method1 == "3" && ratio_of == "r3") {
      if (isNumeric(a) && isNumeric(b) && isNumeric(c1)) {
        const arr = [Number(a), Number(b), Number(c1)];
        const gcf = gcdArray(arr);

        const a_val3 = Number(a) / gcf;
        const b_val3 = Number(b) / gcf;
        const c_val3 = Number(c1) / gcf;

        if (gcf == 1) {
          result.tech_gcf = "gcf";
        }
        if (isDouble(a_val3) || isDouble(b_val3) || isDouble(c_val3)) {
          result.tech_dbl = "dbl";
        }
        result.tech_a_val3 = a_val3;
        result.tech_b_val3 = b_val3;
        result.tech_c_val3 = c_val3;
      } else {
        result.error = "Please Fill All The Fields!";
        return result;
      }
      result.tech_r3 = "r3";
      return result;
    } else if (method1 == "4" && ratio_of == "r3") {
      if (isNumeric(a) && isNumeric(b) && isNumeric(c1)) {
        const a_val4 = Number(a) / Number(a);
        const b_val4 = Number(b) / Number(a);
        const c_val4 = Number(c1) / Number(a);

        if (isDouble(a_val4) || isDouble(b_val4) || isDouble(c_val4)) {
          result.tech_dbl = "dbl";
        }
        result.tech_a_val4 = a_val4;
        result.tech_b_val4 = b_val4;
        result.tech_c_val4 = c_val4;
      } else {
        result.error = "Please Fill All The Fields!";
        return result;
      }
      result.tech_r3 = "r3";
      return result;
    } else if (method1 == "5" && ratio_of == "r3") {
      if (isNumeric(a) && isNumeric(b) && isNumeric(c1)) {
        const a_val5 = Number(a) / Number(b);
        const b_val5 = Number(b) / Number(b);
        const c_val5 = Number(c1) / Number(b);

        if (isDouble(a_val5) || isDouble(b_val5) || isDouble(c_val5)) {
          result.tech_dbl = "dbl";
        }
        result.tech_a_val5 = a_val5;
        result.tech_b_val5 = b_val5;
        result.tech_c_val5 = c_val5;
      } else {
        result.error = "Please Fill All The Fields!";
        return result;
      }
      result.tech_r3 = "r3";
      return result;
    } else if (method1 == "6" && ratio_of == "r3") {
      if (isNumeric(a) && isNumeric(b) && isNumeric(c1)) {
        const a_val6 = Number(a) / Number(c1);
        const b_val6 = Number(b) / Number(c1);
        const c_val6 = Number(c1) / Number(c1);

        if (isDouble(a_val6) || isDouble(b_val6) || isDouble(c_val6)) {
          result.tech_dbl = "dbl";
        }
        result.tech_a_val6 = a_val6;
        result.tech_b_val6 = b_val6;
        result.tech_c_val6 = c_val6;
      } else {
        result.error = "Please Fill All The Fields!";
        return result;
      }
      result.tech_r3 = "r3";
      return result;
    } else {
      result.error = "Please Check Input!";
      return result;
    }
  }

  /** getCalculationLinearInterpolationCalculator
   * POST: /api/calculators-lol/linear-interpolation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLinearInterpolationCalculator(body) {
    let x1 = body.tech_x1;
    let y1 = body.tech_y1;
    let x2 = body.tech_x2;
    let y2 = body.tech_y2;
    let x3 = body.tech_x3;
    let y3 = body.tech_y3;

    let param = {};

    const isNumeric = (n) => !isNaN(parseFloat(n)) && isFinite(n);

    if (
      !x1 &&
      isNumeric(y1) &&
      isNumeric(x2) &&
      isNumeric(y2) &&
      isNumeric(x3) &&
      isNumeric(y3)
    ) {
      if (x2 != x3 && y1 != y2 && y2 != y3 && y1 != y3) {
        let s1 = y3 - y1;
        let s2 = x2 - x3;
        let s3 = y3 - y2;
        let s4 = s1 * s2;
        let s5 = s4 / s3;
        x1 = s5 + Number(x3);
        Object.assign(param, {
          tech_x1: x1,
          tech_s1: s1,
          tech_s2: s2,
          tech_s3: s3,
          tech_s4: s4,
          tech_s5: s5,
        });
      } else {
        param.error = "2 values should not be same.";
      }
    } else if (
      isNumeric(x1) &&
      !y1 &&
      isNumeric(x2) &&
      isNumeric(y2) &&
      isNumeric(x3) &&
      isNumeric(y3)
    ) {
      if (x1 != x2 && x2 != x3 && x1 != x3 && y2 != y3) {
        let s1 = x2 - x1;
        let s2 = y3 - y2;
        let s3 = x3 - x1;
        let s4 = s1 * s2;
        let s5 = s4 / s3;
        y1 = s5 + Number(y2);
        Object.assign(param, {
          tech_y1: y1,
          tech_s1: s1,
          tech_s2: s2,
          tech_s3: s3,
          tech_s4: s4,
          tech_s5: s5,
        });
      } else {
        param.error = "2 values should not be same.";
      }
    } else if (
      isNumeric(x1) &&
      isNumeric(y1) &&
      !x2 &&
      isNumeric(y2) &&
      isNumeric(x3) &&
      isNumeric(y3)
    ) {
      if (x1 != x3 && y1 != y2 && y2 != y3 && y1 != y3) {
        let s1 = y1 - y2;
        let s2 = x3 - x1;
        let s3 = y1 - y3;
        let s4 = s1 * s2;
        let s5 = s4 / s3;
        x2 = s5 + Number(x1);
        Object.assign(param, {
          tech_x2: x2,
          tech_s1: s1,
          tech_s2: s2,
          tech_s3: s3,
          tech_s4: s4,
          tech_s5: s5,
        });
      } else {
        param.error = "2 values should not be same.";
      }
    } else if (
      isNumeric(x1) &&
      isNumeric(y1) &&
      isNumeric(x2) &&
      !y2 &&
      isNumeric(x3) &&
      isNumeric(y3)
    ) {
      if (x1 != x2 && x2 != x3 && x1 != x3 && y1 != y3) {
        let s1 = x3 - x2;
        let s2 = y3 - y1;
        let s3 = x3 - x2;
        let s4 = s1 * s2;
        let s5 = s4 / s3;
        y2 = s5 + Number(y3);
        Object.assign(param, {
          tech_y2: y2,
          tech_s1: s1,
          tech_s2: s2,
          tech_s3: s3,
          tech_s4: s4,
          tech_s5: s5,
        });
      } else {
        param.error = "2 values should not be same.";
      }
    } else if (
      isNumeric(x1) &&
      isNumeric(y1) &&
      isNumeric(x2) &&
      isNumeric(y2) &&
      !x3 &&
      isNumeric(y3)
    ) {
      if (x1 != x2 && y1 != y2 && y2 != y3 && y1 != y3) {
        let s1 = y3 - y2;
        let s2 = x1 - x2;
        let s3 = y1 - y2;
        let s4 = s1 * s2;
        let s5 = s4 / s3;
        x3 = s5 + Number(x2);
        Object.assign(param, {
          tech_x3: x3,
          tech_s1: s1,
          tech_s2: s2,
          tech_s3: s3,
          tech_s4: s4,
          tech_s5: s5,
        });
      } else {
        param.error = "2 values should not be same.";
      }
    } else if (
      isNumeric(x1) &&
      isNumeric(y1) &&
      isNumeric(x2) &&
      isNumeric(y2) &&
      isNumeric(x3) &&
      !y3
    ) {
      if (x1 != x2 && x2 != x3 && x1 != x3 && y1 != y2) {
        let s1 = x3 - x1;
        let s2 = y2 - y1;
        let s3 = x2 - x1;
        let s4 = s1 * s2;
        let s5 = s4 / s3;
        y3 = s5 + Number(y1);
        Object.assign(param, {
          tech_y3: y3,
          tech_s1: s1,
          tech_s2: s2,
          tech_s3: s3,
          tech_s4: s4,
          tech_s5: s5,
        });
      } else {
        param.error = "2 values should not be same.";
      }
    } else {
      param.error = "Please! Check Your Input.";
    }

    return param;
  }

  /**
   * getCalculationIntervalNotationCalculator: Service Method
   * POST: /api/calculators-lol/interval-notation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationIntervalNotationCalculator(body) {
    let i = body.tech_i;
    const x = body.tech_x;
    const result = {};

    // Validation: Check for invalid characters (similar to regex in PHP)
    const invalidCharsRegex = /[<>&]/;
    if (!i || invalidCharsRegex.test(i)) {
      result.error = "Please Enter Valid Input.";
      return result;
    }

    if (i && x) {
      // Clean up the input string
      i = i.replace(/ /g, "");
      i = i.replace(/,,/g, ",");
      i = i.replace(/,\(/g, "(");
      i = i.replace(/,,\(/g, "(");
      i = i.replace(/\(,/g, "(");
      i = i.replace(/\(,,/g, "(");
      i = i.replace(/,\[/g, "[");
      i = i.replace(/,,\[/g, "[");
      i = i.replace(/\[,/g, "[");
      i = i.replace(/\[,,/g, "[");
      i = i.replace(/,\)/g, ")");
      i = i.replace(/,,\)/g, ")");
      i = i.replace(/\),/g, ")");
      i = i.replace(/\),,/g, ")");
      i = i.replace(/,\]/g, "]");
      i = i.replace(/,,\]/g, "]");
      i = i.replace(/\],/g, "]");
      i = i.replace(/\],,/g, "]");

      // Check for multiple commas
      const commaMatches = i.match(/,/g);
      if (commaMatches && commaMatches.length > 1) {
        result.error = "Please Enter Valid Input.";
        return result;
      }

      // Split by comma
      const arr = i.split(",");

      // Extract opening bracket
      const arr0Match = arr[0].match(/\(|\[/);
      if (!arr0Match) {
        result.error = "Please Enter Valid Input.";
        return result;
      }

      // Extract closing bracket
      const arr1Match = arr[1].match(/\)|\]/);
      if (!arr1Match) {
        result.error = "Please Enter Valid Input.";
        return result;
      }

      const arr0 = arr[0];
      const arr1 = arr[1];

      const arr00 = arr0.split(arr0Match[0]);
      const arr11 = arr1.split(arr1Match[0]);

      // Validate format
      if (arr00[0] != "") {
        result.error = "Please Enter Valid Input.";
        return result;
      }
      if (arr11[1] !== "" && arr11[1] !== undefined) {
        result.error = "Please Enter Valid Input.";
        return result;
      }

      const l = Number(arr00[1]);
      const r = Number(arr11[0]);

      if (!isNaN(l) && !isNaN(r)) {
        let lo, lc, ro, rc;

        // Check left bracket type
        const leftParenMatches = i.match(/\(/g);
        if (leftParenMatches) {
          if (leftParenMatches.length > 1) {
            result.error = "Please Enter Valid Input.";
            return result;
          } else {
            lo = "left open";
          }
        } else {
          const leftBracketMatches = i.match(/\[/g);
          if (leftBracketMatches) {
            if (leftBracketMatches.length > 1) {
              result.error = "Please Enter Valid Input.";
              return result;
            } else {
              lc = "left closed";
            }
          }
        }

        // Check right bracket type
        const rightParenMatches = i.match(/\)/g);
        if (rightParenMatches) {
          if (rightParenMatches.length > 1) {
            result.error = "Please Enter Valid Input.";
            return result;
          } else {
            ro = "right open";
          }
        } else {
          const rightBracketMatches = i.match(/\]/g);
          if (rightBracketMatches) {
            if (rightBracketMatches.length > 1) {
              result.error = "Please Enter Valid Input.";
              return result;
            } else {
              rc = "right closed";
            }
          }
        }

        result.tech_l = l;
        result.tech_r = r;

        let set = [];

        // Left open Right open
        if (lo && ro) {
          if (l > r) {
            if (l < 0 && r < 0) {
              for (let idx = r + 1; idx <= l - 1; idx++) {
                set.push(idx);
              }
            } else if (l < 0) {
              for (let idx = l + 1; idx <= r - 1; idx++) {
                set.push(idx);
              }
            } else {
              for (let idx = r + 1; idx <= l - 1; idx++) {
                set.push(idx);
              }
            }
          } else {
            if (l < 0 && r < 0) {
              for (let idx = l + 1; idx <= r - 1; idx++) {
                set.push(idx);
              }
            } else if (l < 0) {
              for (let idx = r + 1; idx <= l - 1; idx++) {
                set.push(idx);
              }
            } else {
              for (let idx = l + 1; idx <= r - 1; idx++) {
                set.push(idx);
              }
            }
          }
          result.tech_lo_ro = "lo_ro";
          result.tech_set = set;
        }
        // Left open Right closed
        else if (lo && rc) {
          if (l > r) {
            if (l < 0 && r < 0) {
              for (let idx = r; idx <= l - 1; idx++) {
                set.push(idx);
              }
            } else if (r < 0) {
              for (let idx = r; idx <= l - 1; idx++) {
                set.push(idx);
              }
            } else {
              for (let idx = r; idx <= l - 1; idx++) {
                set.push(idx);
              }
            }
          } else {
            if (l < 0 && r < 0) {
              for (let idx = l + 1; idx <= r; idx++) {
                set.push(idx);
              }
            } else if (r < 0) {
              for (let idx = r + 1; idx <= l - 1; idx++) {
                set.push(idx);
              }
            } else {
              for (let idx = l + 1; idx <= r; idx++) {
                set.push(idx);
              }
            }
          }
          result.tech_lo_rc = "lo_rc";
          result.tech_set = set;
        }
        // Left closed Right open
        else if (lc && ro) {
          if (l > r) {
            if (l < 0 && r < 0) {
              for (let idx = r + 1; idx <= l; idx++) {
                set.push(idx);
              }
            } else if (r < 0) {
              for (let idx = r + 1; idx <= l; idx++) {
                set.push(idx);
              }
            } else {
              for (let idx = r + 1; idx <= l; idx++) {
                set.push(idx);
              }
            }
          } else {
            if (l < 0 && r < 0) {
              for (let idx = l; idx <= r - 1; idx++) {
                set.push(idx);
              }
            } else if (l < 0) {
              for (let idx = l; idx <= r - 1; idx++) {
                set.push(idx);
              }
            } else {
              for (let idx = l; idx <= r - 1; idx++) {
                set.push(idx);
              }
            }
          }
          result.tech_lc_ro = "lc_ro";
          result.tech_set = set;
        }
        // Left closed Right closed
        else if (lc && rc) {
          if (l > r) {
            if (l < 0) {
              for (let idx = r; idx <= l; idx++) {
                set.push(idx);
              }
            } else {
              for (let idx = r; idx <= l; idx++) {
                set.push(idx);
              }
            }
          } else {
            if (l < 0 && r < 0) {
              for (let idx = l; idx <= r; idx++) {
                set.push(idx);
              }
            } else if (l < 0) {
              for (let idx = l; idx <= r; idx++) {
                set.push(idx);
              }
            } else {
              for (let idx = l; idx <= r; idx++) {
                set.push(idx);
              }
            }
          }
          result.tech_lc_rc = "lc_rc";
          result.tech_set = set;
        }
      } else {
        result.error = "Please Enter Valid Input.";
        return result;
      }

      return result;
    } else {
      result.error = "Please Enter Valid Input.";
      return result;
    }
  }

  /** getCalculationPythagoreanTheoremCalculator
   * POST: /api/calculators-lol/pythagorean-theorem-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPythagoreanTheoremCalculator(body) {
    let one = body.tech_one;
    let two = body.tech_two;
    let forSide = body.tech_for; // renamed to avoid JS keyword `for`
    let nbr = body.tech_nbr;

    let param = {};

    const isNumeric = (n) => !isNaN(parseFloat(n)) && isFinite(n);

    if (isNumeric(one) && isNumeric(two) && isNumeric(nbr)) {
      one = parseFloat(one);
      two = parseFloat(two);
      nbr = parseInt(nbr);

      let a, b, c;

      if (forSide === "a") {
        b = one;
        c = two;
        a = +Math.sqrt(Math.pow(c, 2) - Math.pow(b, 2)).toFixed(nbr);
      } else if (forSide === "b") {
        a = one;
        c = two;
        b = +Math.sqrt(Math.pow(c, 2) - Math.pow(a, 2)).toFixed(nbr);
      } else if (forSide === "c" || forSide === "ar") {
        a = one;
        b = two;
        c = +Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2)).toFixed(nbr);
      } else {
        param.error = 'Invalid "for" parameter.';
        return param;
      }

      let area = +((a * b) / 2).toFixed(nbr);
      let peri = +(a + b + c).toFixed(nbr);
      let h = +((a * b) / c).toFixed(nbr);
      let alfa = +Math.asin(a / c).toFixed(nbr);
      let a_deg = +(alfa * (180 / Math.PI)).toFixed(nbr);
      let beta = +Math.asin(b / c).toFixed(nbr);
      let b_deg = +(beta * (180 / Math.PI)).toFixed(nbr);

      Object.assign(param, {
        tech_a: a,
        tech_b: b,
        tech_c: c,
        tech_area: area,
        tech_peri: peri,
        tech_h: h,
        tech_alfa: alfa,
        tech_a_deg: a_deg,
        tech_beta: beta,
        tech_b_deg: b_deg,
      });
    } else {
      param.error = "Please Check Your Input.";
    }

    return param;
  }

  /** getCalculationUnitCircleCalculator
   * POST: /api/calculators-lol/unit-circle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationUnitCircleCalculator(body) {
    let angle = body.tech_angle;
    let angle_unit = body.tech_angle_unit;

    let param = {};

    const isNumeric = (n) => !isNaN(parseFloat(n)) && isFinite(n);

    if (isNumeric(angle) && angle_unit) {
      angle = parseFloat(angle);

      if (angle_unit === "rad") {
        angle = angle * (180 / Math.PI); // rad to deg
      } else if (angle_unit === "pirad") {
        angle = angle * Math.PI; // π*rad
        angle = angle * (180 / Math.PI); // to deg
      }

      const radians = angle * (Math.PI / 180); // deg to rad
      const sin = Math.sin(radians);
      const cos = Math.cos(radians);
      const tan = Math.tan(radians);

      param.tech_sin = +sin.toFixed(8);
      param.tech_cos = +cos.toFixed(8);
      param.tech_tan = +tan.toFixed(8);
    } else {
      param.error = "Please! Check Your Input.";
    }

    return param;
  }

  /** getCalculationLaplaceTransformCalculator
   * POST: /api/calculators-lol/laplace-transform-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLaplaceTransformCalculator(body) {
    let enterEq = body.tech_EnterEq;

    // Input validation
    if (!enterEq || /[<>&]|php|print_r|print|echo|script|=|%/i.test(enterEq)) {
      return { error: "Please! Check Your Input." };
    }

    // Prepare equation
    let parem = enterEq
      .replace(/ /g, "")
      .replace(/f\(t\)=/g, "")
      .replace(/\+/g, "plus")
      .replace(/%20/g, "")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    try {
      const response = await axios.post(
        "http://167.172.134.148/new-laplace",
        new URLSearchParams({ equ: parem }),
        { timeout: 120000 }
      );

      const buffer = response.data;

      return {
        tech_ans: buffer[0],
        tech_enter: buffer[1],
      };
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationInflectionPointCalculator
   * POST: /api/calculators-lol/inflection-point-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationInflectionPointCalculator(body) {
    let eq = body.tech_eq;

    // Input validation
    if (!eq || /[<>&]|php|print_r|print|echo|script|=|%/i.test(eq)) {
      return { error: "Please! Check Your Input." };
    }

    // Prepare equation
    let parem = eq
      .replace(/ /g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    try {
      const response = await axios.post(
        "http://167.172.134.148/new-inflection",
        new URLSearchParams({ equ: parem }),
        { timeout: 120000 }
      );

      const buffer = response.data;
      const result = {};

      if (buffer.length <= 1) {
        return { error: "Please! Check Your Input." };
      } else if (buffer.length <= 8) {
        result.no = "no";
      } else if (buffer.length === 11) {
        result.tech_ip_1 = "ip_1";
        result.tech_ip1 = parseFloat(buffer[7]).toFixed(3);
        result.tech_ip11 = parseFloat(buffer[8]).toFixed(3);
        result.tech_root = buffer[9];
        result.tech_iptype = buffer[10];
      } else {
        result.tech_ip1 = parseFloat(buffer[7]).toFixed(3);
        result.tech_ip11 = parseFloat(buffer[8]).toFixed(3);
        result.tech_ip2 = parseFloat(buffer[9]).toFixed(3);
        result.tech_ip22 = parseFloat(buffer[10]).toFixed(3);
        result.tech_root = buffer[11];
        result.tech_iptype = buffer[12];
      }

      result.tech_enter = buffer[0];
      result.tech_diff = buffer[1];
      result.tech_step = buffer[2];
      result.tech_diff1 = buffer[3];
      result.tech_step1 = buffer[4];
      result.tech_diff2 = buffer[5];
      result.tech_step2 = buffer[6];

      return result;
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationArcLengthCalculator
   * POST: /api/calculators-lol/arc-length-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationArcLengthCalculator(body) {
    let find = body.tech_find;
    let angle = body.tech_angle;
    let angle_unit = body.tech_angle_unit;
    let rad = body.tech_rad;
    let rad_unit = body.tech_rad_unit;
    let diameter = body.tech_diameter;
    let diameter_unit = body.tech_diameter_unit;
    let area = body.tech_area;
    let area_unit = body.tech_area_unit;
    let chrd_len = body.tech_chrd_len;
    let chrd_len_unit = body.tech_chrd_len_unit;
    let seg_height = body.tech_seg_height;
    let seg_height_unit = body.tech_seg_height_unit;

    let param = {};

    function toRadians(degrees) {
      return degrees * (Math.PI / 180);
    }

    // Angle unit conversion
    if (!isNaN(angle)) {
      if (angle_unit === "deg") angle = angle / 57.2958;
      else if (angle_unit === "gon") angle = angle / 63.662;
      else if (angle_unit === "tr") angle = angle / 0.159155;
      else if (angle_unit === "arcmin") angle = angle / 3437.75;
      else if (angle_unit === "arcsec") angle = angle / 206265;
      else if (angle_unit === "mrad") angle = angle / 1000;
      else if (angle_unit === "urad") angle = angle / 1000000;
      else if (angle_unit === "pirad") angle = angle / 0.31831;
    }

    // Convert length units to meters
    function convertToMeters(value, unit) {
      if (isNaN(value)) return value;
      const conversions = {
        mm: 1 / 1000,
        cm: 1 / 100,
        km: 1000,
        in: 1 / 39.3701,
        ft: 1 / 3.28084,
        yd: 1 / 1.093613,
        mi: 1 / 0.000621371,
        nmi: 1 / 0.000539957,
      };
      return value * (conversions[unit] || 1);
    }

    rad = convertToMeters(rad, rad_unit);
    diameter = convertToMeters(diameter, diameter_unit);
    chrd_len = convertToMeters(chrd_len, chrd_len_unit);
    seg_height = convertToMeters(seg_height, seg_height_unit);

    // Area unit conversion to square meters
    if (!isNaN(area)) {
      const conversions = {
        mm2: 1 / 1e6,
        cm2: 1 / 1e4,
        dm2: 1 / 100,
        km2: 1e6,
        in2: 1 / 1550.003,
        ft2: 1 / 10.7639,
        yd2: 1 / 1.19599,
        mi2: 1 / 0.000000386102,
        a: 1 / 0.01,
        da: 1 / 0.001,
        ha: 1 / 0.0001,
        ac: 1 / 0.0002471054,
        s_f: 1 / 0.000140056,
      };
      area *= conversions[area_unit] || 1;
    }

    let arc_len;

    function round(val, dec) {
      return Math.round(val * Math.pow(10, dec)) / Math.pow(10, dec);
    }

    try {
      switch (find) {
        case "0":
          if (!isNaN(angle) && !isNaN(rad)) {
            diameter = rad * 2;
            area = Math.pow(rad, 2) * (angle / 2);
            arc_len = rad * angle;
            chrd_len = 2 * rad * Math.sin(angle / 2);
            Object.assign(param, {
              tech_arc_len: round(arc_len, 5),
              tech_diameter: round(diameter, 3),
              tech_area: round(area, 4),
              tech_chrd_len: round(chrd_len, 3),
            });
          } else throw "Check Input";
          break;
        case "1":
          if (!isNaN(rad) && !isNaN(seg_height)) {
            if (rad < 10) throw "Radius cannot be less than 10!";
            angle = 2 * Math.acos(1 - seg_height / rad);
            diameter = rad * 2;
            area = Math.pow(rad, 2) * (angle / 2);
            arc_len = rad * angle;
            Object.assign(param, {
              tech_arc_len: round(arc_len, 5),
              tech_angle: round(angle, 5),
              tech_diameter: round(diameter, 3),
              tech_area: round(area, 4),
              tech_chrd_len: round(chrd_len, 3),
            });
          } else throw "Check Input";
          break;
        case "2":
          if (!isNaN(rad) && !isNaN(area)) {
            angle = (2 * area) / Math.pow(rad, 2);
            diameter = rad * 2;
            arc_len = rad * angle;
            chrd_len = 2 * rad * Math.sin(angle / 2);
            if (angle_unit === "deg") angle *= 57.2958;
            area = Math.pow(rad, 2) * (angle / 2);
            Object.assign(param, {
              tech_arc_len: round(arc_len, 5),
              tech_angle: round(angle, 4),
              tech_diameter: round(diameter, 3),
              tech_chrd_len: round(chrd_len, 3),
              tech_area: round(area, 3),
            });
          } else throw "Check Input";
          break;
        case "3":
          if (!isNaN(rad) && !isNaN(chrd_len)) {
            area = Math.pow(rad, 2) * (angle / 2);
            angle = (2 * area) / Math.pow(rad, 2);
            diameter = rad * 2;
            arc_len = rad * angle;
            if (angle_unit === "deg") angle *= 57.2958;
            Object.assign(param, {
              tech_arc_len: round(arc_len, 5),
              tech_angle: round(angle, 4),
              tech_diameter: round(diameter, 3),
              tech_area: round(area, 4),
            });
          } else throw "Check Input";
          break;
        case "4":
          if (!isNaN(angle) && !isNaN(diameter)) {
            rad = diameter / 2;
            area = Math.pow(rad, 2) * (angle / 2);
            arc_len = rad * angle;
            Object.assign(param, {
              tech_arc_len: round(arc_len, 5),
              tech_rad: round(rad, 4),
              tech_diameter: round(diameter, 3),
              tech_area: round(area, 4),
            });
          } else throw "Check Input";
          break;
        case "5":
          if (!isNaN(angle) && !isNaN(area)) {
            rad = Math.sqrt((2 * area) / angle);
            diameter = rad * 2;
            arc_len = rad * angle;
            chrd_len = 2 * rad * Math.sin(angle / 2);
            Object.assign(param, {
              tech_arc_len: round(arc_len, 5),
              tech_rad: round(rad, 4),
              tech_diameter: round(diameter, 3),
              tech_chrd_len: round(chrd_len, 3),
            });
          } else throw "Check Input";
          break;
        case "6":
          if (!isNaN(angle) && !isNaN(chrd_len)) {
            rad = chrd_len / (2 * Math.sin(angle / 2));
            diameter = rad * 2;
            area = Math.pow(rad, 2) * (angle / 2);
            arc_len = rad * angle;
            Object.assign(param, {
              tech_arc_len: round(arc_len, 5),
              tech_rad: round(rad, 4),
              tech_diameter: round(diameter, 3),
              tech_area: round(area, 4),
            });
          } else throw "Check Input";
          break;
        default:
          if (!isNaN(chrd_len) && !isNaN(seg_height)) {
            rad = seg_height / 2 + Math.pow(chrd_len, 2) / (8 * seg_height);
            angle = 2 * Math.asin(chrd_len / (2 * rad));
            diameter = rad * 2;
            area = Math.pow(rad, 2) * (angle / 2);
            arc_len = rad * angle;
            Object.assign(param, {
              tech_arc_len: round(arc_len, 5),
              tech_angle: round(angle, 4),
              tech_rad: round(rad, 4),
              tech_diameter: round(diameter, 3),
              tech_area: round(area, 4),
            });
          } else throw "Check Input";
      }

      return param;
    } catch (err) {
      return { error: err };
    }
  }

  /** getCalculationArcsinCalculator
   * POST: /api/calculators-lol/arcsin-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationArcsinCalculator(body) {
    let arcsin = body.tech_arcsin;
    let round = body.tech_round;

    let param = {};

    function DDtoDMS(dec) {
      let [degPart, fracPart] = dec.toString().split(".");
      let deg = parseInt(degPart);
      let min = 0;
      let sec = 0;

      if (fracPart !== undefined) {
        let tempma = parseFloat("0." + fracPart) * 3600;
        min = Math.floor(tempma / 60);
        sec = Math.round(tempma - min * 60 * 1000) / 1000;
      }

      return { deg, min, sec };
    }

    if (!isNaN(arcsin) && !isNaN(round)) {
      let rad = Math.asin(arcsin);
      let deg = rad * (180 / Math.PI);
      let gon = rad * 63.66;
      let tr = rad * 0.15915;
      let arcmin = rad * 3438;
      let arcsec = rad * 206265;
      let mrad = rad * 1000;
      let urad = rad * 1000000;
      let pirad = rad * 0.3183;

      let DMS = DDtoDMS(deg);
      let d = DMS.deg;
      let m = DMS.min;
      let s = DMS.sec;

      param.tech_angle = +deg.toFixed(1);
      param.tech_rad = +rad.toFixed(round);
      param.tech_gon = +gon.toFixed(round);
      param.tech_tr = +tr.toFixed(round);
      param.tech_arcmin = +arcmin.toFixed(round);
      param.tech_arcsec = +arcsec.toFixed(round);
      param.tech_mrad = +mrad.toFixed(round);
      param.tech_urad = +urad.toFixed(round);
      param.tech_pirad = +pirad.toFixed(round);
      param.tech_deg = +d.toFixed(round);
      param.tech_min = +m.toFixed(round);
      param.tech_sec = +s.toFixed(round);
    } else {
      param.error = "Please! Check Your Input.";
    }

    return param;
  }

  /** getCalculationBinomialTheoremCalculator
   * POST: /api/calculators-lol/binomial-theorem-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationBinomialTheoremCalculator(body) {
    let enterEq = body.tech_enter_eq;
    let x = body.tech_x;

    // Input validation
    if (!enterEq || /[<>&]|php|print_r|print|echo|script|=|%/i.test(enterEq)) {
      return { error: "Please! Check Your Input." };
    }

    if (!isFinite(x)) {
      return { error: "Please! Check Your Input." };
    }

    // Format equation
    let parem = enterEq
      .replace(/ /g, "")
      .replace(/\+/g, "plus")
      .replace(/%20/g, "")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    // Final binomial expression
    parem = `(${parem})**${x}`;

    try {
      const response = await axios.post(
        "http://167.172.134.148/new-binomial",
        new URLSearchParams({
          equ: parem,
          x: x,
        }),
        { timeout: 120000 }
      );

      const buffer = response.data;

      return {
        tech_eq: buffer[1],
        tech_ans: buffer[0],
      };
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationCosineCalculator
   * POST: /api/calculators-lol/cosine-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCosineCalculator(body) {
    let angle = body.tech_angle;
    let angle_unit = body.tech_angle_unit;

    let param = {};

    if (angle !== undefined && angle !== null && angle !== "") {
      let rad;

      if (angle_unit === "deg") {
        rad = angle * (Math.PI / 180);
      } else if (angle_unit === "pirad") {
        rad = angle * Math.PI;
      } else if (angle_unit === "mrad") {
        rad = angle / 1000;
      } else {
        rad = angle; // assume already in radians
      }

      let cos = Math.cos(rad);

      param.tech_cos = +cos.toFixed(8);
    } else {
      param.error = "Please! Check Your Input.";
    }

    return param;
  }

  /** getCalculationSineCalculator
   * POST: /api/calculators-lol/sine-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSineCalculator(body) {
    let angle = body.tech_angle;
    let angle_unit = body.tech_angle_unit;

    let param = {};

    if (!isNaN(angle)) {
      let rad;

      if (angle_unit === "deg") {
        rad = angle * (Math.PI / 180);
      } else if (angle_unit === "pirad") {
        rad = angle * Math.PI;
      } else {
        rad = angle; // assume already in radians
      }

      let sin = Math.sin(rad);

      param.tech_sin = +sin.toFixed(8);
    } else {
      param.error = "Please! Check Your Input.";
    }

    return param;
  }

  /** getCalculationArccosCalculator
   * POST: /api/calculators-lol/arccos-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationArccosCalculator(body) {
    let arccos = body.tech_arccos;
    let round = body.tech_round;

    let param = {};

    if (!isNaN(arccos) && !isNaN(round)) {
      function DDtoDMS(dec) {
        let parts = dec.toString().split(".");
        let deg = parseInt(parts[0]);
        let min = 0,
          sec = 0;

        if (parts.length > 1) {
          let fractional = parseFloat("0." + parts[1]);
          let totalSeconds = fractional * 3600;
          min = Math.floor(totalSeconds / 60);
          sec = +(totalSeconds - min * 60).toFixed(3);
        }

        return { deg, min, sec };
      }

      let rad = Math.acos(arccos);
      let deg = rad * (180 / Math.PI);
      let gon = rad * 63.66;
      let tr = rad * 0.15915;
      let arcmin = rad * 3438;
      let arcsec = rad * 206265;
      let mrad = rad * 1000;
      let urad = rad * 1000000;
      let pirad = rad * 0.3183;

      let DMS = DDtoDMS(deg);
      let d = DMS.deg;
      let m = DMS.min;
      let s = DMS.sec;

      param.tech_angle = +deg.toFixed(1);
      param.tech_rad = +rad.toFixed(round);
      param.tech_gon = +gon.toFixed(round);
      param.tech_tr = +tr.toFixed(round);
      param.tech_arcmin = +arcmin.toFixed(round);
      param.tech_arcsec = +arcsec.toFixed(round);
      param.tech_mrad = +mrad.toFixed(round);
      param.tech_urad = +urad.toFixed(round);
      param.tech_pirad = +pirad.toFixed(round);
      param.tech_deg = +d.toFixed(round);
      param.tech_min = +m.toFixed(round);
      param.tech_sec = +s.toFixed(round);
    } else {
      param.error = "Please! Check Your Input.";
    }

    return param;
  }

  /** getCalculationArctanCalculator
   * POST: /api/calculators-lol/arctan-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationArctanCalculator(body) {
    let arctan = body.tech_arctan;
    let round = body.tech_round;

    let param = {};

    if (!isNaN(arctan) && !isNaN(round)) {
      function DDtoDMS(dec) {
        let parts = dec.toString().split(".");
        let deg = parseInt(parts[0]);
        let min = 0,
          sec = 0;

        if (parts.length > 1) {
          let fractional = parseFloat("0." + parts[1]);
          let totalSeconds = fractional * 3600;
          min = Math.floor(totalSeconds / 60);
          sec = +(totalSeconds - min * 60).toFixed(3);
        }

        return { deg, min, sec };
      }

      let rad = Math.atan(arctan);
      let deg = rad * (180 / Math.PI);
      let gon = rad * 63.66;
      let tr = rad * 0.15915;
      let arcmin = rad * 3438;
      let arcsec = rad * 206265;
      let mrad = rad * 1000;
      let urad = rad * 1000000;
      let pirad = rad * 0.3183;

      let DMS = DDtoDMS(deg);
      let d = DMS.deg;
      let m = DMS.min;
      let s = DMS.sec;

      param.tech_angle = +deg.toFixed(round);
      param.tech_rad = +rad.toFixed(round);
      param.tech_gon = +gon.toFixed(round);
      param.tech_tr = +tr.toFixed(round);
      param.tech_arcmin = +arcmin.toFixed(round);
      param.tech_arcsec = +arcsec.toFixed(round);
      param.tech_mrad = +mrad.toFixed(round);
      param.tech_urad = +urad.toFixed(round);
      param.tech_pirad = +pirad.toFixed(round);
      param.tech_deg = +d.toFixed(round);
      param.tech_min = +m.toFixed(round);
      param.tech_sec = +s.toFixed(round);
    } else {
      param.error = "Please! Check Your Input.";
    }

    return param;
  }

  /** getCalculationTangentCalculator
   * POST: /api/calculators-lol/tangent-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationTangentCalculator(body) {
    let angle = body.tech_angle;
    let angle_unit = body.tech_angle_unit;

    let param = {};

    if (!isNaN(angle)) {
      if (angle_unit === "deg") {
        angle = angle * (Math.PI / 180); // convert to radians
      } else if (angle_unit === "pirad") {
        angle = angle * Math.PI;
      } else if (angle_unit === "mrad") {
        angle = angle / 1000;
      }

      let tan = Math.tan(angle);
      param.tech_tan = +tan.toFixed(8);
    } else {
      param.error = "Please! Check Your Input.";
    }

    return param;
  }

  /** getCalculationSecantCalculator
   * POST: /api/calculators-lol/secant-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationSecantCalculator(body) {
    let angle = body.tech_angle;
    let angle_unit = body.tech_angle_unit;

    let result = {};

    if (typeof angle === "number") {
      let radian;

      if (angle_unit === "deg") {
        radian = angle * (Math.PI / 180); // deg to rad
      } else if (angle_unit === "pirad") {
        radian = angle * Math.PI;
      } else {
        radian = angle; // assume already in radians
      }

      let cosine = Math.cos(radian);
      let sec = 1 / cosine;

      // Handle Infinity or extremely large values
      sec = Math.abs(sec) > 1e10 ? Infinity : sec;

      result.tech_sec = Number(sec.toFixed(8));
    } else {
      result.error = "Please! Check Your Input.";
    }

    return result;
  }

  /** getCalculationCscCalculator
   * POST: /api/calculators-lol/csc-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCscCalculator(body) {
    let angle = body.tech_angle;
    let angle_unit = body.tech_angle_unit;

    let result = {};

    if (!isNaN(angle)) {
      let csc;

      if (angle_unit === "deg") {
        csc = 1 / Math.sin((angle * Math.PI) / 180);
      } else if (angle_unit === "pirad") {
        angle = angle * Math.PI;
        csc = 1 / Math.sin(angle);
      } else {
        csc = 1 / Math.sin(angle);
      }

      result.tech_csc = Number(csc.toFixed(8));
    } else {
      result.error = "Please! Check Your Input.";
    }

    return result;
  }

  /** getCalculationCotangentCalculator
   * POST: /api/calculators-lol/cotangent-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCotangentCalculator(body) {
    let angle = parseFloat(body.tech_angle);
    let angle_unit = body.tech_angle_unit;
    let result = {};

    if (!isNaN(angle)) {
      let cot;

      if (angle_unit === "deg") {
        cot = 1 / Math.tan((angle * Math.PI) / 180);
      } else if (angle_unit === "pirad") {
        angle = angle * Math.PI;
        cot = 1 / Math.tan(angle);
      } else if (angle_unit === "mrad") {
        angle = angle / 1000;
        cot = 1 / Math.tan(angle);
      } else {
        cot = 1 / Math.tan(angle);
      }

      result.tech_cot = Number(cot.toFixed(8));
    } else {
      result.error = "Please! Check Your Input.";
    }

    return result;
  }

  /** getCalculationAreaBetweenTwoCurvesCalculator
   * POST: /api/calculators-lol/area-between-two-curves-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAreaBetweenTwoCurvesCalculator(body) {
    let EnterEq1 = body.tech_enter_eq1;
    let EnterEq2 = body.tech_enter_eq2;
    let wrt = body.tech_with;
    let ub = body.tech_upper;
    let lb = body.tech_lower;

    let result = {};
    const unsafePattern = /<|>|&|php|print_r|print|echo|script|=|%/i;

    // Input validation
    if (
      !EnterEq1 ||
      !EnterEq2 ||
      !lb ||
      !ub ||
      unsafePattern.test(EnterEq1) ||
      unsafePattern.test(EnterEq2)
    ) {
      result.error = "Please! Check Your Input.";
      return result;
    }

    // Compose expression
    let parem = `(${EnterEq1})-(${EnterEq2})`
      .replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/%20/g, "")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    // Clean bounds
    ub = ub.toString().replace(/inf|∞/gi, "oo");
    lb = lb.toString().replace(/inf|∞/gi, "oo");
    if (ub === "e") ub = "2.71828";
    if (lb === "e") lb = "2.71828";

    try {
      const response = await axios.post(
        "http://167.172.134.148/new-area",
        new URLSearchParams({
          equ: parem,
          wrt: wrt,
          ub: ub,
          lb: lb,
        }),
        { timeout: 120000 }
      );

      const buffer = response.data;

      parem = parem
        .replace(/plus/g, "+")
        .replace(/\*\*/g, "^")
        .replace(/"/g, "");

      result.tech_enter = parem;
      result.tech_with = wrt;
      result.tech_ub = ub;
      result.tech_lb = lb;
      result.tech_ans = buffer[0];
      result.tech_ans1 = buffer[1];
      result.tech_steps = buffer[2];

      return result;
    } catch (error) {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /** getCalculationECalculator
   * POST: /api/calculators-lol/e-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationECalculator(body) {
    let cal = body.tech_cal;
    let x = parseFloat(body.tech_x);
    let a = parseFloat(body.tech_a);
    let result = {};

    if (!isNaN(x)) {
      let exp;

      if (cal === "ex") {
        exp = Math.exp(x);
      } else if (cal === "10x") {
        exp = Math.pow(10, x);
      } else if (cal === "ax" && !isNaN(a)) {
        exp = Math.pow(a, x);
      } else {
        result.error = "Please Check Your Input.";
        return result;
      }

      result.tech_exp = exp;
    } else {
      result.error = "Please Check Your Input.";
    }

    return result;
  }

  /**
   * getCalculationFactoringCalculator: Service Method
   * POST: /api/calculators-lol/factoring-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationFactoringCalculator(body) {
    let submit = body.tech_type;
    let num1 = body.tech_num1;
    let num2 = body.tech_num2;
    let eq = body.tech_eq;

    const param = {};

    // Helper function to find divisors
    function printDivisors(n) {
      const divi = [];
      for (let i = 1; i <= n; i++) {
        if (n % i === 0) {
          divi.push(i.toString());
        }
      }
      return divi;
    }

    if (submit == "factor") {
      if (!isNaN(num1) || !isNaN(num2)) {
        // Process num1
        if (!isNaN(num1) && num1) {
          let newnum = parseInt(num1);
          if (newnum > 10000000) {
            param.error = "Number is too large.";
            return param;
          }

          let newtext = "";
          let csv = "";
          let chk = 2;
          let prime = 0;

          while (chk * chk <= newnum) {
            if (newnum % chk == 0) {
              newtext += chk;
              csv += chk;
              newnum = newnum / chk;
              if (newnum !== 1) {
                newtext += " × ";
                csv += " , ";
              }
            } else {
              chk++;
            }
          }

          if (newnum != 1) {
            newtext += newnum;
            csv += newnum;
          }

          if (newtext == num1.toString()) {
            newtext += " is a Prime number.";
            prime = 1;
          }

          if (prime != 1) {
            let number = parseInt(num1);
            const divid = newtext.split(" × ");
            let tree = `<tr><td class='py-2 text-center'>${number}</td><td class='py-2'>&nbsp;</td></tr>`;

            divid.forEach((value) => {
              if (parseInt(value) !== number) {
                number = number / parseInt(value);
                tree += `<tr><td class='py-2'>| </td><td class='py-2'>\\ </td></tr><tr><td class='py-2'>${number}</td><td class='py-2'>${value}</td></tr>`;
              }
            });
            param.tech_tree1 = tree;
          }

          param.tech_Factors1 = newtext;
          param.tech_csv1 = csv;
        }

        // Process num2
        if (!isNaN(num2) && num2) {
          let newnum2 = parseInt(num2);
          if (newnum2 > 10000000) {
            param.error = "Number is too large.";
            return param;
          }

          let newtext2 = "";
          let csv2 = "";
          let chk2 = 2;
          let prime2 = 0;

          while (chk2 * chk2 <= newnum2) {
            if (newnum2 % chk2 == 0) {
              newtext2 += chk2;
              csv2 += chk2;
              newnum2 = newnum2 / chk2;
              if (newnum2 != 1) {
                newtext2 += " × ";
                csv2 += " , ";
              }
            } else {
              chk2++;
            }
          }

          if (newnum2 != 1) {
            newtext2 += newnum2;
            csv2 += newnum2;
          }

          if (newtext2 == num2.toString()) {
            newtext2 += " is a Prime number.";
            prime2 = 1;
          }

          if (prime2 != 1) {
            let number2 = parseInt(num2);
            const divid2 = newtext2.split(" × ");
            let tree2 = `<tr><td class='py-2 text-center'>${number2}</td><td class='py-2'>&nbsp;</td></tr>`;

            divid2.forEach((value2) => {
              if (parseInt(value2) != number2) {
                number2 = number2 / parseInt(value2);
                tree2 += `<tr><td class='py-2'>| </td><td class='py-2'>\\ </td></tr><tr><td class='py-2'>${number2}</td><td class='py-2'>${value2}</td></tr>`;
              }
            });
            param.tech_tree2 = tree2;
          }

          param.tech_Factors2 = newtext2;
          param.tech_csv2 = csv2;
        }
        param.tech_submit = submit;
      } else {
        param.error = "Please Enter a Number.";
        return param;
      }
    } else {
      // Equation factoring
      const variables_list = [];
      const letters = [
        "x",
        "a",
        "b",
        "c",
        "d",
        "f",
        "g",
        "h",
        "i",
        "j",
        "k",
        "l",
        "m",
        "n",
        "o",
        "p",
        "q",
        "r",
        "s",
        "t",
        "u",
        "v",
        "w",
        "y",
        "z",
      ];

      letters.forEach((letter) => {
        const regex = new RegExp(letter, "i");
        if (regex.test(eq)) {
          variables_list.push(letter);
        }
      });

      if (variables_list.length == 1) {
        // Validate input
        if (/<|>|&|php|print_r|print|echo|script|=|%/i.test(eq)) {
          param.error = "Please! Check Your Input.";
          return param;
        }

        let parem = eq;
        parem = parem.replace(/\s/g, "");
        parem = parem.replace(/\+/g, "plus");
        parem = parem.replace(/%20/g, "");
        parem = parem.replace(/\{/g, "(");
        parem = parem.replace(/\}/g, ")");
        parem = parem.replace(/e\^/g, "exp");
        parem = parem.replace(/exp\^/g, "exp");
        parem = parem.replace(/\^/g, "**");
        parem = parem.replace(/e\^sqrt\(x\)/g, "exp(2*x)");

        try {
          const response = await axios.post(
            "http://167.172.134.148/new_factoring",
            new URLSearchParams({
              equ: parem,
            }),
            {
              timeout: 120000,
              headers: {
                "Content-Type": "application/x-www-form-urlencoded",
              },
            }
          );

          const buffer = response.data;
          const factors = buffer[0];
          const eq_enter = buffer[1];
          const all_coeffs = buffer[2];
          const eq_degree = buffer[3];

          if (eq_degree == "2") {
            const matches = all_coeffs.match(/(\+|-){0,1}\d+\.{0,1}\d*/g);
            const eq_coeff_ans = matches;
            const a = parseFloat(matches[0]);
            const b = parseFloat(matches[1]);
            const c = parseFloat(matches[2]);

            if (a == 0) {
              param.error = "Please! Check Your Input.";
              return param;
            }

            if (c != 0) {
              const step1 = Math.abs(a * c);
              const divisors_ans = printDivisors(step1);
              let new_array = [...divisors_ans];
              let median = 0;

              if (divisors_ans.length % 2 != 0) {
                const length = divisors_ans.length;
                const half_length = length / 2;
                const median_index = Math.floor(half_length);
                median = parseInt(divisors_ans[median_index]);
                new_array.splice(median_index, 1);
              }

              const toote = new_array.length / 2;
              const step2_array_first = new_array.slice(0, toote);
              const step2_array_second = new_array.slice(toote).reverse();

              if (median > 0) {
                step2_array_first.push(median.toString());
                step2_array_second.push(median.toString());
              }

              const step2_ans_array = [];
              step2_array_first.forEach((value, key) => {
                step2_ans_array.push(
                  parseInt(value) * parseInt(step2_array_second[key])
                );
              });

              const step3_array_first = [];
              const step3_array_second = [];
              step2_array_first.forEach((value, key) => {
                step3_array_first.push(value);
                step3_array_first.push("-" + value);
                step3_array_second.push(step2_array_second[key]);
                step3_array_second.push("-" + step2_array_second[key]);
              });

              const step3_ans_array = [];
              let pair1, pair2;

              step3_array_first.forEach((value, key) => {
                const val1 = parseInt(value);
                const val2 = parseInt(step3_array_second[key]);

                if (c < 0) {
                  step3_ans_array.push(val1 - val2);
                  if (val1 - val2 === b) {
                    pair1 = val1;
                    pair2 = val2;
                  }
                } else {
                  step3_ans_array.push(val1 + val2);
                  if (val1 + val2 === b) {
                    pair1 = val1;
                    pair2 = val2;
                  }
                }
              });

              const square = Math.pow(b, 2) - 4 * a * c;

              param.tech_divisors_ans = divisors_ans;
              param.tech_step2_array_first = step2_array_first;
              param.tech_step2_array_second = step2_array_second;
              param.tech_step2_ans_array = step2_ans_array;
              param.tech_step3_array_first = step3_array_first;
              param.tech_step3_array_second = step3_array_second;
              param.tech_step3_ans_array = step3_ans_array;
              param.tech_median = median;
              param.tech_square = square;

              if (pair1 !== undefined) param.tech_pair1 = pair1;
              if (pair2 !== undefined) param.tech_pair2 = pair2;
            }

            const variable_ans = variables_list.join("");
            param.tech_a = Math.floor(a);
            param.tech_b = Math.floor(b);
            param.tech_c = Math.floor(c);
            param.tech_variable_ans = variable_ans;
          } else {
            param.tech_ans = buffer[0];
            param.tech_enter = buffer[1];
          }

          param.tech_factors = factors;
          param.tech_eq_enter = eq_enter;
          param.tech_all_coeffs = all_coeffs;
          param.tech_eq_degree = eq_degree;
        } catch (error) {
          param.error = "Please! Check Your Input.";
          return param;
        }
      } else {
        param.error = "Please! Enter Valid Equation.";
        return param;
      }
    }

    param.tech_submit = submit;
    return param;
  }

  /**
   * getCalculationLinearApproximationCalculator: Service Method
   * POST: /api/calculators-lol/linear-approximation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLinearApproximationCalculator(body) {
    let type = body.tech_type;
    let EnterEq = body.tech_EnterEq;
    let EnterEq1 = body.tech_EnterEq1;
    let point = body.tech_point;

    const result = {};

    try {
      if (type == "1") {
        let eq = EnterEq;
        let pt = point;

        // Input validation
        if (pregMatch(/<|>|&|php|print_r|print|echo|script|=|&|%/i, eq)) {
          result.error = "Please Enter Valid Input.";
          return result;
        }

        if (!pt || !eq) {
          result.error = "Please Enter Valid Input.";
          return result;
        }

        // Parameter processing - FIXED VERSION
        let parem = processEquationFixed(eq);
        pt = processPoint(pt);

        try {
          const response = await axios.post(
            "http://167.172.134.148/new-linear",
            {
              equ: parem,
              wrt: "x",
              point: pt,
            },
            {
              timeout: 120000,
              headers: {
                "Content-Type": "application/x-www-form-urlencoded",
              },
            }
          );

          const buffer = response.data;
          console.log(buffer[0]);
          if (Array.isArray(buffer) && buffer.length >= 5) {
            result.tech_fun = Math.round(buffer[0]);
            result.tech_deri = buffer[1];
            result.tech_res = buffer[2];
            result.tech_enter = buffer[3];
            result.tech_simple = buffer[4];
          } else {
            result.error = "Invalid response format from API";
          }

          return result;
        } catch (error) {
          console.error(
            "API Error Details:",
            error.response?.data || error.message
          );
          result.error = "Please! Check Your Input.";
          return result;
        }
      } else if (type == "2") {
        // ... same as before for type 2
        let eq = EnterEq;
        let eq1 = EnterEq1;
        let pt = point;

        // console.log('Type 2 Request:', { eq, eq1, pt });

        if (
          pregMatch(/<|>|&|php|print_r|print|echo|script|=|&|%/i, eq) ||
          pregMatch(/<|>|&|php|print_r|print|echo|script|=|&|%/i, eq1)
        ) {
          result.error = "Please Enter Valid Input.";
          return result;
        }

        if (!pt || !eq || !eq1) {
          result.error = "Please Enter Valid Input.";
          return result;
        }

        let parem = processEquationFixed(eq);
        let parem1 = processEquationFixed(eq1);
        pt = processPoint(pt);

        // console.log('Processed params Type 2:', { parem, parem1, pt });

        try {
          const response = await axios.get("http://167.172.134.148/linear1", {
            params: {
              equ: parem,
              equ1: parem1,
              point: pt,
            },
            timeout: 120000,
          });

          console.log("API Response Type 2:", response.data);

          const buffer = response.data.split("@@@");

          if (buffer.length >= 10) {
            result.tech_deri = buffer[0];
            result.tech_deri1 = buffer[1];
            result.tech_fun = buffer[2];
            result.tech_fun1 = round(parseFloat(buffer[3]), 8);
            result.tech_res = buffer[4];
            result.tech_enter = buffer[5];
            result.tech_enter1 = buffer[6];
            result.tech_simple = buffer[7];
            result.tech_uper = round(parseFloat(buffer[8]), 8);
            result.tech_lower = round(parseFloat(buffer[9]), 8);
          } else {
            result.error = "Invalid response format from API";
          }

          return result;
        } catch (error) {
          console.error(
            "API Error Type 2:",
            error.response?.data || error.message
          );
          result.error = "Please! Check Your Input.";
          return result;
        }
      } else if (type == "3") {
        // ... same as before for type 3
        let eq = EnterEq;
        let pt = point;

        // console.log('Type 3 Request:', { eq, pt });

        if (pregMatch(/<|>|&|php|print_r|print|echo|script|=|&|%/i, eq)) {
          result.error = "Please Enter Valid Input.";
          return result;
        }

        if (!eq || !pt) {
          result.error = "Please Enter Valid Input.";
          return result;
        }

        let parem = processEquationFixed(eq);
        pt = processPoint(pt);

        // console.log('Processed params Type 3:', { parem, pt });

        try {
          const response = await axios.get("http://167.172.134.148/linear2", {
            params: {
              equ: parem,
              point: pt,
            },
            timeout: 120000,
          });

          // console.log('API Response Type 3:', response.data);

          const buffer = response.data.split("@@@");

          if (buffer.length >= 6) {
            const pointVal = round(parseFloat(buffer[2]), 8);
            const funDeri = round(parseFloat(buffer[3]), 8);
            const sinr = round(parseFloat(buffer[4]), 15);
            const cosr = round(parseFloat(buffer[5]), 15);
            const soc =
              (funDeri * sinr + pointVal * cosr) /
              (funDeri * cosr - pointVal * sinr);
            const final = pointVal * sinr - soc * (pointVal * cosr);

            result.tech_enter = buffer[0];
            result.tech_deri = buffer[1];
            result.tech_point = pointVal;
            result.tech_fun_deri = funDeri;
            result.tech_sinr = sinr;
            result.tech_cosr = cosr;
            result.tech_soc = soc;
            result.tech_final = final;
          } else {
            result.error = "Invalid response format from API";
          }

          return result;
        } catch (error) {
          console.error(
            "API Error Type 3:",
            error.response?.data || error.message
          );
          result.error = "Please! Check Your Input.";
          return result;
        }
      } else {
        result.error = "Invalid type specified";
        return result;
      }
    } catch (error) {
      console.error("Unexpected Error:", error);
      result.error = "An unexpected error occurred.";
      return result;
    }

    // FIXED Equation Processing Function
    function processEquationFixed(eq) {
      if (!eq) return "";

      return eq
        .replace(/ /g, "")
        .replace(/%20/g, "")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**")
        .replace(/e\^sqrt\(x\)/g, "exp(2*x)");
      // NOTE: + ko plus nahi replace karna - yehi problem hai
    }

    // Alternative: Agar API ko plus ki jarurat hai toh sirf specific cases mein replace karein
    function processEquationAlternative(eq) {
      if (!eq) return "";

      let processed = eq
        .replace(/ /g, "")
        .replace(/%20/g, "")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**")
        .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

      // Sirf mathematical plus signs ko replace karein, variable names mein nahi
      processed = processed.replace(/(\d)(\+)(\d)/g, "$1plus$3");

      return processed;
    }

    // Helper functions
    function pregMatch(pattern, string) {
      return new RegExp(pattern.source || pattern).test(string);
    }

    function processPoint(point) {
      if (!point) return "";

      return point
        .replace(/inf/g, "oo")
        .replace(/∞/g, "oo")
        .replace(/e/g, "2.71828")
        .replace(/E/g, "2.71828");
    }

    function round(value, decimals) {
      if (isNaN(value)) return value;
      return Number(
        Math.round(parseFloat(value) + "e" + decimals) + "e-" + decimals
      );
    }
  }

  /** getCalculationParallelAndPerpendicularlineCalculator
   * POST: /api/calculators-lol/parallel-and-perpendicular-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationParallelAndPerpendicularlineCalculator(body) {
    let a = parseFloat(body.tech_a);
    let b = parseFloat(body.tech_b);
    let c = parseFloat(body.tech_c);
    let form = body.tech_form;
    let method = body.tech_method;
    let p1 = parseFloat(body.tech_p1);
    let p2 = parseFloat(body.tech_p2);

    function new_gcd_(a, b) {
      a = Math.abs(a);
      b = Math.abs(b);
      if (a < b) [a, b] = [b, a];
      if (b === 0) return 1;
      let r = a % b;
      while (r > 0) {
        a = b;
        b = r;
        r = a % b;
      }
      return b;
    }

    function new_reduce(num, den) {
      let g = new_gcd_(num, den);
      return [num / g, den / g];
    }

    let result = {};

    if (!isNaN(a) && !isNaN(b) && !isNaN(p1) && !isNaN(p2)) {
      if (form === "1") {
        if (!isNaN(c)) {
          let y = method === "2" ? b : -b;
          let [upr, btm] = new_reduce(a, y);
          if (btm < 0) {
            btm = Math.abs(btm);
            upr = -upr;
          }

          if (method === "2") {
            let btm_ = upr;
            let upr_ = btm;
            result.upr_ = btm_;
            result.btm_ = upr_;
            btm = btm_;
            upr = upr_;
          }

          let [upr1, btm1] = new_reduce(c, -b);
          if (btm1 < 0) {
            btm1 = Math.abs(btm1);
            upr1 = -upr1;
          }

          let au = -upr * p1;
          let ab = btm * p2;
          au = ab + au;

          let [upr2, btm2] = new_reduce(au, btm);
          if (btm2 < 0) {
            btm2 = Math.abs(btm2);
            upr2 = -upr2;
          }

          Object.assign(result, {
            tech_upr: upr,
            tech_btm: btm,
            tech_upr1: upr1,
            tech_btm1: btm1,
            tech_upr2: upr2,
            tech_btm2: btm2,
            tech_form: form,
            tech_method: method,
            tech_a: a,
            tech_b: b,
            tech_c: c,
            tech_p1: p1,
            tech_p2: p2,
          });
          return result;
        } else {
          return { error: "Please! Check Your Input." };
        }
      } else {
        if (method === "1") {
          let au = -a * p1 + p2;
          Object.assign(result, {
            tech_au: au,
            tech_method: method,
            tech_form: form,
            tech_a: a,
            tech_b: b,
            tech_p1: p1,
            tech_p2: p2,
          });
          return result;
        } else {
          let upr = a < 0 ? 1 : -1;
          let au = Math.abs(a);
          let au1 = -upr * p1;
          let ab = au * p2;
          au1 = ab + au1;
          let [upr2, btm2] = new_reduce(au1, au);
          if (btm2 < 0) {
            btm2 = Math.abs(btm2);
            upr2 = -upr2;
          }
          Object.assign(result, {
            tech_upr: upr,
            tech_au: au,
            tech_form: form,
            tech_method: method,
            tech_upr2: upr2,
            tech_btm2: btm2,
            tech_a: a,
            tech_b: b,
            tech_p1: p1,
            tech_p2: p2,
          });
          return result;
        }
      }
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationCompositeFunctionCalculator
   * POST: /api/calculators-lol/composite-function-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCompositeFunctionCalculator(body) {
    let one = body.tech_one;
    let two = body.tech_two;
    let point = body.tech_point;

    let result = {};
    const unsafePattern = /<|>|&|php|print_r|print|echo|script|=|%/i;

    // Input validation
    if (
      !one ||
      !two ||
      isNaN(point) ||
      unsafePattern.test(one) ||
      unsafePattern.test(two)
    ) {
      result.error = "Please Enter Valid Input.";
      return result;
    }

    // Compose parem
    let one_ = one.replace(/x/g, "(x)").replace(/x/g, two);
    let parem = one_
      .replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/%20/g, "")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    // Compose parem1
    let two_ = two.replace(/x/g, "(x)").replace(/x/g, one);
    let parem1 = two_
      .replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/%20/g, "")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    try {
      const response = await axios.post(
        "http://167.172.134.148/new-composite",
        new URLSearchParams({
          equ: parem,
          equ1: parem1,
          lim: point.toString(),
        }),
        { timeout: 120000 }
      );

      const buffer = response.data;

      let penter = buffer[1].replace(/x/g, `(${point})`);
      let penter1 = buffer[3].replace(/x/g, `(${point})`);

      parem = parem
        .replace(/plus/g, "+")
        .replace(/\*\*/g, "^")
        .replace(/"/g, "");
      parem1 = parem1
        .replace(/plus/g, "+")
        .replace(/\*\*/g, "^")
        .replace(/"/g, "");

      result.tech_res = buffer[0];
      result.tech_enter = parem;
      result.tech_enter1 = parem1;
      result.tech_enter2 = buffer[1];
      result.tech_penter = penter;
      result.tech_penter1 = penter1;
      result.tech_res1 = buffer[2];
      result.tech_enter3 = buffer[3];
      result.tech_point = point;
      result.tech_one = one;
      result.tech_two = two;

      return result;
    } catch (error) {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /**
   * getCalculationAverageTateOfChangeCalculator: Service Method
   * POST: /api/calculators-lol/average-rate-of-change-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAverageTateOfChangeCalculator(body) {
    let x = body.tech_x;
    let x1 = body.tech_x1;
    let x2 = body.tech_x2;

    // Validation regex check
    if (
      /[<>&]|php|print_r|print|echo|script|=|sin|cos|tan|arcsin|arccos|arctan|&|%/i.test(
        x
      )
    ) {
      return {
        error: "Please! Check Your Input.",
      };
    }

    // Check if x1 and x2 are numeric and x is not empty
    if (
      !isNaN(parseFloat(x1)) &&
      !isNaN(parseFloat(x2)) &&
      x &&
      x.trim() !== ""
    ) {
      let parem = x;

      // String replacements
      parem = parem.replace(/\s/g, "");
      parem = parem.replace(/\+/g, "plus");
      parem = parem.replace(/%20/g, "");
      parem = parem.replace(/\{/g, "(");
      parem = parem.replace(/\}/g, ")");
      parem = parem.replace(/e\^/g, "exp");
      parem = parem.replace(/exp\^/g, "exp");
      parem = parem.replace(/\^/g, "**");
      parem = parem.replace(/e\^sqrt\(x\)/g, "exp(2*x)");

      try {
        const axios = require("axios");

        const response = await axios.post(
          "http://167.172.134.148/new-arocc",
          new URLSearchParams({
            equ: parem,
            x1: x1,
            x2: x2,
          }),
          {
            timeout: 120000,
            headers: {
              "Content-Type": "application/x-www-form-urlencoded",
            },
          }
        );

        const buffer = response.data;

        return {
          tech_eq: buffer[0],
          tech_fx1: Math.round(buffer[1] * 100) / 100,
          tech_fx2: Math.round(buffer[2] * 100) / 100,
          tech_ans: Math.round(buffer[3] * 1000) / 1000,
        };
      } catch (error) {
        return {
          error: "Please! Check Your Input.",
        };
      }
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /** getCalculationCoterminalAngleCalculator
   * POST: /api/calculators-lol/coterminal-angle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCoterminalAngleCalculator(body) {
    let want = parseInt(body.tech_want);
    let unit = parseInt(body.tech_unit);
    let angle = parseFloat(body.tech_angle);
    let angle2 = parseFloat(body.tech_angle2);

    function gcd(a, b) {
      a = Math.abs(a);
      b = Math.abs(b);
      if (a < b) [a, b] = [b, a];
      if (b === 0) return 1;
      let r = a % b;
      while (r > 0) {
        a = b;
        b = r;
        r = a % b;
      }
      return b;
    }

    function reduce(num, den) {
      let g = gcd(num, den);
      return [num / g, den / g];
    }

    let result = {};

    if (unit === 1 && want === 1) {
      let [upr, btm] = reduce(angle, 180);
      let rad = +(upr / btm).toFixed(3);
      result = {
        tech_want: want,
        tech_rad: rad,
        tech_upr: upr,
        tech_btm: btm,
        tech_unit: unit,
        tech_angle: angle,
        tech_angle2: angle2,
      };
    } else if (unit === 2 && want === 1) {
      let deg = +(angle * 180).toFixed(3);
      let two = angle;
      while (two >= 2) {
        two -= 2;
      }

      let pos, neg;
      if (angle >= 2) {
        pos = `${two} π,${two + 2} π,${two + 4} π,${two + 6} π,${
          two + 8
        } π .....`;
        neg = `${two - 2} π,${two - 4} π,${two - 6} π,${two - 8} π,${
          two - 10
        } π .....`;
      } else {
        pos = `${angle + 2} π,${angle + 4} π,${angle + 6} π,${angle + 8} π,${
          angle + 10
        } π .....`;
        neg = `${angle - 2} π,${angle - 4} π,${angle - 6} π,${angle - 8} π,${
          angle - 10
        } π .....`;
      }

      let rem = deg % 360;
      let q = "";
      if (rem > 0 && rem < 90) q = "first quadrant";
      else if (rem === 90) q = "positive y-axis";
      else if (rem > 90 && rem < 180) q = "second quadrant";
      else if (rem === 180) q = "negative x-axis";
      else if (rem > 180 && rem < 270) q = "third quadrant";
      else if (rem === 270) q = "negative y-axis";
      else if (rem > 270) q = "fourth quadrant";
      else if (rem === 0) q = "positive x-axis";

      result = {
        tech_want: want,
        tech_two: two,
        tech_pos: pos,
        tech_neg: neg,
        tech_deg: deg,
        tech_q: q,
        tech_unit: unit,
        tech_angle: angle,
        tech_angle2: angle2,
      };
    } else if (unit === 1 && want === 2) {
      let angle_ = angle % 360;
      let angle2_ = angle2 % 360;
      let check = angle_ === angle2_ ? 1 : 0;
      result = {
        tech_check: check,
        tech_want: want,
        tech_unit: unit,
        tech_angle: angle,
        tech_angle2: angle2,
      };
    } else if (unit === 2 && want === 2) {
      let angle11 = angle * 180;
      let angle22 = angle2 * 180;
      let angle_ = angle11 % 360;
      let angle2_ = angle22 % 360;
      let check = angle_ === angle2_ ? 1 : 0;
      result = {
        tech_check: check,
        tech_want: want,
        tech_unit: unit,
        tech_angle: angle,
        tech_angle2: angle2,
      };
    }

    return result;
  }

  /** getCalculationArithmeticSequenceCalculator
   * POST: /api/calculators-lol/arithmetic-sequences-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationArithmeticSequenceCalculator(body) {
    let first = parseFloat(body.tech_first);
    let diff = parseFloat(body.tech_diff);
    let nth = parseInt(body.tech_nth);

    let result = {};

    if (!isNaN(first) && !isNaN(diff) && !isNaN(nth)) {
      let nth_v = first + (nth - 1) * diff;
      let sum = first;
      let res = `${first}`;

      for (let i = 1; i < 10; i++) {
        sum += diff;
        if (i < 9) {
          res += `, ${sum}`;
        }
        if (i === 9) {
          res += " ....";
        }
      }

      let total = (nth / 2) * (2 * first + (nth - 1) * diff);

      result = {
        tech_first: first,
        tech_diff: diff,
        tech_nth: nth,
        tech_total: total,
        tech_res: res,
        tech_nth_v: nth_v,
      };
    } else {
      result = {
        error: "Please! Check Your Input.",
      };
    }

    return result;
  }

  /** getCalculationInverseFunctionCalculator
   * POST: /api/calculators-lol/inverse-function-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationInverseFunctionCalculator(body) {
    let equ = body.tech_equ;

    let result = {};
    const unsafePattern = /<|>|&|php|print_r|print|echo|script|=|%/i;

    // Basic validation
    if (!equ || unsafePattern.test(equ)) {
      result.error = "Please Enter Valid Input.";
      return result;
    }

    // Extra variable check (only allow x and sqrt)
    const check = equ.split("sqrt");
    if (check.length === 1 && /[a-df-wA-DF-Wyz%]/.test(equ)) {
      result.error = "Equestion unacceptable variables.";
      return result;
    }

    // Format input
    let main = equ
      .replace(/x/g, "y")
      .replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/%20/g, "")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(y\)/g, "exp(2*y)");

    equ = equ
      .replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/%20/g, "")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(y\)/g, "exp(2*y)");

    let main2 = main;
    main = `${main}-x`;

    try {
      const response = await axios.post(
        "http://167.172.134.148/new-inv_fun",
        new URLSearchParams({
          equ,
          main2,
          main,
        }),
        { timeout: 120000 }
      );

      const buffer = response.data;
      let res = buffer[2].replace("\\left[", "").replace("\\right]", "");

      result.tech_enter = buffer[0];
      result.tech_enter2 = buffer[1];
      result.tech_res = res;
      return result;
    } catch (err) {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /** getCalculationDoubleAngleCalculator
   * POST: /api/calculators-lol/double-angle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDoubleAngleCalculator(body) {
    let unit = body.tech_unit;
    let angle = body.tech_angle;

    let result = {};

    function sigFig(value, digits) {
      if (value === 0) {
        return 0;
      }
      const decimalPlaces =
        digits - Math.floor(Math.log10(Math.abs(value))) - 1;
      return +value.toFixed(decimalPlaces);
    }

    if (!isNaN(angle)) {
      angle = parseFloat(angle);
    } else if (typeof angle === "string" && angle.includes("/")) {
      let parts = angle.split("/");
      if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
        angle = parseFloat(parts[0]) / parseFloat(parts[1]);
      } else {
        result.error = "Please! Check Your Input.";
        return result;
      }
    } else {
      result.error = "Please! Check Your Input.";
      return result;
    }

    let deg, red;
    let angle_ = angle;

    if (unit === "1") {
      deg = angle;
      red = (angle * Math.PI) / 180;
    } else if (unit === "2") {
      deg = +((angle * 180) / Math.PI).toFixed(2);
      red = angle;
    } else if (unit === "3") {
      deg = +(angle * 180).toFixed(2);
      result.tech_angle_ = angle_;
      red = (angle * 180 * Math.PI) / 180;
    }

    let sin = 2 * (Math.sin(red).toFixed(5) * Math.cos(red).toFixed(5));
    let cos = 1 - 2 * Math.pow(Math.sin(red).toFixed(5), 2);

    let upper = 2 * Math.tan(red).toFixed(5);
    let bottom = 1 - Math.pow(Math.tan(red).toFixed(5), 2);

    let tan = 0;
    if (upper !== 0 && bottom !== 0) {
      tan = upper / bottom;
    }

    result.tech_sin = sigFig(sin, 6);
    result.tech_cos = sigFig(cos, 6);
    result.tech_tan = sigFig(tan, 6);
    result.tech_deg = deg;
    result.tech_red = red;
    result.tech_angle = angle;
    result.tech_unit = unit;

    return result;
  }

  /** getCalculationRiemannSumCalculator
   * POST: /api/calculators-lol/riemann-sum-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRiemannSumCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let lb = body.tech_lb;
    let ub = body.tech_ub;
    let type = body.tech_type;
    let n = body.tech_n;
    let withVar = body.tech_with;

    let result = {};
    const unsafePattern = /<|>|&|php|print_r|print|echo|script|=|%/i;

    if (!EnterEq || unsafePattern.test(EnterEq)) {
      result.error = "Please! Check Your Input.";
      return result;
    }

    if (!isFinite(lb) || !isFinite(ub) || !isFinite(n)) {
      result.error = "Please! Check Your Input.";
      return result;
    }

    if (lb >= ub) {
      result.error = "The lower limit should be less than the upper limit.";
      return result;
    }

    let parem = EnterEq.replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    let diff = (ub - lb) / n;
    let final = lb;
    let limit = `${final}`;
    let limit_a = [];

    if (type !== "2") {
      limit_a.push(lb);
    }

    while (final < ub) {
      final += diff;
      limit_a.push(final);
      limit += `, ${final}`;
    }

    let lb_ = type === "2" ? lb + diff : lb;

    try {
      const response = await axios.post(
        "http://167.172.134.148/new-riemann",
        new URLSearchParams({
          equ: parem,
          with: withVar,
          ub,
          lb: lb_,
          n,
          type,
          diff,
        }),
        { timeout: 120000 }
      );

      const buffer = response.data;
      const steps = buffer[0].split("HA");

      result.tech_steps = steps;
      result.tech_res = buffer[1];
      result.tech_enter = buffer[2];
      result.tech_ub = ub;
      result.tech_lb = lb;
      result.tech_n = n;
      result.tech_type = type;
      result.tech_diff = diff;
      result.tech_limit = limit;
      result.tech_limit_a = limit_a;
      result.tech_with = withVar;
      return result;
    } catch (err) {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /** getCalculationMeanValueTheoremCalculator
   * POST: /api/calculators-lol/mean-value-theorem-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMeanValueTheoremCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let lb = body.tech_lb;
    let ub = body.tech_ub;
    let withVar = body.tech_with;

    let result = {};
    const unsafePattern = /<|>|&|php|print_r|print|echo|script|=|%/i;

    if (!EnterEq || unsafePattern.test(EnterEq)) {
      result.error = "Please! Check Your Input.";
      return result;
    }

    if (!isFinite(lb) || !isFinite(ub)) {
      result.error = "Please! Check Your Input.";
      return result;
    }

    if (lb >= ub) {
      result.error = "The start interval should be less than the end inverval.";
      return result;
    }

    // Prepare equations
    let parem = EnterEq.replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    let parem1 = parem;
    if (withVar) {
      parem = parem.replace(new RegExp(withVar, "g"), "c");
    }

    try {
      const response = await axios.post(
        "http://167.172.134.148/new-mean",
        new URLSearchParams({
          equ: parem,
          equ1: parem1,
          lb,
          ub,
        }),
        { timeout: 120000 }
      );

      const buffer = response.data;
      const root = String(buffer[4]).replace("[", "").replace("]", "");

      result.tech_enter = buffer[0];
      result.tech_start = buffer[1];
      result.tech_end = buffer[2];
      result.tech_deri = buffer[3];
      result.tech_simple = buffer[5];
      result.tech_ub = ub;
      result.tech_lb = lb;
      result.tech_root = root;
      result.tech_with = withVar;
      return result;
    } catch (error) {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /** getCalculationHalfAngleCalculator
   * POST: /api/calculators-lol/half-angle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationHalfAngleCalculator(body) {
    let cal = body.tech_cal;
    let angle = body.tech_angle;
    let angle_unit = body.tech_angle_unit;
    let func = body.tech_func;

    const result = {};

    // Helper functions
    function deg2rad(deg) {
      return deg * (Math.PI / 180);
    }

    function rad2deg(rad) {
      return rad * (180 / Math.PI);
    }

    function round(value, decimals) {
      return Number(Math.round(value + "e" + decimals) + "e-" + decimals);
    }

    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }

    if (cal === "angle") {
      if (isNumeric(angle) && angle_unit) {
        let angleInDeg;
        if (angle_unit === "rad") {
          angleInDeg = rad2deg(angle);
          result.tech_angle_u = "rad";
        } else if (angle_unit === "pirad") {
          angleInDeg = rad2deg(angle * Math.PI);
          result.tech_angle_u = "pirad";
        } else {
          angleInDeg = parseFloat(angle);
          result.tech_angle_u = "deg";
        }

        const sinx = Math.sin(deg2rad(angleInDeg));
        const cosx = Math.cos(deg2rad(angleInDeg));
        const tanx = Math.tan(deg2rad(angleInDeg));
        const s1 = 1 - cosx;
        const s2 = s1 / 2;
        const c1 = 1 + cosx;
        const c2 = c1 / 2;
        const t1 = s1 / c1;
        const sinx2 = Math.sqrt(s2);
        const cosx2 = Math.sqrt(c2);
        const tanx2 = Math.sqrt(t1);

        result.tech_sinx = round(sinx, 4);
        result.tech_cosx = round(cosx, 4);
        result.tech_tanx = round(tanx, 4);
        result.tech_sinx2 = round(sinx2, 4);
        result.tech_cosx2 = round(cosx2, 4);
        result.tech_tanx2 = round(tanx2, 4);
        result.tech_s1 = round(s1, 4);
        result.tech_s2 = round(s2, 4);
        result.tech_c1 = round(c1, 4);
        result.tech_c2 = round(c2, 4);
        result.tech_t1 = round(t1, 4);
      } else {
        result.error = "Please! Check Your Input.";
      }
    } else {
      if (isNumeric(func)) {
        let angleInDeg;
        if (cal === "sinx") {
          angleInDeg = rad2deg(Math.asin(func));
        } else if (cal === "cosx") {
          angleInDeg = rad2deg(Math.acos(func));
        } else if (cal === "tanx") {
          angleInDeg = rad2deg(Math.atan(func));
        } else if (cal === "sinx_2") {
          const sinx2 = parseFloat(func);
          const cosx = Math.abs(2 * Math.pow(sinx2, 2) - 1);
          angleInDeg = rad2deg(Math.acos(cosx));
        } else {
          // cosx_2
          const cosx2 = parseFloat(func);
          const cosx = 2 * Math.pow(cosx2, 2) - 1;
          angleInDeg = rad2deg(Math.acos(cosx));
        }

        const sinx = Math.sin(deg2rad(angleInDeg));
        const cosx = Math.cos(deg2rad(angleInDeg));
        const tanx = Math.tan(deg2rad(angleInDeg));
        const s1 = 1 - cosx;
        const s2 = s1 / 2;
        const c1 = 1 + cosx;
        const c2 = c1 / 2;
        const t1 = s1 / c1;
        const sinx2 = Math.sqrt(s2);
        const cosx2 = Math.sqrt(c2);
        const tanx2 = Math.sqrt(t1);
        const angle_rad = deg2rad(angleInDeg);
        const angle_pirad = angleInDeg * 0.005556;

        result.tech_angle_deg = round(angleInDeg, 4);
        result.tech_angle_rad = round(angle_rad, 4);
        result.tech_angle_pirad = round(angle_pirad, 4);
        result.tech_sinx = round(sinx, 4);
        result.tech_cosx = round(cosx, 4);
        result.tech_tanx = round(tanx, 4);
        result.tech_sinx2 = round(sinx2, 4);
        result.tech_cosx2 = round(cosx2, 4);
        result.tech_tanx2 = round(tanx2, 4);
        result.tech_s1 = round(s1, 4);
        result.tech_s2 = round(s2, 4);
        result.tech_c1 = round(c1, 4);
        result.tech_c2 = round(c2, 4);
        result.tech_t1 = round(t1, 4);
      } else {
        result.error = "Please! Check Your Input.";
      }
    }

    return result;
  }

  /** getCalculationNewtonsMethodCalculator
   * POST: /api/calculators-lol/newtons-method-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationNewtonsMethodCalculator(body) {
    let fx = body.tech_fx;
    let fx1 = body.tech_fx1;
    let x0 = body.tech_x0;
    let iter = body.tech_iter;
    let round = body.tech_round;

    let result = {};

    // Validation
    const unsafePattern = /<|>|&|php|print_r|print|echo|script|=|%/i;
    if (!fx || unsafePattern.test(fx)) {
      result.error = "Please Enter Valid Input.";
      return result;
    }

    if (!isFinite(round) || !isFinite(iter) || !isFinite(x0)) {
      result.error = "Please! Check Your Input";
      return result;
    }

    // Clean and prepare fx
    let parem = fx
      .replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/%20/g, "")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    let parem1 = "0";
    if (fx1 && fx1 !== "") {
      if (unsafePattern.test(fx1)) {
        result.error = "Please Enter Valid Input.";
        return result;
      }

      parem1 = fx1
        .replace(/\s+/g, "")
        .replace(/\+/g, "plus")
        .replace(/%20/g, "")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**")
        .replace(/e\^sqrt\(x\)/g, "exp(2*x)");
    }

    // Default round if not numeric
    if (!isFinite(round)) {
      round = 4;
    }

    try {
      const response = await axios.post(
        "http://167.172.134.148/new-newtons",
        new URLSearchParams({
          equ: parem,
          equ1: parem1,
          x: x0,
          iter,
          round,
        }),
        { timeout: 120000 }
      );

      let buffer = response.data;

      if (Array.isArray(buffer)) {
        if (buffer.length === 6) {
          result.tech_enter = buffer[0];
          result.tech_enter1 = buffer[1];
          result.tech_steps = buffer[2];
          result.tech_fx = buffer[3];
          result.tech_fx1 = buffer[4];
          result.tech_res = buffer[5];
          result.tech_round = round;
        } else if (buffer.length === 1) {
          result.error = "Please! Check Your Input.";
          return result;
        } else {
          result.tech_check = "check";
          result.tech_enter = buffer[0];
          result.tech_enter1 = buffer[1];
          result.tech_fx = buffer[2];
          result.tech_fx1 = buffer[3];
          result.tech_res = buffer[4];
          result.tech_round = round;
        }
      } else {
        result.error = "Unexpected response format.";
      }

      return result;
    } catch (error) {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /** getCalculationEulerMethodCalculator
   * POST: /api/calculators-lol/trapezoidal-rule-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTrapezoidalRuleCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let lb = body.tech_lb;
    let ub = body.tech_ub;
    let n = body.tech_n;
    let _with = body.tech_with;

    let result = {};

    // Basic validation
    if (!EnterEq || /[<>&=]|php|print_r|print|echo|script|%/i.test(EnterEq)) {
      result.error = "Please! Check Your Input.";
      return result;
    }

    // Check numeric values
    if (!isFinite(lb) || !isFinite(ub) || !isFinite(n)) {
      result.error = "Please! Check Your Input.";
      return result;
    }

    lb = parseFloat(lb);
    ub = parseFloat(ub);
    n = parseInt(n);

    if (lb >= ub) {
      result.error = "The lower limit should be less than the upper limit.";
      return result;
    }

    // Prepare expression
    let parem = EnterEq.replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    let diff = (ub - lb) / n;
    let final = lb;
    let limit_a = [lb];
    let limit = `${final}`;

    while (final < ub) {
      final += diff;
      limit_a.push(final);
      limit += `, ${final}`;
    }

    try {
      const response = await axios.get("http://167.172.134.148/trap", {
        params: {
          equ: parem,
          with: _with,
          lb,
          ub,
          n,
          diff,
        },
        timeout: 120000,
      });

      let buffer = response.data.split("@@@");
      let steps = buffer[0].split("HA");

      result.tech_steps = steps;
      result.tech_res = buffer[1];
      result.tech_enter = buffer[2];
      result.tech_ub = ub;
      result.tech_lb = lb;
      result.tech_n = n;
      result.tech_diff = diff;
      result.tech_limit = limit;
      result.tech_limit_a = limit_a;
      result.tech_with = _with;
      return result;
    } catch (err) {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /**
   * getCalculationEulersMethodCalculator: Service Method
   * POST: /api/calculators-lol/eulers-method-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationEulersMethodCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let steps = body.tech_steps;
    let size = body.tech_size;
    let ini = body.tech_ini;
    let con = body.tech_con;
    let find = body.tech_find;

    // Validation check
    if (!EnterEq || EnterEq.trim() == "") {
      return {
        error: "Please! Check Your Input.",
      };
    }

    // Check equation for variables
    let check_eq = EnterEq.replace(/\s/g, "");
    check_eq = check_eq.replace(/sqrt/g, "");
    check_eq = check_eq.replace(/exp/g, "");
    check_eq = check_eq.replace(/y=/g, "");
    check_eq = check_eq.replace(/f\(x\)=/g, "");
    check_eq = check_eq.replace(/y′=/g, "");
    check_eq = check_eq.replace(/y'=/g, "");

    let check = "";
    let one = "";
    let two = "";

    if (/x/i.test(check_eq) && /y/i.test(check_eq)) {
      one = "x";
      two = "y";
      check = "xy";
    }

    let check2 = "";
    if (/t/i.test(check_eq) && /y/i.test(check_eq)) {
      check2 = "ty";
      one = "t";
      two = "y";
    }

    // Check for conflicting variables
    if (check == "xy" && check2 == "ty") {
      return {
        error: "Equestion contain more variables.",
      };
    }

    if (check2 == "" && check == "") {
      return {
        error: "Please check equation.",
      };
    }

    // Check if all parameters are numeric
    if (
      !isNaN(parseFloat(size)) &&
      !isNaN(parseFloat(ini)) &&
      !isNaN(parseFloat(con)) &&
      !isNaN(parseFloat(find))
    ) {
      let parem = EnterEq;
      parem = parem.replace(/\s/g, "");
      parem = parem.replace(/y=/g, "");
      parem = parem.replace(/f\(x\)=/g, "");
      parem = parem.replace(/y′=/g, "");
      parem = parem.replace(/y'=/g, "");
      parem = parem.replace(/\+/g, "plus");
      parem = parem.replace(/\{/g, "(");
      parem = parem.replace(/\}/g, ")");
      parem = parem.replace(/e\^x/g, "exp(x)");
      parem = parem.replace(/e\^y/g, "exp(y)");
      parem = parem.replace(/e\^/g, "exp");
      parem = parem.replace(/exp\^/g, "exp");
      parem = parem.replace(/\^/g, "**");

      let end = parseFloat(ini);
      let h;

      // Calculate step size
      if (steps == "h") {
        if (parseFloat(size) > parseFloat(find)) {
          return {
            error: "Step Size cannot be greater than t1.",
          };
        }
        h = parseFloat(size);
      } else {
        if (parseFloat(ini) >= parseFloat(find)) {
          return {
            error: "t1 value should be greater than the initial value.",
          };
        }
        h = (parseFloat(find) - parseFloat(ini)) / parseFloat(size);
      }

      // Calculate length/iterations - YE LINE CHANGE HUI HAI
      let length = 0;
      let tempEnd = parseFloat(ini);
      // Floating point precision ke liye tolerance add kiya
      const tolerance = 1e-10;
      while (tempEnd < parseFloat(find) - tolerance) {
        tempEnd = tempEnd + h;
        length++;
      }

      if (length > 100) {
        if (steps == "h") {
          return {
            error: "Step Size too small.",
          };
        } else {
          return {
            error: "Number of steps too large.",
          };
        }
      }

      try {
        const axios = require("axios");

        const response = await axios.post(
          "http://167.172.134.148/new-eulers",
          new URLSearchParams({
            equ: parem,
            one: one,
            two: two,
            ini: parseFloat(ini).toString(),
            h: h.toString(),
            con: parseFloat(con).toString(),
            find: parseFloat(find).toString(),
          }),
          {
            timeout: 120000,
            headers: {
              "Content-Type": "application/x-www-form-urlencoded",
            },
          }
        );

        const buffer = response.data;
        const steps_arr = buffer[0].split("HA");
        const steps1_arr = buffer[1].split("HA");

        return {
          tech_steps: steps_arr,
          tech_steps1: steps1_arr,
          tech_ans: buffer[2],
          tech_enter: buffer[3],
          tech_one: one,
          tech_two: two,
          tech_ini: parseFloat(ini).toString(),
          tech_h: h,
          tech_con: parseFloat(con).toString(),
          tech_step: steps,
          tech_find: parseFloat(find).toString(),
        };
      } catch (error) {
        console.error("API Error:", error.message);
        return {
          error: "Please! Check Your Input.",
        };
      }
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /** getCalculationFOILCalculator
   * POST: /api/calculators-lol/foil-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationFOILCalculator(body) {
    let exp = body.tech_exp;

    if (
      /<|>|&|php|print_r|print|echo|script|=|sin|cos|tan|arcsin|arccos|arctan|%/i.test(
        exp
      )
    ) {
      return { error: "Please Enter Valid Input." };
    }

    if (!exp) {
      return { error: "Please Check Your Input." };
    }

    let parem = exp
      .replace(/ /g, "")
      .replace(/%20/g, "")
      .replace(/plus/g, "+")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    try {
      if (/\*\*2|\*\*3/.test(parem)) {
        let s1 = parem.split("**");
        let opr, a, b;
        let s2 = s1[0].split("+");
        let s2_ = s1[0].split("-");

        if (s2.length === 2) {
          opr = "+";
          let s3 = s2[0].split("(");
          let s4 = s2[1].split(")");
          a = opr + s3[1];
          b = opr + s4[0];
        } else if (s2_.length === 2) {
          opr = "-";
          let s3 = s2_[0].split("(");
          let s4 = s2_[1].split(")");
          a = opr + s3[1];
          b = opr + s4[0];
        }

        let expnt = s1[1];
        let eq = s1[0];
        let par = parem.replace(/\+/g, "plus");

        const response = await axios.get("http://167.172.134.148/foil", {
          timeout: 120000,
          params: {
            equ: par,
            a,
            opr,
            b,
            exp: expnt,
            eq,
          },
        });

        let buffer = response.data.split("@@@");
        return {
          tech_eq: buffer[0],
          tech_ans: buffer[1],
          tech_a: buffer[2],
          tech_b: buffer[3],
          tech_s1: buffer[4],
          tech_s2: buffer[5],
          tech_s3: buffer[6],
          tech_s4: buffer[7],
          tech_equ: buffer[8],
          tech_opr: buffer[9],
          tech_exp: buffer[10],
        };
      } else {
        let s1 = parem.split(")(");
        if (s1.length > 2) {
          return { error: "Please Check Your Input." };
        }

        let s2 = s1[0].split("(");
        let s3 = s1[1].split(")");
        let opr, a, b, opr1, c, d;

        let s4 = s2[1].split("+");
        let s4_ = s2[1].split("-");
        let s5 = s3[0].split("+");
        let s5_ = s3[0].split("-");

        if (s4.length === 2) {
          opr = "plus";
          a = s4[0];
          b = opr + s4[1];
        } else if (s4_.length === 2) {
          opr = "-";
          a = s4_[0];
          b = opr + s4_[1];
        } else if (s4_.length === 3) {
          opr = "-";
          a = opr + s4_[1];
          b = opr + s4_[2];
        }

        if (s5.length === 2) {
          opr1 = "plus";
          c = s5[0];
          d = opr1 + s5[1];
        } else if (s5_.length === 2) {
          opr1 = "-";
          c = s5_[0];
          d = opr1 + s5_[1];
        } else if (s5_.length === 3) {
          opr1 = "-";
          c = opr1 + s5_[1];
          d = opr1 + s5_[2];
        }

        let par = parem.replace(/\+/g, "plus");

        const response = await axios.get("http://167.172.134.148/foil", {
          timeout: 120000,
          params: {
            equ: par,
            a,
            opr,
            b,
            c,
            opr1,
            d,
          },
        });

        let buffer = response.data.split("@@@");
        return {
          tech_eq: buffer[0],
          tech_ans: buffer[1],
          tech_a: buffer[2],
          tech_b: buffer[3],
          tech_c: buffer[4],
          tech_d: buffer[5],
          tech_s1: buffer[6],
          tech_s2: buffer[7],
          tech_s3: buffer[8],
          tech_s4: buffer[9],
          tech_opr: buffer[10],
          tech_opr1: buffer[11],
          tech_check: buffer[12],
        };
      }
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }

  /**
   * getCalculationTriangleCalculator: Service Method
   * POST: /api/calculators-lol/triangle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTriangleCalculator(body) {
    // Helper function to convert decimal degrees to DMS
    function DDtoDMS(dec) {
      const vars = dec.toString().split(".");
      const deg = parseInt(vars[0]);
      let tempma = parseFloat("0." + (vars[1] || "0"));

      tempma = tempma * 3600;
      const min = Math.floor(tempma / 60);
      const sec = Math.round(tempma - min * 60);

      return { deg: deg, min: min, sec: sec };
    }

    let a = body.tech_a;
    let b = body.tech_b;
    let c = body.tech_c;
    let A = body.tech_A;
    let B = body.tech_B;
    let C = body.tech_C;
    let unit = body.tech_unit;

    // Convert empty strings to null/undefined
    a = a == "" ? null : a;
    b = b == "" ? null : b;
    c = c == "" ? null : c;
    A = A == "" ? null : A;
    B = B == "" ? null : B;
    C = C == "" ? null : C;

    let check = false;
    let comb = 0;
    let Ar, Ad, At, Br, Bd, Bt, Cr, Cd, Ct;
    let area, peri, semi, ha, hb, hc, ma, mb, mc, inr, circ;
    let result = {};

    // Helper function to convert degrees to radians
    const deg2rad = (deg) => deg * (Math.PI / 180);

    // Helper function to convert radians to degrees
    const rad2deg = (rad) => rad * (180 / Math.PI);

    // Case 1: Three sides given (SSS)
    if (
      a != null &&
      !isNaN(a) &&
      b != null &&
      !isNaN(b) &&
      c != null &&
      !isNaN(c) &&
      (A == null || A == "") &&
      (B == null || B == "") &&
      (C == null || C == "")
    ) {
      a = parseFloat(a);
      b = parseFloat(b);
      c = parseFloat(c);

      A = (Math.pow(b, 2) + Math.pow(c, 2) - Math.pow(a, 2)) / (2 * b * c);
      Ar = Math.acos(A);
      Ad = rad2deg(Ar);
      At = DDtoDMS(Ad);

      B = (Math.pow(a, 2) + Math.pow(c, 2) - Math.pow(b, 2)) / (2 * a * c);
      Br = Math.acos(B);
      Bd = rad2deg(Br);
      Bt = DDtoDMS(Bd);

      C = (Math.pow(a, 2) + Math.pow(b, 2) - Math.pow(c, 2)) / (2 * a * b);
      Cr = Math.acos(C);
      Cd = rad2deg(Cr);
      Ct = DDtoDMS(Cd);

      check = true;
      comb = 1;
    }
    // Case 2: Two sides and one angle (a, b, A) - SSA
    else if (
      a != null &&
      !isNaN(a) &&
      b != null &&
      !isNaN(b) &&
      (c == null || c == "") &&
      A != null &&
      A !== "" &&
      (B == null || B == "") &&
      (C == null || C == "")
    ) {
      a = parseFloat(a);
      b = parseFloat(b);

      // Process angle A
      if (unit == "1") {
        Ad = parseFloat(A);
        At = DDtoDMS(Ad);
        Ar = deg2rad(Ad);
      } else {
        const Ac = A.split("/");
        if (Ac.length == 2) {
          if (Ac[0] == "pi" || Ac[0] == "pi()") {
            if (!isNaN(Ac[1])) {
              Ad = 180 / parseFloat(Ac[1]);
              Ar = deg2rad(Ad);
              At = DDtoDMS(Ad);
            } else {
              return { error: "Please! Check Your Input." };
            }
          }
        } else if (!isNaN(A)) {
          Ar = parseFloat(A);
          Ad = rad2deg(Ar);
          At = DDtoDMS(Ad);
        }
      }

      if (Ad >= 180) {
        return { error: "Angle ∠A is too big." };
      }

      Br = Math.asin((b * Math.sin(Ar)) / a);

      if (isNaN(Br) || !isFinite(Br)) {
        return {
          error:
            "These three values can't be used to develop a valid triangle.",
        };
      } else {
        Bd = rad2deg(Br);
        Bt = DDtoDMS(Bd);
        Cd = 180 - Ad - Bd;
        Cr = deg2rad(Cd);
        Ct = DDtoDMS(Cd);
        c = Math.round(((a * Math.sin(Cr)) / Math.sin(Ar)) * 100000) / 100000;

        const B1 = Math.asin((b * Math.sin(Ar)) / a);
        const Bd1 = 180 - rad2deg(B1);
        const Bt1 = DDtoDMS(Bd1);
        const Br1 = deg2rad(Bd1);
        const Cd1 = 180 - Bd1 - Ad;

        if (Cd1 > 0) {
          const Ct1 = DDtoDMS(Cd1);
          const Cr1 = deg2rad(Cd1);
          const c1 = (a * Math.sin(Cr1)) / Math.sin(Ar);
          const area1 =
            Math.round(((a * b * Math.sin(Cr)) / 2) * 100000) / 100000;
          const peri1 = a + b + c1;
          const semi1 = Math.round(((a + b + c1) / 2) * 100000) / 100000;
          const ha1 = Math.round(((2 * area1) / a) * 100000) / 100000;
          const hb1 = Math.round(((2 * area1) / b) * 100000) / 100000;
          const hc1 = Math.round(((2 * area1) / c1) * 100000) / 100000;
          const ma1 =
            Math.round(
              Math.sqrt(
                Math.pow(a / 2, 2) + Math.pow(c1, 2) - a * c1 * Math.cos(Br1)
              ) * 100000
            ) / 100000;
          const mb1 =
            Math.round(
              Math.sqrt(
                Math.pow(b / 2, 2) + Math.pow(a, 2) - a * b * Math.cos(Cr1)
              ) * 100000
            ) / 100000;
          const mc1 =
            Math.round(
              Math.sqrt(
                Math.pow(c1 / 2, 2) + Math.pow(b, 2) - b * c1 * Math.cos(Ar)
              ) * 100000
            ) / 100000;
          const inr1 = Math.round((area1 / semi1) * 100000) / 100000;
          const circ1 = Math.round((a / (2 * Math.sin(Ar))) * 100000) / 100000;

          result.comb2 = 2;
          result.c1 = c1;
          result.Br1 = Br1;
          result.Bd1 = Bd1;
          result.Bt1 = Bt1;
          result.Cr1 = Cr1;
          result.Cd1 = Cd1;
          result.Ct1 = Ct1;
          result.area1 = area1;
          result.peri1 = peri1;
          result.semi1 = semi1;
          result.ha1 = ha1;
          result.hb1 = hb1;
          result.hc1 = hc1;
          result.ma1 = ma1;
          result.mb1 = mb1;
          result.mc1 = mc1;
          result.inr1 = inr1;
          result.circ1 = circ1;
        }

        check = true;
        comb = 2;
      }
    }
    // Case 3: Two sides and one angle (a, b, B) - SSA
    else if (
      a != null &&
      !isNaN(a) &&
      b != null &&
      !isNaN(b) &&
      (c == null || c == "") &&
      (A == null || A == "") &&
      B != null &&
      B != "" &&
      (C == null || C == "")
    ) {
      a = parseFloat(a);
      b = parseFloat(b);

      // Process angle B
      if (unit == "1") {
        Bd = parseFloat(B);
        Bt = DDtoDMS(Bd);
        Br = deg2rad(Bd);
      } else {
        const Bc = B.split("/");
        if (Bc.length == 2) {
          if (Bc[0] == "pi" || Bc[0] == "pi()") {
            if (!isNaN(Bc[1])) {
              Bd = 180 / parseFloat(Bc[1]);
              Br = deg2rad(Bd);
              Bt = DDtoDMS(Bd);
            } else {
              return { error: "Please! Check Your Input." };
            }
          }
        } else if (!isNaN(B)) {
          Br = parseFloat(B);
          Bd = rad2deg(Br);
          Bt = DDtoDMS(Bd);
        }
      }

      if (Bd >= 180) {
        return { error: "Angle ∠B is too big." };
      }

      A = Math.asin((a * Math.sin(Br)) / b);
      Ar = A;
      Ad = rad2deg(Ar);
      At = DDtoDMS(Ad);
      Cd = 180 - Ad - Bd;
      Ct = DDtoDMS(Cd);
      Cr = deg2rad(Cd);
      c = Math.round(((b * Math.sin(Cr)) / Math.sin(Br)) * 100000) / 100000;
      comb = 3;
      check = true;
    }
    // Case 4: Two sides and included angle (a, b, C) - SAS
    else if (
      a != null &&
      !isNaN(a) &&
      b != null &&
      !isNaN(b) &&
      (c == null || c == "") &&
      (A == null || A == "") &&
      (B == null || B == "") &&
      C != null &&
      C != ""
    ) {
      a = parseFloat(a);
      b = parseFloat(b);

      // Process angle C
      if (unit == "1") {
        Cd = parseFloat(C);
        Ct = DDtoDMS(Cd);
        Cr = deg2rad(Cd);
      } else {
        const Cc = C.split("/");
        if (Cc.length == 2) {
          if (Cc[0] == "pi" || Cc[0] == "pi()") {
            if (!isNaN(Cc[1])) {
              Cd = 180 / parseFloat(Cc[1]);
              Cr = deg2rad(Cd);
              Ct = DDtoDMS(Cd);
            } else {
              return { error: "Please! Check Your Input." };
            }
          }
        } else if (!isNaN(C)) {
          Cr = parseFloat(C);
          Cd = rad2deg(Cr);
          Ct = DDtoDMS(Cd);
        }
      }

      if (Cd >= 180) {
        return { error: "Angle ∠C is too big." };
      }

      c =
        Math.round(
          Math.sqrt(
            Math.pow(b, 2) + Math.pow(a, 2) - 2 * b * a * Math.cos(Cr)
          ) * 100000
        ) / 100000;
      B = Math.acos(
        (Math.pow(c, 2) + Math.pow(a, 2) - Math.pow(b, 2)) / (2 * c * a)
      );
      Br = B;
      Bd = rad2deg(Br);
      Bt = DDtoDMS(Bd);
      A = Math.acos(
        (Math.pow(c, 2) + Math.pow(b, 2) - Math.pow(a, 2)) / (2 * c * b)
      );
      Ar = A;
      Ad = rad2deg(Ar);
      At = DDtoDMS(Ad);
      comb = 4;
      check = true;
    }
    // Case 5: One side and two angles (a, A, B) - AAS
    else if (
      a != null &&
      !isNaN(a) &&
      (b == null || b == "") &&
      (c == null || c == "") &&
      A != null &&
      A != "" &&
      B != null &&
      B != "" &&
      (C == null || C == "")
    ) {
      a = parseFloat(a);

      // Process angle B
      if (unit == "1") {
        Bd = parseFloat(B);
        Bt = DDtoDMS(Bd);
        Br = deg2rad(Bd);
      } else {
        const Bc = B.split("/");
        if (Bc.length == 2) {
          if (Bc[0] == "pi" || Bc[0] == "pi()") {
            if (!isNaN(Bc[1])) {
              Bd = 180 / parseFloat(Bc[1]);
              Br = deg2rad(Bd);
              Bt = DDtoDMS(Bd);
            } else {
              return { error: "Please! Check Your Input." };
            }
          }
        } else if (!isNaN(B)) {
          Br = parseFloat(B);
          Bd = rad2deg(Br);
          Bt = DDtoDMS(Bd);
        }
      }

      if (Bd >= 180) {
        return { error: "Angle ∠B is too big." };
      }

      // Process angle A
      if (unit == "1") {
        Ad = parseFloat(A);
        At = DDtoDMS(Ad);
        Ar = deg2rad(Ad);
      } else {
        const Ac = A.split("/");
        if (Ac.length == 2) {
          if (Ac[0] == "pi" || Ac[0] == "pi()") {
            if (!isNaN(Ac[1])) {
              Ad = 180 / parseFloat(Ac[1]);
              Ar = deg2rad(Ad);
              At = DDtoDMS(Ad);
            } else {
              return { error: "Please! Check Your Input." };
            }
          }
        } else if (!isNaN(A)) {
          Ar = parseFloat(A);
          Ad = rad2deg(Ar);
          At = DDtoDMS(Ad);
        }
      }

      if (Ad >= 180) {
        return { error: "Angle ∠A is too big." };
      }

      if (Ad + Bd >= 180) {
        return {
          error:
            "These three values can't be used to develop a valid triangle.",
        };
      }

      Cd = 180 - Ad - Bd;
      Cr = deg2rad(Cd);
      Ct = DDtoDMS(Cd);
      b = Math.round(((a * Math.sin(Br)) / Math.sin(Ar)) * 100000) / 100000;
      c = Math.round(((a * Math.sin(Cr)) / Math.sin(Ar)) * 100000) / 100000;
      comb = 5;
      check = true;
    }
    // Case 6: One side and two angles (b, A, B) - AAS
    else if (
      (a == null || a == "") &&
      b != null &&
      !isNaN(b) &&
      (c == null || c == "") &&
      A != null &&
      A != "" &&
      B != null &&
      B !== "" &&
      (C == null || C == "")
    ) {
      b = parseFloat(b);

      // Process angle B
      if (unit == "1") {
        Bd = parseFloat(B);
        Bt = DDtoDMS(Bd);
        Br = deg2rad(Bd);
      } else {
        const Bc = B.split("/");
        if (Bc.length == 2) {
          if (Bc[0] == "pi" || Bc[0] == "pi()") {
            if (!isNaN(Bc[1])) {
              Bd = 180 / parseFloat(Bc[1]);
              Br = deg2rad(Bd);
              Bt = DDtoDMS(Bd);
            } else {
              return { error: "Please! Check Your Input." };
            }
          }
        } else if (!isNaN(B)) {
          Br = parseFloat(B);
          Bd = rad2deg(Br);
          Bt = DDtoDMS(Bd);
        }
      }

      if (Bd >= 180) {
        return { error: "Angle ∠B is too big." };
      }

      // Process angle A
      if (unit == "1") {
        Ad = parseFloat(A);
        At = DDtoDMS(Ad);
        Ar = deg2rad(Ad);
      } else {
        const Ac = A.split("/");
        if (Ac.length == 2) {
          if (Ac[0] == "pi" || Ac[0] == "pi()") {
            if (!isNaN(Ac[1])) {
              Ad = 180 / parseFloat(Ac[1]);
              Ar = deg2rad(Ad);
              At = DDtoDMS(Ad);
            } else {
              return { error: "Please! Check Your Input." };
            }
          }
        } else if (!isNaN(A)) {
          Ar = parseFloat(A);
          Ad = rad2deg(Ar);
          At = DDtoDMS(Ad);
        }
      }

      if (Ad >= 180) {
        return { error: "Angle ∠A is too big." };
      }

      if (Ad + Bd >= 180) {
        return {
          error:
            "These three values can't be used to develop a valid triangle.",
        };
      }

      Cd = 180 - Ad - Bd;
      Cr = deg2rad(Cd);
      Ct = DDtoDMS(Cd);
      a = Math.round(((b * Math.sin(Ar)) / Math.sin(Br)) * 100000) / 100000;
      c = Math.round(((b * Math.sin(Cr)) / Math.sin(Br)) * 100000) / 100000;
      comb = 6;
      check = true;
    }
    // Case 7: One side and two angles (c, A, B) - AAS
    else if (
      (a == null || a == "") &&
      (b == null || b == "") &&
      c != null &&
      !isNaN(c) &&
      A != null &&
      A != "" &&
      B != null &&
      B != "" &&
      (C == null || C == "")
    ) {
      c = parseFloat(c);

      // Process angle B
      if (unit == "1") {
        Bd = parseFloat(B);
        Bt = DDtoDMS(Bd);
        Br = deg2rad(Bd);
      } else {
        const Bc = B.split("/");
        if (Bc.length == 2) {
          if (Bc[0] == "pi" || Bc[0] == "pi()") {
            if (!isNaN(Bc[1])) {
              Bd = 180 / parseFloat(Bc[1]);
              Br = deg2rad(Bd);
              Bt = DDtoDMS(Bd);
            } else {
              return { error: "Please! Check Your Input." };
            }
          }
        } else if (!isNaN(B)) {
          Br = parseFloat(B);
          Bd = rad2deg(Br);
          Bt = DDtoDMS(Bd);
        }
      }

      if (Bd >= 180) {
        return { error: "Angle ∠B is too big." };
      }

      // Process angle A
      if (unit == "1") {
        Ad = parseFloat(A);
        At = DDtoDMS(Ad);
        Ar = deg2rad(Ad);
      } else {
        const Ac = A.split("/");
        if (Ac.length == 2) {
          if (Ac[0] == "pi" || Ac[0] == "pi()") {
            if (!isNaN(Ac[1])) {
              Ad = 180 / parseFloat(Ac[1]);
              Ar = deg2rad(Ad);
              At = DDtoDMS(Ad);
            } else {
              return { error: "Please! Check Your Input." };
            }
          }
        } else if (!isNaN(A)) {
          Ar = parseFloat(A);
          Ad = rad2deg(Ar);
          At = DDtoDMS(Ad);
        }
      }

      if (Ad >= 180) {
        return { error: "Angle ∠A is too big." };
      }

      if (Ad + Bd >= 180) {
        return {
          error:
            "These three values can't be used to develop a valid triangle.",
        };
      }

      Cd = 180 - Ad - Bd;
      Cr = deg2rad(Cd);
      Ct = DDtoDMS(Cd);
      a = Math.round(((c * Math.sin(Ar)) / Math.sin(Cr)) * 100000) / 100000;
      b = Math.round(((c * Math.sin(Br)) / Math.sin(Cr)) * 100000) / 100000;
      comb = 7;
      check = true;
    }
    // Case 8: One side and two angles (a, A, C) - AAS
    else if (
      a != null &&
      !isNaN(a) &&
      (b == null || b == "") &&
      (c == null || c == "") &&
      A != null &&
      A != "" &&
      (B == null || B == "") &&
      C != null &&
      C != ""
    ) {
      a = parseFloat(a);

      // Process angle A
      if (unit == "1") {
        Ad = parseFloat(A);
        At = DDtoDMS(Ad);
        Ar = deg2rad(Ad);
      } else {
        const Ac = A.split("/");
        if (Ac.length == 2) {
          if (Ac[0] == "pi" || Ac[0] == "pi()") {
            if (!isNaN(Ac[1])) {
              Ad = 180 / parseFloat(Ac[1]);
              Ar = deg2rad(Ad);
              At = DDtoDMS(Ad);
            } else {
              return { error: "Please! Check Your Input." };
            }
          }
        } else if (!isNaN(A)) {
          Ar = parseFloat(A);
          Ad = rad2deg(Ar);
          At = DDtoDMS(Ad);
        }
      }

      if (Ad >= 180) {
        return { error: "Angle ∠A is too big." };
      }

      // Process angle C
      if (unit == "1") {
        Cd = parseFloat(C);
        Ct = DDtoDMS(Cd);
        Cr = deg2rad(Cd);
      } else {
        const Cc = C.split("/");
        if (Cc.length == 2) {
          if (Cc[0] == "pi" || Cc[0] == "pi()") {
            if (!isNaN(Cc[1])) {
              Cd = 180 / parseFloat(Cc[1]);
              Cr = deg2rad(Cd);
              Ct = DDtoDMS(Cd);
            } else {
              return { error: "Please! Check Your Input." };
            }
          }
        } else if (!isNaN(C)) {
          Cr = parseFloat(C);
          Cd = rad2deg(Cr);
          Ct = DDtoDMS(Cd);
        }
      }

      if (Cd >= 180) {
        return { error: "Angle ∠C is too big." };
      }

      if (Ad + Cd >= 180) {
        return {
          error:
            "These three values can't be used to develop a valid triangle.",
        };
      }

      Bd = 180 - Ad - Cd;
      Br = deg2rad(Bd);
      Bt = DDtoDMS(Bd);
      b = Math.round(((a * Math.sin(Br)) / Math.sin(Ar)) * 100000) / 100000;
      c = Math.round(((a * Math.sin(Cr)) / Math.sin(Ar)) * 100000) / 100000;
      comb = 8;
      check = true;
    }
    // Case 9: One side and two angles (b, A, C) - AAS
    else if (
      (a == null || a == "") &&
      b != null &&
      !isNaN(b) &&
      (c == null || c == "") &&
      A != null &&
      A != "" &&
      (B == null || B == "") &&
      C != null &&
      C != ""
    ) {
      b = parseFloat(b);

      // Process angle A
      if (unit == "1") {
        Ad = parseFloat(A);
        At = DDtoDMS(Ad);
        Ar = deg2rad(Ad);
      } else {
        const Ac = A.split("/");
        if (Ac.length == 2) {
          if (Ac[0] == "pi" || Ac[0] == "pi()") {
            if (!isNaN(Ac[1])) {
              Ad = 180 / parseFloat(Ac[1]);
              Ar = deg2rad(Ad);
              At = DDtoDMS(Ad);
            } else {
              return { error: "Please! Check Your Input." };
            }
          }
        } else if (!isNaN(A)) {
          Ar = parseFloat(A);
          Ad = rad2deg(Ar);
          At = DDtoDMS(Ad);
        }
      }

      if (Ad >= 180) {
        return { error: "Angle ∠A is too big." };
      }

      // Process angle C
      if (unit == "1") {
        Cd = parseFloat(C);
        Ct = DDtoDMS(Cd);
        Cr = deg2rad(Cd);
      } else {
        const Cc = C.split("/");
        if (Cc.length == 2) {
          if (Cc[0] == "pi" || Cc[0] == "pi()") {
            if (!isNaN(Cc[1])) {
              Cd = 180 / parseFloat(Cc[1]);
              Cr = deg2rad(Cd);
              Ct = DDtoDMS(Cd);
            } else {
              return { error: "Please! Check Your Input." };
            }
          }
        } else if (!isNaN(C)) {
          Cr = parseFloat(C);
          Cd = rad2deg(Cr);
          Ct = DDtoDMS(Cd);
        }
      }

      if (Cd >= 180) {
        return { error: "Angle ∠C is too big." };
      }

      if (Ad + Cd >= 180) {
        return {
          error:
            "These three values can't be used to develop a valid triangle.",
        };
      }

      Bd = 180 - Ad - Cd;
      Br = deg2rad(Bd);
      Bt = DDtoDMS(Bd);
      a = Math.round(((b * Math.sin(Ar)) / Math.sin(Br)) * 100000) / 100000;
      c = Math.round(((b * Math.sin(Cr)) / Math.sin(Br)) * 100000) / 100000;
      comb = 9;
      check = true;
    }
    // Case 10: One side and two angles (c, A, C) - AAS
    else if (
      (a == null || a == "") &&
      (b == null || b == "") &&
      c != null &&
      !isNaN(c) &&
      A != null &&
      A != "" &&
      (B == null || B == "") &&
      C != null &&
      C != ""
    ) {
      c = parseFloat(c);

      // Process angle A
      if (unit == "1") {
        Ad = parseFloat(A);
        At = DDtoDMS(Ad);
        Ar = deg2rad(Ad);
      } else {
        const Ac = A.split("/");
        if (Ac.length == 2) {
          if (Ac[0] == "pi" || Ac[0] == "pi()") {
            if (!isNaN(Ac[1])) {
              Ad = 180 / parseFloat(Ac[1]);
              Ar = deg2rad(Ad);
              At = DDtoDMS(Ad);
            } else {
              return { error: "Please! Check Your Input." };
            }
          }
        } else if (!isNaN(A)) {
          Ar = parseFloat(A);
          Ad = rad2deg(Ar);
          At = DDtoDMS(Ad);
        }
      }

      if (Ad >= 180) {
        return { error: "Angle ∠A is too big." };
      }

      // Process angle C
      if (unit == "1") {
        Cd = parseFloat(C);
        Ct = DDtoDMS(Cd);
        Cr = deg2rad(Cd);
      } else {
        const Cc = C.split("/");
        if (Cc.length == 2) {
          if (Cc[0] == "pi" || Cc[0] == "pi()") {
            if (!isNaN(Cc[1])) {
              Cd = 180 / parseFloat(Cc[1]);
              Cr = deg2rad(Cd);
              Ct = DDtoDMS(Cd);
            } else {
              return { error: "Please! Check Your Input." };
            }
          }
        } else if (!isNaN(C)) {
          Cr = parseFloat(C);
          Cd = rad2deg(Cr);
          Ct = DDtoDMS(Cd);
        }
      }

      if (Ad + Cd >= 180) {
        return {
          error:
            "These three values can't be used to develop a valid triangle.",
        };
      }
      if (Cd >= 180) {
        return { error: "Angle ∠C is too big." };
      }

      Bd = 180 - Ad - Cd;
      Br = deg2rad(Bd);
      Bt = DDtoDMS(Bd);
      a = Math.round(((c * Math.sin(Ar)) / Math.sin(Cr)) * 100000) / 100000;
      b = Math.round(((c * Math.sin(Br)) / Math.sin(Cr)) * 100000) / 100000;
      comb = 10;
      check = true;
    }
    // Case 11: One side and two angles (a, B, C) - AAS
    else if (
      a != null &&
      !isNaN(a) &&
      (b == null || b == "") &&
      (c == null || c == "") &&
      (A == null || A == "") &&
      B != null &&
      B != "" &&
      C != null &&
      C != ""
    ) {
      a = parseFloat(a);

      // Process angle C
      if (unit == "1") {
        Cd = parseFloat(C);
        Ct = DDtoDMS(Cd);
        Cr = deg2rad(Cd);
      } else {
        const Cc = C.split("/");
        if (Cc.length == 2) {
          if (Cc[0] == "pi" || Cc[0] == "pi()") {
            if (!isNaN(Cc[1])) {
              Cd = 180 / parseFloat(Cc[1]);
              Cr = deg2rad(Cd);
              Ct = DDtoDMS(Cd);
            } else {
              return { error: "Please! Check Your Input." };
            }
          }
        } else if (!isNaN(C)) {
          Cr = parseFloat(C);
          Cd = rad2deg(Cr);
          Ct = DDtoDMS(Cd);
        }
      }

      if (Cd >= 180) {
        return { error: "Angle ∠C is too big." };
      }

      // Process angle B
      if (unit == "1") {
        Bd = parseFloat(B);
        Bt = DDtoDMS(Bd);
        Br = deg2rad(Bd);
      } else {
        const Bc = B.split("/");
        if (Bc.length == 2) {
          if (Bc[0] == "pi" || Bc[0] == "pi()") {
            if (!isNaN(Bc[1])) {
              Bd = 180 / parseFloat(Bc[1]);
              Br = deg2rad(Bd);
              Bt = DDtoDMS(Bd);
            } else {
              return { error: "Please! Check Your Input." };
            }
          }
        } else if (!isNaN(B)) {
          Br = parseFloat(B);
          Bd = rad2deg(Br);
          Bt = DDtoDMS(Bd);
        }
      }

      if (Bd >= 180) {
        return { error: "Angle ∠B is too big." };
      }

      if (Bd + Cd >= 180) {
        return {
          error:
            "These three values can't be used to develop a valid triangle.",
        };
      }

      Ad = 180 - Bd - Cd;
      Ar = deg2rad(Ad);
      At = DDtoDMS(Ad);
      b = Math.round(((a * Math.sin(Br)) / Math.sin(Ar)) * 100000) / 100000;
      c = Math.round(((a * Math.sin(Cr)) / Math.sin(Ar)) * 100000) / 100000;
      comb = 11;
      check = true;
    }
    // Case 12: One side and two angles (b, B, C) - AAS
    else if (
      (a == null || a == "") &&
      b != null &&
      !isNaN(b) &&
      (c == null || c == "") &&
      (A == null || A == "") &&
      B != null &&
      B != "" &&
      C != null &&
      C != ""
    ) {
      b = parseFloat(b);

      // Process angle C
      if (unit == "1") {
        Cd = parseFloat(C);
        Ct = DDtoDMS(Cd);
        Cr = deg2rad(Cd);
      } else {
        const Cc = C.split("/");
        if (Cc.length == 2) {
          if (Cc[0] == "pi" || Cc[0] == "pi()") {
            if (!isNaN(Cc[1])) {
              Cd = 180 / parseFloat(Cc[1]);
              Cr = deg2rad(Cd);
              Ct = DDtoDMS(Cd);
            } else {
              return { error: "Please! Check Your Input." };
            }
          }
        } else if (!isNaN(C)) {
          Cr = parseFloat(C);
          Cd = rad2deg(Cr);
          Ct = DDtoDMS(Cd);
        }
      }

      if (Cd >= 180) {
        return { error: "Angle ∠C is too big." };
      }

      // Process angle B
      if (unit == "1") {
        Bd = parseFloat(B);
        Bt = DDtoDMS(Bd);
        Br = deg2rad(Bd);
      } else {
        const Bc = B.split("/");
        if (Bc.length == 2) {
          if (Bc[0] == "pi" || Bc[0] == "pi()") {
            if (!isNaN(Bc[1])) {
              Bd = 180 / parseFloat(Bc[1]);
              Br = deg2rad(Bd);
              Bt = DDtoDMS(Bd);
            } else {
              return { error: "Please! Check Your Input." };
            }
          }
        } else if (!isNaN(B)) {
          Br = parseFloat(B);
          Bd = rad2deg(Br);
          Bt = DDtoDMS(Bd);
        }
      }

      if (Bd >= 180) {
        return { error: "Angle ∠B is too big." };
      }

      if (Bd + Cd >= 180) {
        return {
          error:
            "These three values can't be used to develop a valid triangle.",
        };
      }

      Ad = 180 - Bd - Cd;
      Ar = deg2rad(Ad);
      At = DDtoDMS(Ad);
      a = Math.round(((b * Math.sin(Ar)) / Math.sin(Br)) * 100000) / 100000;
      c = Math.round(((b * Math.sin(Cr)) / Math.sin(Br)) * 100000) / 100000;
      comb = 12;
      check = true;
    }
    // Case 13: One side and two angles (c, B, C) - AAS
    else if (
      (a == null || a == "") &&
      (b == null || b == "") &&
      c != null &&
      !isNaN(c) &&
      (A == null || A == "") &&
      B != null &&
      B != "" &&
      C != null &&
      C != ""
    ) {
      c = parseFloat(c);

      // Process angle C
      if (unit == "1") {
        Cd = parseFloat(C);
        Ct = DDtoDMS(Cd);
        Cr = deg2rad(Cd);
      } else {
        const Cc = C.split("/");
        if (Cc.length == 2) {
          if (Cc[0] == "pi" || Cc[0] == "pi()") {
            if (!isNaN(Cc[1])) {
              Cd = 180 / parseFloat(Cc[1]);
              Cr = deg2rad(Cd);
              Ct = DDtoDMS(Cd);
            } else {
              return { error: "Please! Check Your Input." };
            }
          }
        } else if (!isNaN(C)) {
          Cr = parseFloat(C);
          Cd = rad2deg(Cr);
          Ct = DDtoDMS(Cd);
        }
      }

      if (Cd >= 180) {
        return { error: "Angle ∠C is too big." };
      }

      // Process angle B
      if (unit == "1") {
        Bd = parseFloat(B);
        Bt = DDtoDMS(Bd);
        Br = deg2rad(Bd);
      } else {
        const Bc = B.split("/");
        if (Bc.length == 2) {
          if (Bc[0] == "pi" || Bc[0] == "pi()") {
            if (!isNaN(Bc[1])) {
              Bd = 180 / parseFloat(Bc[1]);
              Br = deg2rad(Bd);
              Bt = DDtoDMS(Bd);
            } else {
              return { error: "Please! Check Your Input." };
            }
          }
        } else if (!isNaN(B)) {
          Br = parseFloat(B);
          Bd = rad2deg(Br);
          Bt = DDtoDMS(Bd);
        }
      }

      if (Bd >= 180) {
        return { error: "Angle ∠B is too big." };
      }

      if (Bd + Cd >= 180) {
        return {
          error:
            "These three values can't be used to develop a valid triangle.",
        };
      }

      Ad = 180 - Bd - Cd;
      Ar = deg2rad(Ad);
      At = DDtoDMS(Ad);
      a = Math.round(((c * Math.sin(Ar)) / Math.sin(Cr)) * 100000) / 100000;
      b = Math.round(((c * Math.sin(Br)) / Math.sin(Cr)) * 100000) / 100000;
      comb = 13;
      check = true;
    }

    // Calculate additional properties if triangle is valid
    if (check === true) {
      area = Math.round(((a * b * Math.sin(Cr)) / 2) * 100000) / 100000;
      peri = a + b + c;
      semi = Math.round(((a + b + c) / 2) * 100000) / 100000;
      ha = Math.round(((2 * area) / a) * 100000) / 100000;
      hb = Math.round(((2 * area) / b) * 100000) / 100000;
      hc = Math.round(((2 * area) / c) * 100000) / 100000;
      ma =
        Math.round(
          Math.sqrt(
            Math.pow(a / 2, 2) + Math.pow(c, 2) - a * c * Math.cos(Br)
          ) * 100000
        ) / 100000;
      mb =
        Math.round(
          Math.sqrt(
            Math.pow(b / 2, 2) + Math.pow(a, 2) - a * b * Math.cos(Cr)
          ) * 100000
        ) / 100000;
      mc =
        Math.round(
          Math.sqrt(
            Math.pow(c / 2, 2) + Math.pow(b, 2) - b * c * Math.cos(Ar)
          ) * 100000
        ) / 100000;
      inr = Math.round((area / semi) * 100000) / 100000;
      circ = Math.round((a / (2 * Math.sin(Ar))) * 100000) / 100000;

      result.tech_a = a;
      result.tech_b = b;
      result.tech_c = c;
      result.tech_Ar = Ar;
      result.tech_Ad = Ad;
      result.tech_At = At;
      result.tech_Br = Br;
      result.tech_Bd = Bd;
      result.tech_Bt = Bt;
      result.tech_Cr = Cr;
      result.tech_Cd = Cd;
      result.tech_Ct = Ct;
      result.tech_area = area;
      result.tech_peri = peri;
      result.tech_semi = semi;
      result.tech_ha = ha;
      result.tech_hb = hb;
      result.tech_hc = hc;
      result.tech_ma = ma;
      result.tech_mb = mb;
      result.tech_mc = mc;
      result.tech_inr = inr;
      result.tech_circ = circ;
      result.tech_comb = comb;

      return result;
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationUnitTangentVectorCalculator
   * POST: /api/calculators-lol/unit-tangent-vector-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationUnitTangentVectorCalculator(body) {
    let x = body.tech_x;
    let y = body.tech_y;
    let z = body.tech_z;
    let t = body.tech_t;

    const isInvalid = (val) =>
      !val || /[<>&]|php|print_r|print|echo|script|=|%/i.test(val);

    if (isInvalid(x) || isInvalid(y) || isInvalid(z)) {
      return { error: "Please! Check Your Input." };
    }

    if (!isFinite(t)) {
      return { error: "Please! Check Your Input." };
    }

    const formatExpr = (expr) => {
      return expr
        .replace(/ /g, "")
        .replace(/\+/g, "plus")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**")
        .replace(/e\^sqrt\(x\)/g, "exp(2*x)");
    };

    let parem = formatExpr(x);
    let parem1 = formatExpr(y);
    let parem2 = formatExpr(z);

    const containsTrig = (str) => /sin|cos|tan/i.test(str);
    const checkMethod =
      containsTrig(x) || containsTrig(y) || containsTrig(z)
        ? "method1"
        : "method2";

    try {
      const response = await axios.get("http://167.172.134.148/utvc", {
        timeout: 120000,
        params: {
          eq: parem,
          eq1: parem1,
          eq2: parem2,
          t: t,
          check: checkMethod,
        },
      });

      const buffer = response.data.split("@@@");
      let result = { check: buffer[0] };

      if (buffer[0] === "method1") {
        result.tech_enter = buffer[1];
        result.tech_enter1 = buffer[2];
        result.tech_enter2 = buffer[3];
        result.tech_deriv = buffer[4];
        result.tech_deriv1 = buffer[5];
        result.tech_deriv2 = buffer[6];
        result.tech_steps = buffer[7];
        result.tech_steps1 = buffer[8];
        result.tech_steps2 = buffer[9];
        result.tech_eq_len = buffer[10];
        result.tech_eq1_len = buffer[11];
        result.tech_eq2_len = buffer[12];
        result.tech_eq_solve = buffer[13];
        if (t) {
          result.tech_res = buffer[14];
          result.tech_res1 = buffer[15];
          result.tech_res2 = buffer[16];
        }
        result.t = t;
      } else if (buffer[0] === "method2") {
        result.tech_enter = buffer[1];
        result.tech_enter1 = buffer[2];
        result.tech_enter2 = buffer[3];
        result.tech_deriv = buffer[4];
        result.tech_deriv1 = buffer[5];
        result.tech_deriv2 = buffer[6];
        result.tech_steps = buffer[7];
        result.tech_steps1 = buffer[8];
        result.tech_steps2 = buffer[9];
        result.tech_eq_len = buffer[10];
        result.tech_eq1_len = buffer[11];
        result.tech_eq2_len = buffer[12];
        result.tech_ans = buffer[13];
        result.tech_ans1 = buffer[14];
        result.tech_ans2 = buffer[15];
        result.tech_t = t;
      } else {
        return { error: "Please! Check Your Input." };
      }

      return result;
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationRemainderTheoremCalculator
   * POST: /api/calculators-lol/remainder-theorem-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRemainderTheoremCalculator(body) {
    let num = body.tech_num;
    let denom = body.tech_denom;

    const isInvalid = (val) =>
      !val || /[<>&]|php|print_r|print|echo|script|=|%/i.test(val);

    if (isInvalid(num) || isInvalid(denom)) {
      return { error: "Please Enter Valid Input." };
    }

    const formatExpr = (expr) => {
      return expr
        .replace(/ /g, "")
        .replace(/\+/g, "plus")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**")
        .replace(/e\^sqrt\(x\)/g, "exp(2*x)");
    };

    let parem = formatExpr(num);
    let parem1 = formatExpr(denom);

    try {
      const response = await axios.get("http://167.172.134.148/r_t", {
        timeout: 120000,
        params: {
          eq: parem,
          eq1: parem1,
        },
      });

      const buffer = response.data.split("@@@");
      return {
        tech_enter: buffer[0],
        tech_enter1: buffer[1],
        tech_x: buffer[2],
        tech_ans: buffer[3],
      };
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationPowerSetCalculator
   * POST: /api/calculators-lol/power-set-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPowerSetCalculator(body) {
    let set = body.tech_set;

    let result = {};

    // Input validation
    if (
      /<|>|\&|\+|\-|\(|\)|\{|\}|\[|\]|\||php|print_r|print|echo|sin|cos|tan|arcsin|arccos|arctan|script|=|&|%/i.test(
        set
      )
    ) {
      result.error = "Please Enter Valid Input.";
      return result;
    }

    if (set && set.trim() !== "") {
      set = set.replace(/\s+/g, "").split(",");

      if (set.length >= 10) {
        result.error = "Please Enter maximum 10 numbers.";
        return result;
      }

      // Powerset function
      function powerSet(array) {
        let results = [[]];
        array.forEach((value, key) => {
          results.forEach((subset) => {
            results.push([...subset, value]);
          });
        });

        results.sort((a, b) => {
          if (a.length !== b.length) {
            return a.length - b.length;
          }
          return 0;
        });

        return results;
      }

      let size = set.length;
      let powset = powerSet(set);
      let count = powset.length;

      // Format powerset as string
      let powersetStr = powset
        .map((subset) => `{${subset.join(",")}}`)
        .join(",");

      result.tech_size = size;
      result.tech_powerset = powersetStr;
      result.tech_subsets = count;
      result.tech_pro_subsets = count - 1;
      return result;
    } else {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /** getCalculationGradientCalculator
   * POST: /api/calculators-lol/gradient-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationGradientCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let x = body.tech_x;
    let y = body.tech_y;
    let z = body.tech_z;
    let type = body.tech_type;

    let result = {};

    const invalidPattern = /<|>|\&|php|print_r|print|echo|script|=|&|%/i;

    if (!EnterEq || invalidPattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    if (type === "two") {
      if (isNaN(x) || isNaN(y)) {
        return { error: "Please! Check Your Input." };
      }
    } else if (type === "three") {
      if (isNaN(x) || isNaN(y) || isNaN(z)) {
        return { error: "Please! Check Your Input." };
      }
    } else {
      return { error: "Please! Check Your Input." };
    }

    // Prepare and sanitize expression
    let expr = EnterEq.replace(/\s+|%20/g, "")
      .replace(/\+/g, "plus")
      .replace(/[{}]/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^x/g, "exp(x)")
      .replace(/e\^y/g, "exp(y)")
      .replace(/e\^z/g, "exp(z)")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    try {
      const params = { eq: expr, x, y, type };
      if (type === "three") params.z = z;

      const r = await axios.get("http://167.172.134.148/gradient", { params });
      const buf = r.data.split("@@@");

      if (type === "two") {
        const [difs1, difs2, x1, y1, enter, steps, steps1] = buf;
        Object.assign(result, {
          tech_difs1: difs1,
          tech_difs2: difs2,
          tech_x1: +parseFloat(x1).toFixed(5),
          tech_y1: +parseFloat(y1).toFixed(5),
          tech_enter: enter,
          tech_steps: steps,
          tech_steps1: steps1,
        });
      } else {
        const [difs1, difs2, difs3, x1, y1, z1, enter, steps, steps1, steps2] =
          buf;
        Object.assign(result, {
          tech_difs1: difs1,
          tech_difs2: difs2,
          tech_difs3: difs3,
          tech_x1: +parseFloat(x1).toFixed(5),
          tech_y1: +parseFloat(y1).toFixed(5),
          tech_z1: +parseFloat(z1).toFixed(5),
          tech_enter: enter,
          tech_steps: steps,
          tech_steps1: steps1,
          tech_steps2: steps2,
        });
      }

      return result;
    } catch (e) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationVertexFormCalculator
   * POST: /api/calculators-lol/vertex-form-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationVertexFormCalculator(body) {
    let a1 = body.tech_a1;
    let b1 = body.tech_b1;
    let c1 = body.tech_c1;
    let a = body.tech_a;
    let b = body.tech_b;
    let c = body.tech_c;
    let submit = body.tech_type;

    let result = {};
    let A,
      B,
      C,
      variable_ans = "x",
      eq = "";

    if (submit === "standard") {
      if (!a1 || a1 == 0) {
        result.error = "Enter a, In quadratic equation a is not equal 0";
        return result;
      }

      eq += `${a1}x^2`;

      if (b1 && b1 != 0) {
        eq += b1 > 0 ? ` + ${b1}x` : ` ${b1}x`;
      }

      if (c1 == null) c1 = 0;

      if (c1 && c1 != 0) {
        eq += c1 > 0 ? ` + ${c1}` : ` ${c1}`;
      }

      A = Number(a1);
      B = Number(b1) || 0;
      C = Number(c1) || 0;
    } else {
      if (c == null) c = 0;
      if (b == null) b = 0;

      if (!isNaN(a) && a !== "0" && !isNaN(b) && !isNaN(c)) {
        A = Number(a);
        C = Math.pow(b, 2) * A + Number(c);
        B = -1 * b * 2 * A;
      } else {
        result.error = "Please Check Your Input.";
        return result;
      }
    }

    let round3 = C.toString().includes(".")
      ? C.toString().split(".")[1].length
      : 0;
    let firstx = Number(((-1 * B) / (2 * A)).toFixed(3));
    let round1 = firstx.toString().includes(".")
      ? firstx.toString().split(".")[1].length
      : 0;

    let first_part = A * Math.pow(firstx, 2);
    let second_part = B * firstx;

    // Build evaluation string
    if (second_part < 0 && C < 0) {
      eq = `${first_part} ${second_part} ${C}`;
    } else if (second_part < 0 && C >= 0) {
      eq = `${first_part} ${second_part} + ${C}`;
    } else if (second_part >= 0 && C < 0) {
      eq = `${first_part} + ${second_part} ${C}`;
    } else {
      eq = `${first_part} + ${second_part} + ${C}`;
    }

    let yaxis;
    try {
      yaxis = eval(eq); // Safe in this controlled context
    } catch (e) {
      result.error = "Evaluation Error";
      return result;
    }

    yaxis = Number(yaxis.toFixed(3));
    let round2 = yaxis.toString().includes(".")
      ? yaxis.toString().split(".")[1].length
      : 0;

    let vertexStr = `${A}(${variable_ans} ${
      firstx < 0 ? "+ " + -firstx : "- " + firstx
    })^2 ${yaxis < 0 ? "- " + -yaxis : "+ " + yaxis}`;

    result.tech_vertex = vertexStr;
    result.tech_A = A;
    result.tech_B = B;
    result.tech_C = C;
    result.tech_firstx = firstx;
    result.tech_yaxis = yaxis;
    result.tech_round1 = round1;
    result.tech_round2 = round2;
    result.tech_round3 = round3;
    result.tech_variable_ans = variable_ans;
    result.tech_submit = submit;

    return result;
  }

  /** getCalculationMidpointRuleCalculator
   * POST: /api/calculators-lol/midpoint-rule-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMidpointRuleCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let lb = body.tech_lb;
    let ub = body.tech_ub;
    let n = body.tech_n;
    let withVal = body.tech_with;

    let result = {};

    const invalidPattern = /<|>|\&|php|print_r|print|echo|script|=|&|%/i;

    if (!EnterEq || invalidPattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    if (isNaN(lb) || isNaN(ub) || isNaN(n) || lb >= ub) {
      return {
        error:
          lb >= ub
            ? "The lower limit should be less than the upper limit."
            : "Please! Check Your Input.",
      };
    }

    let expr = EnterEq.replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    let diff = (ub - lb) / n;
    let final = parseFloat(lb);
    let limit_a = [final];
    let limit = `${final}`;

    while (final < ub) {
      final += diff;
      limit_a.push(final);
      limit += `, ${final}`;
    }

    try {
      const postData = qs.stringify({
        equ: expr,
        with: withVal,
        ub,
        lb,
        n,
        type: 3,
        diff,
      });

      const response = await axios.post(
        "http://167.172.134.148/new-riemann",
        postData,
        {
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
          },
          timeout: 120000,
        }
      );

      const buffer = response.data;
      const steps = buffer[0].split("HA");

      Object.assign(result, {
        tech_steps: steps,
        tech_res: buffer[1],
        tech_enter: buffer[2],
        tech_ub: ub,
        tech_lb: lb,
        tech_n: n,
        tech_diff: diff,
        tech_limit: limit,
        tech_limit_a: limit_a,
        tech_with: withVal,
      });

      return result;
    } catch (err) {
      console.error("Error during request:", err.message);
      return { error: "Please! Check Your Input.", detail: err.message };
    }
  }

  /** getCalculationSubsetCalculator
   * POST: /api/calculators-lol/subset-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSubsetCalculator(body) {
    let cal_by = body.tech_cal_by;
    let set = body.tech_set;
    let cardinal = body.tech_cardinal;

    let result = {};
    let check = false;
    let size,
      count,
      ne = [];

    // Validation regex
    const invalidPattern =
      /<|>|\&|\+|\-|\(|\)|\{|\}|\[|\]|\||php|print_r|print|echo|sin|cos|tan|arcsin|arccos|arctan|script|=|&|%/i;

    if (cal_by === "elements") {
      if (!set || invalidPattern.test(set)) {
        result.error = "Please Enter Valid Input.";
        return result;
      }

      check = true;
      set = set.replace(/\s/g, "").split(",");

      if (set.length > 10) {
        result.error = "Number of Elements must be less than or equal to 10.";
        return result;
      }

      // Generate powerset
      function powerSet(array) {
        let results = [[]];
        for (let value of array) {
          let temp = [];
          for (let subset of results) {
            temp.push([...subset, value]);
          }
          results = results.concat(temp);
        }

        results.sort((a, b) => a.length - b.length);
        return results;
      }

      size = set.length;
      const powset = powerSet(set);
      count = powset.length;

      let arr = powset.map((sub) => `{${sub.join(",")}}`).join(",");
      result.tech_pw = arr;
    } else if (cal_by === "cardinality") {
      if (!isNaN(cardinal)) {
        check = true;
        if (cardinal > 100) {
          result.error = "Elements must be less than or equal to 100.";
          return result;
        }

        size = Number(cardinal);
        count = Math.pow(2, size);
      } else {
        result.error = "Please! Check Your Input.";
        return result;
      }
    }

    if (check) {
      function factorial(n) {
        let result = 1;
        for (let i = 2; i <= n; i++) {
          result *= i;
        }
        return result;
      }

      let size1 = size;
      for (let i = 0; i <= size; i++) {
        let value = factorial(size) / (factorial(i) * factorial(size1));
        ne.push(value);
        size1--;
      }

      result.tech_subsets = count;
      result.tech_pro_subsets = count - 1;
      result.tech_ne = ne;
      return result;
    } else {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /** getCalculationMaclaurinSeriesCalculator
   * POST: /api/calculators-lol/maclaurin-series-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMaclaurinSeriesCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let find = body.tech_find;
    let n = body.tech_n;
    let withVal = body.tech_with;

    let point = 0;
    let result = {};

    const invalidPattern = /<|>|\&|php|print_r|print|echo|script|=|&|%/i;

    if (!EnterEq || invalidPattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    if (isNaN(n)) {
      return { error: "Please! Check Your Input." };
    }

    if (find == null) {
      find = "";
    }

    let expr = EnterEq.replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^x/g, "exp(x)")
      .replace(/e\^y/g, "exp(y)")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    try {
      const response = await axios.get("http://167.172.134.148/taylor", {
        params: {
          equ: expr,
          wrt: withVal,
          how: n,
          find: find,
          point: point,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@HA_");

      result.tech_eexe = buffer[0];
      result.tech_enter = buffer[1];
      result.tech_res = buffer[2];
      result.tech_series = buffer[3];

      if (!isNaN(find)) {
        result.tech_efun = buffer[4];
        result.tech_eser = buffer[5];
        result.tech_efv = buffer[6];
        result.tech_fsv = buffer[7];
        result.tech_err = buffer[8];
      }

      return result;
    } catch (err) {
      console.error("Request error:", err.message);
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationDifferenceQuotientCalculator
   * POST: /api/calculators-lol/difference-quotient-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDifferenceQuotientCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let result = {};

    const invalidPattern = /<|>|\&|php|print_r|print|echo|script|=|%/i;
    if (!EnterEq || invalidPattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    let parem = EnterEq.toLowerCase();

    // Clean and sanitize the input
    parem = parem.replace(
      /f\^-1\(x\)=?|f\(x\)=|y=|h\(x\)=|f-1\(2\)=|y=f\(x\)=|=y|∣|%20|\||f\s*\(\s*x\s*\)\s*=|=|f\(x\)|fx=|fx/g,
      ""
    );

    // parem = parem.replace(/f\^-1\(x\)|f\(x\)=|y=|h\(x\)=|f-1\(2\)=|y=f\(x\)=|=y|∣|f\^-1\(x\)=|%20|\||f \( x \ ) =|=|f\(x\)|fx=|fx/g, '');

    const variableMatches = parem.match(/[a-zA-Z]+/g) || [];
    const filteredVars = variableMatches.filter(
      (v) =>
        !["log", "sin", "cos", "tan", "exp", "sqrt", "e", "arctan"].includes(v)
    );
    const uniqueVars = [...new Set(filteredVars)];

    if (uniqueVars.length > 1) {
      return { error: "More than one variable found in the equation" };
    } else if (uniqueVars.length === 0) {
      return { error: "No variable found in the equation." };
    }

    const withVal = uniqueVars[0];

    // Additional formatting
    parem = parem
      .replace(/sqrt\(/gi, "sqrt(")
      .replace(/arctan\(/gi, "atan(")
      .replace(/e\^([a-z0-9\(\)\*\+]+)/gi, "zain($1)")
      .replace(/\^/g, "**")
      .replace(/−/g, "-")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/\[/g, "(")
      .replace(/\]/g, ")")
      .replace(/(\d)([a-z\(])/gi, "$1*$2");

    // f(x + h)
    let parem1 = parem.replace(new RegExp(withVal, "g"), `(${withVal} + h)`);
    parem1 = parem1.replace(/sqrt\(/gi, "sqrt(").replace(/arctan\(/gi, "atan(");

    let final = `((${parem1}) - (${parem}))/h`;

    try {
      const response = await axios.get("http://167.172.134.148/difference", {
        params: {
          equ: parem,
          wrt: withVal,
          equ1: parem1,
          final: final,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      result.tech_with = withVal;
      result.tech_enter = buffer[0];
      result.tech_equ1 = buffer[1];
      result.tech_final = buffer[2];
      result.tech_res = buffer[3];

      return result;
    } catch (err) {
      console.error("Error:", err.message);
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationComplexNumberCalculator
   * POST: /api/calculators-lol/complex-number-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationComplexNumberCalculator(body) {
    let exp = body.tech_exp;
    let result = {};

    const invalidPattern =
      /<|>|&|php|print_r|print|echo|script|=|sin|cos|tan|arcsin|arccos|arctan|%/i;

    // Validation
    if (!exp || invalidPattern.test(exp)) {
      return { error: "Please Enter Valid Input." };
    }

    // Expression cleanup
    let parem = exp;
    parem = parem.replace(/\s+/g, "");
    parem = parem.replace(/%20/g, "");
    parem = parem.replace(/\+/g, "plus");
    parem = parem.replace(/{/g, "(");
    parem = parem.replace(/}/g, ")");
    parem = parem.replace(/e\^sqrt\(x\)/g, "exp(2*x)");
    parem = parem.replace(/e\^/g, "exp");
    parem = parem.replace(/exp\^/g, "exp");
    parem = parem.replace(/\^/g, "**");

    try {
      const response = await axios.get("http://167.172.134.148/complex_num", {
        params: {
          equ: parem,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      result.tech_enter = buffer[0];
      result.tech_expand = buffer[1];
      result.tech_expand1 = buffer[2];
      result.tech_a = buffer[3];
      result.tech_b = buffer[4];
      result.tech_b1 = buffer[5];
      result.tech_r = buffer[6];
      result.tech_theta = buffer[7];
      result.tech_simp = buffer[8];

      return result;
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationWronskianCalculator
   * POST: /api/calculators-lol/wronskian-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationWronskianCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let wrt = body.tech_with;

    let result = {};

    const invalidPattern = /<|>|&|php|print_r|print|echo|script|=|%/i;

    if (!EnterEq || !wrt || invalidPattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    let parem = EnterEq;
    parem = parem.replace(/\s+/g, "");
    parem = parem.replace(/\+/g, "plus");
    parem = parem.replace(/{/g, "(");
    parem = parem.replace(/}/g, ")");
    parem = parem.replace(/e\^sqrt\(x\)/g, "exp(2*x)");
    parem = parem.replace(/e\^x/g, "exp(x)");
    parem = parem.replace(/e\^y/g, "exp(y)");
    parem = parem.replace(/e\^/g, "exp");
    parem = parem.replace(/exp\^/g, "exp");
    parem = parem.replace(/\^/g, "**");

    const funcCount = parem.split(",").length;

    if (funcCount < 2 || funcCount > 5) {
      return {
        error:
          "The number of functions cannot be less than 2 or greater than 5.",
      };
    }

    try {
      const response = await axios.get("http://167.172.134.148/wronskian", {
        params: {
          equ: parem,
          wrt: wrt,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      result.tech_enter = buffer[0];
      result.tech_matrix = buffer[1];
      result.tech_res = buffer[2];

      return result;
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationInverseLaplaceTransformCalculator
   * POST: /api/calculators-lol/inverse-laplace-transform-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationInverseLaplaceTransformCalculator(body) {
    let EnterEq = body.tech_EnterEq;

    let result = {};
    const invalidPattern = /<|>|php|print_r|print|echo|script|=|%|&/i;

    if (!EnterEq || invalidPattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    let parem = EnterEq;
    parem = parem.replace(/\s+/g, "");
    parem = parem.replace(/\+/g, "plus");
    parem = parem.replace(/%20/g, "");
    parem = parem.replace(/{/g, "(");
    parem = parem.replace(/}/g, ")");
    parem = parem.replace(/e\^s/g, "exp(s)");
    parem = parem.replace(/e\^sqrt\(x\)/g, "exp(2*x)");
    parem = parem.replace(/e\^/g, "exp");
    parem = parem.replace(/exp\^/g, "exp");
    parem = parem.replace(/\^/g, "**");

    try {
      const response = await axios.get("http://167.172.134.148/inverse_lap", {
        params: {
          equ: parem,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      result.tech_ans = buffer[0];
      result.tech_enter = buffer[1];

      return result;
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationInverseLaplaceTransformCalculator
   * POST: /api/calculators-lol/summation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSummationCalculator(body) {
    let cal_meth = body.tech_cal_meth;
    let nums = body.tech_nums;
    let eq = body.tech_eq;
    let x = body.tech_x;
    let n = body.tech_n;

    let result = {};
    const invalidPattern =
      /<|>|\&|\+|\-|\(|\)|\{|\}|\[|\]|\||php|print_r|print|echo|script|=|%|sin|cos|tan|arcsin|arccos|arctan/i;

    if (
      (nums && invalidPattern.test(nums)) ||
      (eq && invalidPattern.test(eq)) ||
      (x && invalidPattern.test(x)) ||
      (n && invalidPattern.test(n))
    ) {
      return { error: "Please! Enter Valid Input." };
    }

    if (cal_meth === "simple_sum") {
      if (nums) {
        nums = nums.replace(/\s+/g, "");
        let numArr = nums.split(",").map(Number);
        let sum = numArr.reduce((acc, val) => acc + val, 0);
        let tn = numArr.length;

        result.tech_sum = sum;
        result.tech_tn = tn;
        return result;
      } else {
        return { error: "Please! Check Your Input." };
      }
    } else if (cal_meth === "sigma_sum") {
      if (!eq || !x || !n) {
        return { error: "Please! Check Your Input." };
      }

      let parem = eq;
      parem = parem.replace(/\s+/g, "");
      parem = parem.replace(/%20/g, "");
      parem = parem.replace(/\+/g, "plus");
      parem = parem.replace(/{/g, "(");
      parem = parem.replace(/}/g, ")");
      parem = parem.replace(/e\^sqrt\(x\)/g, "exp(2*x)");
      parem = parem.replace(/e\^/g, "exp");
      parem = parem.replace(/exp\^/g, "exp");
      parem = parem.replace(/\^/g, "**");

      try {
        const response = await axios.get("http://167.172.134.148/summation", {
          params: {
            equ: parem,
            x: x,
            n: n,
          },
          timeout: 120000,
        });

        const buffer = response.data.split("@@@");

        if (buffer[0] === "False") {
          result.tech_cnvrgnt = buffer[0];
          result.tech_enter = buffer[1];
        } else {
          result.tech_cnvrgnt = buffer[0];
          result.tech_enter = buffer[1];
          result.tech_sum = buffer[2];

          let solve = buffer[3].split("###");
          solve.pop();
          result.tech_solve = solve;
          result.tech_tn = solve.length;

          let i_n = buffer[4].split("###");
          i_n.pop();
          result.tech_i_n = i_n;
        }

        return result;
      } catch (err) {
        return { error: "Please! Check Your Input." };
      }
    } else {
      return { error: "Invalid calculation method." };
    }
  }

  /** getCalculationPolarCoordinatesCalculator
   * POST: /api/calculators-lol/polar-coordinates-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPolarCoordinatesCalculator(body) {
    let x = body.tech_x1;
    let y = body.tech_x2;
    let chose = body.tech_chose;

    let result = {};

    if (x === undefined || y === undefined || x === "" || y === "") {
      return { error: "Please Check Your Input." };
    }

    try {
      const response = await axios.get("http://167.172.134.148/polar", {
        params: {
          x: x,
          y: y,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      let angle = parseFloat(buffer[0]);
      let magnitude = parseFloat(buffer[4]);
      let atn = angle / magnitude;

      let one = Math.atan(atn);
      let two = one + Math.PI;

      let x1 = magnitude * Math.cos(angle);
      let y1 = magnitude * Math.sin(angle);

      result.tech_mag = buffer[1];
      result.tech_ex = buffer[2];
      result.tech_ey = buffer[3];
      result.tech_one = one;
      result.tech_x1 = x1;
      result.tech_y1 = y1;
      result.tech_chose = chose;
      result.tech_x = magnitude;
      result.tech_y = angle;
      result.tech_two = two;

      return result;
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationConvolutionCalculator
   * POST: /api/calculators-lol/convolution-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationConvolutionCalculator(body) {
    let seq1 = body.tech_seq1;
    let seq2 = body.tech_seq2;

    if (!seq1 || !seq2) {
      return { error: "Please! Check Your Input." };
    }

    let set1 = seq1
      .split(",")
      .map((s) => s.trim())
      .filter(Boolean);
    let set2 = seq2
      .split(",")
      .map((s) => s.trim())
      .filter(Boolean);

    let isValid = set1.every((n) => !isNaN(n)) && set2.every((n) => !isNaN(n));

    if (!isValid) {
      return { error: "Please! Check Your Input." };
    }

    try {
      const response = await axios.get("http://167.172.134.148/convolution", {
        params: {
          seq1: seq1,
          seq2: seq2,
        },
        timeout: 120000,
      });

      const buffer = response.data;
      let conv = buffer.split("###");
      conv.pop(); // Remove last empty element

      return {
        tech_conv: conv,
      };
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationConvolutionCalculator
   * POST: /api/calculators-lol/jacobian-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationJacobianCalculator(body) {
    let xu = body.tech_xu;
    let xu_var = body.tech_xu_var;
    let yv = body.tech_yv;
    let yv_var = body.tech_yv_var;
    let zw = body.tech_zw;
    let zw_var = body.tech_zw_var;
    let submit = body.tech_type;

    // Input security check
    const invalidPattern = /<|>|\&|php|print_r|print|echo|script|=|&|%/i;
    if (
      invalidPattern.test(xu) ||
      invalidPattern.test(yv) ||
      invalidPattern.test(zw)
    ) {
      return { error: "Please Enter Valid Input." };
    }

    if (!xu || !yv) {
      return { error: "Please Check Your Input." };
    }

    // Cleaning helper
    const clean = (str) =>
      str
        .replace(/ /g, "")
        .replace(/%20/g, "")
        .replace(/\+/g, "plus")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**");

    let parem = clean(xu);
    let parem1 = clean(yv);
    let parem2 = zw ? clean(zw) : null;

    try {
      let apiURL = "http://167.172.134.148/jacobian";
      let params = {
        equ: parem,
        equ1: parem1,
        var: xu_var,
        var1: yv_var,
        check: submit,
      };

      if (submit === "three" && parem2) {
        params.equ2 = parem2;
        params.var2 = zw_var;
      }

      const response = await axios.get(apiURL, {
        params,
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      if (submit === "three") {
        return {
          tech_enter: buffer[0],
          tech_enter1: buffer[1],
          tech_enter2: buffer[2],
          tech_jacob: buffer[3],
          tech_dtrmnt: buffer[4],
          tech_var: buffer[5],
          tech_var1: buffer[6],
          tech_var2: buffer[7],
          tech_check: submit,
        };
      } else {
        return {
          tech_enter: buffer[0],
          tech_enter1: buffer[1],
          tech_jacob: buffer[2],
          tech_dtrmnt: buffer[3],
          tech_var: buffer[4],
          tech_var1: buffer[5],
          tech_check: submit,
        };
      }
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationHyperbolaCalculator
   * POST: /api/calculators-lol/hyperbola-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationHyperbolaCalculator(body) {
    let x = body.tech_x;
    let y = body.tech_y;
    let a = body.tech_a;
    let b = body.tech_b;

    let result = {};

    if (!isNaN(x) && !isNaN(y) && !isNaN(a) && !isNaN(b)) {
      x = Number(x);
      y = Number(y);
      a = Number(a);
      b = Number(b);

      // Perfect square check
      function isPerfectSquare(n) {
        let sqrt = Math.sqrt(n);
        if (Number.isInteger(sqrt)) {
          return sqrt;
        } else {
          return `\\sqrt{${n}}`;
        }
      }

      let c1 = x;
      let c2 = y;
      let as = Math.sqrt(a);
      let bs = Math.sqrt(b);

      let v1 = `${(c1 - as).toFixed(5)} , ${c2}`;
      let v2 = `${(c1 + as).toFixed(5)} , ${c2}`;
      let v21 = +(c2 - bs).toFixed(5);
      let v22 = +(c2 + bs).toFixed(5);

      let c = Math.sqrt(a + b);
      let f1 = `${(c1 - c).toFixed(5)} , ${c2}`;
      let f2 = `${(c1 + c).toFixed(5)} , ${c2}`;
      let ecc = +(c / as).toFixed(5);
      let fp = +(b / c).toFixed(5);

      let dir1 = +(c1 - (a * c) / (a + b)).toFixed(5);
      let dir2 = +(c1 + (a * c) / (a + b)).toFixed(5);
      let fl1 = +(c1 - c).toFixed(5);
      let fl2 = +(c1 + c).toFixed(5);

      let ashow = isPerfectSquare(a);
      let bshow = isPerfectSquare(b);
      let cshow = isPerfectSquare(a + b);

      result = {
        tech_as: as,
        tech_bs: bs,
        tech_v1: v1,
        tech_v2: v2,
        tech_v21: v21,
        tech_v22: v22,
        tech_f1: f1,
        tech_f2: f2,
        tech_ecc: ecc,
        tech_fp: fp,
        tech_dir1: dir1,
        tech_dir2: dir2,
        tech_fl1: fl1,
        tech_fl2: fl2,
        tech_c: c,
        tech_ashow: ashow,
        tech_bshow: bshow,
        tech_cshow: cshow,
      };
    } else {
      result.error = "Please! Check Your Input.";
    }

    return result;
  }

  /** getCalculationWasherMethodCalculator
   * POST: /api/calculators-lol/washer-method-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationWasherMethodCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let EnterEq1 = body.tech_EnterEq1;
    let ub = body.tech_ub;
    let lb = body.tech_lb;

    // Validation: Check required fields and prevent script injection
    const invalidPattern = /<|>|\&|php|print_r|print|echo|script|=|%/i;
    if (
      !EnterEq ||
      !EnterEq1 ||
      invalidPattern.test(EnterEq) ||
      invalidPattern.test(EnterEq1)
    ) {
      return { error: "Please! Check Your Input." };
    }

    if (!isFinite(ub) || !isFinite(lb)) {
      return { error: "Please! Check Your Input." };
    }

    // Function to clean expression
    const clean = (str) =>
      str
        .replace(/ /g, "")
        .replace(/\+/g, "plus")
        .replace(/%20/g, "")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
        .replace(/e\^x/g, "exp(x)")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**");

    let parem = clean(EnterEq);
    let parem1 = clean(EnterEq1);

    // Construct washer formula: (f(x))^2 - (g(x))^2
    let equ = `(${parem})**2-(${parem1})**2`;

    try {
      const response = await axios.get("http://167.172.134.148/washer", {
        params: {
          equ: equ,
          ub: ub,
          lb: lb,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      return {
        tech_step: buffer[0],
        tech_res: buffer[1],
        tech_enter: buffer[2],
        tech_ress: buffer[3],
        tech_ress1: buffer[4],
      };
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationShellMethodCalculator
   * POST: /api/calculators-lol/shell-method-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationShellMethodCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let ub = body.tech_ub;
    let lb = body.tech_lb;
    let withVar = body.tech_with;

    const invalidPattern = /<|>|\&|php|print_r|print|echo|script|=|%/i;
    if (!EnterEq || invalidPattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    if (!isFinite(ub) || !isFinite(lb)) {
      return { error: "Please! Check Your Input." };
    }

    // Expression formatting
    const clean = (str) =>
      str
        .replace(/ /g, "")
        .replace(/\+/g, "plus")
        .replace(/%20/g, "")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
        .replace(/e\^x/g, "exp(x)")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**");

    let parem = clean(EnterEq);
    withVar = withVar?.trim() || "";

    let equ = `2*pi*${withVar}(${parem})`;

    try {
      const response = await axios.get("http://167.172.134.148/shell", {
        params: {
          equ: equ,
          ub: ub,
          lb: lb,
          with: withVar,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      return {
        tech_step: buffer[0],
        tech_res: buffer[1],
        tech_enter: buffer[2],
        tech_ress: buffer[3],
        tech_ress1: buffer[4],
      };
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationImplicitDifferentiationCalculator
   * POST: /api/calculators-lol/implicit-differentiation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationImplicitDifferentiationCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let EnterEq1 = body.tech_EnterEq1;
    let x = body.tech_x;
    let y = body.tech_y;
    let withVar = body.tech_with;

    const invalidPattern = /<|>|\&|php|print_r|print|echo|script|=|%/i;

    if (
      !EnterEq ||
      !EnterEq1 ||
      invalidPattern.test(EnterEq) ||
      invalidPattern.test(EnterEq1)
    ) {
      return { error: "Please! Check Your Input." };
    }

    if (!withVar) {
      return { error: "Please! Check Your Input." };
    }

    const clean = (str) =>
      str
        .replace(/ /g, "")
        .replace(/\+/g, "plus")
        .replace(/%20/g, "")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
        .replace(/e\^x/g, "exp(x)")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**");

    let parem = clean(EnterEq);
    let parem1 = clean(EnterEq1);
    let equ = `(${parem})-(${parem1})`;

    let params = {
      equ: parem,
      equ1: parem1,
      with: withVar,
      main: equ,
    };

    if (!isNaN(x) && !isNaN(y)) {
      params.x = x;
      params.y = y;
    }

    try {
      const response = await axios.get("http://167.172.134.148/implicit", {
        params: params,
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      let result = {
        tech_res: buffer[0],
        tech_enter: buffer[1],
        tech_enter1: buffer[2],
      };

      if (!isNaN(x) && !isNaN(y)) {
        result.tech_resf = buffer[3];
      }

      return result;
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationCriticalPointCalculator
   * POST: /api/calculators-lol/critical-points-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCriticalPointCalculator(body) {
    let EnterEq = body.tech_EnterEq;

    const invalidPattern = /<|>|\&|php|print_r|print|echo|script|=|%/i;
    if (!EnterEq || invalidPattern.test(EnterEq)) {
      return { error: "Please Enter Valid Input." };
    }

    const clean = (str) =>
      str
        .replace(/ /g, "")
        .replace(/\+/g, "plus")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
        .replace(/e\^x/g, "exp(x)")
        .replace(/exp\^/g, "exp")
        .replace(/e\^/g, "exp")
        .replace(/\^/g, "**");

    let parem = clean(EnterEq);
    let wrt = /x/i.test(parem) && /y/i.test(parem) ? "xy" : "x";

    try {
      const response = await axios.get("http://167.172.134.148/critical", {
        params: {
          equ: parem,
          wrt: wrt,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      if (buffer[4] === "\\left[ \\right]") {
        return { error: "No solution exists" };
      }

      let result = {
        tech_buffer: buffer[0],
        tech_ans: buffer[1],
        tech_enter: buffer[2],
        tech_simple: buffer[3],
        tech_root: buffer[4],
      };

      if (wrt === "xy") {
        result.tech_step = buffer[5];
        result.tech_ans1 = buffer[6];
        result.tech_wrt = "xy";
      } else {
        result.tech_mini = buffer[5];
        result.tech_maxi = buffer[6];
      }

      return result;
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationPartialDerivativeCalculator
   * POST: /api/calculators-lol/partial-derivative-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPartialDerivativeCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let withRespectTo = body.tech_with;
    let how = body.tech_how;

    const invalidPattern = /<|>|&|php|print_r|print|echo|script|=|%/i;
    if (!EnterEq || invalidPattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    // Clean up the input expression
    let parem = EnterEq.replace(/ /g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^x/g, "exp(x)")
      .replace(/e\^y/g, "exp(y)")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    let wrt = (withRespectTo || "").trim();
    let howOrder = how;

    try {
      const response = await axios.get("http://167.172.134.148/derivative", {
        params: {
          equ: parem,
          wrt: wrt,
          how: howOrder,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      if (howOrder > 1) {
        return {
          tech_enter: buffer[0],
          tech_final_res: buffer,
        };
      } else {
        return {
          tech_buffer: buffer[0],
          tech_ans: buffer[1],
          tech_enter: buffer[2],
          tech_simple: buffer[3],
        };
      }
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationAbsoluteValueCalculator
   * POST: /api/calculators-lol/absolute-value-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAbsoluteValueCalculator(body) {
    let eq = body.tech_eq;
    let n = body.tech_n;
    let n1 = body.tech_n1;
    let variable = body.tech_var;
    let type = body.tech_type;

    const invalidPattern = /<|>|&|php|print_r|print|echo|script|=|%/i;

    if (type === "m1" && !isNaN(n)) {
      return {
        tech_res: Math.abs(Number(n)),
      };
    } else if (type === "m2" && eq && n1) {
      if (invalidPattern.test(eq)) {
        return { error: "Please Enter Valid Input." };
      }

      const cleanExpression = (str) => {
        return str
          .replace(/ /g, "")
          .replace(/%20/g, "")
          .replace(/\+/g, "plus")
          .replace(/{/g, "(")
          .replace(/}/g, ")")
          .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
          .replace(/e\^/g, "exp")
          .replace(/exp\^/g, "exp")
          .replace(/\^/g, "**");
      };

      let parem = cleanExpression(eq);
      let parem1 = cleanExpression(n1);

      let equ = `(${parem})-(${parem1})`;
      let equ1 = `(${parem})plus(${parem1})`;

      try {
        const response = await axios.get("http://167.172.134.148/absolute", {
          params: {
            eq: equ,
            eq1: equ1,
            var: variable,
            e1: parem,
            e2: parem1,
          },
          timeout: 120000,
        });

        const buffer = response.data.split("@@@");
        let [res, res1, check1, check11, check2, check22] = buffer;

        if (/\|/.test(eq)) {
          check1 = Math.abs(check1);
          check2 = Math.abs(check2);
        } else if (/\|/.test(n1)) {
          check11 = Math.abs(check11);
          check22 = Math.abs(check22);
        }

        return {
          tech_res: res,
          tech_res1: res1,
          tech_check1: check1,
          tech_check11: check11,
          tech_check2: check2,
          tech_check22: check22,
          tech_eq: eq,
          tech_n1: n1,
        };
      } catch (err) {
        return { error: "Please! Check Your Input." };
      }
    } else {
      return { error: "Please Enter Valid Input." };
    }
  }

  /** getCalculationAreaUnderTheCurveCalculator
   * POST: /api/calculators-lol/area-under-the-curve-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAreaUnderTheCurveCalculator(body) {
    let enterEq1 = body.tech_EnterEq1;
    let withRespectTo = body.tech_with;
    let upper = body.tech_upper?.trim();
    let lower = body.tech_lower?.trim();

    if (!enterEq1) {
      return { error: "Please enter any one value." };
    }

    let parem = enterEq1
      .replace(/ /g, "")
      .replace(/\+/g, "plus")
      .replace(/%20/g, "")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^x/g, "exp(x)")
      .replace(/e\^y/g, "exp(y)")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    const normalizeBound = (val) => {
      if (val === "e") return 2.71828;
      return val.replace(/inf|∞/g, "oo");
    };

    upper = normalizeBound(upper);
    lower = normalizeBound(lower);

    try {
      const response = await axios.post(
        "http://167.172.134.148/new-area",
        qs.stringify({
          equ: parem,
          wrt: withRespectTo,
          ub: upper,
          lb: lower,
        }),
        {
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
          },
          timeout: 120000,
        }
      );

      const buffer = response.data;
      parem = parem.replace(/plus/g, "+");
      let readableEq = parem.replace(/\*\*/g, "^");

      return {
        tech_enter: readableEq,
        tech_with: withRespectTo,
        tech_ub: upper,
        tech_lb: lower,
        tech_ans: buffer[0],
        tech_ans1: buffer[1],
        tech_steps: buffer[2],
      };
    } catch (err) {
      return { error: "Backend error: " + err.message };
    }
  }

  /** getCalculationSecondDerivativeCalculator
   * POST: /api/calculators-lol/second-derivative-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSecondDerivativeCalculator(body) {
    let enterEq = body.tech_EnterEq;
    let withRespectTo = body.tech_with;
    let how = 2;

    // Basic input validation
    if (!enterEq || /[<>&]|php|print_r|print|echo|script|=|%/i.test(enterEq)) {
      return { error: "Please! Check Your Input." };
    }

    let parem = enterEq
      .replace(/ /g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^x/g, "exp(x)")
      .replace(/e\^y/g, "exp(y)")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    try {
      const response = await axios.get("http://167.172.134.148/derivative", {
        params: {
          equ: parem,
          wrt: withRespectTo,
          how: how,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      return {
        tech_enter: buffer[0],
        tech_final_res: buffer,
      };
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationDoubleIntegralCalculator
   * POST: /api/calculators-lol/double-integral-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDoubleIntegralCalculator(body) {
    let enterEq = body.tech_EnterEq;
    let withRespectTo = body.tech_with;
    let form = body.tech_form;
    let lbx = body.tech_lbx;
    let ubx = body.tech_ubx;
    let lby = body.tech_lby;
    let uby = body.tech_uby;

    // Basic validation
    if (!enterEq || /[<>&]|php|print_r|print|echo|script|=|%/i.test(enterEq)) {
      return { error: "Please! Check Your Input." };
    }

    if (form === "def") {
      if (!ubx || !lbx || !uby || !lby) {
        return { error: "Please! Check Your Input." };
      }
    }

    let parem = enterEq
      .replace(/ /g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^x/g, "exp(x)")
      .replace(/e\^y/g, "exp(y)")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    let url = "http://167.172.134.148/double_int";
    let params = {
      equ: parem,
      wrt: withRespectTo,
    };

    if (form === "def") {
      params.ubx = ubx.replace(/\+/g, "plus");
      params.lbx = lbx.replace(/\+/g, "plus");
      params.uby = uby.replace(/\+/g, "plus");
      params.lby = lby.replace(/\+/g, "plus");
    }

    try {
      const response = await axios.get(url, {
        params: params,
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      let result = {
        tech_def: form,
        tech_enter: buffer[0],
        tech_final: buffer[1],
        tech_en1: buffer[2],
        tech_en2: buffer[3],
        tech_step1: buffer[4],
        tech_step2: buffer[5],
      };

      if (form === "def") {
        result.tech_finaln = buffer[6];
      }

      return result;
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationTripleIntegralCalculator
   * POST: /api/calculators-lol/triple-integral-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTripleIntegralCalculator(body) {
    let enterEq = body.tech_EnterEq;
    let withRespectTo = body.tech_with;
    let form = body.tech_form;
    let lbx = body.tech_lbx;
    let ubx = body.tech_ubx;
    let lby = body.tech_lby;
    let uby = body.tech_uby;
    let lbz = body.tech_lbz;
    let ubz = body.tech_ubz;

    // Input validation
    if (!enterEq || /[<>&]|php|print_r|print|echo|script|=|%/i.test(enterEq)) {
      return { error: "Please! Check Your Input." };
    }

    if (form === "def") {
      if (!ubx || !lbx || !uby || !lby || !ubz || !lbz) {
        return { error: "Please! Check Your Input." };
      }
    }

    // Equation cleanup
    let parem = enterEq
      .replace(/ /g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^x/g, "exp(x)")
      .replace(/e\^y/g, "exp(y)")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    let url = "http://167.172.134.148/triple_int";
    let params = {
      equ: parem,
      wrt: withRespectTo,
    };

    if (form === "def") {
      params.ubx = ubx.replace(/\+/g, "plus");
      params.lbx = lbx.replace(/\+/g, "plus");
      params.uby = uby.replace(/\+/g, "plus");
      params.lby = lby.replace(/\+/g, "plus");
      params.ubz = ubz.replace(/\+/g, "plus");
      params.lbz = lbz.replace(/\+/g, "plus");
    }

    try {
      const response = await axios.get(url, {
        params: params,
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      let result = {
        tech_def: form,
        tech_enter: buffer[0],
        tech_final: buffer[1],
        tech_en1: buffer[2],
        tech_en2: buffer[3],
        tech_en3: buffer[4],
        tech_step1: buffer[5],
        tech_step2: buffer[6],
        tech_step3: buffer[7],
      };

      if (form === "def") {
        result.tech_finaln = buffer[8];
      }

      return result;
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationZerosCalculator
   * POST: /api/calculators-lol/zeros-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationZerosCalculator(body) {
    let eq = body.tech_eq;
    let param = {};

    // Validation
    let isInvalid =
      /<|>|&|php|print_r|print|echo|script|sin|cos|tan|arcsin|arccos|arctan|%/i;
    if (!eq || isInvalid.test(eq)) {
      return { error: "Please Check Your Input!" };
    }

    // Sanitize input
    let parem = eq
      .replace(/\s+/g, "")
      .replace(/%20/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    // Handle equation formatting
    let splitEq = parem.split("=");
    if (splitEq.length === 2) {
      eq = `(${splitEq[0]})-(${splitEq[1]})`;
    } else {
      eq = splitEq[0];
    }

    try {
      const { data } = await axios.get("http://167.172.134.148/zeros", {
        params: { equ: eq },
        timeout: 120000,
      });

      let buffer = data.split("@@@");
      param.tech_eq = buffer[0];
      param.tech_s2 = buffer[1];
      param.tech_sum = buffer[2];
      param.tech_prod = buffer[3];
      return param;
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationGeometricSequenceCalculator
   * POST: /api/calculators-lol/geometric-sequence-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationGeometricSequenceCalculator(body) {
    let find = body.tech_find;
    let cw = body.tech_cw;
    let a1 = body.tech_a1;
    let r = body.tech_r;
    let n = body.tech_n;
    let an = body.tech_an;
    let sn = body.tech_sn;
    let n1 = body.tech_n1;
    let a_n = body.tech_a_n;

    // Helper to check if value is numeric
    function isNumeric(value) {
      return !isNaN(parseFloat(value)) && isFinite(value);
    }

    let param = {};

    if (find === "gs" && isNumeric(a1) && isNumeric(r) && isNumeric(n)) {
      let an_val = a1 * Math.pow(r, n - 1);
      let sn_val = (a1 * (1 - Math.pow(r, n))) / (1 - r);

      let seq = "";
      for (let i = 1; i <= 10; i++) {
        let sum = Math.pow(a1, i);
        seq += i < 10 ? `${sum}, ` : `${sum} ....`;
      }

      param.tech_an_val = an_val;
      param.tech_sn_val = sn_val;
      param.tech_seq = seq;
    } else if (
      find === "a1" &&
      isNumeric(r) &&
      isNumeric(n1) &&
      isNumeric(a_n)
    ) {
      let a1_val = a_n / Math.pow(r, n1 - 1);
      param.tech_a1_val = a1_val;
    } else if (
      find === "r" &&
      isNumeric(a1) &&
      isNumeric(n1) &&
      isNumeric(a_n)
    ) {
      let r_val = Math.pow(a_n / a1, 1 / (n1 - 1));
      param.tech_r_val = r_val;
    } else if (find === "n" && isNumeric(a1) && isNumeric(r)) {
      if (cw === "nth" && isNumeric(an)) {
        let n_val = Math.log(an / a1) / Math.log(r) + 1;
        param.tech_n_val = n_val;
      } else if (cw === "s_n" && isNumeric(sn)) {
        let numerator = ((sn / a1) * (1 - r) - 1) * -1;
        let n_val = Math.log(numerator) / Math.log(r);
        param.tech_n_val = n_val;
      }
    } else {
      return { error: "Please Check Your Input." };
    }

    return param;
  }

  /**
   * getCalculationTangentPlaneCalculator: Service Method
   * POST: /api/calculators-lol/tangent-plane-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationTangentPlaneCalculator(body) {
    let eq = body.tech_eq;
    let x = body.tech_x;
    let y = body.tech_y;
    let z = body.tech_z;
    let type = body.tech_type;

    // Validation check
    if (!eq || eq.trim() == "") {
      return {
        error: "Please Enter Valid Input.",
      };
    }

    // Check for invalid characters
    if (/[<>&]|php|print_r|print|echo|script|&|%/i.test(eq)) {
      return {
        error: "Please Enter Valid Input.",
      };
    }

    // Check if x and y are numeric and submit type exists
    if (!isNaN(parseFloat(x)) && !isNaN(parseFloat(y)) && type) {
      let parem = eq;
      parem = parem.replace(/\s/g, "");
      parem = parem.replace(/%20/g, "");
      parem = parem.replace(/\+/g, "plus");
      parem = parem.replace(/\{/g, "(");
      parem = parem.replace(/\}/g, ")");
      parem = parem.replace(/e\^/g, "exp");
      parem = parem.replace(/exp\^/g, "exp");
      parem = parem.replace(/\^/g, "**");
      parem = parem.replace(/e\^sqrt\(x\)/g, "exp(2*x)");

      // Split by = sign
      const paremParts = parem.split("=");
      let finalEq;

      if (paremParts.length == 2) {
        finalEq = "(" + paremParts[0] + ")-(" + paremParts[1] + ")";
      } else {
        finalEq = paremParts[0];
      }

      try {
        const axios = require("axios");
        let response;

        if (type == "two") {
          response = await axios.get("http://167.172.134.148/tpc", {
            params: {
              eq: finalEq,
              x: x,
              y: y,
              method: type,
            },
            timeout: 120000,
          });
        } else if (type == "three") {
          response = await axios.get("http://167.172.134.148/tpc", {
            params: {
              eq: finalEq,
              x: x,
              y: y,
              z: z,
              method: type,
            },
            timeout: 120000,
          });
        } else {
          return {
            error: "Please! Check Your Input.",
          };
        }

        const buffer = response.data;
        const bufferParts = buffer.split("@@@");

        let result = {};

        if (type == "two") {
          result.tech_eq = bufferParts[0];
          result.tech_t = bufferParts[1];
          result.tech_diffa = bufferParts[2];
          result.tech_diffb = bufferParts[3];
          result.tech_stepsx = bufferParts[4];
          result.tech_stepsy = bufferParts[5];
          result.tech_a = bufferParts[6];
          result.tech_b = bufferParts[7];
          result.tech_c = bufferParts[8];
        } else if (type == "three") {
          result.tech_eq = bufferParts[0];
          result.tech_t = bufferParts[1];
          result.tech_diffa = bufferParts[2];
          result.tech_diffb = bufferParts[3];
          result.tech_diffc = bufferParts[4];
          result.tech_stepsx = bufferParts[5];
          result.tech_stepsy = bufferParts[6];
          result.tech_stepsz = bufferParts[7];
          result.tech_a = bufferParts[8];
          result.tech_b = bufferParts[9];
          result.tech_c = bufferParts[10];
          result.tech_ans = bufferParts[11];
        }

        return result;
      } catch (error) {
        console.error("API Error:", error.message);
        return {
          error: "Please! Check Your Input.",
        };
      }
    } else {
      return {
        error: "Please Enter Valid Input.",
      };
    }
  }

  /**
   * getCalculationPerimeterCalculator: Service Method
   * POST: /api/calculators-lol/perimeter-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPerimeterCalculator(body) {
    // Helper function to convert units to cm
    function convertToCm(value, unit) {
      value = parseFloat(value);
      switch (unit) {
        case "mm":
          return value * 0.1;
        case "m":
          return value * 100;
        case "in":
          return value * 2.54;
        case "ft":
          return value * 30.48;
        case "yd":
          return value * 91.44;
        case "cm":
        default:
          return value;
      }
    }

    // Helper function to convert degrees to radians
    function deg2rad(deg) {
      return deg * (Math.PI / 180);
    }

    let shape = body.tech_shape;
    let given = body.tech_given;
    let givena = body.tech_givena;
    let r = body.tech_r;
    let r_unit = body.tech_r_unit;
    let b = body.tech_b;
    let b_unit = body.tech_b_unit;
    let c = body.tech_c;
    let c_unit = body.tech_c_unit;
    let d = body.tech_d;
    let d_unit = body.tech_d_unit;
    let angle = body.tech_angle;
    let angle_unit = body.tech_angle_unit;
    let angleb = body.tech_angleb;
    let angleb_unit = body.tech_angleb_unit;
    let nbr = body.tech_nbr;

    let peri;

    // Shape 1: Square
    if (shape == "1") {
      if (r && !isNaN(parseFloat(r))) {
        const rVal = parseFloat(r);
        peri = Math.round(rVal * 4 * 1000) / 1000 + " " + r_unit;
        return {
          tech_peri: peri,
        };
      } else {
        return { error: "Please! Check Your Input" };
      }
    }
    // Shape 2: Rectangle
    else if (shape == "2") {
      if (r && !isNaN(parseFloat(r)) && b && !isNaN(parseFloat(b))) {
        let rVal = parseFloat(r);
        let bVal = parseFloat(b);

        if (r_unit === b_unit) {
          peri = Math.round(2 * (rVal + bVal) * 1000) / 1000 + " " + r_unit;
        } else {
          rVal = convertToCm(rVal, r_unit);
          bVal = convertToCm(bVal, b_unit);
          peri = Math.round(2 * (rVal + bVal) * 1000) / 1000 + " cm";
        }
        return {
          tech_peri: peri,
        };
      } else {
        return { error: "Please! Check Your Input" };
      }
    }
    // Shape 3: Triangle
    else if (shape == "3") {
      if (given == "1") {
        // Three sides given
        if (
          r &&
          !isNaN(parseFloat(r)) &&
          b &&
          !isNaN(parseFloat(b)) &&
          c &&
          !isNaN(parseFloat(c))
        ) {
          let rVal = parseFloat(r);
          let bVal = parseFloat(b);
          let cVal = parseFloat(c);

          if (r_unit == b_unit && r_unit == c_unit) {
            peri =
              Math.round((rVal + bVal + cVal) * 1000) / 1000 + " " + r_unit;
          } else {
            rVal = convertToCm(rVal, r_unit);
            bVal = convertToCm(bVal, b_unit);
            cVal = convertToCm(cVal, c_unit);
            peri = Math.round((rVal + bVal + cVal) * 1000) / 1000 + " cm";
          }
          return {
            tech_peri: peri,
          };
        } else {
          return { error: "Please! Check Your Input" };
        }
      } else if (given == "2") {
        // Two sides and included angle
        if (
          r &&
          !isNaN(parseFloat(r)) &&
          b &&
          !isNaN(parseFloat(b)) &&
          angleb &&
          !isNaN(parseFloat(angleb))
        ) {
          let rVal = parseFloat(r);
          let bVal = parseFloat(b);
          let anglebVal = parseFloat(angleb);

          if (angleb_unit == "deg") {
            anglebVal = deg2rad(anglebVal);
          }

          if (r_unit == b_unit) {
            peri =
              Math.round(
                (rVal +
                  bVal +
                  Math.sqrt(
                    Math.pow(rVal, 2) +
                      Math.pow(bVal, 2) -
                      2 * rVal * bVal * Math.cos(anglebVal)
                  )) *
                  1000
              ) /
                1000 +
              " " +
              r_unit;
          } else {
            rVal = convertToCm(rVal, r_unit);
            bVal = convertToCm(bVal, b_unit);
            peri =
              Math.round(
                (rVal +
                  bVal +
                  Math.sqrt(
                    Math.pow(rVal, 2) +
                      Math.pow(bVal, 2) -
                      2 * rVal * bVal * Math.cos(anglebVal)
                  )) *
                  1000
              ) /
                1000 +
              " cm";
          }
          return {
            tech_peri: peri,
          };
        } else {
          return { error: "Please! Check Your Input" };
        }
      } else if (given == "3") {
        // One side and two angles
        if (
          r &&
          !isNaN(parseFloat(r)) &&
          angle &&
          !isNaN(parseFloat(angle)) &&
          angleb &&
          !isNaN(parseFloat(angleb))
        ) {
          let rVal = parseFloat(r);
          let angleVal = parseFloat(angle);
          let anglebVal = parseFloat(angleb);

          if (angleb_unit == "deg") {
            anglebVal = deg2rad(anglebVal);
          }
          if (angle_unit == "deg") {
            angleVal = deg2rad(angleVal);
          }

          peri =
            Math.round(
              (rVal +
                (rVal / Math.sin(angleVal + anglebVal)) *
                  (Math.sin(angleVal) + Math.sin(anglebVal))) *
                1000
            ) /
              1000 +
            " " +
            r_unit;
          return {
            tech_peri: peri,
          };
        } else {
          return { error: "Please! Check Your Input" };
        }
      }
    }
    // Shape 4: Circle
    else if (shape == "4") {
      if (r && !isNaN(parseFloat(r))) {
        const rVal = parseFloat(r);
        peri = Math.round(2 * Math.PI * rVal * 1000) / 1000 + " " + r_unit;
        return {
          tech_peri: peri,
        };
      } else {
        return { error: "Please! Check Your Input" };
      }
    }
    // Shape 5: Semicircle
    else if (shape == "5") {
      if (r && !isNaN(parseFloat(r))) {
        const rVal = parseFloat(r);
        peri =
          Math.round((rVal * Math.PI + 2 * rVal) * 1000) / 1000 + " " + r_unit;
        return {
          tech_peri: peri,
        };
      } else {
        return { error: "Please! Check Your Input" };
      }
    }
    // Shape 6: Sector
    else if (shape == "6") {
      if (r && !isNaN(parseFloat(r)) && angle && !isNaN(parseFloat(angle))) {
        let rVal = parseFloat(r);
        let angleVal = parseFloat(angle);

        if (angle_unit == "deg") {
          angleVal = deg2rad(angleVal);
        }

        peri = Math.round(rVal * (angleVal + 2) * 1000) / 1000 + " " + r_unit;
        return {
          tech_peri: peri,
        };
      } else {
        return { error: "Please! Check Your Input" };
      }
    }
    // Shape 7: Ellipse
    else if (shape == "7") {
      if (r && !isNaN(parseFloat(r)) && b && !isNaN(parseFloat(b))) {
        let rVal = parseFloat(r);
        let bVal = parseFloat(b);

        if (r_unit === b_unit) {
          peri =
            Math.round(
              Math.PI *
                (3 * (rVal + bVal) -
                  Math.sqrt((3 * rVal + bVal) * (rVal + 3 * bVal))) *
                1000
            ) /
              1000 +
            " " +
            r_unit;
        } else {
          rVal = convertToCm(rVal, r_unit);
          bVal = convertToCm(bVal, b_unit);
          peri =
            Math.round(
              Math.PI *
                (3 * (rVal + bVal) -
                  Math.sqrt((3 * rVal + bVal) * (rVal + 3 * bVal))) *
                1000
            ) /
              1000 +
            " cm";
        }
        return {
          tech_peri: peri,
        };
      } else {
        return { error: "Please! Check Your Input" };
      }
    }
    // Shape 8: Quadrilateral (4 sides)
    else if (shape == "8") {
      if (
        r &&
        !isNaN(parseFloat(r)) &&
        b &&
        !isNaN(parseFloat(b)) &&
        c &&
        !isNaN(parseFloat(c)) &&
        d &&
        !isNaN(parseFloat(d))
      ) {
        let rVal = convertToCm(parseFloat(r), r_unit);
        let bVal = convertToCm(parseFloat(b), b_unit);
        let cVal = convertToCm(parseFloat(c), c_unit);
        let dVal = convertToCm(parseFloat(d), d_unit);

        peri = Math.round((rVal + bVal + cVal + dVal) * 1000) / 1000 + " cm";
        return {
          tech_peri: peri,
        };
      } else {
        return { error: "Please! Check Your Input" };
      }
    }
    // Shape 9: Parallelogram
    else if (shape == "9") {
      if (givena == "1") {
        // Two sides given
        if (r && !isNaN(parseFloat(r)) && b && !isNaN(parseFloat(b))) {
          let rVal = parseFloat(r);
          let bVal = parseFloat(b);

          if (r_unit == b_unit) {
            peri = Math.round(2 * (rVal + bVal) * 1000) / 1000 + " " + r_unit;
          } else {
            rVal = convertToCm(rVal, r_unit);
            bVal = convertToCm(bVal, b_unit);
            peri = Math.round(2 * (rVal + bVal) * 1000) / 1000 + " cm";
          }
          return {
            tech_peri: peri,
          };
        } else {
          return { error: "Please! Check Your Input" };
        }
      } else if (givena == "2") {
        // Side and diagonals
        if (
          r &&
          !isNaN(parseFloat(r)) &&
          b &&
          !isNaN(parseFloat(b)) &&
          c &&
          !isNaN(parseFloat(c))
        ) {
          let rVal = parseFloat(r);
          let bVal = parseFloat(b);
          let cVal = parseFloat(c);

          if (r_unit == b_unit && r_unit == c_unit) {
            peri =
              Math.round(
                (2 * Math.pow(rVal, 2) +
                  Math.sqrt(
                    2 * Math.pow(bVal, 2) +
                      2 * Math.pow(cVal, 2) -
                      4 * Math.pow(rVal, 2)
                  )) *
                  1000
              ) /
                1000 +
              " " +
              r_unit;
          } else {
            rVal = convertToCm(rVal, r_unit);
            bVal = convertToCm(bVal, b_unit);
            cVal = convertToCm(cVal, c_unit);
            peri =
              Math.round(
                (Math.pow(rVal, 2) +
                  Math.sqrt(
                    2 * Math.pow(bVal, 2) +
                      2 * Math.pow(cVal, 2) -
                      4 * Math.pow(rVal, 2)
                  )) *
                  1000
              ) /
                1000 +
              " cm";
          }
          return {
            tech_peri: peri,
          };
        } else {
          return { error: "Please! Check Your Input" };
        }
      } else if (givena == "3") {
        // Side, height and angle
        if (
          r &&
          !isNaN(parseFloat(r)) &&
          b &&
          !isNaN(parseFloat(b)) &&
          angle &&
          !isNaN(parseFloat(angle))
        ) {
          let rVal = parseFloat(r);
          let bVal = parseFloat(b);
          let angleVal = parseFloat(angle);

          if (angle_unit == "deg") {
            angleVal = deg2rad(angleVal);
          }

          if (r_unit == b_unit) {
            peri =
              Math.round(2 * (rVal + bVal / Math.sin(angleVal)) * 1000) / 1000 +
              " " +
              r_unit;
          } else {
            rVal = convertToCm(rVal, r_unit);
            bVal = convertToCm(bVal, b_unit);
            peri =
              Math.round(2 * (rVal + bVal / Math.sin(angleVal)) * 1000) / 1000 +
              " cm";
          }
          return {
            tech_peri: peri,
          };
        } else {
          return { error: "Please! Check Your Input" };
        }
      }
    }
    // Shape 10: Rhombus
    else if (shape == "10") {
      if (r && !isNaN(parseFloat(r))) {
        const rVal = parseFloat(r);
        peri = Math.round(rVal * 4 * 1000) / 1000 + " " + r_unit;
        return {
          tech_peri: peri,
        };
      } else {
        return { error: "Please! Check Your Input" };
      }
    }
    // Shape 11: Trapezoid
    else if (shape == "11") {
      if (r && !isNaN(parseFloat(r)) && b && !isNaN(parseFloat(b))) {
        let rVal = parseFloat(r);
        let bVal = parseFloat(b);

        if (r_unit == b_unit) {
          peri = Math.round(2 * (rVal + bVal) * 1000) / 1000 + " " + r_unit;
        } else {
          rVal = convertToCm(rVal, r_unit);
          bVal = convertToCm(bVal, b_unit);
          peri = Math.round(2 * (rVal + bVal) * 1000) / 1000 + " cm";
        }
        return {
          tech_peri: peri,
        };
      } else {
        return { error: "Please! Check Your Input" };
      }
    }
    // Shape 12: Annulus (Ring)
    else if (shape == "12") {
      if (r && !isNaN(parseFloat(r)) && b && !isNaN(parseFloat(b))) {
        let rVal = parseFloat(r);
        let bVal = parseFloat(b);

        if (r_unit === b_unit) {
          peri =
            Math.round(2 * Math.PI * (rVal + bVal) * 1000) / 1000 +
            " " +
            r_unit;
        } else {
          rVal = convertToCm(rVal, r_unit);
          bVal = convertToCm(bVal, b_unit);
          peri = Math.round(2 * Math.PI * (rVal + bVal) * 1000) / 1000 + " cm";
        }
        return {
          tech_peri: peri,
        };
      } else {
        return { error: "Please! Check Your Input" };
      }
    }
    // Shape 13: Regular Polygon
    else if (shape == "13") {
      if (r && !isNaN(parseFloat(r)) && nbr && !isNaN(parseFloat(nbr))) {
        const rVal = parseFloat(r);
        const nbrVal = parseFloat(nbr);
        peri = Math.round(rVal * nbrVal * 1000) / 1000 + " " + r_unit;
        return {
          tech_peri: peri,
        };
      } else {
        return { error: "Please! Check Your Input" };
      }
    }

    return { error: "Please! Check Your Input" };
  }

  /** getCalculationTruthTableCalculator
   * POST: /api/calculators-lol/truth-table-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTruthTableCalculator(body) {
    let eq = (body.tech_eq || "").trim();
    let submit = body.tech_submit;

    let param = {};

    // Input validation
    if (
      !eq ||
      /php|print_r|print|echo|script|sin|cos|tan|arcsin|arccos|arctan|%/i.test(
        eq
      )
    ) {
      return { error: "Please Enter Valid Input." };
    }

    if (submit) {
      param.tech_eq = eq;
      return param;
    } else {
      return { error: "Please! Check Your Input" };
    }
  }

  /**
   * getCalculationAxisOfSymmetryCalculator: Service Method
   * POST: /api/calculators-lol/axis-of-symmetry-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAxisOfSymmetryCalculator(body) {
    try {
      let eq = body.tech_eq;

      let param = {};

      // ✅ Input validation
      if (!eq || /[<>&]/.test(eq)) {
        param.error = "Please! Check Your Input.";
        return param;
      }

      // ✅ GCD function
      function new_gcd(a, b) {
        return b === 0 ? a : new_gcd(b, a % b);
      }

      // ✅ Divide or Factorize function
      function divideOrFactorize(numerator, denominator) {
        const commonDivisor = new_gcd(numerator, denominator);
        if (commonDivisor > 1) {
          numerator /= commonDivisor;
          denominator /= commonDivisor;
        }
        return { numerator, denominator };
      }

      // ✅ Expression cleaning
      let parem = eq
        .replace(/\s+/g, "")
        .replace(/%20/g, "")
        .replace(/\+/g, "plus")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**")
        .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

      // ✅ External API request
      const response = await axios.post(
        "http://167.172.134.148/axis",
        new URLSearchParams({ equ: parem }),
        { timeout: 120000 }
      );

      let buffer = response.data.split("@@@");

      // ✅ Validation check
      if (buffer[5] === "False") {
        param.error =
          "The expression provided needs to be a valid univariate quadratic expression in x.";
        return param;
      }

      // ✅ Extracted values
      let input_eq = buffer[0];
      let coeff_a = parseFloat(buffer[1]);
      let coeff_b = parseFloat(buffer[2]);
      let coeff_c = parseFloat(buffer[3]);
      let expand_eq = buffer[4];

      // ✅ Calculate answer
      let ans = coeff_b / (2 * coeff_a);
      let asal_jawab;

      if (Number.isInteger(ans)) {
        asal_jawab = (coeff_b / (2 * coeff_a)) * -1;
      } else {
        let result = divideOrFactorize(coeff_b, 2 * coeff_a);
        if (result.denominator === 1 || result.denominator === 0) {
          asal_jawab = result.numerator * -1;
        } else {
          if (
            (result.numerator < 0 && result.denominator < 0) ||
            (result.numerator > 0 && result.denominator > 0)
          ) {
            asal_jawab = `- \\frac{${result.numerator}}{${result.denominator}}`;
          } else {
            asal_jawab = `\\frac{${result.numerator}}{${result.denominator}}`;
          }
        }
      }

      // ✅ Final response
      param.tech_input_eq = input_eq;
      param.tech_coeff_a = coeff_a;
      param.tech_coeff_b = coeff_b;
      param.tech_coeff_c = coeff_c;
      param.tech_expand_eq = expand_eq;
      param.tech_asal_jawab = asal_jawab;

      return param;
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationEvenOddFunctionCalculator
   * POST: /api/calculators-lol/even-odd-function-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationEvenOddFunctionCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let withRespectTo = body.tech_with;

    // Input validation
    if (!EnterEq || /[<>&=]|php|print_r|print|echo|script|%/i.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    // Count and remove '|' if more than one
    let abs = (EnterEq.match(/\|/g) || []).length;
    let mode = null;

    if (abs > 1) {
      EnterEq = EnterEq.replace(/\|/g, "");
      mode = withRespectTo;
    }

    // Equation cleanup
    let parem = EnterEq.trim()
      .replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^x/g, "exp(x)")
      .replace(/e\^y/g, "exp(y)")
      .replace(/e\^/g, " exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    // Replace exp with e, then do substitution for -x
    let newEq = parem.replace(/exp/g, "e");
    let parem1 = newEq.replace(
      new RegExp(withRespectTo, "g"),
      `(-${withRespectTo})`
    );
    parem1 = parem1.replace(/e/g, " exp");

    try {
      const response = await axios.get("http://167.172.134.148/even", {
        params: {
          equ: parem,
          equ1: parem1,
          wrt: withRespectTo,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      return {
        tech_ans: buffer[0],
        tech_enter: buffer[1],
        tech_with: withRespectTo,
        tech_mode: mode,
      };
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationSyntheticDivisionCalculator
   * POST: /api/calculators-lol/synthetic-division-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSyntheticDivisionCalculator(body) {
    let dividend = body.tech_dividend;
    let divisor = body.tech_divisor;

    // Input validation for security
    const unsafePattern =
      /<|>|&|php|print_r|print|echo|script|sin|cos|tan|arcsin|arccos|arctan|%/i;
    if (unsafePattern.test(dividend) || unsafePattern.test(divisor)) {
      return { error: "Please Enter Valid Input." };
    }

    // Divisor pattern check
    const pattern =
      /^\s*(\(?\s*-?\d+(\.\d+)?\s*\)?|)\s*\(?([a-zA-Z])\)?\s*([\+\-])\s*\(?-?\d+(\.\d+)?\)?\s*$/;
    const matches = divisor.match(pattern);
    if (matches) {
      if (!dividend.includes(matches[3])) {
        return {
          error: `Variable ${matches[3]} does not exist in the function`,
        };
      }

      const uniqueVariables = [...new Set(dividend.match(/[a-zA-Z]/g) || [])];
      if (uniqueVariables.length > 1) {
        return { error: "Dividend contains more than one variable" };
      }

      if (!dividend || !divisor) {
        return { error: "Please! Check Your Input" };
      }

      // Clean and transform expressions
      const cleanup = (str) =>
        str
          .replace(/\s+/g, "")
          .replace(/%20/g, "")
          .replace(/\+/g, "plus")
          .replace(/{/g, "(")
          .replace(/}/g, ")")
          .replace(/–/g, "-")
          .replace(/e\^/g, "exp")
          .replace(/exp\^/g, "exp")
          .replace(/\^/g, "**")
          .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

      let parem = cleanup(dividend);
      let parem1 = cleanup(divisor);

      try {
        const response = await axios.get("http://167.172.134.148/synthetic", {
          params: {
            eq: parem,
            eq1: parem1,
          },
          timeout: 120000,
        });

        const buffer = response.data.split("@@@");
        const coeffs = buffer[2].split("###");
        const coeffs1 = buffer[7].split("###");

        return {
          tech_eq: buffer[0],
          tech_eq1: buffer[1],
          tech_coeffs: coeffs,
          tech_divby: buffer[3],
          tech_quot: buffer[4],
          tech_rmnd: buffer[5],
          tech_divby1: buffer[6],
          tech_coeffs1: coeffs1,
        };
      } catch (error) {
        return { error: "Please! Check Your Input." };
      }
    } else {
      return { error: "Please! Check Your Input" };
    }
  }
  /** getCalculationProductRuleDerivativeCalculator
   * POST: /api/calculators-lol/product-rule-derivative-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationProductRuleDerivativeCalculator(body) {
    let EnterEq = body.tech_enter_eq;
    let withRespectTo = body.tech_with;
    let how = body.tech_how;

    // Validation
    const unsafePattern = /<|>|&|php|print_r|print|echo|script|=|%/i;
    if (!EnterEq || unsafePattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    // Clean and transform input
    let parem = EnterEq.replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    let parem1 = withRespectTo;
    let parem2 = how;

    try {
      const response = await axios.get("http://167.172.134.148/derivative", {
        params: {
          equ: parem,
          wrt: parem1,
          how: parem2,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      if (parseInt(how) > 1) {
        return {
          tech_enter: buffer[0],
          tech_final_res: buffer,
          RESULT: 1,
        };
      } else {
        return {
          tech_buffer: buffer[0],
          tech_ans: buffer[1],
          tech_enter: buffer[2],
          tech_simple: buffer[3],
        };
      }
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }

  /**
   * getCalculationDistributivePropertyCalculator: Service Method
   * POST: /api/calculators-lol/distributive-property-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDistributivePropertyCalculator(body) {
    try {
      let EnterEq = body.tech_EnterEq;

      let param = {};

      // ✅ Input validation
      if (!EnterEq || EnterEq.trim() === "") {
        param.error = "Please! Check Your Input.";
        return param;
      }

      // ✅ Original input cleanup (for display)
      let input = EnterEq.replace(/\s+/g, "")
        .replace(/\)\(/g, ")*(")
        .replace(/plus/g, "+");

      // ✅ Expression cleanup for backend request
      let parem = EnterEq.replace(/\s+/g, "")
        .replace(/\)\(/g, ")*(")
        .replace(/\+/g, "plus")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**")
        .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

      // ✅ External API call
      const response = await axios.get(
        `http://167.172.134.148/distributive?equ=${encodeURIComponent(parem)}`,
        { timeout: 120000 }
      );

      let buffer = response.data?.toString().trim();

      // ✅ Response check
      if (!isNaN(buffer)) {
        param.tech_input = input;
        param.tech_ans = buffer;
        return param;
      } else {
        param.error = "Please! Check Your Input.";
        return param;
      }
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationOrthocenterCalculator
   * POST: /api/calculators-lol/orthocenter-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationOrthocenterCalculator(body) {
    let x1 = body.tech_x1;
    let y1 = body.tech_y1;
    let x2 = body.tech_x2;
    let y2 = body.tech_y2;
    let x3 = body.tech_x3;
    let y3 = body.tech_y3;

    const result = {};

    if (
      isNaN(x1) ||
      isNaN(y1) ||
      isNaN(x2) ||
      isNaN(y2) ||
      isNaN(x3) ||
      isNaN(y3)
    ) {
      result.error = "Please! Check Your Input.";
      return result;
    }

    let ab1, ab2, bc1, bc2, ca1, ca2;
    let xx;

    const a = y2 - y1;
    const a1 = x2 - x1;
    if (a !== 0 && a1 !== 0) {
      const ab = a / a1;
      ab1 = -1 / ab;
      ab2 = y3 - ab1 * x3;
      xx = `y=${ab1}x${ab2 >= 0 ? "+" + ab2 : ab2}`;
    }

    const b = y3 - y2;
    const b1 = x3 - x2;
    if (b !== 0 && b1 !== 0) {
      const bc = b / b1;
      bc1 = -1 / bc;
      bc2 = y1 - bc1 * x1;
      xx = `y=${bc1}x${bc2 >= 0 ? "+" + bc2 : bc2}`;
    }

    const c = y3 - y1;
    const c1 = x3 - x1;
    if (c !== 0 && c1 !== 0) {
      const ca = c / c1;
      ca1 = -1 / ca;
      ca2 = y2 - ca1 * x2;
      xx = `y=${ca1}x${ca2 >= 0 ? "+" + ca2 : ca2}`;
    }

    if (a !== 0 && a1 !== 0 && b !== 0 && b1 !== 0 && c !== 0 && c1 !== 0) {
      const con = -bc1;
      const con1 = -bc2;
      const ad = con + ab1;
      const ad1 = ab2 + con1;
      const di = ad1 / ad;
      const di1 = -di;
      const y8 = bc1 * di1 + bc2;

      if (isNaN(di1) || isNaN(y8)) {
        result.error = "Please! Check Your Input.";
        return result;
      } else {
        result.tech_x = Number.isInteger(di1)
          ? di1
          : parseFloat(di1.toFixed(5));
        result.tech_y = Number.isInteger(y8) ? y8 : parseFloat(y8.toFixed(5));
      }
    } else if (a !== 0 && a1 !== 0 && b !== 0 && b1 !== 0) {
      const con = -bc1;
      const con1 = -bc2;
      const ad = con + ab1;
      const ad1 = ab2 + con1;
      const di = ad1 / ad;
      const di1 = -di;
      const y8 = bc1 * di1 + bc2;

      if (isNaN(di1) || isNaN(y8)) {
        result.error = "Please! Check Your Input.";
        return result;
      } else {
        result.tech_x = Number.isInteger(di1)
          ? di1
          : parseFloat(di1.toFixed(5));
        result.tech_y = Number.isInteger(y8) ? y8 : parseFloat(y8.toFixed(5));
      }
    } else if (b !== 0 && b1 !== 0 && c !== 0 && c1 !== 0) {
      const con2 = -ca1;
      const con3 = -ca2;
      const ad2 = con2 + bc1;
      const ad3 = bc2 + con3;
      const di = ad3 / ad2;
      const di1 = -di;
      const y8 = ca1 * di1 + ca2;

      if (isNaN(di1) || isNaN(y8)) {
        result.error = "Please! Check Your Input.";
        return result;
      } else {
        result.tech_x = Number.isInteger(di1)
          ? di1
          : parseFloat(di1.toFixed(5));
        result.tech_y = Number.isInteger(y8) ? y8 : parseFloat(y8.toFixed(5));
      }
    } else if (a !== 0 && a1 !== 0 && c !== 0 && c1 !== 0) {
      const con2 = -ab1;
      const con3 = -ab2;
      const ad2 = con2 + ca1;
      const ad3 = ca2 + con3;
      const di = ad3 / ad2;
      const di1 = -di;
      const y8 = ab1 * di1 + ab2;

      if (isNaN(di1) || isNaN(y8)) {
        result.error = "Please! Check Your Input.";
        return result;
      } else {
        result.tech_x = Number.isInteger(di1)
          ? di1
          : parseFloat(di1.toFixed(5));
        result.tech_y = Number.isInteger(y8) ? y8 : parseFloat(y8.toFixed(5));
      }
    } else {
      result.error = "Please! Check Your Input.";
      return result;
    }

    return result;
  }

  /** getCalculationPolynomialLongDivisionCalculator
   * POST: /api/calculators-lol/polynomial-long-division-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPolynomialLongDivisionCalculator(body) {
    let dividend = body.tech_dividend;
    let divisor = body.tech_divisor;

    const result = {};

    // Input validation
    if (!dividend || !divisor) {
      result.error = "Please Enter Valid Input.";
      return result;
    }

    // Check for forbidden characters
    const forbiddenPattern =
      /<|>|&|php|print_r|print|echo|script|sin|cos|tan|arcsin|arccos|arctan|&|%/i;
    if (forbiddenPattern.test(dividend) || forbiddenPattern.test(divisor)) {
      result.error = "Please Enter Valid Input.";
      return result;
    }

    // Process dividend
    let processedDividend = dividend
      .replace(/\s+/g, "")
      .replace(/%20/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    // Process divisor
    let processedDivisor = divisor
      .replace(/\s+/g, "")
      .replace(/%20/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    // Check variable consistency
    if (
      (divisor.includes("x") && dividend.includes("y")) ||
      (divisor.includes("y") && dividend.includes("x"))
    ) {
      result.error = "The divisor and dividend have different variables.";
      return result;
    }

    // Determine variable check
    let check = "";
    if (divisor.includes("x") && divisor.includes("y")) {
      check = "xy";
    } else if (divisor.includes("x") && !divisor.includes("y")) {
      check = "x";
    } else if (divisor.includes("y") && !divisor.includes("x")) {
      check = "y";
    }

    try {
      // Make API request
      const response = await axios.get("http://167.172.134.148/polynomial", {
        params: {
          eq: processedDividend,
          eq1: processedDivisor,
          check: check,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      // Basic results
      result.tech_check = check;
      result.tech_eq = buffer[0];
      result.tech_eq1 = buffer[1];
      result.tech_quot = buffer[2];
      result.tech_rmnd = buffer[3];

      if (check !== "xy") {
        // Additional results for non-xy cases
        const quotient = buffer[4].split("###").filter((item) => item);
        const multiplies = buffer[5].split("###").filter((item) => item);
        const steps = buffer[6].split("###").filter((item) => item);
        const divCoeff = buffer[7].split("###").filter((item) => item);
        const leading_term = buffer[9].split("###").filter((item) => item);

        result.tech_quotient = quotient;
        result.tech_multiplies = multiplies;
        result.tech_steps = steps;
        result.tech_divCoeff = divCoeff;
        result.tech_loop_len = buffer[8];
        result.tech_leading_term = leading_term;
        result.tech_divby_lt = buffer[10];
      }

      return result;
    } catch (error) {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /** getCalculationRadiusOfConvergenceCalculator
   * POST: /api/calculators-lol/radius-of-convergence-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRadiusOfConvergenceCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let wrt = body.tech_with;

    // Trim and validate input
    EnterEq = EnterEq?.trim();
    wrt = wrt?.trim();

    const invalidPattern = /[<>&=]|php|print_r|print|echo|script|%/i;

    if (!EnterEq || invalidPattern.test(EnterEq)) {
      return { error: "Please Enter Valid Input." };
    }

    if (!wrt) {
      return { error: "Please Enter Valid Input." };
    }

    // Clean and transform the equation
    let parem = EnterEq.replace(/ /g, "")
      .replace(/%20/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    let enter = parem;
    let upr = parem.replace(/n/g, "(nplus1)");
    parem = `(${upr})/(${parem})`;

    try {
      const response = await axios.get("http://167.172.134.148/radius", {
        params: {
          equ: parem,
          wrt,
          enter,
        },
        timeout: 120000,
      });

      if (!response || !response.data) {
        return { error: "Please! Check Your Input." };
      }

      let buffer = response.data.split("@@@");

      const result = {
        tech_enter: buffer[0],
        tech_ans: buffer[1],
        tech_equs: buffer[2],
        tech_shareURL: "", // optional: you can build shareURL here if needed
      };

      return result;
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationPowerSeriesCalculator
   * POST: /api/calculators-lol/power-series-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPowerSeriesCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let point = body.tech_point;
    let n = body.tech_n;
    let wrt = body.tech_with;

    EnterEq = EnterEq?.trim();
    point = point?.toString().trim();
    n = n?.toString().trim();
    wrt = wrt?.trim();

    const invalidPattern = /[<>&=]|php|print_r|print|echo|script|%/i;

    if (!EnterEq || invalidPattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    if (!wrt || isNaN(n) || isNaN(point)) {
      return { error: "Please! Check Your Input." };
    }

    // Clean and process EnterEq
    let parem = EnterEq.replace(/ /g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^x/g, "exp(x)")
      .replace(/e\^y/g, "exp(y)")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    try {
      const response = await axios.get("http://167.172.134.148/power_ser", {
        params: {
          equ: parem,
          wrt,
          how: n,
          point,
        },
        timeout: 120000,
      });

      if (!response || !response.data) {
        return { error: "Please! Check Your Input." };
      }

      const buffer = response.data.split("@@@");

      return {
        tech_ans: buffer[0],
        tech_enter: buffer[1],
      };
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationSimpsonRuleCalculator
   * POST: /api/calculators-lol/simpsons-rule-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationSimpsonRuleCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let lb = body.tech_lb;
    let ub = body.tech_ub;
    let n = body.tech_n;
    let wrt = body.tech_with;

    EnterEq = EnterEq?.toString().trim();
    lb = parseFloat(lb);
    ub = parseFloat(ub);
    n = parseInt(n);
    wrt = wrt?.toString().trim();

    const invalidPattern = /[<>&=]|php|print_r|print|echo|script|%/i;

    if (!EnterEq || invalidPattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    if (isNaN(lb) || isNaN(ub) || isNaN(n) || n % 2 !== 0) {
      return { error: "Number of rectangles should be even number." };
    }

    if (lb >= ub) {
      return { error: "The lower limit should be less than the upper limit." };
    }

    // Process equation
    let parem = EnterEq.replace(/ /g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    let diff = (ub - lb) / n;
    let final = lb;
    let limitArray = [lb];
    let limitString = `${lb}`;

    while (final < ub) {
      final = parseFloat((final + diff).toFixed(10)); // avoid floating point issues
      limitArray.push(final);
      limitString += `, ${final}`;
    }

    try {
      const response = await axios.get("http://167.172.134.148/simpsons", {
        params: {
          equ: parem,
          with: wrt,
          lb,
          ub,
          n,
          diff,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      const errorValue = Math.abs((buffer[4] - buffer[1]) / buffer[4]);
      const steps = buffer[0].split("HA");

      return {
        tech_steps: steps,
        tech_res: buffer[1],
        tech_enter: buffer[2],
        tech_int: buffer[3],
        tech_intv: buffer[4],
        tech_errorans: errorValue,
        tech_ub: ub,
        tech_lb: lb,
        tech_n: n,
        tech_diff: diff,
        tech_limit: limitString,
        tech_limit_a: limitArray,
        tech_with: wrt,
      };
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationCurlCalculator
   * POST: /api/calculators-lol/curl-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCurlCalculator(body) {
    let xeq = body.tech_xeq;
    let yeq = body.tech_yeq;
    let zeq = body.tech_zeq;
    let x = body.tech_x;
    let y = body.tech_y;
    let z = body.tech_z;

    xeq = xeq?.toString().trim();
    yeq = yeq?.toString().trim();
    zeq = zeq?.toString().trim();
    const invalidPattern = /[<>&=]|php|print_r|print|echo|script|%/i;

    if (
      !xeq ||
      !yeq ||
      !zeq ||
      invalidPattern.test(xeq) ||
      invalidPattern.test(yeq) ||
      invalidPattern.test(zeq)
    ) {
      return { error: "Please! Check Your Input." };
    }

    const sanitize = (eq) =>
      eq
        .replace(/ /g, "")
        .replace(/\+/g, "plus")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**");

    xeq = sanitize(xeq);
    yeq = sanitize(yeq);
    zeq = sanitize(zeq);

    const isPointProvided = !isNaN(x) && !isNaN(y) && !isNaN(z);

    try {
      const params = isPointProvided
        ? { xeq, yeq, zeq, x, y, z }
        : { xeq, yeq, zeq };

      const response = await axios.get("http://167.172.134.148/curl", {
        params,
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      const result = {
        tech_enx: buffer[0],
        tech_eny: buffer[1],
        tech_enz: buffer[2],
        tech_one: buffer[3],
        tech_two: buffer[4],
        tech_three: buffer[5],
        tech_four: buffer[6],
        tech_five: buffer[7],
        tech_six: buffer[8],
        tech_ans1: buffer[9],
        tech_ans2: buffer[10],
        tech_ans3: buffer[11],
      };

      if (isPointProvided) {
        result.tech_ev1 = buffer[12];
        result.tech_ev2 = buffer[13];
        result.tech_ev3 = buffer[14];
      }

      return result;
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }
  /** getCalculationSaddlePointCalculator
   * POST: /api/calculators-lol/saddle-point-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSaddlePointCalculator(body) {
    let EnterEq = body.tech_EnterEq;

    EnterEq = EnterEq?.toString().trim();
    const invalidPattern = /[<>&=]|php|print_r|print|echo|script|%/i;

    if (!EnterEq || invalidPattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    let parem = EnterEq.replace(/ /g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^x/g, "exp(x)")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    const wrt = "xy";

    try {
      const response = await axios.get("http://167.172.134.148/saddle", {
        params: {
          equ: parem,
          wrt: wrt,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      if (buffer[4] === "\\left[ \\right]") {
        return { error: "no solution exist." };
      }

      return {
        tech_buffer: buffer[0],
        tech_ans: buffer[1],
        tech_enter: buffer[2],
        tech_simple: buffer[3],
        tech_root: buffer[4],
        tech_step: buffer[5],
        tech_ans1: buffer[6],
        tech_step1: buffer[7],
        tech_step2: buffer[8],
        tech_en1: buffer[9],
        tech_en2: buffer[10],
        tech_wrt: "xy",
      };
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationImproperIntegralCalculator
   * POST: /api/calculators-lol/improper-integral-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationImproperIntegralCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let ub = body.tech_ub;
    let lb = body.tech_lb;
    let wrt = body.tech_with;

    EnterEq = EnterEq?.toString().trim();
    const invalidPattern = /[<>&=]|php|print_r|print|echo|script|%/i;

    if (!EnterEq || invalidPattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    if (!ub || !lb || !wrt) {
      return { error: "Please! Check Your Input." };
    }

    // Sanitize expression
    let parem = EnterEq.replace(/ /g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/xe\^/g, "x*e^")
      .replace(/ye\^/g, "y*e^")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    let upper = ub.replace(/\+/g, "plus").replace(/inf|∞/gi, "oo");
    let lower = lb.replace(/\+/g, "plus").replace(/inf|∞/gi, "oo");
    let wrtVar = wrt.trim();

    try {
      const response = await axios.get("http://167.172.134.148/improper", {
        params: {
          equ: parem,
          wrt: wrtVar,
          ub: upper,
          lb: lower,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      return {
        tech_enter: buffer[0],
        tech_int: buffer[1],
        tech_res: buffer[2],
        tech_ans: buffer[3],
        tech_first: buffer[4],
        tech_sec: buffer[5],
        tech_res1: buffer[6],
      };
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }
  /** getCalculationFourierSeriesCalculator
   * POST: /api/calculators-lol/fourier-series-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationFourierSeriesCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let ub = body.tech_ub;
    let lb = body.tech_lb;
    let wrt = body.tech_with;

    EnterEq = EnterEq?.toString().trim();
    const invalidPattern = /[<>&=]|php|print_r|print|echo|script|%/i;

    if (!EnterEq || invalidPattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    if (!ub || !lb || !wrt) {
      return { error: "Please! Check Your Input." };
    }

    // Clean equation
    let parem = EnterEq.replace(/ /g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/xe\^/g, "x*e^")
      .replace(/ye\^/g, "y*e^")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    // Bounds replacement
    let upper = ub.replace(/\+/g, "plus").replace(/inf|∞/gi, "oo");
    let lower = lb.replace(/\+/g, "plus").replace(/inf|∞/gi, "oo");
    let wrtVar = wrt.trim();

    try {
      const response = await axios.get("http://167.172.134.148/fourier", {
        params: {
          equ: parem,
          wrt: wrtVar,
          ub: upper,
          lb: lower,
        },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");

      return {
        tech_enter: buffer[0],
        tech_a0: buffer[1],
        tech_an: buffer[2],
        tech_bn: buffer[3],
        tech_res: buffer[4],
        tech_t1: buffer[5],
        tech_t2: buffer[6],
        tech_t: buffer[7],
      };
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationDivergenceCalculator
   * POST: /api/calculators-lol/divergence-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDivergenceCalculator(body) {
    let xeq = body.tech_xeq;
    let yeq = body.tech_yeq;
    let zeq = body.tech_zeq;
    let x = body.tech_x;
    let y = body.tech_y;
    let z = body.tech_z;

    const invalidPattern = /[<>&=]|php|print_r|print|echo|script|%/i;

    // Validate inputs
    if (
      !xeq ||
      !yeq ||
      !zeq ||
      invalidPattern.test(xeq) ||
      invalidPattern.test(yeq) ||
      invalidPattern.test(zeq)
    ) {
      return { error: "Please! Check Your Input." };
    }

    const sanitize = (expr) =>
      expr
        .replace(/ /g, "")
        .replace(/\+/g, "plus")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/xe\^/g, "x*e^")
        .replace(/ye\^/g, "y*e^")
        .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**");

    xeq = sanitize(xeq);
    yeq = sanitize(yeq);
    zeq = sanitize(zeq);

    const isValidNumber = (val) => !isNaN(val) && val !== null && val !== "";

    const params = { xeq, yeq, zeq };

    if (isValidNumber(x) && isValidNumber(y) && isValidNumber(z)) {
      params.x = x;
      params.y = y;
      params.z = z;
    }

    try {
      const response = await axios.get("http://167.172.134.148/divergence", {
        params,
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");
      const result = {
        tech_enx: buffer[0],
        tech_eny: buffer[1],
        tech_enz: buffer[2],
        tech_one: buffer[3],
        tech_two: buffer[4],
        tech_three: buffer[5],
      };

      if (isValidNumber(x) && isValidNumber(y) && isValidNumber(z)) {
        result.tech_ev1 = buffer[6];
        result.tech_ev2 = buffer[7];
        result.tech_ev3 = buffer[8];
      }

      return result;
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }
  /** getCalculationLeastToGreatestCalculator
   * POST: /api/calculators-lol/least-to-greatest-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLeastToGreatestCalculator(body) {
    let x = body.tech_x;
    let order = body.tech_order;
    const result = {};

    // Input validation
    if (!x) {
      result.error = "Please! Check Your Input.";
      return result;
    }

    // Check for forbidden characters
    const forbiddenPattern =
      /<|>|&|php|print_r|print|echo|script|=|[a-zA-Z]|&/i;
    if (forbiddenPattern.test(x)) {
      result.error = "Please Enter Valid Input.";
      return result;
    }

    try {
      // Process input string
      const processedX = x.replace(/plus/g, "+");
      const input = processedX.split(",").map((item) => item.trim());

      const filter = {};
      const filter1 = {};

      for (const value of input) {
        let ans;
        const index = value;

        // Check for fractions
        const chech_frac = value.split("/");
        if (chech_frac.length > 1) {
          let up = chech_frac[0];
          const btm = parseFloat(chech_frac[1]);

          // Handle mixed numbers (e.g., "1 1/2")
          const check_up = up.split(" ");
          if (check_up.length > 1) {
            const sahi = parseFloat(check_up[0]);
            up = parseFloat(check_up[1]);

            // Handle negative mixed numbers
            if (sahi < 0 && up > 0) {
              up = up * -1;
            }

            ans = (btm * sahi + up) / btm;
          } else {
            ans = parseFloat(up) / btm;
          }
        } else {
          // Handle percentages and simple expressions
          const processedValue = value
            .replace(/%/g, "/100")
            .replace(/\s+/g, "+");

          // Use safe evaluation (in a real app, consider a more secure expression evaluator)
          ans = eval(processedValue);
        }

        // Validate the result
        if (isNaN(ans)) {
          result.error = "Please Enter Valid Input.";
          return result;
        }

        filter[index] = ans;
        filter1[ans.toString()] = index;
      }

      // Sort the results
      const sorted = { ...filter };
      const sortedArray = Object.entries(sorted);

      if (order === "1") {
        sortedArray.sort((a, b) => a[1] - b[1]);
      } else {
        sortedArray.sort((a, b) => b[1] - a[1]);
      }

      // Convert back to object
      const sortedResult = {};
      for (const [key, value] of sortedArray) {
        sortedResult[key] = value;
      }

      // Prepare response
      result.tech_solve = filter;
      result.tech_order = order;
      result.tech_ans = sortedResult;
      result.tech_filter1 = filter1;

      return result;
    } catch (error) {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /**
   * getCalculationRationalExpressionCalculator: Service Method
   * POST: /api/calculators-lol/rational-expression-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRationalExpressionCalculator(body) {
    // Helper function for string replacements
    function processExpression(expr) {
      let processed = expr;
      processed = processed.replace(/ /g, "");
      processed = processed.replace(/\+/g, "plus");
      processed = processed.replace(/{/g, "(");
      processed = processed.replace(/}/g, ")");
      processed = processed.replace(/xe\^/g, "x*e^");
      processed = processed.replace(/ye\^/g, "y*e^");
      processed = processed.replace(/e\^/g, "exp");
      processed = processed.replace(/exp\^/g, "exp");
      processed = processed.replace(/\^/g, "**");
      processed = processed.replace(/e\^sqrt\(x\)/g, "exp(2*x)");
      return processed;
    }

    // Input validation function
    function validateInput(input) {
      if (!input || !/^[^<>&]*$/i.test(input)) {
        return false;
      }
      if (/<|>|&|php|print_r|print|echo|script|=|%|&/i.test(input)) {
        return false;
      }
      return true;
    }

    const to = body.tech_to;
    const to_cal = body.tech_to_cal;

    if (to == "1") {
      const n1 = body.tech_n1;
      const d1 = body.tech_d1;

      // Validation
      if (!validateInput(n1) || !validateInput(d1)) {
        return {
          status: "success",
          payload: {
            error: "Please! Check Your Input.",
          },
        };
      }

      const xeq = processExpression(n1);
      const yeq = processExpression(d1);
      const equ = "(" + xeq + ")/(" + yeq + ")";

      try {
        const response = await axios.get("http://167.172.134.148/rational", {
          params: {
            xeq: xeq,
            to: "1",
            yeq: yeq,
          },
          timeout: 120000,
        });

        const buffer = response.data.split("@@@");

        return {
          status: "success",
          payload: {
            tech_enter: buffer[0],
            tech_up: buffer[1],
            tech_ress: buffer[2],
            tech_down: buffer[3],
          },
        };
      } catch (error) {
        return {
          status: "success",
          payload: {
            error: "Please! Check Your Input.",
          },
        };
      }
    } else if (to == "2") {
      if (to_cal == "two") {
        const n1 = body.tech_n11;
        const d1 = body.tech_d11;
        const n2 = body.tech_n22;
        const d2 = body.tech_d22;
        const action = body.tech_action;

        // Validation
        if (
          !validateInput(n1) ||
          !validateInput(d1) ||
          !validateInput(n2) ||
          !validateInput(d2)
        ) {
          return {
            status: "success",
            payload: {
              error: "Please! Check Your Input.",
            },
          };
        }

        const xeq = processExpression(n1);
        const yeq = processExpression(d1);
        const xeq1 = processExpression(n2);
        const yeq1 = processExpression(d2);

        try {
          const response = await axios.get("http://167.172.134.148/rational", {
            params: {
              xeq: xeq,
              yeq: yeq,
              xeq1: xeq1,
              yeq1: yeq1,
              to: "2",
              cal: "2",
              action: action,
            },
            timeout: 120000,
          });

          const buffer = response.data.split("@@@");
          let lcm = null;

          if (buffer[2]) {
            const lcmParts = buffer[2].split("}{");
            if (lcmParts.length === 2) {
              lcm = lcmParts[1].slice(0, -1);
            }
          }

          const processedAction = action
            .replace(/plus/g, "+")
            .replace(/div/g, "÷");
          const result = {
            tech_up: buffer[0],
            tech_down: buffer[1],
            tech_ans: buffer[2],
            tech_action: processedAction,
          };

          if (lcm) {
            result.tech_lcm = lcm;
          }

          if (processedAction == "+" || processedAction == "-") {
            result.tech_left = buffer[3];
            result.tech_right = buffer[4];
            result.tech_top = buffer[5];
            result.tech_bottom = buffer[6];
          } else {
            result.tech_top = buffer[3];
            result.tech_bottom = buffer[4];
          }

          return result;
        } catch (error) {
          return {
            status: "success",
            payload: {
              error: "Please! Check Your Input.",
            },
          };
        }
      } else {
        const n1 = body.tech_n13;
        const d1 = body.tech_d13;
        const n2 = body.tech_n23;
        const d2 = body.tech_d23;
        const n3 = body.tech_n33;
        const d3 = body.tech_d33;
        const action1 = body.tech_action1;
        const action2 = body.tech_action2;

        // Validation
        if (
          !validateInput(n1) ||
          !validateInput(d1) ||
          !validateInput(n2) ||
          !validateInput(d2) ||
          !validateInput(n3) ||
          !validateInput(d3)
        ) {
          return {
            status: "success",
            payload: {
              error: "Please! Check Your Input.",
            },
          };
        }

        const xeq = processExpression(n1);
        const yeq = processExpression(d1);
        const xeq1 = processExpression(n2);
        const yeq1 = processExpression(d2);
        const xeq2 = processExpression(n3);
        const yeq2 = processExpression(d3);

        try {
          const response = await axios.get("http://167.172.134.148/rational", {
            params: {
              xeq: xeq,
              yeq: yeq,
              xeq1: xeq1,
              yeq1: yeq1,
              xeq2: xeq2,
              yeq2: yeq2,
              to: "2",
              cal: "3",
              action: action1,
              action1: action2,
            },
            timeout: 120000,
          });

          const buffer = response.data.split("@@@");
          let lcm = null;
          let lcm1 = null;

          if (buffer[1]) {
            const lcmParts = buffer[1].split("}{");
            if (lcmParts.length > 1) {
              lcm = lcmParts[1].slice(0, -1);
            }
          }

          const processedAction = action1
            .replace(/plus/g, "+")
            .replace(/div/g, "÷");
          const processedAction1 = action2
            .replace(/plus/g, "+")
            .replace(/div/g, "÷");

          const result = {
            status: "success",
            payload: {
              ans: buffer[1],
              up: buffer[2],
              down: buffer[3],
              thr: buffer[4],
              action: processedAction,
              action1: processedAction1,
              RESULT: 1,
            },
          };

          if (lcm) {
            result.payload.lcm = lcm;
          }

          if (
            (processedAction == "+" || processedAction == "-") &&
            (processedAction1 == "+" || processedAction1 == "-")
          ) {
            result.payload.left = buffer[5];
            result.payload.center = buffer[6];
            result.payload.right = buffer[7];
            result.payload.top = buffer[8];
          } else if (
            (processedAction == "*" || processedAction == "÷") &&
            (processedAction1 == "*" || processedAction1 == "÷")
          ) {
            result.payload.up1 = buffer[5];
            result.payload.up2 = buffer[6];
            result.payload.down1 = buffer[7];
            result.payload.down2 = buffer[8];
          } else {
            result.payload.up1 = buffer[5];
            result.payload.ansl = buffer[6];
            result.payload.down1 = buffer[7];
            result.payload.top = buffer[8];
            result.payload.left = buffer[9];
            result.payload.right = buffer[10];

            if (buffer[6]) {
              const lcm1Parts = buffer[6].split("}{");
              if (lcm1Parts.length > 1) {
                lcm1 = lcm1Parts[1].slice(0, -1);
                result.payload.lcm1 = lcm1;
              }
            }
          }

          return result;
        } catch (error) {
          return {
            status: "success",
            payload: {
              error: "Please! Check Your Input.",
            },
          };
        }
      }
    } else if (to == "3") {
      const expr = body.tech_expr;

      if (!validateInput(expr)) {
        return {
          status: "success",
          payload: {
            error: "Please Enter Valid Input.",
          },
        };
      }

      const xeq = processExpression(expr);

      try {
        const response = await axios.get("http://167.172.134.148/rational", {
          params: {
            xeq: xeq,
            to: "3",
          },
          timeout: 120000,
        });

        const buffer = response.data.split("@@@");

        return {
          status: "success",
          payload: {
            tech_enter: buffer[0],
            tech_ans: buffer[1],
          },
        };
      } catch (error) {
        return {
          status: "success",
          payload: {
            error: "Please! Check Your Input.",
          },
        };
      }
    }

    // Default return if no valid 'to' value
    return {
      status: "success",
      payload: {
        error: "Invalid operation type.",
      },
    };
  }

  /** getCalculationAngleOfElevationCalculator
   * POST: /api/calculators-lol/angle-of-elevation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationAngleOfElevationCalculator(body) {
    let to_cal = body.tech_to_cal;
    let vertical = body.tech_vertical;
    let vertical_unit = body.tech_vertical_unit;
    let hori = body.tech_hori;
    let hori_unit = body.tech_hori_unit;
    let angle = body.tech_angle;
    let angle_unit = body.tech_angle_unit;

    function unitToMeter(value, unit) {
      const conversion = {
        cm: 0.01,
        km: 1000,
        in: 0.0254,
        ft: 0.3048,
        yd: 0.9144,
        mi: 1609.3,
      };
      return value * (conversion[unit] || 1);
    }

    const param = {};

    try {
      if (to_cal === "1") {
        if (isFinite(vertical) && isFinite(hori)) {
          vertical = unitToMeter(Number(vertical), vertical_unit);
          hori = unitToMeter(Number(hori), hori_unit);
          const angleRad = Math.atan(vertical / hori);
          const ang_deg = (angleRad * 180) / Math.PI;
          const grade = vertical / hori;
          const gradep = grade * 100;

          param.tech_angle = angleRad;
          param.tech_ang_deg = ang_deg;
          param.tech_grade = grade;
          param.tech_gradep = gradep;
        } else {
          param.error = "Please! Check Your Input.";
        }
      } else if (to_cal === "2") {
        if (isFinite(angle) && isFinite(hori)) {
          hori = unitToMeter(Number(hori), hori_unit);
          const angleRad =
            angle_unit === "deg"
              ? (Number(angle) * Math.PI) / 180
              : Number(angle);
          const vertical = hori * Math.tan(angleRad);
          const grade = vertical / hori;
          const gradep = grade * 100;

          param.tech_vertical = vertical.toFixed(4) + " " + hori_unit;
          param.tech_grade = grade;
          param.tech_gradep = gradep;
        } else {
          param.error = "Please! Check Your Input.";
        }
      } else {
        if (isFinite(vertical) && isFinite(angle)) {
          vertical = unitToMeter(Number(vertical), vertical_unit);
          const angleRad =
            angle_unit === "deg"
              ? (Number(angle) * Math.PI) / 180
              : Number(angle);
          const hori = vertical / Math.tan(angleRad);
          const grade = vertical / hori;
          const gradep = grade * 100;

          param.tech_hori = hori.toFixed(4) + " " + vertical_unit;
          param.tech_grade = grade;
          param.tech_gradep = gradep;
        } else {
          param.error = "Please! Check Your Input.";
        }
      }
    } catch (e) {
      param.error = "An error occurred during calculation.";
    }

    return param;
  }

  /** getCalculationDilationCalculator
   * POST: /api/calculators-lol/dilation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDilationCalculator(body) {
    let nbr = body.tech_nbr;
    let dil = body.tech_dil;
    let a1 = body.tech_a1;
    let z1 = body.tech_z1;
    let a2 = body.tech_a2;
    let z2 = body.tech_z2;
    let a3 = body.tech_a3;
    let z3 = body.tech_z3;
    let a4 = body.tech_a4;
    let z4 = body.tech_z4;
    let a5 = body.tech_a5;
    let z5 = body.tech_z5;
    let a6 = body.tech_a6;
    let z6 = body.tech_z6;
    let a7 = body.tech_a7;
    let z7 = body.tech_z7;
    let a8 = body.tech_a8;
    let z8 = body.tech_z8;

    nbr = parseInt(nbr);
    dil = parseFloat(dil);

    const aValues = [a1, a2, a3, a4, a5, a6, a7, a8];
    const zValues = [z1, z2, z3, z4, z5, z6, z7, z8];
    const abc = ["A", "B", "C", "D", "E", "F", "G", "H"];

    const param = {};

    let checkInputs = true;

    for (let i = 0; i < nbr; i++) {
      const aVal = parseFloat(aValues[i]);
      const zVal = parseFloat(zValues[i]);

      if (!isFinite(aVal) || !isFinite(zVal)) {
        checkInputs = false;
        break;
      }
    }

    if (isFinite(dil) && checkInputs) {
      param.tech_aval = aValues;
      param.tech_zval = zValues;
      param.tech_abc = abc;
      param.tech_dil = dil;
    } else {
      param.error = "Please! Check Your Input.";
    }

    return param;
  }

  /**
   * getCalculationAreaOfASectorCalculator: Service Method
   * POST: /api/calculators-lol/area-of-a-sector-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

   async getCalculationAreaOfASectorCalculator(body) {
        // Helper function to convert degrees to radians
          let param = {};
        function deg2rad(deg) {
            return deg * (Math.PI / 180);
        }

        // Helper function for unit conversion
        function convertToCm(value, unit) {
            switch(unit) {
                case 'in':
                    return value * 2.54;
                case 'm':
                    return value * 100;
                case 'ft':
                    return value * 30.48;
                case 'yd':
                    return value * 91.44;
                default:
                    return value;
            }
        }

        function convertAreaToCm2(value, unit) {
            switch(unit) {
                case 'in':
                    return value * 6.45;
                case 'm':
                    return value * 10000;
                case 'ft':
                    return value * 929;
                case 'yd':
                    return value * 8361;
                default:
                    return value;
            }
        }
            let angle = body.tech_angle;
            let angle_unit = body.tech_angle_unit;
            let rad = body.tech_rad;
            let rad_unit = body.tech_rad_unit;
            let diameter = body.tech_diameter;
            let diameter_unit = body.tech_diameter_unit;
            let area = body.tech_area;
            let area_unit = body.tech_area_unit;
            let arc = body.tech_arc;
            let arc_unit = body.tech_arc_unit;
            let c = body.tech_c;
            let c_unit = body.tech_c_unit;

        // Convert string values to numbers where applicable
        const numAngle = angle ? parseFloat(angle) : null;
        const numRad = rad ? parseFloat(rad) : null;
        const numDiameter = diameter ? parseFloat(diameter) : null;
        const numArea = area ? parseFloat(area) : null;
        const numArc = arc ? parseFloat(arc) : null;
        const numC = c ? parseFloat(c) : null;

        // Case 1: angle and radius provided
        if (numAngle != null && numRad != null && 
            numDiameter == null && numArea == null && 
            numArc == null && numC == null) {
            
            let processedAngle = numAngle;
            if (angle_unit == 'deg') {
                processedAngle = deg2rad(processedAngle);
            }

            const calculatedArea = (processedAngle * Math.pow(numRad, 2)) / 2;
            const calculatedDia = numRad * 2;
            const calculatedArc = processedAngle * numRad;
            const calculatedC = 2 * numRad * Math.sin(processedAngle / 2);

            return {
                status: "success",
                 tech_mode: 1,
                tech_area: isNaN(calculatedArea) ? "NaN" : calculatedArea,
                tech_unit: rad_unit,
                tech_dia: isNaN(calculatedDia) ? "NaN" : calculatedDia,
                tech_arc: isNaN(calculatedArc) ? "NaN" : calculatedArc,
                tech_c: isNaN(calculatedC) ? "NaN" : calculatedC,

            };
        }
        // Case 2: angle and diameter provided
        else if (numAngle != null && numRad == null && 
                numDiameter != null && numArea == null && 
                numArc == null && numC == null) {
            
            let processedAngle = numAngle;
            if (angle_unit == 'deg') {
                processedAngle = deg2rad(processedAngle);
            }

            const calculatedRad = numDiameter / 2;
            const calculatedArea = (processedAngle * Math.pow(calculatedRad, 2)) / 2;
            const calculatedArc = processedAngle * calculatedRad;
            const calculatedC = 2 * calculatedRad * Math.sin(processedAngle / 2);

            return {
                status: "success",
                  tech_mode: 2,
                  tech_area: isNaN(calculatedArea) ? "NaN" : calculatedArea,
                  tech_unit: diameter_unit,
                  tech_rad: isNaN(calculatedRad) ? "NaN" : calculatedRad,
                  tech_arc: isNaN(calculatedArc) ? "NaN" : calculatedArc,
                  tech_c: isNaN(calculatedC) ? "NaN" : calculatedC,

            };
        }
        // Case 3: radius and area provided
        else if (numAngle == null && numRad != null && 
                numDiameter == null && numArea != null && 
                numArc == null && numC == null) {
            
            const checkUnit = area_unit.replace('²', '');
            let unit = rad_unit;
            let processedRad = numRad;
            let processedArea = numArea;

            if (checkUnit != rad_unit) {
                unit = 'cm';
                processedRad = convertToCm(numRad, rad_unit);
                processedArea = convertAreaToCm2(numArea, checkUnit);
            }

            const calculatedAngle = (processedArea * 2) / Math.pow(processedRad, 2);
            const calculatedArc = calculatedAngle * processedRad;
            const calculatedC = 2 * processedRad * Math.sin(calculatedAngle / 2);
            const calculatedDia = processedRad * 2;

            return {
                status: "success",
                 tech_mode: 3,
                  tech_angle: isNaN(calculatedAngle) ? "NaN" : calculatedAngle,
                  tech_unit: unit,
                  tech_dia: isNaN(calculatedDia) ? "NaN" : calculatedDia,
                  tech_arc: isNaN(calculatedArc) ? "NaN" : calculatedArc,
                  tech_c: isNaN(calculatedC) ? "NaN" : calculatedC,

            };
        }
        // Case 4: angle and area provided
        else if (numAngle != null && numRad == null && 
                numDiameter == null && numArea != null && 
                numArc == null && numC == null) {
            
            const unit = area_unit.replace('²', '');
            let processedAngle = numAngle;
            if (angle_unit == 'deg') {
                processedAngle = deg2rad(processedAngle);
            }

            const calculatedRad = Math.sqrt((2 * numArea) / processedAngle);
            const calculatedArc = processedAngle * calculatedRad;
            const calculatedC = 2 * calculatedRad * Math.sin(processedAngle / 2);
            const calculatedDia = calculatedRad * 2;

            return {
                status: "success",
                 tech_mode: 4,
                  tech_rad: isNaN(calculatedRad) ? "NaN" : calculatedRad,
                  tech_unit: unit,
                  tech_dia: isNaN(calculatedDia) ? "NaN" : calculatedDia,
                  tech_arc: isNaN(calculatedArc) ? "NaN" : calculatedArc,
                  tech_c: isNaN(calculatedC) ? "NaN" : calculatedC,

            };
        }
        // Case 5: angle and arc provided
        else if (numAngle != null && numRad == null && 
                numDiameter == null && numArea == null && 
                numArc != null && numC == null) {
            
            let processedAngle = numAngle;
            if (angle_unit == 'deg') {
                processedAngle = deg2rad(processedAngle);
            }

            const calculatedRad = numArc / processedAngle;
            const calculatedDia = calculatedRad * 2;
            const calculatedArea = (processedAngle * Math.pow(calculatedRad, 2)) / 2;
            const calculatedC = 2 * calculatedRad * Math.sin(processedAngle / 2);

            return {
                status: "success",
                 tech_mode: 5,
                tech_rad: isNaN(calculatedRad) ? "NaN" : calculatedRad,
                tech_unit: arc_unit,
                tech_dia: isNaN(calculatedDia) ? "NaN" : calculatedDia,
                tech_area: isNaN(calculatedArea) ? "NaN" : calculatedArea,
                tech_c: isNaN(calculatedC) ? "NaN" : calculatedC,

            };
        }
        // Case 6: angle and chord length provided
        else if (numAngle != null && numRad == null && 
                numDiameter == null && numArea == null && 
                numArc == null && numC !== null) {
            
            let processedAngle = numAngle;
            if (angle_unit == 'deg') {
                processedAngle = deg2rad(processedAngle);
            }

            const calculatedRad = numC / (2 * Math.sin(processedAngle / 2));
            const calculatedDia = calculatedRad * 2;
            const calculatedArea = (processedAngle * Math.pow(calculatedRad, 2)) / 2;
            const calculatedArc = processedAngle * calculatedRad;

            return {
                status: "success",
                  tech_mode: 6,
                  tech_rad: isNaN(calculatedRad) ? "NaN" : calculatedRad,
                  tech_unit: c_unit,
                  tech_dia: isNaN(calculatedDia) ? "NaN" : calculatedDia,
                  tech_area: isNaN(calculatedArea) ? "NaN" : calculatedArea,
                  tech_arc: isNaN(calculatedArc) ? "NaN" : calculatedArc,

            };
        }
        // Case 7: radius and arc provided
        else if (numAngle == null && numRad != null && 
                numDiameter == null && numArea == null && 
                numArc != null && numC == null) {
            
            let unit = rad_unit;
            let processedRad = numRad;
            let processedArc = numArc;

            if (arc_unit != rad_unit) {
                unit = 'cm';
                processedRad = convertToCm(numRad, rad_unit);
                processedArc = convertToCm(numArc, arc_unit);
            }

            const calculatedAngle = processedArc / processedRad;
            const calculatedArea = (calculatedAngle * Math.pow(processedRad, 2)) / 2;
            const calculatedC = 2 * processedRad * Math.sin(calculatedAngle / 2);
            const calculatedDia = processedRad * 2;

            return {
                status: "success",
                   tech_mode: 7,
                tech_angle: isNaN(calculatedAngle) ? "NaN" : calculatedAngle,
                tech_unit: unit,
                tech_dia: isNaN(calculatedDia) ? "NaN" : calculatedDia,
                tech_area: isNaN(calculatedArea) ? "NaN" : calculatedArea,
                tech_c: isNaN(calculatedC) ? "NaN" : calculatedC,

            };
        }
        // Case 8: radius and chord length provided
        else if (numAngle == null && numRad != null && 
                numDiameter == null && numArea == null && 
                numArc == null && numC != null) {
            
            let unit = rad_unit;
            let processedRad = numRad;
            let processedC = numC;

            if (c_unit != rad_unit) {
                unit = 'cm';
                processedRad = convertToCm(numRad, rad_unit);
                processedC = convertToCm(numC, c_unit);
            }

            const calculatedDia = processedRad * 2;
            const calculatedAngle = 2 * Math.asin(processedC / (2 * processedRad));
            const calculatedArea = (calculatedAngle * Math.pow(processedRad, 2)) / 2;
            const calculatedArc = calculatedAngle * processedRad;
            return {
                status: "success",
                    tech_mode: 8,
                    tech_angle: isNaN(calculatedAngle) ? "NaN" : calculatedAngle,
                    tech_unit: unit,
                    tech_dia: isNaN(calculatedDia) ? "NaN" : calculatedDia,
                    tech_area: isNaN(calculatedArea) ? "NaN" : calculatedArea,
                    tech_arc: isNaN(calculatedArc) ? "NaN" : calculatedArc,
            };
        }
        // Case 9: diameter and area provided
        else if (numAngle == null && numRad == null && 
                numDiameter != null && numArea != null && 
                numArc == null && numC == null) {
            
            const checkUnit = area_unit.replace('²', '');
            let unit = diameter_unit;
            let processedDiameter = numDiameter;
            let processedArea = numArea;

            if (checkUnit != diameter_unit) {
                unit = 'cm';
                processedDiameter = convertToCm(numDiameter, diameter_unit);
                processedArea = convertAreaToCm2(numArea, checkUnit);
            }

            const calculatedRad = processedDiameter / 2;
            const calculatedAngle = (processedArea * 2) / Math.pow(calculatedRad, 2);
            const calculatedArc = calculatedAngle * calculatedRad;
            const calculatedC = 2 * calculatedRad * Math.sin(calculatedAngle / 2);

            return {
                status: "success",
                    tech_mode: 9,
                tech_angle: isNaN(calculatedAngle) ? "NaN" : calculatedAngle,
                  tech_unit: unit,
                  tech_rad: isNaN(calculatedRad) ? "NaN" : calculatedRad,
                  tech_arc: isNaN(calculatedArc) ? "NaN" : calculatedArc,
                  tech_x: isNaN(calculatedC) ? "NaN" : calculatedC,
            };
        }
        // Case 10: diameter and arc provided
        else if (numAngle == null && numRad == null && 
                numDiameter != null && numArea == null && 
                numArc != null && numC == null) {
            
            let unit = diameter_unit;
            let processedDiameter = numDiameter;
            let processedArc = numArc;

            if (diameter_unit != arc_unit) {
                unit = 'cm';
                processedDiameter = convertToCm(numDiameter, diameter_unit);
                processedArc = convertToCm(numArc, arc_unit);
            }

            const calculatedRad = processedDiameter / 2;
            const calculatedAngle = processedArc / calculatedRad;
            const calculatedArea = (calculatedAngle * Math.pow(calculatedRad, 2)) / 2;
            const calculatedC = 2 * calculatedRad * Math.sin(calculatedAngle / 2);

            return {
                status: "success",
                    tech_mode: 10,
                  tech_angle: isNaN(calculatedAngle) ? "NaN" : calculatedAngle,
                  tech_unit: unit,
                  tech_rad: isNaN(calculatedRad) ? "NaN" : calculatedRad,
                  tech_area: isNaN(calculatedArea) ? "NaN" : calculatedArea,
                  tech_c: isNaN(calculatedC) ? "NaN" : calculatedC,

            };
        }
        // Case 11: diameter and chord length provided
        else if (numAngle == null && numRad == null && 
                numDiameter != null && numArea == null && 
                numArc == null && numC != null) {
            
            let unit = diameter_unit;
            let processedDiameter = numDiameter;
            let processedC = numC;

            if (c_unit != diameter_unit) {
                unit = 'cm';
                processedDiameter = convertToCm(numDiameter, diameter_unit);
                processedC = convertToCm(numC, c_unit);
            }

            const calculatedRad = processedDiameter / 2;
            const calculatedAngle = 2 * Math.asin(processedC / (2 * calculatedRad));
            const calculatedArea = (calculatedAngle * Math.pow(calculatedRad, 2)) / 2;
            const calculatedArc = calculatedAngle * calculatedRad;

            return {
                status: "success",
                    tech_mode: 11,
                   tech_angle: isNaN(calculatedAngle) ? "NaN" : calculatedAngle,
                  tech_unit: unit,
                  tech_rad: isNaN(calculatedRad) ? "NaN" : calculatedRad,
                  tech_area: isNaN(calculatedArea) ? "NaN" : calculatedArea,
                  tech_arc: isNaN(calculatedArc) ? "NaN" : calculatedArc,

            };
        }
        // Case 12: area and arc provided
        else if (numAngle == null && numRad == null && 
                numDiameter == null && numArea != null && 
                numArc != null && numC == null) {
            
            const checkUnit = area_unit.replace('²', '');
            let unit = arc_unit;
            let processedArea = numArea;
            let processedArc = numArc;

            if (checkUnit != arc_unit) {
                unit = 'cm';
                processedArc = convertToCm(numArc, arc_unit);
                processedArea = convertAreaToCm2(numArea, checkUnit);
            }

            const calculatedAngle = Math.pow(processedArc, 2) / (processedArea * 2);
            const calculatedRad = processedArc / calculatedAngle;
            const calculatedDia = calculatedRad * 2;
            const calculatedC = 2 * calculatedRad * Math.sin(calculatedAngle / 2);

            return {
                status: "success",
                 tech_mode: 12,
                tech_angle: isNaN(calculatedAngle) ? "NaN" : calculatedAngle,
                tech_unit: unit,
                tech_rad: isNaN(calculatedRad) ? "NaN" : calculatedRad,
                tech_dia: isNaN(calculatedDia) ? "NaN" : calculatedDia,
                tech_c: isNaN(calculatedC) ? "NaN" : calculatedC,

            };
        }
        // Case 13: area and chord length provided (not supported)
        else if (numAngle == null && numRad == null && 
                numDiameter == null && numArea != null && 
                numArc == null && numC != null) {
            
           return {
            status: false,
            error: 'Please Try with other values.'
        };
        }
        // Case 14: arc and chord length provided (not supported)
        else if (numAngle == null && numRad == null && 
                numDiameter == null && numArea == null && 
                numArc !== null && numC != null) {
            
             return {
            status: false,
            error: 'Please Try with other values.'
        };
        }
        // Default case: invalid input
        else {
           return {
            status: false,
            error: 'Please! Check Your Input.'
        };
        }
    }

  /** getCalculationPercentageIncreaseCalculator
   * POST: /api/calculators-lol/percentage-increase-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPercentageIncreaseCalculator(body) {
    let start = body.tech_start;
    let final = body.tech_final;

    start = parseFloat(start);
    final = parseFloat(final);

    const param = {};

    if (isFinite(start) && isFinite(final)) {
      let ans1 = (final - start) / Math.abs(start);
      let ans = ans1 * 100;
      let dif = final - start;

      param.tech_ans1 = parseFloat(ans1.toFixed(3));
      param.tech_ans = ans;
      param.tech_dif = dif;
    } else {
      param.error = "Please! Check Your Input.";
    }

    return param;
  }

  /** getCalculationPercentageDecreaseCalculator
   * POST: /api/calculators-lol/percentage-decrease-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPercentageDecreaseCalculator(body) {
    let start = body.tech_start;
    let final = body.tech_final;

    start = parseFloat(start);
    final = parseFloat(final);

    const param = {};

    if (isFinite(start) && isFinite(final)) {
      let ans = (final - start) / Math.abs(start);
      ans = ans * -100;
      let dif = final - start;

      param.tech_ans = ans;
      param.tech_dif = dif;
    } else {
      param.error = "Please! Check Your Input.";
    }

    return param;
  }

  /** getCalculationSphereCalculator
   * POST: /api/calculators-lol/sphere-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationSphereCalculator(body) {
    let slct1 = body.tech_slct1;
    let rad = body.tech_rad;
    let pi = body.tech_pi;

    let param = {};

    rad = parseFloat(rad);
    pi = parseFloat(pi);

    if (isFinite(rad) && isFinite(pi)) {
      let volume, surfacearea, circumference;
      let v1, c1, s1;

      if (slct1 === "1") {
        volume = (4 / 3) * pi * rad ** 3;
        surfacearea = pi * rad ** 2;
        circumference = 2 * pi * rad;
        v1 = (4 / 3) * rad ** 3;
        c1 = 2 * rad;
        s1 = c1 ** 2;
      } else if (slct1 === "2") {
        const originalVolume = rad; // input is volume
        rad = Math.cbrt((3 * originalVolume) / (4 * pi));
        volume = originalVolume;
        circumference = Math.pow(pi, 2 / 3) * Math.pow(6 * volume, 1 / 3);
        surfacearea = Math.pow(pi, 1 / 3) * Math.pow(6 * volume, 2 / 3);
        v1 = volume / pi;
        c1 = circumference / pi;
        s1 = surfacearea / pi;
      } else if (slct1 === "3") {
        const originalArea = rad; // input is surface area
        rad = Math.sqrt(originalArea / (4 * pi));
        surfacearea = originalArea;
        circumference = Math.sqrt(pi * surfacearea);
        volume = Math.pow(surfacearea, 1.5) / (6 * Math.sqrt(pi));
        v1 = volume / pi;
        c1 = circumference / pi;
        s1 = surfacearea / pi;
      } else if (slct1 === "4") {
        const originalCirc = rad; // input is circumference
        rad = originalCirc / (2 * pi);
        circumference = originalCirc;
        surfacearea = Math.pow(circumference, 2) / pi;
        volume = Math.pow(circumference, 3) / (6 * pi * pi);
        v1 = volume / pi;
        c1 = circumference / pi;
        s1 = surfacearea / pi;
      }

      param.tech_rad = +rad.toFixed(5);
      param.tech_vol = +volume.toFixed(5);
      param.tech_v1 = +v1.toFixed(5);
      param.tech_c1 = +c1.toFixed(5);
      param.tech_s1 = +s1.toFixed(5);
      param.tech_area = +surfacearea.toFixed(5);
      param.tech_c = +circumference.toFixed(5);
    } else {
      param.error = "Please! Check Your Input.";
    }

    return param;
  }

  /** getCalculationPercentageDifferenceCalculator
   * POST: /api/calculators-lol/percentage-difference-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPercentageDifferenceCalculator(body) {
    let start = parseFloat(body.tech_start);
    let final = parseFloat(body.tech_final);

    let param = {};

    if (isFinite(start) && isFinite(final)) {
      let ans = (Math.abs(start - final) / ((start + final) / 2)) * 100;
      let dif = final - start;

      param.tech_ans = ans;
      param.tech_dif = dif;
    } else {
      param.error = "Please! Check Your Input.";
    }

    return param;
  }

  /**
   * getCalculationParallelogramCalculator: Service Method
   * POST: /api/calculators-lol/parallelogram-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationParallelogramCalculator(body) {
    const unit = body.tech_unit;
    const rad = body.tech_rad1;
    const side1 = body.tech_side1;
    const side2 = body.tech_side2;
    const pi = body.tech_pi;
    const method = body.tech_slct1;

    const param = {};

    if (method == "1") {
      if (rad > 0 && rad < 90) {
        const c1 = 180;
        const c2 = c1 - rad;
        param.tech_rad = isNaN(rad) ? "NaN" : rad;
        param.tech_c2 = isNaN(c2) ? "NaN" : c2;
        return param;
      } else {
        param.error = "For a Parallelogram 0 < A < 90°";
        return param;
      }
    } else if (method == "2") {
      if (rad >= 91 && rad <= 179) {
        const c1 = 180;
        const c2 = c1 - rad;
        param.tech_rad = isNaN(rad) ? "NaN" : rad;
        param.tech_c1 = isNaN(c1) ? "NaN" : c1;

        return param;
      } else {
        param.error = "For a Parallelogram 90° < B < 180°";
        return param;
      }
    } else if (method == "3") {
      if (rad <= 89 && rad >= 1) {
        const c1 = 180;
        const c2 = c1 - rad;
        const hValue = side1 * Math.sin((rad * Math.PI) / 180);
        const h = (isNaN(hValue) ? "NaN" : hValue) + " " + unit;
        param.tech_h = h;
        param.tech_c2 = isNaN(c2) ? "NaN" : c2;

        return param;
      } else {
        param.error = "For a Parallelogram 0 < A < 90°";
        return param;
      }
    } else if (method == "4") {
      if (rad <= 89 && rad >= 1) {
        const aValue = side1 / Math.sin((rad * Math.PI) / 180);
        const bValue = 180 - rad;
        param.tech_a = isNaN(aValue) ? "NaN" : aValue;
        param.tech_b = isNaN(bValue) ? "NaN" : bValue;
        return param;
      } else {
        param.error = "For a Parallelogram 0 < A < 90°";
        return param;
      }
    } else if (method == "5") {
      if (rad > 0 && side1 > 0) {
        if (side1 <= rad * 2) {
          param.error =
            "Perimeter (P) must be at least 2 times side length (a).";
          return param;
        } else {
          const bValue = (side1 - 2 * rad) / 2;
          param.tech_b = isNaN(bValue) ? "NaN" : bValue;
          return param;
        }
      } else {
        param.error = "Please Enter Positive Numbers.";
        return param;
      }
    } else if (method == "6") {
      if (side1 <= rad * 2) {
        param.error = "Perimeter (P) must be at least 2 times side length (a).";
        return param;
      } else {
        const aValue = (side1 - 2 * rad) / 2;
        param.tech_a = isNaN(aValue) ? "NaN" : aValue;
        return param;
      }
    } else if (method == "7") {
      if (rad > 0 && side1 > 0) {
        const pValue = 2 * rad + 2 * side1;
        param.tech_p = isNaN(pValue) ? "NaN" : pValue;
        return param;
      } else {
        param.error = "Please Enter Positive Numbers.";
        return param;
      }
    } else if (method == "8") {
      if (rad > 0 && side1 > 0) {
        const hValue = side1 / rad;
        param.tech_h = isNaN(hValue) ? "NaN" : hValue;
        return param;
      } else {
        param.error = "Please Enter Positive Numbers.";
        return param;
      }
    } else if (method == "9") {
      if (rad > 0 && side1 > 0) {
        const bValue = side1 / rad;
        param.tech_b = isNaN(bValue) ? "NaN" : bValue;
        return param;
      } else {
        param.error = "Please Enter Positive Numbers.";
        return param;
      }
    } else if (method == "10") {
      if (rad > 0 && side1 > 0) {
        const kValue = rad * side1;
        param.tech_k = isNaN(kValue) ? "NaN" : kValue;
        return param;
      } else {
        param.error = "Please Enter Positive Numbers.";
        return param;
      }
    } else if (method == "11") {
      if (side1 > 0 && side2 > 0) {
        if (rad <= 89 && rad >= 1) {
          const val = 180;
          const calculate = val - rad;
          const h = side1 * Math.sin((rad * Math.PI) / 180);
          const k = side2 * h;
          const p = Math.sqrt(
            side1 * side1 +
              side2 * side2 -
              2 * side1 * side2 * Math.cos((rad * Math.PI) / 180)
          );
          const q = Math.sqrt(
            side1 * side1 +
              side2 * side2 +
              2 * side1 * side2 * Math.cos((rad * Math.PI) / 180)
          );
          const P = 2 * side1 + 2 * side2;
          param.tech_calculate = isNaN(calculate) ? "NaN" : calculate;
          param.tech_h = isNaN(h) ? "NaN" : h;
          param.tech_k = isNaN(k) ? "NaN" : k;
          param.tech_p = isNaN(p) ? "NaN" : p;
          param.tech_q = isNaN(q) ? "NaN" : q;
          param.tech_P = isNaN(P) ? "NaN" : P;
          return param;
        } else {
          param.error = "For a Parallelogram 0 < A < 90°";
          return param;
        }
      } else {
        param.error = "Please Enter Positive Numbers.";
        return param;
      }
    } else if (method == "12") {
      if (rad > 0 && side1 > 0 && side2 > 0) {
        const a =
          (Math.acos(
            (side2 * side2 - rad * rad - side1 * side1) / (-2 * rad * side1)
          ) *
            180) /
          Math.PI;
        const val = 180;
        const calculate = 180 - a;
        const h = rad * Math.sin((a * Math.PI) / 180);
        const q = Math.sqrt(
          rad * rad +
            side1 * side1 +
            2 * rad * side1 * Math.cos((a * Math.PI) / 180)
        );
        const P = 2 * rad + 2 * side1;
        const pl = Math.sqrt(
          rad * rad +
            side1 * side1 -
            2 * rad * side1 * Math.cos((a * Math.PI) / 180)
        );
        const pythagoras = Math.sqrt(rad * rad + side1 * side1);

        if (side2 <= pythagoras) {
          param.tech_h = isNaN(h) ? "NaN" : h;
          param.tech_calculate = isNaN(calculate) ? "NaN" : calculate;
          param.tech_q = isNaN(q) ? "NaN" : q;
          param.tech_P = isNaN(P) ? "NaN" : P;
          param.tech_pl = isNaN(pl) ? "NaN" : pl;
          param.tech_pythagoras = isNaN(pythagoras) ? "NaN" : pythagoras;
          return param;
        } else {
          param.error = `The shorter diagonal (p) must be less than ${pythagoras} according to the Pythagorean theorem with (a and b) as the two sides and (p) as the hypotenuse. Try entering a, b and q instead.`;
          return param;
        }
      } else {
        param.error = "Please Enter Positive Numbers.";
        return param;
      }
    } else if (method == "13") {
      if (rad > 0 && side1 > 0 && side2 > 0) {
        const pythagoras = Math.sqrt(rad * rad + side1 * side1);

        if (side2 >= pythagoras) {
          const a =
            (Math.acos(
              (side2 * side2 - rad * rad - side1 * side1) / (2 * rad * side1)
            ) *
              180) /
            Math.PI;
          const b = 180 - a;
          const P = 2 * rad + 2 * side1;
          const p = Math.sqrt(
            rad * rad +
              side1 * side1 -
              2 * rad * side1 * Math.cos((a * Math.PI) / 180)
          );
          const h = rad * Math.sin((a * Math.PI) / 180);
          param.tech_a = isNaN(a) ? "NaN" : a;
          param.tech_b = isNaN(b) ? "NaN" : b;
          param.tech_P = isNaN(P) ? "NaN" : P;
          param.tech_p = isNaN(p) ? "NaN" : p;
          param.tech_h = isNaN(h) ? "NaN" : h;

          return param;
        } else {
          param.error = `The longer diagonal (q) must be greater than ${pythagoras} according to the Pythagorean theorem with (a and b) as the two sides and (q) as the hypotenuse. Try entering a, b and p instead.`;
          return param;
        }
      } else {
        param.error = "Please Enter Positive Numbers.";
        return param;
      }
    } else if (method == "14") {
      if (rad > 0 && side1 > 0 && side2 > 0) {
        if (side2 <= rad) {
          const a = (Math.asin(side2 / rad) * 180) / Math.PI;
          const b = 180 - a;
          const p = Math.sqrt(
            rad * rad +
              side1 * side1 -
              2 * rad * side1 * Math.cos((a * Math.PI) / 180)
          );
          const q = Math.sqrt(
            rad * rad +
              side1 * side1 +
              2 * rad * side1 * Math.cos((a * Math.PI) / 180)
          );
          const P = 2 * rad + 2 * side1;
          const k = side1 * side2;
          param.tech_a = isNaN(a) ? "NaN" : a;
          param.tech_b = isNaN(b) ? "NaN" : b;
          param.tech_P = isNaN(P) ? "NaN" : P;
          param.tech_p = isNaN(p) ? "NaN" : p;
          param.tech_q = isNaN(q) ? "NaN" : q;
          param.tech_k = isNaN(k) ? "NaN" : k;

          return param;
        } else {
          param.error =
            "Height (h) must be less than or equal to the side length (a) to form a parallelogram.";
          return param;
        }
      } else {
        param.error = "Please Enter Positive Numbers.";
        return param;
      }
    } else if (method == "15") {
      if (rad > 0 && side1 > 0 && side2 > 0) {
        if (side2 > rad * side1) {
          param.error =
            "The area K of a rhombus must be less than or equal to side length (a) times side length (b) which is the area of a rectangle with sides a and b. (K ≤ a x b)";
          return param;
        } else if (side2 <= rad * side1) {
          const a = (Math.asin(side2 / (rad * side1)) * 180) / Math.PI;
          const b = 180 - a;
          const p = Math.sqrt(
            rad * rad +
              side1 * side1 -
              2 * rad * side1 * Math.cos((a * Math.PI) / 180)
          );
          const q = Math.sqrt(
            rad * rad +
              side1 * side1 +
              2 * rad * side1 * Math.cos((a * Math.PI) / 180)
          );
          const k = rad * side1;
          const h = rad * Math.sin((a * Math.PI) / 180);
          const P = 2 * rad + 2 * side1;
          param.tech_a = isNaN(a) ? "NaN" : a;
          param.tech_b = isNaN(b) ? "NaN" : b;
          param.tech_p = isNaN(p) ? "NaN" : p;
          param.tech_q = isNaN(q) ? "NaN" : q;
          param.tech_k = isNaN(k) ? "NaN" : k;
          param.tech_h = isNaN(h) ? "NaN" : h;
          param.tech_P = isNaN(P) ? "NaN" : P;

          return param;
        }
      } else {
        param.error = "Please Enter Positive Numbers.";
        return param;
      }
    } else if (method == "16") {
      if (side1 > 0 && side2 > 0) {
        if (rad <= 89 && rad >= 1) {
          const b = side2 / (side1 * Math.sin((rad * Math.PI) / 180));
          const b_angle = 180 - rad;
          const h = side1 * Math.sin((rad * Math.PI) / 180);
          const P = 2 * side1 + 2 * b;
          const p = Math.sqrt(
            side1 * side1 +
              b * b -
              2 * side1 * b * Math.cos((rad * Math.PI) / 180)
          );
          const q = Math.sqrt(
            side1 * side1 +
              b * b +
              2 * side1 * b * Math.cos((rad * Math.PI) / 180)
          );
          param.tech_b = isNaN(b) ? "NaN" : b;
          param.tech_b_angle = isNaN(b_angle) ? "NaN" : b_angle;
          param.tech_h = isNaN(h) ? "NaN" : h;
          param.tech_P = isNaN(P) ? "NaN" : P;
          param.tech_p = isNaN(p) ? "NaN" : p;
          param.tech_q = isNaN(q) ? "NaN" : q;

          return param;
        } else {
          param.error = "For a Parallelogram 0 < A < 90°";
          return param;
        }
      } else {
        param.error = "Please Enter Positive Numbers.";
        return param;
      }
    } else if (method == "17") {
      if (side1 > 0 && side2 > 0) {
        if (rad <= 89 && rad >= 1) {
          const a = side2 / (side1 * Math.sin((rad * Math.PI) / 180));
          const b_angle = 180 - rad;
          const P = 2 * a + 2 * side1;
          const h = a * Math.sin((rad * Math.PI) / 180);
          const p = Math.sqrt(
            a * a +
              side1 * side1 -
              2 * a * side1 * Math.cos((rad * Math.PI) / 180)
          );
          const q = Math.sqrt(
            a * a +
              side1 * side1 +
              2 * a * side1 * Math.cos((rad * Math.PI) / 180)
          );
          param.tech_a = isNaN(a) ? "NaN" : a;
          param.tech_b_angle = isNaN(b_angle) ? "NaN" : b_angle;
          param.tech_P = isNaN(P) ? "NaN" : P;
          param.tech_h = isNaN(h) ? "NaN" : h;
          param.tech_p = isNaN(p) ? "NaN" : p;
          param.tech_q = isNaN(q) ? "NaN" : q;
          return param;
        } else {
          param.error = "Please Enter Positive Numbers.";
          return param;
        }
      } else {
        param.error = "Please Enter Positive Numbers.";
        return param;
      }
    } else if (method == "18") {
      if (rad > 0 && side1 > 0 && side2 > 0) {
        let c1, c2, log, sam;

        if (side1 > side2) {
          c1 = (side1 - side2) / 2 + side1;
          c2 = (side2 - side2) / 2;
          log = "p";
          sam = "q";
        } else {
          c1 = (side2 - side1) / 2 + side1;
          c2 = (side2 - side1) / 2;
          log = "q";
          sam = "p";
        }

        if (rad < c2) {
          param.error = `Side length (b) must be longer than the difference between the longer diagonal (${log}) and the shorter diagonal (${sam}) divided by 2 plus (p). Side length (b) must be less than ${c2} or a diagonal must be longer. [b > absolute value of (q-p)/2].`;
          return param;
        } else if (rad > c1) {
          param.error = `Side length (b) must be shorter than the difference between the longer diagonal (${log}) and the shorter diagonal (${sam}) divided by 2 plus (p). Side length (b) must be less than ${c1} or b diagonal must be longer. [b > absolute value of (q-p)/2].`;
          return param;
        } else {
          const b = (side1 * side1 + side2 * side2 - 2 * (rad * rad)) / 2;
          const sq = Math.sqrt(b);
          const a =
            (Math.acos((side2 * side2 - rad * rad - sq * sq) / (2 * rad * sq)) *
              180) /
            Math.PI;
          const b_angle = 180 - a;
          const h = rad * Math.sin((a * Math.PI) / 180);
          const P = 2 * rad + 2 * sq;
          const k = rad * sq * Math.sin((a * Math.PI) / 180);
          param.tech_b = isNaN(b) ? "NaN" : b;
          param.tech_sq = isNaN(sq) ? "NaN" : sq;
          param.tech_a = isNaN(a) ? "NaN" : a;
          param.tech_b_angle = isNaN(b_angle) ? "NaN" : b_angle;
          param.tech_h = isNaN(h) ? "NaN" : h;
          param.tech_P = isNaN(P) ? "NaN" : P;
          param.tech_k = isNaN(k) ? "NaN" : k;
          return param;
        }
      } else {
        param.error = "Please Enter Positive Numbers.";
        return param;
      }
    } else if (method == "19") {
      if (rad > 0 && side1 > 0 && side2 > 0) {
        let c1, c2, log, sam;

        if (side1 > side2) {
          c1 = (side1 - side2) / 2 + side1;
          c2 = (side2 - side2) / 2;
          log = "p";
          sam = "q";
        } else {
          c1 = (side2 - side1) / 2 + side1;
          c2 = (side2 - side1) / 2;
          log = "q";
          sam = "p";
        }

        if (rad < c2) {
          param.error = `Side length (b) must be longer than the difference between the longer diagonal (${log}) and the shorter diagonal (${sam}) divided by 2 plus (p). Side length (b) must be less than ${c2} or a diagonal must be longer. [b > absolute value of (q-p)/2].`;
          return param;
        } else if (rad > c1) {
          param.error = `Side length (b) must be shorter than the difference between the longer diagonal (${log}) and the shorter diagonal (${sam}) divided by 2 plus (p). Side length (b) must be less than ${c1} or b diagonal must be longer. [b > absolute value of (q-p)/2].`;
          return param;
        } else {
          const a = (side1 * side1 + side2 * side2 - 2 * (rad * rad)) / 2;
          const sq = Math.sqrt(a);
          const an =
            (Math.acos((side2 * side2 - sq * sq - rad * rad) / (2 * sq * rad)) *
              180) /
            Math.PI;
          const b_angle = 180 - an;
          const h = sq * Math.sin((an * Math.PI) / 180);
          const P = 2 * sq + 2 * rad;
          const k = sq * rad * Math.sin((an * Math.PI) / 180);
          param.tech_a = isNaN(a) ? "NaN" : a;
          param.tech_sq = isNaN(sq) ? "NaN" : sq;
          param.tech_an = isNaN(an) ? "NaN" : an;
          param.tech_b_angle = isNaN(b_angle) ? "NaN" : b_angle;
          param.tech_h = isNaN(h) ? "NaN" : h;
          param.tech_P = isNaN(P) ? "NaN" : P;
          param.tech_k = isNaN(k) ? "NaN" : k;

          return param;
        }
      } else {
        param.error = "Please Enter Positive Numbers.";
        return param;
      }
    }

    return param;
  }

  /**
   * getCalculationVariationCalculator: Service Method
   * POST: /api/calculators-lol/variation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationVariationCalculator(body) {
    const x = parseFloat(body.tech_x); // The first numeric value
    const y = parseFloat(body.tech_y); // The second numeric value
    const select = body.tech_select; // The selection for the operation

    // Check if both x and y are numeric
    if (!isNaN(x) && !isNaN(y)) {
      let ans;

      switch (select) {
        case "1":
          ans = y / x;
          break;
        case "2":
          ans = y * x;
          break;
        case "3":
          ans = y / Math.pow(x, 2);
          break;
        case "4":
          ans = y / Math.pow(x, 3);
          break;
        case "5":
          ans = y / Math.sqrt(x);
          break;
        case "6":
          ans = y * Math.pow(x, 2);
          break;
        case "7":
          ans = y * Math.pow(x, 3);
          break;
        case "8":
          ans = y * Math.sqrt(x);
          break;
        default:
          return { error: "Invalid selection option." };
      }

      return {
        tech_ans: ans,
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /**
   * getCalculationDoublingtimeCalculator: Service Method
   * POST: /api/calculators-lol/doubling-time-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDoublingtimeCalculator(body) {
    const x = parseFloat(body.tech_x); // The percentage value
    const want = parseInt(body.tech_want); // The want value (1 or other)

    // Check if both x and want are numeric
    if (!isNaN(x) && !isNaN(want)) {
      let ans;

      if (want === 1) {
        // Doubling time formula for want = 1
        ans = Math.log(2) / Math.log(1 + x / 100);
      } else {
        // Doubling time formula for other values of want
        ans = Math.log(2) / x;
        ans = Math.pow(Math.E, ans) - 1;
        ans = ans * 100;
      }
      return {
        tech_ans: ans,
      };
    } else {
      return {
        error: "Please Check Your Input.",
      };
    }
  }

  /** getCalculationStandardFormtoSlopeInterceptFormCalculator
   * POST: /api/calculators-lol/standard-form-to-slope-intercept-form
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationStandardFormtoSlopeInterceptFormCalculator(body) {
    let a = body.tech_a;
    let b = body.tech_b;
    let c = body.tech_c;
    let to = body.tech_to;

    const result = {};

    // Helper functions
    function gcd(a, b) {
      a = Math.abs(a);
      b = Math.abs(b);

      if (a < b) {
        [b, a] = [a, b];
      }
      if (b === 0) {
        return 1;
      }
      let r = a % b;
      while (r > 0) {
        a = b;
        b = r;
        r = a % b;
      }
      return b;
    }

    function reduce(num, den) {
      const g = gcd(num, den);
      return [num / g, den / g];
    }

    function toFrac(num) {
      const numStr = num.toString();
      const parts = numStr.split(".");
      let div = "1";
      let count = 0;

      if (parts.length > 1) {
        count = parts[1].length;
      }

      for (let i = 1; i <= count; i++) {
        div += "0";
      }

      const divNum = parseInt(div);
      let upr;

      if (parts.length > 1) {
        upr = parseInt(parts[0] + parts[1]);
      } else {
        upr = parseInt(numStr);
      }

      return reduce(upr, divNum);
    }

    function lcmofn(numbers, n) {
      let ans = numbers[0];
      for (let i = 1; i < n; i++) {
        ans = (numbers[i] * ans) / gcd(numbers[i], ans);
      }
      return ans;
    }

    try {
      if (to == 1) {
        // Convert standard form to slope-intercept form
        let aNum = parseFloat(a);
        let bNum = parseFloat(b);
        let cNum = parseFloat(c);

        // Handle fractions
        const checkA = a.toString().split("/");
        if (checkA.length === 2) {
          aNum = parseFloat(checkA[0]) / parseFloat(checkA[1]);
        }

        const checkB = b.toString().split("/");
        if (checkB.length === 2) {
          bNum = parseFloat(checkB[0]) / parseFloat(checkB[1]);
        }

        const checkC = c.toString().split("/");
        if (checkC.length === 2) {
          cNum = parseFloat(checkC[0]) / parseFloat(checkC[1]);
        }

        if (isNaN(aNum) || isNaN(bNum) || isNaN(cNum) || bNum === 0) {
          result.error = "Please! Check Your Input.";
          return result;
        }

        const m = (-1 * aNum) / bNum;
        const nb = cNum / bNum;
        const angle =
          Math.round(Math.atan(m) * (180 / Math.PI) * 10000) / 10000;

        result.tech_m = Math.round(m * 100000) / 100000;
        result.tech_nb = Math.round(nb * 100000) / 100000;
        result.tech_angle = angle;
      } else {
        // Convert slope-intercept form to standard form
        let mNum = parseFloat(a);
        let cNum = parseFloat(b);

        // Handle fractions
        const checkA = a.toString().split("/");
        const checkB = b.toString().split("/");

        let upr, btm, upr1, btm1;
        let lcm;

        if (checkA.length === 1 && checkB.length === 1) {
          [upr, btm] = toFrac(mNum);
          [upr1, btm1] = toFrac(cNum);
          lcm = lcmofn([btm, btm1], 2);
        } else if (checkA.length === 2 && checkB.length === 1) {
          upr = parseFloat(checkA[0]);
          btm = parseFloat(checkA[1]);
          [upr1, btm1] = toFrac(cNum);
          lcm = lcmofn([btm, btm1], 2);
        } else if (checkA.length === 1 && checkB.length === 2) {
          [upr, btm] = toFrac(mNum);
          upr1 = parseFloat(checkB[0]);
          btm1 = parseFloat(checkB[1]);
          lcm = lcmofn([btm, btm1], 2);
        } else if (checkA.length === 2 && checkB.length === 2) {
          upr = parseFloat(checkA[0]);
          btm = parseFloat(checkA[1]);
          upr1 = parseFloat(checkB[0]);
          btm1 = parseFloat(checkB[1]);
          lcm = lcmofn([btm, btm1], 2);
        }

        const A = -1 * upr * (lcm / btm);
        const B = 1 * (lcm / btm1);
        const C = upr1 * (lcm / btm1);

        result.tech_A = A;
        result.tech_B = B;
        result.tech_C = C;
      }

      return result;
    } catch (error) {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /** getCalculationPolygonCalculator
   * POST: /api/calculators-lol/polygon-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPolygonCalculator(body) {
    let num1 = body.tech_operations;
    let num2 = body.tech_npolygon;
    let num3 = body.tech_calculation;
    let Label = body.tech_labl;
    let pie = body.tech_pie;
    let unit = body.tech_units;

    const result = {};

    if (isNaN(Label) || isNaN(pie)) {
      result.error = "Please Check Your Input";
      return result;
    }

    let nvalue = num1;

    if (nvalue == 15) {
      nvalue = num2;
      if (isNaN(nvalue) || nvalue <= 0) {
        result.error = "Enter number of polygon:";
        return result;
      }
    }

    let side_a, inradius, circumradius, area, perimeter, interior, extrior;

    try {
      const pieValue = parseFloat(pie);
      const labelValue = parseFloat(Label);
      const nvalueNum = parseFloat(nvalue);

      switch (num3) {
        case "01":
          const num01 = pieValue / nvalueNum;
          const co = 1 / Math.tan(num01);
          const res = 0.5 * labelValue;
          inradius = res * co;
          const se = 1 / Math.cos(num01);
          circumradius = inradius * se;
          const rr = inradius * inradius;
          const nr = nvalueNum * rr;
          const ta = Math.tan(num01);
          area = nr * ta;
          perimeter = nvalueNum * labelValue;
          const sub = nvalueNum - 2;
          const di = sub / nvalueNum;
          interior = di * 180;
          extrior = 360 / nvalueNum;
          side_a = labelValue;
          break;

        case "02":
          const a2 = Math.tan(pieValue / nvalueNum);
          const a0 = 2 * labelValue;
          side_a = a2 * a0;
          const r1 = 0.5 * side_a;
          const r2 = 1 / a2;
          inradius = r1 * r2;
          const R1 = 1 / Math.cos(pieValue / nvalueNum);
          circumradius = inradius * R1;
          const A1 = inradius * inradius;
          const A2 = nvalueNum * A1;
          area = A2 * a2;
          perimeter = nvalueNum * side_a;
          const sub2 = nvalueNum - 2;
          const di2 = sub2 / nvalueNum;
          interior = di2 * 180;
          extrior = 360 / nvalueNum;
          break;

        case "03":
          const Ra = 2 * labelValue;
          const Ra1 = Math.sin(pieValue / nvalueNum);
          side_a = Ra * Ra1;
          inradius = labelValue * Math.cos(pieValue / nvalueNum);
          const RR1 = 1 / Math.cos(pieValue / nvalueNum);
          circumradius = inradius * RR1;
          area =
            nvalueNum * Math.pow(inradius, 2) * Math.tan(pieValue / nvalueNum);
          perimeter = nvalueNum * side_a;
          const sub3 = nvalueNum - 2;
          const di3 = sub3 / nvalueNum;
          interior = di3 * 180;
          extrior = 360 / nvalueNum;
          break;

        case "04":
          nvalue = num1;
          const Aa1 = Math.tan(pieValue / nvalueNum);
          const Aa2 = 4 * Aa1 * labelValue;
          const Aa3 = Aa2 / nvalueNum;
          side_a = Math.sqrt(Aa3);
          const Ar1 = 1 / Math.tan(pieValue / nvalueNum);
          inradius = 0.5 * side_a * Ar1;
          const AR1 = 1 / Math.cos(pieValue / nvalueNum);
          circumradius = inradius * AR1;
          perimeter = nvalueNum * side_a;
          const sub4 = nvalueNum - 2;
          const di4 = sub4 / nvalueNum;
          interior = di4 * 180;
          extrior = 360 / nvalueNum;
          area = labelValue;
          break;

        case "05":
          side_a = labelValue / nvalueNum;
          const pr1 = 1 / Math.tan(pieValue / nvalueNum);
          inradius = 0.5 * side_a * pr1;
          const pR1 = 1 / Math.cos(pieValue / nvalueNum);
          circumradius = inradius * pR1;
          const pA1 = inradius * inradius;
          const pA2 = nvalueNum * pA1;
          const pA3 = Math.tan(pieValue / nvalueNum);
          area = pA2 * pA3;
          const sub5 = nvalueNum - 2;
          const di5 = sub5 / nvalueNum;
          interior = di5 * 180;
          extrior = 360 / nvalueNum;
          perimeter = labelValue;
          break;

        default:
          result.error = "Invalid calculation type";
          return result;
      }

      result.tech_nvalue = nvalue;
      result.tech_side_a = side_a;
      result.tech_inradius = inradius;
      result.tech_circumradius = circumradius;
      result.tech_area = area;
      result.tech_perimeter = perimeter;
      result.tech_interior = interior;
      result.tech_extrior = extrior;
      result.tech_unit = unit;

      return result;
    } catch (error) {
      result.error = "Please Check Your Input";
      return result;
    }
  }

  /** getCalculationGoldenRatioCalculator
   * POST: /api/calculators-lol/golden-ratio-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationGoldenRatioCalculator(body) {
    let selection = body.tech_selection;
    let a = body.tech_a;
    let value = 1.6180339887498;
    let param = {};

    a = parseFloat(a);

    if (isFinite(a)) {
      let longer_section, shorter_section, sum;

      if (selection === "1") {
        longer_section = a;
        shorter_section = a / value;
        sum = shorter_section + a;
      }

      if (selection === "2") {
        shorter_section = a;
        longer_section = value * a;
        sum = longer_section + a;
      }

      if (selection === "3") {
        sum = a;
        longer_section = a / value;
        shorter_section = longer_section / value;
      }

      param.tech_value = value;
      param.tech_a = +a.toFixed(5);
      param.tech_sum = +sum.toFixed(5);
      param.tech_longer_section = +longer_section.toFixed(5);
      param.tech_shorter_section = +shorter_section.toFixed(5);
    } else {
      param.error = "Please Check Your Input.";
    }

    return param;
  }

  /**
   * getCalculationReferenceAngleCalculator: Service Method
   * POST: /api/calculators-lol/reference-angle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationReferenceAngleCalculator(body) {
    const angle = body.tech_angle;
    const angle_unit = body.tech_angle_unit;
    const param = {};

    if (angle_unit == "deg") {
      if (!isNaN(angle) && angle !== null && angle !== "") {
        let angle_convert = angle * 1;
        let ans, src;

        if (angle_convert >= 0 && angle_convert <= 90) {
          ans = angle_convert;
          src = "11.svg";
        } else if (angle_convert > 90 && angle_convert <= 180) {
          ans = 180 - angle_convert;
          src = "22.svg";
        } else if (angle_convert > 180 && angle_convert <= 270) {
          ans = angle_convert - 180;
          src = "33.svg";
        } else if (angle_convert > 270 && angle_convert <= 360) {
          ans = 360 - angle_convert;
          src = "44.svg";
        } else if (angle_convert > 360) {
          while (angle_convert > 360) {
            angle_convert = angle_convert - 360;
          }
          if (angle_convert >= 0 && angle_convert <= 90) {
            ans = angle_convert;
            src = "11.svg";
          } else if (angle_convert > 90 && angle_convert <= 180) {
            ans = 180 - angle_convert;
            src = "22.svg";
          } else if (angle_convert > 180 && angle_convert <= 270) {
            ans = angle_convert - 180;
            src = "33.svg";
          } else if (angle_convert > 270 && angle_convert <= 360) {
            ans = 360 - angle_convert;
            src = "44.svg";
          }
        } else if (angle_convert <= 0 && angle_convert >= -90) {
          const mul = -1;
          ans = angle_convert * mul;
          src = "44.svg";
        } else if (angle_convert < -90 && angle_convert >= -180) {
          const mul = -1;
          const converting = angle_convert * -1;
          ans = 180 - converting;
          src = "33.svg";
        } else if (angle_convert < -180 && angle_convert >= -270) {
          const mul = -1;
          const converting = angle_convert * -1;
          ans = converting - 180;
          src = "22.svg";
        } else if (angle_convert < -270 && angle_convert >= -360) {
          const mul = -1;
          const converting = angle_convert * -1;
          ans = converting - 360;
          src = "11.svg";
        } else if (angle_convert < -360) {
          while (angle_convert < -360) {
            angle_convert = angle_convert + 360;
          }
          if (angle_convert <= 0 && angle_convert >= -90) {
            const mul = -1;
            ans = angle_convert * mul;
            src = "44.svg";
          } else if (angle_convert < -90 && angle_convert >= -180) {
            const mul = -1;
            const converting = angle_convert * mul;
            ans = 180 - converting;
            src = "33.svg";
          } else if (angle_convert < -180 && angle_convert >= -270) {
            const mul = -1;
            const converting = angle_convert * mul;
            ans = angle_convert - converting;
            src = "22.svg";
          } else if (angle_convert < -270 && angle_convert >= -360) {
            const mul = -1;
            const converting = angle_convert * mul;
            ans = angle_convert - converting;
            src = "11.svg";
          }
        }
        param.tech_pi = ans * 0.005556;
        param.tech_ans = ans;
        param.tech_src = src;
      } else {
        param.error = "Please Check Your Input.";
        return param;
      }
    } else if (angle_unit == "rad") {
      if (!isNaN(angle) && angle !== null && angle !== "") {
        let convert = angle * 57.2958;
        let ans, src;

        if (convert >= 0 && convert <= 90) {
          ans = convert;
          src = "11.svg";
        } else if (convert > 90 && convert <= 180) {
          ans = 180 - convert;
          src = "22.svg";
        } else if (convert > 180 && convert <= 270) {
          ans = convert - 180;
          src = "33.svg";
        } else if (convert > 270 && convert <= 360) {
          ans = 360 - convert;
          src = "44.svg";
        } else if (convert > 360) {
          while (convert > 360) {
            convert = convert - 360;
          }
          if (convert >= 0 && convert <= 90) {
            ans = convert;
            src = "11.svg";
          } else if (convert > 90 && convert <= 180) {
            ans = 180 - convert;
            src = "22.svg";
          } else if (convert > 180 && convert <= 270) {
            ans = convert - 180;
            src = "33.svg";
          } else if (convert > 270 && convert <= 360) {
            ans = 360 - convert;
            src = "44.svg";
          }
        } else if (convert <= 0 && convert >= -90) {
          const mul = -1;
          ans = convert * mul;
          src = "44.svg";
        } else if (convert < -90 && convert >= -180) {
          src = "33.svg";
          const mul = -1;
          const converting = convert * mul;
          ans = 180 - converting;
        } else if (convert < -180 && convert >= -270) {
          const mul = -1;
          src = "22.svg";
          const converting = convert * mul;
          ans = converting - 180;
        } else if (convert < -270 && convert >= -360) {
          src = "11.svg";
          const mul = -1;
          const converting = convert * mul;
          ans = 360 - converting;
        } else if (convert < -360) {
          while (convert < -360) {
            convert = convert + 360;
          }
          if (convert <= 0 && convert >= -90) {
            const mul = -1;
            ans = convert * mul;
            src = "44.svg";
          } else if (convert < -90 && convert >= -180) {
            src = "33.svg";
            const mul = -1;
            const converting = convert * mul;
            ans = 180 - converting;
          } else if (convert < -180 && convert >= -270) {
            const mul = -1;
            const converting = convert * mul;
            src = "22.svg";
            ans = converting - 180;
          } else if (convert < -270 && convert >= -360) {
            src = "11.svg";
            const mul = -1;
            const converting = convert * mul;
            ans = 360 - converting;
          }
        }
        param.tech_pi = ans * 0.3183 * 0.017453;
        param.tech_ans = ans;
        param.tech_src = src;
      } else {
        param.error = "Please Check Your Input.";
        return param;
      }
    } else {
      if (!isNaN(angle) && angle !== null && angle !== "") {
        const ans = angle * 0;
        const src = "";
        param.tech_ans = ans;
        param.tech_src = src;
      } else {
        param.error = "Please Check Your Input.";
        return param;
      }
    }

    return param;
  }

  /** getCalculationImproperFractionstoMixedNumbersCalculator
   * POST: /api/calculators-lol/improper-fractions-to-mixed-numbers
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationImproperFractionstoMixedNumbersCalculator(body) {
    let uper = body.tech_uper;
    let btm = body.tech_btm;
    let param = {};

    uper = parseFloat(uper);
    btm = parseFloat(btm);

    if (isFinite(uper) && isFinite(btm)) {
      if (uper >= btm) {
        let rem = uper % btm;
        let q = Math.floor(uper / btm);
        param.tech_q = q;
        param.tech_rem = rem;
      } else {
        param.RESULT = 1;
      }
    } else {
      param.error = "Please Check Your Input.";
    }

    return param;
  }

  /** getCalculationMixedNumberstoImproperFractionsCalculator
   * POST: /api/calculators-lol/mixed-numbers-to-improper-fractions
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMixedNumberstoImproperFractionsCalculator(body) {
    let whole = body.tech_whole;
    let uper = body.tech_uper;
    let btm = body.tech_btm;

    let param = {};

    whole = parseFloat(whole);
    uper = parseFloat(uper);
    btm = parseFloat(btm);

    if (isFinite(uper) && isFinite(btm) && isFinite(whole)) {
      let multi = btm * whole;
      let plus = multi + uper;

      param.tech_multi = multi;
      param.tech_plus = plus;
    } else {
      param.error = "Please Check Your Input.";
    }

    return param;
  }

  /** getCalculationLocalMaximaandMinimaCalculator
   * POST: /api/calculators-lol/local-maxima-and-minima-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLocalMaximaandMinimaCalculator(body) {
    let EnterEq = body.tech_equation;

    let param = {};

    // Input validation
    if (
      !EnterEq ||
      typeof EnterEq !== "string" ||
      /[<>&]|php|print_r|print|echo|script|=|%/i.test(EnterEq)
    ) {
      param.error = "Please! Check Your Input.";
      return param;
    }

    // Cleaning and transforming the equation
    let parem = EnterEq.replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^x/g, "exp(x)")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    try {
      let wrt = /y/i.test(parem) && /x/i.test(parem) ? "xy" : "x";

      const response = await axios.get("http://167.172.134.148/local", {
        params: {
          equ: parem,
          wrt: wrt,
        },
        timeout: 120000, // 120 seconds
      });

      const buffer = response.data.split("@@@");

      if (buffer[4] === "\\left[ \\right]") {
        param.error = "No solution exists";
        return param;
      }

      param.tech_buffer = buffer[0];
      param.tech_ans = buffer[1];
      param.tech_enter = buffer[2];
      param.tech_simple = buffer[3];
      param.tech_root = buffer[4];
      param.tech_fac = buffer[7];

      if (wrt === "xy") {
        param.tech_step = buffer[5];
        param.tech_ans1 = buffer[6];
        param.tech_wrt = "xy";
      } else {
        param.tech_mini = buffer[5];
        param.tech_maxi = buffer[6];
      }

      return param;
    } catch (err) {
      param.error = "Please! Check Your Input.";
      return param;
    }
  }

  /**
   * getCalculationRationalOrIrrationalCalculator: Service Method
   * POST: /api/calculators-lol/rational-or-irrational-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRationalOrIrrationalCalculator(body) {
    const expression_unit = body.tech_expression_unit;
    const num1 = body.tech_num1;
    const num2 = body.tech_num2;
    const param = {};

    // Helper function to find repeating patterns
    function findRepeat(number) {
      const maxLength = 6;
      const numberStr = number.toString();
      const dotIndex = numberStr.indexOf(".");

      if (dotIndex == -1) return false;

      let decimal = numberStr.substring(dotIndex + 1);

      if (decimal.length >= maxLength) {
        decimal = decimal.substring(0, maxLength);
      }

      const checkLength = decimal.length;

      for (let i = 0; i < checkLength - 3; ++i) {
        // Check for single repetition
        if (decimal[i] == decimal[i + 1] && decimal[i + 1] == decimal[i + 2]) {
          return { position: i, patternSize: 1 };
        }
        // Triple repetition
        if (decimal.substring(i, i + 3) == decimal.substring(i + 3, i + 6)) {
          return { position: i, patternSize: 3 };
        }
        // Double repetition
        if (decimal.substring(i, i + 2) == decimal.substring(i + 2, i + 4)) {
          return { position: i, patternSize: 2 };
        }
      }
      return false;
    }

    if (
      !isNaN(num1) &&
      num1 != null &&
      num1 != "" &&
      !isNaN(num2) &&
      num2 != null &&
      num2 != ""
    ) {
      let final_ans, exp;

      if (expression_unit == "1") {
        if (num1 > 0 && num2 > 0) {
          const num1_ans = 1 / num1;
          final_ans = Math.pow(num2, num1_ans);
        } else {
          param.error = "Please Enter value greater than zero.";
          return param;
        }

        if (num2 % num1 == 0) {
          if (num1 == num2) {
            if (num1 == 1 && num2 == 1) {
              exp = "Given Number is Rational";
            } else {
              exp = "Given Number is Irrational";
            }
          } else if (num1 != num2) {
            exp = "Given Number is Rational";
          }
        } else {
          exp = "Given Number is Irrational";
        }
      } else if (expression_unit == "2") {
        if (!isNaN(num1) && num1 != null && num1 != "" && num2 > 0) {
          if (num1 == 22 && num2 == 7) {
            final_ans = num1 / num2;
            exp = "Given Number is Irrational";
          } else {
            final_ans = num1 / num2;
            exp = "Given Number is Rational";
          }

          const repeatResult = findRepeat(final_ans);
          if (repeatResult != false) {
            const finalAnsStr = final_ans.toString();
            const dotIndex = finalAnsStr.indexOf(".");
            const leadingNum = finalAnsStr.substring(0, dotIndex);

            let nonRepeat = finalAnsStr.substring(
              dotIndex + 1,
              dotIndex + 1 + repeatResult.position
            );
            if (nonRepeat == "") {
              nonRepeat = ".";
            }

            const repeat = finalAnsStr.substring(
              dotIndex + 1 + repeatResult.position,
              dotIndex + 1 + repeatResult.position + repeatResult.patternSize
            );

            const nonRepeatStr = nonRepeat == "." ? "." : "." + nonRepeat;
            final_ans =
              leadingNum +
              nonRepeatStr +
              "<span style='text-decoration:overline'>" +
              repeat +
              "</span>";
          } else {
            final_ans = final_ans;
          }
        } else {
          param.error = "Please Enter value greater than zero.";
          return param;
        }
      }

      if (final_ans != undefined && final_ans != null) {
        param.tech_final_ans = final_ans;
      }
      if (exp != undefined && exp != null && exp != "") {
        param.tech_exp = exp;
      }
      return param;
    } else {
      param.error = "Please! Check Your Input.";
      return param;
    }
  }

  /**
   * getCalculationSimplifyRadicalsCalculator: Service Method
   * POST: /api/calculators-lol/simplify-radicals-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSimplifyRadicalsCalculator(body) {
    let num1 = body.tech_num1;
    let num2 = body.tech_num2;
    let num3 = body.tech_num3;
    let num4 = body.tech_num4;
    let num5 = body.tech_num5;
    let num6 = body.tech_num6;
    const expression_unit = body.tech_expression_unit;
    const param = {};

    if (expression_unit == "1") {
      if (
        !isNaN(num2) &&
        num2 != null &&
        num2 != "" &&
        !isNaN(num3) &&
        num3 != null &&
        num3 != ""
      ) {
        if (num2 < 0) {
          param.error = "b cannot be negative";
          return param;
        }
        if (num3 < 2) {
          param.error = "n cannot be smaller than 2";
          return param;
        }
        if (num1 != "" && num1 != null && num1 != undefined) {
          // num1 has value
        } else if (num1 == "" || num1 == null || num1 == undefined) {
          num1 = 1;
        } else if (num1 == 0) {
          param.error = "Number cannot be zero";
          return param;
        }

        param.tech_num1 = num1;
        param.tech_num2 = num2;
        param.tech_num3 = num3;
        param.tech_num4 = 1;
        param.tech_num5 = 1;
        param.tech_num6 = 1;
        param.tech_expression_unit = expression_unit;
        return param;
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }
    } else if (expression_unit == "2") {
      if (
        !isNaN(num2) &&
        num2 != null &&
        num2 != "" &&
        !isNaN(num3) &&
        num3 != null &&
        num3 != "" &&
        !isNaN(num5) &&
        num5 != null &&
        num5 != "" &&
        !isNaN(num6) &&
        num6 != null &&
        num6 != ""
      ) {
        if (num2 < 0) {
          param.error = "b cannot be negative";
          return param;
        }
        if (num3 < 2) {
          param.error = "n cannot be smaller than 2";
          return param;
        }
        if (num5 < 0) {
          param.error = "d cannot be negative";
          return param;
        }
        if (num6 < 2) {
          param.error = "m cannot be smaller than 2";
          return param;
        }

        if (num1 == "" || num1 == null || num1 == undefined) {
          num1 = 1;
        } else if (num1 != "" && num1 != null && num1 != undefined) {
          param.tech_num1 = num1;
        } else if (num1 == 0) {
          param.error = "Number cannot be zero";
          return param;
        }

        if (num4 == "" || num4 == null || num4 == undefined) {
          num4 = 1;
        } else if (num4 != "" && num4 != null && num4 != undefined) {
          param.tech_num4 = num4;
        } else if (num4 == 0) {
          param.error = "Number cannot be zero";
          return param;
        }

        param.tech_num1 = num1;
        param.tech_num4 = num4;
        param.tech_num2 = num2;
        param.tech_num3 = num3;
        param.tech_num5 = num5;
        param.tech_num6 = num6;
        param.tech_expression_unit = expression_unit;
        return param;
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }
    } else if (expression_unit == "3") {
      if (
        !isNaN(num2) &&
        num2 != null &&
        num2 != "" &&
        !isNaN(num3) &&
        num3 != null &&
        num3 != "" &&
        !isNaN(num5) &&
        num5 != null &&
        num5 != "" &&
        !isNaN(num6) &&
        num6 != null &&
        num6 != ""
      ) {
        if (num2 < 0) {
          param.error = "b cannot be negative";
          return param;
        }
        if (num3 < 2) {
          param.error = "n cannot be smaller than 2";
          return param;
        }
        if (num5 < 0) {
          param.error = "d cannot be negative";
          return param;
        }
        if (num6 < 2) {
          param.error = "m cannot be smaller than 2";
          return param;
        }

        if (num1 == "" || num1 == null || num1 == undefined) {
          num1 = 1;
        } else if (num1 != "" && num1 != null && num1 != undefined) {
          param.tech_num1 = num1;
        } else if (num1 == 0) {
          param.error = "Number cannot be zero";
          return param;
        }

        if (num4 == "" || num4 == null || num4 == undefined) {
          num4 = 1;
        } else if (num4 != "" && num4 != null && num4 != undefined) {
          param.tech_num4 = num4;
        } else if (num4 == 0) {
          param.error = "Number cannot be zero";
          return param;
        }

        param.tech_num1 = num1;
        param.tech_num4 = num4;
        param.tech_num2 = num2;
        param.tech_num3 = num3;
        param.tech_num5 = num5;
        param.tech_num6 = num6;
        param.tech_expression_unit = expression_unit;
        param.tech_operation = 4;
        return param;
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }
    } else if (expression_unit == "4") {
      if (
        !isNaN(num2) &&
        num2 != null &&
        num2 != "" &&
        !isNaN(num3) &&
        num3 != null &&
        num3 != "" &&
        !isNaN(num5) &&
        num5 != null &&
        num5 != "" &&
        !isNaN(num6) &&
        num6 != null &&
        num6 != ""
      ) {
        if (num2 < 0) {
          param.error = "b cannot be negative";
          return param;
        }
        if (num3 < 2) {
          param.error = "n cannot be smaller than 2";
          return param;
        }
        if (num5 < 0) {
          param.error = "d cannot be negative";
          return param;
        }
        if (num6 < 2) {
          param.error = "m cannot be smaller than 2";
          return param;
        }

        if (num1 == "" || num1 == null || num1 == undefined) {
          num1 = 1;
        } else if (num1 != "" && num1 != null && num1 != undefined) {
          param.tech_num1 = num1;
        } else if (num1 == 0) {
          param.error = "Number cannot be zero";
          return param;
        }

        if (num4 == "" || num4 == null || num4 == undefined) {
          num4 = 1;
        } else if (num4 != "" && num4 != null && num4 != undefined) {
          param.tech_num4 = num4;
        } else if (num4 == 0) {
          param.error = "Number cannot be zero";
          return param;
        }

        param.tech_num1 = num1;
        param.tech_num4 = num4;
        param.tech_num2 = num2;
        param.tech_num3 = num3;
        param.tech_num5 = num5;
        param.tech_num6 = num6;
        param.tech_expression_unit = expression_unit;
        param.tech_operation = 4;
        return param;
      } else {
        param.error = "Please! Check Your Input";
        return param;
      }
    }
  }

  /** getCalculationLCDCalculator
   * POST: /api/calculators-lol/lcd-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLCDCalculator(body) {
    let x = body.tech_x;
    const result = {};

    if (!x || typeof x !== "string") {
      result.error = "Please! Check Your Input.";
      return result;
    }

    x = x.trim();
    const input = x.split(",");
    const upper = [];
    const btm = [];
    let check = true;

    for (let value of input) {
      value = value.trim();
      const fraction_check = value.split("/");
      if (fraction_check.length === 2) {
        const mixed_check = fraction_check[0].trim().split(" ");
        if (mixed_check.length === 2) {
          const [whole, numerator] = mixed_check.map(Number);
          const denominator = parseFloat(fraction_check[1]);

          if (isNaN(whole) || isNaN(numerator) || isNaN(denominator)) {
            check = false;
            break;
          }

          const up = whole * denominator + numerator;
          upper.push(up);
          btm.push(denominator);
        } else if (mixed_check.length === 1) {
          const num = parseFloat(fraction_check[0]);
          const den = parseFloat(fraction_check[1]);
          if (isNaN(num) || isNaN(den)) {
            check = false;
            break;
          }
          upper.push(num);
          btm.push(den);
        } else {
          check = false;
          break;
        }
      } else if (fraction_check.length === 1) {
        const val = parseFloat(value);
        if (isNaN(val)) {
          check = false;
          break;
        }
        upper.push(val);
        btm.push(1);
      } else {
        check = false;
        break;
      }
    }

    if (!check) {
      result.error = "Please! Check Your Input.";
      return result;
    }

    // GCD function
    function gcd(a, b) {
      return b === 0 ? a : gcd(b, a % b);
    }

    // LCM of array
    function lcmOfArray(arr) {
      return arr.reduce((a, b) => (a * b) / gcd(a, b));
    }

    const lcm = lcmOfArray(btm);
    const multiple = btm.map((den) => lcm / den);

    result.tech_input = input;
    result.tech_upper = upper;
    result.tech_btm = btm;
    result.tech_multiple = multiple;
    result.tech_lcm = lcm;
    return result;
  }

  /** getCalculationUnitRateCalculator
   * POST: /api/calculators-lol/unit-rate-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationUnitRateCalculator(body) {
    let a = parseFloat(body.tech_a);
    let b = parseFloat(body.tech_b);
    let c = body.tech_c; // unused, but extracted for completeness
    let d = body.tech_d; // unused, but extracted for completeness

    const result = {};

    if (!isNaN(a) && !isNaN(b)) {
      if (b !== 0) {
        let ans = a / b;
        let ans2 = ans;
        let ans3 = ans;

        if (ans.toString().includes(".")) {
          ans = ans.toFixed(2);
          ans2 = ans2.toFixed(2);
          ans3 = ans3.toFixed(2);
        }

        result.tech_ans = ans;
        result.tech_ans2 = ans2;
        result.tech_ans3 = ans3;
      } else {
        result.error = "Denominator cannot be zero.";
      }
    } else {
      result.error = "Please! Check Your Input.";
    }

    return result;
  }

  /** getCalculationEquivalentFractionsCalculator
   * POST: /api/calculators-lol/equivalent-fractions-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationEquivalentFractionsCalculator(body) {
    let want_to = parseInt(body.tech_want_to);
    let is_frac = parseInt(body.tech_is_frac);
    let s1 = parseFloat(body.tech_s1);
    let n1 = parseFloat(body.tech_n1);
    let d1 = parseFloat(body.tech_d1);
    let s2 = parseFloat(body.tech_s2);
    let n2 = parseFloat(body.tech_n2);
    let d2 = parseFloat(body.tech_d2);
    let s3 = parseFloat(body.tech_s3);
    let n3 = parseFloat(body.tech_n3);
    let d3 = parseFloat(body.tech_d3);
    let no = parseInt(body.tech_no);

    const result = {};

    function gcd(a, b) {
      a = Math.abs(a);
      b = Math.abs(b);
      if (a < b) [a, b] = [b, a];
      if (b === 0) return 1;
      let r = a % b;
      while (r > 0) {
        a = b;
        b = r;
        r = a % b;
      }
      return b;
    }

    function reduce(num, den) {
      const g = gcd(num, den);
      return [num / g, den / g];
    }

    if (want_to === 1) {
      if (!isNaN(n1) && !isNaN(d1)) {
        let up;
        if (is_frac === 2 && !isNaN(s1)) {
          if (n1 < 0) {
            result.error = "Numerator and denominator must be positive";
            return result;
          }
          up = s1 < 1 ? d1 * s1 - n1 : d1 * s1 + n1;
        } else {
          up = n1;
        }

        if (no > 100) no = 100;

        let upper = [];
        let bottom = [];

        for (let i = 1; i <= no; i++) {
          upper.push(up * i);
          bottom.push(d1 * i);
        }

        result.tech_upper = upper;
        result.tech_bottom = bottom;
        return result;
      } else {
        result.error = "Please Check Your Input";
        return result;
      }
    } else {
      if (!isNaN(n2) && !isNaN(d2) && !isNaN(n3) && !isNaN(d3)) {
        let up1, up2, input1, input2;

        if (is_frac === 2 && !isNaN(s2)) {
          if (n2 < 0) {
            result.error = "Numerator and denominator must be positive";
            return result;
          }
          up1 = s2 < 1 ? d2 * s2 - n2 : d2 * s2 + n2;
          input1 = `${s2} ${n2}/${d2}`;
        } else {
          up1 = n2;
          input1 = `${n2}/${d2}`;
        }

        if (is_frac === 2 && !isNaN(s3)) {
          if (n3 < 0) {
            result.error = "Numerator and denominator must be positive";
            return result;
          }
          up2 = s3 < 1 ? d3 * s3 - n3 : d3 * s3 + n3;
          input2 = `${s3} ${n3}/${d3}`;
        } else {
          up2 = n3;
          input2 = `${n3}/${d3}`;
        }

        const [fupr, fbtm] = reduce(up1, d2);
        const [fupr1, fbtm1] = reduce(up2, d3);

        const same = fupr === fupr1 && fbtm === fbtm1 ? "yes" : "no";
        const sign = same === "yes" ? "=" : "≠";

        result.tech_same = same;
        result.tech_sign = sign;
        result.tech_input1 = input1;
        result.tech_input2 = input2;
        return result;
      } else {
        result.error = "Please Check Your Input";
        return result;
      }
    }
  }

  /** getCalculationComparingFractionsCalculator
   * POST: /api/calculators-lol/comparing-fractions-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationComparingFractionsCalculator(body) {
    let first = body.tech_first;
    let second = body.tech_second;

    const result = {};

    if (!first || !second) {
      result.error = "Please! Check Your Input.";
      return result;
    }

    function parseValue(value) {
      value = value.trim();
      if (value.includes("%")) {
        const num = parseFloat(value.replace("%", ""));
        if (!isNaN(num)) {
          return num / 100;
        } else {
          return null;
        }
      }

      const fracParts = value.split("/");
      if (fracParts.length === 2) {
        const mixedParts = fracParts[0].trim().split(" ");
        if (mixedParts.length === 2) {
          const [whole, numerator] = mixedParts.map(Number);
          const denominator = parseFloat(fracParts[1]);
          if (!isNaN(whole) && !isNaN(numerator) && !isNaN(denominator)) {
            return (whole * denominator + numerator) / denominator;
          } else {
            return null;
          }
        } else if (mixedParts.length === 1) {
          const numerator = parseFloat(fracParts[0]);
          const denominator = parseFloat(fracParts[1]);
          if (!isNaN(numerator) && !isNaN(denominator)) {
            return numerator / denominator;
          } else {
            return null;
          }
        } else {
          return null;
        }
      } else if (fracParts.length > 2) {
        return null;
      } else {
        const num = parseFloat(value);
        return !isNaN(num) ? num : null;
      }
    }

    const nbr1 = parseValue(first);
    const nbr2 = parseValue(second);

    if (nbr1 === null || nbr2 === null) {
      result.error = "Please Enter Valid Input.";
      return result;
    }

    let sign = "=";
    if (nbr1 > nbr2) sign = ">";
    else if (nbr1 < nbr2) sign = "<";

    result.tech_nbr1 = nbr1;
    result.tech_nbr2 = nbr2;
    result.tech_sign = sign;
    return result;
  }

  /** getCalculationTimetoDecimalCalculator
   * POST: /api/calculators-lol/time-to-decimal-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTimetoDecimalCalculator(body) {
    let hh = body.tech_hh;
    let mm = body.tech_mm;
    let ss = body.tech_ss;

    const result = {};

    if (
      (hh === undefined || hh === "") &&
      (mm === undefined || mm === "") &&
      (ss === undefined || ss === "")
    ) {
      result.error = "Please Check Your Input.";
      return result;
    }

    let hour = 0;
    let min = 0;
    let sec = 0;

    if (!isNaN(hh)) {
      hour = parseFloat(hh);
    }
    if (!isNaN(mm)) {
      min = parseFloat(mm);
    }
    if (!isNaN(ss)) {
      sec = parseFloat(ss);
    }

    let hours = hour + min / 60 + sec / 3600;
    let mins = hour * 60 + min + sec / 60;
    let secs = hour * 3600 + min * 60 + sec;

    result.tech_hour = hour.toString().padStart(2, "0");
    result.tech_min = min.toString().padStart(2, "0");
    result.tech_sec = sec.toString().padStart(2, "0");
    result.tech_hours = hours;
    result.tech_mins = mins;
    result.tech_secs = secs;

    return result;
  }

  /** getCalculationPercenttoDecimalCalculator
   * POST: /api/calculators-lol/percent-to-decimal-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPercenttoDecimalCalculator(body) {
    let per = body.tech_per;

    const result = {};

    if (!isNaN(per)) {
      let ans = parseFloat(per) / 100;
      result.tech_ans = ans;
    } else {
      result.error = "Please! Check Your Input.";
    }

    return result;
  }

  /** getCalculationDecimaltoPercentCalculator
   * POST: /api/calculators-lol/decimal-to-percent-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDecimaltoPercentCalculator(body) {
    let per = body.tech_per;

    const result = {};

    if (!isNaN(per)) {
      let ans = parseFloat(per) * 100;
      result.tech_ans = ans;
    } else {
      result.error = "Please! Check Your Input.";
    }

    return result;
  }

  /** getCalculationIntegerCalculator
   * POST: /api/calculators-lol/integer-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationIntegerCalculator(body) {
    let opr = body.tech_opr;
    let a = parseFloat(body.tech_a);
    let b = parseFloat(body.tech_b);

    const result = {};

    if (!isNaN(a) && !isNaN(b)) {
      let ansText = "";
      let ans = "";

      switch (parseInt(opr)) {
        case 1:
          ansText = "a + b = ?";
          ans = `${a} + ${b} = ${a + b}`;
          break;
        case 2:
          ansText = "a - b = ?";
          ans = `${a} - ${b} = ${a - b}`;
          break;
        case 3:
          ansText = "a x b = ?";
          ans = `${a} x ${b} = ${a * b}`;
          break;
        case 4:
          ansText = "a ÷ b = ?";
          ans = `${a} ÷ ${b} = ${b !== 0 ? (a / b).toFixed(5) : "Infinity"}`;
          break;
        case 5:
          ansText = `a<sup class="font-s-14">b</sup> = ?`;
          ans = `${a}<sup class="font-s-14">${b}</sup> = ${Math.pow(a, b)}`;
          break;
        case 6:
          ansText = `<sup class="font-s-14">${b}</sup>√a = ?`;
          ans = `<sup class="font-s-14">${b}</sup>√${a} = ${Math.pow(
            a,
            1 / b
          ).toFixed(5)}`;
          break;
        case 7:
          ansText = `log<sub class="font-s-14">${a}</sub>${b} = ?`;
          ans = `log<sub class="font-s-14">${a}</sub>${b} = ${
            Math.log(b) / Math.log(a)
          }`;
          break;
        default:
          result.error = "Invalid operation";
          return result;
      }

      result.tech_ansText = ansText;
      result.tech_ans = ans;
    } else {
      result.error = "Please! Check Your Input.";
    }

    return result;
  }

  /** getCalculationMultiplicativeInverseCalculator
   * POST: /api/calculators-lol/multiplicative-inverse-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMultiplicativeInverseCalculator(body) {
    let dec = body.tech_dec;
    let is_frac = parseInt(body.tech_is_frac);
    let s1 = parseFloat(body.tech_s1);
    let n1 = parseFloat(body.tech_n1);
    let d1 = parseFloat(body.tech_d1);

    let result = {};
    let check = true;
    let upr, btm;

    if (is_frac === 1) {
      if (!isNaN(dec)) {
        upr = parseFloat(dec);
        btm = 1;
      } else {
        check = false;
      }
    } else if (is_frac === 2) {
      if (!isNaN(n1) && !isNaN(d1)) {
        upr = n1;
        btm = d1;
      } else {
        check = false;
      }
    } else {
      if (!isNaN(s1) && !isNaN(n1) && !isNaN(d1)) {
        if (n1 < 0) {
          result.error = "Numerator and denominator must be positive.";
          return result;
        }
        upr = s1 < 1 ? d1 * s1 - n1 : d1 * s1 + n1;
        btm = d1;
      } else {
        check = false;
      }
    }

    if (check) {
      result.tech_ans = parseFloat((btm / upr).toFixed(8));
      result.tech_upr = upr;
      result.tech_btm = btm;
    } else {
      result.error = "Please Enter Valid Input.";
    }

    return result;
  }

  /** getCalculationInverseModuloCalculator
   * POST: /api/calculators-lol/inverse-modulo-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationInverseModuloCalculator(body) {
    let opr = body.tech_opr;
    let a = body.tech_a;
    let b = body.tech_b;

    a = Number(a);
    b = Number(b);
    opr = Number(opr);

    function xgcd(a, b) {
      let a1 = 1,
        b1 = 0,
        a2 = 0,
        b2 = 1;
      let aneg = 1,
        bneg = 1;
      let flag = false;
      let result = [];

      if (a < 0) {
        a = -a;
        aneg = -1;
      }
      if (b < 0) {
        b = -b;
        bneg = -1;
      }
      if (b > a) {
        [a, b] = [b, a];
        flag = true;
      }

      while (true) {
        let quot = Math.floor(a / b) * -1;
        a %= b;
        a1 += quot * a2;
        b1 += quot * b2;

        if (a === 0 && !flag) return [b * bneg, a2, b2];
        if (a === 0 && flag) return [b * bneg, b2, a2];

        quot = Math.floor(b / a) * -1;
        b %= a;
        a2 += quot * a1;
        b2 += quot * b1;

        if (b === 0 && !flag) return [a * aneg, a1, b1];
        if (b === 0 && flag) return [a * aneg, b1, a1];
      }
    }

    if (isFinite(a) && isFinite(b)) {
      let m = b;
      let res;

      if (opr === 1) {
        let [gcd, inv] = xgcd(a, m);
        if (Math.abs(gcd) === 1) {
          while (inv < 0) inv += m;
          res = inv;
        } else {
          res = "no";
        }
      } else if (opr === 2) {
        let res1 = -a,
          res2 = -a;
        while ((res1 < 0 || res1 >= m) && (res2 < 0 || res2 >= m)) {
          res1 += m;
          res2 -= m;
        }
        res = res1 >= 0 && res1 < m ? res1 : res2;
      }

      return {
        tech_res: res,
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }
  }

  /** getCalculationSolveforxCalculator
   * POST: /api/calculators-lol/combine-like-terms-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCombiningLikeTermsCalculator(body) {
    let input = body.tech_input;

    if (!input) {
      return { error: "Please Check Your Input" };
    }

    let parem = input
      .replace(/ /g, "")
      .replace(/x=/g, "")
      .replace(/y=/g, "")
      .replace(/−/g, "-")
      .replace(/plus/g, "+")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    try {
      const response = await axios.post(
        "http://167.172.134.148/combine",
        new URLSearchParams({ equ: parem }),
        { timeout: 120000 }
      );

      const [enter, inputLatex, answer] = response.data;

      let like = inputLatex
        .replace(/\\left\(/g, "")
        .replace(/\\right\)/g, "")
        .replace(/ /g, "")
        .replace(/\\/g, "");
      let likes = like.split(",");

      let combine = {};
      likes.forEach((val) => {
        let lowerVal = val.toLowerCase();
        let matched = false;
        for (let ch = 97; ch <= 122; ch++) {
          let key = String.fromCharCode(ch);
          if (lowerVal.includes(key)) {
            combine[key] = combine[key] || [];
            combine[key].push(val);
            matched = true;
            break;
          }
        }
        if (!matched) {
          combine["zcon"] = combine["zcon"] || [];
          combine["zcon"].push(val);
        }
      });

      let powera = {};
      for (let key in combine) {
        combine[key].forEach((val) => {
          if (key !== "zcon") {
            let parts = val.split(`${key}^{`);
            if (parts.length === 2) {
              let base = parts[0].trim() || "1";
              let exponent = parts[1].replace("}", "").trim();
              powera[`${key}^{${exponent}}`] =
                powera[`${key}^{${exponent}}`] || [];
              powera[`${key}^{${exponent}}`].push(base);
            } else {
              let base = val.replace(new RegExp(key, "g"), "").trim() || "1";
              powera[key] = powera[key] || [];
              powera[key].push(base);
            }
          } else {
            powera["zcon"] = powera["zcon"] || [];
            powera["zcon"].push(val.trim());
          }
        });
      }

      let steps = [];
      let final = [];
      let finals = [];
      let ans = "";
      let i = 0;
      let j = 0;

      const sortedKeys = Object.keys(powera).sort();
      for (let key of sortedKeys) {
        let values = powera[key];
        if (!values) continue;

        let step = "";
        let plus =
          values.reduce((sum, val) => sum + Number(val), 0) > 0 ? " + " : "";

        if (key !== "zcon") {
          finals.push(
            plus +
              (values.length > 1 || values[0] !== "1"
                ? values.reduce((sum, val) => sum + Number(val), 0)
                : "") +
              key
          );
        } else {
          finals.push(plus + values.reduce((sum, val) => sum + Number(val), 0));
        }

        if (values.length > 1) step = "Combining like terms ";
        values.forEach((val, idx) => {
          if (values.length > 1) {
            step +=
              idx === 0
                ? `\\( ${val !== "1" ? val : ""}${key} \\)`
                : ` and \\( ${val !== "1" ? val : ""}${key} \\)`;
          }

          i++;
          let sign = Number(val) >= 0 && i > 1 ? " + " : i === 1 ? "" : " ";
          let term =
            val === "1" && key !== "zcon"
              ? key
              : `${val}${key !== "zcon" ? key : ""}`;
          ans += `${sign}${term}`;
          final[j] = (final[j] || "") + `${sign}${term}`;
        });

        steps.push(values.length > 1 ? step : "");
        j++;
      }

      return {
        tech_enter: enter,
        tech_input: inputLatex,
        tech_answer: answer,
        tech_powera: powera,
        tech_steps: steps,
        tech_final: final,
        tech_finals: finals,
        tech_ans: ans,
      };
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationSolveforxCalculator
   * POST: /api/calculators-lol/solve-for-x-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationSolveforxCalculator(body) {
    let input = body.tech_input;
    let is_equal = body.tech_is_equal;

    if (!input || isNaN(is_equal)) {
      return { error: "Please Enter Valid Input." };
    }

    if (!/x/i.test(input)) {
      return { error: "x is not in the Equestion." };
    }

    let parem = input
      .replace(/ /g, "")
      .replace(/−/g, "-")
      .replace(/plus/g, "+")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    parem += `-(${is_equal})`;

    try {
      const response = await axios.post(
        "http://167.172.134.148/solve-x",
        new URLSearchParams({ equ: parem }),
        { timeout: 120000 }
      );

      let buffer = response.data;
      let ans = buffer[0];

      return {
        tech_ans: ans,
      };
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationInequalityCalculator
   * POST: /api/calculators-lol/inequality-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationInequalityCalculator(body) {
    let select = body.tech_select;
    let equ1 = body.tech_equ1;
    let con = body.tech_con;
    let equ2 = body.tech_equ2;

    let vari = "x";

    if (!equ1) {
      return { error: "Equation 1 is required." };
    }

    equ1 = equ1.replace(/ /g, "");
    let greater_than_equal_count = (equ1.match(/>=/g) || []).length;
    let less_than_equal_count = (equ1.match(/<=/g) || []).length;
    let less_than_count =
      (equ1.match(/</g) || []).length - less_than_equal_count;
    let greater_than_count =
      (equ1.match(/>/g) || []).length - greater_than_equal_count;
    let equal_count =
      (equ1.match(/=/g) || []).length -
      greater_than_equal_count -
      less_than_equal_count;
    let all_count =
      greater_than_equal_count +
      less_than_equal_count +
      less_than_count +
      greater_than_count +
      equal_count;

    if (all_count > 1) {
      return { error: "Equation has more than one symbol." };
    }

    if (equ1.includes(">=")) equ1 = equ1.replace(">=", "gtae");
    else if (equ1.includes("<=")) equ1 = equ1.replace("<=", "ltae");
    else if (equ1.includes("<")) equ1 = equ1.replace("<", "less");
    else if (equ1.includes(">")) equ1 = equ1.replace(">", "greater");
    else if (equ1.includes("=")) equ1 = equ1.replace("=", "equal");

    let parem = equ1
      .replace(/−/g, "-")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    let form_params = {
      select,
      vari,
      equ: parem,
    };

    if (select === "1") {
      if (!equ2) {
        return { error: "Please! Check Your Input." };
      }

      equ2 = equ2.replace(/ /g, "");
      greater_than_equal_count = (equ2.match(/>=/g) || []).length;
      less_than_equal_count = (equ2.match(/<=/g) || []).length;
      less_than_count = (equ2.match(/</g) || []).length - less_than_equal_count;
      greater_than_count =
        (equ2.match(/>/g) || []).length - greater_than_equal_count;
      equal_count =
        (equ2.match(/=/g) || []).length -
        greater_than_equal_count -
        less_than_equal_count;
      all_count =
        greater_than_equal_count +
        less_than_equal_count +
        less_than_count +
        greater_than_count +
        equal_count;

      if (all_count > 1) {
        return { error: "Second Equation has more than one symbol." };
      }

      if (equ2.includes(">=")) equ2 = equ2.replace(">=", "gtae");
      else if (equ2.includes("<=")) equ2 = equ2.replace("<=", "ltae");
      else if (equ2.includes("<")) equ2 = equ2.replace("<", "less");
      else if (equ2.includes(">")) equ2 = equ2.replace(">", "greater");
      else if (equ2.includes("=")) equ2 = equ2.replace("=", "equal");

      let parem2 = equ2
        .replace(/−/g, "-")
        .replace(/\+/g, "plus")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**")
        .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

      form_params["equ1"] = parem2;
    }

    try {
      const response = await axios.post(
        "http://167.172.134.148/compound",
        new URLSearchParams(form_params),
        {
          timeout: 120000,
        }
      );

      let buffer = response.data;

      let result = {
        tech_solution_inequality: buffer.latex_solution_eq,
        tech_steps: buffer.steps,
      };

      if (buffer.latex_solution_eq_sec) {
        result.tech_latex_solution_eq_sec = buffer.latex_solution_eq_sec;
      }

      if (buffer.steps_sec) {
        result.tech_steps_sec = buffer.steps_sec;
      }

      return result;
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationMultiplyingPolynomialsCalculator
   * POST: /api/calculators-lol/multiplying-polynomials-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMultiplyingPolynomialsCalculator(body) {
    let first = body.tech_first;
    let second = body.tech_second;

    if (first && second) {
      let parem = first
        .replace(/ /g, "")
        .replace(/−/g, "-")
        .replace(/plus/g, "+")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**");

      let parem1 = second
        .replace(/ /g, "")
        .replace(/−/g, "-")
        .replace(/plus/g, "+")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**");

      try {
        const response = await axios.post(
          "http://167.172.134.148/multiplying",
          new URLSearchParams({
            equ: parem,
            equ1: parem1,
          }),
          { timeout: 120000 }
        );

        let buffer = response.data;
        let input1 = buffer[0];
        let input2 = buffer[1];
        let ans = buffer[2];
        let left = buffer[3];
        let right = buffer[4];
        let nextstep = buffer[5];

        nextstep = nextstep
          .replace(/\\left\[/g, "")
          .replace(/\\right\]/g, "")
          .replace(/ /g, "")
          .replace(/\\/g, "")
          .replace(/frac/g, "\\dfrac")
          .replace(/sqrt/g, "\\sqrt")
          .split(",");

        let lefts = left
          .replace(/\\left\(/g, "")
          .replace(/\\right\)/g, "")
          .replace(/ /g, "")
          .replace(/\\/g, "")
          .replace(/frac/g, "\\dfrac")
          .replace(/sqrt/g, "\\sqrt")
          .split(",");

        let rights = right
          .replace(/\\left\(/g, "")
          .replace(/\\right\)/g, "")
          .replace(/ /g, "")
          .replace(/\\/g, "")
          .replace(/frac/g, "\\dfrac")
          .replace(/sqrt/g, "\\sqrt")
          .split(",");

        let step = "";
        let next = "";

        for (let value of lefts) {
          for (let value1 of rights) {
            step += step
              ? ` + (${value}) \\times (${value1})`
              : `(${value}) \\times (${value1})`;
          }
        }

        for (let value of nextstep) {
          next += next ? ` + ( ${value} )` : `( ${value} )`;
        }

        return {
          tech_input1: input1,
          tech_input2: input2,
          tech_step: step,
          tech_next: next,
          tech_ans: ans,
        };
      } catch (error) {
        return {
          error: "Please! Check Your Input.",
        };
      }
    } else {
      return {
        error: "2 values should not be same.",
      };
    }
  }

  /** getCalculationEquationLineCalculatorCalculator
   * POST: /api/calculators-lol/equation-of-a-line-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationEquationLineCalculatorCalculator(body) {
    let type = body.tech_type;
    let x1 = body.tech_x1;
    let x2 = body.tech_x2;
    let y1 = body.tech_y1;
    let y2 = body.tech_y2;
    let x3 = body.tech_x3;
    let y3 = body.tech_y3;

    let result = {};

    if (type === "2") {
      if (!isNaN(x1) && !isNaN(x2) && !isNaN(y1) && !isNaN(y2)) {
        let x = x2 - x1;
        let y = y2 - y1;
        let slope = +(y / x).toFixed(4);
        let angle = +(Math.atan(slope) * (180 / Math.PI)).toFixed(4);
        let distance = +Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)).toFixed(4);
        let b = +(y1 - slope * x1).toFixed(2);

        result = {
          tech_type: type,
          tech_x: x,
          tech_y: y,
          tech_b: b,
          tech_slope: slope,
          tech_angle: `${angle} deg`,
          tech_distance: distance,
        };
      } else {
        return { error: "Please Check Your Input." };
      }
    } else if (type === "1") {
      let slope = x2;
      if (!isNaN(x1) && !isNaN(y1) && !isNaN(slope)) {
        let angle = +(Math.atan(slope) * (180 / Math.PI)).toFixed(4);
        let b = +(y1 - slope * x1).toFixed(4);

        result = {
          tech_type: type,
          tech_b: b,
          tech_slope: slope,
          tech_angle: `${angle} deg`,
        };
      } else {
        return { error: "Please Check Your Input." };
      }
    } else if (type === "3") {
      let b = x1;
      let slope = x2;
      if (!isNaN(b) && !isNaN(slope)) {
        let angle = +(Math.atan(slope) * (180 / Math.PI)).toFixed(4);

        result = {
          tech_type: type,
          tech_b: b,
          tech_slope: slope,
          tech_angle: `${angle} deg`,
        };
      } else {
        return { error: "Please Check Your Input." };
      }
    } else if (type === "4") {
      if (
        !isNaN(x1) &&
        !isNaN(x2) &&
        !isNaN(y1) &&
        !isNaN(y2) &&
        !isNaN(x3) &&
        !isNaN(y3)
      ) {
        let f_down = y1 - x1;
        let s_down = y2 - x2;
        let t_down = y3 - x3;

        result = {
          tech_type: type,
          tech_f_down: f_down,
          tech_s_down: s_down,
          tech_t_down: t_down,
        };
      } else {
        return { error: "Please Check Your Input." };
      }
    }

    return result;
  }

  /** getCalculationFractionExponentCalculator
   * POST: /api/calculators-lol/fraction-exponent-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationFractionExponentCalculator(body) {
    let x = body.tech_x;
    let n = body.tech_n;
    let d = body.tech_d;

    let result = {};

    if (!isNaN(x) && !isNaN(n) && !isNaN(d)) {
      if (d != 0) {
        if (Number.isInteger(n)) {
          let all_roots = [];
          let answer, a, ans_f;

          if (x >= 0) {
            a = Math.pow(x, n);
            ans_f = n / d;
            answer = Math.pow(x, ans_f);

            let z = x;
            let r_f = Math.pow(x, 2);
            let r = Math.sqrt(r_f);
            let theta = 0;
            let power = 1 / d;
            let r_pow = Math.pow(r, power);

            if (d < 0) d = -1 * d;

            for (let i = 0; i < d; i++) {
              let f_step = 2 * 180 * i;
              let uper_fstep = theta + f_step;
              let f_ans2 = uper_fstep / d;
              let cos_fans2 = Math.cos(f_ans2 * (Math.PI / 180));
              let sin_fans2 = Math.sin(f_ans2 * (Math.PI / 180));
              let cos_fans = +(r_pow * cos_fans2).toFixed(6);
              let sin_fans = +(r_pow * sin_fans2).toFixed(6);
              if (sin_fans < 0) {
                sin_fans = -sin_fans;
                all_roots.push(`${cos_fans}-${sin_fans}i`);
              } else {
                all_roots.push(`${cos_fans}+${sin_fans}i`);
              }
            }
          } else {
            x = -1 * x;
            a = Math.pow(x, n);
            ans_f = n / d;
            answer = Math.pow(x, ans_f) + "i";

            let z = x;
            let r_f = Math.pow(x, 2);
            let r = Math.sqrt(r_f);
            let theta = 0;
            let power = 1 / d;
            let r_pow = Math.pow(r, power);

            for (let i = 0; i < d; i++) {
              let f_step = 2 * 180 * i;
              let uper_fstep = theta + f_step;
              let f_ans2 = uper_fstep / d;
              let cos_fans2 = Math.cos(f_ans2 * (Math.PI / 180));
              let sin_fans2 = Math.sin(f_ans2 * (Math.PI / 180));
              let cos_fans = +(r_pow * cos_fans2).toFixed(6);
              let sin_fans = +(r_pow * sin_fans2).toFixed(6);
              if (sin_fans < 0) {
                sin_fans = -sin_fans;
                all_roots.push(`${cos_fans}-${sin_fans}i`);
              } else {
                all_roots.push(`${cos_fans}+${sin_fans}i`);
              }
            }
          }

          result = {
            tech_all_roots: all_roots,
            tech_a: a,
            tech_ans_f: ans_f,
            tech_answer: answer,
          };
        } else {
          return { error: "Use only integers for the Numerator." };
        }
      } else {
        return { error: "Enter a non-zero Denominator." };
      }
    } else {
      return { error: "Please! Check Your Input." };
    }

    return result;
  }

  /**
   * getCalculationEllipseEquationCalculator: Service Method
   * POST: /api/calculators-lol/ellipse-equation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationEllipseEquationCalculator(body) {
    const d1 = body.tech_d1;
    const n2 = body.tech_n2;
    const second_value = body.tech_second_value;
    const c1 = body.tech_c1;
    const c2 = body.tech_c2;
    const selection = body.tech_selection;
    const param = {};

    // Helper function to calculate GCD
    function gcd(a23, b23) {
      a23 = Math.abs(a23);
      b23 = Math.abs(b23);

      if (a23 < b23) {
        [b23, a23] = [a23, b23];
      }
      if (b23 == 0) {
        return 1;
      }
      let r = a23 % b23;
      while (r > 0) {
        const a = b23;
        b23 = r;
        r = a % b23;
      }
      return b23;
    }

    // Helper function to reduce fraction
    function reduce(num23, den23) {
      const g = gcd(num23, den23);
      return [num23 / g, den23 / g];
    }

    if (selection == "1") {
      if (
        !isNaN(d1) &&
        d1 != null &&
        d1 != "" &&
        !isNaN(n2) &&
        n2 != null &&
        n2 != "" &&
        !isNaN(second_value) &&
        second_value !== null &&
        second_value !== "" &&
        d1 > 0 &&
        n2 > 0 &&
        second_value > 0
      ) {
        if (!isNaN(n2) && !isNaN(d1)) {
          const totalN = n2;
          const totalD = d1;
          const g = gcd(totalN, totalD);
          const [upr, btm] = reduce(totalN, totalD);

          // Return Values
          param.tech_upr = upr;
          param.tech_totalN = totalN;
          param.tech_totalD = totalD;
          param.tech_g = g;
          param.tech_btm = btm;
          param.tech_method = selection;
        }

        if (!isNaN(n2) && !isNaN(second_value)) {
          const totalN1 = n2;
          const totalD1 = second_value;
          const g1 = gcd(totalN1, totalD1);
          const [upr1, btm1] = reduce(totalN1, totalD1);

          // Return Values
          param.tech_upr1 = upr1;
          param.tech_totalN1 = totalN1;
          param.tech_totalD1 = totalD1;
          param.tech_g1 = g1;
          param.tech_btm1 = btm1;
          param.tech_method = selection;
          return param;
        }
      } else {
        param.error = "Please! Check Your Input.";
        return param;
      }
    } else if (selection == "2") {
      if (
        !isNaN(c1) &&
        c1 != null &&
        c1 != "" &&
        !isNaN(c2) &&
        c2 != null &&
        c2 != "" &&
        !isNaN(d1) &&
        d1 != null &&
        d1 != "" &&
        !isNaN(second_value) &&
        second_value != null &&
        second_value != "" &&
        d1 > 0 &&
        second_value > 0
      ) {
        let calculate_eccentricity;
        if (d1 > second_value) {
          calculate_eccentricity =
            Math.sqrt(d1 * d1 - second_value * second_value) / d1;
        } else if (second_value > d1) {
          calculate_eccentricity =
            Math.sqrt(second_value * second_value - d1 * d1) / second_value;
        }

        const area = 3.14 * d1 * second_value;

        param.tech_d1 = d1;
        param.tech_c2 = second_value;
        param.tech_center1 = c1;
        param.tech_center2 = c2;
        param.tech_calculate_eccentricity = calculate_eccentricity;
        param.tech_area = area;
        param.tech_method = selection;
        return param;
      } else {
        param.error = "Please! Check Your Input.";
        return param;
      }
    }
  }

  /**
   * getCalculationRrefCalculator: Service Method
   * POST: /api/calculators-lol/rref-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationRrefCalculator(body) {
    const matrix2 = parseInt(body.matrix2);
    const matrix22 = parseInt(body.matrix22);
    const second_matrix = [];

    // Extract matrix data
    for (let i = 1; i <= matrix2; i++) {
      for (let j = 1; j <= matrix22; j++) {
        const key = `matrix3${i}_${j}`;
        if (body[key] !== undefined && !isNaN(parseFloat(body[key]))) {
          second_matrix.push(parseFloat(body[key]));
        }
      }
    }

    // Helper functions
    const gcd22 = (a, b, f) => {
      if (f) {
        if (b <= 1) return a;
      } else {
        if (!b) return a;
      }
      return gcd22(b, a % b, f);
    };

    const roundresult2 = (x) => {
      const y = parseFloat(x);
      return roundnum2(y, 10);
    };

    const toPrecision2 = (number, precision) => {
      if (number == 0) return 0;
      const exponent = Math.floor(Math.log10(Math.abs(number)) + 1);
      const significand =
        Math.round(
          (number / Math.pow(10, exponent)) * Math.pow(10, precision)
        ) / Math.pow(10, precision);
      return significand * Math.pow(10, exponent);
    };

    const roundnum2 = (x, p) => {
      const n = parseFloat(x);
      const m = toPrecision2(n, p + 1);
      const y = m.toString();
      return y;
    };

    const digits_after_period2 = (x) => {
      const f = x.toString();
      const i = f.indexOf(".");
      if (i === -1) return 0;
      return f.length - i - 1;
    };

    const convert2 = (xelem) => {
      let sign = "";
      let sign2 = "+";
      let f = false;
      const x = xelem;
      const x2 = roundresult2(x);
      const absx = Math.abs(x2);
      const y = Math.floor(absx);
      const frac = absx - y;

      if (x2 < 0) {
        sign = sign2 = "-";
      }

      const d = digits_after_period2(absx);
      const den = Math.round(Math.pow(10, d));
      const num = Math.round(frac * den);
      const a12 = num.toString();
      const len = a12.length;

      if (len > 8) f = true;

      const g = gcd22(num, den, f);
      const num2 = Math.round(num / g);
      const den2 = Math.round(den / g);

      const top_jawab = sign + (num2 + den2 * y);
      const down_jawab = den2;

      return [top_jawab, down_jawab];
    };

    // Function to remove ONLY negative zeros but preserve other negative values
    const cleanMatrixValues = (matrix) => {
      return matrix.map((row) =>
        row.map((val) => {
          // Check if it's a negative zero (either -0 or very close to 0 but negative)
          if (Math.abs(val) < 1e-10 && val < 0) {
            return 0;
          }
          // For very small positive numbers that might be floating point errors
          if (Math.abs(val) < 1e-10 && val >= 0) {
            return 0;
          }
          return val;
        })
      );
    };

    const rref2 = (matrix) => {
      let lead = 0;
      let pz = matrix.map((row) => [...row]); // Create a deep copy
      const swap = [];
      const swap_line = [];
      const rowCount = matrix.length;

      if (rowCount == 0) return [matrix, swap, swap_line, pz];

      let columnCount = 0;
      if (matrix[0]) {
        columnCount = matrix[0].length;
      }

      for (let r = 0; r < rowCount; r++) {
        if (lead >= columnCount) break;

        // Find pivot row
        let i = r;
        while (Math.abs(matrix[i][lead]) < 1e-10) {
          // Use tolerance for zero check
          i++;
          if (i == rowCount) {
            i = r;
            lead++;
            if (lead == columnCount) {
              const finalMatrix = cleanMatrixValues(matrix);
              const finalPz = cleanMatrixValues(pz);
              return [finalMatrix, swap, swap_line, finalPz];
            }
          }
        }

        // Swap rows if needed
        if (i != r) {
          [matrix[r], matrix[i]] = [matrix[i], matrix[r]];
          [pz[r], pz[i]] = [pz[i], pz[r]];

          if (Math.abs(matrix[i][lead]) < 1e-10) {
            swap_line.push(`Swap the row ${r + 1} with row ${i + 1}`);
            swap.push(cleanMatrixValues(pz.map((row) => [...row])));
          }
        }

        // Normalize pivot row
        const lv = matrix[r][lead];
        if (Math.abs(lv) > 1e-10) {
          for (let j = 0; j < columnCount; j++) {
            matrix[r][j] = matrix[r][j] / lv;
            pz[r][j] = pz[r][j] / lv;
          }

          const test1 = convert2(lv);
          if (test1[1] == 1) {
            swap_line.push(
              `Divide row ${r + 1} by ${lv}: R<sub>${r + 1}</sub> = R<sub>${
                r + 1
              }</sub>/${lv}`
            );
          } else {
            const lv3 = `${test1[1]}/${test1[0]}`;
            swap_line.push(
              `Multiply row ${r + 1} by ${lv3}: R<sub>${
                r + 1
              }</sub> = ${lv3} R<sub>${r + 1}</sub>`
            );
          }
          swap.push(cleanMatrixValues(pz.map((row) => [...row])));
        }

        // Eliminate other rows
        for (let i = 0; i < rowCount; i++) {
          if (i != r && Math.abs(matrix[i][lead]) > 1e-10) {
            const lv = matrix[i][lead];
            const lv2 = pz[i][lead];

            for (let j = 0; j < columnCount; j++) {
              matrix[i][j] -= lv * matrix[r][j];
              pz[i][j] -= lv2 * pz[r][j];
            }

            // Clean only negative zeros after each operation
            matrix[i] = matrix[i].map((val) => {
              if (Math.abs(val) < 1e-10 && val < 0) return 0;
              if (Math.abs(val) < 1e-10 && val >= 0) return 0;
              return val;
            });
            pz[i] = pz[i].map((val) => {
              if (Math.abs(val) < 1e-10 && val < 0) return 0;
              if (Math.abs(val) < 1e-10 && val >= 0) return 0;
              return val;
            });

            swap.push(cleanMatrixValues(pz.map((row) => [...row])));
            const test = convert2(lv);
            let displayLv = lv;
            if (test[1] != 1) {
              displayLv = `${test[0]}/${test[1]}`;
            }
            swap_line.push(
              `Subtract row ${i} multiplied by ${displayLv} from row R${
                i + 1
              }: R<sub>${i + 1}</sub> = R<sub>${
                i + 1
              }</sub> - ${displayLv}R<sub>${i}</sub>`
            );
          }
        }

        lead++;
      }

      // Final cleanup of ONLY negative zeros
      const finalMatrix = cleanMatrixValues(matrix);
      const finalPz = cleanMatrixValues(pz);

      return [finalMatrix, swap, swap_line, finalPz];
    };

    // Main logic
    const mul = matrix22 * matrix2;
    let result = {};

    if (mul == second_matrix.length) {
      // Convert flat array to 2D matrix
      const zain = [];
      for (let i = 0; i < matrix2; i++) {
        const row = second_matrix.slice(i * matrix22, (i + 1) * matrix22);
        zain.push(row);
      }

      const fahad2 = rref2(zain);
      result.tech_matrix = fahad2[0];
      result.tech_swap = fahad2[1];
      result.tech_swap_line = fahad2[2];
    } else {
      result.error = "Please! Check Your Input.";
    }

    return result;
  }

  /** getCalculationAmplitudeAndPeriodCalculator
   * POST: /api/calculators-lol/amplitude-and-period-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAmplitudeAndPeriodCalculator(body) {
    let trigonometric_unit = body.tech_trigonometric_unit;
    let first_number = body.tech_first_number;
    let second_number = body.tech_second_number;
    let third_number = body.tech_third_number;
    let fourth_number = body.tech_fourth_number;

    let result = {};

    if (
      !isNaN(first_number) &&
      !isNaN(second_number) &&
      !isNaN(third_number) &&
      !isNaN(fourth_number)
    ) {
      if (first_number == 0) {
        return { error: "For A=0, this is not a trigonometric function!" };
      } else if (second_number == 0) {
        return { error: "For B=0, this is not a trigonometric function!" };
      } else {
        result.first_number = first_number;
        result.second_number = 2 / second_number;
        result.third_number = third_number / second_number;
        result.fourth_number = fourth_number;
        result.fifth_number = second_number;
        result.sixth_number = third_number;
        result.operation = trigonometric_unit;
        return result;
      }
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationExponentialGrowthCalculator
   * POST: /api/calculators-lol/exponential-growth-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationExponentialGrowthCalculator(body) {
    let operations = body.tech_operations;
    let first = body.tech_first;
    let second = body.tech_second;
    let third = body.tech_third;
    let four = body.tech_four;
    let t_unit = body.tech_t_unit;

    let result = {};

    function timer(unit, value) {
      switch (unit) {
        case "sec":
          return value / 31540000;
        case "min":
          return value / 525600;
        case "hr":
          return value / 8760;
        case "days":
          return value / 365;
        case "wks":
          return value / 52.143;
        case "mon":
          return value / 12;
        default:
          return value;
      }
    }

    third = timer(t_unit, third);
    let final, jawab;

    if (operations === "1") {
      if (!isNaN(second) && !isNaN(third) && !isNaN(four)) {
        let divide = second / 100;
        let plus = 1 + divide;
        let power = Math.pow(plus, third);
        final = four / power;
        final = final.toFixed(4);
        jawab = "Initial Value (x₀)";
      } else {
        return { error: "Please! Check Your Input." };
      }
    } else if (operations === "2") {
      if (!isNaN(first) && !isNaN(third) && !isNaN(four)) {
        let divide1 = four / first;
        let log_div1 = Math.log(divide1);
        let divide2 = log_div1 / third;
        let antilog = Math.exp(divide2);
        let minus = antilog - 1;
        final = minus * 100;
        final = final.toFixed(4);
        jawab = "Rate of Change (r)";
      } else {
        return { error: "Please! Check Your Input." };
      }
    } else if (operations === "3") {
      if (!isNaN(first) && !isNaN(second) && !isNaN(four)) {
        let divide = four / first;
        let divide2 = second / 100;
        let plus = 1 + divide2;
        let log1 = Math.log(plus);
        let log2 = Math.log(divide);
        final = log2 / log1;
        final = final.toFixed(4);
        jawab = "Elapsed Time (t)";
      } else {
        return { error: "Please! Check Your Input." };
      }
    } else if (operations === "4") {
      if (!isNaN(first) && !isNaN(second) && !isNaN(third)) {
        let divide = second / 100;
        let plus = 1 + divide;
        let power = Math.pow(plus, third);
        final = first * power;
        final = final.toFixed(4);
        jawab = "Final Value x(t)";
      } else {
        return { error: "Please! Check Your Input." };
      }
    }

    result.final = final;
    result.operations = operations;
    result.jawab = jawab;
    return result;
  }

  /** getCalculationPerfectSquareTrinomialCalculator
   * POST: /api/calculators-lol/perfect-square-trinomial-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPerfectSquareTrinomialCalculator(body) {
    let A = body.tech_A;
    let B = body.tech_B;
    let C = body.tech_C;

    let result = {};

    if (!isNaN(A) && !isNaN(B) && !isNaN(C)) {
      let ds = Math.pow(B, 2) - 4 * A * C;
      result.tech_sd = ds;
      return result;
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /**
   * getCalculationGematriaCalculator: Service Method
   * POST: /api/calculators-lol/gematria-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationGematriaCalculator(body) {
    const input = body.tech_input;
    const param = {};

    // Gematria mapping arrays
    const English_Ordinal = {
      a: 1,
      b: 2,
      c: 3,
      d: 4,
      e: 5,
      f: 6,
      g: 7,
      h: 8,
      i: 9,
      j: 10,
      k: 11,
      l: 12,
      m: 13,
      n: 14,
      o: 15,
      p: 16,
      q: 17,
      r: 18,
      s: 19,
      t: 20,
      u: 21,
      v: 22,
      w: 23,
      x: 24,
      y: 25,
      z: 26,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
    };

    const Full_Reduction = {
      a: 1,
      b: 2,
      c: 3,
      d: 4,
      e: 5,
      f: 6,
      g: 7,
      h: 8,
      i: 9,
      j: 1,
      k: 2,
      l: 3,
      m: 4,
      n: 5,
      o: 6,
      p: 7,
      q: 8,
      r: 9,
      s: 1,
      t: 2,
      u: 3,
      v: 4,
      w: 5,
      x: 6,
      y: 7,
      z: 8,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
    };

    const Reverse_Ordinal = {
      a: 26,
      b: 25,
      c: 24,
      d: 23,
      e: 22,
      f: 21,
      g: 20,
      h: 19,
      i: 18,
      j: 17,
      k: 16,
      l: 15,
      m: 14,
      n: 13,
      o: 12,
      p: 11,
      q: 10,
      r: 9,
      s: 8,
      t: 7,
      u: 6,
      v: 5,
      w: 4,
      x: 3,
      y: 2,
      z: 1,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
    };

    const Reverse_Full_Reduction = {
      a: 8,
      b: 7,
      c: 6,
      d: 5,
      e: 4,
      f: 3,
      g: 2,
      h: 1,
      i: 9,
      j: 8,
      k: 7,
      l: 6,
      m: 5,
      n: 4,
      o: 3,
      p: 2,
      q: 1,
      r: 9,
      s: 8,
      t: 7,
      u: 6,
      v: 5,
      w: 4,
      x: 3,
      y: 2,
      z: 1,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
    };

    const Jewish_Gematria = {
      a: 1,
      b: 2,
      c: 3,
      d: 4,
      e: 5,
      f: 6,
      g: 7,
      h: 8,
      i: 9,
      j: 600,
      k: 10,
      l: 20,
      m: 30,
      n: 40,
      o: 50,
      p: 60,
      q: 70,
      r: 80,
      s: 90,
      t: 100,
      u: 200,
      v: 700,
      w: 900,
      x: 300,
      y: 400,
      z: 500,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
    };

    const English_Gematria = {
      a: 6,
      b: 12,
      c: 18,
      d: 24,
      e: 30,
      f: 36,
      g: 42,
      h: 48,
      i: 54,
      j: 60,
      k: 66,
      l: 72,
      m: 78,
      n: 84,
      o: 90,
      p: 96,
      q: 102,
      r: 108,
      s: 114,
      t: 120,
      u: 126,
      v: 132,
      w: 138,
      x: 144,
      y: 150,
      z: 156,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
    };

    const Hebrew = {
      a: 1,
      b: 2,
      c: 8,
      d: 4,
      e: 5,
      f: 80,
      g: 3,
      h: 5,
      i: 10,
      j: 10,
      k: 20,
      l: 30,
      m: 40,
      n: 50,
      o: 70,
      p: 80,
      q: 100,
      r: 200,
      s: 60,
      t: 9,
      u: 6,
      v: 6,
      w: 6,
      x: 60,
      y: 10,
      z: 7,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
    };

    // Helper functions
    function printDivisors(n) {
      const divi = [];
      for (let i = 1; i <= n; i++) {
        if (n % i == 0) divi.push(i);
      }
      return divi;
    }

    function np(num) {
      let prev = "";
      let next = 0;

      // Find next prime
      let i = num;
      let check_n = 0;
      while (i < 10000000 && check_n != 1) {
        i++;
        let mm = 0;
        for (let j = 2; j <= i / 2; j++) {
          if (i % j == 0) {
            mm++;
            break;
          }
        }
        if (mm == 0) {
          next = i;
          check_n = 1;
        }
      }

      // Find previous prime
      i = num;
      check_n = 0;
      while (i > 2 && check_n !== 1) {
        i--;
        let mm = 0;
        for (let j = 2; j <= i / 2; j++) {
          if (i % j == 0) {
            mm++;
            break;
          }
        }
        if (mm == 0) {
          prev = i;
          check_n = 1;
        }
      }

      return [prev, next];
    }

    function factor(loop_eo) {
      let newtext_eo = "";
      let chk_eo = 2;

      while (chk_eo * chk_eo <= loop_eo) {
        if (loop_eo % chk_eo == 0) {
          newtext_eo += chk_eo;
          loop_eo = loop_eo / chk_eo;
          if (loop_eo !== 1) {
            newtext_eo += " × ";
          }
        } else {
          chk_eo++;
        }
      }

      if (loop_eo != 1) {
        newtext_eo += loop_eo;
      }

      if (newtext_eo == "" + loop_eo) {
        newtext_eo = "1 × " + newtext_eo;
      }

      return newtext_eo;
    }

    function total(num) {
      let totalCount = 0;
      for (let i = 2; i <= num; i++) {
        let mm = 0;
        for (let j = 2; j <= i / 2; j++) {
          if (i % j == 0) {
            mm++;
            break;
          }
        }
        if (mm == 0) {
          totalCount++;
        }
      }
      return totalCount;
    }

    function primeCheck(number) {
      if (number == 1) return 0;
      for (let i = 2; i <= number / 2; i++) {
        if (number % i == 0) return 0;
      }
      return 1;
    }

    // Generate triangular numbers
    const triangular = [];
    for (let i = 2, j = 1; i < 10000; i++) {
      triangular.push(j);
      j += i;
    }

    // Generate prime numbers
    const prime_nums = [];
    for (let i = 0; i < 10000; i++) {
      if (i == 1 || i == 0) continue;
      let f = 1;
      for (let j = 2; j < Math.floor(i / 2) + 1; j++) {
        if (i % j == 0) {
          f = 0;
          break;
        }
      }
      if (f == 1) prime_nums.push(i);
    }

    // Generate Fibonacci sequence
    const arr = [];
    let num1 = 0;
    let num2 = 1;
    let counter = 0;
    while (counter < 1000) {
      arr.push(num1);
      let num3 = num2 + num1;
      num1 = num2;
      num2 = num3;
      counter++;
    }

    if (!input) {
      param.error = "Please! Enter Your Input.";
      return param;
    }

    // Process input
    const small = input.toLowerCase();
    const words1 = small.replace(/[^a-zA-Z0-9]+/g, " ");
    const alphabets = small.replace(/[^a-zA-Z]+/g, "");
    const null_space = small.replace(/\s/g, "");
    const numbers = null_space.replace(/[^0-9]+/g, "");
    const count_wrd = words1.split(" ");
    const words_ans = count_wrd.length;
    const count_ans = alphabets.length;
    const num_agye = numbers.split("").map(Number);
    const sum_num = num_agye.reduce((a, b) => a + b, 0);
    const array_agai = alphabets.split("");
    const nawa = small.split(" ");

    // Process words
    const inner_alpha = [];
    const inner_ans_eo = [];
    const inner_ans_fr = [];
    const inner_ans_ro = [];
    const inner_ans_rfd = [];
    const inner_ans_jg = [];
    const inner_ans_eg = [];
    const inner_ans_h = [];
    const inner_sum_eo = [];
    const inner_sum_fr = [];
    const inner_sum_ro = [];
    const inner_sum_rfd = [];
    const inner_sum_jg = [];
    const inner_sum_eg = [];
    const inner_sum_h = [];

    nawa.forEach((value, i) => {
      const chars = value.trim().split("");
      inner_alpha[i] = chars;
      inner_ans_eo[i] = [];
      inner_ans_fr[i] = [];
      inner_ans_ro[i] = [];
      inner_ans_rfd[i] = [];
      inner_ans_jg[i] = [];
      inner_ans_eg[i] = [];
      inner_ans_h[i] = [];

      chars.forEach((char) => {
        inner_ans_eo[i].push(English_Ordinal[char] || 0);
        inner_ans_fr[i].push(Full_Reduction[char] || 0);
        inner_ans_ro[i].push(Reverse_Ordinal[char] || 0);
        inner_ans_rfd[i].push(Reverse_Full_Reduction[char] || 0);
        inner_ans_jg[i].push(Jewish_Gematria[char] || 0);
        inner_ans_eg[i].push(English_Gematria[char] || 0);
        inner_ans_h[i].push(Hebrew[char] || 0);
      });

      inner_sum_eo.push(inner_ans_eo[i].reduce((a, b) => a + b, 0));
      inner_sum_fr.push(inner_ans_fr[i].reduce((a, b) => a + b, 0));
      inner_sum_ro.push(inner_ans_ro[i].reduce((a, b) => a + b, 0));
      inner_sum_rfd.push(inner_ans_rfd[i].reduce((a, b) => a + b, 0));
      inner_sum_jg.push(inner_ans_jg[i].reduce((a, b) => a + b, 0));
      inner_sum_eg.push(inner_ans_eg[i].reduce((a, b) => a + b, 0));
      inner_sum_h.push(inner_ans_h[i].reduce((a, b) => a + b, 0));
    });

    // Calculate sums for each system
    const sum_eo = array_agai.map((char) => English_Ordinal[char] || 0);
    const sum_fr = array_agai.map((char) => Full_Reduction[char] || 0);
    const sum_ro = array_agai.map((char) => Reverse_Ordinal[char] || 0);
    const sum_rfd = array_agai.map((char) => Reverse_Full_Reduction[char] || 0);
    const sum_jg = array_agai.map((char) => Jewish_Gematria[char] || 0);
    const sum_eg = array_agai.map((char) => English_Gematria[char] || 0);
    const sum_h = array_agai.map((char) => Hebrew[char] || 0);

    let answer_eo,
      answer_fr,
      answer_ro,
      answer_rfd,
      answer_jg,
      answer_eg,
      answer_h;

    if (/\d/.test(input)) {
      answer_eo = sum_num;
      answer_fr = sum_num;
      answer_ro = sum_num;
      answer_rfd = sum_num;
      answer_jg = sum_num;
      answer_eg = sum_num;
      answer_h = sum_num;
    } else if (/[a-zA-Z]+/.test(input)) {
      answer_eo = sum_eo.reduce((a, b) => a + b, 0) + sum_num;
      answer_fr = sum_fr.reduce((a, b) => a + b, 0) + sum_num;
      answer_ro = sum_ro.reduce((a, b) => a + b, 0) + sum_num;
      answer_rfd = sum_rfd.reduce((a, b) => a + b, 0) + sum_num;
      answer_jg = sum_jg.reduce((a, b) => a + b, 0) + sum_num;
      answer_eg = sum_eg.reduce((a, b) => a + b, 0) + sum_num;
      answer_h = sum_h.reduce((a, b) => a + b, 0) + sum_num;
    } else {
      answer_eo = sum_eo.reduce((a, b) => a + b, 0);
      answer_fr = sum_fr.reduce((a, b) => a + b, 0);
      answer_ro = sum_ro.reduce((a, b) => a + b, 0);
      answer_rfd = sum_rfd.reduce((a, b) => a + b, 0);
      answer_jg = sum_jg.reduce((a, b) => a + b, 0);
      answer_eg = sum_eg.reduce((a, b) => a + b, 0);
      answer_h = sum_h.reduce((a, b) => a + b, 0);
    }

    // Factor calculations
    const newtext_eo = factor(answer_eo);
    const newtext_fr = factor(answer_fr);
    const newtext_ro = factor(answer_ro);
    const newtext_rfd = factor(answer_rfd);
    const newtext_jg = factor(answer_jg);
    const newtext_eg = factor(answer_eg);
    const newtext_h = factor(answer_h);

    // Divisor calculations
    const eo_divi = printDivisors(answer_eo);
    const count_eodivi = eo_divi.length;
    const eodivi_sum = eo_divi.reduce((a, b) => a + b, 0);

    const fr_divi = printDivisors(answer_fr);
    const count_frdivi = fr_divi.length;
    const frdivi_sum = fr_divi.reduce((a, b) => a + b, 0);

    const ro_divi = printDivisors(answer_ro);
    const count_rodivi = ro_divi.length;
    const rodivi_sum = ro_divi.reduce((a, b) => a + b, 0);

    const rfd_divi = printDivisors(answer_rfd);
    const count_rfddivi = rfd_divi.length;
    const rfddivi_sum = rfd_divi.reduce((a, b) => a + b, 0);

    const jg_divi = printDivisors(answer_jg);
    const count_jgdivi = jg_divi.length;
    const jgdivi_sum = jg_divi.reduce((a, b) => a + b, 0);

    const eg_divi = printDivisors(answer_eg);
    const count_egdivi = eg_divi.length;
    const egdivi_sum = eg_divi.reduce((a, b) => a + b, 0);

    const h_divi = printDivisors(answer_h);
    const count_hdivi = h_divi.length;
    const hdivi_sum = h_divi.reduce((a, b) => a + b, 0);

    // Fibonacci calculations
    const sq_root = Math.sqrt(5);
    const final_ans =
      (Math.pow(1.61803, answer_eo) - Math.pow(-0.61803, answer_eo)) / sq_root;
    const final_ans2 =
      (Math.pow(1.61803, answer_fr) - Math.pow(-0.61803, answer_fr)) / sq_root;
    const final_ans3 =
      (Math.pow(1.61803, answer_ro) - Math.pow(-0.61803, answer_ro)) / sq_root;
    const final_ans4 =
      (Math.pow(1.61803, answer_rfd) - Math.pow(-0.61803, answer_rfd)) /
      sq_root;
    const final_ans5 =
      (Math.pow(1.61803, answer_jg) - Math.pow(-0.61803, answer_jg)) / sq_root;
    const final_ans6 =
      (Math.pow(1.61803, answer_eg) - Math.pow(-0.61803, answer_eg)) / sq_root;
    const final_ans7 =
      (Math.pow(1.61803, answer_h) - Math.pow(-0.61803, answer_h)) / sq_root;

    // Adjacent primes
    const ap_eo = np(answer_eo);
    const [apeo_p, apeo_n] = ap_eo;

    const ap_fr = np(answer_fr);
    const [apfr_p, apfr_n] = ap_fr;

    const ap_ro = np(answer_ro);
    const [apro_p, apro_n] = ap_ro;

    const ap_rfd = np(answer_rfd);
    const [aprfd_p, aprfd_n] = ap_rfd;

    const ap_jg = np(answer_jg);
    const [apjg_p, apjg_n] = ap_jg;

    const ap_eg = np(answer_eg);
    const [apeg_p, apeg_n] = ap_eg;

    const ap_h = np(answer_h);
    const [aph_p, aph_n] = ap_h;

    // Prime count
    const previous_eo = total(answer_eo);
    const next_eo = previous_eo + 1;
    const previous_fr = total(answer_fr);
    const next_fr = previous_fr + 1;
    const previous_ro = total(answer_ro);
    const next_ro = previous_ro + 1;
    const previous_rfd = total(answer_rfd);
    const next_rfd = previous_rfd + 1;
    const previous_jg = total(answer_jg);
    const next_jg = previous_jg + 1;
    const previous_eg = total(answer_eg);
    const next_eg = previous_eg + 1;
    const previous_h = total(answer_h);
    const next_h = previous_h + 1;

    // Prime check
    const check_eo = primeCheck(answer_eo);
    const check_fr = primeCheck(answer_fr);
    const check_ro = primeCheck(answer_ro);
    const check_rfd = primeCheck(answer_rfd);
    const check_jg = primeCheck(answer_jg);
    const check_eg = primeCheck(answer_eg);
    const check_h = primeCheck(answer_h);

    // Triangular number check
    const eo = triangular.indexOf(answer_eo);
    const fr = triangular.indexOf(answer_fr);
    const ro = triangular.indexOf(answer_ro);
    const rfd = triangular.indexOf(answer_rfd);
    const jg = triangular.indexOf(answer_jg);
    const eg = triangular.indexOf(answer_eg);
    const h = triangular.indexOf(answer_h);

    // Process triangular results for each system
    const processTriangular = (answer, index, suffix) => {
      if (index !== -1) {
        param[`tech_index_${suffix}`] = index + 2;
      } else {
        const greater = triangular.filter((v) => answer > v);
        const less = triangular.filter((v) => answer < v);
        param[`tech_countg_${suffix}`] = greater.length;
        param[`tech_endg_${suffix}`] = greater[greater.length - 1];
        param[`tech_fl_${suffix}`] = less[0];
        param[`tech_countg_${suffix}1`] = greater.length + 1;
      }
    };

    processTriangular(answer_eo, eo, "eo");
    processTriangular(answer_fr, fr, "fr");
    processTriangular(answer_ro, ro, "ro");
    processTriangular(answer_rfd, rfd, "rfd");
    processTriangular(answer_jg, jg, "jg");
    processTriangular(answer_eg, eg, "eg");
    processTriangular(answer_h, h, "h");

    // Digit sum
    const dosra_eo = answer_eo
      .toString()
      .split("")
      .map(Number)
      .reduce((a, b) => a + b, 0);
    const dosra_fr = answer_fr
      .toString()
      .split("")
      .map(Number)
      .reduce((a, b) => a + b, 0);
    const dosra_ro = answer_ro
      .toString()
      .split("")
      .map(Number)
      .reduce((a, b) => a + b, 0);
    const dosra_rfd = answer_rfd
      .toString()
      .split("")
      .map(Number)
      .reduce((a, b) => a + b, 0);
    const dosra_jg = answer_jg
      .toString()
      .split("")
      .map(Number)
      .reduce((a, b) => a + b, 0);
    const dosra_eg = answer_eg
      .toString()
      .split("")
      .map(Number)
      .reduce((a, b) => a + b, 0);
    const dosra_h = answer_h
      .toString()
      .split("")
      .map(Number)
      .reduce((a, b) => a + b, 0);

    // Triangular relation
    const trelation_eo = triangular[answer_eo - 1] || 0;
    const trelation_fr = triangular[answer_fr - 1] || 0;
    const trelation_ro = triangular[answer_ro - 1] || 0;
    const trelation_rfd = triangular[answer_rfd - 1] || 0;
    const trelation_jg = triangular[answer_jg - 1] || 0;
    const trelation_eg = triangular[answer_eg - 1] || 0;
    const trelation_h = triangular[answer_h - 1] || 0;

    // Prime relation
    const prelation_eo = prime_nums[answer_eo - 1] || 0;
    const prelation_fr = prime_nums[answer_fr - 1] || 0;
    const prelation_ro = prime_nums[answer_ro - 1] || 0;
    const prelation_rfd = prime_nums[answer_rfd - 1] || 0;
    const prelation_jg = prime_nums[answer_jg - 1] || 0;
    const prelation_eg = prime_nums[answer_eg - 1] || 0;
    const prelation_h = prime_nums[answer_h - 1] || 0;

    // Fibonacci check
    const eo_fib = arr.indexOf(answer_eo);
    const fr_fib = arr.indexOf(answer_fr);
    const ro_fib = arr.indexOf(answer_ro);
    const rfd_fib = arr.indexOf(answer_rfd);
    const jg_fib = arr.indexOf(answer_jg);
    const eg_fib = arr.indexOf(answer_eg);
    const h_fib = arr.indexOf(answer_h);

    // Process Fibonacci results for each system
    const processFibonacci = (answer, index, suffix) => {
      if (index != -1) {
        param[`tech_findex_${suffix}`] = index + 2;
      } else {
        const fgreater = arr.filter((v) => answer > v);
        const fless = arr.filter((v) => answer < v);
        param[`tech_fcountg_${suffix}`] = fgreater.length;
        param[`tech_fendg_${suffix}`] = fgreater[fgreater.length - 1];
        param[`tech_ffl_${suffix}`] = fless[0];
        param[`tech_fcountg_${suffix}1`] = fgreater.length + 1;
      }
    };

    processFibonacci(answer_eo, eo_fib, "eo");
    processFibonacci(answer_fr, fr_fib, "fr");
    processFibonacci(answer_ro, ro_fib, "ro");
    processFibonacci(answer_rfd, rfd_fib, "rfd");
    processFibonacci(answer_jg, jg_fib, "jg");
    processFibonacci(answer_eg, eg_fib, "eg");
    processFibonacci(answer_h, h_fib, "h");

    // Assign all results to param
    Object.assign(param, {
      tech_inner_alpha: inner_alpha,
      tech_inner_ans_eo: inner_ans_eo,
      tech_inner_ans_fr: inner_ans_fr,
      tech_inner_ans_ro: inner_ans_ro,
      tech_inner_ans_rfd: inner_ans_rfd,
      tech_inner_ans_jg: inner_ans_jg,
      tech_inner_ans_eg: inner_ans_eg,
      tech_inner_ans_h: inner_ans_h,
      tech_inner_sum_eo: inner_sum_eo,
      tech_inner_sum_fr: inner_sum_fr,
      tech_inner_sum_ro: inner_sum_ro,
      tech_inner_sum_rfd: inner_sum_rfd,
      tech_inner_sum_jg: inner_sum_jg,
      tech_inner_sum_eg: inner_sum_eg,
      tech_inner_sum_h: inner_sum_h,
      tech_answer_eo: answer_eo,
      tech_answer_fr: answer_fr,
      tech_answer_ro: answer_ro,
      tech_answer_rfd: answer_rfd,
      tech_answer_jg: answer_jg,
      tech_answer_eg: answer_eg,
      tech_answer_h: answer_h,
      tech_count_ans: count_ans,
      tech_words_ans: words_ans,
      tech_input: input,
      tech_final_ans: final_ans,
      tech_final_ans2: final_ans2,
      tech_final_ans3: final_ans3,
      tech_final_ans4: final_ans4,
      tech_final_ans5: final_ans5,
      tech_final_ans6: final_ans6,
      tech_final_ans7: final_ans7,
      tech_eo_divi: eo_divi,
      tech_count_eodivi: count_eodivi,
      tech_eodivi_sum: eodivi_sum,
      tech_fr_divi: fr_divi,
      tech_count_frdivi: count_frdivi,
      tech_frdivi_sum: frdivi_sum,
      tech_ro_divi: ro_divi,
      tech_count_rodivi: count_rodivi,
      tech_rodivi_sum: rodivi_sum,
      tech_rfd_divi: rfd_divi,
      tech_count_rfddivi: count_rfddivi,
      tech_rfddivi_sum: rfddivi_sum,
      tech_jg_divi: jg_divi,
      tech_count_jgdivi: count_jgdivi,
      tech_jgdivi_sum: jgdivi_sum,
      tech_eg_divi: eg_divi,
      tech_count_egdivi: count_egdivi,
      tech_egdivi_sum: egdivi_sum,
      tech_h_divi: h_divi,
      tech_count_hdivi: count_hdivi,
      tech_hdivi_sum: hdivi_sum,
      tech_newtext_eo: newtext_eo,
      tech_newtext_fr: newtext_fr,
      tech_newtext_ro: newtext_ro,
      tech_newtext_rfd: newtext_rfd,
      tech_newtext_jg: newtext_jg,
      tech_newtext_eg: newtext_eg,
      tech_newtext_h: newtext_h,
      tech_apeo_p: apeo_p,
      tech_apeo_n: apeo_n,
      tech_apfr_p: apfr_p,
      tech_apfr_n: apfr_n,
      tech_apro_p: apro_p,
      tech_apro_n: apro_n,
      tech_aprfd_p: aprfd_p,
      tech_aprfd_n: aprfd_n,
      tech_apjg_p: apjg_p,
      tech_apjg_n: apjg_n,
      tech_apeg_p: apeg_p,
      tech_apeg_n: apeg_n,
      tech_aph_p: aph_p,
      tech_aph_n: aph_n,
      tech_previous_eo: previous_eo,
      tech_next_eo: next_eo,
      tech_previous_fr: previous_fr,
      tech_next_fr: next_fr,
      tech_previous_ro: previous_ro,
      tech_next_ro: next_ro,
      tech_previous_rfd: previous_rfd,
      tech_next_rfd: next_rfd,
      tech_previous_jg: previous_jg,
      tech_next_jg: next_jg,
      tech_previous_eg: previous_eg,
      tech_next_eg: next_eg,
      tech_previous_h: previous_h,
      tech_next_h: next_h,
      tech_check_eo: check_eo,
      tech_check_fr: check_fr,
      tech_check_ro: check_ro,
      tech_check_rfd: check_rfd,
      tech_check_jg: check_jg,
      tech_check_eg: check_eg,
      tech_check_h: check_h,
      tech_eo: eo,
      tech_fr: fr,
      tech_ro: ro,
      tech_rfd: rfd,
      tech_jg: jg,
      tech_eg: eg,
      tech_h: h,
      tech_dosra_eo: dosra_eo,
      tech_dosra_fr: dosra_fr,
      tech_dosra_ro: dosra_ro,
      tech_dosra_rfd: dosra_rfd,
      tech_dosra_jg: dosra_jg,
      tech_dosra_eg: dosra_eg,
      tech_dosra_h: dosra_h,
      tech_trelation_eo: trelation_eo,
      tech_trelation_fr: trelation_fr,
      tech_trelation_ro: trelation_ro,
      tech_trelation_rfd: trelation_rfd,
      tech_trelation_jg: trelation_jg,
      tech_trelation_eg: trelation_eg,
      tech_trelation_h: trelation_h,
      tech_prelation_eo: prelation_eo,
      tech_prelation_fr: prelation_fr,
      tech_prelation_ro: prelation_ro,
      tech_prelation_rfd: prelation_rfd,
      tech_prelation_jg: prelation_jg,
      tech_prelation_eg: prelation_eg,
      tech_prelation_h: prelation_h,
      tech_eo_fib: eo_fib,
      tech_fr_fib: fr_fib,
      tech_ro_fib: ro_fib,
      tech_rfd_fib: rfd_fib,
      tech_jg_fib: jg_fib,
      tech_eg_fib: eg_fib,
      tech_h_fib: h_fib,
    });

    return param;
  }

  /** getCalculationPowerReducingFormulaCalculator
   * POST: /api/calculators-lol/power-reducing-formula-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPowerReducingFormulaCalculator(body) {
    let know = body.tech_know;
    let angle = body.tech_angle;
    let angle_unit = body.tech_angle_unit;
    let sinx = body.tech_sinx;
    let cosx = body.tech_cosx;
    let tanx = body.tech_tanx;
    let sin2x = body.tech_sin2x;
    let cos2x = body.tech_cos2x;
    let tan2x = body.tech_tan2x;

    let result = {};

    function degToRad(deg) {
      return (deg * Math.PI) / 180;
    }

    function radToDeg(rad) {
      return (rad * 180) / Math.PI;
    }

    if (know == 1) {
      if (!isNaN(angle)) {
        if (angle_unit === "rad") {
          angle = radToDeg(angle);
        }

        let sin = Math.sin(degToRad(angle));
        let cos = Math.cos(degToRad(angle));
        let tan =
          angle == 90 || angle == 270 ? Infinity : Math.tan(degToRad(angle));
        let sin2 = (1 - Math.cos(2 * degToRad(angle))) / 2;
        let cos2 = (1 + Math.cos(2 * degToRad(angle))) / 2;
        let tan2 = sin2 / cos2;
        let sin3 = (3 * sin - Math.sin(3 * degToRad(angle))) / 4;
        let cos3 = (1 / 4) * Math.cos(3 * degToRad(angle)) + (3 / 4) * cos;
        let tan3 = sin3 / cos3;
        let sin4 =
          (3 -
            4 * Math.cos(2 * degToRad(angle)) +
            Math.cos(4 * degToRad(angle))) /
          8;
        let cos4 =
          (3 +
            4 * Math.cos(2 * degToRad(angle)) +
            Math.cos(4 * degToRad(angle))) /
          8;
        let tan4 = sin4 / cos4;

        Object.assign(result, {
          tech_sin: sin,
          tech_cos: cos,
          tech_tan: tan,
          tech_sin2: sin2,
          tech_cos2: cos2,
          tech_tan2: tan2,
          tech_sin3: sin3,
          tech_cos3: cos3,
          tech_tan3: tan3,
          tech_sin4: sin4,
          tech_cos4: cos4,
          tech_tan4: tan4,
        });

        return result;
      } else {
        return { error: "Please Check Your Input." };
      }
    } else if (know == 2) {
      if (!isNaN(sinx) && !cosx && !tanx && !sin2x && !cos2x && !tan2x) {
        angle = Math.asin(sinx);
      } else if (!sinx && !isNaN(cosx) && !tanx && !sin2x && !cos2x && !tan2x) {
        angle = Math.acos(cosx);
      } else if (!sinx && !cosx && !isNaN(tanx) && !sin2x && !cos2x && !tan2x) {
        angle = Math.atan(tanx);
      } else if (!sinx && !cosx && !tanx && !isNaN(sin2x) && !cos2x && !tan2x) {
        angle = Math.asin(Math.sqrt(sin2x));
      } else if (!sinx && !cosx && !tanx && !sin2x && !isNaN(cos2x) && !tan2x) {
        angle = Math.acos(Math.sqrt(cos2x));
      } else if (!sinx && !cosx && !tanx && !sin2x && !cos2x && !isNaN(tan2x)) {
        angle = Math.atan(Math.sqrt(tan2x));
      } else {
        return { error: "Please Enter any one of the known function values." };
      }

      angle = radToDeg(angle);

      let sin = Math.sin(degToRad(angle));
      let cos = Math.cos(degToRad(angle));
      let tan =
        angle == 90 || angle == 270 ? Infinity : Math.tan(degToRad(angle));
      let sin2 = (1 - Math.cos(2 * degToRad(angle))) / 2;
      let cos2 = (1 + Math.cos(2 * degToRad(angle))) / 2;
      let tan2 = sin2 / cos2;
      let sin3 = (3 * sin - Math.sin(3 * degToRad(angle))) / 4;
      let cos3 = (1 / 4) * Math.cos(3 * degToRad(angle)) + (3 / 4) * cos;
      let tan3 = sin3 / cos3;
      let sin4 =
        (3 -
          4 * Math.cos(2 * degToRad(angle)) +
          Math.cos(4 * degToRad(angle))) /
        8;
      let cos4 =
        (3 +
          4 * Math.cos(2 * degToRad(angle)) +
          Math.cos(4 * degToRad(angle))) /
        8;
      let tan4 = sin4 / cos4;

      Object.assign(result, {
        tech_angle: angle,
        tech_sin: sin,
        tech_cos: cos,
        tech_tan: tan,
        tech_sin2: sin2,
        tech_cos2: cos2,
        tech_tan2: tan2,
        tech_sin3: sin3,
        tech_cos3: cos3,
        tech_tan3: tan3,
        tech_sin4: sin4,
        tech_cos4: cos4,
        tech_tan4: tan4,
      });

      return result;
    }
  }

  /** getCalculationFunctionOperationsCalculator
   * POST: /api/calculators-lol/function-operations-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationFunctionOperationsCalculator(body) {
    let fx = body.tech_fx;
    let gx = body.tech_gx;
    let point = body.tech_point;
    let variable = body.tech_variable;

    if (fx && gx) {
      let parem = fx
        .replace(/ /g, "")
        .replace(/−/g, "-")
        .replace(/plus/g, "+")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**");

      let parem1 = gx
        .replace(/ /g, "")
        .replace(/−/g, "-")
        .replace(/plus/g, "+")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**");

      let postData = new URLSearchParams();
      postData.append("fx", parem);
      postData.append("gx", parem1);

      if (!isNaN(point)) {
        postData.append("x", variable);
        postData.append("point", point);
      }

      try {
        const response = await axios.post(
          "http://167.172.134.148/fun-op",
          postData,
          {
            timeout: 120000,
          }
        );

        let buffer = response.data;

        let result = {
          tech_fox: buffer[0],
          tech_gox: buffer[1],
          tech_add: buffer[2],
          tech_sub: buffer[3],
          tech_mul: buffer[4],
          tech_div: buffer[5],
          tech_x: variable,
        };

        if (!isNaN(point)) {
          result.tech_add1 = buffer[6];
          result.tech_sub1 = buffer[7];
          result.tech_mul1 = buffer[8];
          result.tech_div1 = buffer[9];
          result.tech_point = point;
        }

        return result;
      } catch (error) {
        return {
          status: "error",
          error: "Please! Check Your Input.",
        };
      }
    } else {
      return {
        status: "error",
        error: "Please! Check Your Input.",
      };
    }
  }

  /**
   * BaseNumberCalculator: Service Method
   * POST: /api/calculators-lol/base-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async BaseNumberCalculator(data) {
    try {
      const { select_base, first_number, operation, second_number } = data;

      // ========== VALIDATION ==========
      if (
        !select_base ||
        first_number == null ||
        !operation ||
        second_number == null
      ) {
        return {
          status: "error",
          error: "All fields are required.",
        };
      }

      // Extract base number
      const baseMatch = select_base.match(/^\d+/);
      if (!baseMatch) {
        return {
          status: "error",
          error: "Invalid base format.",
        };
      }
      const base = parseInt(baseMatch[0]);

      // Validate base range
      if (base < 2 || base > 36) {
        return {
          status: "error",
          error: "Base must be between 2 and 36.",
        };
      }

      // ========== VALIDATE DIGITS ==========
      const getValidDigits = (baseValue) => {
        if (baseValue <= 10) {
          return `0-${baseValue - 1}`;
        } else {
          return `0-9, A-${String.fromCharCode(64 + baseValue - 10)}`;
        }
      };

      const validateNumberForBase = (num, baseValue) => {
        const numStr = num.toString().toUpperCase();
        const validChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ".slice(
          0,
          baseValue
        );

        for (let char of numStr) {
          if (!validChars.includes(char)) {
            return false;
          }
        }
        return true;
      };

      // Validate first number
      if (!validateNumberForBase(first_number, base)) {
        return {
          status: "error",
          error: `Invalid digit in first number "${first_number}" for base ${base}. Valid digits are: ${getValidDigits(
            base
          )}`,
        };
      }

      // Validate second number
      if (!validateNumberForBase(second_number, base)) {
        return {
          status: "error",
          error: `Invalid digit in second number "${second_number}" for base ${base}. Valid digits are: ${getValidDigits(
            base
          )}`,
        };
      }

      // ========== CONVERT TO DECIMAL ==========
      const firstDecimal = parseInt(first_number.toString(), base);
      const secondDecimal = parseInt(second_number.toString(), base);

      if (isNaN(firstDecimal) || isNaN(secondDecimal)) {
        return {
          status: "error",
          error: `Conversion failed for base ${base}.`,
        };
      }

      // ========== PERFORM OPERATION ==========
      let resultDecimal;
      let operationSymbol = operation;

      switch (operation) {
        case "+":
          resultDecimal = firstDecimal + secondDecimal;
          break;
        case "-":
          resultDecimal = firstDecimal - secondDecimal;
          break;
        case "×":
        case "*":
        case "x":
          resultDecimal = firstDecimal * secondDecimal;
          operationSymbol = "×";
          break;
        case "÷":
        case "/":
          if (secondDecimal === 0) {
            return {
              status: "error",
              error: "Cannot divide by zero.",
            };
          }
          resultDecimal = Math.floor(firstDecimal / secondDecimal);
          operationSymbol = "÷";
          break;
        case "mod":
        case "%":
          if (secondDecimal === 0) {
            return {
              status: "error",
              error: "Cannot calculate modulo with zero.",
            };
          }
          resultDecimal = firstDecimal % secondDecimal;
          operationSymbol = "mod";
          break;
        default:
          return {
            status: "error",
            error: "Invalid operation. Use +, -, ×, ÷, or mod.",
          };
      }

      // ========== CONVERT RESULT ==========
      let resultInBase;
      if (resultDecimal < 0) {
        resultInBase =
          "-" + Math.abs(resultDecimal).toString(base).toUpperCase();
      } else {
        resultInBase = resultDecimal.toString(base).toUpperCase();
      }

      const getBaseName = (baseNum) => {
        const names = {
          2: "Binary",
          8: "Octal",
          10: "Decimal",
          16: "Hexadecimal",
        };
        return names[baseNum] || `Base ${baseNum}`;
      };

      // ========== RETURN SUCCESS ==========
      return {
        status: "success",
        payload: {
          input: {
            base: base,
            base_name: getBaseName(base),
            first_number: first_number.toString().toUpperCase(),
            operation: operationSymbol,
            second_number: second_number.toString().toUpperCase(),
          },
          calculation: {
            expression: `${first_number
              .toString()
              .toUpperCase()} ${operationSymbol} ${second_number
              .toString()
              .toUpperCase()}`,
            base: base,
          },
          result: {
            in_given_base: resultInBase,
            in_decimal: resultDecimal,
            base: base,
          },
          step_by_step: {
            step_1: `Convert ${first_number} (base ${base}) to decimal: ${firstDecimal}`,
            step_2: `Convert ${second_number} (base ${base}) to decimal: ${secondDecimal}`,
            step_3: `Perform operation: ${firstDecimal} ${operationSymbol} ${secondDecimal} = ${resultDecimal}`,
            step_4: `Convert result ${resultDecimal} (decimal) back to base ${base}: ${resultInBase}`,
          },
        },
      };
    } catch (error) {
      return {
        status: "error",
        error: error.message || "Something went wrong in base calculation.",
      };
    }
  }

  /** getCalculationDiamondCalculator
   * POST: /api/calculators-lol/diamond-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDiamondCalculator(body) {
    let factor_a = parseFloat(body.tech_factor_a);
    let factor_b = parseFloat(body.tech_factor_b);
    let product = parseFloat(body.tech_product);
    let sum = parseFloat(body.tech_sum);

    let result = {};
    let facta, factb, pro, su, met;

    if (!isNaN(factor_a) && !isNaN(factor_b) && isNaN(product) && isNaN(sum)) {
      facta = factor_a;
      factb = factor_b;
      pro = factor_a * factor_b;
      su = factor_a + factor_b;
      met = 1;
    } else if (
      !isNaN(factor_a) &&
      !isNaN(product) &&
      isNaN(factor_b) &&
      isNaN(sum)
    ) {
      facta = factor_a;
      factb = parseFloat((product / factor_a).toFixed(3));
      pro = product;
      su = facta + factb;
      met = 2;
    } else if (
      !isNaN(factor_a) &&
      !isNaN(sum) &&
      isNaN(factor_b) &&
      isNaN(product)
    ) {
      facta = factor_a;
      factb = sum - factor_a;
      su = sum;
      pro = facta * factb;
      met = 3;
    } else if (
      !isNaN(factor_b) &&
      !isNaN(product) &&
      isNaN(factor_a) &&
      isNaN(sum)
    ) {
      factb = factor_b;
      facta = parseFloat((product / factor_b).toFixed(2));
      pro = product;
      su = facta + factb;
      met = 4;
    } else if (
      !isNaN(factor_b) &&
      !isNaN(sum) &&
      isNaN(factor_a) &&
      isNaN(product)
    ) {
      factb = factor_b;
      facta = sum - factor_b;
      su = sum;
      pro = facta * factor_b;
      met = 5;
    } else if (
      !isNaN(product) &&
      !isNaN(sum) &&
      isNaN(factor_a) &&
      isNaN(factor_b)
    ) {
      let found = false;
      for (let i = 1; i * i <= product; i++) {
        if (product % i === 0) {
          let j = product / i;
          if (i + j === sum) {
            facta = i;
            factb = j;
            pro = product;
            su = sum;
            met = 6;
            found = true;
            break;
          }
        }
      }
      if (!found) {
        return {
          error: `Cannot find two factors of ${product} that sum equal to ${sum}`,
        };
      }
    } else {
      return { error: "Please! Enter any two values." };
    }

    result.tech_facta = facta;
    result.tech_factb = factb;
    result.tech_pro = pro;
    result.tech_su = su;
    result.tech_met = met;

    return result;
  }

  /** getCalculationCrossMultiplyCalculator
   * POST: /api/calculators-lol/cross-multiply-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCrossMultiplyCalculator(body) {
    let a = parseFloat(body.tech_a);
    let b = parseFloat(body.tech_b);
    let c = parseFloat(body.tech_c);
    let d = parseFloat(body.tech_d);

    let result = {};

    const isA = !isNaN(a);
    const isB = !isNaN(b);
    const isC = !isNaN(c);
    const isD = !isNaN(d);

    const totalInputs = [isA, isB, isC, isD].filter(Boolean).length;

    if (totalInputs === 4) {
      result.error = "Please Enter 3 numbers & leave 1 field empty!";
      return result;
    }

    if (!isA && isB && isC && isD) {
      result.tech_a_val = (b * c) / d;
    } else if (isA && !isB && isC && isD) {
      result.tech_b_val = (a * d) / c;
    } else if (isA && isB && !isC && isD) {
      result.tech_c_val = (a * d) / b;
    } else if (isA && isB && isC && !isD) {
      result.tech_d_val = (b * c) / a;
    } else {
      result.error = "Please! Check Your Input.";
      return result;
    }

    return result;
  }

  /** getCalculationAreaSemicircleCalculator
   * POST: /api/calculators-lol/area-of-a-semicircle
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAreaSemicircleCalculator(body) {
    let radius = parseFloat(body.tech_radius);
    let selection = body.tech_selection;
    let pi = parseFloat(body.tech_pi);
    let units = body.tech_units;

    function convertToCm(unit, val) {
      if (unit === "cm") return val;
      if (unit === "m") return val * 100;
      if (unit === "in") return val * 2.54;
      if (unit === "ft") return val * 30.48;
      if (unit === "yd") return val * 91.44;
      return NaN;
    }

    let result = {};

    let rad, per, da, ac, a;

    if (
      ["1", "2", "3", "4", "6"].includes(selection) &&
      !isNaN(radius) &&
      !isNaN(pi) &&
      radius > 0
    ) {
      let ans = convertToCm(units, radius);

      switch (selection) {
        case "1": // Given Radius
          rad = ans;
          da = rad * 2;
          a = (pi * rad * rad) / 2;
          per = pi * rad + 2 * rad;
          ac = 3.14 * rad;
          break;

        case "2": // Given Diameter
          da = ans;
          rad = da / 2;
          ac = rad * 3.14;
          per = pi * rad + 2 * rad;
          a = (pi * rad * rad) / 2;
          break;

        case "3": // Given Arc Length
          ac = ans;
          rad = ac / pi;
          da = rad * 2;
          per = pi * rad + 2 * rad;
          a = (pi * rad * rad) / 2;
          break;

        case "4": // Given Perimeter
          per = ans;
          rad = per / (pi + 2);
          da = rad * 2;
          ac = rad * pi;
          a = (pi * rad * rad) / 2;
          break;

        case "6": // Given Area
          a = ans;
          rad = Math.sqrt((2 * a) / pi);
          da = rad * 2;
          ac = rad * 3.14;
          per = pi * rad + 2 * rad;
          break;
      }

      result.tech_radius = parseFloat(rad.toFixed(3));
      result.tech_perimeter = parseFloat(per.toFixed(3));
      result.tech_diameter = parseFloat(da.toFixed(3));
      result.tech_arc_length = parseFloat(ac.toFixed(3));
      result.tech_area = parseFloat(a.toFixed(3));
      result.tech_unit = units;
      result.tech_pi = pi;
      result.tech_selection = selection;
      return result;
    } else {
      return { error: "Please! Check Your Input.111" };
    }
  }

  /** getCalculationAreaDegreeandLeadingCoefficientCalculator
   * POST: /api/calculators-lol/degree-and-leading-coefficient
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAreaDegreeandLeadingCoefficientCalculator(body) {
    let equ = body.tech_equ;
    let vari = body.tech_vari;

    let range = [..."abcdefghijklmnopqrstuvwxyz"];

    if (equ && range.includes(vari.toLowerCase())) {
      let input = equ;
      input = input.replace(/ /g, "");
      input = input.replace(/\+/g, "plus");
      input = input.replace(/{/g, "(");
      input = input.replace(/}/g, ")");
      input = input.replace(/xe\^/g, "x*e^");
      input = input.replace(/ye\^/g, "y*e^");
      input = input.replace(/e\^/g, "exp");
      input = input.replace(/exp\^/g, "exp");
      input = input.replace(/\^/g, "**");
      input = input.replace(/e\^sqrt\(x\)/g, "exp(2*x)");

      try {
        const response = await axios.post(
          "http://167.172.134.148/degree",
          new URLSearchParams({ equ: input }),
          {
            timeout: 120000,
          }
        );

        let buffer = response.data;
        input = buffer[1];

        let jawab = buffer[0]
          .trim()
          .replace(/\\left\(/g, "")
          .replace(/\\right\)/g, "")
          .replace(/\\/g, "");

        let parts = jawab.split(",");
        let final = {};

        for (let value of parts) {
          if (value.toLowerCase().includes(vari.toLowerCase())) {
            let index = value.split(vari);
            if (index.length === 2) {
              let keyx = index[0].replace(/ /g, "");
              let valuex = index[1].replace(/[\^{\} ]/g, "");
              if (!valuex && !isNaN(keyx)) {
                final[keyx] = 1;
              } else if (!isNaN(keyx) && !isNaN(valuex)) {
                final[keyx] = parseFloat(valuex);
              }
            }
          }
        }

        if (Object.keys(final).length === 0) {
          return {
            status: "error",
            error: "Please! Check Your Input.",
          };
        } else {
          let degree = Math.max(...Object.values(final));
          let lead = Object.keys(final).find((key) => final[key] === degree);

          return {
            tech_status: "success",
            tech_input: input,
            tech_lead: lead,
            tech_degree: degree,
          };
        }
      } catch (err) {
        return {
          status: "error",
          error: "Please! Check Your Input.",
        };
      }
    } else {
      return {
        status: "error",
        error: "Please! Check Your Input.",
      };
    }
  }

  /** getCalculationEquivalentExpressionsCalculator
   * POST: /api/calculators-lol/equivalent-expressions-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationEquivalentExpressionsCalculator(body) {
    let equ = body.tech_equ;

    if (equ) {
      let input = equ;

      input = input.replace(/ /g, "");
      input = input.replace(/\+/g, "plus");
      input = input.replace(/{/g, "(");
      input = input.replace(/}/g, ")");
      input = input.replace(/xe\^/g, "x*e^");
      input = input.replace(/ye\^/g, "y*e^");
      input = input.replace(/e\^/g, "exp");
      input = input.replace(/exp\^/g, "exp");
      input = input.replace(/\^/g, "**");
      input = input.replace(/e\^sqrt\(x\)/g, "exp(2*x)");

      try {
        const response = await axios.post(
          "http://167.172.134.148/equ_exp",
          new URLSearchParams({ equ: input }),
          {
            timeout: 120000,
          }
        );

        let buffer = response.data;

        return {
          tech_status: "success",
          tech_ans: buffer[1],
        };
      } catch (err) {
        return {
          status: "error",
          error: "Please! Check Your Input.",
        };
      }
    } else {
      return {
        status: "error",
        error: "Please! Check Your Input.",
      };
    }
  }

  /**
   * getCalculationRatioToFractionCalculator: Service Method
   * POST: /api/calculators-lol/ratio-to-fraction-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationRatioToFractionCalculator(body) {
    const select_unit = body.tech_select_unit;
    const first_number = body.tech_first_number;
    const second_number = body.tech_second_number;
    const convert = body.tech_convert;
    const param = {};

    // Helper function to calculate GCD (Greatest Common Divisor)
    function gcd(a, b) {
      a = Math.abs(a);
      b = Math.abs(b);

      if (a < b) {
        [a, b] = [b, a];
      }

      if (b == 0) {
        return 1;
      }

      let r = a % b;
      while (r > 0) {
        a = b;
        b = r;
        r = a % b;
      }
      return b;
    }

    // Helper function to reduce fraction
    function reduce(num, den) {
      const g = gcd(num, den);
      return [num / g, den / g];
    }

    // Validate if input is numeric
    function isNumeric(value) {
      return !isNaN(parseFloat(value)) && isFinite(value);
    }

    if (convert == "1") {
      // Convert Ratio to Fraction
      if (select_unit == "1") {
        if (isNumeric(first_number) && isNumeric(second_number)) {
          const fn = parseFloat(first_number);
          const sn = parseFloat(second_number);

          if (fn >= 0 && sn >= 0) {
            if (fn == 0 && sn == 0) {
              param.error =
                "There must be at least one part, A or B, greater than 0.";
              return param;
            } else {
              const addition = fn + sn;
              const totalN = fn;
              const totalD = addition;

              const [upr1, btm1] = reduce(totalN, totalD);

              const totalN1 = sn;
              const totalD1 = addition;

              const [upr2, btm2] = reduce(totalN1, totalD1);

              const method = 1;
              param.tech_upr1 = upr1;
              param.tech_btm1 = btm1;
              param.tech_upr2 = upr2;
              param.tech_btm2 = btm2;
              param.tech_addition = addition;
              param.tech_first_number = first_number;
              param.tech_second_number = second_number;
              param.tech_method = method;
            }
          } else {
            param.error = "Enter 0 or a whole number";
            return param;
          }
        } else {
          param.error = "Please Check Your Input!";
          return param;
        }
      } else if (select_unit == "2") {
        if (isNumeric(first_number) && isNumeric(second_number)) {
          const fn = parseFloat(first_number);
          const sn = parseFloat(second_number);

          if (fn >= 0 && sn >= 0) {
            if (fn == 0 && sn == 0) {
              param.error = "Enter 0 or a whole number";
              return param;
            } else {
              if (fn <= sn) {
                // Part is less than whole
                const totalN1 = fn;
                const totalD1 = sn;

                const [upr2, btm2] = reduce(totalN1, totalD1);

                const method2 = 2;
                param.tech_first_number = first_number;
                param.tech_second_number = second_number;
                param.tech_upr2 = upr2;
                param.tech_btm2 = btm2;
                param.tech_method = method2;
              } else {
                param.error =
                  "The Part must be less than or equal to the Whole.";
                return param;
              }
            }
          } else {
            param.error =
              "There must be at least one part, A or B, greater than 0.";
            return param;
          }
        } else {
          param.error = "Please Check Your Input!";
          return param;
        }
      }
    } else if (convert == "2") {
      // Convert Fraction to Ratio
      if (select_unit == "1") {
        if (isNumeric(first_number) && isNumeric(second_number)) {
          const fn = parseFloat(first_number);
          const sn = parseFloat(second_number);

          if (fn >= 0 && sn >= 0) {
            if (fn == 0 && sn == 0) {
              param.error =
                "There must be at least one part, A or B, greater than 0.";
              return param;
            } else {
              const totalN = fn;
              const totalD = sn;

              const [upr1, btm1] = reduce(totalN, totalD);

              const method = 3;
              param.tech_upr1 = upr1;
              param.tech_upr2 = btm1;
              param.tech_first_number = first_number;
              param.tech_second_number = second_number;
              param.tech_method = method;
            }
          } else {
            param.error = "Enter 0 or a whole number";
            return param;
          }
        } else {
          param.error = "Please Check Your Input!";
          return param;
        }
      } else if (select_unit == "2") {
        if (isNumeric(first_number) && isNumeric(second_number)) {
          const fn = parseFloat(first_number);
          const sn = parseFloat(second_number);

          if (fn >= 0 && sn >= 0) {
            if (fn == 0 && sn == 0) {
              param.error =
                "There must be at least one part, A or B, greater than 0.";
              return param;
            } else {
              if (fn <= sn) {
                const subtraction = sn - fn;
                const totalN = fn;
                const totalD = subtraction;

                const [upr1, btm1] = reduce(totalN, totalD);

                const totalN1 = sn;
                const totalD1 = subtraction;

                const [upr2, btm2] = reduce(totalN1, totalD1);

                const method = 4;
                param.tech_upr1 = upr1;
                param.tech_btm1 = btm1;
                param.tech_upr2 = upr2;
                param.tech_btm2 = btm2;
                param.tech_subtraction = subtraction;
                param.tech_first_number = first_number;
                param.tech_second_number = second_number;
                param.tech_method = method;
              } else {
                param.error =
                  "The Part must be less than or equal to the Whole.";
                return param;
              }
            }
          } else {
            param.error =
              "There must be at least one part, A or B, greater than 0.";
            return param;
          }
        } else {
          param.error = "Please Check Your Input!";
          return param;
        }
      }
    }

    return param;
  }

  /** getCalculationDescartesRuleSignsCalculator
   * POST: /api/calculators-lol/descartes-rule-of-signs-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDescartesRuleSignsCalculator(body) {
    let equ = body.tech_equ;
    let vari = body.tech_vari;

    let range = [..."abcdefghijklmnopqrstuvwxyz"];

    if (equ && range.includes(vari.toLowerCase())) {
      let input = equ;

      input = input.replace(/ /g, "");
      input = input.replace(/\+/g, "plus");
      input = input.replace(/{/g, "(");
      input = input.replace(/}/g, ")");
      input = input.replace(/xe\^/g, "x*e^");
      input = input.replace(/ye\^/g, "y*e^");
      input = input.replace(/e\^/g, "exp");
      input = input.replace(/exp\^/g, "exp");
      input = input.replace(/\^/g, "**");
      input = input.replace(/e\^sqrt\(x\)/g, "exp(2*x)");

      let input1 = input.replace(new RegExp(vari, "g"), `(-${vari})`);

      try {
        const response = await axios.post(
          "http://167.172.134.148/descartes",
          new URLSearchParams({
            equ: input,
            equ1: input1,
            wrt: vari,
          }),
          { timeout: 120000 }
        );

        let buffer = response.data;
        let cof1 = buffer[2].split(",").filter((v) => v.trim() !== "");
        let cof2 = buffer[3].split(",").filter((v) => v.trim() !== "");

        let sign1 = [];
        for (let value of cof1) {
          let num = parseFloat(value.trim());
          if (!isNaN(num)) {
            sign1.push(num < 0 ? "-" : "+");
          } else {
            return {
              status: "error",
              error: "Please! Enter Univariate Polynomial",
            };
          }
        }

        let sign2 = [];
        for (let value of cof2) {
          let num = parseFloat(value.trim());
          if (!isNaN(num)) {
            sign2.push(num < 0 ? "-" : "+");
          } else {
            return {
              status: "error",
              error: "Please! Enter Univariate Polynomial",
            };
          }
        }

        let positive = 0;
        for (let i = 0; i < sign1.length - 1; i++) {
          if (sign1[i] !== sign1[i + 1]) {
            positive++;
          }
        }

        let negative = 0;
        for (let i = 0; i < sign2.length - 1; i++) {
          if (sign2[i] !== sign2[i + 1]) {
            negative++;
          }
        }

        return {
          tech_status: "success",
          tech_input1: buffer[0],
          tech_input2: buffer[1],
          tech_positive: positive,
          tech_negative: negative,
          tech_cof1: cof1,
          tech_cof2: cof2,
        };
      } catch (err) {
        return {
          status: "error",
          error: "Please! Check Your Input.",
        };
      }
    } else {
      return {
        status: "error",
        error: "Please Check Your Input!",
      };
    }
  }

  /**
   * getCalculationGramSchmidtCalculator: Service Method
   * POST: /api/calculators-lol/gram-schmidt-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationGramSchmidtCalculator(body) {
    const matrix2 = parseInt(body.tech_matrix2);
    const matrix22 = parseInt(body.tech_matrix22);
    const second_matrix = [];

    // Extract matrix data
    for (let i = 1; i <= matrix2; i++) {
      for (let j = 1; j <= matrix22; j++) {
        const key = `tech_matrix3${i}_${j}`;
        if (body[key] != undefined && !isNaN(parseFloat(body[key]))) {
          second_matrix.push(parseFloat(body[key]));
        }
      }
    }

    // Helper functions
    const new_roundNumb = (a) => {
      return Math.round(a * 100) / 100;
    };

    const normalizeVector = (coordinates, vector) => {
      let divisor = 0;
      for (let i = 0; i < coordinates; i++) {
        divisor = divisor + Math.pow(vector[i], 2);
      }
      divisor = Math.sqrt(divisor);
      if (divisor !== 0) {
        for (let i = 0; i < coordinates; i++) {
          vector[i] = new_roundNumb(vector[i] / divisor);
        }
      }
      return vector;
    };

    const subtractPrevious = (coordinates, vector1, vector2) => {
      let divisor1 = 0;
      let divisor2 = 0;
      let dotProduct = 0;
      for (let i = 0; i < coordinates; i++) {
        divisor1 += vector1[i] * vector1[i];
        divisor2 += vector2[i] * vector2[i];
        dotProduct += vector1[i] * vector2[i];
      }
      if (divisor1 !== 0 && divisor2 !== 0) {
        for (let i = 0; i < coordinates; i++) {
          vector1[i] = new_roundNumb(
            vector1[i] - (dotProduct * vector2[i]) / divisor2
          );
        }
      }
      return vector1;
    };

    // Main logic
    const mul = matrix22 * matrix2;
    let result = {};

    if (mul === second_matrix.length) {
      // Convert flat array to 2D matrix
      const zain = [];
      for (let i = 0; i < matrix2; i++) {
        const row = second_matrix.slice(i * matrix22, (i + 1) * matrix22);
        zain.push(row);
      }

      // Get column vectors
      const all_vec = [];
      for (let i = 0; i < matrix22; i++) {
        const column = [];
        for (let j = 0; j < matrix2; j++) {
          column.push(zain[j][i]);
        }
        all_vec.push(column);
      }

      const first_unit = normalizeVector(matrix2, [...all_vec[0]]);
      const fahad = Math.max(matrix22, matrix2);
      const f_vec = [...all_vec[0]];

      // Calculate projections for all vectors
      const total = [];
      const vector_unit = [];

      for (let i = 1; i < fahad; i++) {
        if (all_vec[i]) {
          const s_vec = all_vec[i];
          const temp = [];
          for (let key = 0; key < f_vec.length; key++) {
            temp.push(f_vec[key] * s_vec[key]);
          }
          total[i] = temp;
          vector_unit.push(temp.reduce((sum, val) => sum + val, 0));
        }
      }

      // Calculate vector magnitude
      const itself_mul = [];
      for (const value of f_vec) {
        itself_mul.push(Math.pow(value, 2));
      }
      const vector_u = itself_mul.reduce((sum, val) => sum + val, 0);

      // Calculate combined vectors
      const combined_vector = [];
      for (const value7 of vector_unit) {
        combined_vector.push(value7 / vector_u);
      }

      // Calculate projection answers
      const ans_pro = [];
      for (let l = 0; l < f_vec.length; l++) {
        const temp = [];
        for (const values of combined_vector) {
          temp.push(values * f_vec[l]);
        }
        ans_pro.push(temp);
      }

      // Transpose ans_pro to get column vectors
      const pros_ans = [];
      for (let m = 0; m < matrix22 - 1; m++) {
        const column = [];
        for (let n = 0; n < ans_pro.length; n++) {
          if (ans_pro[n][m] !== undefined) {
            column.push(ans_pro[n][m]);
          }
        }
        pros_ans.push(column);
      }

      // Remove first element from zaini
      const zaini = [...all_vec];
      zaini.shift();

      // Calculate subtracted vectors
      const subtract = [];
      for (let main = 0; main < pros_ans.length; main++) {
        if (zaini[main]) {
          subtract.push(
            subtractPrevious(matrix2, [...zaini[main]], [...pros_ans[main]])
          );
        }
      }

      // Calculate unit vectors
      const all_vecunit = [];
      for (const value of subtract) {
        all_vecunit.push(normalizeVector(matrix2, [...value]));
      }

      // Set result values - match Laravel structure exactly
      result.tech_all_vec = all_vec;
      result.tech_first_unit = first_unit;
      result.tech_all_vecunit = all_vecunit;
      result.tech_pros_ans = pros_ans;
      result.tech_subtract = subtract;
    } else {
      result.error = "Please! Check Your Input.";
    }

    return result;
  }

  /** getCalculationRotationCalculator
   * POST: /api/calculators-lol/rotation-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRotationCalculator(body) {
    let point_rotate_one = body.tech_point_rotate_one;
    let point_rotate_two = body.tech_point_rotate_two;
    let angle = body.tech_angle;
    let unit = body.tech_unit;
    let point_around_one = body.tech_point_around_one;
    let point_around_two = body.tech_point_around_two;
    let direction = body.tech_direction;

    // Helper function to check if a value is numeric
    function isNumeric(value) {
      return !isNaN(parseFloat(value)) && isFinite(value);
    }

    const result = {
      param: {},
    };

    if (unit === "radians") {
      if (
        isNumeric(point_rotate_one) &&
        isNumeric(point_rotate_two) &&
        isNumeric(angle) &&
        isNumeric(point_around_one) &&
        isNumeric(point_around_two)
      ) {
        if (direction === "anticlockwise" || direction === "clockwise") {
          let rotationAngle = angle;
          if (direction === "clockwise") {
            rotationAngle = angle * -1;
          } else if (direction === "anticlockwise") {
            rotationAngle = angle * 1;
          }

          const first_point = point_rotate_one - point_around_one;
          const second_point = point_rotate_two - point_around_two;
          const first_part = first_point * Math.cos(rotationAngle);
          const second_part = second_point * Math.sin(rotationAngle);
          const formula = first_part - second_part + point_around_one;
          const third_part = first_point * Math.sin(rotationAngle);
          const fourth_part = second_point * Math.cos(rotationAngle);
          const formula2 = third_part + fourth_part + point_around_two;

          result.param.tech_point_rotate_one = point_rotate_one;
          result.param.tech_point_rotate_two = point_rotate_two;
          result.param.tech_point_around_one = point_around_one;
          result.param.tech_point_around_two = point_around_two;
          result.param.tech_formula_one = formula;
          result.param.tech_formula_two = formula2;
          result.param.tech_angle = rotationAngle;
          result.param.tech_angle2 = rotationAngle;
          result.param.tech_unit = unit;
          result.param.tech_direction = direction;
        }
      } else {
        result.param.error = "Please! Check Your Input.";
        return result.param;
      }
    } else if (unit === "degrees") {
      if (
        isNumeric(point_rotate_one) &&
        isNumeric(point_rotate_two) &&
        isNumeric(angle) &&
        isNumeric(point_around_one) &&
        isNumeric(point_around_two)
      ) {
        if (direction === "anticlockwise" || direction === "clockwise") {
          let rotationAngle = angle;
          if (direction === "clockwise") {
            rotationAngle = angle * -1;
          } else if (direction === "anticlockwise") {
            rotationAngle = angle * 1;
          }

          const first_point = point_rotate_one - point_around_one;
          const second_point = point_rotate_two - point_around_two;
          const sp = (rotationAngle * Math.PI) / 180;
          const first_part = first_point * Math.cos(sp);
          const second_part = second_point * Math.sin(sp);
          const formula = first_part - second_part + point_around_one;
          const third_part = first_point * Math.sin(sp);
          const fourth_part = second_point * Math.cos(sp);
          const formula2 = third_part + fourth_part + point_around_two;

          result.param.tech_point_rotate_one = point_rotate_one;
          result.param.tech_point_rotate_two = point_rotate_two;
          result.param.tech_point_around_one = point_around_one;
          result.param.tech_point_around_two = point_around_two;
          result.param.tech_formula_one = formula;
          result.param.tech_formula_two = formula2;
          result.param.tech_angle = sp;
          result.param.tech_angle2 = rotationAngle;
          result.param.tech_direction = direction;
          result.param.tech_unit = unit;
        }
      } else {
        result.param.error = "Please! Check Your Input.";
        return result.param;
      }
    }

    return result.param;
  }

  /** getCalculationReciprocalCalculator
   * POST: /api/calculators-lol/reciprocal-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationReciprocalCalculator(body) {
    let operations = body.tech_operations;
    let first = body.tech_first;
    let second = body.tech_second;
    let third = body.tech_third;

    let param = {};

    function gcd(a, b) {
      a = Math.abs(a);
      b = Math.abs(b);
      if (a < b) [a, b] = [b, a];
      if (b === 0) return 1;
      let r = a % b;
      while (r > 0) {
        a = b;
        b = r;
        r = a % b;
      }
      return b;
    }

    function reduce(num, den) {
      let g = gcd(num, den);
      return [num / g, den / g];
    }

    if (operations == 1) {
      if (!isNaN(second) && !isNaN(third)) {
        if (second != 0) {
          if (third != 0) {
            let answer = third / second;
            let totalN = second;
            let totalD = third;
            let g = gcd(totalN, totalD);
            let [upr, btm] = reduce(totalN, totalD);
            param.tech_upr = upr;
            param.tech_totalN = totalN;
            param.tech_totalD = totalD;
            param.tech_g = g;
            param.tech_btm = btm;
            param.tech_answer = answer;
          } else {
            param.error = "Denominator cannot be zero.";
            return param;
          }
        } else {
          param.error = "Numerator cannot be zero.";
          return param;
        }
      } else {
        param.error = "Please Check Your Input";
        return param;
      }
    } else if (operations == 2) {
      if (!isNaN(first)) {
        if (first != 0) {
          let zz = first.toString().split(".");
          let answer = 1 / first;
          if (zz.length === 1) {
            param.tech_answer = answer;
          } else if (zz.length === 2) {
            let len = zz[1].length;
            let aja = "0".repeat(len);
            let upper = parseInt("1" + aja);
            let lower = first * upper;
            let totalN = upper;
            let totalD = lower;
            let g = gcd(totalN, totalD);
            let [upr, btm] = reduce(totalN, totalD);
            param.tech_upr = upr;
            param.tech_totalN = totalN;
            param.tech_totalD = totalD;
            param.tech_g = g;
            param.tech_btm = btm;
            param.tech_answer = answer;
            param.tech_upper = upper;
            param.tech_lower = lower;
          }
        } else {
          param.error = "The multiplicative inverse of 0 is undefined.";
          return param;
        }
      } else {
        param.error = "Please Check Your Input";
        return param;
      }
    } else if (operations == 3) {
      if (!isNaN(first) && !isNaN(second) && !isNaN(third)) {
        if (third != 0) {
          let totalD = third;
          let val1 = first;
          let totalN = totalD * val1 + second;
          let g = gcd(totalN, totalD);
          let [upr, btm] = reduce(totalN, totalD);
          param.tech_upr = upr;
          param.tech_totalN = totalN;
          param.tech_totalD = totalD;
          param.tech_g = g;
          param.tech_btm = btm;
        } else {
          param.error = "Denominator cannot be zero.";
          return param;
        }
      } else {
        param.error = "Please Check Your Input";
        return param;
      }
    }

    param.tech_operations = operations;
    return param;
  }

  /**
   * getCalculationVolumeOfTriangularPyramidCalculator: Service Method
   * POST: /api/calculators-lol/volume-of-triangular-pyramid
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationVolumeOfTriangularPyramidCalculator(body) {
    const selection = body.tech_selection;
    const triangle_type = body.tech_triangle_type;
    const base = body.tech_base;
    const base_unit = body.tech_base_unit;
    const base_height = body.tech_base_height;
    const base_height_unit = body.tech_base_height_unit;
    const pyramid_height = body.tech_pyramid_height;
    const pyramid_height_unit = body.tech_pyramid_height_unit;
    const pyramid_base_area = body.tech_pyramid_base_area;
    const pyramid_base_area_unit = body.tech_pyramid_base_area_unit;
    const sidea = body.tech_sidea;
    const sidea_length_unit = body.tech_sidea_length_unit;
    const sideb = body.tech_sideb;
    const sideb_length_unit = body.tech_sideb_length_unit;
    const sidec = body.tech_sidec;
    const sidec_length_unit = body.tech_sidec_length_unit;
    const angle_gamma = body.tech_angle_gamma;
    const angle_gamma_unit = body.tech_angle_gamma_unit;
    const angle_beta = body.tech_angle_beta;
    const angle_beta_unit = body.tech_angle_beta_unit;

    const param = {};

    // Helper function to convert length units to cm
    function unit_convert(unit, value) {
      const conversions = {
        mm: 0.1,
        cm: 1,
        m: 100,
        km: 100000,
        in: 2.54,
        ft: 30.48,
        yd: 91.44,
        mi: 160934,
      };
      return value * (conversions[unit] || 1);
    }

    // Helper function to convert angle units to radians
    function angle_convert(unit2, value2) {
      if (unit2 == "deg") {
        return value2 * 0.017453;
      } else if (unit2 == "rad") {
        return value2 * 1;
      }
      return value2;
    }

    // Helper function to convert area units to cm²
    function centi(unit3, value3) {
      const conversions = {
        "mm²": 0.01,
        "cm²": 1,
        "m²": 10000,
        "km²": 10000000000,
        "in²": 6.452,
        "ft²": 929,
        "yd²": 8361,
        "mi²": 25899881103,
      };
      return value3 * (conversions[unit3] || 1);
    }

    // Validate if input is numeric
    function isNumeric(value) {
      return !isNaN(parseFloat(value)) && isFinite(value);
    }

    let pba, volume;

    if (selection == "1") {
      // Calculate using triangle dimensions
      if (triangle_type == "1") {
        // Right Triangle: base, height, pyramid height
        if (
          isNumeric(base) &&
          isNumeric(base_height) &&
          isNumeric(pyramid_height)
        ) {
          const b_value = unit_convert(base_unit, parseFloat(base));
          const bh_value = unit_convert(
            base_height_unit,
            parseFloat(base_height)
          );
          const ph_value = unit_convert(
            pyramid_height_unit,
            parseFloat(pyramid_height)
          );
          pba = (b_value * bh_value) / 2;
          volume = (pba * ph_value) / 3;
        } else {
          param.error = "Please! Check your input";
          return param;
        }
      } else if (triangle_type == "2") {
        // Three sides (Heron's formula)
        if (
          isNumeric(sidea) &&
          isNumeric(sideb) &&
          isNumeric(sidec) &&
          isNumeric(pyramid_height)
        ) {
          const sa = parseFloat(sidea);
          const sb = parseFloat(sideb);
          const sc = parseFloat(sidec);

          // Validate triangle inequality
          if (sa > sb + sc) {
            param.error =
              "Side a must be less than the sum of the other two sides (b+c)";
            return param;
          } else if (sb > sa + sc) {
            param.error =
              "Side b must be less than the sum of the other two sides (a+c)";
            return param;
          } else if (sc > sa + sb) {
            param.error =
              "Side c must be less than the sum of the other two sides (a+b)";
            return param;
          } else {
            const sa_value = unit_convert(sidea_length_unit, sa);
            const sb_value = unit_convert(sideb_length_unit, sb);
            const sc_value = unit_convert(sidec_length_unit, sc);
            const ph_value = unit_convert(
              pyramid_height_unit,
              parseFloat(pyramid_height)
            );

            const sect_one = sa_value + sb_value + sc_value;
            const sect_two = -sa_value + sb_value + sc_value;
            const sect_three = sa_value - sb_value + sc_value;
            const sect_four = sa_value + sb_value - sc_value;

            pba =
              0.25 * Math.sqrt(sect_one * sect_two * sect_three * sect_four);
            volume = (pba * ph_value) / 3;
          }
        } else {
          param.error = "Please! Check your input";
          return param;
        }
      } else if (triangle_type == "3") {
        // Two sides and included angle
        if (
          isNumeric(sidea) &&
          isNumeric(sideb) &&
          isNumeric(angle_gamma) &&
          isNumeric(pyramid_height)
        ) {
          const sa_value = unit_convert(sidea_length_unit, parseFloat(sidea));
          const sb_value = unit_convert(sideb_length_unit, parseFloat(sideb));
          const alpha_value = angle_convert(
            angle_gamma_unit,
            parseFloat(angle_gamma)
          );

          if (angle_gamma_unit == "deg") {
            if (parseFloat(angle_gamma) < 180) {
              const ph_value = unit_convert(
                pyramid_height_unit,
                parseFloat(pyramid_height)
              );
              pba = sa_value * sb_value * Math.sin(alpha_value) * 0.5;
              volume = (pba * ph_value) / 3;
            } else {
              param.error = "Angles should be between 0 and 180 deg";
              return param;
            }
          } else if (angle_gamma_unit == "rad") {
            if (alpha_value < 3.14159) {
              const ph_value = unit_convert(
                pyramid_height_unit,
                parseFloat(pyramid_height)
              );
              pba = sa_value * sb_value * Math.sin(alpha_value) * 0.5;
              volume = (pba * ph_value) / 3;
            } else {
              param.error = "Angles should be between 0 and 180 deg";
              return param;
            }
          }
        } else {
          param.error = "Please! Check your input";
          return param;
        }
      } else if (triangle_type == "4") {
        // One side and two angles
        if (
          isNumeric(sidea) &&
          isNumeric(angle_beta) &&
          isNumeric(angle_gamma) &&
          isNumeric(pyramid_height)
        ) {
          const sa_value = unit_convert(sidea_length_unit, parseFloat(sidea));

          let alpha_value, beta_value;

          // Convert gamma angle
          if (angle_gamma_unit == "rad") {
            alpha_value = parseFloat(angle_gamma);
          } else if (angle_gamma_unit == "deg") {
            alpha_value = parseFloat(angle_gamma) * 0.017453;
          }

          // Convert beta angle
          if (angle_beta_unit == "rad") {
            beta_value = parseFloat(angle_beta);
          } else if (angle_beta_unit == "deg") {
            beta_value = parseFloat(angle_beta) * 0.017453;
          }

          // Convert to degrees for validation
          // const alpha_deg = angle_gamma_unit == "deg" ? parseFloat(angle_gamma) : parseFloat(angle_gamma) * 57.2958;
          // const beta_deg = angle_beta_unit == "deg" ? parseFloat(angle_beta) : parseFloat(angle_beta) * 57.2958;
          // dd($alpha_value,$angle_gamma,$ang);
          // console.log(alpha_deg,beta_deg);
          if (alpha_value < 180 && beta_value < 180) {
            if (alpha_value + beta_value < 180) {
              const ph_value = unit_convert(
                pyramid_height_unit,
                parseFloat(pyramid_height)
              );
              const sect1 =
                sa_value *
                sa_value *
                Math.sin(beta_value) *
                Math.sin(alpha_value);
              const sect2 = 2 * Math.sin(alpha_value + beta_value);
              pba = sect1 / sect2;
              volume = (pba * ph_value) / 3;
            } else {
              param.error = "The sum of the two angles cannot exceed 180 deg.";
              return param;
            }
          } else {
            param.error = "Angles should be between 0 and 180 deg range";
            return param;
          }
        } else {
          param.error = "Please! Check your input";
          return param;
        }
      }

      param.tech_pba = pba;
      param.tech_volume = volume;
    } else if (selection == "2") {
      // Calculate using base area directly
      if (isNumeric(pyramid_base_area) && isNumeric(pyramid_height)) {
        const pb_value = centi(
          pyramid_base_area_unit,
          parseFloat(pyramid_base_area)
        );
        const ph_value = unit_convert(
          pyramid_height_unit,
          parseFloat(pyramid_height)
        );
        volume = (pb_value * ph_value) / 3;
        param.tech_volume = volume;
      } else {
        param.error = "Please! Check your input";
        return param;
      }
    }

    return param;
  }

  /** getCalculationCofunctionCalculator
   * POST: /api/calculators-lol/cofunction-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCofunctionCalculator(body) {
    let func = body.tech_func;
    let angle = body.tech_angle;
    let unit = body.tech_unit;

    let param = {};

    if (!isNaN(func) && !isNaN(angle)) {
      let ang = angle;

      if (unit === "rad") {
        angle = (angle * 180) / Math.PI;
      }

      if (angle < 0 || angle > 90) {
        param["error"] =
          "Angle for cofunction identities is 0-90 degrees (or 0 - π/2 in radians).";
        return param;
      }

      let ang1 = 90 - angle;
      if (unit === "rad") {
        ang1 = (ang1 * Math.PI) / 180;
      }

      let ans, ans1;

      switch (parseInt(func)) {
        case 1: // sin
          ans = Math.sin((angle * Math.PI) / 180);
          if (angle == 30) ans1 = " = 1/2";
          else if (angle == 45) ans1 = " = √2/2";
          else if (angle == 60) ans1 = " = √3/2";
          break;
        case 2: // cos
          ans = Math.cos((angle * Math.PI) / 180);
          if (angle == 30) ans1 = " = √3/2";
          else if (angle == 45) ans1 = " = √2/2";
          else if (angle == 60) ans1 = " = 1/2";
          break;
        case 3: // tan
          ans = Math.tan((angle * Math.PI) / 180);
          if (angle == 30) ans1 = " = 1/√3 = √3/3";
          else if (angle == 60) ans1 = " = √3";
          break;
        case 4: // cot
          ans = 1 / Math.tan((angle * Math.PI) / 180);
          if (angle == 30) ans1 = " = √3";
          else if (angle == 60) ans1 = " = 1/√3 = √3/3";
          break;
        case 5: // sec
          ans = 1 / Math.cos((angle * Math.PI) / 180);
          if (angle == 30) ans1 = " = 2√3/3";
          else if (angle == 45) ans1 = " = √2";
          break;
        case 6: // csc
          ans = 1 / Math.sin((angle * Math.PI) / 180);
          if (angle == 45) ans1 = " = √2";
          else if (angle == 60) ans1 = " = 2√3/3";
          break;
        default:
          param["error"] = "Invalid function selected.";
          return param;
      }

      param["tech_ans"] = Number(ans.toFixed(8));
      param["tech_ang"] = Number(ang.toFixed(8));
      param["tech_ang1"] = Number(ang1.toFixed(8));
      if (ans1) param["tech_ans1"] = ans1;

      return param;
    } else {
      param["error"] = "Please Check Your Input.";
      return param;
    }
  }

  /**
   * getCalculationAreaCalculator: Service Method
   * POST: /api/calculators-lol/area-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationAreaCalculator(body) {
    const shapes = body.tech_shapes;
    const radius = body.tech_radius;
    const radius_unit = body.tech_radius_unit;
    const area = body.tech_area;
    const area_unit = body.tech_area_unit;
    const box = body.tech_box;
    const box_unit = body.tech_box_unit;
    const angle_alpha = body.tech_angle_alpha;
    const angle_alpha_unit = body.tech_angle_alpha_unit;
    const height = body.tech_height;
    const height_unit = body.tech_height_unit;
    const bara_radius = body.tech_bara_radius;
    const bara_radius_unit = body.tech_bara_radius_unit;
    const e = body.tech_e;
    const e_unit = body.tech_e_unit;
    const f = body.tech_f;
    const f_unit = body.tech_f_unit;
    const number_of_sides = body.tech_number_of_sides;
    const find_triangle = body.tech_find_triangle;
    const find_triangle_two = body.tech_find_triangle_two;
    const find_triangle_three = body.tech_find_triangle_three;
    const find_triangle_four = body.tech_find_triangle_four;
    const c = body.tech_c;
    const c_unit = body.tech_c_unit;
    const angle_gamma = body.tech_angle_gamma;
    const angle_gamma_unit = body.tech_angle_gamma_unit;
    const angle_beta = body.tech_angle_beta;
    const angle_beta_unit = body.tech_angle_beta_unit;
    const angle_theta = body.tech_angle_theta;
    const angle_theta_unit = body.tech_angle_theta_unit;

    const param = {};

    // Helper function to convert length units to cm
    function unit_convert(unit, value) {
      const conversions = {
        mm: 0.1,
        cm: 1,
        m: 100,
        km: 100000,
        in: 2.54,
        ft: 30.48,
        yd: 91.44,
        mi: 160934,
      };
      return value * (conversions[unit] || 1);
    }

    // Helper function to convert angle units to radians
    function angle_convert(unit2, value2) {
      if (unit2 == "deg") {
        return value2 * 0.017453;
      } else if (unit2 == "rad") {
        return value2 * 1;
      }
      return value2;
    }

    // Helper function to convert area units to cm²
    function centi(unit3, value3) {
      const conversions = {
        "mm²": 0.01,
        "cm²": 1,
        "m²": 10000,
        "km²": 10000000000,
        "in²": 6.452,
        "ft²": 929,
        "yd²": 8361,
        "mi²": 25899881103,
      };
      return value3 * (conversions[unit3] || 1);
    }

    // Validate if input is numeric
    function isNumeric(value) {
      return !isNaN(parseFloat(value)) && isFinite(value);
    }

    let answer, method;

    if (shapes == "square") {
      method = 1;
      if (isNumeric(area)) {
        const area_value = unit_convert(area_unit, parseFloat(area));
        answer = area_value * area_value;
        param.tech_area = isNaN(area) ? "NaN" : area;
      } else {
        param.error = "Please! Check your input";
        return param;
      }
    } else if (shapes == "rectangle") {
      method = 2;
      if (isNumeric(area) && isNumeric(box)) {
        const area_value = unit_convert(area_unit, parseFloat(area));
        const box_value = unit_convert(box_unit, parseFloat(box));
        param.tech_area = isNaN(area_value) ? "NaN" : area_value;
        param.tech_box = isNaN(box_value) ? "NaN" : box_value;
        answer = area_value * box_value;
      } else {
        param.error = "Please! Check your input";
        return param;
      }
    } else if (shapes == "triangle") {
      if (find_triangle == "1") {
        method = 31;
        if (isNumeric(box) && isNumeric(height)) {
          const box_value = unit_convert(box_unit, parseFloat(box));
          const height_value = unit_convert(height_unit, parseFloat(height));
          param.tech_height = isNaN(height_value) ? "NaN" : height_value;
          param.tech_box = isNaN(box_value) ? "NaN" : box_value;
          answer = (box_value * height_value) / 2;
        } else {
          param.error = "Please! Check your input";
          return param;
        }
      } else if (find_triangle == "2") {
        method = 32;
        if (isNumeric(box) && isNumeric(area) && isNumeric(c)) {
          const box_value = unit_convert(box_unit, parseFloat(box));
          const area_value = unit_convert(area_unit, parseFloat(area));
          const c_value = unit_convert(c_unit, parseFloat(c));
          const sect_one = area_value + box_value + c_value;
          const sect_two = -area_value + box_value + c_value;
          const sect_three = area_value - box_value + c_value;
          const sect_four = area_value + box_value - c_value;
          answer =
            0.25 * Math.sqrt(sect_one * sect_two * sect_three * sect_four);
          param.tech_area = isNaN(area_value) ? "NaN" : area_value;
          param.tech_box = isNaN(box_value) ? "NaN" : box_value;
          param.tech_c = isNaN(c_value) ? "NaN" : c_value;
        } else {
          param.error = "Please! Check your input";
          return param;
        }
      } else if (find_triangle == "3") {
        method = 33;
        if (isNumeric(area) && isNumeric(box) && isNumeric(angle_gamma)) {
          const box_value = unit_convert(box_unit, parseFloat(box));
          const area_value = unit_convert(area_unit, parseFloat(area));
          const gamma_value = angle_convert(
            angle_gamma_unit,
            parseFloat(angle_gamma)
          );
          answer = area_value * box_value * Math.sin(gamma_value) * 0.5;
          param.tech_area = isNaN(area_value) ? "NaN" : area_value;
          param.tech_box = isNaN(box_value) ? "NaN" : box_value;
          param.tech_gamma = isNaN(gamma_value) ? "NaN" : gamma_value;
        } else {
          param.error = "Please! Check your input";
          return param;
        }
      } else if (find_triangle == "4") {
        method = 34;
        if (
          isNumeric(area) &&
          isNumeric(angle_beta) &&
          isNumeric(angle_gamma)
        ) {
          const area_value = unit_convert(area_unit, parseFloat(area));
          const gamma_value = angle_convert(
            angle_gamma_unit,
            parseFloat(angle_gamma)
          );
          const beta_value = angle_convert(
            angle_beta_unit,
            parseFloat(angle_beta)
          );

          const gamma_deg =
            angle_gamma_unit == "deg"
              ? parseFloat(angle_gamma)
              : parseFloat(angle_gamma) * 57.2958;
          const beta_deg =
            angle_beta_unit == "deg"
              ? parseFloat(angle_beta)
              : parseFloat(angle_beta) * 57.2958;

          if (gamma_deg < 180 && beta_deg < 180) {
            if (gamma_deg + beta_deg < 180) {
              const sect1 =
                area_value *
                area_value *
                Math.sin(beta_value) *
                Math.sin(gamma_value);
              const sect2 = 2 * Math.sin(gamma_value + beta_value);
              answer = sect1 / sect2;
            } else {
              param.error = "The sum of the two angles cannot exceed 180 deg.";
              return param;
            }
          } else {
            param.error = "Angles should be between 0 and 180 deg range";
            return param;
          }
          param.tech_area = isNaN(area_value) ? "NaN" : area_value;
          param.tech_beta = isNaN(beta_value) ? "NaN" : beta_value;
          param.tech_gamma = isNaN(gamma_value) ? "NaN" : gamma_value;
        } else {
          param.error = "Please! Check your input";
          return param;
        }
      }
    } else if (shapes === "parallelogram") {
      if (find_triangle_two == "1") {
        method = 15;
        if (isNumeric(box) && isNumeric(height)) {
          const box_value = unit_convert(box_unit, parseFloat(box));
          const height_value = unit_convert(height_unit, parseFloat(height));
          param.tech_height = isNaN(height_value) ? "NaN" : height_value;
          param.tech_box = isNaN(box_value) ? "NaN" : box_value;

          answer = box_value * height_value;
        } else {
          param.error = "Please! Check your input";
          return param;
        }
      } else if (find_triangle_two == "2") {
        method = 16;
        if (isNumeric(area) && isNumeric(box) && isNumeric(angle_alpha)) {
          const area_value = unit_convert(area_unit, parseFloat(area));
          const box_value = unit_convert(box_unit, parseFloat(box));
          const alpha_value = angle_convert(
            angle_alpha_unit,
            parseFloat(angle_alpha)
          );
          param.tech_area = isNaN(area_value) ? "NaN" : area_value;
          param.tech_box = isNaN(box_value) ? "NaN" : box_value;
          param.tech_alpha = isNaN(alpha_value) ? "NaN" : alpha_value;
          answer = box_value * area_value * Math.sin(alpha_value);
        } else {
          param.error = "Please! Check your input";
          return param;
        }
      } else if (find_triangle_two == "3") {
        method = 17;
        if (isNumeric(e) && isNumeric(f) && isNumeric(angle_theta)) {
          const e_value = unit_convert(e_unit, parseFloat(e));
          const f_value = unit_convert(f_unit, parseFloat(f));
          const theta_value = angle_convert(
            angle_theta_unit,
            parseFloat(angle_theta)
          );
          param.tech_e = isNaN(e_value) ? "NaN" : e_value;
          param.tech_f = isNaN(f_value) ? "NaN" : f_value;
          param.tech_theta_value = isNaN(theta_value) ? "NaN" : theta_value;

          answer = e_value * f_value * Math.sin(theta_value);
        } else {
          param.error = "Please! Check your input";
          return param;
        }
      }
    } else if (shapes == "rhombus") {
      if (find_triangle_three == "1") {
        method = 21;
        if (isNumeric(area) && isNumeric(height)) {
          const area_value = unit_convert(area_unit, parseFloat(area));
          const height_value = unit_convert(height_unit, parseFloat(height));
          param.tech_height = isNaN(height_value) ? "NaN" : height_value;
          param.tech_area = isNaN(area_value) ? "NaN" : area_value;
          answer = area_value * height_value;
        } else {
          param.error = "Please! Check your input";
          return param;
        }
      } else if (find_triangle_three == "2") {
        method = 22;
        if (isNumeric(e) && isNumeric(f)) {
          const e_value = unit_convert(e_unit, parseFloat(e));
          const f_value = unit_convert(f_unit, parseFloat(f));
          param.tech_e = isNaN(e_value) ? "NaN" : e_value;
          param.tech_f = isNaN(f_value) ? "NaN" : f_value;
          answer = (e_value * f_value) / 2;
        } else {
          param.error = "Please! Check your input";
          return param;
        }
      } else if (find_triangle_three == "3") {
        method = 23;
        if (isNumeric(area) && isNumeric(angle_alpha)) {
          const area_value = unit_convert(area_unit, parseFloat(area));
          const alpha_value = angle_convert(
            angle_alpha_unit,
            parseFloat(angle_alpha)
          );
          param.tech_area = isNaN(area_value) ? "NaN" : area_value;
          param.tech_alpha_value = isNaN(alpha_value) ? "NaN" : alpha_value;

          answer = area_value * area_value * Math.sin(alpha_value);
        } else {
          param.error = "Please! Check your input";
          return param;
        }
      }
    } else if (shapes == "kite") {
      if (find_triangle_four == "2") {
        method = 24;
        if (isNumeric(area) && isNumeric(box) && isNumeric(angle_alpha)) {
          const area_value = unit_convert(area_unit, parseFloat(area));
          const box_value = unit_convert(box_unit, parseFloat(box));
          const alpha_value = angle_convert(
            angle_alpha_unit,
            parseFloat(angle_alpha)
          );
          param.tech_area = isNaN(area_value) ? "NaN" : area_value;
          param.tech_box = isNaN(box_value) ? "NaN" : box_value;
          param.tech_alpha = isNaN(alpha_value) ? "NaN" : alpha_value;
          answer = box_value * area_value * Math.sin(alpha_value);
        } else {
          param.error = "Please! Check your input";
          return param;
        }
      } else if (find_triangle_four == "1") {
        method = 25;
        if (isNumeric(e) && isNumeric(f)) {
          const e_value = unit_convert(e_unit, parseFloat(e));
          const f_value = unit_convert(f_unit, parseFloat(f));
          param.tech_e = isNaN(e_value) ? "NaN" : e_value;
          param.tech_f = isNaN(f_value) ? "NaN" : f_value;

          answer = (e_value * f_value) / 2;
        } else {
          param.error = "Please! Check your input";
          return param;
        }
      }
    } else if (shapes == "circle") {
      method = 4;
      if (isNumeric(radius)) {
        const radius_value = unit_convert(radius_unit, parseFloat(radius));
        answer = radius_value * radius_value * Math.PI;
        param.tech_radius = isNaN(radius_value) ? "NaN" : radius_value;
      } else {
        param.error = "Please! Check your input";
        return param;
      }
    } else if (shapes == "semicircle") {
      method = 5;
      if (isNumeric(radius)) {
        const radius_value = unit_convert(radius_unit, parseFloat(radius));
        answer = radius_value * radius_value * Math.PI * 0.5;
        param.tech_radius = isNaN(radius) ? "NaN" : radius;
      } else {
        param.error = "Please! Check your input";
        return param;
      }
    } else if (shapes == "sector") {
      method = 6;
      if (isNumeric(angle_alpha) && isNumeric(radius)) {
        const radius_value = unit_convert(radius_unit, parseFloat(radius));
        const angle_value = angle_convert(
          angle_alpha_unit,
          parseFloat(angle_alpha)
        );
        answer = (radius_value * radius_value * angle_value) / 2;
        param.tech_angle_value = isNaN(angle_value) ? "NaN" : angle_value;
        param.tech_radius = isNaN(radius) ? "NaN" : radius;
      } else {
        param.error = "Please! Check your input";
        return param;
      }
    } else if (shapes == "ellipse") {
      method = 7;
      if (isNumeric(area) && isNumeric(box)) {
        const area_value = unit_convert(area_unit, parseFloat(area));
        const box_value = unit_convert(box_unit, parseFloat(box));
        answer = area_value * box_value * Math.PI;
        param.tech_area = isNaN(area_value) ? "NaN" : area_value;
        param.tech_box = isNaN(box_value) ? "NaN" : box_value;
      } else {
        param.error = "Please! Check your input";
        return param;
      }
    } else if (shapes == "trapezoid") {
      method = 8;
      if (isNumeric(area) && isNumeric(box) && isNumeric(height)) {
        const area_value = unit_convert(area_unit, parseFloat(area));
        const box_value = unit_convert(box_unit, parseFloat(box));
        const height_value = unit_convert(height_unit, parseFloat(height));
        answer = ((area_value + box_value) * height_value) / 2;
        param.tech_area = isNaN(area_value) ? "NaN" : area_value;
        param.tech_box = isNaN(box_value) ? "NaN" : box_value;
        param.tech_height = isNaN(height_value) ? "NaN" : height_value;
      } else {
        param.error = "Please! Check your input";
        return param;
      }
    } else if (shapes == "regular pentagon") {
      method = 9;
      if (isNumeric(area)) {
        const area_value = unit_convert(area_unit, parseFloat(area));
        answer =
          (area_value * area_value * Math.sqrt(25 + 10 * Math.sqrt(5))) / 4;
        param.tech_area = isNaN(area_value) ? "NaN" : area_value;
      } else {
        param.error = "Please! Check your input";
        return param;
      }
    } else if (shapes == "regular hexagon") {
      method = 10;
      if (isNumeric(area)) {
        const area_value = unit_convert(area_unit, parseFloat(area));
        answer = (3 / 2) * Math.sqrt(3) * area_value * area_value;
        param.tech_area = isNaN(area_value) ? "NaN" : area_value;
      } else {
        param.error = "Please! Check your input";
        return param;
      }
    } else if (shapes == "regular octagon") {
      method = 11;
      if (isNumeric(area)) {
        const area_value = unit_convert(area_unit, parseFloat(area));
        answer = 2 * (1 + Math.sqrt(2)) * area_value * area_value;
        param.tech_area = isNaN(area_value) ? "NaN" : area_value;
      } else {
        param.error = "Please! Check your input";
        return param;
      }
    } else if (shapes == "annulus (ring)") {
      method = 12;
      if (isNumeric(radius) && isNumeric(bara_radius)) {
        const r_val = parseFloat(radius);
        const br_val = parseFloat(bara_radius);

        if (br_val > r_val) {
          const radius_value = unit_convert(radius_unit, r_val);
          const bara_radius_value = unit_convert(bara_radius_unit, br_val);
          answer =
            Math.PI *
            (bara_radius_value * bara_radius_value -
              radius_value * radius_value);
          param.tech_radius = isNaN(radius_value) ? "NaN" : radius_value;
          param.tech_bara_radius = isNaN(bara_radius_value)
            ? "NaN"
            : bara_radius_value;
        } else {
          param.error = "Radius R should be greater than r.";
          return param;
        }
      } else {
        param.error = "Please! Check your input";
        return param;
      }
    } else if (shapes == "irregular quadrilateral") {
      method = 13;
      if (isNumeric(e) && isNumeric(f) && isNumeric(angle_alpha)) {
        const e_value = unit_convert(e_unit, parseFloat(e));
        const f_value = unit_convert(f_unit, parseFloat(f));
        const angle_value = angle_convert(
          angle_alpha_unit,
          parseFloat(angle_alpha)
        );
        answer = e_value * f_value * Math.sin(angle_value);
        param.tech_e = isNaN(e_value) ? "NaN" : e_value;
        param.tech_f = isNaN(f_value) ? "NaN" : f_value;
        param.tech_angle_value = isNaN(angle_value) ? "NaN" : angle_value;
      } else {
        param.error = "Please! Check your input";
        return param;
      }
    } else if (shapes === "regular polygon") {
      method = 14;
      if (isNumeric(area) && isNumeric(number_of_sides)) {
        const area_value = unit_convert(area_unit, parseFloat(area));
        const n = parseFloat(number_of_sides);
        answer = (n * area_value * area_value * 1) / Math.tan(Math.PI / n) / 4;
        param.tech_number_of_sides = isNaN(number_of_sides)
          ? "NaN"
          : number_of_sides;
        param.tech_area = isNaN(area_value) ? "NaN" : area_value;
      } else {
        param.error = "Please! Check your input";
        return param;
      }
    }

    param.tech_answer = answer;
    param.tech_method = method;

    return param;
  }

  /** getCalculationAdditiveInverseCalculator
   * POST: /api/calculators-lol/additive-inverse-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAdditiveInverseCalculator(body) {
    let nbr = body.tech_nbr;

    let param = {};

    if (!isNaN(nbr)) {
      let ans = -1 * nbr;
      param["tech_ans"] = ans;
      return param;
    } else {
      param["error"] = "Please! Check Your Input.";
      return param;
    }
  }

  /** getCalculationMonomialCalculator
   * POST: /api/calculators-lol/monomial-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMonomialCalculator(body) {
    let equ = body.tech_equ;
    let param = {};

    if (equ && equ.trim() !== "") {
      let parem = equ;

      parem = parem.replace(/ /g, "");
      parem = parem.replace(/\+/g, "plus");
      parem = parem.replace(/{/g, "(");
      parem = parem.replace(/}/g, ")");
      parem = parem.replace(/e\^/g, "exp");
      parem = parem.replace(/exp\^/g, "exp");
      parem = parem.replace(/\^/g, "**");
      parem = parem.replace(/e\^sqrt\(x\)/g, "exp(2*x)");

      try {
        const response = await axios.post(
          "http://167.172.134.148/monomial",
          new URLSearchParams({ equ: parem }),
          { timeout: 120000 }
        );

        const buffer = response.data;

        param["tech_ans"] = buffer[1];
        return param;
      } catch (error) {
        param["error"] = "Please! Check Your Input.";
        return param;
      }
    } else {
      param["error"] = "Please! Check Your Input.";
      return param;
    }
  }

  /** getCalculationLongMultiplicationCalculator
   * POST: /api/calculators-lol/long-multiplication-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationLongMultiplicationCalculator(body) {
    let first = body.tech_first;
    let second = body.tech_second;
    let param = {};

    if (!isNaN(first) && !isNaN(second)) {
      let answer1 = first * second;
      let answer;

      let aa = answer1.toString().split(".");

      if (aa.length === 1) {
        answer = answer1.toString();
      } else if (aa.length === 2) {
        answer = aa[0] + aa[1];
      }

      let xx = first.toString().split(".");
      let yy = second.toString().split(".");
      let l1, l2, total;

      if (xx.length === 2) l1 = xx[1].length;
      if (yy.length === 2) l2 = yy[1].length;

      if (l1 && l2) {
        total = l1 + l2;
      } else {
        total = l1 || l2 || 0;
      }

      if (total > 0) {
        param[
          "tech_line1"
        ] = `The following decimals contain overall <b>${total}</b> decimal places`;
        param[
          "tech_line2"
        ] = `You just need to carry out long multiplication as you do with normal integers by ignoring the decimals.`;
        param[
          "tech_line3"
        ] = `In the final final, start from right to left and move up to <b>${total}</b> decimal places to insert the decimal. This is the final answer.`;
      }

      let firstClean = first.toString().replace(".", "");
      let secondClean = second.toString().replace(".", "");

      let absFirst = Math.abs(parseInt(firstClean));
      let absSecond = Math.abs(parseInt(secondClean));

      let answer2 = absFirst * absSecond;
      let f_len = absFirst.toString().length;
      let s_len = absSecond.toString().length;
      let col = answer.length;

      let f_array = absFirst.toString().split("");
      let s_array = absSecond.toString().split("");

      let arr_rev = [];
      let m_j = [];
      let upper, lower;

      if (f_len >= s_len) {
        let rev_array = [...s_array].reverse();
        arr_rev = rev_array;

        arr_rev.forEach((value) => {
          m_j.push(parseInt(value) * absFirst);
        });

        upper = f_array;
        lower = s_array;
      } else {
        let rev_array = [...f_array].reverse();
        arr_rev = rev_array;

        arr_rev.forEach((value) => {
          m_j.push(parseInt(value) * absSecond);
        });

        upper = s_array;
        lower = f_array;
      }

      let final = answer.split("");

      param["tech_upper"] = upper;
      param["tech_lower"] = lower;
      param["tech_col"] = col;
      param["tech_m_j"] = m_j;
      param["tech_final"] = final;
      param["tech_answer"] = answer;
      param["tech_answer1"] = answer1;

      return param;
    } else {
      param["error"] = "Please Check Your Input.";
      return param;
    }
  }

  /** getCalculationDivisibleCalculator
   * POST: /api/calculators-lol/divisible-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDivisibleCalculator(body) {
    let no = body.tech_no;
    let divisible = body.tech_divisible;
    let param = {};

    if (
      !isNaN(no) &&
      !isNaN(divisible) &&
      no > 0 &&
      divisible > 0 &&
      no >= divisible
    ) {
      no = parseInt(no);
      divisible = parseInt(divisible);

      let division = Math.floor(no / divisible);
      let modulus = no % divisible;

      let division_array = division.toString().split("");
      let divisible_array = divisible.toString().split("");
      let number_array = no.toString().split("");
      let counter = 1;
      let com = "";

      for (let i = 0; i < number_array.length; i++) {
        if (i === 0) {
          com = number_array[i];
        }
        if (parseInt(com) < divisible) {
          com = com + number_array[i + 1];
          counter += 1;
        }
      }

      let stokes = com;
      let com_array = com.toString().split("");

      let separate_values = [];
      for (let z = com_array.length; z < number_array.length; z++) {
        separate_values.push(number_array[z]);
      }

      let multiplication = [];
      let p_length = [];
      let tree = [];
      let read = [];
      let extra = [];

      for (let j = 0; j < division_array.length; j++) {
        let mult = divisible * parseInt(division_array[j]);
        multiplication.push(mult);
        let p = parseInt(com) - mult;
        p_length.push(p);
        tree.push(p);

        if (p < divisible) {
          if (typeof separate_values[j] !== "undefined") {
            com = p.toString() + separate_values[j];
            extra.push(com);
          }
        }

        read.push(com);
      }

      param["tech_stokes"] = stokes;
      param["tech_divisible_array"] = divisible_array;
      param["tech_number_array"] = number_array;
      param["tech_number"] = no;
      param["tech_divisible"] = divisible;
      param["tech_division"] = division;
      param["tech_modulus"] = modulus;
      param["tech_multiply"] = multiplication;
      param["tech_read"] = read;
      param["tech_com"] = com;
      param["tech_p_length"] = p_length;
      param["tech_tree_array"] = tree;

      return param;
    } else {
      param["error"] = "Please Enter Valid Input.";
      return param;
    }
  }

  /** getCalculationAverageValueFunctionCalculator
   * POST: /api/calculators-lol/average-value-of-function
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAverageValueFunctionCalculator(body) {
    let fun = body.tech_fun;
    let lb = body.tech_lb;
    let ub = body.tech_ub;

    let param = {};

    if (fun && !isNaN(lb) && !isNaN(ub)) {
      let vari = 0;
      let withVar = "";
      let value = fun
        .replace(/%20/g, "")
        .replace(/ /g, "")
        .replace(/plus/g, "+");

      // Detect the single variable used
      for (let char of "abcdefghijklmnopqrstuvwxyz") {
        if (new RegExp(char, "i").test(value)) {
          vari++;
          withVar = char;
        }
      }

      if (vari !== 1) {
        param["error"] = "The function contains more than one variable.";
        return param;
      }

      if (Number(lb) > Number(ub)) {
        param["error"] = "Upper Limit must be greater than Lower Limit.";
        return param;
      }

      let divide = ub - lb;

      // Format equation string
      let parem = fun;
      parem = parem.replace(/ /g, "");
      parem = parem.replace(/\+/g, "plus");
      parem = parem.replace(/{/g, "(");
      parem = parem.replace(/}/g, ")");
      parem = parem.replace(/e\^/g, "exp");
      parem = parem.replace(/exp\^/g, "exp");
      parem = parem.replace(/\^/g, "**");
      parem = parem.replace(/e\^sqrt\(x\)/g, "exp(2*x)");

      try {
        const response = await axios.post(
          "http://167.172.134.148/avg_fun",
          new URLSearchParams({
            equ: parem,
            wrt: withVar,
            ub: ub,
            lb: lb,
            divide: divide,
          }),
          { timeout: 120000 }
        );

        const buffer = response.data;

        param["tech_input"] = buffer[0];
        param["tech_sim"] = buffer[1];
        param["tech_ans"] = buffer[2];
        param["tech_with"] = withVar;
        param["tech_divide"] = divide;
        return param;
      } catch (err) {
        param["error"] = "Please! Check Your Input.";
        return param;
      }
    } else {
      param["error"] = "Please Check Your Input!";
      return param;
    }
  }

  /** getCalculationProductSumCalculator
   * POST: /api/calculators-lol/product-sum-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationProductSumCalculator(body) {
    let product = body.tech_product;
    let sum = body.tech_sum;
    let param = {};

    if (!isNaN(product) && !isNaN(sum)) {
      let A = 1;
      let B = -1 * sum;
      let C = product;

      let dis = Math.pow(B, 2) - 4 * A * C;

      if (dis > 0) {
        let x1 = Number(((-B + Math.sqrt(dis)) / (2 * A)).toFixed(4));
        let x2 = Number(((-B - Math.sqrt(dis)) / (2 * A)).toFixed(4));

        param["fact"] =
          `${A}(x ${x1 < 0 ? "+ " + Math.abs(x1) : "- " + x1} )` +
          `(x ${x2 < 0 ? "+ " + Math.abs(x2) : "- " + x2} )`;
        param["roots"] = `x₁ = ${x1} , x₂ = ${x2}`;
      } else if (dis < 0) {
        let real = Number((-B / (2 * A)).toFixed(4));
        let imag = Number((Math.sqrt(-dis) / (2 * A)).toFixed(4));

        let x1 = `${real} + ${imag}`;
        let x2 = `${real} - ${imag}`;

        param["tech_fact"] = `${A}(x - (${x1}\\,i) )(x - (${x2}\\,i) )`;
        param["tech_roots"] = `x₁ = ${x1} <i>i</i><br> x₂ = ${x2} <i>i</i>`;
      } else {
        let x1 = Number((-B / (2 * A)).toFixed(4));
        param["tech_fact"] = `${A}(x ${
          x1 < 0 ? "+ " + Math.abs(x1) : "- " + x1
        } )^2`;
        param["tech_roots"] = `x = ${x1}`;
      }

      param["tech_dis"] = dis;
      param["tech_a"] = A;
      param["tech_B"] = B;
      param["tech_C"] = C;
      return param;
    } else {
      param["error"] = "Please Check Your Input!";
      return param;
    }
  }

  /** getCalculationPascalTriangleCalculator
   * POST: /api/calculators-lol/pascals-triangle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPascalTriangleCalculator(body) {
    let method = body.tech_method;
    let row = body.tech_row;
    let to_row = body.tech_to_row;
    let column = body.tech_column;
    let param = {};

    if (method === "1") {
      if (!isNaN(row)) {
        row = parseInt(row);
        if (row >= 0) {
          if (row < 100) {
            param["row"] = row;
          } else {
            param["error"] = "The row must be less than 100.";
            return param;
          }
        } else {
          param["error"] = "The row must be non-negative.";
          return param;
        }
      } else {
        param["error"] = "Please! Check Your Input.";
        return param;
      }
    } else if (method === "2") {
      if (!isNaN(row)) {
        row = parseInt(row);
        if (row >= 0) {
          if (row >= 100) {
            param["error"] = "The row must be less than 100.";
            return param;
          }
        } else {
          param["error"] = "The row must be non-negative.";
          return param;
        }
      } else {
        param["error"] = "Please! Check Your Input.";
        return param;
      }
    } else if (method === "3") {
      if (!isNaN(row) && !isNaN(to_row)) {
        row = parseInt(row);
        to_row = parseInt(to_row);
        if (row >= 0 && to_row >= 0) {
          if (to_row >= row) {
            param["tech_col"] = to_row;
          } else {
            param["error"] =
              "The end-row must be at least equal to the one we started with.";
            return param;
          }
        } else {
          param["error"] = "The row must be non-negative.";
          return param;
        }
      } else {
        param["error"] = "Please! Check Your Input.";
        return param;
      }
    } else if (method === "4") {
      if (!isNaN(row) && !isNaN(column)) {
        row = parseInt(row);
        column = parseInt(column);
        if (row >= column && row > 0 && column > 0) {
          param["tech_column"] = column;
        } else {
          param["error"] = "Enter Row n ≥ Col k ≥ 0.";
          return param;
        }
      } else {
        param["error"] = "Please! Check Your Input.";
        return param;
      }
    }

    param["tech_row"] = row;
    param["tech_method"] = method;
    return param;
  }

  /**
   * getCalculationthirtytriangleCalculator: Service Method
   * POST: /api/calculators-lol/30-60-90-triangle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationthirtytriangleCalculator(body) {
    const sides = body.tech_sides;
    const input = body.tech_input;
    const linear_unit = body.tech_linear_unit;
    const square_unit = body.tech_square_unit;
    const param = {};

    // Helper function to convert length units to cm
    function again_unit_convert(unit, value) {
      const conversions = {
        mm: 0.1,
        cm: 1,
        m: 100,
        km: 100000,
        in: 2.54,
        ft: 30.48,
        yd: 91.44,
        mi: 160934,
      };
      return value * (conversions[unit] || 1);
    }

    // Helper function to convert area units to cm²
    function again_centi(unit3, value3) {
      const conversions = {
        "mm²": 0.01,
        "cm²": 1,
        "m²": 10000,
        "km²": 10000000000,
        "in²": 6.452,
        "ft²": 929,
        "yd²": 8361,
        "mi²": 25899881103,
      };
      return value3 * (conversions[unit3] || 1);
    }

    // Validate if input is numeric
    function isNumeric(value) {
      return !isNaN(parseFloat(value)) && isFinite(value);
    }

    if (!isNumeric(input)) {
      param.error = "Please Check Your Input.";
      return param;
    }

    let method, lena_val, b, c, area, peri, height, in_radius, radius;

    if (sides == "a") {
      // Given side 'a' (shortest side)
      method = 1;
      lena_val = again_unit_convert(linear_unit, parseFloat(input));
      b = Math.sqrt(3) * lena_val;
      c = 2 * lena_val;
      area = (lena_val * b) / 2;
      peri = lena_val + b + c;
      height = b / 2;
      in_radius = (lena_val * b) / peri;
      radius = c / 2;
    } else if (sides == "b") {
      // Given side 'b' (middle side)
      method = 2;
      b = again_unit_convert(linear_unit, parseFloat(input));
      lena_val = (b * Math.sqrt(3)) / 3;
      c = 2 * ((b * Math.sqrt(3)) / 3);
      area = (lena_val * b) / 2;
      peri = lena_val + b + c;
      height = b / 2;
      in_radius = (lena_val * b) / peri;
      radius = c / 2;
    } else if (sides == "c") {
      // Given side 'c' (hypotenuse)
      method = 3;
      c = again_unit_convert(linear_unit, parseFloat(input));
      b = (c * Math.sqrt(3)) / 2;
      lena_val = c / 2;
      area = (lena_val * b) / 2;
      peri = lena_val + b + c;
      height = b / 2;
      in_radius = (lena_val * b) / peri;
      radius = c / 2;
    } else if (sides == "h") {
      // Given height
      method = 4;
      height = again_unit_convert(linear_unit, parseFloat(input));
      b = height * 2;
      lena_val = b / Math.sqrt(3);
      c = 2 * lena_val;
      area = lena_val * lena_val * (Math.sqrt(3) / 2);
      peri = lena_val + b + c;
      in_radius = (lena_val * b) / peri;
      radius = c / 2;
    } else if (sides == "A") {
      // Given area
      method = 5;
      area = again_centi(square_unit, parseFloat(input));
      lena_val = Math.sqrt((2 * area) / Math.sqrt(3));
      b = lena_val * Math.sqrt(3);
      c = 2 * lena_val;
      height = (lena_val * b) / c;
      peri = lena_val + b + c;
      in_radius = (lena_val * b) / peri;
      radius = c / 2;
    } else if (sides == "p") {
      // Given perimeter
      method = 6;
      peri = again_unit_convert(linear_unit, parseFloat(input));
      lena_val = peri / (3 + Math.sqrt(3));
      b = lena_val * Math.sqrt(3);
      c = 2 * lena_val;
      height = (lena_val * b) / c;
      area = lena_val * lena_val * (Math.sqrt(3) / 2);
      in_radius = (lena_val * b) / peri;
      radius = c / 2;
    }

    // Round to 3 decimal places
    param.tech_method = method;
    param.tech_a = Math.round(lena_val * 1000) / 1000;
    param.tech_a_unit = linear_unit;
    param.tech_b = Math.round(b * 1000) / 1000;
    param.tech_b_unit = linear_unit;
    param.tech_c = Math.round(c * 1000) / 1000;
    param.tech_c_unit = linear_unit;
    param.tech_area_unit = square_unit;
    param.tech_perimeter_unit = linear_unit;
    param.tech_aa = Math.round(area * 1000) / 1000;
    param.tech_peri = Math.round(peri * 1000) / 1000;
    param.tech_height = Math.round(height * 1000) / 1000;
    param.tech_height_unit = linear_unit;
    param.tech_in_radius = Math.round(in_radius * 1000) / 1000;
    param.tech_radius = Math.round(radius * 1000) / 1000;

    return param;
  }

  /** getCalculationOrderOfOperationsCalculator
   * POST: /api/calculators-lol/order-of-operations-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationOrderOfOperationsCalculator(body) {
    let expression = body.tech_expression;

    let param = {};

    if (expression !== "") {
      let fixedstring = expression.replace(/ /g, "+");

      if (fixedstring) {
        param["tech_method"] = 1;
        param["tech_expression"] = fixedstring;
        return param;
      } else {
        param["error"] = "Please! Check Input.";
        return param;
      }
    } else {
      param["error"] = "Please! Check Input.";
      return param;
    }
  }

  /**
   * getCalculationTrigonometryCalculator: Service Method
   * POST: /api/calculators-lol/trigonometry-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTrigonometryCalculator(body) {
    const find = body.tech_find;
    const angle = body.tech_angle;
    const angle_unit = body.tech_angle_unit;

    const result = {};

    // Helper function: degrees to radians
    const deg2rad = (degrees) => degrees * (Math.PI / 180);

    // Helper function: radians to degrees
    const rad2deg = (radians) => radians * (180 / Math.PI);

    // Validate angle is numeric
    if (!angle || isNaN(angle)) {
      result.error = "Please Check Your Input.";
      return result;
    }

    const angleNum = parseFloat(angle);
    let method;

    // Case 1: Single trigonometric function
    if (["sin", "cos", "tan", "cot", "sec", "csc"].includes(find)) {
      method = 1;
      let ans1, ans2;

      if (angle_unit == "deg") {
        const radAngle = deg2rad(angleNum);

        switch (find) {
          case "sin":
            ans1 = Math.sin(radAngle);
            break;
          case "cos":
            ans1 = Math.cos(radAngle);
            break;
          case "tan":
            ans1 = Math.tan(radAngle);
            break;
          case "csc":
            ans1 = 1 / Math.sin(radAngle);
            break;
          case "sec":
            ans1 = 1 / Math.cos(radAngle);
            break;
          case "cot":
            ans1 = 1 / Math.tan(radAngle);
            break;
        }
        ans2 = radAngle;
      } else if (angle_unit == "rad") {
        switch (find) {
          case "sin":
            ans1 = Math.sin(angleNum);
            break;
          case "cos":
            ans1 = Math.cos(angleNum);
            break;
          case "tan":
            ans1 = Math.tan(angleNum);
            break;
          case "cot":
            ans1 = 1 / Math.tan(angleNum);
            break;
          case "csc":
            ans1 = 1 / Math.sin(angleNum);
            break;
          case "sec":
            ans1 = 1 / Math.cos(angleNum);
            break;
        }
        ans2 = rad2deg(angleNum);
      }

      result.tech_ans1 = isNaN(ans1) ? "NaN" : ans1;
      result.tech_ans2 = isNaN(ans2) ? "NaN" : ans2;
    }
    // Case 2: All trigonometric functions
    else if (find == "All") {
      method = 2;
      let sin, cos, tan, csc, sec, cot;
      let asin, acos, atan, acsc, asec, acot;
      let fns;

      if (angle_unit == "deg") {
        const radAngle = deg2rad(angleNum);

        sin = Math.sin(radAngle);
        cos = Math.cos(radAngle);
        tan = Math.tan(radAngle);
        csc = 1 / Math.sin(radAngle);
        sec = 1 / Math.cos(radAngle);
        cot = 1 / Math.tan(radAngle);

        asin = Math.asin(angleNum);
        acos = Math.acos(angleNum);
        atan = Math.atan(angleNum);
        acsc = Math.asin(1 / angleNum);
        asec = Math.acos(1 / angleNum);
        acot = Math.atan(1 / angleNum);

        fns = radAngle;
      } else if (angle_unit === "rad") {
        sin = Math.sin(angleNum);
        cos = Math.cos(angleNum);
        tan = Math.tan(angleNum);
        csc = 1 / Math.sin(angleNum);
        sec = 1 / Math.cos(angleNum);
        cot = 1 / Math.tan(angleNum);

        asin = Math.asin(angleNum);
        acos = Math.acos(angleNum);
        atan = Math.atan(angleNum);
        acsc = Math.asin(1 / angleNum);
        asec = Math.acos(1 / angleNum);
        acot = Math.atan(1 / angleNum);

        fns = rad2deg(angleNum);
      }

      result.tech_sin = isNaN(sin) ? "NaN" : sin;
      result.tech_cos = isNaN(cos) ? "NaN" : cos;
      result.tech_tan = isNaN(tan) ? "NaN" : tan;
      result.tech_csc = isNaN(csc) ? "NaN" : csc;
      result.tech_cot = isNaN(cot) ? "NaN" : cot;
      result.tech_sec = isNaN(sec) ? "NaN" : sec;
      result.tech_asin = isNaN(asin) ? "NaN" : asin;
      result.tech_acos = isNaN(acos) ? "NaN" : acos;
      result.tech_atan = isNaN(atan) ? "NaN" : atan;
      result.tech_acsc = isNaN(acsc) ? "NaN" : acsc;
      result.tech_acot = isNaN(acot) ? "NaN" : acot;
      result.tech_asec = isNaN(asec) ? "NaN" : asec;
      result.tech_fns = isNaN(fns) ? "NaN" : fns;
    }
    // Case 3: Inverse trigonometric functions
    else if (
      ["arcsin", "arccos", "arctan", "arccsc", "arcsec", "arccot"].includes(
        find
      )
    ) {
      method = 3;

      // Parse degrees, minutes, seconds
      const vars = angle.toString().split(".");
      let deg, min, sec;

      if (vars.length < 2) {
        deg = parseInt(vars[0]);
        min = 0;
        sec = 0;
      } else {
        deg = parseInt(vars[0]);
        let tempma = parseFloat("0." + vars[1]);
        tempma = tempma * 3600;
        min = Math.floor(tempma / 60);
        sec = Math.round((tempma - min * 60) * 1000) / 1000;
      }

      let rad;

      switch (find) {
        case "arcsin":
          rad = Math.asin(angleNum);
          break;
        case "arccos":
          rad = Math.acos(angleNum);
          break;
        case "arctan":
          rad = Math.atan(angleNum);
          break;
        case "arccsc":
          rad = Math.asin(1 / angleNum);
          break;
        case "arcsec":
          rad = Math.acos(1 / angleNum);
          break;
        case "arccot":
          rad = Math.atan(1 / angleNum);
          break;
      }

      deg = rad2deg(rad);

      result.rad = rad;
      result.deg = deg;
    }

    // Set group name based on function
    const groupMap = {
      sin: "Group 4",
      cos: "Group 3",
      tan: "Group 2",
      sec: "Group 6",
      csc: "Group 5",
      cot: "Group 1",
    };

    if (groupMap[find]) {
      result.tech_naam = groupMap[find];
    }

    result.tech_find = find;
    result.tech_angle = isNaN(angle) ? "NaN" : angle;
    result.tech_angle_unit = angle_unit;
    result.tech_method = method;

    return result;
  }

  /**
   * getCalculationSohcahtoaCalculator: Service Method
   * POST: /api/calculators-lol/sohcahtoa-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

   async  getCalculationSohcahtoaCalculator(body) {
      const len_a = body.tech_len_a;
      const len_a_unit = body.tech_len_a_unit;
      const len_b = body.tech_len_b;
      const len_b_unit = body.tech_len_b_unit;
      const len_c = body.tech_len_c;
      const len_c_unit = body.tech_len_c_unit;
      const area = body.tech_area;
      const area_unit = body.tech_area_unit;
      let angle_alpha = body.tech_angle_alpha;
      let angle_alpha_unit = body.tech_angle_alpha_unit;
      let angle_beta = body.tech_angle_beta;
      let angle_beta_unit = body.tech_angle_beta_unit;

      // Helper function for unit conversion
      function newUnitConvert(unit, value) {
        const conversions = {
          mm: 0.1,
          cm: 1,
          m: 100,
          km: 1000,
          in: 2.54,
          ft: 30.48,
          yd: 91.44,
          mi: 160934,
        };
        return value * (conversions[unit] || 1);
      }

      // Helper function for area conversion
      function newCenti(unit3, value3) {
        const conversions = {
          "mm²": 0.01,
          "cm²": 1,
          "m²": 10000,
          "km²": 10000000000,
          "in²": 6.452,
          "ft²": 929,
          "yd²": 8361,
          "mi²": 25899881103,
        };
        return value3 * (conversions[unit3] || 1);
      }

      // Convert angle units
      if (angle_alpha_unit === "rad") {
        angle_alpha_unit = 57.3;
      } else {
        angle_alpha_unit = 0.017453;
      }

      if (angle_beta_unit === "rad") {
        angle_beta_unit = 57.3;
      } else {
        angle_beta_unit = 0.017453;
      }

      const param = {};
      let method, a, b, c, anglea, angleb, area_value, peremter, height, R_cap, R_sml;

      const isNumeric = (val) => val !== null && val !== undefined && val !== "" && !isNaN(val);

      // Method 1: len_a and len_b
      if (isNumeric(len_a) && isNumeric(len_b)) {
        if (!isNumeric(len_c) && !isNumeric(area) && !isNumeric(angle_alpha) && !isNumeric(angle_beta)) {
          method = 1;
          a = parseFloat(len_a);
          b = parseFloat(len_b);

          c = Math.sqrt(a * a + b * b);
          anglea = b !== 0 ? Math.atan(a / b) : 0;
          angleb = a !== 0 ? Math.atan(b / a) : 0;
          area_value = (a * b) / 2;
          peremter = a + b + c;
          height = c !== 0 ? (a * b) / c : 0;
          R_cap = c / 2;
          R_sml = (a + b - c) / 2;

          param.tech_peremter = peremter;
          param.tech_area = area_value;
        } else {
          param.error = "Please! Enter only two values in one of the following fields.";
          return param;
        }
      }
      // Method 2: len_a and len_c
      else if (isNumeric(len_a) && isNumeric(len_c)) {
        if (parseFloat(len_a) >= parseFloat(len_c)) {
          param.error = "Hypotenuse (c) must be larger than leg (a)";
          return param;
        }
        if (!isNumeric(len_b) && !isNumeric(area) && !isNumeric(angle_alpha) && !isNumeric(angle_beta)) {
          method = 2;
          a = parseFloat(len_a);
          c = parseFloat(len_c);

          if (c * c >= a * a) {
            b = Math.sqrt(c * c - a * a);
          } else {
            b = 0;
          }

          anglea = b !== 0 ? Math.atan(a / b) : 0;
          angleb = a !== 0 ? Math.atan(b / a) : 0;
          area_value = (a * b) / 2;
          peremter = a + b + c;
          height = c !== 0 ? (a * b) / c : 0;
          R_cap = c / 2;
          R_sml = (a + b - c) / 2;

          param.tech_peremter = peremter;
          param.tech_area = area_value;
        } else {
          param.error = "Please! Enter only two values in one of the following fields.";
          return param;
        }
      }
      // Method 3: len_b and len_c
      else if (isNumeric(len_b) && isNumeric(len_c)) {
        if (!isNumeric(len_a) && !isNumeric(area) && !isNumeric(angle_alpha) && !isNumeric(angle_beta)) {
          method = 3;
          c = parseFloat(len_c);
          b = parseFloat(len_b);

          a = Math.sqrt(c * c - b * b);
          anglea = Math.atan(a / b);
          angleb = a !== 0 ? Math.atan(b / a) : 0;
          area_value = (a * b) / 2;
          height = c !== 0 ? (a * b) / c : 0;
          peremter = a + b + c;
          R_cap = c / 2;
          R_sml = (a + b - c) / 2;

          param.tech_peremter = peremter;
          param.tech_area = area_value;
        } else {
          param.error = "Please! Enter only two values in one of the following fields.";
          return param;
        }
      }
      // Method 4: angle_alpha and len_a
      else if (isNumeric(angle_alpha) && isNumeric(len_a)) {
        if (!isNumeric(len_b) && !isNumeric(len_c) && !isNumeric(angle_beta) && !isNumeric(area)) {
          method = 4;
          a = parseFloat(len_a);
          anglea = parseFloat(angle_alpha) * angle_alpha_unit;

          if (Math.tan(anglea) !== 0) {
            b = a / Math.tan(anglea);
          } else {
            b = 0;
          }

          c = Math.sqrt(a * a + b * b);
          angleb = a !== 0 ? Math.atan(b / a) : 0;
          area_value = (a * b) / 2;
          height = c !== 0 ? (a * b) / c : 0;
          peremter = a + b + c;
          R_cap = c / 2;
          R_sml = (a + b - c) / 2;

          param.tech_peremter = peremter;
          param.tech_area = area_value;
        } else {
          param.error = "Please! Enter only two values in one of the following fields.";
          return param;
        }
      }
      // Method 5: angle_alpha and len_b
      else if (isNumeric(angle_alpha) && isNumeric(len_b)) {
        if (!isNumeric(len_a) && !isNumeric(len_c) && !isNumeric(angle_beta) && !isNumeric(area)) {
          method = 5;
          b = parseFloat(len_b);
          anglea = parseFloat(angle_alpha) * angle_alpha_unit;

          a = b * Math.tan(anglea);
          c = Math.sqrt(a * a + b * b);
          angleb = a !== 0 ? Math.atan(b / a) : 0;
          area_value = (a * b) / 2;
          peremter = a + b + c;
          height = c !== 0 ? (a * b) / c : 0;
          R_cap = c / 2;
          R_sml = (a + b - c) / 2;

          param.tech_peremter = peremter;
          param.tech_area = area_value;
        } else {
          param.error = "Please! Enter only two values in one of the following fields.";
          return param;
        }
      }
      // Method 6: angle_alpha and len_c
      else if (isNumeric(angle_alpha) && isNumeric(len_c)) {
        if (!isNumeric(len_a) && !isNumeric(len_b) && !isNumeric(angle_beta) && !isNumeric(area)) {
          method = 6;
          c = parseFloat(len_c);
          anglea = parseFloat(angle_alpha) * angle_alpha_unit;

          a = c * Math.sin(anglea);
          b = c * Math.cos(anglea);
          angleb = a !== 0 ? Math.atan(b / a) : 0;
          area_value = (a * b) / 2;
          peremter = a + b + c;
          height = c !== 0 ? (a * b) / c : 0;
          R_cap = c / 2;
          R_sml = (a + b - c) / 2;

          param.tech_peremter = peremter;
          param.tech_area = area_value;
        } else {
          param.error = "Please! Enter only two values in one of the following fields.";
          return param;
        }
      }
      // Method 7: angle_beta and len_a
      else if (isNumeric(angle_beta) && isNumeric(len_a)) {
        if (!isNumeric(len_b) && !isNumeric(len_c) && !isNumeric(angle_alpha) && !isNumeric(area)) {
          method = 7;
          a = parseFloat(len_a);

          if (angle_beta_unit == "0.017453") {
            angleb = (parseFloat(angle_beta) * Math.PI) / 180;
            anglea = Math.PI / 2 - angleb;
          } else if (angle_beta_unit == "57.3") {
            anglea = Math.PI / 2 - parseFloat(angle_beta);
          } else {
            anglea = Math.PI / 2 - parseFloat(angle_beta);
          }

          if (Math.tan(anglea) !== 0) {
            b = a / Math.tan(anglea);
          } else {
            b = 0;
          }

          c = Math.sqrt(a * a + b * b);
          anglea = b !== 0 ? Math.atan(a / b) : 0;
          angleb = a !== 0 ? Math.atan(b / a) : 0;
          area_value = (a * b) / 2;
          peremter = a + b + c;
          height = c !== 0 ? (a * b) / c : 0;
          R_cap = c / 2;
          R_sml = (a + b - c) / 2;

          param.tech_peremter = peremter;
          param.tech_area = area_value;
        } else {
          param.error = "Please! Enter only two values in one of the following fields.";
          return param;
        }
      }
      // Method 8: angle_beta and len_b
      else if (isNumeric(angle_beta) && isNumeric(len_b)) {
        if (!isNumeric(len_a) && !isNumeric(len_c) && !isNumeric(angle_alpha) && !isNumeric(area)) {
          method = 8;
          b = parseFloat(len_b);

          if (angle_beta_unit == "0.017453") {
            angleb = (parseFloat(angle_beta) * Math.PI) / 180;
            anglea = Math.PI / 2 - angleb;
          } else if (angle_beta_unit == "57.3") {
            anglea = Math.PI / 2 - parseFloat(angle_beta);
          } else {
            anglea = Math.PI / 2 - parseFloat(angle_beta);
          }

          a = b * Math.tan(anglea);
          c = Math.sqrt(a * a + b * b);
          anglea = b !== 0 ? Math.atan(a / b) : 0;
          angleb = a !== 0 ? Math.atan(b / a) : 0;
          area_value = (a * b) / 2;
          peremter = a + b + c;
          height = c !== 0 ? (a * b) / c : 0;
          R_cap = c / 2;
          R_sml = (a + b - c) / 2;

          param.tech_peremter = peremter;
          param.tech_area = area_value;
        } else {
          param.error = "Please! Enter only two values in one of the following fields.";
          return param;
        }
      }
      // Method 9: angle_beta and len_c
      else if (isNumeric(angle_beta) && isNumeric(len_c)) {
        if (!isNumeric(len_a) && !isNumeric(len_b) && !isNumeric(angle_alpha) && !isNumeric(area)) {
          method = 9;
          c = parseFloat(len_c);

          if (angle_beta_unit == "0.017453") {
            angleb = (parseFloat(angle_beta) * Math.PI) / 180;
            anglea = Math.PI / 2 - angleb;
          } else if (angle_beta_unit == "57.3") {
            anglea = Math.PI / 2 - parseFloat(angle_beta);
          }

          a = c * Math.sin(anglea);
          b = c * Math.cos(anglea);
          anglea = b !== 0 ? Math.atan(a / b) : 0;
          angleb = a !== 0 ? Math.atan(b / a) : 0;
          area_value = (a * b) / 2;
          height = c !== 0 ? (a * b) / c : 0;
          peremter = a + b + c;
          R_cap = c / 2;
          R_sml = (a + b - c) / 2;

          param.tech_peremter = peremter;
          param.tech_area = area_value;
        } else {
          param.error = "Please! Enter only two values in one of the following fields.";
          return param;
        }
      }
      // Method 10: area and len_a
      else if (isNumeric(area) && isNumeric(len_a)) {
        if (!isNumeric(len_b) && !isNumeric(len_c) && !isNumeric(angle_alpha) && !isNumeric(angle_beta)) {
          method = 10;
          area_value = newCenti(area_unit, parseFloat(area));

          b = parseFloat(len_a) !== 0 ? (2 * area_value) / parseFloat(len_a) : 0;
          a = parseFloat(len_a);
          c = Math.sqrt(a * a + b * b);
          anglea = b !== 0 ? Math.atan(a / b) : 0;
          angleb = a !== 0 ? Math.atan(b / a) : 0;
          height = c !== 0 ? (a * b) / c : 0;
          peremter = a + b + c;
          R_cap = c / 2;
          R_sml = (a + b - c) / 2;

          param.tech_peremter = peremter;
          param.tech_area = area_value;
        } else {
          param.error = "Please! Enter only two values in one of the following fields.";
          return param;
        }
      }
      // Method 11: area and len_b
      else if (isNumeric(area) && isNumeric(len_b)) {
        if (!isNumeric(len_a) && !isNumeric(len_c) && !isNumeric(angle_alpha) && !isNumeric(angle_beta)) {
          method = 11;
          b = parseFloat(len_b);
          area_value = newCenti(area_unit, parseFloat(area));

          if (b == 0) {
            param.error = "Length b cannot be zero.";
            return param;
          }

          a = (2 * area_value) / b;
          c = Math.sqrt(a * a + b * b);
          anglea = b !== 0 ? Math.atan(a / b) : 0;
          angleb = a !== 0 ? Math.atan(b / a) : 0;
          peremter = a + b + c;
          height = c !== 0 ? (a * b) / c : 0;
          R_cap = c / 2;
          R_sml = (a + b - c) / 2;

          param.tech_peremter = peremter;
          param.tech_area = area_value;
        } else {
          param.error = "Please! Enter only two values in one of the following fields.";
          return param;
        }
      }
      // Method 12: area and len_c
      else if (isNumeric(area) && isNumeric(len_c)) {
        if (!isNumeric(len_a) && !isNumeric(len_b) && !isNumeric(angle_alpha) && !isNumeric(angle_beta)) {
          method = 12;
          c = parseFloat(len_c);
          area_value = newCenti(area_unit, parseFloat(area));

          const discriminant = Math.pow(c, 4) - 16 * Math.pow(area_value, 2);

          if (discriminant < 0) {
            param.error = "Invalid input values: discriminant is negative.";
            return param;
          }

          a = Math.sqrt((c * c + Math.sqrt(discriminant)) / 2);
          b = Math.sqrt((c * c - Math.sqrt(discriminant)) / 2);

          if (c == 0 || a == 0) {
            param.error = "Side length cannot be zero.";
            return param;
          }

          anglea = Math.asin(a / c);
          angleb = Math.atan(b / a);
          peremter = a + b + c;
          height = (a * b) / c;
          R_cap = c / 2;
          R_sml = (a + b - c) / 2;

          param.tech_peremter = peremter;
          param.tech_area = area_value;
        } else {
          param.error = "Please! Enter only two values in one of the following fields.";
          return param;
        }
      }
      // Method 13: area and angle_alpha
      else if (isNumeric(area) && isNumeric(angle_alpha)) {
        if (!isNumeric(len_a) && !isNumeric(len_b) && !isNumeric(len_c) && !isNumeric(angle_beta)) {
          method = 13;
          area_value = newCenti(area_unit, parseFloat(area));
          anglea = parseFloat(angle_alpha) * angle_alpha_unit;

          if (anglea == 0) {
            param.error = "Angle alpha cannot be zero.";
            return param;
          }

          a = Math.sqrt(2 * area_value * Math.tan(anglea));
          b = Math.sqrt((2 * area_value) / Math.tan(anglea));
          c = Math.sqrt(a * a + b * b);

          if (b == 0 || a == 0) {
            param.error = "Side length cannot be zero.";
            return param;
          }

          anglea = Math.atan(a / b);
          angleb = Math.atan(b / a);
          peremter = a + b + c;
          height = (a * b) / c;
          R_cap = c / 2;
          R_sml = (a + b - c) / 2;

          param.tech_peremter = peremter;
          param.tech_area = area_value;
        } else {
          param.error = "Please! Enter only two values in one of the following fields.";
          return param;
        }
      }
      // Method 14: area and angle_beta
      else if (isNumeric(area) && isNumeric(angle_beta)) {
        if (!isNumeric(len_a) && !isNumeric(len_b) && !isNumeric(len_c) && !isNumeric(angle_alpha)) {
          method = 14;
          area_value = newCenti(area_unit, parseFloat(area));
          angleb = parseFloat(angle_beta) * angle_beta_unit;

          if (angleb == 0) {
            param.error = "Angle beta cannot be zero.";
            return param;
          }

          a = Math.sqrt(2 * area_value * Math.tan(angleb));
          b = Math.sqrt((2 * area_value) / Math.tan(angleb));
          c = Math.sqrt(a * a + b * b);

          if (b == 0 || a == 0) {
            param.error = "Side length cannot be zero.";
            return param;
          }

          anglea = Math.atan(a / b);
          angleb = Math.atan(b / a);
          height = (a * b) / c;
          peremter = a + b + c;
          R_cap = c / 2;
          R_sml = (a + b - c) / 2;

          param.tech_peremter = peremter;
          param.tech_area = area_value;
        } else {
          param.error = "Please! Enter only two values in one of the following fields.";
          return param;
        }
      }
      // Both angles provided
      else if (isNumeric(angle_alpha) && isNumeric(angle_beta)) {
        if (!isNumeric(len_a) && !isNumeric(len_b) && !isNumeric(len_c) && !isNumeric(area)) {
          param.error = "Can not calculate based on 2 angles only.";
          return param;
        } else {
          param.error = "Please! Enter only two values in one of the following fields.";
          return param;
        }
      }

      // Set final results
      param.tech_R_cap = R_cap;
      param.tech_R_sml = R_sml;
      param.tech_height = height;
      param.tech_method = method;
      param.tech_a = a;
      param.tech_b = b;
      param.tech_c = c;
      param.tech_anglea = anglea;
      param.tech_angleb = angleb;
      param.tech_RESULT = 1;

      return param;
    }


  /** getCalculationCharacteristicPolynomialCalculator
   * POST: /api/calculators-lol/characteristic-polynomial-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCharacteristicPolynomialCalculator(body) {
    let matrix22 = body.tech_matrix22;

    let second_matrix = [];
    for (let i = 1; i <= matrix22; i++) {
      for (let j = 1; j <= matrix22; j++) {
        let key = `tech_matrix3${i}_${j}`;
        if (body.hasOwnProperty(key) && !isNaN(body[key])) {
          second_matrix.push(parseFloat(body[key]));
        }
      }
    }

    let mul = matrix22 * matrix22;
    if (mul !== second_matrix.length) {
      return { error: "Please! Check Your Input." };
    }

    let zain = [];
    for (let i = 0; i < matrix22; i++) {
      zain.push(second_matrix.slice(i * matrix22, (i + 1) * matrix22));
    }

    let advance = [];
    for (let i = 0; i < second_matrix.length; i++) {
      if (i % (matrix22 + 1) === 0) {
        advance.push(`${second_matrix[i]}-λ`);
      } else {
        advance.push(`${second_matrix[i]}`);
      }
    }

    let val_array = [];
    for (let i = 0; i < advance.length; i += matrix22) {
      val_array.push(advance.slice(i, i + matrix22));
    }

    let input = [];
    for (let rowIndex = 0; rowIndex < val_array.length; rowIndex++) {
      let row = val_array[rowIndex];
      for (let i = 0; i < row.length; i++) {
        input.push(row[i]);
        if (i < row.length - 1) {
          input.push(",");
        }
      }
      if (rowIndex < val_array.length - 1) {
        input.push("@@");
      }
    }

    let mat = input.join("");
    let param = {};

    try {
      const response = await axios.post(
        "http://167.172.134.148/characteristic",
        new URLSearchParams({ mat }),
        { timeout: 120000 }
      );

      let buffer = response.data.split("@@@");
      param["tech_answer"] = buffer[0];
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }

    param["tech_matrix"] = val_array;
    param["tech_input_ma"] = zain;
    return param;
  }

  /** getCalculationXAndYInterceptsCalculator
   * POST: /api/calculators-lol/intercepts-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationXAndYInterceptsCalculator(body) {
    let EnterEq = body.tech_EnterEq;

    // Basic validation
    if (!EnterEq || /<|>|&|php|print_r|print|echo|script|%/i.test(EnterEq)) {
      return { error: "Please Enter Valid Input." };
    }

    // Sanitize expression
    let parem = EnterEq.replace(/ /g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/log/g, "ln")
      .replace(/=/g, "-")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    let param = {};

    try {
      const response = await axios.post(
        "http://167.172.134.148/intercepts",
        new URLSearchParams({ equ: parem }),
        { timeout: 120000 }
      );

      const buffer = response.data;

      let equation = buffer[0];
      let xIntercepts = buffer[1]
        .split(",")
        .map((item) => (item === "\\left[ \\right]" ? "0" : `${item},0`));
      let yIntercept =
        buffer[2] === "\\left[ \\right]" ? "0,0" : `0,${buffer[2]}`;
      yIntercept = yIntercept.replace(/\\left\[|\\right\]/g, "");

      param["tech_equation"] = equation;
      param["tech_buffer_zero"] = xIntercepts;
      param["tech_c"] = xIntercepts.length;
      param["tech_buffer_one"] = yIntercept;
      param["tech_method"] = buffer[3];

      return param;
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }

  /**
   * getCalculationComparingDecimalCalculator: Service Method
   * POST: /api/calculators-lol/comparing-decimals-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationComparingDecimalCalculator(body) {
    const first = body.tech_first;
    const second = body.tech_second;

    // Check if both values are numeric
    if (!isNaN(first) && !isNaN(second)) {
      return {
        tech_first: first,
        tech_second: second,
      };
    } else {
      return {
        error: "Please Check Your Input.",
      };
    }
  }

  /** getCalculationDomainAndRangeCalculator
   * POST: /api/calculators-lol/domain-and-range-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDomainAndRangeCalculator(body) {
    let eq = body.tech_eq;

    if (!eq) {
      return { error: "Please Check Your Input." };
    }

    // Input validation
    const invalidPattern =
      /<|>|&|php|print_r|print|echo|script|=|sin|cos|tan|arcsin|arccos|arctan|%/i;
    if (invalidPattern.test(eq)) {
      return { error: "Please Enter Valid Input." };
    }

    // Sanitize equation
    let parem = eq
      .replace(/ /g, "")
      .replace(/\+/g, "plus")
      .replace(/%20/g, "")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

    try {
      const response = await axios.post(
        "http://167.172.134.148/domain",
        new URLSearchParams({ equ: parem }),
        { timeout: 120000 }
      );

      const buffer = response.data;

      return {
        tech_domain: buffer[0],
        tech_range: buffer[1],
      };
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationDistanceBetweenTwoPointsCalculator
   * POST: /api/calculators-lol/distance-between-two-points-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationDistanceBetweenTwoPointsCalculator(body) {
    let x1 = body.tech_x1;
    let y1 = body.tech_y1;
    let x2 = body.tech_x2;
    let y2 = body.tech_y2;
    if (isNumeric(x1) && isNumeric(y1) && isNumeric(x2) && isNumeric(y2)) {
      let dx = x2 - x1;
      let dy = y2 - y1;
      let ans =
        Math.round(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)) * 10000) /
        10000;

      return {
        tech_ans: ans,
      };
    } else {
      return {
        error: "Please Check Your Input.",
      };
    }

    function isNumeric(value) {
      return !isNaN(parseFloat(value)) && isFinite(value);
    }
  }

  /** getCalculationSASTriangleCalculator
   * POST: /api/calculators-lol/sas-triangle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationSASTriangleCalculator(body) {
    let first = body.tech_first;
    let unit1 = body.tech_unit1;
    let second = body.tech_second;
    let unit2 = body.tech_unit2;
    let third = body.tech_third;
    let unit3 = body.tech_unit3;

    function toCm(unit, value) {
      switch (unit) {
        case "mm":
          return value / 10;
        case "cm":
          return value;
        case "m":
          return value * 100;
        case "in":
          return value * 2.54;
        case "ft":
          return value * 30.48;
        default:
          return NaN;
      }
    }

    function toDeg(unit, value) {
      switch (unit) {
        case "pi":
          return value * 57.2958;
        case "deg":
          return value;
        default:
          return NaN;
      }
    }

    let a = toCm(unit1, first);
    let b = toCm(unit2, second);
    let C = toDeg(unit3, third);

    if ([a, b, C].every((x) => typeof x === "number" && !isNaN(x))) {
      let c = Math.sqrt(
        a ** 2 + b ** 2 - 2 * a * b * Math.cos((C * Math.PI) / 180)
      );
      c = Math.round(c * 1000) / 1000;

      let p = a + b + c;
      let s = p / 2;
      let t = Math.sqrt(s * (s - a) * (s - b) * (s - c));
      t = Math.round(t * 10000) / 10000;

      let h_a = (2 * t) / a;
      let h_b = (2 * t) / b;
      let h_c = (2 * t) / c;

      let alpha =
        (Math.acos((b ** 2 + c ** 2 - a ** 2) / (2 * b * c)) * 180) / Math.PI;
      let beta =
        (Math.acos((a ** 2 + c ** 2 - b ** 2) / (2 * a * c)) * 180) / Math.PI;
      let gamma = 180 - alpha - beta;

      let r = t / s;
      let R = (a * b * c) / (4 * r * s);

      let m_a = Math.sqrt(2 * b ** 2 + 2 * c ** 2 - a ** 2) / 2;
      let m_b = Math.sqrt(2 * c ** 2 + 2 * a ** 2 - b ** 2) / 2;
      let m_c = Math.sqrt(2 * a ** 2 + 2 * b ** 2 - c ** 2) / 2;

      return {
        tech_a: a,
        tech_b: b,
        tech_c: c,
        tech_t: t,
        tech_s: s,
        tech_p: p,
        tech_alpha: alpha,
        tech_beta: beta,
        tech_gema: gamma,
        tech_h_a: h_a,
        tech_h_b: h_b,
        tech_h_c: h_c,
        tech_m_a: m_a,
        tech_m_b: m_b,
        tech_m_c: m_c,
        tech_r: r,
        tech_R: R,
      };
    } else {
      return { error: "Please Check Your Input." };
    }
  }

  /**
   * getCalculationLogBase2Calculator: Service Method
   * POST: /api/calculators-lol/log-base-2-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLogBase2Calculator(body) {
    const input = body.tech_input;

    if (typeof input === "number") {
      const answer = Math.log2(input);

      return {
        tech_answer: answer,
      };
    } else {
      return {
        error: "Please Check Your Input.",
      };
    }
  }

  /** getCalculationRadiusCircleCalculator
   * POST: /api/calculators-lol/radius-of-a-circle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationRadiusCircleCalculator(body) {
    let operations = body.tech_operations;
    let first = body.tech_first;
    let unit1 = body.tech_unit1;
    let second = body.tech_second;
    let unit2 = body.tech_unit2;

    let foot, centi;
    function conCm(a, b) {
      if (a == "mm") {
        centi = b / 10;
      } else if (a == "cm") {
        centi = b * 1;
      } else if (a == "dm") {
        centi = b * 10;
      } else if (a == "m") {
        centi = b * 100;
      } else if (a == "km") {
        centi = b * 100000;
      } else if (a == "in") {
        centi = b * 2.54;
      } else if (a == "ft") {
        centi = b * 30.48;
      } else if (a == "yd") {
        centi = b * 91.44;
      } else if (a == "mi") {
        centi = b * 160900;
      } else if (a == "nmi") {
        centi = b * 185200;
      }
      return centi;
    }
    function conCmSq(a, b) {
      if (a == "mm²") {
        foot = b / 10;
      } else if (a == "cm²") {
        foot = b * 1;
      } else if (a == "dm²") {
        foot = b * 10;
      } else if (a == "m²") {
        foot = b * 100;
      } else if (a == "km²") {
        foot = b * 100000;
      } else if (a == "in²") {
        foot = b * 2.54;
      } else if (a == "ft²") {
        foot = b * 30.48;
      } else if (a == "yd²") {
        foot = b * 91.44;
      } else if (a == "mi²") {
        foot = b * 160900;
      } else if (a == "a") {
        foot = b * 1000000;
      } else if (a == "da") {
        foot = b * 1000;
      } else if (a == "ha") {
        foot = b * 100000000;
      } else if (a == "ac") {
        foot = b * 40468564.224;
      } else if (a == "sf") {
        foot = b * 71224673.03424;
      }
      return foot;
    }

    let radius, diameter, area, circum;

    if (operations === "1") {
      let converted = conCm(unit1, first);
      if (isFinite(converted)) {
        radius = converted / (2 * 3.14);
        diameter = 2 * radius;
        area = Math.pow(radius, 2) * 3.14;
        return {
          tech_diameter: diameter,
          tech_area: area,
          tech_radius: radius,
        };
      }
    } else if (operations === "2") {
      let converted = conCmSq(unit2, second);
      if (isFinite(converted)) {
        radius = Math.sqrt(converted / 3.14);
        diameter = 2 * radius;
        circum = 2 * 3.14 * radius;
        return {
          tech_diameter: diameter,
          tech_radius: radius,
          tech_circum: circum,
        };
      }
    } else if (operations === "3") {
      let converted = conCm(unit1, first);
      if (isFinite(converted)) {
        radius = converted / 2;
        circum = 2 * 3.14 * radius;
        area = Math.pow(radius, 2) * 3.14;
        return {
          tech_radius: radius,
          tech_circum: circum,
          tech_area: area,
        };
      }
    }

    return { error: "Please Check Your Input." };
  }

  /** getCalculationEquilateralTriangleCalculator
   * POST: /api/calculators-lol/equilateral-triangle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationEquilateralTriangleCalculator(body) {
    let operations = body.tech_operations;
    let first = body.tech_first;
    let unit1 = body.tech_unit1;
    let a, p, s, k, h;

    if (operations === "side" && isFinite(first)) {
      a = first;
      p = a * 3;
      s = (3 * a) / 2;
      k = (1 / 4) * Math.sqrt(3) * Math.pow(a, 2);
      h = (1 / 2) * Math.sqrt(3) * a;
    } else if (operations === "perimeter" && isFinite(first)) {
      a = first / 3;
      p = first;
      s = (3 * a) / 2;
      k = (1 / 4) * Math.sqrt(3) * Math.pow(a, 2);
      h = (1 / 2) * Math.sqrt(3) * a;
    } else if (operations === "semiperimeter" && isFinite(first)) {
      a = (first * 2) / 3;
      p = 3 * a;
      s = first;
      k = (1 / 4) * Math.sqrt(3) * Math.pow(a, 2);
      h = (1 / 2) * Math.sqrt(3) * a;
    } else if (operations === "area" && isFinite(first)) {
      a = 2 * Math.sqrt(first / Math.sqrt(3));
      p = 3 * a;
      s = (3 * a) / 2;
      k = first;
      h = (1 / 2) * Math.sqrt(3) * a;
    } else if (operations === "altitude" && isFinite(first)) {
      a = 2 * Math.sqrt(3) * first;
      p = 3 * a;
      s = (3 * a) / 2;
      k = (1 / 4) * Math.sqrt(3) * Math.pow(a, 2);
      h = first;
    } else {
      return { error: "Please Check Your Input." };
    }

    return {
      tech_a: a,
      tech_k: k,
      tech_p: p,
      tech_s: s,
      tech_h: h,
      tech_unit: unit1,
    };
  }

  /** getCalculationPointOfIntersectionCalculator
   * POST: /api/calculators-lol/point-of-intersection
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPointOfIntersectionCalculator(body) {
    let x1 = parseFloat(body.tech_x1);
    let y1 = parseFloat(body.tech_y1);
    let c1 = parseFloat(body.tech_c1);
    let x2 = parseFloat(body.tech_x2);
    let y2 = parseFloat(body.tech_y2);
    let c2 = parseFloat(body.tech_c2);

    let result = {};

    if (
      !isNaN(x1) &&
      !isNaN(y1) &&
      !isNaN(c1) &&
      !isNaN(x2) &&
      !isNaN(y2) &&
      !isNaN(c2)
    ) {
      if ((x1 === x2 && y1 === y2) || (x1 === y1 && x2 === y2)) {
        result.x = "-Infinity";
        result.y = "Infinity";
        result.error = "Both Lines are Parallel.";
        return result;
      }

      c1 = -c1;
      c2 = -c2;
      let const1 = -c1;
      let const2 = -c2;

      let x = (y1 * c2 - y2 * c1) / (x1 * y2 - x2 * y1);
      let y = (x2 * c1 - x1 * c2) / (x1 * y2 - x2 * y1);

      let x1num = y1 * c2 - y2 * c1;
      let x1den = x1 * y2 - x2 * y1;
      let y1num = x2 * c1 - x1 * c2;
      let y1den = x1 * y2 - x2 * y1;

      let th = 0;
      let Line1 = {};
      let Line2 = {};

      let max = Math.max(Math.abs(x), Math.abs(y));
      th = Math.round(max) + 100;

      for (let i = -th; i < th; i++) {
        Line1[i] = const1 / y1 - (x1 * i) / y1;
        Line2[i] = const2 / y2 - (x2 * i) / y2;
      }

      result.tech_x = x;
      result.tech_y = y;
      result.tech_th = th;
      result.tech_x1num = x1num;
      result.tech_x1den = x1den;
      result.tech_y1num = y1num;
      result.tech_y1den = y1den;
      result.tech_Line1 = Line1;
      result.tech_Line2 = Line2;
      return result;
    } else {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /** getCalculationExponentialFunctionCalculator
   * POST: /api/calculators-lol/exponential-function-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationExponentialFunctionCalculator(body) {
    let t1 = parseFloat(body.tech_t1);
    let y1 = parseFloat(body.tech_y1);
    let t2 = parseFloat(body.tech_t2);
    let y2 = parseFloat(body.tech_y2);
    let point_optional =
      body.tech_point_optional !== undefined
        ? parseFloat(body.tech_point_optional)
        : null;

    let result = {};

    if (!isNaN(t1) && !isNaN(y1) && !isNaN(t2) && !isNaN(y2)) {
      if (y1 !== y2 && t1 !== t2 && y1 > 0 && y2 > 0) {
        let y = y1 / y2;
        let natural_log = Math.log(y);
        let time_minus = t1 - t2;
        let time = 1 / time_minus;
        let k = parseFloat((time * natural_log).toFixed(4));

        let exp_power = -1 * k * t2;
        let e = Math.exp(exp_power);
        let A = parseFloat((y2 * e).toFixed(4));

        let exp_fun =
          point_optional !== null
            ? Math.exp(k * point_optional)
            : Math.exp(k * 2);

        let f = parseFloat((A * exp_fun).toFixed(4));

        result.tech_k = k;
        result.tech_A = A;
        result.tech_f = f;
        return result;
      } else {
        result.error = "Please! Check Your Input.";
        return result;
      }
    } else {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /**
   * getCalculationFortyFivetriangleCalculator: Service Method
   * POST: /api/calculators-lol/45-45-90-triangle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationFortyFivetriangleCalculator(body) {
    let sides = body.tech_sides;
    let input = body.tech_input;
    let linear_unit = body.tech_linear_unit;
    let square_unit = body.tech_square_unit;

    const result = {};

    // Helper function: Convert length units to centimeters
    function unitConvert(unit, value) {
      const conversions = {
        mm: 0.1,
        cm: 1,
        m: 100,
        km: 1000,
        in: 2.54,
        ft: 30.48,
        yd: 91.44,
        mi: 160934,
      };
      return value * (conversions[unit] || 1);
    }

    // Helper function: Convert area units to square centimeters
    function centi(unit3, value3) {
      const conversions = {
        "mm²": 0.01,
        "cm²": 1,
        "m²": 10000,
        "km²": 10000000000,
        "in²": 6.452,
        "ft²": 929,
        "yd²": 8361,
        "mi²": 25899881103,
      };
      return value3 * (conversions[unit3] || 1);
    }

    // Validate input is numeric
    if (!input || isNaN(input)) {
      result.error = "Please! Check Your Input.";
      return result;
    }

    const inputNum = parseFloat(input);
    let a_ans, b_ans, c_ans, area_ans, perimeter_ans;
    let user_input;

    // Calculate based on which side is given
    switch (sides) {
      case "a":
        user_input = unitConvert(linear_unit, inputNum);
        a_ans = user_input;
        b_ans = user_input;
        c_ans = user_input * Math.sqrt(2);
        area_ans = Math.pow(user_input, 2) / 2;
        perimeter_ans = user_input * 3.41421356;
        break;

      case "b":
        user_input = unitConvert(linear_unit, inputNum);
        c_ans = user_input * Math.sqrt(2);
        a_ans = user_input;
        b_ans = user_input;
        area_ans = Math.pow(user_input, 2) / 2;
        perimeter_ans = user_input * 3.41421356;
        break;

      case "c":
        user_input = unitConvert(linear_unit, inputNum);
        c_ans = user_input;
        a_ans = user_input / 1.4142135;
        b_ans = a_ans;
        area_ans = Math.pow(a_ans, 2) / 2;
        perimeter_ans = a_ans * 3.41421356;
        break;

      case "area":
        user_input = centi(square_unit, inputNum);
        area_ans = user_input;
        a_ans = Math.sqrt(user_input * 2);
        b_ans = a_ans;
        c_ans = a_ans * Math.sqrt(2);
        perimeter_ans = a_ans * 3.41421356;
        break;

      case "perimeter":
        user_input = unitConvert(linear_unit, inputNum);
        perimeter_ans = user_input;
        a_ans = user_input / 3.41421356;
        b_ans = a_ans;
        c_ans = a_ans * Math.sqrt(2);
        area_ans = Math.pow(a_ans, 2) / 2;
        break;

      default:
        result.error = "Please! Check Your Input.";
        return result;
    }

    // Calculate height and radius
    const height = c_ans / 2;
    const radius = a_ans - height;
    result.tech_a_ans = isNaN(a_ans) ? "NaN" : a_ans;
    result.tech_b_ans = isNaN(b_ans) ? "NaN" : b_ans;
    result.tech_c_ans = isNaN(c_ans) ? "NaN" : c_ans;
    result.tech_area_ans = isNaN(area_ans) ? "NaN" : area_ans;
    result.tech_perimeter_ans = isNaN(perimeter_ans) ? "NaN" : perimeter_ans;
    result.tech_height = isNaN(height) ? "NaN" : height;
    result.tech_radius = isNaN(radius) ? "NaN" : radius;

    return result;
  }

  /**
   * getCalculationAbsoluteChangeCalculator: Service Method
   * POST: /api/calculators-lol/absolute-change-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAbsoluteChangeCalculator(body) {
    const initial = body.tech_initial;
    const final = body.tech_final;

    if (typeof initial === "number" && typeof final === "number") {
      const answer = final - initial;

      return {
        tech_answer: answer,
        tech_initial: initial,
        tech_final: final,
      };
    } else {
      return {
        error: "Please Check Your Input.",
      };
    }
  }

  /** getCalculationPowerof10Calculator
   * POST: /api/calculators-lol/power-of-10-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationPowerof10Calculator(body) {
    let input = body.tech_input;

    let result = {};

    try {
      // Safely evaluate the input using Function constructor instead of eval
      let exp = Function('"use strict"; return (' + input + ")")();

      if (typeof exp === "number" && !isNaN(exp)) {
        let output = Math.pow(10, exp);
        result.tech_result = output;
        result.tech_x = exp;
      } else {
        result.error = "Please! Check Your Input.";
      }
    } catch (e) {
      result.error = "Please! Check Your Input.";
    }

    return result;
  }

  /**
   * getCalculationSquereRootCurveCalculator: Service Method
   * POST: /api/calculators-lol/square-root-curve-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSquereRootCurveCalculator(body) {
    const percentage = body.tech_percentage;

    if (typeof percentage === "number" && !isNaN(percentage)) {
      if (percentage <= 0) {
        return {
          error:
            "Number of percentage grade value cannot be equal to or less than zero.",
        };
      }

      const answer = Math.sqrt(percentage) * 10;

      return {
        tech_answer: answer,
        tech_percentage: percentage,
      };
    } else {
      return {
        error: "Please Check Your Input.",
      };
    }
  }

  /**
   * getCalculationRoundtoTheNearestCentCalculator: Service Method
   * POST: /api/calculators-lol/round-to-the-nearest-cent
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRoundtoTheNearestCentCalculator(body) {
    const value = body.tech_round;

    if (typeof value === "number" && !isNaN(value)) {
      const result = Math.round(value * 100) / 100; // Round to 2 decimal places
      return {
        tech_result: result,
      };
    } else {
      return {
        error: "Please Check Your Input.",
      };
    }
  }

  /** getCalculationSlopePercentageCalculator
   * POST: /api/calculators-lol/slope-percentage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationSlopePercentageCalculator(body) {
    let rise = parseFloat(body.tech_rise);
    let run = parseFloat(body.tech_run);
    let rise_unit = body.tech_rise_unit;
    let run_unit = body.tech_run_unit;

    let result = {};

    // Unit conversion for rise
    if (rise_unit) {
      if (rise_unit == "m") {
        rise = rise;
      } else if (rise_unit == "mm") {
        rise = rise * 1000;
      } else if (rise_unit == "cm") {
        rise = rise * 100;
      } else if (rise_unit == "km") {
        rise = rise * 0.001;
      } else if (rise_unit == "in") {
        rise = rise * 39.37;
      } else if (rise_unit == "ft") {
        rise = rise * 3.281;
      }
    }
    if (run_unit) {
      if (run_unit == "m") {
        run = run;
      } else if (run_unit == "mm") {
        run = run * 1000;
      } else if (run_unit == "cm") {
        run = run * 100;
      } else if (run_unit == "km") {
        run = run * 0.001;
      } else if (run_unit == "in") {
        run = run * 39.37;
      } else if (run_unit == "ft") {
        run = run * 3.281;
      }
    }

    if (!isNaN(rise)) {
      if (run === 0) {
        result.error = "The run cannot be zero.";
        return result;
      }

      let slopePercentage = (rise / run) * 100;
      let slopeAngle = Math.atan(rise / run);
      let slopeAngleDegrees = slopeAngle * (180 / Math.PI);

      result.tech_slopeAngle = slopeAngle;
      result.tech_slopeAngleDegrees = slopeAngleDegrees;
      result.tech_slopePercentage = slopePercentage;
      return result;
    } else {
      result.error = "Please check your input.";
      return result;
    }
  }

  /** getCalculationChangeOfBaseFormulaCalculator
   * POST: /api/calculators-lol/change-of-base-formula-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationChangeOfBaseFormulaCalculator(body) {
    let x = parseFloat(body.tech_x);
    let a = parseFloat(body.tech_a);
    let b = parseFloat(body.tech_b);

    let result = {};

    if (!isNaN(x) && !isNaN(a) && !isNaN(b)) {
      if (a <= 0) {
        result.error =
          "Number of 'a' value cannot be equal to or less than zero.";
        return result;
      }

      if (b <= 0) {
        result.error =
          "Number of 'b' value cannot be equal to or less than zero.";
        return result;
      }

      let log_one = Math.log(x) / Math.log(a); // log base a of x
      let log_two = Math.log(x) / Math.log(b); // log base b of x
      let log_three = Math.log(a) / Math.log(b); // log base b of a

      if (log_three <= 0) {
        result.error =
          "Logarithm of a or b cannot be equal to or less than zero.";
        return result;
      }

      let answer = log_two / log_three;

      result.tech_answer = answer;
      result.tech_log_one = log_one;
      result.tech_log_two = log_two;
      result.tech_log_three = log_three;
      return result;
    } else {
      result.error = "Please Check Your Input.";
      return result;
    }
  }

  /** getCalculationCompletingTheSquareCalculator
   * POST: /api/calculators-lol/completing-the-square-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCompletingTheSquareCalculator(body) {
    let A = parseFloat(body.tech_A);
    let B = parseFloat(body.tech_B);
    let C = parseFloat(body.tech_C);

    let result = {};

    if (!isNaN(A) && !isNaN(B) && !isNaN(C)) {
      if (A === 0) {
        result.error = "A cannot be zero.";
        return result;
      }

      let firstx = +(-B / (2 * A)).toFixed(3);
      let first_part = A * Math.pow(firstx, 2);
      let second_part = B * firstx;

      let eq = "";
      if (second_part < 0 && C < 0) {
        eq = `${first_part} ${second_part} ${C}`;
      } else if (second_part < 0 && C >= 0) {
        eq = `${first_part} ${second_part} + ${C}`;
      } else if (second_part >= 0 && C < 0) {
        eq = `${first_part} + ${second_part} ${C}`;
      } else {
        eq = `${first_part} + ${second_part} + ${C}`;
      }

      let yaxis;
      try {
        yaxis = Function('"use strict"; return (' + eq + ")")();
        yaxis = +yaxis.toFixed(3);
      } catch (e) {
        result.error = "Invalid expression generated.";
        return result;
      }

      let left_side = B / A;
      let C_ = -C / A;
      let right_side = C_ + Math.pow(B, 2) / Math.pow(2 * A, 2);

      let x1, x2;

      if (right_side > 0) {
        x1 = +(-left_side / 2 + Math.sqrt(right_side)).toFixed(4);
        x2 = +(-left_side / 2 - Math.sqrt(right_side)).toFixed(4);
        result.tech_fact =
          `${A}(x ${x1 < 0 ? "+ " + -x1 : "- " + x1})` +
          `(x ${x2 < 0 ? "+ " + -x2 : "- " + x2})`;
        result.tech_roots = `x₁ = ${x1} , x₂ = ${x2}`;
      } else if (right_side < 0) {
        let imaginary = Math.sqrt(-right_side).toFixed(4);
        let base = (-left_side / 2).toFixed(4);
        x1 = `${base} + ${imaginary}`;
        x2 = `${base} - ${imaginary}`;
        result.tech_fact = `${A}(x - (${x1} i))(x - (${x2} i))`;
        result.tech_roots = `x₁ = ${x1} i<br> x₂ = ${x2} i`;
      } else {
        x1 = +(-left_side / 2).toFixed(4);
        result.tech_fact = `${A}(x ${x1 < 0 ? "+ " + -x1 : "- " + x1})^2`;
        result.tech_roots = `x = ${x1}`;
      }

      result.tech_B = B;
      result.tech_C = C;
      result.tech_x1 = x1;
      result.tech_x2 = x2 || null;
      return result;
    } else {
      result.error = "Please Check Your Input.";
      return result;
    }
  }

  /** getCalculationCubeRootCalculator
   * POST: /api/calculators-lol/cube-root-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationCubeRootCalculator(body) {
    let number = parseFloat(body.tech_number);
    let result = {};

    if (!isNaN(number)) {
      let cube_root = Math.cbrt(number); // Handles negative numbers correctly
      result.tech_cube_root = cube_root;
      return result;
    } else {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /** getCalculationTruncatedPyramidCalculator
   * POST: /api/calculators-lol/truncated-pyramid-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationTruncatedPyramidCalculator(body) {
    let ubl = parseFloat(body.tech_ubl);
    let ubw = parseFloat(body.tech_ubw);
    let lbl = parseFloat(body.tech_lbl);
    let lbw = parseFloat(body.tech_lbw);
    let height = parseFloat(body.tech_height);

    let result = {};

    if (
      !isNaN(ubl) &&
      !isNaN(ubw) &&
      !isNaN(lbl) &&
      !isNaN(lbw) &&
      !isNaN(height)
    ) {
      let DL = +Math.sqrt(Math.pow(lbl, 2) + Math.pow(lbw, 2)).toFixed(2);
      let DT = +Math.sqrt(Math.pow(ubl, 2) + Math.pow(ubw, 2)).toFixed(2);
      let dia = DL / 2 - DT / 2;
      let HL = +Math.sqrt(Math.pow(dia, 2) + Math.pow(height, 2)).toFixed(2);

      let sL = lbl / 2;
      let sW = lbw / 2;
      let si = ubl / 2;
      let sw = ubw / 2;

      let c1 = sW - sw;
      let c2 = sL - si;

      let slA = +Math.sqrt(Math.pow(c1, 2) + Math.pow(height, 2)).toFixed(2);
      let slB = +Math.sqrt(Math.pow(c2, 2) + Math.pow(height, 2)).toFixed(2);

      let a = +(Math.asin(height / HL) * (180 / Math.PI)).toFixed(2);
      let b = +(Math.atan(height / c1) * (180 / Math.PI)).toFixed(2);
      let c = +(Math.atan(height / c2) * (180 / Math.PI)).toFixed(2);

      result.tech_DL = DL;
      result.tech_DT = DT;
      result.tech_HL = HL;
      result.tech_slA = slA;
      result.tech_slB = slB;
      result.tech_a = a;
      result.tech_b = b;
      result.tech_c = c;
      return result;
    } else {
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /**
   * getCalculationVolumeOfSquareCalculator: Service Method
   * POST: /api/calculators-lol/volume-of-square
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationVolumeOfSquareCalculator(body) {
    let {
      tech_length,
      tech_length_unit,
      tech_height,
      tech_height_unit,
      tech_width,
      tech_width_unit,
    } = body;

    tech_length = parseFloat(tech_length);
    tech_height = parseFloat(tech_height);
    tech_width = parseFloat(tech_width);

    function convertToInches(unit, value) {
      switch (unit) {
        case "mm":
          return value / 25.4;
        case "cm":
          return value / 2.54;
        case "m":
          return value * 39.37;
        case "km":
          return value * 39370;
        case "in":
          return value;
        case "ft":
          return value * 12;
        case "yd":
          return value * 36;
        case "mi":
          return value * 63360;
        default:
          return value;
      }
    }

    if (!isNaN(tech_length) && !isNaN(tech_height) && !isNaN(tech_width)) {
      const convertedLength = convertToInches(tech_length_unit, tech_length);
      const convertedHeight = convertToInches(tech_height_unit, tech_height);
      const convertedWidth = convertToInches(tech_width_unit, tech_width);

      const answer = convertedLength * convertedHeight * convertedWidth;

      return {
        tech_answer: answer,
      };
    } else {
      return {
        error: "Please Check Your Input.",
      };
    }
  }

  /**
   * getCalculationeUcGpaCalculator: Service Method
   * POST: /api/calculators-lol/uc-gpa-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationeUcGpaCalculator(body) {
    try {
      const { currentCGPA, creditsCompleted, semesters } = body;

      let totalGradePoints = 0;
      let totalCredits = 0;
      let semesterResults = [];

      // Calculate previous coursework if provided
      if (currentCGPA && creditsCompleted) {
        const prevCGPA = parseFloat(currentCGPA);
        const prevCredits = parseFloat(creditsCompleted);
        totalGradePoints += prevCGPA * prevCredits;
        totalCredits += prevCredits;
      }

      // Calculate each semester
      if (semesters && Array.isArray(semesters)) {
        semesters.forEach((semester, semesterIndex) => {
          let semesterGradePoints = 0;
          let semesterCredits = 0;
          let semesterCourses = [];

          if (semester.courses && Array.isArray(semester.courses)) {
            semester.courses.forEach((course, courseIndex) => {
              const credits = parseFloat(course.credits);
              const gradePoint = parseFloat(course.grade); // Direct numeric value from dropdown

              if (!isNaN(credits) && !isNaN(gradePoint)) {
                const courseGradePoints = credits * gradePoint;
                semesterGradePoints += courseGradePoints;
                semesterCredits += credits;

                semesterCourses.push({
                  courseName: course.courseName || `Course ${courseIndex + 1}`,
                  grade: course.grade, // Numeric value
                  gradePoint: gradePoint,
                  credits: credits,
                  gradePoints: parseFloat(courseGradePoints.toFixed(2)),
                });
              }
            });
          }

          // Calculate semester GPA
          let semesterGPA = 0;
          if (semesterCredits > 0) {
            semesterGPA = semesterGradePoints / semesterCredits;
          }

          semesterResults.push({
            semesterName:
              semester.semesterName || `Semester ${semesterIndex + 1}`,
            courses: semesterCourses,
            totalCredits: semesterCredits,
            semesterGPA: parseFloat(semesterGPA.toFixed(2)),
            semesterGradePoints: parseFloat(semesterGradePoints.toFixed(2)),
          });

          // Add to overall totals
          totalGradePoints += semesterGradePoints;
          totalCredits += semesterCredits;
        });
      }

      // Calculate cumulative GPA
      let cumulativeGPA = 0;
      if (totalCredits > 0) {
        cumulativeGPA = totalGradePoints / totalCredits;
      }

      // Format results
      const result = {
        success: true,
        cumulativeGPA: parseFloat(cumulativeGPA.toFixed(2)),
        totalGradePoints: parseFloat(totalGradePoints.toFixed(2)),
        totalCredits: totalCredits,
        semesters: semesterResults,
      };

      return result;
    } catch (error) {
      console.error("Error in UC GPA calculation:", error);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  /** getCalculationMixedNumberCalculator
   * POST: /api/calculators-lol/mixed-number-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationMixedNumberCalculator(body) {
    let n1 = parseFloat(body.tech_n1);
    let d1 = parseFloat(body.tech_d1);
    let n2 = parseFloat(body.tech_n2);
    let d2 = parseFloat(body.tech_d2);
    let s1 = parseFloat(body.tech_s1);
    let s2 = parseFloat(body.tech_s2);
    let action = body.tech_action;

    let result = {};

    if (!isNaN(n1) && !isNaN(d1) && !isNaN(n2) && !isNaN(d2)) {
      // Convert to improper fractions if whole parts exist
      if (!isNaN(s1)) {
        if (s1 < 0 && n1 > 0) n1 *= -1;
        n1 = d1 * s1 + n1;
      }
      if (!isNaN(s2)) {
        if (s2 < 0 && n2 > 0) n2 *= -1;
        n2 = d2 * s2 + n2;
      }

      let totalN = 0,
        totalD = 0;

      switch (action) {
        case "+":
          totalN = n1 * d2 + n2 * d1;
          totalD = d1 * d2;
          break;
        case "-":
          totalN = n1 * d2 - n2 * d1;
          totalD = d1 * d2;
          break;
        case "×":
          totalN = n1 * n2;
          totalD = d1 * d2;
          break;
        case "÷":
          totalN = n1 * d2;
          totalD = n2 * d1;
          break;
        default:
          result.error = "Invalid operation";
          return result;
      }

      // GCD and Reduce
      function gcd(a, b) {
        a = Math.abs(a);
        b = Math.abs(b);
        if (b === 0) return 1;
        while (b !== 0) {
          [a, b] = [b, a % b];
        }
        return a;
      }

      function reduce(num, den) {
        let g = gcd(num, den);
        return [num / g, den / g];
      }

      let g = gcd(totalN, totalD);
      let [upr, btm] = reduce(totalN, totalD);

      result.tech_upr = upr;
      result.tech_btm = btm;
      result.tech_N1 = n1;
      result.tech_N2 = n2;
      result.tech_D1 = d1;
      result.tech_D2 = d2;
      result.tech_totalN = totalN;
      result.tech_totalD = totalD;
      result.tech_g = g;

      return result;
    } else {
      result.error = "Please fill all fields.";
      return result;
    }
  }

  /** getCalculationFractionSimplifierCalculator
   * POST: /api/calculators-lol/fraction-simplifier-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationFractionSimplifierCalculator(body) {
    let n1 = parseFloat(body.tech_n1); // Optional whole number
    let n2 = parseFloat(body.tech_n2); // Numerator
    let d1 = parseFloat(body.tech_d1); // Denominator

    let result = {};

    if (!isNaN(n2) && !isNaN(d1)) {
      let totalN = n2;
      let totalD = d1;

      if (!isNaN(n1)) {
        if (n1 < 0 && totalN > 0) {
          totalN *= -1;
        }
        totalN = totalD * n1 + totalN;
      }

      function gcd(a, b) {
        a = Math.abs(a);
        b = Math.abs(b);
        while (b !== 0) {
          [a, b] = [b, a % b];
        }
        return a || 1;
      }

      function reduce(num, den) {
        const g = gcd(num, den);
        return [num / g, den / g];
      }

      const g = gcd(totalN, totalD);
      const [upr, btm] = reduce(totalN, totalD);

      result.tech_upr = upr;
      result.tech_btm = btm;
      result.tech_totalN = totalN;
      result.tech_totalD = totalD;
      result.tech_g = g;
      return result;
    } else {
      result.error = "Please Check Your Input.";
      return result;
    }
  }

  /** getCalculationDeterminantCalculator
   * POST: /api/calculators-lol/determinant-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDeterminantCalculator(body) {
    let det = 0;
    let check = true;

    let dtrmn_slct_method = body.tech_dtrmn_slct_method;

    dtrmn_slct_method = parseInt(dtrmn_slct_method);
    if (![2, 3, 4, 5].includes(dtrmn_slct_method)) {
      return { error: "Matrix size not supported. Only 2x2 to 5x5 supported." };
    }

    let matrix = [];

    for (let i = 0; i < dtrmn_slct_method; i++) {
      let row = [];
      for (let j = 0; j < dtrmn_slct_method; j++) {
        let key = `tech_dtrmn_${i}_${j}`;
        let val = parseFloat(body[key]);
        if (isNaN(val)) {
          return { error: "Please Check Your Input." };
        }
        row.push(val);
      }
      matrix.push(row);
    }

    try {
      det = math.round(math.det(matrix), 6);
      return {
        tech_ans: det,
      };
    } catch (e) {
      return { error: "Determinant could not be calculated." };
    }
  }

  /**
   * getCalculationParabolaCalculator: Service Method
   * POST: /api/calculators-lol/parabola-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationParabolaCalculator(body) {
    const param = {};
    const from = body.tech_from;

    // GCD helper function
    function gcd(a, b) {
      a = Math.abs(a);
      b = Math.abs(b);
      if (b == 0) return a;
      return gcd(b, a % b);
    }

    // Numeric check helper
    function isNumeric(value) {
      return !isNaN(parseFloat(value)) && isFinite(value);
    }

    // Common calculations function
    function performCalculations(a, b, c, from, axis = null) {
      // Calculate h (vertex x-coordinate)
      let h1 = -1 * b;
      let h2 = 2 * a;
      let gcdVal = gcd(h1, h2);
      h1 = h1 / gcdVal;
      h2 = h2 / gcdVal;
      let hf = "ni";
      if (h1 % h2 == 0) {
        hf = h1 / h2;
      }
      const hf_ = h1 / h2;

      // Calculate k (vertex y-coordinate)
      let k1 = Math.pow(b, 2);
      let k2 = 4 * a;
      gcdVal = gcd(k1, k2);
      k1 = k1 / gcdVal;
      k2 = k2 / gcdVal;
      k1 = c * k2 - k1;
      let kf = "ni";
      if (k1 % k2 == 0) {
        kf = k1 / k2;
      }
      const kf_ = k1 / k2;

      // Calculate focus
      let fu1 = Math.pow(b, 2) - 1;
      let fu2 = 4 * a;
      gcdVal = gcd(fu1, fu2);
      fu1 = fu1 / gcdVal;
      fu2 = fu2 / gcdVal;
      fu1 = c * fu2 - fu1;
      let fuf = "ni";
      if (fu1 % fu2 == 0) {
        fuf = fu1 / fu2;
      }

      // Calculate directrix
      let dir1 = Math.pow(b, 2) + 1;
      let dir2 = 4 * a;
      gcdVal = gcd(dir1, dir2);
      dir1 = dir1 / gcdVal;
      dir2 = dir2 / gcdVal;
      let dirf = "ni";
      if (dir1 % dir2 == 0) {
        dirf = dir1 / dir2;
      }
      dir1 = c * dir2 - dir1;

      // Calculate x-intercepts
      const x_inter = -1 * (k1 / k2);
      if (x_inter >= 0) {
        const x_inter_sqrt = Math.sqrt(x_inter / a);
        const rith = h1 / h2;
        const x_inter1 =
          Math.round((rith + x_inter_sqrt) * 100000000) / 100000000;
        const x_inter2 =
          Math.round((rith - x_inter_sqrt) * 100000000) / 100000000;
        param["tech_x_inter1"] = x_inter1;
        param["tech_x_inter2"] = x_inter2;
      }

      // Calculate y-intercept
      const y_inter = (a * Math.pow(h1 / h2, 2) * k2 + k1) / k2;

      // Set all parameters
      if (axis) param["tech_axis"] = axis;
      param["tech_a"] = a;
      param["tech_b"] = b;
      param["tech_c"] = c;
      param["tech_h1"] = h1;
      param["tech_hf"] = hf;
      param["tech_hf_"] = hf_;
      param["tech_kf"] = kf;
      param["tech_kf_"] = kf_;
      param["tech_h2"] = h2;
      param["tech_k1"] = k1;
      param["tech_k2"] = k2;
      param["tech_fu1"] = fu1;
      param["tech_fu2"] = fu2;
      param["tech_fuf"] = fuf;
      param["tech_y_inter"] = y_inter;
      param["tech_dir1"] = dir1;
      param["tech_dir2"] = dir2;
      param["tech_dirf"] = dirf;
      param["tech_from"] = from;
      param["RESULT"] = 1;

      return param;
    }

    try {
      // Form 1: Standard form (ax² + bx + c)
      if (from == "1") {
        const a = parseFloat(body.tech_a);
        const b = parseFloat(body.tech_b);
        const c = parseFloat(body.tech_c);

        if (!isNumeric(a) || !isNumeric(b) || !isNumeric(c)) {
          param["error"] = "Please! Check Your Input.";
          return param;
        }

        if (a == 0) {
          param["error"] = "a can never equal zero for a parabola!";
          return param;
        }

        return performCalculations(a, b, c, from);
      }

      // Form 2: Vertex form (a(x-h)² + k)
      else if (from == "2") {
        const a = parseFloat(body.tech_a);
        const h = parseFloat(body.tech_b);
        const k = parseFloat(body.tech_c);

        if (!isNumeric(a) || !isNumeric(h) || !isNumeric(k)) {
          param["error"] = "Please! Check Your Input.";
          return param;
        }

        if (a == 0) {
          param["error"] = "a can never equal zero for a parabola!";
          return param;
        }

        // Convert vertex form to standard form
        const b = -2 * a * h;
        const c = k + Math.pow(b, 2) / (4 * a);

        return performCalculations(a, b, c, from);
      }

      // Form 3: Vertex + Point
      else if (from == "3") {
        const h = parseFloat(body.tech_h1);
        const k = parseFloat(body.tech_k1);
        const x11 = parseFloat(body.tech_x11);
        const y11 = parseFloat(body.tech_y11);
        const axis = body.tech_axis;

        // Sirf required fields check karo
        if (
          !isNumeric(h) ||
          !isNumeric(k) ||
          !isNumeric(x11) ||
          !isNumeric(y11)
        ) {
          param["error"] = "Please! Check Your Input.";
          return param;
        }

        let equ;
        let tempH = h,
          tempK = k;

        if (axis == "x") {
          equ = `(a(${x11}-(${h}))**2plus${k})-(${y11})`;
        } else {
          equ = `(a(${y11}-(${k}))**2plus${h})-(${x11})`;
          tempH = k;
          tempK = h;
        }

        try {
          const response = await axios.get("http://167.172.134.148/parabolaa", {
            params: { equ },
            timeout: 120000,
          });

          // Response data ko safely handle karo
          let aValue;
          if (typeof response.data == "string") {
            aValue = response.data.trim();
          } else if (typeof response.data == "number") {
            aValue = response.data.toString();
          } else {
            // Agar object hai to stringify karo
            aValue = JSON.stringify(response.data);
          }

          const a = parseFloat(aValue);

          if (isNaN(a)) {
            param["error"] =
              "Could not calculate 'a' value from the given points";
            return param;
          }

          if (a == 0) {
            param["error"] = "You can't build a parabola with these points";
            return param;
          }

          const b = -2 * a * tempH;
          const c = tempK + Math.pow(b, 2) / (4 * a);

          return performCalculations(a, b, c, from, axis);
        } catch (error) {
          console.error("Error in form 3 calculation:", error);
          console.error("Error response:", error.response?.data);
          param["error"] = "Please! Check Your Input.";
          return param;
        }
      }

      // Form 7: Three points
      else if (from == "7") {
        const x1 = parseFloat(body.tech_x1);
        const y1 = parseFloat(body.tech_y1);
        const x2 = parseFloat(body.tech_x2);
        const y2 = parseFloat(body.tech_y2);
        const x3 = parseFloat(body.tech_x3);
        const y3 = parseFloat(body.tech_y3);
        const axis = body.tech_axis;

        if (
          !isNumeric(x1) ||
          !isNumeric(y1) ||
          !isNumeric(x2) ||
          !isNumeric(y2) ||
          !isNumeric(x3) ||
          !isNumeric(y3)
        ) {
          param["error"] = "Please! Check Your Input.";
          return param;
        }

        let eq1, eq1c, eq2, eq2c, eq3, eq3c;

        if (axis == "x") {
          eq1 = `${Math.pow(x1, 2)}aplus${x1}bplusc`;
          eq1c = y1;
          eq2 = `${Math.pow(x2, 2)}aplus${x2}bplusc`;
          eq2c = y2;
          eq3 = `${Math.pow(x3, 2)}aplus${x3}bplusc`;
          eq3c = y3;
        } else {
          eq1 = `${Math.pow(y1, 2)}aplus${y1}bplusc`;
          eq1c = x1;
          eq2 = `${Math.pow(y2, 2)}aplus${y2}bplusc`;
          eq2c = x2;
          eq3 = `${Math.pow(y3, 2)}aplus${y3}bplusc`;
          eq3c = x3;
        }

        try {
          const response = await axios.get("http://167.172.134.148/parabola", {
            params: { eq1, eq1c, eq2, eq2c, eq3, eq3c },
            timeout: 120000,
          });

          let buffer = response.data;

          // Safely handle buffer data
          if (typeof buffer != "string") {
            buffer = buffer.toString();
          }

          buffer = buffer.replace(/\(/g, "").replace(/\)/g, "");
          const bufferArray = buffer.split(",");

          if (bufferArray.length != 3) {
            param["error"] = "Parabola can't be built with these points.";
            return param;
          }

          // Evaluate each expression
          let a, b, c;
          try {
            a = new Function("return " + bufferArray[0])();
            b = new Function("return " + bufferArray[1])();
            c = new Function("return " + bufferArray[2])();
          } catch (e) {
            a = parseFloat(bufferArray[0]);
            b = parseFloat(bufferArray[1]);
            c = parseFloat(bufferArray[2]);
          }

          if (isNaN(a) || a == 0) {
            param["error"] = "You can't build a parabola with these points";
            return param;
          }

          return performCalculations(a, b, c, from, axis);
        } catch (error) {
          console.error("Error in form 7 calculation:", error);
          param["error"] = "Please! Check Your Input.";
          return param;
        }
      } else {
        param["error"] = "Invalid form type";
        return param;
      }
    } catch (error) {
      console.error("General error in parabola calculator:", error);
      param["error"] = "An error occurred during calculation.";
      return param;
    }
  }

  /**
   * getCalculationTwoComplementCalculator: Service Method
   * POST: /api/calculators-lol/twos-complement-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTwoComplementCalculator(body) {
    let selection = body.tech_selection;
    let cal = body.tech_cal;
    let dec = body.tech_dec;
    let bnry = body.tech_bnry;
    let hex = body.tech_hex;
    let bits = body.tech_bits;
    let no_of_bits = body.tech_no_of_bits;
    let no = body.tech_no;
    let no1 = body.tech_no1;
    let action = body.tech_action;

    const result = {};

    // Helper function: Flip bit
    function flip(c) {
      return c === "0" ? "1" : "0";
    }

    // Helper function: One's complement
    function onesComplement(str) {
      const n = str.length;
      let ones = "";

      // For ones complement, flip every bit
      for (let i = 0; i < n; i++) {
        ones += flip(str[i]);
      }

      return ones;
    }

    // Helper function: Two's complement
    function twosComplement(str) {
      const n = str.length;
      let strArr = str.split("");

      // Traverse the string to get first '1' from the last of string
      let i;
      for (i = n - 1; i >= 0; i--) {
        if (strArr[i] == "1") break;
      }

      // If there exists no '1', concatenate 1 at the starting of string
      if (i == -1) return "1" + str;

      // Continue traversal after the position of first '1'
      for (let k = i - 1; k >= 0; k--) {
        // Just flip the values
        strArr[k] = strArr[k] == "1" ? "0" : "1";
      }

      // Return the modified string
      return strArr.join("");
    }

    // Helper function: Add space for readability
    function addspace(binary) {
      const bit_len = binary.length;
      const s1 = Math.floor(bit_len / 4);
      const s2 = s1 * 4;
      const s3 = bit_len - s2;
      let res = "";
      const rem = bit_len % 4;
      const len = rem != 0 ? s1 + 1 : s1;
      let space = 0;

      for (let i = 0; i < len; i++) {
        if (i == 0 && s3 != 0) {
          for (let j = 0; j <= s3; j++) {
            if (j !== s3) {
              res += binary[j];
            } else {
              res += " ";
              space++;
            }
          }
        } else {
          const s4 = res.length - space;
          for (let j = 0; j <= 4; j++) {
            if (j != 4) {
              res += binary[s4 + j];
            } else {
              res += " ";
              space++;
            }
          }
        }
      }

      return res;
    }

    // Helper function: Binary calculation
    function bnry_cal(bnry, bits) {
      // Ensure the input is treated as a binary string
      const binary_input = String(bnry);
      const dec = parseInt(binary_input, 2); // Convert binary to decimal
      const hex = parseInt(binary_input, 2).toString(16); // Convert binary to hexadecimal
      const bit_len = binary_input.length;
      const bitsNum = parseInt(bits);
      const n = bitsNum - bit_len;

      let binary = binary_input;

      // Padding binary to the specified bit length
      if (dec < 0) {
        for (let i = 0; i < n; i++) {
          if (n < bitsNum) {
            binary = "1" + binary;
          }
        }
      } else {
        for (let i = 0; i < n; i++) {
          if (n < bitsNum) {
            binary = "0" + binary;
          }
        }
      }

      binary = binary.slice(-bitsNum);
      let _1s = onesComplement(binary);
      _1s = addspace(_1s);

      let _2s;
      if (dec === 0) {
        _2s = "0";
        for (let i = 0; i < n; i++) {
          _2s = "0" + _2s;
        }
        _2s = addspace(_2s);
      } else {
        _2s = twosComplement(binary);
        _2s = addspace(_2s);
      }

      binary = addspace(binary);

      return {
        bits: bitsNum,
        dec: dec,
        binary: binary,
        hex: hex.toUpperCase(),
        _1s: _1s,
        _2s: _2s,
      };
    }

    // Helper function: Decimal calculation
    function dec_cal(dec, bits) {
      // Convert decimal to binary
      const bnry = parseInt(dec).toString(2);
      const bitsNum = parseInt(bits);

      // Pad binary to the specified bit length
      const padded_bnry = bnry.padStart(bitsNum, "0");

      const hex = parseInt(padded_bnry, 2).toString(16);
      const _1s = onesComplement(padded_bnry);
      const _2s = twosComplement(padded_bnry);

      // Add space for readability
      const binary_with_space = addspace(padded_bnry);
      const _1s_with_space = addspace(_1s);
      const _2s_with_space = addspace(_2s);

      return {
        bits: bitsNum,
        dec: parseInt(dec),
        binary: binary_with_space,
        hex: hex.toUpperCase(),
        _1s: _1s_with_space,
        _2s: _2s_with_space,
      };
    }

    // Helper function: Hexadecimal calculation
    function hex_cal(hex, bits) {
      // Convert hex to binary
      let binary = parseInt(hex, 16).toString(2);

      // Calculate the bit length of the binary representation
      const bit_len = binary.length;
      const bitsNum = parseInt(bits);
      const n = bitsNum - bit_len;

      // Padding the binary string to the specified bit length
      for (let i = 0; i < n; i++) {
        binary = "0" + binary;
      }

      // Ensure the binary string is exactly the specified bit length
      binary = binary.slice(-bitsNum);

      // Calculate one's complement
      const _1s = onesComplement(binary);

      // Calculate two's complement
      const _2s = twosComplement(binary);

      // Add spaces for readability
      const binary_with_space = addspace(binary);
      const _1s_with_space = addspace(_1s);
      const _2s_with_space = addspace(_2s);

      // Prepare the result object
      return {
        bits: bitsNum,
        dec: parseInt(binary, 2), // Convert binary to decimal
        binary: binary_with_space,
        hex: hex.toUpperCase(),
        _1s: _1s_with_space,
        _2s: _2s_with_space,
      };
    }

    // Main logic
    if (selection == "distance") {
      let check = true;

      if (cal == "bnry_cal") {
        if (!bnry || !/^[01]+$/.test(bnry)) {
          check = false;
        }
      } else if (cal == "dec_cal") {
        if (!dec || isNaN(dec)) {
          check = false;
        }
      } else if (cal == "hex_cal") {
        if (!hex || hex == "") {
          check = false;
        }
      }

      let finalBits;
      if (bits == "other") {
        if (no_of_bits && !isNaN(no_of_bits)) {
          finalBits = no_of_bits;
        } else {
          result.error = "Please! Check Your Input";
          return result;
        }
      } else {
        finalBits = bits;
      }

      if (!check) {
        result.error = "Please! Check Your Input";
        return result;
      }

      let calculationResult;
      if (cal === "dec_cal") {
        calculationResult = dec_cal(dec, finalBits);
      } else if (cal === "bnry_cal") {
        calculationResult = bnry_cal(bnry, finalBits);
      } else if (cal === "hex_cal") {
        calculationResult = hex_cal(hex, finalBits);
      }

      result.tech_bit = calculationResult.bits;
      result.tech_dec = calculationResult.dec;
      result.tech_binary = calculationResult.binary;
      result.tech_hex = calculationResult.hex;
      result.tech_1s = calculationResult._1s;
      result.tech_2s = calculationResult._2s;

      return result;
    } else {
      // Addition/Subtraction mode
      if (no && no1 && !isNaN(no) && !isNaN(no1)) {
        let ans;

        if (action == "+") {
          ans = parseInt(no, 2) + parseInt(no1, 2);
        } else {
          ans = parseInt(no, 2) - parseInt(no1, 2);
        }

        if (ans < 0) {
          ans = "-" + Math.abs(ans).toString(2);
        } else {
          ans = Math.abs(ans).toString(2);
        }

        result.tech_add_sub = ans;
        result.tech_no = no;
        result.tech_no1 = no1;
        result.tech_action = action;

        return result;
      } else {
        result.error = "Please! Check Your Input";
        return result;
      }
    }
  }

  /**
   * getCalculationLawOfSinesCalculator: Service Method
   * POST: /api/calculators-lol/law-of-sines-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLawOfSinesCalculator(body) {
    let cal = body.tech_cal;
    let side_a = body.tech_side_a;
    let side_a_unit = body.tech_side_a_unit;

    let side_b = body.tech_side_b;
    let side_b_unit = body.tech_side_b_unit;

    let side_c = body.tech_side_c;
    let side_c_unit = body.tech_side_c_unit;

    let angle_a = body.tech_angle_a;
    let angle_a_unit = body.tech_angle_a_unit;

    let angle_b = body.tech_angle_b;
    let angle_b_unit = body.tech_angle_b_unit;

    let angle_c = body.tech_angle_c;
    let angle_c_unit = body.tech_angle_c_unit;

    let s_a = parseFloat(side_a);
    let s_b = parseFloat(side_b);
    let s_c = parseFloat(side_c);
    let a_a = parseFloat(angle_a);
    let a_b = parseFloat(angle_b);
    let a_c = parseFloat(angle_c);

    // Convert side units to cm
    if (!isNaN(s_a)) {
      switch (side_a_unit) {
        case "mm":
          s_a = s_a / 10;
          break;
        case "m":
          s_a = s_a / 0.01;
          break;
        case "km":
          s_a = s_a / 0.00001;
          break;
        case "in":
          s_a = s_a / 0.393701;
          break;
        case "ft":
          s_a = s_a / 0.0328084;
          break;
        case "yd":
          s_a = s_a / 0.01093613;
          break;
        case "mi":
          s_a = s_a / 0.00000621371;
          break;
        case "nmi":
          s_a = s_a / 0.00000539957;
          break;
      }
    }

    if (!isNaN(s_b)) {
      switch (side_b_unit) {
        case "mm":
          s_b = s_b / 10;
          break;
        case "m":
          s_b = s_b / 0.01;
          break;
        case "km":
          s_b = s_b / 0.00001;
          break;
        case "in":
          s_b = s_b / 0.393701;
          break;
        case "ft":
          s_b = s_b / 0.0328084;
          break;
        case "yd":
          s_b = s_b / 0.01093613;
          break;
        case "mi":
          s_b = s_b / 0.00000621371;
          break;
        case "nmi":
          s_b = s_b / 0.00000539957;
          break;
      }
    }

    if (!isNaN(s_c)) {
      switch (side_c_unit) {
        case "mm":
          s_c = s_c / 10;
          break;
        case "m":
          s_c = s_c / 0.01;
          break;
        case "km":
          s_c = s_c / 0.00001;
          break;
        case "in":
          s_c = s_c / 0.393701;
          break;
        case "ft":
          s_c = s_c / 0.0328084;
          break;
        case "yd":
          s_c = s_c / 0.01093613;
          break;
        case "mi":
          s_c = s_c / 0.00000621371;
          break;
        case "nmi":
          s_c = s_c / 0.00000539957;
          break;
      }
    }

    // Convert angle units to degrees
    if (!isNaN(a_a)) {
      switch (angle_a_unit) {
        case "rad":
          a_a = a_a / 0.017453;
          break;
        case "gon":
          a_a = a_a / 1.111;
          break;
        case "tr":
          a_a = a_a / 0.002778;
          break;
        case "arcmin":
          a_a = a_a / 60;
          break;
        case "arcsec":
          a_a = a_a / 3600;
          break;
        case "mrad":
          a_a = a_a / 17.453;
          break;
        case "urad":
          a_a = a_a / 17453;
          break;
        case "pirad":
          a_a = a_a / 0.005556;
          break;
      }
    }

    if (!isNaN(a_b)) {
      switch (angle_b_unit) {
        case "rad":
          a_b = a_b / 0.017453;
          break;
        case "gon":
          a_b = a_b / 1.111;
          break;
        case "tr":
          a_b = a_b / 0.002778;
          break;
        case "arcmin":
          a_b = a_b / 60;
          break;
        case "arcsec":
          a_b = a_b / 3600;
          break;
        case "mrad":
          a_b = a_b / 17.453;
          break;
        case "urad":
          a_b = a_b / 17453;
          break;
        case "pirad":
          a_b = a_b / 0.005556;
          break;
      }
    }

    if (!isNaN(a_c)) {
      switch (angle_c_unit) {
        case "rad":
          a_c = a_c / 0.017453;
          break;
        case "gon":
          a_c = a_c / 1.111;
          break;
        case "tr":
          a_c = a_c / 0.002778;
          break;
        case "arcmin":
          a_c = a_c / 60;
          break;
        case "arcsec":
          a_c = a_c / 3600;
          break;
        case "mrad":
          a_c = a_c / 17.453;
          break;
        case "urad":
          a_c = a_c / 17453;
          break;
        case "pirad":
          a_c = a_c / 0.005556;
          break;
      }
    }

    const result = {};

    // Helper function to convert degrees to radians
    const deg2rad = (deg) => (deg * Math.PI) / 180;
    // Helper function to convert radians to degrees
    const rad2deg = (rad) => (rad * 180) / Math.PI;

    if (cal == "abb" && !isNaN(s_a) && !isNaN(s_b) && !isNaN(a_b)) {
      const s1 = (s_a * Math.sin(deg2rad(a_b))) / s_b;
      const angle_a_rad = Math.asin(s1);
      a_c = 180 - (rad2deg(angle_a_rad) + a_b);
      s_c = (s_b * Math.sin(deg2rad(a_c))) / Math.sin(deg2rad(a_b));
      const P = s_a + s_b + s_c;
      const s_val = 0.5 * P;
      const K = Math.sqrt(
        s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c)
      );
      const r = Math.sqrt(
        ((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val
      );
      const R = (s_a * s_b * s_c) / (4 * K);

      result.tech_angle_a = isNaN(rad2deg(angle_a_rad))
        ? "NaN"
        : rad2deg(angle_a_rad);
      result.tech_angle_b = isNaN(a_b) ? "NaN" : a_b;
      result.tech_angle_c = isNaN(a_c) ? "NaN" : a_c;
      result.tech_side_a = isNaN(s_a) ? "NaN" : s_a;
      result.tech_side_b = isNaN(s_b) ? "NaN" : s_b;
      result.tech_side_c = isNaN(s_c) ? "NaN" : s_c;
      result.tech_P = isNaN(P) ? "NaN" : P;
      result.tech_s = isNaN(s_val) ? "NaN" : s_val;
      result.tech_K = isNaN(K) ? "NaN" : K;
      result.tech_r = isNaN(r) ? "NaN" : r;
      result.tech_R = isNaN(R) ? "NaN" : R;
    } else if (cal == "acc" && !isNaN(s_a) && !isNaN(s_c) && !isNaN(a_c)) {
      const s1 = (s_a * Math.sin(deg2rad(a_c))) / s_c;
      const angle_a_rad = Math.asin(s1);
      a_b = 180 - (rad2deg(angle_a_rad) + a_c);
      s_b = (s_c * Math.sin(deg2rad(a_b))) / Math.sin(deg2rad(a_c));
      const P = s_a + s_b + s_c;
      const s_val = 0.5 * P;
      const K = Math.sqrt(
        s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c)
      );
      const r = Math.sqrt(
        ((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val
      );
      const R = (s_a * s_b * s_c) / (4 * K);

      result.tech_angle_a = isNaN(rad2deg(angle_a_rad))
        ? "NaN"
        : rad2deg(angle_a_rad);
      result.tech_angle_b = isNaN(a_b) ? "NaN" : a_b;
      result.tech_angle_c = isNaN(a_c) ? "NaN" : a_c;
      result.tech_side_a = isNaN(s_a) ? "NaN" : s_a;
      result.tech_side_b = isNaN(s_b) ? "NaN" : s_b;
      result.tech_side_c = isNaN(s_c) ? "NaN" : s_c;
      result.tech_P = isNaN(P) ? "NaN" : P;
      result.tech_s = isNaN(s_val) ? "NaN" : s_val;
      result.tech_K = isNaN(K) ? "NaN" : K;
      result.tech_r = isNaN(r) ? "NaN" : r;
      result.tech_R = isNaN(R) ? "NaN" : R;
    } else if (cal == "aba" && !isNaN(s_a) && !isNaN(s_b) && !isNaN(a_a)) {
      const s1 = (s_b * Math.sin(deg2rad(a_a))) / s_a;
      const angle_b_rad = Math.asin(s1);
      a_c = 180 - (a_a + rad2deg(angle_b_rad));
      s_c = (s_a * Math.sin(deg2rad(a_c))) / Math.sin(deg2rad(a_a));
      const P = s_a + s_b + s_c;
      const s_val = 0.5 * P;
      const K = Math.sqrt(
        s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c)
      );
      const r = Math.sqrt(
        ((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val
      );
      const R = (s_a * s_b * s_c) / (4 * K);

      result.tech_angle_a = isNaN(a_a) ? "NaN" : a_a;
      result.tech_angle_b = isNaN(rad2deg(angle_b_rad))
        ? "NaN"
        : rad2deg(angle_b_rad);
      result.tech_angle_c = isNaN(a_c) ? "NaN" : a_c;
      result.tech_side_a = isNaN(s_a) ? "NaN" : s_a;
      result.tech_side_b = isNaN(s_b) ? "NaN" : s_b;
      result.tech_side_c = isNaN(s_c) ? "NaN" : s_c;
      result.tech_P = isNaN(P) ? "NaN" : P;
      result.tech_s = isNaN(s_val) ? "NaN" : s_val;
      result.tech_K = isNaN(K) ? "NaN" : K;
      result.tech_r = isNaN(r) ? "NaN" : r;
      result.tech_R = isNaN(R) ? "NaN" : R;
    } else if (cal == "bcc" && !isNaN(s_b) && !isNaN(s_c) && !isNaN(a_c)) {
      const s1 = (s_b * Math.sin(deg2rad(a_c))) / s_c;
      const angle_b_rad = Math.asin(s1);
      a_a = 180 - (rad2deg(angle_b_rad) + a_c);
      s_a = (s_c * Math.sin(deg2rad(a_a))) / Math.sin(deg2rad(a_c));
      const P = s_a + s_b + s_c;
      const s_val = 0.5 * P;
      const K = Math.sqrt(
        s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c)
      );
      const r = Math.sqrt(
        ((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val
      );
      const R = (s_a * s_b * s_c) / (4 * K);

      result.tech_angle_a = isNaN(a_a) ? "NaN" : a_a;
      result.tech_angle_b = isNaN(rad2deg(angle_b_rad))
        ? "NaN"
        : rad2deg(angle_b_rad);
      result.tech_angle_c = isNaN(a_c) ? "NaN" : a_c;
      result.tech_side_a = isNaN(s_a) ? "NaN" : s_a;
      result.tech_side_b = isNaN(s_b) ? "NaN" : s_b;
      result.tech_side_c = isNaN(s_c) ? "NaN" : s_c;
      result.tech_P = isNaN(P) ? "NaN" : P;
      result.tech_s = isNaN(s_val) ? "NaN" : s_val;
      result.tech_K = isNaN(K) ? "NaN" : K;
      result.tech_r = isNaN(r) ? "NaN" : r;
      result.tech_R = isNaN(R) ? "NaN" : R;
    } else if (cal == "aca" && !isNaN(s_a) && !isNaN(s_c) && !isNaN(a_a)) {
      const s1 = (s_c * Math.sin(deg2rad(a_a))) / s_a;
      const angle_c_rad = Math.asin(s1);
      a_b = 180 - (a_a + rad2deg(angle_c_rad));
      s_b = (s_a * Math.sin(deg2rad(a_b))) / Math.sin(deg2rad(a_a));
      const P = s_a + s_b + s_c;
      const s_val = 0.5 * P;
      const K = Math.sqrt(
        s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c)
      );
      const r = Math.sqrt(
        ((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val
      );
      const R = (s_a * s_b * s_c) / (4 * K);
      result.tech_angle_a = isNaN(a_a) ? "NaN" : a_a;
      result.tech_angle_b = isNaN(a_b) ? "NaN" : a_b;
      result.tech_angle_c = isNaN(rad2deg(angle_c_rad))
        ? "NaN"
        : rad2deg(angle_c_rad);
      result.tech_side_a = isNaN(s_a) ? "NaN" : s_a;
      result.tech_side_b = isNaN(s_b) ? "NaN" : s_b;
      result.tech_side_c = isNaN(s_c) ? "NaN" : s_c;
      result.tech_P = isNaN(P) ? "NaN" : P;
      result.tech_s = isNaN(s_val) ? "NaN" : s_val;
      result.tech_K = isNaN(K) ? "NaN" : K;
      result.tech_r = isNaN(r) ? "NaN" : r;
      result.tech_R = isNaN(R) ? "NaN" : R;
    } else if (cal == "bcb" && !isNaN(s_b) && !isNaN(s_c) && !isNaN(a_b)) {
      const s1 = (s_c * Math.sin(deg2rad(a_b))) / s_b;
      const angle_c_rad = Math.asin(s1);
      a_a = 180 - (a_b + rad2deg(angle_c_rad));
      s_a = (s_b * Math.sin(deg2rad(a_a))) / Math.sin(deg2rad(a_b));
      const P = s_a + s_b + s_c;
      const s_val = 0.5 * P;
      const K = Math.sqrt(
        s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c)
      );
      const r = Math.sqrt(
        ((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val
      );
      const R = (s_a * s_b * s_c) / (4 * K);

      result.tech_angle_a = isNaN(a_a) ? "NaN" : a_a;
      result.tech_angle_b = isNaN(a_b) ? "NaN" : a_b;
      result.tech_angle_c = isNaN(rad2deg(angle_c_rad))
        ? "NaN"
        : rad2deg(angle_c_rad);
      result.tech_side_a = isNaN(s_a) ? "NaN" : s_a;
      result.tech_side_b = isNaN(s_b) ? "NaN" : s_b;
      result.tech_side_c = isNaN(s_c) ? "NaN" : s_c;
      result.tech_P = isNaN(P) ? "NaN" : P;
      result.tech_s = isNaN(s_val) ? "NaN" : s_val;
      result.tech_K = isNaN(K) ? "NaN" : K;
      result.tech_r = isNaN(r) ? "NaN" : r;
      result.tech_R = isNaN(R) ? "NaN" : R;
    } else if (cal == "bab" && !isNaN(s_b) && !isNaN(a_a) && !isNaN(a_b)) {
      a_c = 180 - (a_a + a_b);
      s_a = (s_b * Math.sin(deg2rad(a_a))) / Math.sin(deg2rad(a_b));
      s_c = (s_a * Math.sin(deg2rad(a_c))) / Math.sin(deg2rad(a_a));
      const P = s_a + s_b + s_c;
      const s_val = 0.5 * P;
      const K = Math.sqrt(
        s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c)
      );
      const r = Math.sqrt(
        ((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val
      );
      const R = (s_a * s_b * s_c) / (4 * K);

      result.tech_angle_a = isNaN(a_a) ? "NaN" : a_a;
      result.tech_angle_b = isNaN(a_b) ? "NaN" : a_b;
      result.tech_angle_c = isNaN(a_c) ? "NaN" : a_c;
      result.tech_side_a = isNaN(s_a) ? "NaN" : s_a;
      result.tech_side_b = isNaN(s_b) ? "NaN" : s_b;
      result.tech_side_c = isNaN(s_c) ? "NaN" : s_c;
      result.tech_P = isNaN(P) ? "NaN" : P;
      result.tech_s = isNaN(s_val) ? "NaN" : s_val;
      result.tech_K = isNaN(K) ? "NaN" : K;
      result.tech_r = isNaN(r) ? "NaN" : r;
      result.tech_R = isNaN(R) ? "NaN" : R;
    } else if (cal == "cac" && !isNaN(s_c) && !isNaN(a_a) && !isNaN(a_c)) {
      a_b = 180 - (a_a + a_c);
      s_a = (s_c * Math.sin(deg2rad(a_a))) / Math.sin(deg2rad(a_c));
      s_b = (s_a * Math.sin(deg2rad(a_b))) / Math.sin(deg2rad(a_a));
      const P = s_a + s_b + s_c;
      const s_val = 0.5 * P;
      const K = Math.sqrt(
        s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c)
      );
      const r = Math.sqrt(
        ((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val
      );
      const R = (s_a * s_b * s_c) / (4 * K);

      result.tech_angle_a = isNaN(a_a) ? "NaN" : a_a;
      result.tech_angle_b = isNaN(a_b) ? "NaN" : a_b;
      result.tech_angle_c = isNaN(a_c) ? "NaN" : a_c;
      result.tech_side_a = isNaN(s_a) ? "NaN" : s_a;
      result.tech_side_b = isNaN(s_b) ? "NaN" : s_b;
      result.tech_side_c = isNaN(s_c) ? "NaN" : s_c;
      result.tech_P = isNaN(P) ? "NaN" : P;
      result.tech_s = isNaN(s_val) ? "NaN" : s_val;
      result.tech_K = isNaN(K) ? "NaN" : K;
      result.tech_r = isNaN(r) ? "NaN" : r;
      result.tech_R = isNaN(R) ? "NaN" : R;
    } else if (cal == "aab" && !isNaN(s_a) && !isNaN(a_a) && !isNaN(a_b)) {
      a_c = 180 - (a_a + a_b);
      s_b = (s_a * Math.sin(deg2rad(a_b))) / Math.sin(deg2rad(a_a));
      s_c = (s_a * Math.sin(deg2rad(a_c))) / Math.sin(deg2rad(a_a));
      const P = s_a + s_b + s_c;
      const s_val = 0.5 * P;
      const K = Math.sqrt(
        s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c)
      );
      const r = Math.sqrt(
        ((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val
      );
      const R = (s_a * s_b * s_c) / (4 * K);

      result.tech_angle_a = isNaN(a_a) ? "NaN" : a_a;
      result.tech_angle_b = isNaN(a_b) ? "NaN" : a_b;
      result.tech_angle_c = isNaN(a_c) ? "NaN" : a_c;
      result.tech_side_a = isNaN(s_a) ? "NaN" : s_a;
      result.tech_side_b = isNaN(s_b) ? "NaN" : s_b;
      result.tech_side_c = isNaN(s_c) ? "NaN" : s_c;
      result.tech_P = isNaN(P) ? "NaN" : P;
      result.tech_s = isNaN(s_val) ? "NaN" : s_val;
      result.tech_K = isNaN(K) ? "NaN" : K;
      result.tech_r = isNaN(r) ? "NaN" : r;
      result.tech_R = isNaN(R) ? "NaN" : R;
    } else if (cal == "cbc" && !isNaN(s_c) && !isNaN(a_b) && !isNaN(a_c)) {
      a_a = 180 - (a_b + a_c);
      s_a = (s_c * Math.sin(deg2rad(a_a))) / Math.sin(deg2rad(a_c));
      s_b = (s_a * Math.sin(deg2rad(a_b))) / Math.sin(deg2rad(a_a));
      const P = s_a + s_b + s_c;
      const s_val = 0.5 * P;
      const K = Math.sqrt(
        s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c)
      );
      const r = Math.sqrt(
        ((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val
      );
      const R = (s_a * s_b * s_c) / (4 * K);

      result.tech_angle_a = isNaN(a_a) ? "NaN" : a_a;
      result.tech_angle_b = isNaN(a_b) ? "NaN" : a_b;
      result.tech_angle_c = isNaN(a_c) ? "NaN" : a_c;
      result.tech_side_a = isNaN(s_a) ? "NaN" : s_a;
      result.tech_side_b = isNaN(s_b) ? "NaN" : s_b;
      result.tech_side_c = isNaN(s_c) ? "NaN" : s_c;
      result.tech_P = isNaN(P) ? "NaN" : P;
      result.tech_s = isNaN(s_val) ? "NaN" : s_val;
      result.tech_K = isNaN(K) ? "NaN" : K;
      result.tech_r = isNaN(r) ? "NaN" : r;
      result.tech_R = isNaN(R) ? "NaN" : R;
    } else if (cal == "aac" && !isNaN(s_a) && !isNaN(a_a) && !isNaN(a_c)) {
      a_b = 180 - (a_a + a_c);
      s_b = (s_a * Math.sin(deg2rad(a_b))) / Math.sin(deg2rad(a_a));
      s_c = (s_a * Math.sin(deg2rad(a_c))) / Math.sin(deg2rad(a_a));
      const P = s_a + s_b + s_c;
      const s_val = 0.5 * P;
      const K = Math.sqrt(
        s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c)
      );
      const r = Math.sqrt(
        ((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val
      );
      const R = (s_a * s_b * s_c) / (4 * K);

      result.tech_angle_a = isNaN(a_a) ? "NaN" : a_a;
      result.tech_angle_b = isNaN(a_b) ? "NaN" : a_b;
      result.tech_angle_c = isNaN(a_c) ? "NaN" : a_c;
      result.tech_side_a = isNaN(s_a) ? "NaN" : s_a;
      result.tech_side_b = isNaN(s_b) ? "NaN" : s_b;
      result.tech_side_c = isNaN(s_c) ? "NaN" : s_c;
      result.tech_P = isNaN(P) ? "NaN" : P;
      result.tech_s = isNaN(s_val) ? "NaN" : s_val;
      result.tech_K = isNaN(K) ? "NaN" : K;
      result.tech_r = isNaN(r) ? "NaN" : r;
      result.tech_R = isNaN(R) ? "NaN" : R;
    } else if (cal == "bbc" && !isNaN(s_b) && !isNaN(a_b) && !isNaN(a_c)) {
      a_a = 180 - (a_b + a_c);
      s_a = (s_b * Math.sin(deg2rad(a_a))) / Math.sin(deg2rad(a_b));
      s_c = (s_a * Math.sin(deg2rad(a_c))) / Math.sin(deg2rad(a_a));
      const P = s_a + s_b + s_c;
      const s_val = 0.5 * P;
      const K = Math.sqrt(
        s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c)
      );
      const r = Math.sqrt(
        ((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val
      );
      const R = (s_a * s_b * s_c) / (4 * K);

      result.tech_angle_a = isNaN(a_a) ? "NaN" : a_a;
      result.tech_angle_b = isNaN(a_b) ? "NaN" : a_b;
      result.tech_angle_c = isNaN(a_c) ? "NaN" : a_c;
      result.tech_side_a = isNaN(s_a) ? "NaN" : s_a;
      result.tech_side_b = isNaN(s_b) ? "NaN" : s_b;
      result.tech_side_c = isNaN(s_c) ? "NaN" : s_c;
      result.tech_P = isNaN(P) ? "NaN" : P;
      result.tech_s = isNaN(s_val) ? "NaN" : s_val;
      result.tech_K = isNaN(K) ? "NaN" : K;
      result.tech_r = isNaN(r) ? "NaN" : r;
      result.tech_R = isNaN(R) ? "NaN" : R;
    } else {
      result.error = "Please Check Your Input.1";
      return result;
    }
    return result;
  }

  /**
   * getCalculationLawOfCosinesCalculator: Service Method
   * POST: /api/calculators-lol/law-of-cosines-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLawOfCosinesCalculator(body) {
    let cal = body.tech_cal;
    let side_a = body.tech_side_a;
    let side_a_unit = body.tech_side_a_unit;
    let side_b = body.tech_side_b;
    let side_b_unit = body.tech_side_b_unit;
    let side_c = body.tech_side_c;
    let side_c_unit = body.tech_side_c_unit;
    let angle_a = body.tech_angle_a;
    let angle_a_unit = body.tech_angle_a_unit;
    let angle_b = body.tech_angle_b;
    let angle_b_unit = body.tech_angle_b_unit;
    let angle_c = body.tech_angle_c;
    let angle_c_unit = body.tech_angle_c_unit;

    let s_a = parseFloat(side_a);
    let s_b = parseFloat(side_b);
    let s_c = parseFloat(side_c);
    let a_a = parseFloat(angle_a);
    let a_b = parseFloat(angle_b);
    let a_c = parseFloat(angle_c);

    // Convert side units to cm
    if (!isNaN(s_a)) {
      switch (side_a_unit) {
        case "mm":
          s_a = s_a / 10;
          break;
        case "m":
          s_a = s_a / 0.01;
          break;
        case "km":
          s_a = s_a / 0.00001;
          break;
        case "in":
          s_a = s_a / 0.393701;
          break;
        case "ft":
          s_a = s_a / 0.0328084;
          break;
        case "yd":
          s_a = s_a / 0.01093613;
          break;
        case "mi":
          s_a = s_a / 0.00000621371;
          break;
        case "nmi":
          s_a = s_a / 0.00000539957;
          break;
      }
    }

    if (!isNaN(s_b)) {
      switch (side_b_unit) {
        case "mm":
          s_b = s_b / 10;
          break;
        case "m":
          s_b = s_b / 0.01;
          break;
        case "km":
          s_b = s_b / 0.00001;
          break;
        case "in":
          s_b = s_b / 0.393701;
          break;
        case "ft":
          s_b = s_b / 0.0328084;
          break;
        case "yd":
          s_b = s_b / 0.01093613;
          break;
        case "mi":
          s_b = s_b / 0.00000621371;
          break;
        case "nmi":
          s_b = s_b / 0.00000539957;
          break;
      }
    }

    if (!isNaN(s_c)) {
      switch (side_c_unit) {
        case "mm":
          s_c = s_c / 10;
          break;
        case "m":
          s_c = s_c / 0.01;
          break;
        case "km":
          s_c = s_c / 0.00001;
          break;
        case "in":
          s_c = s_c / 0.393701;
          break;
        case "ft":
          s_c = s_c / 0.0328084;
          break;
        case "yd":
          s_c = s_c / 0.01093613;
          break;
        case "mi":
          s_c = s_c / 0.00000621371;
          break;
        case "nmi":
          s_c = s_c / 0.00000539957;
          break;
      }
    }

    // Convert angle units to degrees
    if (!isNaN(a_a)) {
      switch (angle_a_unit) {
        case "rad":
          a_a = a_a / 0.017453;
          break;
        case "gon":
          a_a = a_a / 1.111;
          break;
        case "tr":
          a_a = a_a / 0.002778;
          break;
        case "arcmin":
          a_a = a_a / 60;
          break;
        case "arcsec":
          a_a = a_a / 3600;
          break;
        case "mrad":
          a_a = a_a / 17.453;
          break;
        case "urad":
          a_a = a_a / 17453;
          break;
        case "pirad":
          a_a = a_a / 0.005556;
          break;
      }
    }

    if (!isNaN(a_b)) {
      switch (angle_b_unit) {
        case "rad":
          a_b = a_b / 0.017453;
          break;
        case "gon":
          a_b = a_b / 1.111;
          break;
        case "tr":
          a_b = a_b / 0.002778;
          break;
        case "arcmin":
          a_b = a_b / 60;
          break;
        case "arcsec":
          a_b = a_b / 3600;
          break;
        case "mrad":
          a_b = a_b / 17.453;
          break;
        case "urad":
          a_b = a_b / 17453;
          break;
        case "pirad":
          a_b = a_b / 0.005556;
          break;
      }
    }

    if (!isNaN(a_c)) {
      switch (angle_c_unit) {
        case "rad":
          a_c = a_c / 0.017453;
          break;
        case "gon":
          a_c = a_c / 1.111;
          break;
        case "tr":
          a_c = a_c / 0.002778;
          break;
        case "arcmin":
          a_c = a_c / 60;
          break;
        case "arcsec":
          a_c = a_c / 3600;
          break;
        case "mrad":
          a_c = a_c / 17.453;
          break;
        case "urad":
          a_c = a_c / 17453;
          break;
        case "pirad":
          a_c = a_c / 0.005556;
          break;
      }
    }

    const result = {};

    // Helper function to convert degrees to radians
    const deg2rad = (deg) => (deg * Math.PI) / 180;
    // Helper function to convert radians to degrees
    const rad2deg = (rad) => (rad * 180) / Math.PI;

    if (
      (cal == "aa" || cal == "ab" || cal == "ac") &&
      !isNaN(s_a) &&
      !isNaN(s_b) &&
      !isNaN(s_c)
    ) {
      // All three sides given - calculate all angles
      const s1 =
        (Math.pow(s_b, 2) + Math.pow(s_c, 2) - Math.pow(s_a, 2)) /
        (2 * s_b * s_c);
      const angle_a_rad = Math.acos(s1);

      const s2 =
        (Math.pow(s_a, 2) + Math.pow(s_c, 2) - Math.pow(s_b, 2)) /
        (2 * s_a * s_c);
      const angle_b_rad = Math.acos(s2);

      const s3 =
        (Math.pow(s_a, 2) + Math.pow(s_b, 2) - Math.pow(s_c, 2)) /
        (2 * s_a * s_b);
      const angle_c_rad = Math.acos(s3);

      const P = s_a + s_b + s_c;
      const s_val = 0.5 * P;
      const K = Math.sqrt(
        s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c)
      );
      const r = Math.sqrt(
        ((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val
      );
      const R = (s_a * s_b * s_c) / (4 * K);

      result.tech_angle_a = isNaN(rad2deg(angle_a_rad))
        ? "NaN"
        : rad2deg(angle_a_rad);
      result.tech_angle_b = isNaN(rad2deg(angle_b_rad))
        ? "NaN"
        : rad2deg(angle_b_rad);
      result.tech_angle_c = isNaN(rad2deg(angle_c_rad))
        ? "NaN"
        : rad2deg(angle_c_rad);
      result.tech_side_a = isNaN(s_a) ? "NaN" : s_a;
      result.tech_side_b = isNaN(s_b) ? "NaN" : s_b;
      result.tech_side_c = isNaN(s_c) ? "NaN" : s_c;
      result.tech_P = isNaN(P) ? "NaN" : P;
      result.tech_s = isNaN(s_val) ? "NaN" : s_val;
      result.tech_K = isNaN(K) ? "NaN" : K;
      result.tech_r = isNaN(r) ? "NaN" : r;
      result.tech_R = isNaN(R) ? "NaN" : R;
    } else if (cal == "sa" && !isNaN(s_b) && !isNaN(s_c) && !isNaN(a_a)) {
      // Two sides and included angle given - calculate third side
      s_a = Math.sqrt(
        Math.pow(s_b, 2) +
          Math.pow(s_c, 2) -
          2 * s_b * s_c * Math.cos(deg2rad(a_a))
      );

      const s1 =
        (Math.pow(s_a, 2) + Math.pow(s_c, 2) - Math.pow(s_b, 2)) /
        (2 * s_a * s_c);
      const angle_b_rad = Math.acos(s1);

      const s2 =
        (Math.pow(s_a, 2) + Math.pow(s_b, 2) - Math.pow(s_c, 2)) /
        (2 * s_a * s_b);
      const angle_c_rad = Math.acos(s2);

      const P = s_a + s_b + s_c;
      const s_val = 0.5 * P;
      const K = Math.sqrt(
        s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c)
      );
      const r = Math.sqrt(
        ((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val
      );
      const R = (s_a * s_b * s_c) / (4 * K);

      result.tech_angle_a = isNaN(a_a) ? "NaN" : a_a;
      result.tech_angle_b = isNaN(rad2deg(angle_b_rad))
        ? "NaN"
        : rad2deg(angle_b_rad);
      result.tech_angle_c = isNaN(rad2deg(angle_c_rad))
        ? "NaN"
        : rad2deg(angle_c_rad);
      result.tech_side_a = isNaN(s_a) ? "NaN" : s_a;
      result.tech_side_b = isNaN(s_b) ? "NaN" : s_b;
      result.tech_side_c = isNaN(s_c) ? "NaN" : s_c;
      result.tech_P = isNaN(P) ? "NaN" : P;
      result.tech_s = isNaN(s_val) ? "NaN" : s_val;
      result.tech_K = isNaN(K) ? "NaN" : K;
      result.tech_r = isNaN(r) ? "NaN" : r;
      result.tech_R = isNaN(R) ? "NaN" : R;
    } else if (cal == "sb" && !isNaN(s_a) && !isNaN(s_c) && !isNaN(a_b)) {
      // Two sides and included angle given - calculate third side
      s_b = Math.sqrt(
        Math.pow(s_a, 2) +
          Math.pow(s_c, 2) -
          2 * s_a * s_c * Math.cos(deg2rad(a_b))
      );

      const s1 =
        (Math.pow(s_b, 2) + Math.pow(s_c, 2) - Math.pow(s_a, 2)) /
        (2 * s_b * s_c);
      const angle_a_rad = Math.acos(s1);

      const s2 =
        (Math.pow(s_a, 2) + Math.pow(s_b, 2) - Math.pow(s_c, 2)) /
        (2 * s_a * s_b);
      const angle_c_rad = Math.acos(s2);

      const P = s_a + s_b + s_c;
      const s_val = 0.5 * P;
      const K = Math.sqrt(
        s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c)
      );
      const r = Math.sqrt(
        ((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val
      );
      const R = (s_a * s_b * s_c) / (4 * K);

      result.tech_angle_a = isNaN(rad2deg(angle_a_rad))
        ? "NaN"
        : rad2deg(angle_a_rad);
      result.tech_angle_b = isNaN(a_b) ? "NaN" : a_b;
      result.tech_angle_c = isNaN(rad2deg(angle_c_rad))
        ? "NaN"
        : rad2deg(angle_c_rad);
      result.tech_side_a = isNaN(s_a) ? "NaN" : s_a;
      result.tech_side_b = isNaN(s_b) ? "NaN" : s_b;
      result.tech_side_c = isNaN(s_c) ? "NaN" : s_c;
      result.tech_P = isNaN(P) ? "NaN" : P;
      result.tech_s = isNaN(s_val) ? "NaN" : s_val;
      result.tech_K = isNaN(K) ? "NaN" : K;
      result.tech_r = isNaN(r) ? "NaN" : r;
      result.tech_R = isNaN(R) ? "NaN" : R;
    } else if (cal == "sc" && !isNaN(s_a) && !isNaN(s_b) && !isNaN(a_c)) {
      // Two sides and included angle given - calculate third side
      s_c = Math.sqrt(
        Math.pow(s_a, 2) +
          Math.pow(s_b, 2) -
          2 * s_a * s_b * Math.cos(deg2rad(a_c))
      );

      const s1 =
        (Math.pow(s_b, 2) + Math.pow(s_c, 2) - Math.pow(s_a, 2)) /
        (2 * s_b * s_c);
      const angle_a_rad = Math.acos(s1);

      const s2 =
        (Math.pow(s_a, 2) + Math.pow(s_c, 2) - Math.pow(s_b, 2)) /
        (2 * s_a * s_c);
      const angle_b_rad = Math.acos(s2);

      const P = s_a + s_b + s_c;
      const s_val = 0.5 * P;
      const K = Math.sqrt(
        s_val * (s_val - s_a) * (s_val - s_b) * (s_val - s_c)
      );
      const r = Math.sqrt(
        ((s_val - s_a) * (s_val - s_b) * (s_val - s_c)) / s_val
      );
      const R = (s_a * s_b * s_c) / (4 * K);

      result.tech_angle_a = isNaN(rad2deg(angle_a_rad))
        ? "NaN"
        : rad2deg(angle_a_rad);
      result.tech_angle_b = isNaN(rad2deg(angle_b_rad))
        ? "NaN"
        : rad2deg(angle_b_rad);
      result.tech_angle_c = isNaN(a_c) ? "NaN" : a_c;
      result.tech_side_a = isNaN(s_a) ? "NaN" : s_a;
      result.tech_side_b = isNaN(s_b) ? "NaN" : s_b;
      result.tech_side_c = isNaN(s_c) ? "NaN" : s_c;
      result.tech_P = isNaN(P) ? "NaN" : P;
      result.tech_s = isNaN(s_val) ? "NaN" : s_val;
      result.tech_K = isNaN(K) ? "NaN" : K;
      result.tech_r = isNaN(r) ? "NaN" : r;
      result.tech_R = isNaN(R) ? "NaN" : R;
    } else {
      result.error = "Please! Check Your Input.";
      return result;
    }

    return result;
  }

  /**
   * getCalculationTangentLineCalculator: Service Method
   * POST: /api/calculators-lol/tangent-line-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTangentLineCalculator(body) {
    const cal = body.tech_cal;
    const func = body.tech_func;
    const func1 = body.tech_func1;
    const point = body.tech_point;

    const result = {};

    // Helper function to sanitize and format the equation
    const sanitizeEquation = (equation) => {
      let sanitized = equation.replace(/\s/g, "");
      sanitized = sanitized.replace(/\+/g, "plus");
      sanitized = sanitized.replace(/%20/g, "");
      sanitized = sanitized.replace(/{/g, "(");
      sanitized = sanitized.replace(/}/g, ")");
      sanitized = sanitized.replace(/e\^/g, "exp");
      sanitized = sanitized.replace(/exp\^/g, "exp");
      sanitized = sanitized.replace(/\^/g, "**");
      sanitized = sanitized.replace(/e\^sqrt\(x\)/g, "exp(2*x)");
      return sanitized;
    };

    // Security check function
    const hasInvalidCharacters = (input) => {
      const regex =
        /<|>|&|php|print_r|print|echo|script|=|sin|cos|tan|arcsin|arccos|arctan|&|%/i;
      return regex.test(input);
    };

    try {
      if (cal === "y" && func && point) {
        if (hasInvalidCharacters(func)) {
          result.error = "Please Enter Valid Input.";
          return result;
        }

        const parem = sanitizeEquation(func);
        const check = "y";

        // Make API call
        const response = await fetch("http://167.172.134.148/tangent_line", {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
          },
          body: new URLSearchParams({
            equ: parem,
            point: point,
            check: check,
          }),
          timeout: 120000,
        });

        if (!response.ok) {
          throw new Error("API request failed");
        }

        const buffer = await response.json();

        result.tech_point = point;
        result.tech_enter = buffer[0];
        result.tech_s1 = Math.round(buffer[1] * 1000) / 1000; // Round to 3 decimal places
        result.tech_diff = buffer[2];
        result.tech_steps = buffer[3];
        result.tech_s2 = Math.round(buffer[4] * 1000) / 1000;
        result.tech_s3 = buffer[5];
        result.tech_ans = buffer[6];
      } else if (cal === "x" && func && point) {
        if (hasInvalidCharacters(func)) {
          result.error = "Please Enter Valid Input.";
          return result;
        }

        const parem = sanitizeEquation(func);
        const check = "x";

        // Make API call
        const response = await fetch("http://167.172.134.148/tangent_line", {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
          },
          body: new URLSearchParams({
            equ: parem,
            point: point,
            check: check,
          }),
          timeout: 120000,
        });

        if (!response.ok) {
          throw new Error("API request failed");
        }

        const buffer = await response.json();

        result.tech_point = point;
        result.tech_enter = buffer[0];
        result.tech_s1 = Math.round(buffer[1] * 1000) / 1000;
        result.tech_diff = buffer[2];
        result.tech_steps = buffer[3];
        result.tech_s2 = Math.round(buffer[4] * 1000) / 1000;
        result.tech_s3 = buffer[5];
        result.tech_ans = buffer[6];
      } else if (cal === "xy" && func && func1 && point) {
        if (hasInvalidCharacters(func) || hasInvalidCharacters(func1)) {
          result.error = "Please Enter Valid Input.";
          return result;
        }

        const parem = sanitizeEquation(func);
        const parem1 = sanitizeEquation(func1);
        const check = "xy";

        // Make API call
        const response = await fetch("http://167.172.134.148/tangent_line", {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
          },
          body: new URLSearchParams({
            equ: parem,
            point: point,
            check: check,
            equ1: parem1,
          }),
          timeout: 120000,
        });

        if (!response.ok) {
          throw new Error("API request failed");
        }

        const buffer = await response.json();

        result.tech_point = point;
        result.tech_enter = buffer[0];
        result.tech_enter1 = buffer[1];
        result.tech_s1 = Math.round(buffer[2] * 1000) / 1000;
        result.tech_diff = buffer[3];
        result.tech_steps = buffer[4];
        result.tech_s11 = Math.round(buffer[5] * 1000) / 1000;
        result.tech_diff1 = buffer[6];
        result.tech_steps1 = buffer[7];
        result.tech_s3 = buffer[8];
        result.tech_s4 = Math.round(buffer[9] * 1000) / 1000;
        result.tech_s5 = buffer[10];
        result.tech_ans = buffer[11];
      } else if (cal === "r" && func && point) {
        if (hasInvalidCharacters(func)) {
          result.error = "Please Enter Valid Input.";
          return result;
        }

        const parem = sanitizeEquation(func);
        const check = "r";

        // Make API call
        const response = await fetch("http://167.172.134.148/tangent_line", {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
          },
          body: new URLSearchParams({
            equ: parem,
            point: point,
            check: check,
          }),
          timeout: 120000,
        });

        if (!response.ok) {
          throw new Error("API request failed");
        }

        const buffer = await response.json();

        result.tech_point = point;
        result.tech_enter = buffer[0];
        result.tech_s1 = Math.round(buffer[1] * 1000) / 1000;
        result.tech_diff = buffer[2];
        result.tech_steps = buffer[3];
        result.tech_x0 = buffer[4];
        result.tech_y0 = buffer[5];
        result.tech_s2 = buffer[6];
        result.tech_s3 = buffer[7];
        result.tech_s4 = buffer[8];
        result.tech_s5 = buffer[9];
        result.tech_ans = buffer[10];
      } else {
        result.error = "Please Check Your Input.";
        return result;
      }

      return result;
    } catch (error) {
      console.error("Error in tangent line calculation:", error);
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /**
   * getCalculationOnesComplementCalculator: Service Method
   * POST: /api/calculators-lol/ones-complement-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationOnesComplementCalculator(body) {
    const cal = body.tech_cal;
    const dec = body.tech_dec;
    const bnry = body.tech_bnry;
    const hex = body.tech_hex;
    const bits = body.tech_bits;
    const no_of_bits = body.tech_no_of_bits;

    const result = {};

    // Security check function
    const hasInvalidCharacters = (input) => {
      const regex =
        /<|>|&|\/|\\\\|-|php|print_r|print|echo|script|=|sin|cos|tan|arcsin|arccos|arctan|&|%/i;
      return regex.test(input);
    };

    // Ones complement function
    const onesComplement = (str) => {
      const flip = (c) => (c == "0" ? "1" : "0");
      let ones = "";
      for (let i = 0; i < str.length; i++) {
        ones += flip(str[i]);
      }
      return ones;
    };

    // Add space function for binary formatting
    const addspace = (binary) => {
      const bit_len = binary.length;
      const s1 = Math.floor(bit_len / 4);
      const s2 = s1 * 4;
      const s3 = bit_len - s2;
      let res = "";
      const rem = bit_len % 4;
      const len = rem !== 0 ? s1 + 1 : s1;
      let space = 0;

      for (let i = 0; i < len; i++) {
        if (i == 0 && s3 != 0) {
          for (let j = 0; j <= s3; j++) {
            if (j !== s3) {
              res += binary[j];
            } else {
              res += " ";
              space++;
            }
          }
        } else {
          const s4 = res.length - space;
          for (let j = 0; j <= 4; j++) {
            if (j != 4) {
              res += binary[s4 + j];
            } else {
              res += " ";
              space++;
            }
          }
        }
      }
      return res.trim();
    };

    // Binary calculation function
    const bnry_cal = (dec, bits) => {
      let binary = (dec >>> 0).toString(2);
      const hex = parseInt(binary, 2).toString(16);
      const bit_len = binary.length;
      const n = bits - bit_len;

      if (dec < 0) {
        for (let i = 0; i < n; i++) {
          if (n < bits) {
            binary = "1" + binary;
          }
        }
      } else {
        for (let i = 0; i < n; i++) {
          if (n < bits) {
            binary = "0" + binary;
          }
        }
      }

      binary = binary.slice(-bits);
      let _1s = onesComplement(binary);
      _1s = addspace(_1s);
      const formattedBinary = addspace(binary);

      return {
        bits: bits,
        dec: dec,
        binary: formattedBinary,
        hex: hex,
        _1s: _1s,
      };
    };

    // Decimal calculation function
    const dec_cal = (bnry, bits) => {
      const dec = parseInt(bnry, 2);
      const hex = dec.toString(16);
      const bit_len = bnry.length;
      const n = bits - bit_len;
      let binary = bnry;

      if (dec < 0) {
        for (let i = 0; i < n; i++) {
          if (n < bits) {
            binary = "1" + binary;
          }
        }
      } else {
        for (let i = 0; i < n; i++) {
          if (n < bits) {
            binary = "0" + binary;
          }
        }
      }

      binary = binary.slice(-bits);
      let _1s = onesComplement(binary);
      _1s = addspace(_1s);
      const formattedBinary = addspace(binary);

      return {
        bits: bits,
        dec: dec,
        binary: formattedBinary,
        hex: hex,
        _1s: _1s,
      };
    };

    // Hexadecimal calculation function
    const hex_cal = (hex, bits) => {
      const dec = parseInt(hex, 16);
      let binary = dec.toString(2);
      const bit_len = binary.length;
      const n = bits - bit_len;

      for (let i = 0; i < n; i++) {
        if (n < bits) {
          binary = "0" + binary;
        }
      }

      binary = binary.slice(-bits);
      let _1s = onesComplement(binary);
      const formattedBinary = addspace(binary);
      _1s = addspace(_1s);

      return {
        bits: bits,
        dec: dec,
        binary: formattedBinary,
        hex: hex,
        _1s: _1s,
      };
    };

    // Input validation
    if (hasInvalidCharacters(hex)) {
      result.error = "Please Enter Valid Input.";
      return result;
    }

    let check = true;

    // Validate inputs based on calculation type
    if (cal == "bnry_cal") {
      if (!dec || isNaN(parseFloat(dec))) {
        check = false;
      }
    } else if (cal == "dec_cal") {
      if (!bnry || !/^[01]+$/.test(bnry)) {
        check = false;
      }
    } else if (cal == "hex_cal") {
      if (!hex) {
        check = false;
      }
    }

    if (!check) {
      result.error = "Please Check Your Input.";
      return result;
    }

    let calculationResult;

    try {
      if (cal == "bnry_cal") {
        const decimalValue = parseFloat(dec);
        check = false;

        if (bits == "4") {
          if (decimalValue >= -8 && decimalValue <= 7) {
            check = true;
            calculationResult = bnry_cal(decimalValue, 4);
          }
        } else if (bits == "8") {
          if (decimalValue >= -128 && decimalValue <= 127) {
            check = true;
            calculationResult = bnry_cal(decimalValue, 8);
          }
        } else if (bits == "12") {
          if (decimalValue >= -2048 && decimalValue <= 2047) {
            check = true;
            calculationResult = bnry_cal(decimalValue, 12);
          }
        } else if (bits == "16") {
          if (decimalValue >= -32768 && decimalValue <= 32767) {
            check = true;
            calculationResult = bnry_cal(decimalValue, 16);
          }
        } else {
          const customBits = parseInt(no_of_bits);
          if (customBits > 1 && customBits < 71) {
            const min = Math.pow(2, customBits - 1) * -1;
            const max = Math.pow(2, customBits - 1) - 1;
            if (decimalValue >= min && decimalValue <= max) {
              check = true;
              calculationResult = bnry_cal(decimalValue, customBits);
            }
          } else {
            result.error = "Please! Enter Number in Range (2-70).";
            return result;
          }
        }
      } else if (cal == "dec_cal") {
        check = false;
        const bnry_len = bnry.length;

        if (bits == "4") {
          if (bnry_len <= 4) {
            check = true;
            calculationResult = dec_cal(bnry, 4);
          }
        } else if (bits == "8") {
          if (bnry_len <= 8) {
            check = true;
            calculationResult = dec_cal(bnry, 8);
          }
        } else if (bits == "12") {
          if (bnry_len <= 12) {
            check = true;
            calculationResult = dec_cal(bnry, 12);
          }
        } else if (bits == "16") {
          if (bnry_len <= 16) {
            check = true;
            calculationResult = dec_cal(bnry, 16);
          }
        } else {
          const customBits = parseInt(no_of_bits);
          if (customBits > 1 && customBits < 71) {
            if (bnry_len > 0 && bnry_len <= customBits) {
              check = true;
              calculationResult = dec_cal(bnry, customBits);
            }
          } else {
            result.error = "Please! Enter Number in Range (2-70).";
            return result;
          }
        }
      } else if (cal == "hex_cal") {
        if (hex === "0") {
          result.error = "Undefined Value!";
          return result;
        }

        const hex_len = hex.length;
        if (hex_len > 16) {
          result.error = "Please! Enter Number in Range.";
          return result;
        } else {
          check = true;
          calculationResult = hex_cal(hex, 16);
        }
      } else {
        result.error = "Please Check Your Input.";
        return result;
      }
    } catch (error) {
      console.error("Calculation error:", error);
      result.error = "Please Check Your Input.";
      return result;
    }

    if (check && calculationResult) {
      result.tech_bit = calculationResult.bits;
      result.tech_dec = calculationResult.dec;
      result.tech_binary = calculationResult.binary;
      result.tech_hex = calculationResult.hex;
      result.tech_1s = calculationResult._1s;
    } else {
      result.error = "Please! Enter Number in Range.";
    }

    return result;
  }

  /**
   * getCalculationHypotenuseCalculator: Service Method
   * POST: /api/calculators-lol/hypotenuse-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationHypotenuseCalculator(body) {
    const cal_from = body.tech_cal_from;
    const cal = body.tech_cal;
    const cal_with = body.tech_cal_with;
    const cal_with1 = body.tech_cal_with1;
    const area = body.tech_area;
    const area_unit = body.tech_area_unit;
    const a = body.tech_a;
    const a_unit = body.tech_a_unit;
    const angle_a = body.tech_angle_a;
    const angle_a_unit = body.tech_angle_a_unit;
    const b = body.tech_b;
    const b_unit = body.tech_b_unit;
    const angle_b = body.tech_angle_b;
    const angle_b_unit = body.tech_angle_b_unit;

    const result = {};

    // Helper function to convert degrees to radians
    const deg2rad = (deg) => (deg * Math.PI) / 180;

    let s_a = parseFloat(a);
    let s_b = parseFloat(b);
    let ang_a = parseFloat(angle_a);
    let ang_b = parseFloat(angle_b);
    let area_val = parseFloat(area);

    // Convert side a units to cm
    if (!isNaN(s_a)) {
      switch (a_unit) {
        case "mm":
          s_a = s_a * 0.1;
          break;
        case "m":
          s_a = s_a * 100;
          break;
        case "km":
          s_a = s_a * 100000;
          break;
        case "in":
          s_a = s_a * 2.54;
          break;
        case "ft":
          s_a = s_a * 30.48;
          break;
        case "yd":
          s_a = s_a * 91.44;
          break;
        case "mi":
          s_a = s_a * 160934;
          break;
        case "nmi":
          s_a = s_a * 185200;
          break;
      }
    }

    // Convert side b units to cm
    if (!isNaN(s_b)) {
      switch (b_unit) {
        case "mm":
          s_b = s_b * 0.1;
          break;
        case "m":
          s_b = s_b * 100;
          break;
        case "km":
          s_b = s_b * 100000;
          break;
        case "in":
          s_b = s_b * 2.54;
          break;
        case "ft":
          s_b = s_b * 30.48;
          break;
        case "yd":
          s_b = s_b * 91.44;
          break;
        case "mi":
          s_b = s_b * 160934;
          break;
        case "nmi":
          s_b = s_b * 185200;
          break;
      }
    }

    // Convert angle a units to degrees
    if (!isNaN(ang_a)) {
      switch (angle_a_unit) {
        case "rad":
          ang_a = ang_a / 0.017453;
          break;
        case "gon":
          ang_a = ang_a / 1.111;
          break;
        case "tr":
          ang_a = ang_a / 0.002778;
          break;
        case "arcmin":
          ang_a = ang_a / 60;
          break;
        case "arcsec":
          ang_a = ang_a / 3600;
          break;
        case "mrad":
          ang_a = ang_a / 17.453;
          break;
        case "urad":
          ang_a = ang_a / 17453;
          break;
        case "pirad":
          ang_a = ang_a / 0.005556;
          break;
      }
    }

    // Convert angle b units to degrees
    if (!isNaN(ang_b)) {
      switch (angle_b_unit) {
        case "rad":
          ang_b = ang_b / 0.017453;
          break;
        case "gon":
          ang_b = ang_b / 1.111;
          break;
        case "tr":
          ang_b = ang_b / 0.002778;
          break;
        case "arcmin":
          ang_b = ang_b / 60;
          break;
        case "arcsec":
          ang_b = ang_b / 3600;
          break;
        case "mrad":
          ang_b = ang_b / 17.453;
          break;
        case "urad":
          ang_b = ang_b / 17453;
          break;
        case "pirad":
          ang_b = ang_b / 0.005556;
          break;
      }
    }

    // Convert area units to cm²
    if (!isNaN(area_val)) {
      switch (area_unit) {
        case "mm2":
          area_val = area_val * 0.01;
          break;
        case "dm2":
          area_val = area_val * 100;
          break;
        case "m2":
          area_val = area_val * 10000;
          break;
        case "km2":
          area_val = area_val * 10000000000;
          break;
        case "in2":
          area_val = area_val * 6.452;
          break;
        case "ft2":
          area_val = area_val * 929;
          break;
        case "yd2":
          area_val = area_val * 8361;
          break;
        case "mi2":
          area_val = area_val * 25899881103;
          break;
        case "ares":
          area_val = area_val * 1000000;
          break;
        case "da":
          area_val = area_val * 10000000;
          break;
        case "ha":
          area_val = area_val * 100000000;
          break;
        case "ac":
          area_val = area_val * 40468560;
          break;
        case "s_f":
          area_val = area_val * 71400000;
          break;
      }
    }

    try {
      if (cal_from == "two_sides" && !isNaN(s_a) && !isNaN(s_b)) {
        const s1 = Math.pow(s_a, 2);
        const s2 = Math.pow(s_b, 2);
        const s3 = s1 + s2;
        const c = Math.sqrt(s3);

        result.tech_two_sides = "two_sides";
        result.tech_c = Math.round(c * 1000) / 1000;
        result.tech_a = isNaN(s_a) ? "NaN" : s_a;
        result.tech_b = isNaN(s_b) ? "NaN" : s_b;
        result.tech_s1 = isNaN(s1) ? "NaN" : s1;
        result.tech_s2 = isNaN(s2) ? "NaN" : s2;
        result.tech_s3 = isNaN(s3) ? "NaN" : s3;
      } else if (
        cal_from == "angle_side" &&
        cal_with == "a_angle" &&
        !isNaN(ang_a) &&
        !isNaN(s_a)
      ) {
        const s1 = Math.sin(deg2rad(ang_a));
        const c = s_a / s1;

        result.tech_a_angle = "a_angle";
        result.tech_c = Math.round(c * 1000) / 1000;
        result.tech_angle_a = isNaN(ang_a) ? "NaN" : ang_a;
        result.tech_a = isNaN(s_a) ? "NaN" : s_a;
        result.tech_s1 = isNaN(s1) ? "NaN" : s1;
      } else if (
        cal_from == "angle_side" &&
        cal_with == "b_angle" &&
        !isNaN(ang_b) &&
        !isNaN(s_b)
      ) {
        const s1 = Math.sin(deg2rad(ang_b));
        const c = s_b / s1;

        result.tech_b_angle = "b_angle";
        result.tech_c = Math.round(c * 1000) / 1000;
        result.tech_angle_b = isNaN(ang_b) ? "NaN" : ang_b;
        result.tech_b = isNaN(s_b) ? "NaN" : s_b;
        result.tech_s1 = isNaN(s1) ? "NaN" : s1;
      } else if (
        cal_from == "area_side" &&
        cal == "hypo" &&
        cal_with1 == "area_a" &&
        !isNaN(area_val) &&
        !isNaN(s_a)
      ) {
        const s1 = Math.pow(s_a, 2);
        const s2 = area_val * 2;
        const s3 = s2 / s_a;
        const s4 = Math.pow(s3, 2);
        const s5 = s1 + s4;
        const c = Math.sqrt(s5);

        result.tech_hypo_a = "hypo_a";
        result.tech_c = Math.round(c * 1000) / 1000;
        result.tech_area = isNaN(area_val) ? "NaN" : area_val;
        result.tech_a = isNaN(s_a) ? "NaN" : s_a;
        result.tech_s1 = isNaN(s1) ? "NaN" : s1;
        result.tech_s2 = isNaN(s2) ? "NaN" : s2;
        result.tech_s3 = isNaN(s3) ? "NaN" : s3;
        result.tech_s4 = isNaN(s4) ? "NaN" : s4;
        result.tech_s5 = isNaN(s5) ? "NaN" : s5;
      } else if (
        cal_from == "area_side" &&
        cal == "hypo" &&
        cal_with1 == "area_b" &&
        !isNaN(area_val) &&
        !isNaN(s_b)
      ) {
        const s1 = Math.pow(s_b, 2);
        const s2 = area_val * 2;
        const s3 = s2 / s_b;
        const s4 = Math.pow(s3, 2);
        const s5 = s1 + s4;
        const c = Math.sqrt(s5);

        result.tech_hypo_b = "hypo_b";
        result.tech_c = Math.round(c * 1000) / 1000;
        result.tech_area = isNaN(area_val) ? "NaN" : area_val;
        result.tech_b = isNaN(s_b) ? "NaN" : s_b;
        result.tech_s1 = isNaN(s1) ? "NaN" : s1;
        result.tech_s2 = isNaN(s2) ? "NaN" : s2;
        result.tech_s3 = isNaN(s3) ? "NaN" : s3;
        result.tech_s4 = isNaN(s4) ? "NaN" : s4;
        result.tech_s5 = isNaN(s5) ? "NaN" : s5;
      } else if (
        cal_from == "area_side" &&
        cal == "area" &&
        !isNaN(s_a) &&
        !isNaN(s_b)
      ) {
        const s1 = s_a * s_b;
        const area_result = s1 / 2;

        result.tech_area_cal = "area_cal";
        result.tech_area = Math.round(area_result * 1000) / 1000;
        result.tech_a = isNaN(s_a) ? "NaN" : s_a;
        result.tech_b = isNaN(s_b) ? "NaN" : s_b;
        result.tech_s1 = isNaN(s1) ? "NaN" : s1;
      } else if (
        cal_from == "area_side" &&
        cal == "side_a" &&
        !isNaN(area_val) &&
        !isNaN(s_b)
      ) {
        const s1 = area_val * 2;
        const a_result = s1 / s_b;

        result.tech_side_a = "side_a";
        result.tech_a = Math.round(a_result * 1000) / 1000;
        result.tech_area = isNaN(area_val) ? "NaN" : area_val;
        result.tech_b = isNaN(s_b) ? "NaN" : s_b;
        result.tech_s1 = isNaN(s1) ? "NaN" : s1;
      } else if (
        cal_from == "area_side" &&
        cal == "side_b" &&
        !isNaN(area_val) &&
        !isNaN(s_a)
      ) {
        const s1 = area_val * 2;
        const b_result = s1 / s_a;

        result.tech_side_b = "side_b";
        result.tech_b = Math.round(b_result * 1000) / 1000;
        result.tech_area = isNaN(area_val) ? "NaN" : area_val;
        result.tech_a = isNaN(s_a) ? "NaN" : s_a;
        result.tech_s1 = isNaN(s1) ? "NaN" : s1;
      } else {
        result.error = "Please! Check Your Input.";
        return result;
      }

      return result;
    } catch (error) {
      console.error("Error in hypotenuse calculation:", error);
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /**
   * getCalculationAngleBetweenTwoVectorsCalculator: Service Method
   * POST: /api/calculators-lol/angle-between-two-vectors-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAngleBetweenTwoVectorsCalculator(body) {
    const dimen = body.tech_dimen;
    const a_rep = body.tech_a_rep;
    const ax = body.tech_ax;
    const ay = body.tech_ay;
    const az = body.tech_az;
    const a1 = body.tech_a1;
    const a2 = body.tech_a2;
    const a3 = body.tech_a3;

    const b_rep = body.tech_b_rep;
    const bx = body.tech_bx;
    const by = body.tech_by;
    const bz = body.tech_bz;
    const b1 = body.tech_b1;
    const b2 = body.tech_b2;
    const b3 = body.tech_b3;

    const aa1 = body.tech_aa1;
    const aa2 = body.tech_aa2;
    const aa3 = body.tech_aa3;

    const bb1 = body.tech_bb1;
    const bb2 = body.tech_bb2;
    const bb3 = body.tech_bb3;

    const submit = body.tech_submit;

    const result = {};

    // Helper function to check if all required fields are numeric
    const areAllNumeric = (...values) => {
      return values.every(
        (value) =>
          value != undefined &&
          value != null &&
          value != "" &&
          !isNaN(parseFloat(value))
      );
    };

    // Helper function to round numbers
    const round = (num, decimals = 5) => {
      return Math.round(num * Math.pow(10, decimals)) / Math.pow(10, decimals);
    };

    if (!submit) {
      result.error = "Please! Check Your Input";
      return result;
    }

    try {
      if (dimen == "3d") {
        if (a_rep == "coor" && b_rep == "coor") {
          if (areAllNumeric(ax, ay, az, bx, by, bz)) {
            const i = parseFloat(ax) * parseFloat(bx);
            const j = parseFloat(ay) * parseFloat(by);
            const k = parseFloat(az) * parseFloat(bz);
            const prod = i + j + k;

            const ax2 = Math.pow(parseFloat(ax), 2);
            const ay2 = Math.pow(parseFloat(ay), 2);
            const az2 = Math.pow(parseFloat(az), 2);
            const bx2 = Math.pow(parseFloat(bx), 2);
            const by2 = Math.pow(parseFloat(by), 2);
            const bz2 = Math.pow(parseFloat(bz), 2);

            const mgntd_a = Math.sqrt(ax2 + ay2 + az2);
            const mgntd_b = Math.sqrt(bx2 + by2 + bz2);
            const mgntd = mgntd_a * mgntd_b;

            const angle = prod / mgntd;
            const theta = Math.acos(angle);
            const deg = (theta * 180) / Math.PI;

            result.tech_i = i;
            result.tech_j = j;
            result.tech_k = k;
            result.tech_ax2 = ax2;
            result.tech_ay2 = ay2;
            result.tech_az2 = az2;
            result.tech_bx2 = bx2;
            result.tech_by2 = by2;
            result.tech_bz2 = bz2;
            result.tech_mgntd = round(mgntd, 5);
            result.tech_mgntd_a = round(mgntd_a, 5);
            result.tech_mgntd_b = round(mgntd_b, 5);
            result.tech_prod = prod;
            result.tech_angle = round(angle, 7);
            result.tech_deg = round(deg, 5);
          } else {
            result.error = "Please Fill All The Fields";
            return result;
          }
        } else if (a_rep == "coor" && b_rep == "point") {
          if (areAllNumeric(ax, ay, az, aa1, aa2, aa3, bb1, bb2, bb3)) {
            const bx_val = parseFloat(bb1) - parseFloat(aa1);
            const by_val = parseFloat(bb2) - parseFloat(aa2);
            const bz_val = parseFloat(bb3) - parseFloat(aa3);

            const i = parseFloat(ax) * bx_val;
            const j = parseFloat(ay) * by_val;
            const k = parseFloat(az) * bz_val;
            const prod = i + j + k;

            const ax2 = Math.pow(parseFloat(ax), 2);
            const ay2 = Math.pow(parseFloat(ay), 2);
            const az2 = Math.pow(parseFloat(az), 2);
            const bx2 = Math.pow(bx_val, 2);
            const by2 = Math.pow(by_val, 2);
            const bz2 = Math.pow(bz_val, 2);

            const mgntd_a = Math.sqrt(ax2 + ay2 + az2);
            const mgntd_b = Math.sqrt(bx2 + by2 + bz2);
            const mgntd = mgntd_a * mgntd_b;

            if (mgntd == 0) {
              result.error =
                "Your input give 0 answer Please Fill Correct Input";
              return result;
            }

            const angle = prod / mgntd;
            const theta = Math.acos(angle);
            const deg = (theta * 180) / Math.PI;

            result.tech_i = i;
            result.tech_j = j;
            result.tech_k = k;
            result.tech_bx = bx_val;
            result.tech_by = by_val;
            result.tech_bz = bz_val;
            result.tech_ax2 = ax2;
            result.tech_ay2 = ay2;
            result.tech_az2 = az2;
            result.tech_bx2 = bx2;
            result.tech_by2 = by2;
            result.tech_bz2 = bz2;
            result.tech_mgntd = round(mgntd, 5);
            result.tech_mgntd_a = round(mgntd_a, 5);
            result.tech_mgntd_b = round(mgntd_b, 5);
            result.tech_prod = prod;
            result.tech_angle = round(angle, 7);
            result.tech_deg = round(deg, 5);
          } else {
            result.error = "Please Fill All The Fields";
            return result;
          }
        } else if (a_rep == "point" && b_rep == "coor") {
          if (areAllNumeric(a1, a2, a3, b1, b2, b3, bx, by, bz)) {
            const ax_val = parseFloat(b1) - parseFloat(a1);
            const ay_val = parseFloat(b2) - parseFloat(a2);
            const az_val = parseFloat(b3) - parseFloat(a3);

            const i = ax_val * parseFloat(bx);
            const j = ay_val * parseFloat(by);
            const k = az_val * parseFloat(bz);
            const prod = i + j + k;

            const ax2 = Math.pow(ax_val, 2);
            const ay2 = Math.pow(ay_val, 2);
            const az2 = Math.pow(az_val, 2);
            const bx2 = Math.pow(parseFloat(bx), 2);
            const by2 = Math.pow(parseFloat(by), 2);
            const bz2 = Math.pow(parseFloat(bz), 2);

            const mgntd_a = Math.sqrt(ax2 + ay2 + az2);
            const mgntd_b = Math.sqrt(bx2 + by2 + bz2);
            const mgntd = mgntd_a * mgntd_b;

            const angle = prod / mgntd;
            const theta = Math.acos(angle);
            const deg = (theta * 180) / Math.PI;

            result.tech_i = i;
            result.tech_j = j;
            result.tech_k = k;
            result.tech_ax = ax_val;
            result.tech_ay = ay_val;
            result.tech_az = az_val;
            result.tech_ax2 = ax2;
            result.tech_ay2 = ay2;
            result.tech_az2 = az2;
            result.tech_bx2 = bx2;
            result.tech_by2 = by2;
            result.tech_bz2 = bz2;
            result.tech_mgntd = round(mgntd, 5);
            result.tech_mgntd_a = round(mgntd_a, 5);
            result.tech_mgntd_b = round(mgntd_b, 5);
            result.tech_prod = prod;
            result.tech_angle = round(angle, 7);
            result.tech_deg = round(deg, 5);
          } else {
            result.error = "Please Fill All The Fields";
            return result;
          }
        } else if (a_rep == "point" && b_rep == "point") {
          if (
            areAllNumeric(a1, a2, a3, b1, b2, b3, aa1, aa2, aa3, bb1, bb2, bb3)
          ) {
            const ax_val = parseFloat(b1) - parseFloat(a1);
            const ay_val = parseFloat(b2) - parseFloat(a2);
            const az_val = parseFloat(b3) - parseFloat(a3);
            const bx_val = parseFloat(bb1) - parseFloat(aa1);
            const by_val = parseFloat(bb2) - parseFloat(aa2);
            const bz_val = parseFloat(bb3) - parseFloat(aa3);

            const i = ax_val * bx_val;
            const j = ay_val * by_val;
            const k = az_val * bz_val;
            const prod = i + j + k;

            const ax2 = Math.pow(ax_val, 2);
            const ay2 = Math.pow(ay_val, 2);
            const az2 = Math.pow(az_val, 2);
            const bx2 = Math.pow(bx_val, 2);
            const by2 = Math.pow(by_val, 2);
            const bz2 = Math.pow(bz_val, 2);

            const mgntd_a = Math.sqrt(ax2 + ay2 + az2);
            const mgntd_b = Math.sqrt(bx2 + by2 + bz2);
            const mgntd = mgntd_a * mgntd_b;

            if (mgntd == 0) {
              result.error =
                "Your input give 0 answer Please Fill Correct Input";
              return result;
            }

            const angle = prod / mgntd;
            const theta = Math.acos(angle);
            const deg = (theta * 180) / Math.PI;

            result.tech_i = i;
            result.tech_j = j;
            result.tech_k = k;
            result.tech_ax = ax_val;
            result.tech_ay = ay_val;
            result.tech_az = az_val;
            result.tech_bx = bx_val;
            result.tech_by = by_val;
            result.tech_bz = bz_val;
            result.tech_ax2 = ax2;
            result.tech_ay2 = ay2;
            result.tech_az2 = az2;
            result.tech_bx2 = bx2;
            result.tech_by2 = by2;
            result.tech_bz2 = bz2;
            result.tech_mgntd = round(mgntd, 5);
            result.tech_mgntd_a = round(mgntd_a, 5);
            result.tech_mgntd_b = round(mgntd_b, 5);
            result.tech_prod = prod;
            result.tech_angle = round(angle, 7);
            result.tech_deg = round(deg, 5);
          } else {
            result.error = "Please Fill All The Fields";
            return result;
          }
        } else {
          result.error = "Please! Check Your Input";
          return result;
        }
      } else if (dimen == "2d") {
        if (a_rep == "coor" && b_rep == "coor") {
          if (areAllNumeric(ax, ay, bx, by)) {
            const i = parseFloat(ax) * parseFloat(bx);
            const j = parseFloat(ay) * parseFloat(by);
            const prod = i + j;

            const ax2 = Math.pow(parseFloat(ax), 2);
            const ay2 = Math.pow(parseFloat(ay), 2);
            const bx2 = Math.pow(parseFloat(bx), 2);
            const by2 = Math.pow(parseFloat(by), 2);

            const mgntd_a = Math.sqrt(ax2 + ay2);
            const mgntd_b = Math.sqrt(bx2 + by2);
            const mgntd = mgntd_a * mgntd_b;

            const angle = prod / mgntd;
            const theta = Math.acos(angle);
            const deg = (theta * 180) / Math.PI;

            result.tech_i = i;
            result.tech_j = j;
            result.tech_ax2 = ax2;
            result.tech_ay2 = ay2;
            result.tech_bx2 = bx2;
            result.tech_by2 = by2;
            result.tech_mgntd = round(mgntd, 5);
            result.tech_mgntd_a = round(mgntd_a, 5);
            result.tech_mgntd_b = round(mgntd_b, 5);
            result.tech_prod = prod;
            result.tech_angle = round(angle, 7);
            result.tech_deg = round(deg, 5);
          } else {
            result.error = "Please Fill All The Fields";
            return result;
          }
        } else if (a_rep == "coor" && b_rep == "point") {
          if (areAllNumeric(ax, ay, aa1, aa2, bb1, bb2)) {
            const bx_val = parseFloat(bb1) - parseFloat(aa1);
            const by_val = parseFloat(bb2) - parseFloat(aa2);

            const i = parseFloat(ax) * bx_val;
            const j = parseFloat(ay) * by_val;
            const prod = i + j;

            const ax2 = Math.pow(parseFloat(ax), 2);
            const ay2 = Math.pow(parseFloat(ay), 2);
            const bx2 = Math.pow(bx_val, 2);
            const by2 = Math.pow(by_val, 2);

            const mgntd_a = Math.sqrt(ax2 + ay2);
            const mgntd_b = Math.sqrt(bx2 + by2);
            const mgntd = mgntd_a * mgntd_b;

            const angle = prod / mgntd;
            const theta = Math.acos(angle);
            const deg = (theta * 180) / Math.PI;

            result.tech_i = i;
            result.tech_j = j;
            result.tech_bx = bx_val;
            result.tech_by = by_val;
            result.tech_ax2 = ax2;
            result.tech_ay2 = ay2;
            result.tech_bx2 = bx2;
            result.tech_by2 = by2;
            result.tech_mgntd = round(mgntd, 5);
            result.tech_mgntd_a = round(mgntd_a, 5);
            result.tech_mgntd_b = round(mgntd_b, 5);
            result.tech_prod = prod;
            result.tech_angle = round(angle, 7);
            result.tech_deg = round(deg, 5);
          } else {
            result.error = "Please Fill All The Fields";
            return result;
          }
        } else if (a_rep == "point" && b_rep == "coor") {
          if (areAllNumeric(a1, a2, b1, b2, bx, by)) {
            const ax_val = parseFloat(b1) - parseFloat(a1);
            const ay_val = parseFloat(b2) - parseFloat(a2);

            const i = ax_val * parseFloat(bx);
            const j = ay_val * parseFloat(by);
            const prod = i + j;

            const ax2 = Math.pow(ax_val, 2);
            const ay2 = Math.pow(ay_val, 2);
            const bx2 = Math.pow(parseFloat(bx), 2);
            const by2 = Math.pow(parseFloat(by), 2);

            const mgntd_a = Math.sqrt(ax2 + ay2);
            const mgntd_b = Math.sqrt(bx2 + by2);
            const mgntd = mgntd_a * mgntd_b;

            const angle = prod / mgntd;
            const theta = Math.acos(angle);
            const deg = (theta * 180) / Math.PI;

            result.tech_i = i;
            result.tech_j = j;
            result.tech_ax = ax_val;
            result.tech_ay = ay_val;
            result.tech_ax2 = ax2;
            result.tech_ay2 = ay2;
            result.tech_bx2 = bx2;
            result.tech_by2 = by2;
            result.tech_mgntd = round(mgntd, 5);
            result.tech_mgntd_a = round(mgntd_a, 5);
            result.tech_mgntd_b = round(mgntd_b, 5);
            result.tech_prod = prod;
            result.tech_angle = round(angle, 7);
            result.tech_deg = round(deg, 5);
          } else {
            result.error = "Please Fill All The Fields";
            return result;
          }
        } else if (a_rep == "point" && b_rep == "point") {
          if (areAllNumeric(a1, a2, b1, b2, aa1, aa2, bb1, bb2)) {
            const ax_val = parseFloat(b1) - parseFloat(a1);
            const ay_val = parseFloat(b2) - parseFloat(a2);
            const bx_val = parseFloat(bb1) - parseFloat(aa1);
            const by_val = parseFloat(bb2) - parseFloat(aa2);

            const i = ax_val * bx_val;
            const j = ay_val * by_val;
            const prod = i + j;

            const ax2 = Math.pow(ax_val, 2);
            const ay2 = Math.pow(ay_val, 2);
            const bx2 = Math.pow(bx_val, 2);
            const by2 = Math.pow(by_val, 2);

            const mgntd_a = Math.sqrt(ax2 + ay2);
            const mgntd_b = Math.sqrt(bx2 + by2);
            const mgntd = mgntd_a * mgntd_b;

            const angle = prod / mgntd;
            const theta = Math.acos(angle);
            const deg = (theta * 180) / Math.PI;

            result.tech_i = i;
            result.tech_j = j;
            result.tech_ax = ax_val;
            result.tech_ay = ay_val;
            result.tech_bx = bx_val;
            result.tech_by = by_val;
            result.tech_ax2 = ax2;
            result.tech_ay2 = ay2;
            result.tech_bx2 = bx2;
            result.tech_by2 = by2;
            result.tech_mgntd = round(mgntd, 5);
            result.tech_mgntd_a = round(mgntd_a, 5);
            result.tech_mgntd_b = round(mgntd_b, 5);
            result.tech_prod = prod;
            result.tech_angle = round(angle, 7);
            result.tech_deg = round(deg, 5);
          } else {
            result.error = "Please Fill All The Fields";
            return result;
          }
        } else {
          result.error = "Please! Check Your Input";
          return result;
        }
      } else {
        result.error = "Please! Check Your Input";
        return result;
      }

      return result;
    } catch (error) {
      console.error("Error in angle calculation:", error);
      result.error = "Please! Check Your Input";
      return result;
    }
  }

  /**
   * getCalculationDirectionalDerivativeCalculator: Service Method
   * POST: /api/calculators-lol/directional-derivative-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDirectionalDerivativeCalculator(body) {
    const EnterEq = body.tech_EnterEq;
    const u1 = body.tech_u1;
    const u2 = body.tech_u2;
    const u3 = body.tech_u3;
    const x = body.tech_x;
    const y = body.tech_y;
    const z = body.tech_z;
    const type = body.tech_type;

    const result = {};

    // Helper function to sanitize and format the equation
    const sanitizeEquation = (equation) => {
      let sanitized = equation.replace(/\s/g, "");
      sanitized = sanitized.replace(/%20/g, "");
      sanitized = sanitized.replace(/\+/g, "plus");
      sanitized = sanitized.replace(/{/g, "(");
      sanitized = sanitized.replace(/}/g, ")");
      sanitized = sanitized.replace(/e\^x/g, "exp(x)");
      sanitized = sanitized.replace(/e\^y/g, "exp(y)");
      sanitized = sanitized.replace(/e\^z/g, "exp(z)");
      sanitized = sanitized.replace(/e\^/g, "exp");
      sanitized = sanitized.replace(/exp\^/g, "exp");
      sanitized = sanitized.replace(/\^/g, "**");
      sanitized = sanitized.replace(/e\^sqrt\(x\)/g, "exp(2*x)");
      return sanitized;
    };

    // Security check function
    const hasInvalidCharacters = (input) => {
      const regex = /<|>|&|php|print_r|print|echo|script|=|&|%/i;
      return regex.test(input);
    };

    // Helper function to check if all required fields are numeric
    const areAllNumeric = (...values) => {
      return values.every(
        (value) =>
          value !== undefined &&
          value !== null &&
          value !== "" &&
          !isNaN(parseFloat(value))
      );
    };

    // Helper function to round numbers
    const round = (num, decimals = 5) => {
      return Math.round(num * Math.pow(10, decimals)) / Math.pow(10, decimals);
    };

    try {
      if (type == "two") {
        // Security check
        if (hasInvalidCharacters(EnterEq)) {
          result.error = "Please Enter Valid Input.";
          return result;
        }

        // Input validation
        if (!areAllNumeric(u1, u2, x, y) || !EnterEq) {
          result.error = "Please! Check Your Input.";
          return result;
        }

        const parem = sanitizeEquation(EnterEq);
        const u1_val = parseFloat(u1);
        const u2_val = parseFloat(u2);
        const x_val = parseFloat(x);
        const y_val = parseFloat(y);

        // Calculate magnitude and unit vector
        const mag = Math.sqrt(Math.pow(u1_val, 2) + Math.pow(u2_val, 2));
        const one = u1_val / mag;
        const two = u2_val / mag;

        // Make API call
        const params = new URLSearchParams({
          equ: parem,
          x: x_val.toString(),
          y: y_val.toString(),
          u1: u1_val.toString(),
          u2: u2_val.toString(),
          type: type,
        });

        const response = await fetch(
          `http://167.172.134.148/direct?${params.toString()}`,
          {
            method: "GET",
            timeout: 120000,
          }
        );

        if (!response.ok) {
          throw new Error("API request failed");
        }

        const buffer = await response.text();
        const bufferArray = buffer.split("@@@");

        if (bufferArray.length < 5) {
          throw new Error("Invalid response from API");
        }

        const x1 = parseFloat(bufferArray[2]);
        const y1 = parseFloat(bufferArray[3]);
        const ans = x1 * one + y1 * two;

        result.tech_difs1 = bufferArray[0];
        result.tech_difs2 = bufferArray[1];
        result.tech_x1 = round(x1, 5);
        result.tech_y1 = round(y1, 5);
        result.tech_enter = bufferArray[4];
        result.tech_mag = mag;
        result.tech_ans = ans;
      } else if (type == "three") {
        // Security check
        if (hasInvalidCharacters(EnterEq)) {
          result.error = "Please Enter Valid Input.";
          return result;
        }

        // Input validation
        if (!areAllNumeric(u1, u2, u3, x, y, z) || !EnterEq) {
          result.error = "Please! Check Your Input.";
          return result;
        }

        const parem = sanitizeEquation(EnterEq);
        const u1_val = parseFloat(u1);
        const u2_val = parseFloat(u2);
        const u3_val = parseFloat(u3);
        const x_val = parseFloat(x);
        const y_val = parseFloat(y);
        const z_val = parseFloat(z);

        // Calculate magnitude and unit vector
        const mag = Math.sqrt(
          Math.pow(u1_val, 2) + Math.pow(u2_val, 2) + Math.pow(u3_val, 2)
        );
        const one = u1_val / mag;
        const two = u2_val / mag;
        const three = u3_val / mag;

        // Make API call
        const params = new URLSearchParams({
          equ: parem,
          x: x_val.toString(),
          y: y_val.toString(),
          z: z_val.toString(),
          u1: u1_val.toString(),
          u2: u2_val.toString(),
          u3: u3_val.toString(),
          type: type,
        });

        const response = await fetch(
          `http://167.172.134.148/direct?${params.toString()}`,
          {
            method: "GET",
            timeout: 120000,
          }
        );

        if (!response.ok) {
          throw new Error("API request failed");
        }

        const buffer = await response.text();
        const bufferArray = buffer.split("@@@");

        if (bufferArray.length < 7) {
          throw new Error("Invalid response from API");
        }

        const x1 = parseFloat(bufferArray[3]);
        const y1 = parseFloat(bufferArray[4]);
        const z1 = parseFloat(bufferArray[5]);
        const ans = x1 * one + y1 * two + z1 * three;

        result.tech_difs1 = bufferArray[0];
        result.tech_difs2 = bufferArray[1];
        result.tech_difs3 = bufferArray[2];
        result.tech_x1 = round(x1, 5);
        result.tech_y1 = round(y1, 5);
        result.tech_z1 = round(z1, 5);
        result.tech_enter = bufferArray[6];
        result.tech_mag = mag;
        result.tech_ans = ans;
      } else {
        result.error = "Please! Check Your Input.";
        return result;
      }

      return result;
    } catch (error) {
      console.error("Error in directional derivative calculation:", error);
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /**
   * getCalculationEigenvaluesCalculator: Service Method
   * POST: /api/calculators-lol/eigenvalues-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationEigenvaluesCalculator(body) {
    const matrix = body.tech_matrix;

    const matrix_0_0 = body.tech_matrix_0_0;
    const matrix_0_1 = body.tech_matrix_0_1;
    const matrix_0_2 = body.tech_matrix_0_2;
    const matrix_0_3 = body.tech_matrix_0_3;
    const matrix_0_4 = body.tech_matrix_0_4;

    const matrix_1_0 = body.tech_matrix_1_0;
    const matrix_1_1 = body.tech_matrix_1_1;
    const matrix_1_2 = body.tech_matrix_1_2;
    const matrix_1_3 = body.tech_matrix_1_3;
    const matrix_1_4 = body.tech_matrix_1_4;

    const matrix_2_0 = body.tech_matrix_2_0;
    const matrix_2_1 = body.tech_matrix_2_1;
    const matrix_2_2 = body.tech_matrix_2_2;
    const matrix_2_3 = body.tech_matrix_2_3;
    const matrix_2_4 = body.tech_matrix_2_4;

    const matrix_3_0 = body.tech_matrix_3_0;
    const matrix_3_1 = body.tech_matrix_3_1;
    const matrix_3_2 = body.tech_matrix_3_2;
    const matrix_3_3 = body.tech_matrix_3_3;
    const matrix_3_4 = body.tech_matrix_3_4;

    const matrix_4_0 = body.tech_matrix_4_0;
    const matrix_4_1 = body.tech_matrix_4_1;
    const matrix_4_2 = body.tech_matrix_4_2;
    const matrix_4_3 = body.tech_matrix_4_3;
    const matrix_4_4 = body.tech_matrix_4_4;

    const result = {};

    // Helper function to check if all required fields are numeric
    const areAllNumeric = (...values) => {
      return values.every(
        (value) =>
          value !== undefined &&
          value !== null &&
          value !== "" &&
          !isNaN(parseFloat(value))
      );
    };

    try {
      if (
        matrix == "2" &&
        areAllNumeric(matrix_0_0, matrix_0_1, matrix_1_0, matrix_1_1)
      ) {
        const params = new URLSearchParams({
          matrix: matrix,
          matrix_0_0: matrix_0_0.toString(),
          matrix_0_1: matrix_0_1.toString(),
          matrix_1_0: matrix_1_0.toString(),
          matrix_1_1: matrix_1_1.toString(),
        });

        const response = await fetch(
          `http://167.172.134.148/eigenvalues?${params.toString()}`,
          {
            method: "GET",
            timeout: 120000,
          }
        );

        if (!response.ok) {
          throw new Error("API request failed");
        }

        const buffer = await response.text();
        const bufferArray = buffer.split("@@@");

        if (bufferArray.length < 5) {
          throw new Error("Invalid response from API");
        }

        result.tech_eigvals = bufferArray[0];
        result.tech_d = bufferArray[1];
        result.tech_dtrmnt = bufferArray[2];
        result.tech_l1 = bufferArray[3];
        result.tech_l2 = bufferArray[4];
      } else if (
        matrix == "3" &&
        areAllNumeric(
          matrix_0_0,
          matrix_0_1,
          matrix_0_2,
          matrix_1_0,
          matrix_1_1,
          matrix_1_2,
          matrix_2_0,
          matrix_2_1,
          matrix_2_2
        )
      ) {
        const params = new URLSearchParams({
          matrix: matrix,
          matrix_0_0: matrix_0_0.toString(),
          matrix_0_1: matrix_0_1.toString(),
          matrix_0_2: matrix_0_2.toString(),
          matrix_1_0: matrix_1_0.toString(),
          matrix_1_1: matrix_1_1.toString(),
          matrix_1_2: matrix_1_2.toString(),
          matrix_2_0: matrix_2_0.toString(),
          matrix_2_1: matrix_2_1.toString(),
          matrix_2_2: matrix_2_2.toString(),
        });

        const response = await fetch(
          `http://167.172.134.148/eigenvalues?${params.toString()}`,
          {
            method: "GET",
            timeout: 120000,
          }
        );

        if (!response.ok) {
          throw new Error("API request failed");
        }

        const buffer = await response.text();
        const bufferArray = buffer.split("@@@");

        if (bufferArray.length < 6) {
          throw new Error("Invalid response from API");
        }

        result.tech_eigvals = bufferArray[0];
        result.tech_d = bufferArray[1];
        result.tech_dtrmnt = bufferArray[2];
        result.tech_l1 = bufferArray[3];
        result.tech_l2 = bufferArray[4];
        result.tech_l3 = bufferArray[5];
      } else if (
        matrix == "4" &&
        areAllNumeric(
          matrix_0_0,
          matrix_0_1,
          matrix_0_2,
          matrix_0_3,
          matrix_1_0,
          matrix_1_1,
          matrix_1_2,
          matrix_1_3,
          matrix_2_0,
          matrix_2_1,
          matrix_2_2,
          matrix_2_3,
          matrix_3_0,
          matrix_3_1,
          matrix_3_2,
          matrix_3_3
        )
      ) {
        const params = new URLSearchParams({
          matrix: matrix,
          matrix_0_0: matrix_0_0.toString(),
          matrix_0_1: matrix_0_1.toString(),
          matrix_0_2: matrix_0_2.toString(),
          matrix_0_3: matrix_0_3.toString(),
          matrix_1_0: matrix_1_0.toString(),
          matrix_1_1: matrix_1_1.toString(),
          matrix_1_2: matrix_1_2.toString(),
          matrix_1_3: matrix_1_3.toString(),
          matrix_2_0: matrix_2_0.toString(),
          matrix_2_1: matrix_2_1.toString(),
          matrix_2_2: matrix_2_2.toString(),
          matrix_2_3: matrix_2_3.toString(),
          matrix_3_0: matrix_3_0.toString(),
          matrix_3_1: matrix_3_1.toString(),
          matrix_3_2: matrix_3_2.toString(),
          matrix_3_3: matrix_3_3.toString(),
        });

        const response = await fetch(
          `http://167.172.134.148/eigenvalues?${params.toString()}`,
          {
            method: "GET",
            timeout: 120000,
          }
        );

        if (!response.ok) {
          throw new Error("API request failed");
        }

        const buffer = await response.text();
        const bufferArray = buffer.split("@@@");

        if (bufferArray.length < 7) {
          throw new Error("Invalid response from API");
        }

        result.tech_eigvals = bufferArray[0];
        result.tech_d = bufferArray[1];
        result.tech_dtrmnt = bufferArray[2];
        result.tech_l1 = bufferArray[3];
        result.tech_l2 = bufferArray[4];
        result.tech_l3 = bufferArray[5];
        result.tech_l4 = bufferArray[6];
      } else if (
        matrix == "5" &&
        areAllNumeric(
          matrix_0_0,
          matrix_0_1,
          matrix_0_2,
          matrix_0_3,
          matrix_0_4,
          matrix_1_0,
          matrix_1_1,
          matrix_1_2,
          matrix_1_3,
          matrix_1_4,
          matrix_2_0,
          matrix_2_1,
          matrix_2_2,
          matrix_2_3,
          matrix_2_4,
          matrix_3_0,
          matrix_3_1,
          matrix_3_2,
          matrix_3_3,
          matrix_3_4,
          matrix_4_0,
          matrix_4_1,
          matrix_4_2,
          matrix_4_3,
          matrix_4_4
        )
      ) {
        const params = new URLSearchParams({
          matrix: matrix,
          matrix_0_0: matrix_0_0.toString(),
          matrix_0_1: matrix_0_1.toString(),
          matrix_0_2: matrix_0_2.toString(),
          matrix_0_3: matrix_0_3.toString(),
          matrix_0_4: matrix_0_4.toString(),
          matrix_1_0: matrix_1_0.toString(),
          matrix_1_1: matrix_1_1.toString(),
          matrix_1_2: matrix_1_2.toString(),
          matrix_1_3: matrix_1_3.toString(),
          matrix_1_4: matrix_1_4.toString(),
          matrix_2_0: matrix_2_0.toString(),
          matrix_2_1: matrix_2_1.toString(),
          matrix_2_2: matrix_2_2.toString(),
          matrix_2_3: matrix_2_3.toString(),
          matrix_2_4: matrix_2_4.toString(),
          matrix_3_0: matrix_3_0.toString(),
          matrix_3_1: matrix_3_1.toString(),
          matrix_3_2: matrix_3_2.toString(),
          matrix_3_3: matrix_3_3.toString(),
          matrix_3_4: matrix_3_4.toString(),
          matrix_4_0: matrix_4_0.toString(),
          matrix_4_1: matrix_4_1.toString(),
          matrix_4_2: matrix_4_2.toString(),
          matrix_4_3: matrix_4_3.toString(),
          matrix_4_4: matrix_4_4.toString(),
        });

        const response = await fetch(
          `http://167.172.134.148/eigenvalues?${params.toString()}`,
          {
            method: "GET",
            timeout: 120000,
          }
        );

        if (!response.ok) {
          throw new Error("API request failed");
        }

        const buffer = await response.text();
        const bufferArray = buffer.split("@@@");

        if (bufferArray.length < 8) {
          throw new Error("Invalid response from API");
        }

        result.tech_eigvals = bufferArray[0];
        result.tech_d = bufferArray[1];
        result.tech_dtrmnt = bufferArray[2];
        result.tech_l1 = bufferArray[3];
        result.tech_l2 = bufferArray[4];
        result.tech_l3 = bufferArray[5];
        result.tech_l4 = bufferArray[6];
        result.tech_l5 = bufferArray[7];
      } else {
        result.error = "Please! Check Your Input.";
        return result;
      }

      return result;
    } catch (error) {
      console.error("Error in eigenvalues calculation:", error);
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /** getCalculationEigenvectorCalculator
   * POST: /api/calculators-lol/eigenvectors-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationEigenvectorCalculator(body) {
    let matrix = body.tech_matrix;
    let matrix_0_0 = body.tech_matrix_0_0;
    let matrix_0_1 = body.tech_matrix_0_1;
    let matrix_0_2 = body.tech_matrix_0_2;
    let matrix_1_0 = body.tech_matrix_1_0;
    let matrix_1_1 = body.tech_matrix_1_1;
    let matrix_1_2 = body.tech_matrix_1_2;
    let matrix_2_0 = body.tech_matrix_2_0;
    let matrix_2_1 = body.tech_matrix_2_1;
    let matrix_2_2 = body.tech_matrix_2_2;

    function isNumeric(val) {
      return !isNaN(parseFloat(val)) && isFinite(val);
    }

    try {
      let params = {};
      if (
        matrix === "2" &&
        isNumeric(matrix_0_0) &&
        isNumeric(matrix_0_1) &&
        isNumeric(matrix_1_0) &&
        isNumeric(matrix_1_1)
      ) {
        params = {
          matrix,
          matrix_0_0,
          matrix_0_1,
          matrix_1_0,
          matrix_1_1,
        };
      } else if (
        matrix === "3" &&
        isNumeric(matrix_0_0) &&
        isNumeric(matrix_0_1) &&
        isNumeric(matrix_0_2) &&
        isNumeric(matrix_1_0) &&
        isNumeric(matrix_1_1) &&
        isNumeric(matrix_1_2) &&
        isNumeric(matrix_2_0) &&
        isNumeric(matrix_2_1) &&
        isNumeric(matrix_2_2)
      ) {
        params = {
          matrix,
          matrix_0_0,
          matrix_0_1,
          matrix_0_2,
          matrix_1_0,
          matrix_1_1,
          matrix_1_2,
          matrix_2_0,
          matrix_2_1,
          matrix_2_2,
        };
      } else {
        return { error: "Please! Check Your Input." };
      }

      const response = await axios.get("http://167.172.134.148/eigenvectors", {
        params,
      });
      const buffer = response.data.split("@@@");

      if (matrix === "2") {
        return {
          tech_eigvecs: buffer[0],
          tech_d: buffer[1],
          tech_dtrmnt: buffer[2],
          tech_l1: buffer[3],
          tech_l2: buffer[4],
          tech_mul: buffer[5],
          tech_eigvals: buffer[6],
          tech_eigvals1: buffer[7],
          tech_eigvals2: buffer[8],
          tech_a: buffer[9],
          tech_eigvecs1: buffer[10],
          tech_eigvecs2: buffer[11],
          tech_b: buffer[12],
          tech_res1: buffer[13],
          tech_res2: buffer[14],
        };
      } else {
        return {
          tech_eigvecs: buffer[0],
          tech_d: buffer[1],
          tech_dtrmnt: buffer[2],
          tech_l1: buffer[3],
          tech_l2: buffer[4],
          tech_l3: buffer[5],
          tech_mul: buffer[6],
          tech_eigvals: buffer[7],
          tech_eigvals1: buffer[8],
          tech_eigvals2: buffer[9],
          tech_eigvals3: buffer[10],
          tech_a: buffer[11],
          tech_eigvecs1: buffer[12],
          tech_eigvecs2: buffer[13],
          tech_eigvecs3: buffer[14],
          tech_b: buffer[15],
          tech_res1: buffer[16],
          tech_res2: buffer[17],
          tech_res3: buffer[18],
          tech_c: buffer[19],
        };
      }
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }
  /** getCalculationNullSpaceCalculator
   * POST: /api/calculators-lol/null-space-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationNullSpaceCalculator(body) {
    let row = body.tech_row;
    let colum = body.tech_colum;

    let input = "";

    for (let i = 0; i < row; i++) {
      for (let j = 0; j < colum; j++) {
        let key = `tech_matrix_${i}_${j}`;
        if (!isNumeric(body[key])) {
          return { error: "Please enter only numeric values." };
        }

        input += body[key];
        if (j !== colum - 1) input += ",";
      }
      if (i !== row - 1) input += "@@";
    }

    try {
      const response = await axios.get("http://167.172.134.148/null", {
        params: { mat: input },
        timeout: 120000,
      });

      const buffer = response.data.split("@@@");
      let reff = buffer[0].replace("\\left( \\left[", "\\left[");
      reff = reff.split("\\left(")[0].split(",");

      return {
        tech_rref: reff[0],
        tech_null: buffer[1],
        tech_enter: buffer[2],
        tech_total: buffer[3],
        tech_input: input,
        tech_row: row,
        tech_colum: colum,
      };
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }

    function isNumeric(val) {
      return !isNaN(parseFloat(val)) && isFinite(val);
    }
  }

  /** getCalculationMatrixMultiplicationCalculator
   * POST: /api/calculators-lol/matrix-multiplication-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMatrixMultiplicationCalculator(body) {
    let rows1 = body.tech_rows1;
    let columns1 = body.tech_columns1;
    let matrix2 = body.tech_matrix2;
    let matrix22 = body.tech_matrix22;

    let r = [],
      m = [],
      l = [];

    function isNumeric(val) {
      return !isNaN(parseFloat(val)) && isFinite(val);
    }

    if (columns1 != matrix2) {
      return {
        error:
          "The number of columns in the first matrix should be equal to the number of rows in the second.",
      };
    }

    // First matrix validation and flattening
    for (let i = 1; i <= rows1; i++) {
      for (let j = 1; j <= columns1; j++) {
        let key = `tech_matrix${i}_${j}`;
        if (body[key] !== undefined && isNumeric(body[key])) {
          r.push(parseFloat(body[key]));
        } else {
          return { error: "Please! Check Your Input.111" };
        }
      }
    }

    // Second matrix validation and flattening
    for (let i = 1; i <= matrix2; i++) {
      for (let j = 1; j <= matrix22; j++) {
        let key = `tech_matrix3${i}_${j}`;
        if (body[key] !== undefined && isNumeric(body[key])) {
          m.push(parseFloat(body[key]));
        } else {
          return { error: "Please! Check Your Input.2222" };
        }
      }
    }

    // Matrix multiplication
    let result = [];
    for (let i = 1; i <= rows1; i++) {
      result[i] = [];
      for (let j = 1; j <= matrix22; j++) {
        result[i][j] = 0;
        for (let k = 1; k <= matrix2; k++) {
          result[i][j] +=
            parseFloat(body[`tech_matrix${i}_${k}`]) *
            parseFloat(body[`tech_matrix3${k}_${j}`]);
        }
        l.push(result[i][j]);
      }
    }

    return {
      tech_r: r,
      tech_l: l,
    };
  }

  /**
   * getCalculationEquationOfCircleCalculator: Service Method
   * POST: /api/calculators-lol/equation-of-a-circle
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationEquationOfCircleCalculator(body) {
    const from = body.tech_from;
    const a = body.tech_a;
    const b = body.tech_b;
    const c = body.tech_c;

    const x1 = body.tech_x1;
    const y1 = body.tech_y1;
    const r = body.tech_r;

    const h1 = body.tech_h1;
    const k1 = body.tech_k1;

    const result = {};

    // Helper function to check if all required fields are numeric
    const areAllNumeric = (...values) => {
      return values.every(
        (value) =>
          value !== undefined &&
          value !== null &&
          value !== "" &&
          !isNaN(parseFloat(value))
      );
    };

    // Helper function to format numbers to 2 decimal places
    const formatNumber = (num) => {
      return Math.round(num * 100) / 100;
    };

    try {
      let A,
        B,
        C,
        D,
        E,
        F,
        radius,
        diameter,
        sq_radius,
        area,
        circumference,
        eccentricity,
        d1,
        d2,
        r1,
        r2;

      if (from === "1") {
        if (areAllNumeric(a, b, c)) {
          const c_val = parseFloat(c);
          if (c_val > 0) {
            radius = Math.sqrt(c_val);
            diameter = 2 * radius;
            sq_radius = Math.pow(radius, 2);
            area = sq_radius * Math.PI;
            circumference = diameter * Math.PI;
            A = parseFloat(a);
            B = parseFloat(b);
            C = c_val;
            D = A * -2;
            E = B * -2;
            const F_f1 = Math.pow(A, 2);
            const F_f2 = Math.pow(B, 2);
            const F_f3 = F_f1 + F_f2;
            F = F_f3 - c_val;
            d1 = A - radius;
            d2 = A + radius;
            r1 = B - radius;
            r2 = B + radius;
            eccentricity = 0;
          } else {
            result.error = "Such circle (C) does not exist.";
            return result;
          }
        } else {
          result.error = "Please! Check Your Input.";
          return result;
        }
      } else if (from === "2") {
        if (areAllNumeric(a, b, c)) {
          radius = parseFloat(c);
          diameter = 2 * radius;
          sq_radius = Math.pow(radius, 2);
          area = sq_radius * Math.PI;
          circumference = diameter * Math.PI;
          eccentricity = 0;
          A = parseFloat(a);
          B = parseFloat(b);
          C = radius;
          D = A * -2;
          E = B * -2;
          const F_f1 = Math.pow(A, 2);
          const F_f2 = Math.pow(B, 2);
          const F_f3 = F_f1 + F_f2;
          F = F_f3 - sq_radius;
          d1 = A - radius;
          d2 = A + radius;
          r1 = B - radius;
          r2 = B + radius;
        } else {
          result.error = "Please check your input.";
          return result;
        }
      } else if (from === "3") {
        if (areAllNumeric(a, b, c)) {
          A = parseFloat(a) / -2;
          B = parseFloat(b) / -2;
          C = parseFloat(c);
          D = parseFloat(a);
          E = parseFloat(b);
          F = parseFloat(c);
          const D2 = D / 2;
          const D2_sq = Math.pow(D2, 2);
          const E2 = E / 2;
          const E2_sq = Math.pow(E2, 2);
          const plus = D2_sq + E2_sq;
          const sq_root = plus - F;
          radius = Math.sqrt(sq_root);
          diameter = 2 * radius;
          sq_radius = Math.pow(radius, 2);
          area = sq_radius * Math.PI;
          circumference = diameter * Math.PI;
          eccentricity = 0;
          d1 = A - radius;
          d2 = A + radius;
          r1 = B - radius;
          r2 = B + radius;
        } else {
          result.error = "Please check your input.";
          return result;
        }
      } else if (from === "4") {
        if (areAllNumeric(x1, y1)) {
          const r_val = parseFloat(r);
          if (r_val > 0) {
            A = parseFloat(x1);
            B = parseFloat(y1);
            radius = r_val;
            sq_radius = Math.pow(radius, 2);
            C = parseFloat(c);
            D = A * -2;
            E = B * -2;
            const F_f1 = Math.pow(x1, 2);
            const F_f2 = Math.pow(y1, 2);
            const F_f3 = F_f1 + F_f2;
            F = F_f3 - sq_radius;
            diameter = 2 * radius;
            area = sq_radius * Math.PI;
            circumference = diameter * Math.PI;
            eccentricity = 0;
            d1 = A - radius;
            d2 = B + radius;
            r1 = A - radius;
            r2 = B + radius;
          } else {
            result.error = "Such circle (r) does not exist.";
            return result;
          }
        } else {
          result.error = "Please check your input.";
          return result;
        }
      } else if (from === "5") {
        if (areAllNumeric(x1, y1, h1, k1)) {
          A = parseFloat(x1);
          B = parseFloat(y1);
          const ans1 = A - parseFloat(h1);
          const ans1_sq = Math.pow(ans1, 2);
          const ans2 = B - parseFloat(k1);
          const ans2_sq = Math.pow(ans2, 2);
          const plus = ans1_sq + ans2_sq;
          radius = Math.sqrt(plus);
          sq_radius = Math.pow(radius, 2);
          C = parseFloat(c);
          D = A * -2;
          E = B * -2;
          const F_f1 = Math.pow(A, 2);
          const F_f2 = Math.pow(B, 2);
          const F_f3 = F_f1 + F_f2;
          F = F_f3 - sq_radius;
          diameter = 2 * radius;
          area = sq_radius * Math.PI;
          circumference = diameter * Math.PI;
          eccentricity = 0;
          d1 = A - radius;
          d2 = B + radius;
          r1 = parseFloat(h1) - radius;
          r2 = parseFloat(k1) + radius;
        } else {
          result.error = "Please check your input.";
          return result;
        }
      } else {
        result.error = "Please! Check Your Input.";
        return result;
      }

      // Format numbers to 2 decimal places
      result.tech_A = formatNumber(A);
      result.tech_B = formatNumber(B);
      result.tech_C = formatNumber(C);
      result.tech_E = formatNumber(E);
      result.tech_D = formatNumber(D);
      result.tech_F = formatNumber(F);
      result.tech_d1 = formatNumber(d1);
      result.tech_d2 = formatNumber(d2);
      result.tech_r1 = formatNumber(r1);
      result.tech_r2 = formatNumber(r2);
      result.tech_radius = formatNumber(radius);
      result.tech_area = formatNumber(area);
      result.tech_diameter = formatNumber(diameter);
      result.tech_circumference = formatNumber(circumference);
      result.tech_eccentricity = formatNumber(eccentricity);

      return result;
    } catch (error) {
      console.error("Error in equation of circle calculation:", error);
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /** getCalculationSGPAToPercentageCalculator
   * POST: /api/calculators-lol/sgpa-to-percentage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSGPAToPercentageCalculator(body) {
    let type = body.tech_type;
    let sgp = body.tech_sgp;
    let sgpa = body.tech_sgpa;
    let selection = body.tech_selection;
    let number_of_semesters = body.tech_number_of_semesters;
    let sum = body.tech_sum;

    function isNumeric(val) {
      return !isNaN(parseFloat(val)) && isFinite(val);
    }

    if (type === "first") {
      if (selection === "1") {
        if (isNumeric(sgp)) {
          let single_value = (sgp - 0.75) * 10;
          return {
            tech_final_gpa: single_value,
          };
        } else {
          return { error: "Please Check Your Input." };
        }
      } else if (selection === "2") {
        if (isNumeric(number_of_semesters) && isNumeric(sum)) {
          if (number_of_semesters > 0 && sum > 0) {
            if (number_of_semesters < 25) {
              let semester = number_of_semesters * 10;
              if (sum > semester) {
                return {
                  error: `Sgpa should be within ${semester}`,
                };
              } else {
                let final_result = sum / number_of_semesters;
                return {
                  tech_final_result: final_result,
                };
              }
            } else {
              return { error: "Enter number of semester below 25." };
            }
          } else {
            return { error: "Please! Enter Positive Number." };
          }
        } else {
          return { error: "Please Check Your Input." };
        }
      }
    } else if (type === "second") {
      if (!Array.isArray(sgpa)) {
        return { error: "Please provide SGPA as an array." };
      }

      let count = sgpa.length;
      let total = 0;

      for (let i = 0; i < count; i++) {
        if (isNumeric(sgpa[i])) {
          total += parseFloat(sgpa[i]);
        } else {
          return { error: "Please Check Your Input." };
        }
      }

      let percentage = total / count;
      let final_gpa = (percentage - 0.75) * 10;

      return {
        tech_final_gpa: final_gpa,
        tech_percentage: percentage,
        tech_sgpa: sgpa,
      };
    }

    return { error: "Invalid type." };
  }

  /**
   * getCalculationGaussianEliminationCalculator: Service Method
   * POST: /api/calculators-lol/gaussian-elimination-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationGaussianEliminationCalculator(body) {
    const { matrix2, matrix22, ...request } = body;
    const result = {};

    // Helper function for GCD calculation
    const gcd22 = (a, b, f) => {
      if (f) {
        if (b <= 1) return a;
      } else {
        if (!b) return a;
      }
      return gcd22(b, a % b, f);
    };

    // Helper function to round numbers with precision
    const toPrecision2 = (number, precision) => {
      if (number == 0) return 0;
      const exponent = Math.floor(Math.log10(Math.abs(number))) + 1;
      const significand =
        Math.round(
          (number / Math.pow(10, exponent)) * Math.pow(10, precision)
        ) / Math.pow(10, precision);
      return significand * Math.pow(10, exponent);
    };

    // Helper function to round numbers
    const roundnum2 = (x, p) => {
      const n = parseFloat(x);
      const m = toPrecision2(n, p + 1);
      const y = m.toString();
      return y;
    };

    // Helper function to round results
    const roundresult2 = (x) => {
      const y = parseFloat(x);
      return roundnum2(y, 10);
    };

    // Helper function to count digits after decimal point
    const digits_after_period2 = (x) => {
      const f = x.toString();
      const i = f.indexOf(".");
      if (i == -1) return 0;
      return f.length - i - 1;
    };

    // Helper function to convert decimal to fraction
    const convert2 = (xelem) => {
      let sign = "";
      let sign2 = "+";
      let f = false;
      const x = xelem;
      const x2 = roundresult2(x);
      const absx = Math.abs(x2);
      const y = Math.floor(absx);
      const frac = absx - y;

      if (x2 < 0) {
        sign = sign2 = "-";
      }

      const d = digits_after_period2(absx);
      const den = Math.round(Math.pow(10, d));
      const num = Math.round(frac * den);
      const a12 = num.toString();
      const len = a12.length;

      if (len > 8) f = true;

      const g = gcd22(num, den, f);
      const num2 = Math.round(num / g);
      const den2 = Math.round(den / g);

      const top_jawab = sign + (num2 + den2 * y);
      const down_jawab = den2;

      return [top_jawab, down_jawab];
    };

    // Main RREF function - FIXED ROW INDEXING
    const rref2 = (matrix) => {
      let lead = 0;
      let pz = matrix.map((row) => [...row]); // Create a deep copy
      const swap = [];
      const swap_line = [];
      const rowCount = matrix.length;

      if (rowCount === 0) return matrix;

      let columnCount = 0;
      if (matrix[0]) {
        columnCount = matrix[0].length;
      }

      let bus;
      if (rowCount > columnCount) {
        bus = rowCount - 2;
      } else if (rowCount < columnCount) {
        bus = rowCount;
      } else if (rowCount == columnCount) {
        bus = rowCount - 1;
      }

      for (let r = 0; r < bus; r++) {
        if (lead >= columnCount) break;

        // Find pivot row
        let i = r;
        while (matrix[i][lead] == 0) {
          i++;
          if (i == rowCount) {
            i = r;
            lead++;
            if (lead == columnCount) return [matrix, swap, swap_line, pz];
          }
        }

        // Swap rows if needed
        if (i != r) {
          [matrix[r], matrix[i]] = [matrix[i], matrix[r]];
          [pz[r], pz[i]] = [pz[i], pz[r]];

          // FIXED: Use 0-based indexing for row numbers
          swap_line.push(`Swap the row ${r} with row ${i}`);
          swap.push(pz.map((row) => [...row]));
        }

        // Normalize pivot row
        const lv = matrix[r][lead];
        if (lv != 0) {
          for (let j = 0; j < columnCount; j++) {
            matrix[r][j] = matrix[r][j] / lv;
            pz[r][j] = pz[r][j] / lv;
          }

          const test1 = convert2(lv);
          if (test1[1] == 1) {
            // FIXED: Use 0-based indexing for row numbers
            swap_line.push(
              `Divide row ${r} by ${lv}: R<sub>${r}</sub> = R<sub>${r}</sub>/${lv}`
            );
          } else if (test1[1] != 1) {
            const lv3 = `${test1[1]}/${test1[0]}`;
            // FIXED: Use 0-based indexing for row numbers
            swap_line.push(
              `Multiply row ${r} by ${lv3}: R<sub>${r}</sub> = ${lv3} R<sub>${r}</sub>`
            );
          }
          swap.push(pz.map((row) => [...row]));
        }

        // Eliminate other rows
        for (let i = 0; i < rowCount; i++) {
          if (i != r) {
            const lv = matrix[i][lead];
            const lv2 = pz[i][lead];

            for (let j = 0; j < columnCount; j++) {
              matrix[i][j] -= lv * matrix[r][j];
              pz[i][j] -= lv2 * pz[r][j];
            }

            swap.push(pz.map((row) => [...row]));
            const test = convert2(lv);

            let displayLv = lv;
            if (test[1] != 1) {
              displayLv = `${test[0]}/${test[1]}`;
            }

            // FIXED: Use 0-based indexing for row numbers
            if (lv < 0) {
              swap_line.push(
                `Add row ${i} multiplied by ${displayLv} from row R${r}: R<sub>${i}</sub> = R<sub>${i}</sub> + ${displayLv}R<sub>${r}</sub>`
              );
            } else if (lv >= 0) {
              swap_line.push(
                `Subtract row ${i} multiplied by ${displayLv} from row R${r}: R<sub>${i}</sub> = R<sub>${i}</sub> - ${displayLv}R<sub>${r}</sub>`
              );
            }
          }
        }
        lead++;
      }

      return [matrix, swap, swap_line, pz];
    };

    try {
      // Validate matrix dimensions
      const rows = parseInt(matrix2);
      const cols = parseInt(matrix22);

      if (isNaN(rows) || isNaN(cols) || rows <= 0 || cols <= 0) {
        result.error = "Please! Check Your Input.";
        return result;
      }

      // Extract matrix data from request
      const second_matrix = [];
      for (let i = 1; i <= rows; i++) {
        for (let j = 1; j <= cols; j++) {
          const key = `matrix3${i}_${j}`;
          const value = request[key];

          if (
            value == undefined ||
            value == null ||
            value == "" ||
            isNaN(parseFloat(value))
          ) {
            result.error = "Please! Check Your Input.";
            return result;
          }

          second_matrix.push(parseFloat(value));
        }
      }

      // Convert flat array to 2D matrix
      const zain = [];
      for (let i = 0; i < rows; i++) {
        zain.push(second_matrix.slice(i * cols, (i + 1) * cols));
      }

      // Perform Gaussian elimination
      const fahad2 = rref2(zain);

      result.tech_matrix = fahad2[0];
      result.tech_swap = fahad2[1];
      result.tech_swap_line = fahad2[2];
      result.tech_pz = fahad2[3];

      return result;
    } catch (error) {
      console.error("Error in Gaussian elimination calculation:", error);
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /** getCalculationHexCalculator
   * POST: /api/calculators-lol/hex-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationHexCalculator(body) {
    let type = body.tech_type;
    let bnr_frs = body.tech_bnr_frs;
    let bnr_sec = body.tech_bnr_sec;
    let bnr_slc = body.tech_bnr_slc;
    let options = body.tech_options;
    let nmbr = body.tech_nmbr;

    function bnrCal(fN, sN, op) {
      let rN, binary, decimal, hexa, octal, operate;

      if (op === "add") {
        rN = fN + sN;
        operate = "+";
      } else if (op === "sub") {
        rN = fN - sN;
        operate = "-";
      } else if (op === "mul") {
        rN = fN * sN;
        operate = "×";
      } else if (op === "divide") {
        rN = fN / sN;
        operate = "÷";
      } else {
        return null;
      }

      decimal = rN;
      const absVal = Math.abs(decimal);
      binary = (decimal < 0 ? "-" : "") + parseInt(absVal, 10).toString(2);
      hexa =
        (decimal < 0 ? "-" : "") +
        parseInt(absVal, 10).toString(16).toUpperCase();
      octal = (decimal < 0 ? "-" : "") + parseInt(absVal, 10).toString(8);

      return { binary, decimal, hexa, octal, operate };
    }

    if (type === "first") {
      if (!bnr_frs || !bnr_sec) {
        return { error: "Please! Check Your Input." };
      }

      let fN = parseInt(bnr_frs, 16);
      let sN = parseInt(bnr_sec, 16);
      let result = bnrCal(fN, sN, bnr_slc);

      if (!result) return { error: "Invalid operation." };

      return {
        tech_type: type,
        tech_first_ans1: bnr_frs,
        tech_second_ans1: bnr_sec,
        tech_first_ans: fN,
        tech_second_ans: sN,
        tech_bn: result.binary,
        tech_dc: result.decimal,
        tech_hx: result.hexa,
        tech_oc: result.octal,
        tech_op: result.operate,
      };
    }

    if (type === "second") {
      if (!nmbr) return { error: "Please! Check Your Input." };

      let answer, text;

      switch (options) {
        case "1":
          answer = parseInt(nmbr, 16).toString(10);
          text = "Decimal numeral";
          break;
        case "2":
          answer = parseInt(nmbr, 10).toString(16);
          text = "Hex numeral";
          break;
        case "3":
          answer = parseInt(nmbr, 16).toString(2);
          text = "Binary numeral";
          break;
        case "4":
          answer = parseInt(nmbr, 2).toString(16);
          text = "Hex numeral";
          break;
        default:
          return { error: "Invalid option." };
      }

      return {
        tech_type: type,
        tech_answer: answer,
        tech_text: text,
      };
    }

    return { error: "Please! Check Your Input." };
  }

  /**
   * getCalculationFinalGradeCalculator: Service Method
   * POST: /api/calculators-lol/final-grade-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationFinalGradeCalculator(body) {
    const selection = body.tech_selection;

    const current_grade = body.tech_current_grade;
    const final_exam_grade1 = body.tech_final_exam_grade1;
    const final_exam_grade2 = body.tech_final_exam_grade2;
    const final_exam_weight = body.tech_final_exam_weight;

    const grading_system = body.tech_grading_system;

    const current_grade3 = body.tech_current_grade3;
    const target_grade3 = body.tech_target_grade3;

    const current_grade4 = body.tech_current_grade4;
    const target_grade4 = body.tech_target_grade4;

    const current_grade5 = body.tech_current_grade5;
    const target_grade5 = body.tech_target_grade5;

    const current_grade6 = body.tech_current_grade6;
    const target_grade6 = body.tech_target_grade6;

    const current_grade7 = body.tech_current_grade7;
    const target_grade7 = body.tech_target_grade7;

    const current_grade8 = body.tech_current_grade8;
    const target_grade8 = body.tech_target_grade8;

    const current_grade9 = body.tech_current_grade9;
    const target_grade9 = body.tech_target_grade9;

    const current_grade2 = body.tech_current_grade2;
    const final_exam_weight2 = body.tech_final_exam_weight2;
    const target_grade2 = body.tech_target_grade2;
    const total_weight2 = body.tech_total_weight2;
    const final_exam_weight3 = body.tech_final_exam_weight3;

    const type = body.tech_type;
    const pollard = body.tech_pollard;

    const current_letter = body.tech_current_letter;
    const target_letter = body.tech_target_letter;

    const grade_was = body.tech_grade_was;
    const worth = body.tech_worth;
    const you_want = body.tech_you_want;
    const grading_system2 = body.tech_grading_system2;

    const grade_was2 = body.tech_grade_was2;
    const c = body.tech_c;
    const undertaker = body.tech_undertaker;

    const grade_was3 = body.tech_grade_was3;
    const c2 = body.tech_c2;
    const undertaker2 = body.tech_undertaker2;

    const grade_was4 = body.tech_grade_was4;
    const c3 = body.tech_c3;
    const undertaker3 = body.tech_undertaker3;

    const grade_was5 = body.tech_grade_was5;
    const c4 = body.tech_c4;
    const undertaker4 = body.tech_undertaker4;

    const grade_was6 = body.tech_grade_was6;
    const c5 = body.tech_c5;
    const undertaker5 = body.tech_undertaker5;

    const grade_was7 = body.grade_was7;
    const c6 = body.tech_c6;
    const undertaker6 = body.tech_undertaker6;

    const grade_was8 = body.tech_grade_was8;
    const c7 = body.tech_c7;
    const undertaker7 = body.tech_undertaker7;

    const result = {};

    // Helper functions for grade conversion
    const boom1 = (parameter) => {
      const grades = {
        "A+": 9825,
        A: 9450,
        "A-": 9100,
        "B+": 8800,
        B: 8450,
        "B-": 8100,
        "C+": 7800,
        C: 7450,
        "C-": 7100,
        "D+": 6800,
        D: 6450,
        "D-": 6100,
        F: 2975,
        "No grade (0)": 0,
      };
      return grades[parameter] || 0;
    };

    const USAstd = (grade) => {
      if (grade > 10000) {
        return "I am sorry, but with your current grades it is impossible to get the grade you want.";
      } else if (grade >= 9637) {
        return "A+";
      } else if (grade >= 9275) {
        return "A";
      } else if (grade >= 8950) {
        return "A-";
      } else if (grade >= 8625) {
        return "B+";
      } else if (grade >= 8275) {
        return "B";
      } else if (grade >= 7950) {
        return "B-";
      } else if (grade >= 7625) {
        return "C+";
      } else if (grade >= 7275) {
        return "C";
      } else if (grade >= 6950) {
        return "C-";
      } else if (grade >= 6625) {
        return "D+";
      } else if (grade >= 6275) {
        return "D";
      } else if (grade >= 4537) {
        return "D-";
      } else if (grade >= 0) {
        return "F";
      } else {
        return "CONGRATULATIONS!! No matter what you do, you will get your desired grade or higher! Just check the requirements of your particular subject";
      }
    };

    const boom2 = (parameter2) => {
      const grades = {
        A: 9500,
        B: 8450,
        C: 7450,
        D: 6450,
        "E/F": 2950,
        "No grade (0)": 0,
      };
      return grades[parameter2] || 0;
    };

    const USAnormal = (grade) => {
      if (grade > 10000) {
        return "I am sorry, but with your current grades it is impossible to get the grade you want.";
      } else if (grade >= 8975) {
        return "A";
      } else if (grade >= 7950) {
        return "B";
      } else if (grade >= 6950) {
        return "C";
      } else if (grade >= 4700) {
        return "D";
      } else if (grade >= 0) {
        return "E/F";
      } else {
        return "CONGRATULATIONS!! No matter what you do, you will get your desired grade or higher! Just check the requirements of your particular subject";
      }
    };

    const boom3 = (parameter3) => {
      const grades = {
        "A+": 9750,
        A: 9050,
        "A-": 8300,
        "B+": 7800,
        B: 7450,
        "B-": 7100,
        "C+": 6800,
        C: 6450,
        "C-": 6100,
        "D+": 5800,
        D: 5450,
        "D-": 5100,
        R: 2450,
        "No grade (0)": 0,
      };
      return grades[parameter3] || 0;
    };

    const canada = (grade) => {
      if (grade > 10000) {
        return "I am sorry, but with your current grades it is impossible to get the grade you want.";
      } else if (grade >= 9400) {
        return "A+";
      } else if (grade >= 8675) {
        return "A";
      } else if (grade >= 8050) {
        return "A-";
      } else if (grade >= 7625) {
        return "B+";
      } else if (grade >= 7275) {
        return "B";
      } else if (grade >= 6950) {
        return "B-";
      } else if (grade >= 6625) {
        return "C+";
      } else if (grade >= 6275) {
        return "C";
      } else if (grade >= 5950) {
        return "C-";
      } else if (grade >= 5625) {
        return "D+";
      } else if (grade >= 5275) {
        return "D";
      } else if (grade >= 3775) {
        return "D-";
      } else if (grade >= 0) {
        return "R";
      } else {
        return "CONGRATULATIONS!! No matter what you do, you will get your desired grade or higher! Just check the requirements of your particular subject";
      }
    };

    const boom4 = (grade) => {
      const grades = {
        "A*": 9500,
        A: 8450,
        B: 7450,
        C: 6450,
        D: 5450,
        E: 4450,
        Fail: 1950,
        "No grade (0)": 0,
      };
      return grades[grade] || 0;
    };

    const GCSE = (parameter) => {
      if (parameter > 10000) {
        return "I am sorry, but with your current grades it is impossible to get the grade you want.";
      } else if (parameter >= 8975) {
        return "A*";
      } else if (parameter >= 7950) {
        return "A";
      } else if (parameter >= 6950) {
        return "B";
      } else if (parameter >= 5950) {
        return "C";
      } else if (parameter >= 4950) {
        return "D";
      } else if (parameter >= 3200) {
        return "E";
      } else if (parameter >= 0) {
        return "Fail";
      } else {
        return "0";
      }
    };

    const boom5 = (current_grade) => {
      const grades = {
        Band6: 9500,
        Band5: 8450,
        Band4: 7450,
        Band3: 6450,
        Band2: 5450,
        Band1: 2450,
        "No grade (0)": 0,
      };
      return grades[current_grade] || 0;
    };

    const AustraliaSchool = (grade) => {
      if (grade > 10000) {
        return "I am sorry, but with your current grades it is impossible to get the grade you want.";
      } else if (grade >= 8975) {
        return "Band6";
      } else if (grade >= 7950) {
        return "Band5";
      } else if (grade >= 6950) {
        return "Band4";
      } else if (grade >= 5950) {
        return "Band3";
      } else if (grade >= 3950) {
        return "Band2";
      } else if (grade >= 0) {
        return "Band1";
      } else {
        return "CONGRATULATIONS!! No matter what you do, you will get your desired grade or higher! Just check the requirements of your particular subject";
      }
    };

    const boom6 = (grade) => {
      const grades = {
        HD: 9250,
        D: 7950,
        Cr: 6950,
        P: 5700,
        F: 2450,
        "No grade (0)": 0,
      };
      return grades[grade] || 0;
    };

    const AustraliaUni = (grade) => {
      if (grade > 10000) {
        return "I am sorry, but with your current grades it is impossible to get the grade you want.";
      } else if (grade >= 8600) {
        return "HD";
      } else if (grade >= 7450) {
        return "D";
      } else if (grade >= 6325) {
        return "Cr";
      } else if (grade >= 4075) {
        return "P";
      } else if (grade >= 0) {
        return "F";
      } else {
        return "0";
      }
    };

    const boom7 = (grade) => {
      const grades = {
        A1: 9550,
        A2: 8550,
        B1: 7550,
        B2: 6550,
        C1: 5550,
        C2: 4550,
        D: 3650,
        E1: 2650,
        E2: 1000,
        "No grade (0)": 0,
      };
      return grades[grade] || 0;
    };

    const IndiaCCE = (grade) => {
      if (grade > 10000) {
        return "I am sorry, but with your current grades it is impossible to get the grade you want.";
      } else if (grade >= 9050) {
        return "A1";
      } else if (grade >= 8050) {
        return "A2";
      } else if (grade >= 7050) {
        return "B1";
      } else if (grade >= 6050) {
        return "B2";
      } else if (grade >= 5050) {
        return "C1";
      } else if (grade >= 4100) {
        return "C2";
      } else if (grade >= 3150) {
        return "D";
      } else if (grade >= 1825) {
        return "E1";
      } else if (grade >= 0) {
        return "E2";
      } else {
        return "CONGRATULATIONS!! No matter what you do, you will get your desired grade or higher! Just check the requirements of your particular subject";
      }
    };

    // Helper function to convert letter grades to GPA
    const convert_letter = (letter) => {
      const gpaMap = {
        "A+": 4.33,
        A: 4.0,
        "A-": 3.67,
        "B+": 3.33,
        B: 3.0,
        "B-": 2.67,
        "C+": 2.33,
        C: 2.0,
        "C-": 1.67,
        "D+": 1.33,
        D: 1.0,
        "D-": 0.67,
        F: 0,
      };
      return gpaMap[letter] || 0;
    };

    try {
      if (selection == "1") {
        if (grading_system == "1" || grading_system == "2") {
          // Percentage OR Numbers
          if (
            isNumeric(current_grade) &&
            isNumeric(final_exam_grade1) &&
            isNumeric(final_exam_weight) &&
            current_grade > 0 &&
            final_exam_grade1 > 0 &&
            final_exam_weight > 0 &&
            final_exam_weight < 100
          ) {
            const final =
              (final_exam_grade1 -
                (current_grade * (100.0 - final_exam_weight)) / 100.0) /
              (final_exam_weight / 100.0);
            result.tech_final_result = final;
            return result;
          } else {
            result.error = "Please! Check Your Input";
            return result;
          }
        } else if (grading_system == "3") {
          // USA Standard
          if (
            isNumeric(final_exam_weight) &&
            final_exam_weight > 0 &&
            final_exam_weight < 100
          ) {
            const ik = boom1(current_grade3);
            const ik2 = boom1(target_grade3);
            const final2 =
              (ik2 - (ik * (100.0 - final_exam_weight)) / 100.0) /
              (final_exam_weight / 100.0);
            result.tech_nawaz = USAstd(final2);
            return result;
          } else {
            result.error = "Please! Check Your Input";
            return result;
          }
        } else if (grading_system == "4") {
          // USA (Advanced Program)
          if (
            isNumeric(final_exam_weight) &&
            final_exam_weight > 0 &&
            final_exam_weight < 100
          ) {
            const ik = boom2(current_grade4);
            const ik2 = boom2(target_grade4);
            const final2 =
              (ik2 - (ik * (100.0 - final_exam_weight)) / 100.0) /
              (final_exam_weight / 100.0);
            result.tech_nawaz = USAnormal(final2);
            return result;
          } else {
            result.error = "Please! Check Your Input";
            return result;
          }
        } else if (grading_system == "5") {
          // Canada
          if (
            isNumeric(final_exam_weight) &&
            final_exam_weight > 0 &&
            final_exam_weight < 100
          ) {
            const ik = boom3(current_grade8);
            const ik2 = boom3(target_grade8);
            const final2 =
              (ik2 - (ik * (100.0 - final_exam_weight)) / 100.0) /
              (final_exam_weight / 100.0);
            result.tech_nawaz = canada(final2);
            return result;
          } else {
            result.error = "Please! Check Your Input";
            return result;
          }
        } else if (grading_system == "6") {
          // GCSE
          if (
            isNumeric(final_exam_weight) &&
            final_exam_weight > 0 &&
            final_exam_weight < 100
          ) {
            const ik = boom4(current_grade9);
            const ik2 = boom4(target_grade9);
            const final2 =
              (ik2 - (ik * (100.0 - final_exam_weight)) / 100.0) /
              (final_exam_weight / 100.0);
            result.tech_nawaz = GCSE(final2);
            return result;
          } else {
            result.error = "Please! Checking Your Input";
            return result;
          }
        } else if (grading_system == "7") {
          // Australian Schools
          if (
            isNumeric(final_exam_weight) &&
            final_exam_weight > 0 &&
            final_exam_weight < 100
          ) {
            const ik = boom5(current_grade5);
            const ik2 = boom5(target_grade5);
            const final2 =
              (ik2 - (ik * (100.0 - final_exam_weight)) / 100.0) /
              (final_exam_weight / 100.0);
            result.tech_nawaz = AustraliaSchool(final2);
            return result;
          } else {
            result.error = "Please! Checking Your Input";
            return result;
          }
        } else if (grading_system == "8") {
          // Australian (University)
          if (
            isNumeric(final_exam_weight) &&
            final_exam_weight > 0 &&
            final_exam_weight < 100
          ) {
            const ik = boom6(current_grade6);
            const ik2 = boom6(target_grade6);
            const final2 =
              (ik2 - (ik * (100.0 - final_exam_weight)) / 100.0) /
              (final_exam_weight / 100.0);
            result.tech_nawaz = AustraliaUni(final2);
            return result;
          } else {
            result.error = "Please! Check Your Input";
            return result;
          }
        } else if (grading_system == "9") {
          // India CCE
          if (
            isNumeric(final_exam_weight) &&
            final_exam_weight > 0 &&
            final_exam_weight < 100
          ) {
            const ik = boom7(current_grade7);
            const ik2 = boom7(target_grade7);
            const final2 =
              (ik2 - (ik * (100.0 - final_exam_weight)) / 100.0) /
              (final_exam_weight / 100.0);
            result.tech_nawaz = IndiaCCE(final2);
            return result;
          } else {
            result.error = "Please! Check Your Input";
            return result;
          }
        }
      } else if (selection == "2") {
        if (
          isNumeric(current_grade) &&
          isNumeric(final_exam_grade2) &&
          isNumeric(final_exam_weight) &&
          current_grade > 0 &&
          final_exam_grade2 > 0 &&
          final_exam_weight > 0
        ) {
          const final =
            (current_grade * (100.0 - final_exam_weight) +
              final_exam_grade2 * final_exam_weight) /
            100.0;
          result.tech_final_result = final;
          return result;
        } else {
          result.error = "Please! Check Your Input";
          return result;
        }
      } else if (selection == "3") {
        if (type == "first") {
          if (
            !Array.isArray(current_grade2) ||
            !Array.isArray(final_exam_weight2)
          ) {
            result.error = "Please! Check Your Input";
            return result;
          }

          const count_current_grade = current_grade2.length;
          const count_final_exam_weight2 = final_exam_weight2.length;
          let sum = 0;
          let i = 0;
          let wsum = 0;
          let sum3 = 0;

          while (i < count_current_grade && i < count_final_exam_weight2) {
            if (
              isNumeric(final_exam_weight2[i]) &&
              isNumeric(current_grade2[i])
            ) {
              sum = sum + parseFloat(final_exam_weight2[i]);
              wsum =
                wsum +
                parseFloat(current_grade2[i]) *
                  parseFloat(final_exam_weight2[i]);
            } else {
              result.error = "Please! Check Your Input";
              return result;
            }
            i++;
          }

          const total_final = parseFloat(final_exam_weight3) + sum;
          const total_weight_val = total_weight2
            ? parseFloat(total_weight2)
            : 100;

          if (total_final == total_weight_val) {
            const cg = wsum / sum;
            const cgw = sum;
            const fgw = total_weight_val - cgw;
            const fg =
              (total_weight_val * parseFloat(target_grade2) - cgw * cg) / fgw;

            // Letter grade assignment
            let assign;
            if (fg >= 97) {
              assign = "A+";
            } else if (fg >= 93) {
              assign = "A";
            } else if (fg >= 90) {
              assign = "A-";
            } else if (fg >= 87) {
              assign = "B+";
            } else if (fg >= 83) {
              assign = "B";
            } else if (fg >= 80) {
              assign = "B-";
            } else if (fg >= 77) {
              assign = "C+";
            } else if (fg >= 73) {
              assign = "C";
            } else if (fg >= 70) {
              assign = "C-";
            } else if (fg >= 67) {
              assign = "D+";
            } else if (fg >= 63) {
              assign = "D";
            } else if (fg >= 60) {
              assign = "D-";
            } else {
              assign = "F";
            }

            result.tech_cgw = cgw;
            result.tech_cg = cg;
            result.tech_fgw = fgw;
            result.tech_fg = fg;
            result.tech_method = 3;
            result.tech_assign = assign;
            return result;
          } else {
            result.error = "Sum of weights should be equal to total weights!";
            return result;
          }
        } else if (type == "second") {
          if (!Array.isArray(pollard) || !Array.isArray(current_letter)) {
            result.error = "Please! Check Your Input";
            return result;
          }

          let sum = 0;
          let sum2 = 0;
          let counter = 0;
          const count_pollard = pollard.length;
          const count_letter = current_letter.length;

          while (counter < count_pollard && counter < count_letter) {
            const cl = convert_letter(current_letter[counter]);
            sum = sum + parseFloat(pollard[counter]) * cl;
            sum2 = sum2 + parseFloat(pollard[counter]);
            counter++;
          }

          const cg = sum / sum2;
          const cgw = sum2;
          const rg = convert_letter(target_letter);
          const total_weight_val = total_weight2
            ? parseFloat(total_weight2)
            : 100;
          const addition = cgw + parseFloat(final_exam_weight3);

          if (total_weight_val != addition) {
            result.error = "Sum of weights should be equal to total weights";
            return result;
          } else {
            let fg =
              (total_weight_val * rg - cgw * cg) /
              parseFloat(final_exam_weight3);
            if (fg < 0) {
              fg = 0;
            }

            // Letter grade assignment from GPA
            let assign_grade;
            if (fg >= 4.33) {
              assign_grade = "A+";
            } else if (fg >= 4.0) {
              assign_grade = "A";
            } else if (fg >= 3.67) {
              assign_grade = "A-";
            } else if (fg >= 3.33) {
              assign_grade = "B+";
            } else if (fg >= 3.0) {
              assign_grade = "B";
            } else if (fg >= 2.67) {
              assign_grade = "B-";
            } else if (fg >= 2.33) {
              assign_grade = "C+";
            } else if (fg >= 2.0) {
              assign_grade = "C";
            } else if (fg >= 1.67) {
              assign_grade = "C-";
            } else if (fg >= 1.33) {
              assign_grade = "D+";
            } else if (fg >= 1.0) {
              assign_grade = "D";
            } else if (fg >= 0.67) {
              assign_grade = "D-";
            } else {
              assign_grade = "F";
            }

            result.tech_assign_grade = assign_grade;
            result.tech_method4 = 4;
            result.tech_cg2 = cg;
            result.tech_cgw2 = cgw;
            result.tech_fg2 = fg;
            result.tech_difference = final_exam_weight3;
            return result;
          }
        }
      } else if (selection == "4") {
        // Note: Due to complexity, this section handles the basic case
        // The full implementation would require handling all grading_system2 cases
        if (grading_system2 == "1" || grading_system2 == "2") {
          // Numbers && Percentage
          if (!Array.isArray(grade_was) || !Array.isArray(worth)) {
            result.error = "Please! Check Input";
            return result;
          }

          const count_grade_was = grade_was.length;
          const count_you_worth = worth.length;
          let i = 0;
          let sum = 0;
          let worthing = 0;

          while (i < count_grade_was && i < count_you_worth) {
            if (
              isNumeric(grade_was[i]) &&
              isNumeric(worth[i]) &&
              grade_was[i] > 0 &&
              worth[i] > 0 &&
              grade_was[i] < 100 &&
              worth[i] < 100 &&
              isNumeric(you_want)
            ) {
              const multiplication =
                parseFloat(grade_was[i]) * parseFloat(worth[i]);
              sum = sum + multiplication;
              worthing = worthing + parseFloat(worth[i]);
              i++;
            } else {
              result.error = "Please! Check Input";
              return result;
            }
          }

          if (worthing <= 100) {
            const subtraction = 100 - worthing;
            let read = (parseFloat(you_want) * 100 - sum) / subtraction;

            if (read < 0) {
              read =
                "CONGRATULATIONS! No matter what you do, you will get your desired grade or higher! Just check the requirements of your particular subject.";
            } else if (read > 100) {
              read =
                "I'm sorry, but with your current grades it is impossible to get the grade you want.";
            }

            result.tech_final10 = subtraction;
            result.tech_final11 = read;
            return result;
          } else {
            result.error =
              "The percentage must be from 0 to 100. The sum of all the weights is larger than 100%. Please Check your given input";
            return result;
          }
        } else {
          result.error =
            "This grading system is not yet fully implemented in Node.js version";
          return result;
        }
      } else {
        result.error = "Please! Check Your Input";
        return result;
      }
    } catch (error) {
      console.error("Error in final grade calculation:", error);
      result.error = "Please! Check Your Input";
      return result;
    }

    // Helper function to check if value is numeric
    function isNumeric(value) {
      return (
        value != undefined &&
        value != null &&
        value != "" &&
        !isNaN(parseFloat(value))
      );
    }
  }

  /**
   * getCalculationSubstitutionMethodCalculator: Service Method
   * POST: /api/calculators-lol/substitution-method-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSubstitutionMethodCalculator(body) {
    const operations = body.tech_operations;

    const a1_f = body.tech_a1_f;
    const b1_f = body.tech_b1_f;
    const k1_f = body.tech_k1_f;
    const a2_f = body.tech_a2_f;
    const b2_f = body.tech_b2_f;
    const k2_f = body.tech_k2_f;

    const a1_s = body.tech_a1_s;
    const b1_s = body.tech_b1_s;
    const c1_s = body.tech_c1_s;
    const k1_s = body.tech_k1_s;

    const a2_s = body.tech_a2_s;
    const b2_s = body.tech_b2_s;
    const c2_s = body.tech_c2_s;
    const k2_s = body.tech_k2_s;

    const a3_s = body.tech_a3_s;
    const b3_s = body.tech_b3_s;
    const c3_s = body.tech_c3_s;
    const k3_s = body.tech_k3_s;

    const result = {};

    // Helper functions for equation formatting (same as before)
    const writeEq = (a, b, c) => {
      if (a == 0 && b == 0) return `0 = ${c}`;
      else if (a !== 0 && b == 0) {
        if (Math.abs(a) != 1) return `${a}x = ${c}`;
        else if (a == -1) return `-x = ${c}`;
        else return `x = ${c}`;
      } else if (a == 0 && b != 0) {
        if (Math.abs(b) !== 1) return `${b}y = ${c}`;
        else if (b === -1) return `-y = ${c}`;
        else return `y = ${c}`;
      } else {
        if (b > 0 && b != 1 && Math.abs(a) != 1) return `${a}x + ${b}y = ${c}`;
        else if (b > 0 && b == 1 && Math.abs(a) != 1) return `${a}x + y = ${c}`;
        else if (b > 0 && b != 1 && a == 1) return `x + ${b}y = ${c}`;
        else if (b > 0 && b != 1 && a == -1) return `-x + ${b}y = ${c}`;
        else if (b > 0 && b == 1 && a == 1) return `x + y = ${c}`;
        else if (b > 0 && b == 1 && a == -1) return `-x + y = ${c}`;
        else if (b < 0 && b != -1 && Math.abs(a) != 1)
          return `${a}x - ${-b}y = ${c}`;
        else if (b < 0 && b != -1 && a == 1) return `x - ${-b}y = ${c}`;
        else if (b < 0 && b != -1 && a == -1) return `-x - ${-b}y = ${c}`;
        else if (b < 0 && b == -1 && Math.abs(a) != 1)
          return `${a}x - y = ${c}`;
        else if (b < 0 && b == -1 && a == 1) return `x - y = ${c}`;
        else if (b < 0 && b == -1 && a == -1) return `-x - y = ${c}`;
      }
      return "";
    };

    const writeEqMoveB = (a, b, c) => {
      if (a == 0 && b == 0) return `0 = ${c}`;
      else if (a != 0 && b == 0) {
        if (Math.abs(a) != 1) return `${a}x = ${c}`;
        else if (a == -1) return `-x = ${c}`;
        else return `x = ${c}`;
      } else if (a == 0 && b != 0) {
        if (Math.abs(b) != 1) return `${b}y = ${c}`;
        else if (b == -1) return `-y = ${c}`;
        else return `y = ${c}`;
      } else {
        if (b > 0 && b != 1 && Math.abs(a) != 1) return `${a}x = ${c} - ${b}y`;
        else if (b > 0 && b == 1 && Math.abs(a) != 1) return `${a}x = ${c} - y`;
        else if (b > 0 && b != 1 && a == 1) return `x = ${c} - ${b}y`;
        else if (b > 0 && b != 1 && a == -1) return `-x = ${c} - ${b}y`;
        else if (b > 0 && b == 1 && a == 1) return `x = ${c} - y`;
        else if (b > 0 && b == 1 && a == -1) return `-x = ${c} - y`;
        else if (b < 0 && b != -1 && Math.abs(a) != 1)
          return `${a}x = ${c} + ${-b}y`;
        else if (b < 0 && b != -1 && a == 1) return `x = ${c} + ${-b}y`;
        else if (b < 0 && b != -1 && a == -1) return `-x = ${c} + ${-b}y`;
        else if (b < 0 && b == -1 && Math.abs(a) != 1)
          return `${a}x = ${c} + y`;
        else if (b < 0 && b == -1 && a == 1) return `x = ${c} + y`;
        else if (b < 0 && b == -1 && a == -1) return `-x = ${c} + y`;
      }
      return "";
    };

    const writeEqSubX = (a, b, c, d, e) => {
      let x;
      if (e != 0) {
        if (Math.abs(d) != 1) {
          if (d > 0) x = `${e} + ${d}y`;
          if (d < 0) x = `${e} - ${-d}y`;
          if (d == 0) x = `${e}`;
        } else if (d == -1) {
          x = `${e} - y`;
        } else {
          x = `${e} + ${d}y`;
        }
      } else {
        if (d == 1) x = "y";
        else if (d == -1) x = "-y";
        else x = `${d}y`;
      }
      x = `(${x})`;

      if (a == 0 && b == 0) return `0 = ${c}`;
      else if (a != 0 && b == 0) {
        if (Math.abs(a) != 1) return `${a} ⋅ ${x} = ${c}`;
        else if (a == -1) return `-${x} = ${c}`;
        else return `${x} = ${c}`;
      } else if (a == 0 && b != 0) {
        if (Math.abs(b) != 1) return `${b}y = ${c}`;
        else if (b == -1) return `-y = ${c}`;
        else return `y = ${c}`;
      } else {
        if (b > 0 && b != 1 && Math.abs(a) != 1)
          return `${a} ⋅ ${x} + ${b}y = ${c}`;
        else if (b > 0 && b == 1 && Math.abs(a) != 1)
          return `${a} ⋅ ${x} + y = ${c}`;
        else if (b > 0 && b != 1 && a == 1) return `${x} + ${b}y = ${c}`;
        else if (b > 0 && b != 1 && a == -1) return `-${x} + ${b}y = ${c}`;
        else if (b > 0 && b == 1 && a == 1) return `${x} + y = ${c}`;
        else if (b > 0 && b == 1 && a == -1) return `-${x} + y = ${c}`;
        else if (b < 0 && b != -1 && Math.abs(a) != 1)
          return `${a} ⋅ ${x} - ${-b}y = ${c}`;
        else if (b < 0 && b != -1 && a == 1) return `${x} - ${-b}y = ${c}`;
        else if (b < 0 && b != -1 && a == -1) return `-${x} - ${-b}y = ${c}`;
        else if (b < 0 && b == -1 && Math.abs(a) != 1)
          return `${a} ⋅ ${x} - y = ${c}`;
        else if (b < 0 && b == -1 && a == 1) return `${x} - y = ${c}`;
        else if (b < 0 && b == -1 && a == -1) return `-${x} - y = ${c}`;
      }
      return "";
    };

    const writeEqX = (a, b, y, c) => {
      if (Math.abs(b) != 1) {
        if (Math.abs(a) != 1) {
          if (b > 0 && y >= 0) return `${a}x + ${b} ⋅ ${y} = ${c}`;
          else if (b < 0 && y >= 0) return `${a}x - ${-b} ⋅ ${y} = ${c}`;
          else if (b > 0 && y < 0) return `${a}x + ${b} ⋅ (${y}) = ${c}`;
          else if (b < 0 && y < 0) return `${a}x - ${-b} ⋅ (${y}) = ${c}`;
        } else if (a == 1) {
          if (b > 0 && y >= 0) return `x + ${b} ⋅ ${y} = ${c}`;
          else if (b < 0 && y >= 0) return `x - ${-b} ⋅ ${y} = ${c}`;
          else if (b > 0 && y < 0) return `x + ${b} ⋅ (${y}) = ${c}`;
          else if (b < 0 && y < 0) return `x - ${-b} ⋅ (${y}) = ${c}`;
        } else if (a == -1) {
          if (b > 0 && y >= 0) return `-x + ${b} ⋅ ${y} = ${c}`;
          else if (b < 0 && y >= 0) return `-x - ${-b} ⋅ ${y} = ${c}`;
          else if (b > 0 && y < 0) return `-x + ${b} ⋅ (${y}) = ${c}`;
          else if (b < 0 && y < 0) return `-x - ${-b} ⋅ (${y}) = ${c}`;
        }
      } else if (b == 1) {
        if (Math.abs(a) != 1) {
          if (y >= 0) return `${a}x + ${y} = ${c}`;
          else if (y < 0) return `${a}x - ${-y} = ${c}`;
        } else if (a == 1) {
          if (y >= 0) return `x + ${y} = ${c}`;
          else if (y < 0) return `x - ${-y} = ${c}`;
        } else if (a == -1) {
          if (y >= 0) return `-x + ${y} = ${c}`;
          else if (y < 0) return `-x - ${-y} = ${c}`;
        }
      } else if (b == -1) {
        if (Math.abs(a) != 1) {
          if (y >= 0) return `${a}x - ${y} = ${c}`;
          else if (y < 0) return `${a}x + ${-y} = ${c}`;
        } else if (a == 1) {
          if (y >= 0) return `x - ${y} = ${c}`;
          else if (y < 0) return `x + ${-y} = ${c}`;
        } else if (a == -1) {
          if (y >= 0) return `-x - ${y} = ${c}`;
          else if (y < 0) return `-x + ${-y} = ${c}`;
        }
      }
      return "";
    };

    const writeEqY = (a, x, b, c) => {
      if (Math.abs(b) != 1) {
        if (Math.abs(a) != 1) {
          if (b > 0 && x >= 0) return `${a} ⋅ ${x} + ${b}y = ${c}`;
          else if (b < 0 && x >= 0) return `${a} ⋅ ${x} - ${-b}y = ${c}`;
          else if (b > 0 && x < 0) return `${a} ⋅ (${x}) + ${b}y = ${c}`;
          else if (b < 0 && x < 0) return `${a} ⋅ (${x}) - ${-b}y = ${c}`;
        } else if (a == 1) {
          if (b > 0) return `${x} + ${b}y = ${c}`;
          else if (b < 0) return `${x} - ${-b}y = ${c}`;
        } else if (a == -1) {
          if (b > 0) return `${-x} + ${b}y = ${c}`;
          else if (b < 0) return `${-x} - ${-b}y = ${c}`;
        }
      } else if (b == 1) {
        if (Math.abs(a) != 1) {
          if (x >= 0) return `${a} ⋅ ${x} + y = ${c}`;
          else if (x < 0) return `${a} ⋅ (${x}) + y = ${c}`;
        } else if (a == 1) {
          return `${x} + y = ${c}`;
        } else if (a == -1) {
          return `${-x} + y = ${c}`;
        }
      } else if (b == -1) {
        if (Math.abs(a) != 1) {
          if (x >= 0) return `${a} ⋅ ${x} - y = ${c}`;
          else if (x < 0) return `${a} ⋅ (${x}) - y = ${c}`;
        } else if (a == 1) {
          return `${x} - y = ${c}`;
        } else if (a == -1) {
          return `${-x} - y = ${c}`;
        }
      }
      return "";
    };

    // Helper functions for number operations
    const are3NumbersZero = (a, b, c) => a * a + b * b + c * c === 0;
    const are2NumbersZero = (a, b) => a * a + b * b === 0;
    const roundNumb = (a) => Math.round(a * 100000) / 100000;
    const lastRound = (a) => Math.round(a * 1000) / 1000;

    // Helper function to check if value is numeric
    const isNumeric = (value) => {
      return (
        value !== undefined &&
        value !== null &&
        value !== "" &&
        !isNaN(parseFloat(value))
      );
    };

    // Gaussian elimination for 3x3 system (Laravel style)
    const gauss3Equations = (
      s1,
      t1,
      u1,
      v1,
      s2,
      t2,
      u2,
      v2,
      s3,
      t3,
      u3,
      v3
    ) => {
      let matrix = [
        [s1, t1, u1, v1],
        [s2, t2, u2, v2],
        [s3, t3, u3, v3],
      ];

      if (!are3NumbersZero(matrix[0][0], matrix[1][0], matrix[2][0])) {
        if (matrix[0][0] === 0 && matrix[1][0] !== 0) {
          [matrix[0], matrix[1]] = [matrix[1], matrix[0]];
        }
        if (matrix[0][0] === 0 && matrix[2][0] !== 0) {
          [matrix[0], matrix[2]] = [matrix[2], matrix[0]];
        }
        if (matrix[1][0] === 0 && matrix[2][0] !== 0) {
          [matrix[1], matrix[2]] = [matrix[2], matrix[1]];
        }
      }

      // Forward elimination
      if (matrix[1][0] !== 0) {
        const factor = matrix[1][0] / matrix[0][0];
        for (let j = 0; j < 4; j++) {
          matrix[1][j] = roundNumb(matrix[1][j] - factor * matrix[0][j]);
        }
      }
      if (matrix[2][0] !== 0) {
        const factor = matrix[2][0] / matrix[0][0];
        for (let j = 0; j < 4; j++) {
          matrix[2][j] = roundNumb(matrix[2][j] - factor * matrix[0][j]);
        }
      }

      // Second row elimination
      if (matrix[2][1] !== 0 && matrix[1][1] !== 0) {
        const factor = matrix[2][1] / matrix[1][1];
        for (let j = 1; j < 4; j++) {
          matrix[2][j] = roundNumb(matrix[2][j] - factor * matrix[1][j]);
        }
      }

      return matrix;
    };

    const solveFor3 = (s1, t1, u1, v1, s2, t2, u2, v2, s3, t3, u3, v3) => {
      const matrix = gauss3Equations(
        s1,
        t1,
        u1,
        v1,
        s2,
        t2,
        u2,
        v2,
        s3,
        t3,
        u3,
        v3
      );

      // Check for no solution
      if (
        are3NumbersZero(matrix[2][0], matrix[2][1], matrix[2][2]) &&
        matrix[2][3] !== 0
      ) {
        return 0; // No solution
      }

      // Check for infinite solutions
      if (
        are3NumbersZero(matrix[2][0], matrix[2][1], matrix[2][2]) &&
        matrix[2][3] === 0
      ) {
        if (
          are3NumbersZero(matrix[1][0], matrix[1][1], matrix[1][2]) &&
          matrix[1][3] !== 0
        ) {
          return 0; // No solution
        }
        if (
          are3NumbersZero(matrix[1][0], matrix[1][1], matrix[1][2]) &&
          matrix[1][3] === 0
        ) {
          if (
            are3NumbersZero(matrix[0][0], matrix[0][1], matrix[0][2]) &&
            matrix[0][3] !== 0
          ) {
            return 0; // No solution
          }
          if (
            are3NumbersZero(matrix[0][0], matrix[0][1], matrix[0][2]) &&
            matrix[0][3] === 0
          ) {
            return 1; // Infinite solutions
          }
        }
      }

      // Back substitution for unique solution
      const z = roundNumb(matrix[2][3] / matrix[2][2]);
      const y = roundNumb((matrix[1][3] - matrix[1][2] * z) / matrix[1][1]);
      const x = roundNumb(
        (matrix[0][3] - matrix[0][2] * z - matrix[0][1] * y) / matrix[0][0]
      );

      return [
        [0, 0, lastRound(x)],
        [0, 0, lastRound(y)],
        [0, 0, lastRound(z)],
      ];
    };

    try {
      if (operations == "1") {
        // Two equations system
        if (
          isNumeric(a1_f) &&
          isNumeric(b1_f) &&
          isNumeric(k1_f) &&
          isNumeric(a2_f) &&
          isNumeric(b2_f) &&
          isNumeric(k2_f)
        ) {
          const a1 = parseFloat(a1_f);
          const b1 = parseFloat(b1_f);
          const k1 = parseFloat(k1_f);
          const a2 = parseFloat(a2_f);
          const b2 = parseFloat(b2_f);
          const k2 = parseFloat(k2_f);

          if (a1 != 0 || b1 != 0) {
            if (a2 != 0 || b2 != 0) {
              const f1_equation = writeEq(a1, b1, k1);
              const f2_equation = writeEq(a2, b2, k2);

              result.tech_f1_equation = f1_equation;
              result.tech_f2_equation = f2_equation;

              // Check for special cases with zero coefficients
              if (a1 * b1 * a2 * b2 === 0) {
                let x, y;
                if (a1 === 0 && a2 !== 0 && b1 !== 0 && b2 !== 0) {
                  y = k1 / b1;
                  x = (k2 - b2 * y) / a2;
                  result.tech_first = "‣ From the first equation:";
                  result.tech_second = `y = ${y}`;
                  result.tech_third = `‣ Substitute y = ${y} into the second equation:`;
                  result.tech_four = writeEqX(a2, b2, y, k2);
                  result.tech_five = `x = ${x}`;
                  result.tech_six = "‣ Solution:";
                  result.tech_seven = `x = ${lastRound(x)}, y = ${lastRound(
                    y
                  )}`;
                  result.tech_main_ans = result.tech_seven;
                  result.tech_x = lastRound(x);
                  result.tech_y = lastRound(y);
                } else if (a2 === 0 && a1 !== 0 && b2 !== 0 && b1 !== 0) {
                  y = k2 / b2;
                  x = (k1 - b1 * y) / a1;
                  result.tech_first = "‣ From the second equation:";
                  result.tech_second = `y = ${y}`;
                  result.tech_third = `‣ Substitute y = ${y} into the first equation:`;
                  result.tech_four = writeEqX(a1, b1, y, k1);
                  result.tech_five = `x = ${x}`;
                  result.tech_six = "‣ Solution:";
                  result.tech_seven = `x = ${lastRound(x)}, y = ${lastRound(
                    y
                  )}`;
                  result.tech_main_ans = result.tech_seven;
                  result.tech_x = lastRound(x);
                  result.tech_y = lastRound(y);
                } else if (b1 === 0 && b2 !== 0 && a1 !== 0 && a2 !== 0) {
                  x = k1 / a1;
                  y = (k2 - a2 * x) / b2;
                  result.tech_first = "‣ From the first equation:";
                  result.tech_second = `x = ${x}`;
                  result.tech_third = `‣ Substitute x = ${x} into the second equation:`;
                  result.tech_four = writeEqY(a2, x, b2, k2);
                  result.tech_five = `y = ${y}`;
                  result.tech_six = "‣ Solution:";
                  result.tech_seven = `x = ${lastRound(x)}, y = ${lastRound(
                    y
                  )}`;
                  result.tech_main_ans = result.tech_seven;
                  result.tech_x = lastRound(x);
                  result.tech_y = lastRound(y);
                } else if (b2 === 0 && b1 !== 0 && a2 !== 0 && a1 !== 0) {
                  x = k2 / a2;
                  y = (k1 - a1 * x) / b1;
                  result.tech_first = "‣ From the second equation:";
                  result.tech_second = `x = ${x}`;
                  result.tech_third = `‣ Substitute x = ${x} into the first equation:`;
                  result.tech_four = writeEqY(a1, x, b1, k1);
                  result.tech_five = `y = ${y}`;
                  result.tech_six = "‣ Solution:";
                  result.tech_seven = `x = ${lastRound(x)}, y = ${lastRound(
                    y
                  )}`;
                  result.tech_main_ans = result.tech_seven;
                  result.tech_x = lastRound(x);
                  result.tech_y = lastRound(y);
                }
              } else {
                // General case - use substitution method
                if (
                  Math.abs(a1) == 1 ||
                  Math.abs(a2) == 1 ||
                  Math.abs(b1) == 1 ||
                  Math.abs(b2) == 1
                ) {
                  // Handle cases with coefficients of 1 or -1
                  let a = 0,
                    b = 0,
                    c = 0;
                  if (Math.abs(a1) == 1) {
                    result.tech_first =
                      "‣ Calculate x from the first equation:";
                    result.tech_second = writeEqMoveB(a1, b1, k1);
                    result.tech_third =
                      "‣ Substitute x into the second equation:";
                    result.tech_four = writeEqSubX(a2, b2, k2, -b1, k1);
                    result.tech_five = "‣ Simplify:";
                    a = 0;
                    b = -a2 * b1 + b2;
                    c = k2 - a2 * k1;
                    result.tech_six = writeEq(a, b, c);
                  } else if (Math.abs(a2) == 1) {
                    result.tech_first =
                      "‣ Calculate x from the second equation:";
                    result.tech_second = writeEqMoveB(a2, b2, k2);
                    result.tech_third =
                      "‣ Substitute x into the first equation:";
                    result.tech_four = writeEqSubX(a1, b1, k1, -b2, k2);
                    result.tech_five = "‣ Simplify:";
                    a = 0;
                    b = -a1 * b2 + b1;
                    c = k1 - a1 * k2;
                    result.tech_six = writeEq(a, b, c);
                  } else if (Math.abs(b2) == 1) {
                    result.tech_first =
                      "‣ Calculate y from the second equation:";
                    result.tech_second = writeEqMoveB(a2, b2, k2);
                    result.tech_third =
                      "‣ Substitute y into the first equation:";
                    result.tech_four = writeEqSubX(a1, b1, k1, -a2, k2);
                    result.tech_five = "‣ Simplify:";
                    a = 0;
                    b = a1 - a2 * b1;
                    c = k1 - b1 * k2;
                    result.tech_six = writeEq(a, b, c);
                  } else if (Math.abs(b1) == 1) {
                    result.tech_first =
                      "‣ Calculate y from the first equation:";
                    result.tech_second = writeEqMoveB(a1, b1, k1);
                    result.tech_third =
                      "‣ Substitute y into the second equation:";
                    result.tech_four = writeEqSubX(a2, b2, k2, -a1, k1);
                    result.tech_five = "‣ Simplify:";
                    a = 0;
                    b = a2 - a1 * b2;
                    c = k2 - b2 * k1;
                    result.tech_six = writeEq(a, b, c);
                  }

                  // Solve the simplified equation
                  if (b == 0 && c != 0) {
                    result.tech_main_ans =
                      "<b>Contradiction! There is no solution.</b>";
                  } else if (b == 0 && c == 0) {
                    result.tech_main_ans =
                      "<b>There are infinitely many solutions.</b>";
                  } else {
                    const y_val = c / b;
                    const x_val = (k1 - b1 * y_val) / a1;

                    result.tech_answer1 = "‣ Solve for y:";
                    result.tech_answer2 = `<b>y = ${y_val}</b>`;
                    result.tech_answer3 = `‣ Substituting y = ${y_val} into the first equation, we get:`;
                    result.tech_answer4 = writeEqX(a1, b1, y_val, k1);
                    result.tech_answer5 = "‣ Solve for x:";
                    result.tech_answer6 = `<b>x = ${x_val}</b>`;
                    result.tech_answer7 = "‣ Solution:";
                    result.tech_answer8 = `x = ${lastRound(
                      x_val
                    )}, y = ${lastRound(y_val)}`;
                    result.tech_main_ans = result.tech_answer8;
                    result.tech_x = lastRound(x_val);
                    result.tech_y = lastRound(y_val);
                  }
                } else {
                  // General substitution method
                  result.tech_first = `‣ Calculate x from the first equation. First, add ${-b1}y to both sides of the equation:`;
                  result.tech_second = writeEqMoveB(a1, b1, k1);
                  result.tech_third = `Next, divide both sides by ${a1}:`;
                  result.tech_four = writeEqMoveB(1, b1 / a1, k1 / a1);
                  result.tech_five = "‣ Substitute x into the second equation:";
                  result.tech_six = writeEqSubX(
                    a2,
                    b2,
                    k2,
                    -(b1 / a1),
                    k1 / a1
                  );
                  result.tech_seven = "‣ Simplify:";
                  const b_val = (-a2 * b1) / a1 + b2;
                  const c_val = k2 - (a2 * k1) / a1;
                  result.tech_eight = writeEq(0, b_val, c_val);

                  // Solve for y and x
                  if (b_val === 0 && c_val !== 0) {
                    result.main_ans =
                      "<b>Contradiction! There is no solution.</b>";
                  } else if (b_val === 0 && c_val === 0) {
                    result.main_ans =
                      "<b>There are infinitely many solutions.</b>";
                  } else {
                    const y_val = c_val / b_val;
                    const x_val = (k1 - b1 * y_val) / a1;

                    result.tech_answer1 = "‣ Solve for y:";
                    result.tech_answer2 = `<b>y = ${y_val}</b>`;
                    result.tech_answer3 = `‣ Substituting y = ${y_val} into the first equation, we get:`;
                    result.tech_answer4 = writeEqX(a1, b1, y_val, k1);
                    result.tech_answer5 = "‣ Solve for x:";
                    result.tech_answer6 = `<b>x = ${x_val}</b>`;
                    result.tech_answer7 = "‣ Solution:";
                    result.tech_answer8 = `x = ${lastRound(
                      x_val
                    )}, y = ${lastRound(y_val)}`;
                    result.tech_main_ans = result.tech_answer8;
                    result.tech_x = lastRound(x_val);
                    result.tech_y = lastRound(y_val);
                  }
                }
              }
            } else {
              result.error = "a2 and b2 cannot both be zeros!";
              return result;
            }
          } else {
            result.error = "a1 and b1 cannot both be zeros!";
            return result;
          }
        } else {
          result.error = "Please! Check Your Input.";
          return result;
        }
      } else if (operations == "2") {
        // Three equations system
        if (
          isNumeric(a1_s) &&
          isNumeric(b1_s) &&
          isNumeric(c1_s) &&
          isNumeric(k1_s) &&
          isNumeric(a2_s) &&
          isNumeric(b2_s) &&
          isNumeric(c2_s) &&
          isNumeric(k2_s) &&
          isNumeric(a3_s) &&
          isNumeric(b3_s) &&
          isNumeric(c3_s) &&
          isNumeric(k3_s)
        ) {
          const a1 = parseFloat(a1_s);
          const b1 = parseFloat(b1_s);
          const c1 = parseFloat(c1_s);
          const k1 = parseFloat(k1_s);
          const a2 = parseFloat(a2_s);
          const b2 = parseFloat(b2_s);
          const c2 = parseFloat(c2_s);
          const k2 = parseFloat(k2_s);
          const a3 = parseFloat(a3_s);
          const b3 = parseFloat(b3_s);
          const c3 = parseFloat(c3_s);
          const k3 = parseFloat(k3_s);

          const solution = solveFor3(
            a1,
            b1,
            c1,
            k1,
            a2,
            b2,
            c2,
            k2,
            a3,
            b3,
            c3,
            k3
          );

          if (solution === 0) {
            result.tech_s_fans = "Your system of equations has no solutions.";
          } else if (solution === 1) {
            result.tech_s_fans =
              "Your system of equations has an infinite number of solutions. It is satisfied by any three real numbers.";
          } else {
            const x = solution[0];
            const y = solution[1];
            const z = solution[2];

            result.tech_s_fans = `The unique solution to your system is x = ${x[2]}, y = ${y[2]}, z = ${z[2]}.`;
            result.tech_x = x;
            result.tech_y = y;
          }
        } else {
          result.error = "Please! Check Your Input for three equation system.";
          return result;
        }
      } else {
        result.error = "Invalid operation selected";
        return result;
      }

      result.tech_operations = operations;
      return result;
    } catch (error) {
      console.error("Error in substitution method calculation:", error);
      result.error = "Please! Check Your Input.";
      return result;
    }
  }

  /**
   * SystemOfEquationsCalculator: Service Method
   * POST: /api/calculators-lol/system-of-equations-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async SystemOfEquationsCalculator(body) {
    let operations = body.tech_operations;
    let method = body.tech_method;

    let a1_f = body.tech_a1_f;
    let b1_f = body.tech_b1_f;
    let k1_f = body.tech_k1_f;

    let a2_f = body.tech_a2_f;
    let b2_f = body.tech_b2_f;
    let k2_f = body.tech_k2_f;

    let a1_s = body.tech_a1_s;
    let b1_s = body.tech_b1_s;
    let c1_s = body.tech_c1_s;
    let k1_s = body.tech_k1_s;

    let a2_s = body.tech_a2_s;
    let b2_s = body.tech_b2_s;
    let c2_s = body.tech_c2_s;
    let k2_s = body.tech_k2_s;

    let a3_s = body.tech_a3_s;
    let b3_s = body.tech_b3_s;
    let c3_s = body.tech_c3_s;
    let k3_s = body.tech_k3_s;

    // Helper functions
    function invert(A, debug = false) {
      const n = A.length;

      // Get and append identity matrix
      const I = identity_matrix(n);
      for (let i = 0; i < n; ++i) {
        A[i] = A[i].concat(I[i]);
      }

      if (debug) {
        console.log("\nStarting matrix: ");
        print_matrix(A);
      }

      // Forward run
      for (let j = 0; j < n - 1; ++j) {
        for (let i = j + 1; i < n; ++i) {
          if (A[i][j] != 0) {
            const scalar = A[j][j] / A[i][j];
            for (let jj = j; jj < n * 2; ++jj) {
              A[i][jj] *= scalar;
              A[i][jj] -= A[j][jj];
            }
          }
        }
        if (debug) {
          console.log(`\nForward iteration ${j}: `);
          print_matrix(A);
        }
      }

      // Reverse run
      for (let j = n - 1; j > 0; --j) {
        for (let i = j - 1; i >= 0; --i) {
          if (A[i][j] != 0) {
            const scalar = A[j][j] / A[i][j];
            for (let jj = i; jj < n * 2; ++jj) {
              A[i][jj] *= scalar;
              A[i][jj] -= A[j][jj];
            }
          }
        }
        if (debug) {
          console.log(`\nReverse iteration ${j}: `);
          print_matrix(A);
        }
      }

      // Make all diagonal elements 1
      for (let j = 0; j < n; ++j) {
        if (A[j][j] !== 1) {
          const scalar = 1 / A[j][j];
          for (let jj = j; jj < n * 2; ++jj) {
            A[j][jj] *= scalar;
          }
        }
        if (debug) {
          console.log(`\n1-out iteration ${j}: `);
          print_matrix(A);
        }
      }

      // Extract the inverse matrix
      const Inv = [];
      for (let i = 0; i < n; ++i) {
        Inv[i] = A[i].slice(n);
      }

      return Inv;
    }

    function print_matrix(A, decimals = 6) {
      A.forEach((row) => {
        let rowStr = "\n\t[";
        row.forEach((i) => {
          rowStr += `\t${round(i, decimals).toFixed(decimals)}`;
        });
        rowStr += "\t]";
        console.log(rowStr);
      });
    }

    function round(num, decimals) {
      return Math.round(num * Math.pow(10, decimals)) / Math.pow(10, decimals);
    }

    function identity_matrix(n) {
      const I = [];
      for (let i = 0; i < n; ++i) {
        I[i] = [];
        for (let j = 0; j < n; ++j) {
          I[i][j] = i == j ? 1 : 0;
        }
      }
      return I;
    }

    function multiply(mat1, mat2) {
      const res = [];
      const N = mat1.length;

      for (let i = 0; i < N; i++) {
        res[i] = [];
        for (let j = 0; j < mat2[0].length; j++) {
          res[i][j] = 0;
          for (let k = 0; k < N; k++) {
            res[i][j] += mat1[i][k] * mat2[k][j];
          }
        }
      }
      return res;
    }

    function rref2(matrix) {
      let lead = 0;
      const rowCount = matrix.length;
      if (rowCount == 0) return matrix;

      const columnCount = matrix[0] ? matrix[0].length : 0;

      for (let r = 0; r < rowCount; r++) {
        if (lead >= columnCount) break;

        let i = r;
        while (matrix[i][lead] == 0) {
          i++;
          if (i == rowCount) {
            i = r;
            lead++;
            if (lead == columnCount) return matrix;
          }
        }

        // Swap rows
        [matrix[r], matrix[i]] = [matrix[i], matrix[r]];

        // Normalize the pivot row
        const lv = matrix[r][lead];
        for (let j = 0; j < columnCount; j++) {
          matrix[r][j] = matrix[r][j] / lv;
        }

        // Eliminate other rows
        for (let i = 0; i < rowCount; i++) {
          if (i != r) {
            const lv = matrix[i][lead];
            for (let j = 0; j < columnCount; j++) {
              matrix[i][j] -= lv * matrix[r][j];
            }
          }
        }
        lead++;
      }
      return matrix;
    }

    function deter(arr) {
      const determinant =
        arr[0][0] * (arr[1][1] * arr[2][2] - arr[1][2] * arr[2][1]) -
        arr[0][1] * (arr[1][0] * arr[2][2] - arr[1][2] * arr[2][0]) +
        arr[0][2] * (arr[1][0] * arr[2][1] - arr[1][1] * arr[2][0]);
      return determinant;
    }

    // Main logic
    const result = {};

    if (operations == 1) {
      if (isNumeric(k1_f) && isNumeric(k2_f)) {
        if (!a1_f && a1_f != 0 && !a2_f && a2_f != 0) {
          result.error = "Please! Check Your Input.";
          return result;
        }
        if (!b1_f && b1_f != 0 && !b2_f && b2_f != 0) {
          result.error = "Please! Check Your Input.";
          return result;
        }

        if (method == 1) {
          let n1, n2, n3, multiBy;

          if (a1_f == 1) {
            multiBy = a2_f;
            n1 = a2_f - a1_f * a2_f;
            n2 = b2_f - b1_f * a2_f;
            n3 = k2_f - k1_f * a2_f;
          } else if (a1_f > 1) {
            multiBy = `\\dfrac{${a2_f}}{${a1_f}}`;
            n1 = a2_f - a1_f * (a2_f / a1_f);
            n2 = b2_f - b1_f * (a2_f / a1_f);
            n3 = k2_f - k1_f * (a2_f / a1_f);
          } else if (a1_f == 0) {
            multiBy = "swap";
            n1 = a1_f;
            n2 = b1_f;
            n3 = k1_f;
            // Note: In original PHP, variables were reassigned but this doesn't affect the result object
          } else if (a1_f == -1) {
            multiBy = a2_f;
            n1 = a2_f + a1_f * a2_f;
            n2 = b2_f + b1_f * a2_f;
            n3 = k2_f + k1_f * a2_f;
          } else if (a1_f < -1) {
            multiBy = `\\dfrac{${a2_f}}{${a1_f}}`;
            n1 = a2_f + a1_f * (a2_f / Math.abs(a1_f));
            n2 = b2_f + b1_f * (a2_f / Math.abs(a1_f));
            n3 = k2_f + k1_f * (a2_f / Math.abs(a1_f));
          }

          const y = n3 / n2;
          const x = (k1_f - b1_f * y) / a1_f;

          result.tech_x = x;
          result.tech_y = y;
          result.tech_n1 = n1;
          result.tech_n2 = n2;
          result.tech_n3 = n3;
          result.tech_a1_f = a1_f;
          result.tech_b1_f = b1_f;
          result.tech_k1_f = k1_f;
          return result;
        } else if (method == 2) {
          const invers = [
            [a1_f, b1_f],
            [a2_f, b2_f],
          ];
          const inv = invert(invers);
          const side = [[k1_f], [k2_f]];
          const multi = multiply(inv, side);

          result.tech_x = multi[0][0];
          result.tech_y = multi[1][0];
          result.tech_inv = inv;
          result.tech_multi = multi;
          return result;
        } else if (method == 3) {
          const det1 = a1_f * b2_f - a2_f * b1_f;
          const det2 = k1_f * b2_f - k2_f * b1_f;
          const det3 = a1_f * k2_f - a2_f * k1_f;
          const x = det2 / det1;
          const y = det3 / det1;

          result.tech_x = x;
          result.tech_y = y;
          result.tech_det1 = det1;
          result.tech_det2 = det2;
          result.tech_det3 = det3;
          return result;
        }
      } else {
        result.error = "Please! Check Your Input.";
        return result;
      }
    } else if (operations == 2) {
      if (method == 1) {
        const A = [
          [a1_s, b1_s, c1_s, k1_s],
          [a2_s, b2_s, c2_s, k2_s],
          [a3_s, b3_s, c3_s, k3_s],
        ];
        const rref = rref2(A);
        const x = rref[0][3];
        const y = rref[1][3];
        const z = rref[2][3];

        result.tech_rref = rref;
        result.tech_x = x;
        result.tech_y = y;
        result.tech_z = z;
        return result;
      } else if (method == 2) {
        const A = [
          [a1_s, b1_s, c1_s],
          [a2_s, b2_s, c2_s],
          [a3_s, b3_s, c3_s],
        ];
        const inv = invert(A);
        const side = [[k1_s], [k2_s], [k3_s]];
        const multi = multiply(inv, side);

        result.tech_x = multi[0][0];
        result.tech_y = multi[1][0];
        result.tech_z = multi[2][0];
        result.tech_inv = inv;
        result.tech_multi = multi;
        return result;
      } else if (method == 3) {
        const A = [
          [a1_s, b1_s, c1_s],
          [a2_s, b2_s, c2_s],
          [a3_s, b3_s, c3_s],
        ];
        const B = [
          [k1_s, b1_s, c1_s],
          [k2_s, b2_s, c2_s],
          [k3_s, b3_s, c3_s],
        ];
        const C = [
          [a1_s, k1_s, c1_s],
          [a2_s, k2_s, c2_s],
          [a3_s, k3_s, c3_s],
        ];
        const D = [
          [a1_s, b1_s, k1_s],
          [a2_s, b2_s, k2_s],
          [a3_s, b3_s, k3_s],
        ];
        const det1 = deter(A);
        const det2 = deter(B);
        const det3 = deter(C);
        const det4 = deter(D);

        const x = det2 / det1;
        const y = det3 / det1;
        const z = det4 / det1;

        result.tech_x = isNaN(x) ? "NaN" : x;
        result.tech_y = isNaN(y) ? "NaN" : y;
        result.tech_z = isNaN(z) ? "NaN" : z;

        result.tech_det1 = isNaN(det1) ? "NaN" : det1;
        result.tech_det2 = isNaN(det2) ? "NaN" : det2;
        result.tech_det3 = isNaN(det3) ? "NaN" : det3;
        result.tech_det4 = isNaN(det4) ? "NaN" : det4;

        return result;
      }
    }

    return result;

    // Helper function to check if value is numeric
    function isNumeric(value) {
      return !isNaN(parseFloat(value)) && isFinite(value);
    }
  }

  /**
   * getCalculationInverseMatrixCalculator: Service Method
   * POST: /api/calculators-lol/inverse-matrix-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationInverseMatrixCalculator(body) {
    let dtrmn_slct_method = body.tech_dtrmn_slct_method;
    let dtrmn_opts_method = body.tech_dtrmn_opts_method;

    // Convert to numbers
    const matrixSize = parseInt(dtrmn_slct_method);

    // Helper functions (keep all the previous helper functions as they are)
    function invert(A, debug = false) {
      const n = A.length;
      const matrixCopy = A.map((row) => [...row]);
      const pz = A.map((row) => [...row]);

      const I = identity_matrix(n);
      for (let i = 0; i < n; ++i) {
        matrixCopy[i] = [...matrixCopy[i], ...I[i]];
        pz[i] = [...pz[i], ...I[i]];
      }

      // Forward run
      for (let j = 0; j < n - 1; ++j) {
        for (let i = j + 1; i < n; ++i) {
          if (matrixCopy[i][j] !== 0) {
            const scalar = matrixCopy[j][j] / matrixCopy[i][j];
            for (let jj = j; jj < n * 2; ++jj) {
              matrixCopy[i][jj] *= scalar;
              matrixCopy[i][jj] -= matrixCopy[j][jj];
            }
          }
        }
      }

      // Reverse run
      for (let j = n - 1; j > 0; --j) {
        for (let i = j - 1; i >= 0; --i) {
          if (matrixCopy[i][j] !== 0) {
            const scalar = matrixCopy[j][j] / matrixCopy[i][j];
            for (let jj = i; jj < n * 2; ++jj) {
              matrixCopy[i][jj] *= scalar;
              matrixCopy[i][jj] -= matrixCopy[j][jj];
            }
          }
        }
      }

      // Make all diagonal elements 1
      for (let j = 0; j < n; ++j) {
        if (matrixCopy[j][j] !== 1) {
          const scalar = 1 / matrixCopy[j][j];
          for (let jj = j; jj < n * 2; ++jj) {
            matrixCopy[j][jj] *= scalar;
          }
        }
      }

      // Extract the inverse matrix
      const Inv = [];
      for (let i = 0; i < n; ++i) {
        Inv[i] = matrixCopy[i].slice(n);
      }

      return Inv;
    }

    function rref2(matrix) {
      let lead = 0;
      const matrixCopy = matrix.map((row) => [...row]);
      const pz = matrix.map((row) => [...row]);
      const swap = [];
      const swap_line = [];
      const rowCount = matrixCopy.length;

      if (rowCount === 0) return [matrixCopy, swap, swap_line, pz];

      const columnCount = matrixCopy[0] ? matrixCopy[0].length : 0;

      for (let r = 0; r < rowCount; r++) {
        if (lead >= columnCount) break;

        let i = r;
        while (i < rowCount && matrixCopy[i][lead] === 0) {
          i++;
          if (i === rowCount) {
            i = r;
            lead++;
            if (lead === columnCount) return [matrixCopy, swap, swap_line, pz];
          }
        }

        if (i >= rowCount) continue;

        // Swap rows
        [matrixCopy[r], matrixCopy[i]] = [matrixCopy[i], matrixCopy[r]];

        if (i !== r) {
          swap_line.push(`Swap the row ${r + 1} with row ${i + 1}`);
          [pz[r], pz[i]] = [pz[i], pz[r]];
          swap.push(pz.map((row) => [...row]));
        }

        // Normalize the pivot row
        const lv = matrixCopy[r][lead];
        if (lv !== 0) {
          for (let j = 0; j < columnCount; j++) {
            matrixCopy[r][j] = matrixCopy[r][j] / lv;
            pz[r][j] = pz[r][j] / lv;
          }

          const test1 = convert2(lv);
          if (test1[1] == 1) {
            swap_line.push(
              `Divide row ${r + 1} by ${lv}: R<sub>${r + 1}</sub> = R<sub>${
                r + 1
              }</sub>/${lv}`
            );
          } else {
            const lv3 = `${test1[1]}/${test1[0]}`;
            swap_line.push(
              `Multiply row ${r + 1} by ${lv3}: R<sub>${
                r + 1
              }</sub> = ${lv3} R<sub>${r + 1}</sub>`
            );
          }
          swap.push(pz.map((row) => [...row]));
        }

        // Eliminate other rows
        for (let i = 0; i < rowCount; i++) {
          if (i !== r && matrixCopy[i][lead] !== 0) {
            const lv = matrixCopy[i][lead];
            const lv2 = pz[i][lead];
            for (let j = 0; j < columnCount; j++) {
              matrixCopy[i][j] -= lv * matrixCopy[r][j];
              pz[i][j] -= lv2 * pz[r][j];
            }

            swap.push(pz.map((row) => [...row]));
            const test = convert2(lv);
            let lvDisplay = lv;
            if (test[1] != 1) {
              lvDisplay = `${test[0]}/${test[1]}`;
            }
            swap_line.push(
              `Subtract row ${r + 1} multiplied by ${lvDisplay} from row ${
                i + 1
              }: R<sub>${i + 1}</sub> = R<sub>${
                i + 1
              }</sub> - ${lvDisplay}R<sub>${r + 1}</sub>`
            );
          }
        }
        lead++;
      }
      return [matrixCopy, swap, swap_line, pz];
    }

    function identity_matrix(n) {
      const I = [];
      for (let i = 0; i < n; ++i) {
        I[i] = [];
        for (let j = 0; j < n; ++j) {
          I[i][j] = i === j ? 1 : 0;
        }
      }
      return I;
    }

    function deter(arr, N) {
      // Validate array dimensions
      if (!arr || arr.length !== N) {
        throw new Error(`Invalid matrix dimensions: expected ${N}x${N}`);
      }

      for (let i = 0; i < N; i++) {
        if (!arr[i] || arr[i].length !== N) {
          throw new Error(`Invalid matrix row ${i}: expected length ${N}`);
        }
      }

      if (N === 1) {
        return arr[0][0];
      } else if (N === 2) {
        return arr[0][0] * arr[1][1] - arr[0][1] * arr[1][0];
      } else if (N === 3) {
        return (
          arr[0][0] * (arr[1][1] * arr[2][2] - arr[1][2] * arr[2][1]) -
          arr[0][1] * (arr[1][0] * arr[2][2] - arr[1][2] * arr[2][0]) +
          arr[0][2] * (arr[1][0] * arr[2][1] - arr[1][1] * arr[2][0])
        );
      } else {
        // For larger matrices, use recursive determinant
        return determinant(arr, N, N);
      }
    }

    function getCofactor(A, p, q, n) {
      const temp = Array(n - 1)
        .fill(null)
        .map(() => Array(n - 1).fill(0));
      let i = 0;
      let j = 0;

      for (let row = 0; row < n; row++) {
        for (let col = 0; col < n; col++) {
          if (row !== p && col !== q) {
            temp[i][j++] = A[row][col];
            if (j === n - 1) {
              j = 0;
              i++;
            }
          }
        }
      }
      return temp;
    }

    function determinant(A, n, N) {
      if (n === 1) return A[0][0];

      let D = 0;
      let sign = 1;

      for (let f = 0; f < n; f++) {
        const cofactorTemp = getCofactor(A, 0, f, n);
        D += sign * A[0][f] * determinant(cofactorTemp, n - 1, N);
        sign = -sign;
      }
      return D;
    }

    function adjoint(A, N) {
      if (N === 1) {
        return [[[1]], [], [], [], []];
      }

      const adj = Array(N)
        .fill(null)
        .map(() => Array(N).fill(0));
      const sign22 = [];
      const sign_pow = [];
      const c_sign = [];

      for (let i = 0; i < N; i++) {
        for (let j = 0; j < N; j++) {
          const cofactorTemp = getCofactor(A, i, j, N);
          const sign = (i + j) % 2 === 0 ? 1 : -1;
          sign22.push(sign);
          sign_pow.push(`${i + 1} + ${j + 1}`);
          c_sign.push(`${i + 1}${j + 1}`);
          adj[j][i] = sign * determinant(cofactorTemp, N - 1, N);
        }
      }
      return [adj, sign22, sign_pow, [], c_sign];
    }

    function transpose(A, N) {
      const B = Array(N)
        .fill(null)
        .map(() => Array(N).fill(0));
      for (let i = 0; i < N; i++) {
        for (let j = 0; j < N; j++) {
          B[i][j] = A[j][i];
        }
      }
      return B;
    }

    function convert2(xelem) {
      const x = parseFloat(xelem);
      if (isNaN(x)) return ["0", "1"];

      // Simple fraction conversion for display purposes
      const tolerance = 1.0e-6;
      let numerator = 1;
      let denominator = 1;

      for (let d = 1; d <= 1000; d++) {
        const n = Math.round(x * d);
        if (Math.abs(x - n / d) < tolerance) {
          numerator = n;
          denominator = d;
          break;
        }
      }

      const gcdVal = gcd(numerator, denominator);
      numerator /= gcdVal;
      denominator /= gcdVal;

      return [numerator.toString(), denominator.toString()];
    }

    function gcd(a, b) {
      return b === 0 ? a : gcd(b, a % b);
    }

    // Main logic
    const result = {};

    try {
      // console.log('Input matrix size:', matrixSize);
      // console.log('Method:', dtrmn_opts_method);

      // Validate input matrix
      const all = [];
      let totalElements = 0;

      for (let i = 0; i < matrixSize; i++) {
        for (let j = 0; j < matrixSize; j++) {
          const key = `tech_dtrmn_${i}_${j}`;
          const value = body[key];
          // console.log(`Reading ${key}: ${value}`);

          if (value == undefined || value == null || value == "") {
            result.error = `Please provide value for position [${i}][${j}].`;
            return result;
          }
          if (isNumeric(value)) {
            all.push(parseFloat(value));
            totalElements++;
          } else {
            result.error = `Invalid number at position [${i}][${j}]: ${value}`;
            return result;
          }
        }
      }

      // console.log('Total elements collected:', totalElements);
      // console.log('Expected elements:', matrixSize * matrixSize);

      const zain = chunkArray(all, matrixSize);

      // console.log('Matrix created with dimensions:', zain.length, 'x', zain[0] ? zain[0].length : 0);
      // console.log('Matrix content:', JSON.stringify(zain));

      // Validate matrix creation
      if (zain.length != matrixSize) {
        result.error = `Failed to create matrix. Expected ${matrixSize} rows, got ${zain.length}`;
        return result;
      }

      for (let i = 0; i < zain.length; i++) {
        if (zain[i].length != matrixSize) {
          result.error = `Row ${i} has incorrect length. Expected ${matrixSize}, got ${zain[i].length}`;
          return result;
        }
      }

      let det, inverse;

      if (dtrmn_opts_method == "exp_col") {
        // console.log('Using column expansion method');
        det = deter(zain, matrixSize);
        // console.log('Determinant calculated:', det);

        if (Math.abs(det) < 1e-10) {
          inverse = "The matrix is not invertible (determinant is zero).";
        } else {
          // console.log('Calculating inverse using RREF...');
          const f_ans = invert(zain);
          // console.log('Inverse calculated via inversion');

          const n = zain.length;
          const I = identity_matrix(n);
          const invt = [];

          for (let i = 0; i < n; ++i) {
            invt[i] = [...zain[i], ...I[i]];
          }

          const ans = rref2(invt);
          const inverseFlat = [];

          f_ans.forEach((value) => {
            value.forEach((value2) => {
              const numValue = parseFloat(value2);
              if (!isNaN(numValue)) {
                if (Number.isInteger(numValue)) {
                  inverseFlat.push(numValue);
                } else {
                  inverseFlat.push(parseFloat(numValue.toFixed(6)));
                }
              } else {
                inverseFlat.push(value2);
              }
            });
          });

          inverse = chunkArray(inverseFlat, matrixSize);
          result.tech_matrix = ans[0];
          result.tech_swap = ans[1];
          result.tech_swap_line = ans[2];
        }
      } else if (dtrmn_opts_method == "exp_row") {
        // console.log('Using row expansion method');
        det = deter(zain, matrixSize);
        // console.log('Determinant calculated:', det);

        if (Math.abs(det) < 1e-10) {
          // inverse = "The matrix is not invertible (determinant is zero).";
        } else {
          // console.log('Calculating inverse using adjoint method...');
          const cofa = [];

          for (let i = 0; i < matrixSize; i++) {
            for (let j = 0; j < matrixSize; j++) {
              cofa.push(getCofactor(zain, i, j, matrixSize));
            }
          }

          const all_cofadet = cofa.map((value) =>
            determinant(value, matrixSize - 1, matrixSize)
          );

          const res = adjoint(zain, matrixSize);
          const allans_det = [];

          for (let i = 0; i < all_cofadet.length; i++) {
            allans_det.push(all_cofadet[i] * res[1][i]);
          }

          const adj_ans = res[0];
          const c_down = res[4];
          const minus_pow = res[2];
          const all_cofy = cofa;
          const final_cofa = chunkArray(allans_det, matrixSize);
          const ans_tran = transpose(final_cofa, matrixSize);

          inverse = Array(matrixSize)
            .fill(null)
            .map(() => Array(matrixSize).fill(0));
          for (let i = 0; i < matrixSize; i++) {
            for (let j = 0; j < matrixSize; j++) {
              const invValue = adj_ans[i][j] / det;
              const numValue = parseFloat(invValue);
              if (!isNaN(numValue)) {
                if (Number.isInteger(numValue)) {
                  inverse[i][j] = numValue;
                } else {
                  inverse[i][j] = parseFloat(numValue.toFixed(6));
                }
              } else {
                inverse[i][j] = invValue;
              }
            }
          }

          result.tech_c_down = c_down;
          result.tech_minus_pow = minus_pow;
          result.tech_all_cofy = all_cofy;
          result.tech_allcofy_det = allans_det;
          result.tech_ans_tran = ans_tran;
          result.tech_final_cofa = final_cofa;
        }
      } else {
        result.error = "Invalid method specified.";
        return result;
      }

      result.tech_zain = zain;
      result.tech_det = det;
      result.tech_inverse = inverse;

      // console.log('Calculation completed successfully');
    } catch (error) {
      console.error("Calculation error details:", error);
      result.error = `An error occurred during calculation: ${error.message}`;
    }

    return result;

    // Helper functions
    function isNumeric(value) {
      if (typeof value == "number") return true;
      if (typeof value != "string") return false;
      return !isNaN(value) && !isNaN(parseFloat(value));
    }

    function chunkArray(array, size) {
      if (!array || !size || size <= 0) return [];
      const result = [];
      for (let i = 0; i < array.length; i += size) {
        result.push(array.slice(i, i + size));
      }
      return result;
    }
  }

  /** getCalculationMatrixTransposeCalculator
   * POST: /api/calculators-lol/matrix-transpose-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMatrixTransposeCalculator(body) {
    let matrix2 = parseInt(body.tech_matrix2);
    let matrix22 = parseInt(body.tech_matrix22);
    let second_matrix = [];
    let chuti = [];

    for (let i = 1; i <= matrix2; i++) {
      for (let j = 1; j <= matrix22; j++) {
        const key = `tech_matrix3${i}_${j}`;
        const val = body[key];

        if (val !== undefined && !isNaN(val)) {
          second_matrix.push(Number(val));
          chuti.push(`&${key}=`);
        } else {
          return { error: "Please! Check Your Input." };
        }
      }
    }

    function transpose(A) {
      let rows = A.length;
      if (rows === 0) return A;
      let cols = A[0].length;
      let result = [];

      for (let j = 0; j < cols; j++) {
        result[j] = [];
        for (let i = 0; i < rows; i++) {
          result[j][i] = A[i][j];
        }
      }

      return result;
    }

    const mul = matrix2 * matrix22;

    if (mul === second_matrix.length) {
      const zain = [];
      for (let i = 0; i < matrix2; i++) {
        zain.push(second_matrix.slice(i * matrix22, (i + 1) * matrix22));
      }
      const jawab = transpose(zain);

      return {
        tech_zain: zain,
        tech_jawab: jawab,
        tech_chuti: chuti,
        tech_second_matrix: second_matrix,
      };
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /**
   * getCalculationVectorAdditionCalculator: Service Method
   * POST: /api/calculators-lol/vector-addition-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationVectorAdditionCalculator(body) {
    let calculation = body.tech_calculation;
    let operation = body.tech_operation;
    let alpha = body.tech_alpha;
    let beta = body.tech_beta;

    let vectora_representation = body.tech_vectora_representation;
    let ax = body.tech_ax;
    let ay = body.tech_ay;
    let az = body.tech_az;

    let vectorb_representation = body.tech_vectorb_representation;
    let bx = body.tech_bx;
    let by = body.tech_by;
    let bz = body.tech_bz;

    let magnitude_x = body.tech_magnitude_x;
    let direction_x = body.tech_direction_x;
    let direction_x_unit = body.tech_direction_x_unit;

    let magnitude_y = body.tech_magnitude_y;
    let direction_y = body.tech_direction_y;
    let direction_y_unit = body.tech_direction_y_unit;

    // Helper function to convert angles
    function convert_angle(unit, value) {
      const numValue = parseFloat(value);
      if (isNaN(numValue)) return 0;

      switch (unit) {
        case "deg":
          return numValue * 0.017453;
        case "rad":
          return numValue * 1;
        case "gon":
          return numValue * 0.015708;
        case "tr":
          return numValue * 6.283;
        case "arcmin":
          return numValue * 0.0002909;
        case "arcsec":
          return numValue * 0.000004848;
        case "mrad":
          return numValue * 0.001;
        case "μrad":
          return numValue * 0.000001;
        case "* π rad":
          return numValue * 3.1416;
        default:
          return numValue;
      }
    }

    // Helper function to check if all values are numeric
    function areAllNumeric(...values) {
      return values.every((val) => isNumeric(val));
    }

    const result = {};

    try {
      if (calculation === "3D") {
        // Three Dimensional
        if (operation === "1") {
          // Addition without multiples
          if (areAllNumeric(ax, ay, az, bx, by, bz)) {
            const calculate_x = parseFloat(ax) + parseFloat(bx);
            const calculate_y = parseFloat(ay) + parseFloat(by);
            const calculate_z = parseFloat(az) + parseFloat(bz);
            const calculate_m = Math.sqrt(
              calculate_x * calculate_x +
                calculate_y * calculate_y +
                calculate_z * calculate_z
            );
            const q = parseFloat(bx) + parseFloat(ax);
            const theta = Math.acos(q / calculate_m);

            result.tech_x = isNaN(calculate_x) ? "NaN" : calculate_x;
            result.tech_y = isNaN(calculate_y) ? "NaN" : calculate_y;
            result.tech_z = isNaN(calculate_z) ? "NaN" : calculate_z;
            result.tech_m = isNaN(calculate_m) ? "NaN" : calculate_m;
            result.tech_theta = isNaN(theta) ? "NaN" : theta;
          } else {
            result.error = "Please! Check your input";
            return result;
          }
        } else if (operation === "2") {
          // Addition with multiplies
          if (areAllNumeric(ax, ay, az, bx, by, bz, alpha, beta)) {
            const calculate_x =
              parseFloat(ax) * parseFloat(alpha) +
              parseFloat(bx) * parseFloat(beta);
            const calculate_y =
              parseFloat(ay) * parseFloat(alpha) +
              parseFloat(by) * parseFloat(beta);
            const calculate_z =
              parseFloat(az) * parseFloat(alpha) +
              parseFloat(bz) * parseFloat(beta);

            result.tech_x = isNaN(calculate_x) ? "NaN" : calculate_x;
            result.tech_y = isNaN(calculate_y) ? "NaN" : calculate_y;
            result.tech_z = isNaN(calculate_z) ? "NaN" : calculate_z;
          } else {
            result.error = "Please! Check your input";
            return result;
          }
        } else if (operation === "3") {
          // Subtraction without multiplies
          if (areAllNumeric(ax, ay, az, bx, by, bz)) {
            const calculate_x = parseFloat(ax) - parseFloat(bx);
            const calculate_y = parseFloat(ay) - parseFloat(by);
            const calculate_z = parseFloat(az) - parseFloat(bz);

            result.tech_x = isNaN(calculate_x) ? "NaN" : calculate_x;
            result.tech_y = isNaN(calculate_y) ? "NaN" : calculate_y;
            result.tech_z = isNaN(calculate_z) ? "NaN" : calculate_z;
          } else {
            result.error = "Please! Check your input";
            return result;
          }
        } else if (operation === "4") {
          // Subtraction with multiplies
          if (areAllNumeric(ax, ay, az, bx, by, bz, alpha, beta)) {
            const calculate_x =
              parseFloat(ax) * parseFloat(alpha) -
              parseFloat(bx) * parseFloat(beta);
            const calculate_y =
              parseFloat(ay) * parseFloat(alpha) -
              parseFloat(by) * parseFloat(beta);
            const calculate_z =
              parseFloat(az) * parseFloat(alpha) -
              parseFloat(bz) * parseFloat(beta);

            result.tech_x = isNaN(calculate_x) ? "NaN" : calculate_x;
            result.tech_y = isNaN(calculate_y) ? "NaN" : calculate_y;
            result.tech_z = isNaN(calculate_z) ? "NaN" : calculate_z;
          } else {
            result.error = "Please! Check your input";
            return result;
          }
        }
        result.tech_operation = operation;
      } else if (calculation === "2D") {
        let calculate_x, calculate_y, calculate_m, theta, method;

        if (["1", "2", "3", "4"].includes(operation)) {
          // When both are cartesian coordinates
          if (vectora_representation == "1" && vectorb_representation == "1") {
            if (areAllNumeric(ax, ay, bx, by)) {
              const num_ax = parseFloat(ax);
              const num_ay = parseFloat(ay);
              const num_bx = parseFloat(bx);
              const num_by = parseFloat(by);

              if (operation == "1") {
                calculate_x = num_ax + num_bx;
                calculate_y = num_ay + num_by;
                calculate_m = Math.sqrt(
                  calculate_x * calculate_x + calculate_y * calculate_y
                );
                const q = num_bx + num_ax;
                theta = Math.acos(q / calculate_m);
                method = 1;
              } else if (operation == "2") {
                if (areAllNumeric(alpha, beta)) {
                  calculate_x =
                    num_ax * parseFloat(alpha) + num_bx * parseFloat(beta);
                  calculate_y =
                    num_ay * parseFloat(alpha) + num_by * parseFloat(beta);
                  calculate_m = Math.sqrt(
                    calculate_x * calculate_x + calculate_y * calculate_y
                  );
                  const q = calculate_x;
                  theta = Math.acos(q / calculate_m);
                  method = 1;
                } else {
                  result.error = "Please! Check your input";
                  return result;
                }
              } else if (operation == "3") {
                calculate_x = num_ax - num_bx;
                calculate_y = num_ay - num_by;
                calculate_m = Math.sqrt(
                  calculate_x * calculate_x + calculate_y * calculate_y
                );
                const q = calculate_x;

                if (calculate_m == 0.0) {
                  if (q == 0.0) {
                    theta = 0;
                  } else {
                    theta = Infinity;
                  }
                } else {
                  theta = Math.acos(q / calculate_m);
                }
                method = 2;
                console.log(theta);
              } else if (operation == "4") {
                if (areAllNumeric(alpha, beta)) {
                  calculate_x =
                    num_ax * parseFloat(alpha) - num_bx * parseFloat(beta);
                  calculate_y =
                    num_ay * parseFloat(alpha) - num_by * parseFloat(beta);
                  calculate_m = Math.sqrt(
                    calculate_x * calculate_x + calculate_y * calculate_y
                  );

                  if (calculate_m != 0) {
                    theta = Math.acos(calculate_x / calculate_m);
                  } else {
                    theta = null;
                  }
                  method = 2;
                } else {
                  result.error = "Please! Check your input";
                  return result;
                }
              }
            } else {
              result.error = "Please! Check your input";
              return result;
            }
          }
          // When x is coordinate and y is magnitude
          else if (
            vectora_representation == "1" &&
            vectorb_representation == "2"
          ) {
            if (areAllNumeric(ax, ay, magnitude_y, direction_y)) {
              const direction_y_value = convert_angle(
                direction_y_unit,
                direction_y
              );
              const num_ax = parseFloat(ax);
              const num_ay = parseFloat(ay);
              const num_magnitude_y = parseFloat(magnitude_y);

              if (operation == "1") {
                calculate_x = parseFloat(
                  (
                    num_ax +
                    num_magnitude_y * Math.cos(direction_y_value)
                  ).toFixed(4)
                );
                calculate_y = parseFloat(
                  (
                    num_ay +
                    num_magnitude_y * Math.sin(direction_y_value)
                  ).toFixed(4)
                );
                calculate_m = Math.sqrt(
                  calculate_x * calculate_x + calculate_y * calculate_y
                );
                const q = calculate_x;
                theta = Math.acos(q / calculate_m);
                method = 1;
              } else if (operation == "2") {
                if (areAllNumeric(alpha, beta)) {
                  calculate_x =
                    num_ax * parseFloat(alpha) +
                    num_magnitude_y *
                      parseFloat(beta) *
                      Math.cos(direction_y_value);
                  calculate_y =
                    num_ay * parseFloat(alpha) +
                    num_magnitude_y *
                      (Math.sin(direction_y_value) * parseFloat(beta));
                  calculate_m = Math.sqrt(
                    calculate_x * calculate_x + calculate_y * calculate_y
                  );
                  const q = calculate_x;
                  theta = Math.acos(q / calculate_m);
                  method = 1;
                } else {
                  result.error = "Please! Check your input";
                  return result;
                }
              } else if (operation == "3") {
                calculate_x =
                  num_ax - num_magnitude_y * Math.cos(direction_y_value);
                calculate_y =
                  num_ay - num_magnitude_y * Math.sin(direction_y_value);
                calculate_m = Math.sqrt(
                  calculate_x * calculate_x + calculate_y * calculate_y
                );
                const q = calculate_x;
                theta = Math.acos(q / calculate_m);
                method = 2;
              } else if (operation == "4") {
                if (areAllNumeric(alpha, beta)) {
                  calculate_x =
                    num_ax * parseFloat(alpha) -
                    num_magnitude_y *
                      parseFloat(beta) *
                      Math.cos(direction_y_value);
                  calculate_y =
                    num_ay * parseFloat(alpha) -
                    num_magnitude_y *
                      (Math.sin(direction_y_value) * parseFloat(beta));
                  calculate_m = Math.sqrt(
                    calculate_x * calculate_x + calculate_y * calculate_y
                  );
                  const q = calculate_x;
                  theta = Math.acos(q / calculate_m);
                  method = 2;
                } else {
                  result.error = "Please! Check your input";
                  return result;
                }
              }
            } else {
              result.error = "Please! Check your input";
              return result;
            }
          }
          // When x is magnitude and y is coordinate
          else if (
            vectorb_representation === "1" &&
            vectora_representation === "2"
          ) {
            if (areAllNumeric(bx, by, magnitude_x, direction_x)) {
              const direction_x_value = convert_angle(
                direction_x_unit,
                direction_x
              );
              const num_bx = parseFloat(bx);
              const num_by = parseFloat(by);
              const num_magnitude_x = parseFloat(magnitude_x);

              if (operation == "1") {
                calculate_x =
                  num_magnitude_x * Math.cos(direction_x_value) + num_bx;
                calculate_y =
                  num_magnitude_x * Math.sin(direction_x_value) + num_by;
                calculate_m = Math.sqrt(
                  calculate_x * calculate_x + calculate_y * calculate_y
                );
                theta = Math.acos(calculate_x / calculate_m);
                method = 1;
              } else if (operation == "2") {
                if (areAllNumeric(alpha, beta)) {
                  calculate_x =
                    num_magnitude_x *
                      Math.cos(direction_x_value) *
                      parseFloat(alpha) +
                    num_bx * parseFloat(beta);
                  calculate_y =
                    num_magnitude_x *
                      Math.sin(direction_x_value) *
                      parseFloat(alpha) +
                    num_by * parseFloat(beta);
                  calculate_m = Math.sqrt(
                    calculate_x * calculate_x + calculate_y * calculate_y
                  );
                  theta = Math.acos(calculate_x / calculate_m);
                  method = 1;
                } else {
                  result.error = "Please! Check your input";
                  return result;
                }
              } else if (operation == "3") {
                calculate_x = parseFloat(
                  (
                    num_bx -
                    num_magnitude_x * Math.cos(direction_x_value)
                  ).toFixed(4)
                );
                calculate_y = parseFloat(
                  (
                    num_by -
                    num_magnitude_x * Math.sin(direction_x_value)
                  ).toFixed(4)
                );
                calculate_m = Math.sqrt(
                  calculate_x * calculate_x + calculate_y * calculate_y
                );
                const q = calculate_x;
                theta = Math.acos(q / calculate_m);
                method = 2;
              } else if (operation == "4") {
                if (areAllNumeric(alpha, beta)) {
                  calculate_x =
                    num_magnitude_x *
                      Math.cos(direction_x_value) *
                      parseFloat(alpha) -
                    num_bx * parseFloat(beta);
                  calculate_y =
                    num_magnitude_x *
                      Math.sin(direction_x_value) *
                      parseFloat(alpha) -
                    num_by * parseFloat(beta);
                  calculate_m = Math.sqrt(
                    calculate_x * calculate_x + calculate_y * calculate_y
                  );
                  theta = Math.acos(calculate_x / calculate_m);
                  method = 2;
                } else {
                  result.error = "Please! Check your input";
                  return result;
                }
              }
            } else {
              result.error = "Please! Check your input";
              return result;
            }
          }
          // When both are magnitude representations
          else if (
            vectorb_representation == "2" &&
            vectora_representation == "2"
          ) {
            if (
              areAllNumeric(magnitude_y, direction_y, magnitude_x, direction_x)
            ) {
              const num_magnitude_x = parseFloat(magnitude_x);
              const num_magnitude_y = parseFloat(magnitude_y);

              if (operation == "1") {
                const direction_x_value = convert_angle(
                  direction_x_unit,
                  direction_x
                );
                const direction_y_value = convert_angle(
                  direction_y_unit,
                  direction_y
                );
                const x1 = num_magnitude_x * Math.cos(direction_x_value);
                const x2 = num_magnitude_x * Math.sin(direction_x_value);
                const y1 = num_magnitude_y * Math.cos(direction_y_value);
                const y2 = num_magnitude_y * Math.sin(direction_y_value);
                calculate_x = x1 + y1;
                calculate_y = x2 + y2;
                calculate_m = Math.sqrt(
                  calculate_x * calculate_x + calculate_y * calculate_y
                );
                theta = Math.acos(calculate_x / calculate_m);
                method = 1;
              } else if (operation == "2") {
                if (areAllNumeric(alpha, beta)) {
                  const direction_x_value = convert_angle(
                    direction_x_unit,
                    direction_x
                  );
                  const direction_y_value = convert_angle(
                    direction_y_unit,
                    direction_y
                  );
                  const x1 =
                    num_magnitude_x *
                    Math.cos(direction_x_value) *
                    parseFloat(alpha);
                  const x2 =
                    num_magnitude_x *
                    Math.sin(direction_x_value) *
                    parseFloat(alpha);
                  const y1 =
                    num_magnitude_y *
                    Math.cos(direction_y_value) *
                    parseFloat(beta);
                  const y2 =
                    num_magnitude_y *
                    Math.sin(direction_y_value) *
                    parseFloat(beta);
                  calculate_x = x1 + y1;
                  calculate_y = x2 + y2;
                  calculate_m = Math.sqrt(
                    calculate_x * calculate_x + calculate_y * calculate_y
                  );
                  theta = Math.acos(calculate_x / calculate_m);
                  method = 1;
                } else {
                  result.error = "Please! Check your input";
                  return result;
                }
              } else if (operation == "3") {
                //  let theta = 0;
                const direction_x_value = convert_angle(
                  direction_x_unit,
                  direction_x
                );
                const direction_y_value = convert_angle(
                  direction_y_unit,
                  direction_y
                );
                const x1 = num_magnitude_x * Math.cos(direction_x_value);
                const x2 = num_magnitude_x * Math.sin(direction_x_value);
                const y1 = num_magnitude_y * Math.cos(direction_y_value);
                const y2 = num_magnitude_y * Math.sin(direction_y_value);
                calculate_x = x1 - y1;
                calculate_y = x2 - y2;
                calculate_m = Math.sqrt(
                  calculate_x * calculate_x + calculate_y * calculate_y
                );
                theta = Math.acos(calculate_x / calculate_m);
                method = 2;
              } else if (operation == "4") {
                if (areAllNumeric(alpha, beta)) {
                  const direction_x_value = convert_angle(
                    direction_x_unit,
                    direction_x
                  );
                  const direction_y_value = convert_angle(
                    direction_y_unit,
                    direction_y
                  );
                  const x1 =
                    num_magnitude_x *
                    Math.cos(direction_x_value) *
                    parseFloat(alpha);
                  const x2 =
                    num_magnitude_x *
                    Math.sin(direction_x_value) *
                    parseFloat(alpha);
                  const y1 =
                    num_magnitude_y *
                    Math.cos(direction_y_value) *
                    parseFloat(beta);
                  const y2 =
                    num_magnitude_y *
                    Math.sin(direction_y_value) *
                    parseFloat(beta);
                  calculate_x = x1 - y1;
                  calculate_y = x2 - y2;
                  calculate_m = Math.sqrt(
                    calculate_x * calculate_x + calculate_y * calculate_y
                  );

                  if (calculate_m == 0.0) {
                    if (calculate_x == 0.0) {
                      theta = 0;
                    } else {
                      theta = Infinity;
                    }
                  } else {
                    theta = Math.acos(calculate_x / calculate_m);
                  }
                  method = 2;
                } else {
                  result.error = "Please! Check your input";
                  return result;
                }
              }
            } else {
              result.error = "Please! Check your input";
              return result;
            }
          } else {
            result.error = "Invalid vector representation combination";
            return result;
          }

          result.tech_x = isNaN(calculate_x) ? "NaN" : calculate_x;
          result.tech_y = isNaN(calculate_y) ? "NaN" : calculate_y;
          result.tech_m = isNaN(calculate_m) ? "NaN" : calculate_m;
          result.tech_theta = isNaN(theta) ? "NaN" : theta;
          result.tech_method = method;
        } else {
          result.error = "Invalid operation";
          return result;
        }
      } else {
        result.error = "Invalid calculation type";
        return result;
      }
    } catch (error) {
      console.error("Vector calculation error:", error);
      result.error = `An error occurred during calculation: ${error.message}`;
    }

    return result;

    // Helper function to check if value is numeric
    function isNumeric(value) {
      if (typeof value === "number") return true;
      if (typeof value !== "string") return false;
      return !isNaN(value) && !isNaN(parseFloat(value));
    }
  }

  /** getCalculationWeightedAverageCalculator
   * POST: /api/calculators-lol/weighted-average-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationWeightedAverageCalculator(body) {
    let weight = body.tech_weight;
    let value = body.tech_value;

    if (!Array.isArray(weight) || !Array.isArray(value)) {
      return { error: "Input must be arrays of numbers." };
    }

    let i = 0;
    let weight_sum = 0;
    let weighted_average = 0;

    while (i < weight.length && i < value.length) {
      let w = parseFloat(weight[i]);
      let v = parseFloat(value[i]);

      if (!isFinite(w) || !isFinite(v)) {
        return { error: "Please! Check Your Input." };
      }

      weight_sum += w;
      weighted_average += w * v;
      i++;
    }

    if (weight_sum === 0) {
      return { error: "Total weight cannot be zero." };
    }

    let final_ans = weighted_average / weight_sum;

    return {
      tech_weight_sum: weight_sum,
      tech_weighted_average: final_ans,
      tech_wv: weight.length,
      tech_v: value.length,
      tech_values: value,
      tech_weights: weight,
    };
  }

  /**
   * getCalculationGaussSeidelCalculator: Service Method
   * POST: /api/calculators-lol/gauss-seidel-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */
  async getCalculationGaussSeidelCalculator(body) {
    let number = body.tech_number;
    let value = body.tech_value;

    // Helper function to calculate determinant
    function solve_matrix(m) {
      const size = m.length;

      switch (size) {
        case 1:
          return m[0][0];
        case 2:
          return m[0][0] * m[1][1] - m[0][1] * m[1][0];
        case 3:
          return (
            m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1]) -
            m[1][0] * (m[0][1] * m[2][2] - m[0][2] * m[2][1]) +
            m[2][0] * (m[0][1] * m[1][2] - m[0][2] * m[1][1])
          );
        default:
          return 0;
      }
    }

    const result = {};

    try {
      // Validate inputs
      const n = parseInt(number);
      if (isNaN(n) || n < 0) {
        result.error = "Invalid matrix size";
        return result;
      }

      // Read matrix values
      const matrix = [];
      const r = [];

      for (let i = 0; i <= n; i++) {
        matrix[i] = [];
        for (let j = 0; j <= n; j++) {
          const key = `tech_matrix${i}_${j}`;
          const val = body[key];

          if (isNumeric(val)) {
            matrix[i][j] = parseFloat(val);
            r.push(parseFloat(val));
          } else {
            result.error = `Please! Check Your Input at position [${i}][${j}].`;
            return result;
          }
        }
      }

      // Validate value array
      if (!value || !Array.isArray(value) || value.length <= n) {
        result.error = "Invalid value array";
        return result;
      }

      const numericValue = value
        .map((v) => parseFloat(v))
        .filter((v) => !isNaN(v));
      if (numericValue.length <= n) {
        result.error = "Please! Check Your Input values.";
        return result;
      }

      // Create upper triangular matrix
      const upper = [];
      for (let k = 0; k <= n; k++) {
        upper[k] = [];
        for (let f = 0; f <= n; f++) {
          if (k > f) {
            upper[k][f] = 0;
          } else {
            upper[k][f] = matrix[k][f];
          }
        }
      }

      // Create lower triangular matrix
      const lower = [];
      for (let i = 0; i <= n; i++) {
        lower[i] = [];
        for (let j = 0; j <= n; j++) {
          if (j > i) {
            lower[i][j] = 0;
          } else {
            lower[i][j] = matrix[i][j];
          }
        }
      }

      // Calculate determinant of lower matrix
      const I_matrix_I = solve_matrix(lower);

      if (Math.abs(I_matrix_I) < 1e-10) {
        result.error = "Matrix is singular (determinant is zero)";
        return result;
      }

      // Calculate adjoint matrix
      const adjoint = [];
      for (let i = 0; i <= n; i++) {
        adjoint[i] = [];
        for (let j = 0; j <= n; j++) {
          adjoint[i][j] = 0;
        }
      }

      for (let i = 0; i <= n; i++) {
        for (let j = 0; j <= n; j++) {
          const cofactor = [];
          for (let k = 0; k <= n; k++) {
            if (i !== k) {
              const temp = [];
              for (let l = 0; l <= n; l++) {
                if (j !== l) {
                  temp.push(lower[k][l]);
                }
              }
              if (temp.length > 0) {
                cofactor.push(temp);
              }
            }
          }

          if (cofactor.length > 0) {
            adjoint[j][i] = solve_matrix(cofactor) * Math.pow(-1, i + j);
          } else {
            adjoint[j][i] = 0;
          }
        }
      }

      // Calculate inverse matrix
      const inverse = [];
      for (let i = 0; i <= n; i++) {
        inverse[i] = [];
        for (let j = 0; j <= n; j++) {
          inverse[i][j] = adjoint[i][j] / I_matrix_I;
        }
      }

      // Modify upper matrix (set diagonal to zero)
      for (let i = 0; i < upper.length; i++) {
        for (let j = 0; j < upper[i].length; j++) {
          if (i === j) {
            upper[i][j] = 0;
          }
        }
      }

      // Calculate result matrix: -inverse * upper
      const resultMatrix = [];
      for (let i = 0; i < inverse.length; i++) {
        resultMatrix[i] = [];
        for (let j = 0; j < upper[0].length; j++) {
          resultMatrix[i][j] = 0;
          for (let k = 0; k < upper.length; k++) {
            resultMatrix[i][j] += -inverse[i][k] * upper[k][j];
          }
        }
      }

      // Calculate result2 matrix: inverse * value
      const result2 = [];
      for (let i = 0; i < inverse.length; i++) {
        result2[i] = [];
        for (let j = 0; j < 1; j++) {
          result2[i][j] = 0;
          for (let k = 0; k <= n; k++) {
            result2[i][j] += inverse[i][k] * numericValue[k];
          }
        }
      }

      // Gauss-Seidel iteration (19 iterations as in original code)
      let resultt = [];
      const result3 = [];

      for (let h = 0; h < 19; h++) {
        for (let j = 0; j < resultMatrix.length; j++) {
          result3[j] = [];
          for (let k = 0; k < 1; k++) {
            result3[j][k] = 0;
            for (let m = 0; m < result2.length; m++) {
              if (h === 0) {
                result3[j][k] += resultMatrix[j][m] * result2[m][k];
              } else {
                result3[j][k] += resultMatrix[j][m] * resultt[m][k];
              }
            }
          }
        }

        // Initialize resultt array if not exists
        if (!resultt.length) {
          resultt = Array(result3.length)
            .fill()
            .map(() => Array(1).fill(0));
        }

        for (let n = 0; n < result3.length; n++) {
          for (let z = 0; z < 1; z++) {
            resultt[n][z] = result3[n][z] + result2[n][z];
          }
        }
      }

      // Prepare final result
      result.tech_upper = upper;
      result.tech_lower = lower;
      result.tech_number = n;
      result.tech_inverse = inverse;
      result.tech_value = numericValue;
      result.tech_result = resultMatrix;
      result.tech_result2 = result2;
      result.tech_main_result = resultt;
    } catch (error) {
      console.error("Gauss-Seidel calculation error:", error);
      result.error = `An error occurred during calculation: ${error.message}`;
    }

    return result;

    // Helper function to check if value is numeric
    function isNumeric(value) {
      if (value === null || value === undefined || value === "") return false;
      if (typeof value === "number") return true;
      if (typeof value !== "string") return false;
      return !isNaN(value) && !isNaN(parseFloat(value));
    }
  }

  /** getCalculationTestGradeCalculator
   * POST: /api/calculators-lol/test-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTestGradeCalculator(body) {
    let grades = body.tech_grades;
    let first = body.tech_first;
    let second = body.tech_second;
    let increment = body.tech_increment;
    let aplus = body.tech_aplus;
    let a = body.tech_a;
    let aminus = body.tech_aminus;
    let bplus = body.tech_bplus;
    let b = body.tech_b;
    let bminus = body.tech_bminus;
    let cplus = body.tech_cplus;
    let c = body.tech_c;
    let cminus = body.tech_cminus;
    let dplus = body.tech_dplus;
    let d = body.tech_d;
    let dminus = body.tech_dminus;

    first = parseFloat(first);
    second = parseFloat(second);
    increment = Math.floor(parseFloat(increment));

    if (isNaN(first) || isNaN(second) || isNaN(increment) || increment <= 0) {
      return { error: "Please Check Your Input." };
    }

    let q_array = [],
      i_array = [],
      g_array = [],
      l_array = [],
      letter_ans = "",
      lettertbl = [],
      percenttbl = [];

    for (let j = first; j >= 0; j -= increment) {
      q_array.push(j);
    }

    for (let i = 0; i <= first; i += increment) {
      i_array.push(i);
    }

    let correct = first - second;
    let per = Math.round((100 * correct) / first);

    if (parseInt(grades) === 1) {
      a = parseFloat(a);
      b = parseFloat(b);
      c = parseFloat(c);
      d = parseFloat(d);

      if ([a, b, c, d].some(isNaN)) {
        return { error: "Please Check Your Input." };
      }
      if (a < b || b < c || c < d) {
        return { error: "Grade limits are not in correct descending order." };
      }

      lettertbl = ["A", "B", "C", "D", "F"];
      percenttbl = [a, b, c, d, 0];
    } else if (parseInt(grades) === 2) {
      aplus = parseFloat(aplus);
      a = parseFloat(a);
      aminus = parseFloat(aminus);
      bplus = parseFloat(bplus);
      b = parseFloat(b);
      bminus = parseFloat(bminus);
      cplus = parseFloat(cplus);
      c = parseFloat(c);
      cminus = parseFloat(cminus);
      dplus = parseFloat(dplus);
      d = parseFloat(d);
      dminus = parseFloat(dminus);

      let limits = [
        aplus,
        a,
        aminus,
        bplus,
        b,
        bminus,
        cplus,
        c,
        cminus,
        dplus,
        d,
        dminus,
      ];

      if (limits.some(isNaN)) {
        return { error: "Please Check Your Input." };
      }

      for (let i = 0; i < limits.length - 1; i++) {
        if (limits[i] < limits[i + 1]) {
          return { error: "Grade limits are not in correct descending order." };
        }
      }

      lettertbl = [
        "A+",
        "A",
        "A-",
        "B+",
        "B",
        "B-",
        "C+",
        "C",
        "C-",
        "D+",
        "D",
        "D-",
        "F",
      ];
      percenttbl = [...limits, 0];
    }

    for (let i = 0; i < percenttbl.length; i++) {
      if (per >= percenttbl[i]) {
        letter_ans = lettertbl[i];
        break;
      }
    }

    for (let k = 0; k < q_array.length; k++) {
      let grade = Math.round((100 * q_array[k]) / first);
      for (let i = 0; i < percenttbl.length; i++) {
        if (grade >= percenttbl[i]) {
          l_array.push(lettertbl[i]);
          break;
        }
      }
      g_array.push(grade);
    }

    return {
      tech_first: first,
      tech_correct: correct,
      tech_per: per,
      tech_letter_ans: letter_ans,
      tech_q_array: q_array,
      tech_i_array: i_array,
      tech_g_array: g_array,
      tech_l_array: l_array,
    };
  }

  /** getCalculationMarksPercentageCalculator
   * POST: /api/calculators-lol/marks-percentage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationMarksPercentageCalculator(body) {
    let type = body.tech_type;
    let first = body.tech_first;
    let second = body.tech_second;
    let sub_name = body.tech_sub_name; // array
    let s_marks = body.tech_s_marks; // array
    let a_marks = body.tech_a_marks; // array

    let result = {};

    if (type === "first") {
      if (isNumeric(first) && isNumeric(second)) {
        if (parseFloat(first) <= parseFloat(second)) {
          let percent = (parseFloat(first) / parseFloat(second)) * 100;
          result.tech_type = type;
          result.tech_percent = percent;
          return result;
        } else {
          return {
            error: "Total scored marks should be less than out of marks.",
          };
        }
      } else {
        return { error: "Please! Check Your Input" };
      }
    } else if (type === "second") {
      let name_array = [];
      let s_array = [];
      let a_array = [];

      if (
        Array.isArray(sub_name) &&
        Array.isArray(s_marks) &&
        Array.isArray(a_marks)
      ) {
        let y = 0;
        while (
          y < sub_name.length &&
          y < s_marks.length &&
          y < a_marks.length
        ) {
          if (sub_name[y] && isNumeric(s_marks[y]) && isNumeric(a_marks[y])) {
            name_array.push(sub_name[y]);
            s_array.push(parseFloat(s_marks[y]));
            a_array.push(parseFloat(a_marks[y]));
          } else {
            return { error: "Please! Check Your Input" };
          }
          y++;
        }

        let total_scored = s_array.reduce((a, b) => a + b, 0);
        let total_marks = a_array.reduce((a, b) => a + b, 0);
        let percent = (total_scored / total_marks) * 100;

        result.tech_name_array = name_array;
        result.tech_s_array = s_array;
        result.tech_a_array = a_array;
        result.tech_total_scored = total_scored;
        result.tech_total_marks = total_marks;
        result.tech_type = type;
        result.tech_percent = percent;
        return result;
      } else {
        return { error: "Invalid input arrays." };
      }
    }

    function isNumeric(val) {
      return !isNaN(parseFloat(val)) && isFinite(val);
    }
  }

  /**
   * getCalculationRationalizeTheDenominatorCalculator: Service Method
   * POST: /api/calculators-lol/rationalize-the-denominator-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRationalizeTheDenominatorCalculator(body) {
    const params = {};

    try {
      let type = body.tech_type;
      let operations = body.tech_operations;
      let a = body.tech_a;
      let b = body.tech_b;
      let n = body.tech_n;
      let c = body.tech_c;
      let d = body.tech_d;
      let m = body.tech_m;
      let x = body.tech_x;
      let y = body.tech_y;
      let k = body.tech_k;
      let u = body.tech_u;
      let n1 = body.tech_n1;
      let d1 = body.tech_d1;

      if (type == "first") {
        if (operations == "1") {
          if ([a, b, n, x, y, k].every((val) => !isNaN(val))) {
            if (a != 0) {
              if (b > 0) {
                if (n >= 2) {
                  if (x != 0) {
                    if (y > 0) {
                      if (k != 0) {
                        params.tech_operations = operations;
                        params.tech_type = type;
                        params.tech_a = a;
                        params.tech_b = b;
                        params.tech_n = n;
                        params.tech_x = x;
                        params.tech_y = y;
                        params.tech_k = k;
                        params.tech_z = 0;
                        params.tech_c = 0;
                        params.tech_d = 0;
                        params.tech_m = 0;
                        params.tech_u = 0;
                      } else {
                        params.error = "k cannot be 0.";
                        return params;
                      }
                    } else {
                      params.error = "y cannot be negative.";
                      return params;
                    }
                  } else {
                    params.error =
                      "Are you sure about x being 0? Why don't we input something different?";
                    return params;
                  }
                } else {
                  params.error = "n cannot be smaller than 2.";
                  return params;
                }
              } else {
                params.error = "b cannot be negative.";
                return params;
              }
            } else {
              params.error =
                "Are you sure about a being 0? Why don't we input something different?";
              return params;
            }
          } else {
            params.error = "Please! Check Your Input.";
            return params;
          }
        } else if (operations == "2") {
          if ([a, b, n, c, d, m, x, y, k].every((val) => !isNaN(val))) {
            params.tech_operations = operations;
            params.tech_type = type;
            params.tech_a = a;
            params.tech_b = b;
            params.tech_n = n;
            params.tech_x = x;
            params.tech_y = y;
            params.tech_k = k;
            params.tech_z = 0;
            params.tech_c = c;
            params.tech_d = d;
            params.tech_m = m;
            params.tech_u = 0;
          } else {
            params.error = "Please! Check Your Input.";
            return params;
          }
        } else if (operations == "3") {
          if ([a, b, x, y, k, u].every((val) => !isNaN(val))) {
            params.tech_operations = operations;
            params.tech_type = type;
            params.tech_a = a;
            params.tech_b = b;
            params.tech_n = 1;
            params.tech_x = x;
            params.tech_y = y;
            params.tech_k = 1;
            params.tech_z = k;
            params.tech_c = 1;
            params.tech_d = 1;
            params.tech_m = 1;
            params.tech_u = u;
          } else {
            params.error = "Please! Check Your Input.";
            return params;
          }
        } else if (operations == "4") {
          if ([a, b, d, x, y, k, u, c].every((val) => !isNaN(val))) {
            params.tech_operations = operations;
            params.tech_type = type;
            params.tech_a = a;
            params.tech_b = b;
            params.tech_n = 1;
            params.tech_x = x;
            params.tech_y = y;
            params.tech_k = 1;
            params.tech_z = k;
            params.tech_c = c;
            params.tech_d = d;
            params.tech_m = 1;
            params.tech_u = u;
          } else {
            params.error = "Please! Check Your Input.";
            return params;
          }
        }
      } else if (type === "second") {
        console.log("Processing second type with n1:", n1, "d1:", d1);

        // Input validation
        if (!n1 || !d1 || typeof n1 !== "string" || typeof d1 !== "string") {
          // console.log('n1 or d1 missing or not strings');
          params.error = "Please! Check Your Input. n1 and d1 are required.";
          return params;
        }

        // Security validation - modified to allow = sign
        const dangerousPattern =
          /<|>|&|php|print_r|print|echo|script|%|eval|exec|system|command/i;

        // console.log('Security check - n1:', dangerousPattern.test(n1), 'd1:', dangerousPattern.test(d1));

        if (dangerousPattern.test(n1) || dangerousPattern.test(d1)) {
          // console.log('Dangerous pattern detected');
          params.error =
            "Please! Check Your Input. Invalid characters detected.";
          return params;
        }

        // Process the equations
        let xeq = n1
          .replace(/ /g, "")
          .replace(/\+/g, "plus")
          .replace(/{/g, "(")
          .replace(/}/g, ")")
          .replace(/xe\^/g, "x*e^")
          .replace(/ye\^/g, "y*e^")
          .replace(/e\^/g, "exp")
          .replace(/exp\^/g, "exp")
          .replace(/\^/g, "**")
          .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

        let yeq = d1
          .replace(/ /g, "")
          .replace(/\+/g, "plus")
          .replace(/{/g, "(")
          .replace(/}/g, ")")
          .replace(/xe\^/g, "x*e^")
          .replace(/ye\^/g, "y*e^")
          .replace(/e\^/g, "exp")
          .replace(/exp\^/g, "exp")
          .replace(/\^/g, "**")
          .replace(/e\^sqrt\(x\)/g, "exp(2*x)");

        // console.log('Processed xeq:', xeq);
        // console.log('Processed yeq:', yeq);

        try {
          // console.log('Making API call...');
          const response = await axios.post(
            "http://167.172.134.148/rationalize",
            {
              xeq: xeq,
              yeq: yeq,
            },
            {
              timeout: 120000,
              headers: {
                "Content-Type": "application/x-www-form-urlencoded",
              },
            }
          );

          // console.log('API response status:', response.status);
          // console.log('API response data:', response.data);

          if (response.data && typeof response.data === "string") {
            const buffer = response.data.split("@@@");
            if (buffer.length >= 5) {
              params.tech_enter = buffer[0];
              params.tech_up = buffer[1];
              params.tech_ress = buffer[2];
              params.tech_down = buffer[3];
              params.tech_main_ans = buffer[4];
            } else {
              params.error = "Invalid response format from API.";
              return params;
            }
          } else {
            params.error = "Invalid response from API.";
            return params;
          }
        } catch (error) {
          // console.log('API call error:', error.message);
          if (error.response) {
            // console.log('API response error:', error.response.status, error.response.data);
          }
          params.error =
            "Please! Check Your Input. API call failed: " + error.message;
          return params;
        }
      }

      params.tech_type = type;
      return params;
    } catch (error) {
      const errorParams = {};
      errorParams.error = "Please! Check Your Input.";
      return errorParams;
    }
  }

  /** getCalculationDecimalCalculator
   * POST: /api/calculators-lol/decimal-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDecimalCalculator(body) {
    let method = body.tech_method;
    let rounding = body.tech_rounding;
    let a = body.tech_a;
    let b = body.tech_b;

    let result = {};

    if (isNumeric(a) && isNumeric(b)) {
      a = parseFloat(a);
      b = parseFloat(b);
      let ans;
      let res = "";

      switch (method) {
        case "1":
          ans = a + b;
          res = `<p class='mt-2'>a + b = ?</p> <p class='mt-2'>${a} + ${b} = ${ans}</p>`;
          break;
        case "2":
          ans = a - b;
          res = `<p class='mt-2'>a - b = ?</p> <p class='mt-2'>${a} - ${b} = ${ans}</p>`;
          break;
        case "3":
          ans = a * b;
          res = `<p class='mt-2'>a x b = ?</p> <p class='mt-2'>${a} x ${b} = ${ans}</p>`;
          break;
        case "4":
          ans = a / b;
          res = `<p class='mt-2'>a ÷ b = ?</p> <p class='mt-2'>${a} ÷ ${b} = ${ans}</p>`;
          break;
        case "5":
          // Optional decimal adjustment logic (preserved for parity with PHP)
          ans = Math.pow(a, b);
          res = `a<sup class='font-s-14'>b</sup> = ?`;
          break;
        case "6":
          ans = Math.pow(a, 1 / b);
          res = `<sup class='font-s-14'>b</sup>√a = ?`;
          break;
        case "7":
          ans = Math.log(b) / Math.log(a);
          res = `log<sub class='font-s-14'>a</sub>b = ?`;
          break;
        default:
          return { error: "Invalid method selected." };
      }

      if (rounding !== "not" && isNumeric(rounding)) {
        result.round_ans = parseFloat(ans.toFixed(parseInt(rounding)));
      }

      result.tech_ans = ans;
      result.tech_res = res;
      return result;
    } else {
      return { error: "Please! Check Your Input." };
    }

    function isNumeric(val) {
      return !isNaN(parseFloat(val)) && isFinite(val);
    }
  }

  /**
   * getCalculationSurfaceAreaCalculator: Service Method
   * POST: /api/calculators-lol/surface-area-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSurfaceAreaCalculator(body) {
    const params = {};

    try {
      let operations = body.tech_operations;
      let shape = body.tech_shape;
      let first = body.tech_first;
      let second = body.tech_second;
      let third = body.tech_third;
      let four = body.tech_four;
      let pi = body.tech_pi;
      let unit1 = body.tech_unit1;
      let unit2 = body.tech_unit2;
      let unit3 = body.tech_unit3;
      let unit4 = body.tech_unit4;

      // Unit conversion function
      const calculation = (a, b) => {
        if (!a || !b) return 0;

        if (b == "cm") {
          return parseFloat(a);
        } else if (b == "mm") {
          return parseFloat(a) / 10;
        } else if (b == "m") {
          return parseFloat(a) * 100;
        } else if (b == "in") {
          return parseFloat(a) * 2.54;
        } else if (b == "ft") {
          return parseFloat(a) * 30.48;
        } else if (b == "yd") {
          return parseFloat(a) * 91.44;
        }
        return parseFloat(a);
      };

      // Convert units
      const firstVal = calculation(first, unit1);
      const secondVal = calculation(second, unit2);
      const thirdVal = calculation(third, unit3);
      const fourVal = calculation(four, unit4);

      // Validate numeric inputs
      const isNumeric = (val) => !isNaN(parseFloat(val)) && isFinite(val);

      if (operations == "1") {
        if (isNumeric(firstVal) && isNumeric(secondVal) && isNumeric(pi)) {
          const ttsa =
            2 * parseFloat(pi) * firstVal * (2 * firstVal + secondVal);
          params.tech_ttsa = isNaN(ttsa) ? "NAN" : ttsa;
        } else {
          params.error = "Please check your input";
          return params;
        }
      } else if (operations == "2") {
        if (isNumeric(firstVal) && isNumeric(secondVal) && isNumeric(pi)) {
          const s = Math.pow(firstVal, 2) + Math.pow(secondVal, 2);
          const s_sqrt = Math.sqrt(s);
          const lsa = parseFloat(pi) * firstVal * s_sqrt;
          const bsa = parseFloat(pi) * Math.pow(firstVal, 2);
          const ttsa = parseFloat(pi) * firstVal * (firstVal + s_sqrt);
          params.tech_lsa = isNaN(lsa) ? "NAN" : lsa;
          params.tech_bsa = isNaN(bsa) ? "NAN" : bsa;
          params.tech_ttsa = isNaN(ttsa) ? "NAN" : ttsa;
        } else {
          params.error = "Please check your input";
          return params;
        }
      } else if (operations == "3") {
        if (
          isNumeric(firstVal) &&
          isNumeric(secondVal) &&
          isNumeric(thirdVal) &&
          isNumeric(pi)
        ) {
          const top = parseFloat(pi) * Math.pow(firstVal, 2);
          const bsa = parseFloat(pi) * Math.pow(secondVal, 2);
          const s = Math.pow(firstVal - secondVal, 2) + Math.pow(thirdVal, 2);
          const s_sqrt = Math.sqrt(s);
          const ttsa =
            parseFloat(pi) *
            (Math.pow(firstVal, 2) +
              Math.pow(secondVal, 2) +
              firstVal * secondVal * s_sqrt);
          const lsa = parseFloat(pi) * (firstVal + secondVal) * s_sqrt;
          params.tech_top = isNaN(top) ? "NAN" : top;
          params.tech_bsa = isNaN(bsa) ? "NAN" : bsa;
          params.tech_ttsa = isNaN(ttsa) ? "NAN" : ttsa;
          params.tech_lsa = isNaN(lsa) ? "NAN" : lsa;
        } else {
          params.error = "Please check your input";
          return params;
        }
      } else if (operations == "4") {
        if (isNumeric(firstVal)) {
          const bsa = Math.pow(firstVal, 2);
          const top = Math.pow(firstVal, 2);
          const lsa = 4 * Math.pow(firstVal, 2);
          const ttsa = 6 * bsa;
          params.tech_top = isNaN(top) ? "NAN" : top;
          params.tech_bsa = isNaN(bsa) ? "NAN" : bsa;
          params.tech_ttsa = isNaN(ttsa) ? "NAN" : ttsa;
          params.tech_lsa = isNaN(lsa) ? "NAN" : lsa;
        } else {
          params.error = "Please check your input";
          return params;
        }
      } else if (operations == "5") {
        if (isNumeric(firstVal) && isNumeric(secondVal) && isNumeric(pi)) {
          const top = parseFloat(pi) * Math.pow(firstVal, 2);
          const bsa = parseFloat(pi) * Math.pow(firstVal, 2);
          const ttsa = 2 * parseFloat(pi) * firstVal * (secondVal + firstVal);
          const lsa = ttsa - (top + bsa);
          params.tech_top = isNaN(top) ? "NAN" : top;
          params.tech_bsa = isNaN(bsa) ? "NAN" : bsa;
          params.tech_ttsa = isNaN(ttsa) ? "NAN" : ttsa;
          params.tech_lsa = isNaN(lsa) ? "NAN" : lsa;
        } else {
          params.error = "Please check your input";
          return params;
        }
      } else if (operations == "6") {
        if (isNumeric(firstVal) && isNumeric(pi)) {
          const csa = 2 * parseFloat(pi) * Math.pow(firstVal, 2);
          const bsa = parseFloat(pi) * Math.pow(firstVal, 2);
          const ttsa = 3 * parseFloat(pi) * Math.pow(firstVal, 2);
          params.tech_bsa = isNaN(bsa) ? "NAN" : bsa;
          params.tech_ttsa = isNaN(ttsa) ? "NAN" : ttsa;
          params.tech_csa = isNaN(csa) ? "NAN" : csa;
        } else {
          params.error = "Please check your input";
          return params;
        }
      } else if (operations == "7") {
        if (
          isNumeric(firstVal) &&
          isNumeric(secondVal) &&
          isNumeric(thirdVal)
        ) {
          const bsa = firstVal * secondVal;
          const top = thirdVal * firstVal;
          const top2 = thirdVal * secondVal;
          const ttsa = 2 * (bsa + top + top2);
          const lsa = ttsa - (bsa + top);
          params.tech_top = isNaN(top) ? "NAN" : top;
          params.tech_bsa = isNaN(bsa) ? "NAN" : bsa;
          params.tech_ttsa = isNaN(ttsa) ? "NAN" : ttsa;
          params.tech_lsa = isNaN(lsa) ? "NAN" : lsa;
        } else {
          params.error = "Please check your input";
          return params;
        }
      } else if (operations == "8") {
        if (isNumeric(firstVal) && isNumeric(pi)) {
          const ttsa = 4 * parseFloat(pi) * Math.pow(firstVal, 2);
          params.tech_ttsa = isNaN(ttsa) ? "NAN" : ttsa;
        } else {
          params.error = "Please check your input";
          return params;
        }
      } else if (operations == "9") {
        if (isNumeric(firstVal) && isNumeric(secondVal) && isNumeric(pi)) {
          const csa = 2 * parseFloat(pi) * firstVal * secondVal;
          params.tech_csa = isNaN(csa) ? "NAN" : ttsa;
        } else {
          params.error = "Please check your input";
          return params;
        }
      } else if (operations == "10") {
        if (
          isNumeric(firstVal) &&
          isNumeric(secondVal) &&
          isNumeric(thirdVal) &&
          isNumeric(fourVal)
        ) {
          const add = secondVal + thirdVal;
          if (firstVal >= add) {
            params.error =
              "The sum of sides b and c must be greater than side a to form a triangle";
            return params;
          }
          const top_sq =
            (firstVal + secondVal + thirdVal) *
            (secondVal + thirdVal - firstVal) *
            (thirdVal + firstVal - secondVal) *
            (firstVal + secondVal - thirdVal);
          const top = (1 / 4) * Math.sqrt(top_sq);
          const bsa = top;
          const lsa = fourVal * (firstVal + secondVal + thirdVal);
          const ttsa = top + bsa + lsa;
          params.tech_top = isNaN(top) ? "NAN" : top;
          params.tech_bsa = isNaN(bsa) ? "NAN" : bsa;
          params.tech_ttsa = isNaN(ttsa) ? "NAN" : ttsa;
          params.tech_lsa = isNaN(lsa) ? "NAN" : lsa;
        } else {
          params.error = "Please check your input";
          return params;
        }
      } else if (operations == "11") {
        if (shape == 1) {
          if (isNumeric(firstVal) && isNumeric(secondVal)) {
            const height = 0.866 * firstVal;
            const bsa = (Math.pow(firstVal, 2) * Math.sqrt(3)) / 4;
            const lsa = 1.5 * firstVal * secondVal;
            const ttsa = bsa + lsa;
            params.tech_height = isNaN(height) ? "NAN" : height;
            params.tech_bsa = isNaN(bsa) ? "NAN" : bsa;
            params.tech_lsa = isNaN(lsa) ? "NAN" : lsa;
            params.tech_ttsa = isNaN(ttsa) ? "NAN" : ttsa;
          } else {
            params.error = "Please check your input";
            return params;
          }
        } else if (shape == 2) {
          if (isNumeric(firstVal) && isNumeric(secondVal)) {
            const f_sql = 4 * Math.pow(secondVal, 2);
            const minus_div = (f_sql - Math.pow(firstVal, 2)) / 4;
            const height = Math.sqrt(minus_div);
            const bsa = Math.pow(firstVal, 2);
            const lsa =
              firstVal *
              Math.sqrt(Math.pow(firstVal, 2) + 4 * Math.pow(height, 2));
            const ttsa = bsa + lsa;
            params.tech_height = isNaN(height) ? "NAN" : height;
            params.tech_bsa = isNaN(bsa) ? "NAN" : bsa;
            params.tech_lsa = isNaN(lsa) ? "NAN" : lsa;
            params.tech_ttsa = isNaN(ttsa) ? "NAN" : ttsa;
          } else {
            params.error = "Please check your input";
            return params;
          }
        } else if (shape == 3) {
          if (
            isNumeric(firstVal) &&
            isNumeric(secondVal) &&
            isNumeric(thirdVal)
          ) {
            const la = Math.sqrt(
              Math.pow(thirdVal, 2) + Math.pow(secondVal, 2) / 4
            );
            const lb = Math.sqrt(
              Math.pow(thirdVal, 2) + Math.pow(firstVal, 2) / 4
            );
            const bsa = firstVal * secondVal;
            const lsa = firstVal * la + secondVal * lb;
            const ttsa = bsa + lsa;
            params.tech_bsa = isNaN(bsa) ? "NAN" : bsa;
            params.tech_lsa = isNaN(lsa) ? "NAN" : lsa;
            params.tech_ttsa = isNaN(ttsa) ? "NAN" : ttsa;
          } else {
            params.error = "Please check your input";
            return params;
          }
        } else if (shape == 4) {
          if (isNumeric(firstVal) && isNumeric(secondVal)) {
            const height = Math.sqrt(
              Math.pow(secondVal, 2) - (6.25 * Math.pow(firstVal, 2)) / 13.1769
            );
            const bsa = 1.7222 * Math.pow(firstVal, 2);
            const lsa =
              2.5 *
              firstVal *
              Math.sqrt(0.474 * Math.pow(firstVal, 2) + Math.pow(height, 2));
            const ttsa = bsa + lsa;
            params.tech_height = isNaN(height) ? "NAN" : height;
            params.tech_bsa = isNaN(bsa) ? "NAN" : bsa;
            params.tech_lsa = isNaN(lsa) ? "NAN" : lsa;
            params.tech_ttsa = isNaN(ttsa) ? "NAN" : ttsa;
          } else {
            params.error = "Please check your input";
            return params;
          }
        } else if (shape == 5) {
          if (isNumeric(firstVal) && isNumeric(secondVal)) {
            const height = Math.sqrt(
              Math.pow(secondVal, 2) - (3 * Math.pow(firstVal, 2)) / 4
            );
            const bsa = 2.5981 * Math.pow(firstVal, 2);
            const lsa =
              3 *
              firstVal *
              Math.sqrt(Math.pow(height, 2) + (3 * Math.pow(firstVal, 2)) / 4);
            const ttsa = bsa + lsa;
            params.tech_height = isNaN(height) ? "NAN" : height;
            params.tech_bsa = isNaN(bsa) ? "NAN" : bsa;
            params.tech_lsa = isNaN(lsa) ? "NAN" : lsa;
            params.tech_ttsa = isNaN(ttsa) ? "NAN" : ttsa;
          } else {
            params.error = "Please check your input";
            return params;
          }
        }
      } else if (operations == "12") {
        if (isNumeric(firstVal)) {
          const ttsa = 4 * 3.141593 * Math.pow(firstVal, 2);
          params.tech_ttsa = isNaN(ttsa) ? "NAN" : ttsa;
        } else {
          params.error = "Please check your input";
          return params;
        }
      } else if (operations == "13") {
        if (isNumeric(firstVal) && isNumeric(secondVal) && isNumeric(fourVal)) {
          const f_mul = Math.pow(firstVal * secondVal, 1.6);
          const s_mul = Math.pow(firstVal * fourVal, 1.6);
          const t_mul = Math.pow(secondVal * fourVal, 1.6);
          const divide = (f_mul + s_mul + t_mul) / 3;
          const ttsa = 4 * 3.141593 * Math.pow(divide, 0.625);
          params.tech_ttsa = isNaN(ttsa) ? "NAN" : ttsa;
        } else {
          params.error = "Please check your input";
          return params;
        }
      } else {
        params.error = "Invalid operation specified";
        return params;
      }

      return params;
    } catch (error) {
      console.log("Surface area calculation error:", error.message);
      const errorParams = {};
      errorParams.error = "Please check your input. Error: " + error.message;
      return errorParams;
    }
  }

  /**
   * getCalculationLengthOfCurveCalculator: Service Method
   * POST: /api/calculators-lol/length-of-curve-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLengthOfCurveCalculator(body) {
    let cal = body.tech_cal;
    let func = body.tech_func;
    let func1 = body.tech_func1;
    let func2 = body.tech_func2;
    let lower = body.tech_lower;
    let upper = body.tech_upper;

    if (!lower || !upper) {
      return { error: "Please! Check Your Input." };
    }

    // Input validation function
    const validateInput = (input) => {
      const dangerousPatterns = /<|>|&|php|print_r|print|echo|script|=|&|%/i;
      return !dangerousPatterns.test(input);
    };

    // Parameter processing function
    const processParam = (param) => {
      return param
        .replace(/ /g, "")
        .replace(/\+/g, "plus")
        .replace(/%20/g, "")
        .replace(/{/g, "(")
        .replace(/}/g, ")")
        .replace(/e\^/g, "exp")
        .replace(/exp\^/g, "exp")
        .replace(/\^/g, "**")
        .replace(/e\^sqrt\(x\)/g, "exp(2*x)");
    };

    try {
      if (cal == "y" && func) {
        if (!validateInput(func)) {
          return { error: "Please! Check Your Input." };
        }

        const parem = processParam(func);
        const check = "y";

        const response = await fetch("http://167.172.134.148/length", {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
          },
          body: new URLSearchParams({
            equ: parem,
            check: check,
          }),
          timeout: 120000,
        });

        const buffer = await response.text();
        const bufferArray = buffer.split("@@@");

        return {
          tech_enter: bufferArray[0],
          tech_diff: bufferArray[1],
          tech_lower: lower,
          tech_upper: upper,
        };
      } else if (cal == "x" && func) {
        if (!validateInput(func)) {
          return { error: "Please! Check Your Input." };
        }

        const parem = processParam(func);
        const check = "x";

        const response = await fetch("http://167.172.134.148/length", {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
          },
          body: new URLSearchParams({
            equ: parem,
            check: check,
          }),
          timeout: 120000,
        });

        const buffer = await response.text();
        const bufferArray = buffer.split("@@@");

        return {
          tech_enter: bufferArray[0],
          tech_diff: bufferArray[1],
          tech_lower: lower,
          tech_upper: upper,
        };
      } else if (cal == "xy" && func && func1) {
        if (!validateInput(func) || !validateInput(func1)) {
          return { error: "Please! Check Your Input." };
        }

        const parem = processParam(func);
        const parem1 = processParam(func1);
        const check = "xy";

        const response = await fetch("http://167.172.134.148/length", {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
          },
          body: new URLSearchParams({
            equ: parem,
            check: check,
            equ1: parem1,
          }),
          timeout: 120000,
        });

        const buffer = await response.text();
        const bufferArray = buffer.split("@@@");

        return {
          tech_enter: bufferArray[0],
          tech_enter1: bufferArray[1],
          tech_diff: bufferArray[2],
          tech_diff1: bufferArray[3],
          tech_lower: lower,
          tech_upper: upper,
        };
      } else if (cal == "r" && func) {
        if (!validateInput(func)) {
          return { error: "Please! Check Your Input." };
        }

        const parem = processParam(func).replace(/plus/g, "+");
        const check = "r";

        const response = await fetch("http://167.172.134.148/length", {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
          },
          body: new URLSearchParams({
            equ: parem,
            check: check,
          }),
          timeout: 120000,
        });

        const buffer = await response.text();
        const bufferArray = buffer.split("@@@");

        return {
          tech_enter: bufferArray[0],
          tech_diff: bufferArray[1],
          tech_lower: lower,
          tech_upper: upper,
        };
      } else if (cal == "xyz" && func && func1 && func2) {
        if (
          !validateInput(func) ||
          !validateInput(func1) ||
          !validateInput(func2)
        ) {
          return { error: "Please! Check Your Input." };
        }

        const parem = processParam(func);
        const parem1 = processParam(func1);
        const parem2 = processParam(func2);
        const check = "xyz";

        const response = await fetch("http://167.172.134.148/length", {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
          },
          body: new URLSearchParams({
            equ: parem,
            check: check,
            equ1: parem1,
            equ2: parem2,
          }),
          timeout: 120000,
        });

        const buffer = await response.text();
        const bufferArray = buffer.split("@@@");

        return {
          tech_enter: bufferArray[0],
          tech_enter1: bufferArray[1],
          tech_enter2: bufferArray[2],
          tech_diff: bufferArray[3],
          tech_diff1: bufferArray[4],
          tech_diff2: bufferArray[5],
          tech_lower: lower,
          tech_upper: upper,
        };
      } else {
        return { error: "Please! Check Your Input." };
      }
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }
  }

  /**
   * getCalculationDiagonalCalculator: Service Method
   * POST: /api/calculators-lol/diagonal-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDiagonalCalculator(body) {
    let given = body.tech_given;
    let ls = body.tech_ls;
    let ls_unit = body.tech_ls_unit;
    let ss = body.tech_ss;
    let ss_unit = body.tech_ss_unit;
    let perimeter = body.tech_perimeter;
    let perimeter_unit = body.tech_perimeter_unit;
    let area = body.tech_area;
    let area_unit = body.tech_area_unit;
    let angle = body.tech_angle;
    let angle_unit = body.tech_angle_unit;
    let circum = body.tech_circum;
    let circum_unit = body.tech_circum_unit;

    // Unit conversion functions
    const myunitConvert = (unit, value) => {
      const conversions = {
        mm: value * 0.1,
        cm: value * 1,
        m: value * 100,
        km: value * 1000,
        in: value * 2.54,
        ft: value * 30.48,
        yd: value * 91.44,
        mi: value * 160934,
      };
      return conversions[unit] || value;
    };

    const centimeter = (unit3, value3) => {
      const conversions = {
        "mm²": value3 * 0.01,
        "cm²": value3 * 1,
        "m²": value3 * 10000,
        "km²": value3 * 10000000000,
        "in²": value3 * 6.452,
        "ft²": value3 * 929,
        "yd²": value3 * 8361,
        "mi²": value3 * 25899881103,
        a: value3 * 1000000,
        da: value3 * 10000000,
        ha: value3 * 100000000,
        ac: value3 * 40468560,
      };
      return conversions[unit3] || value3;
    };

    const deg2rad = (degrees) => {
      return degrees * (Math.PI / 180);
    };

    // Initialize variables
    let lsv, ssv, areaResult, perimeterResult, diagonal, angle_α, radius;

    try {
      if (given == "1") {
        // Longer Side and Shorter Side
        if (isNumeric(ls) && isNumeric(ss)) {
          lsv = myunitConvert(ls_unit, ls);
          ssv = myunitConvert(ss_unit, ss);
          // console.log(lsv,ssv);
          if (ls > ss) {
            areaResult = lsv * ssv;
            perimeterResult = 2 * ss + 2 * lsv;
            diagonal = Math.sqrt(lsv * lsv + ssv * ssv);
            radius = diagonal / 2;
            const δ = Math.atan(ssv / lsv);
            angle_α = Math.PI - 2 * δ;
            lsv = "";
            ssv = "";
            // console.log(perimeterResult,ssv,lsv);
          } else {
            return {
              error: "Please! Longer side should be greater than shorter side.",
            };
          }
        } else {
          return { error: "Please! Check Your Input." };
        }
      } else if (given == "2") {
        // Longer Side and Area
        if (isNumeric(ls) && isNumeric(area)) {
          lsv = myunitConvert(ls_unit, ls);
          const av = centimeter(area_unit, area);
          ssv = av / lsv;
          perimeterResult = 2 * ssv + 2 * lsv;
          const δ = Math.atan(ssv / lsv);
          angle_α = Math.PI - 2 * δ;
          diagonal = Math.sqrt(lsv * lsv + ssv * ssv);
          radius = diagonal / 2;
          lsv = "";
          areaResult = "";
        } else {
          return { error: "Please! Check Your Input." };
        }
      } else if (given == "3") {
        // Longer Side and Perimeter
        if (isNumeric(ls) && isNumeric(perimeter)) {
          if (ls * 2 + 1 <= perimeter) {
            lsv = myunitConvert(ls_unit, ls);
            const pv = myunitConvert(perimeter_unit, perimeter);
            ssv = (pv - 2 * lsv) / 2;
            areaResult = lsv * ssv;
            const δ = Math.atan(ssv / lsv);
            angle_α = Math.PI - 2 * δ;
            diagonal = Math.sqrt(lsv * lsv + ssv * ssv);
            radius = diagonal / 2;
            lsv = "";
            perimeterResult = "";
          } else {
            return { error: "Perimeter is too small." };
          }
        } else {
          return { error: "Please! Check Your Input." };
        }
      } else if (given == "4") {
        // Longer Side and Angle alpha
        if (isNumeric(ls) && isNumeric(angle)) {
          if (angle <= 90) {
            return {
              error: "Angle between diagonals must be greater than 90°.",
            };
          } else {
            lsv = myunitConvert(ls_unit, ls);
            let angle_α_temp;

            if (angle_unit == "deg") {
              angle_α_temp = 1 * angle;
            } else if (angle_unit == "rad") {
              angle_α_temp = 57.3 * angle;
            } else if (angle_unit == "gon") {
              angle_α_temp = 0.9 * angle;
            } else {
              angle_α_temp = 180 * angle;
            }

            angle_α_temp = angle_α_temp / 2;
            ssv = lsv / Math.tan(deg2rad(angle_α_temp));
            areaResult = lsv * ssv;
            perimeterResult = 2 * ssv + 2 * lsv;
            diagonal = Math.sqrt(lsv * lsv + ssv * ssv);
            radius = diagonal / 2;
            lsv = "";
            angle_α = "";
          }
        } else {
          return { error: "Please! Check Your Input." };
        }
      } else if (given == "5") {
        // Shorter Side and Area
        if (isNumeric(ss) && isNumeric(area)) {
          ssv = myunitConvert(ss_unit, ss);
          const av = centimeter(area_unit, area);
          lsv = av / ssv;
          perimeterResult = 2 * ssv + 2 * lsv;
          const δ = Math.atan(ssv / lsv);
          angle_α = Math.PI - 2 * δ;
          diagonal = Math.sqrt(lsv * lsv + ssv * ssv);
          radius = diagonal / 2;
          ssv = "";
          areaResult = "";
        } else {
          return { error: "Please! Check Your Input." };
        }
      } else if (given == "6") {
        // Shorter Side and Perimeter
        if (isNumeric(ss) && isNumeric(perimeter)) {
          if (perimeter >= ss * 4) {
            ssv = myunitConvert(ss_unit, ss);
            const pv = myunitConvert(perimeter_unit, perimeter);
            lsv = (pv - 2 * ssv) / 2;
            areaResult = lsv * ssv;
            perimeterResult = 2 * ss + 2 * lsv;
            diagonal = Math.sqrt(lsv * lsv + ssv * ssv);
            radius = diagonal / 2;
            const δ = Math.atan(ssv / lsv);
            angle_α = Math.PI - 2 * δ;
            ssv = "";
            perimeterResult = "";
          } else {
            return { error: "Perimeter is too small." };
          }
        } else {
          return { error: "Please! Check Your Input." };
        }
      } else if (given == "7") {
        // Shorter Side and Angle
        if (isNumeric(ss) && isNumeric(angle)) {
          ssv = myunitConvert(ss_unit, ss);
          let angle_α_temp;

          if (angle_unit == "deg") {
            angle_α_temp = 1 * angle;
          } else if (angle_unit == "rad") {
            angle_α_temp = 57.3 * angle;
          } else if (angle_unit == "gon") {
            angle_α_temp = 0.9 * angle;
          } else {
            angle_α_temp = 180 * angle;
          }

          angle_α_temp = angle_α_temp / 2;
          lsv = ssv * Math.tan(deg2rad(angle_α_temp));
          areaResult = lsv * ssv;
          perimeterResult = 2 * ssv + 2 * lsv;
          diagonal = Math.sqrt(lsv * lsv + ssv * ssv);
          radius = diagonal / 2;
          ssv = "";
          angle_α = "";
        } else {
          return { error: "Please! Check Your Input." };
        }
      } else if (given == "8") {
        // Circumference
        if (isNumeric(circum)) {
          const circumValue = myunitConvert(circum_unit, circum);
          diagonal = circumValue * 2;
          ssv = "";
          lsv = "";
          areaResult = "";
          radius = "";
          perimeterResult = "";
          angle_α = "";
        }
      } else {
        return { error: "Please! Check Your Input." };
      }

      return {
        tech_lsv: lsv || "",
        tech_ssv: ssv || "",
        tech_area: areaResult || "",
        tech_perimeter: perimeterResult || "",
        tech_diagonal: diagonal || "",
        tech_angle_α: angle_α || "",
        tech_radius: radius || "",
      };
    } catch (error) {
      return { error: "Please! Check Your Input." };
    }

    // Helper function to check if value is numeric
    function isNumeric(value) {
      return !isNaN(parseFloat(value)) && isFinite(value);
    }
  }

  /**
   * getCalculationRationalZerosCalculator: Service Method
   * POST: /api/calculators-lol/rational-zeros-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationRationalZerosCalculator(body) {
    let v1 = body.tech_v1;
    let v2 = body.tech_v2;
    let v3 = body.tech_v3;
    let v4 = body.tech_v4;
    let v5 = body.tech_v5;
    let v6 = body.tech_v6;
    let v7 = body.tech_v7;
    let v8 = body.tech_v8;
    let v9 = body.tech_v9;
    let v10 = body.tech_v10;
    let no_of = body.tech_no_of;

    // Helper function to check if value is numeric
    const isNumeric = (value) => {
      return !isNaN(parseFloat(value)) && isFinite(value);
    };

    // Function to get divisors
    const printDivisors = (n) => {
      const divi = [];
      const absN = Math.abs(n);
      for (let i = 1; i <= absN; i++) {
        if (absN % i == 0) {
          divi.push(i);
        }
      }
      return divi;
    };

    // Validate all inputs are numeric
    const allNumeric = [v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, no_of].every(
      isNumeric
    );

    if (!allNumeric) {
      return { error: "Please! Check Your Input." };
    }

    try {
      let q = parseFloat(v1);
      let p;

      // Determine p based on no_of
      switch (parseInt(no_of)) {
        case 2:
          p = parseFloat(v3);
          break;
        case 3:
          p = parseFloat(v4);
          break;
        case 4:
          p = parseFloat(v5);
          break;
        case 5:
          p = parseFloat(v6);
          break;
        case 6:
          p = parseFloat(v7);
          break;
        case 7:
          p = parseFloat(v8);
          break;
        case 8:
          p = parseFloat(v9);
          break;
        case 9:
          p = parseFloat(v10);
          break;
        default:
          return { error: "Please! Check Your Input." };
      }

      // Make p positive for divisor calculation
      const pAbs = Math.abs(p);

      const array_p = printDivisors(pAbs);
      const new_times = array_p.map((value) => -1 * value);
      const array_q = printDivisors(q);
      const new_times2 = array_q.map((value) => value * -1);

      const final_p = [...array_p, ...new_times];
      const final_q = [...array_q, ...new_times2];

      const ans = [];
      const main_ans = [];
      const main_ans2 = [];
      const main_ans3 = [];

      // YAHAN PAR MAIN FIX HAI - PHP logic ke according calculation
      for (let i = 0; i < final_q.length; i++) {
        if (final_q[i] !== 1) {
          for (const value of final_p) {
            const calculatedValue = value / final_q[i];

            if (value % final_q[i] === 0) {
              ans.push(calculatedValue);
            } else {
              ans.push(`\\frac{${value}}{${final_q[i]}}`);
            }
            main_ans.push(`\\frac{${value}}{${final_q[i]}}`);
            main_ans2.push(calculatedValue);
            main_ans3.push(`${value} / ${final_q[i]}`);
          }
        }
      }

      // Get unique values - PHP ke jaisa filter karna
      const uq = [...new Set(ans)].filter(
        (val) => val !== null && val !== undefined && val !== ""
      );

      // Format polynomial coefficients
      const formatCoefficient = (val, isFirst = false) => {
        const numVal = parseFloat(val);
        if (isFirst) {
          return numVal !== 1 ? numVal : "";
        }
        return numVal >= 0 ? ` +${numVal}` : ` ${numVal}`;
      };

      const s1 = formatCoefficient(v1, true);
      const s2 = formatCoefficient(v2);
      const s3 = formatCoefficient(v3);
      const s4 = formatCoefficient(v4);
      const s5 = formatCoefficient(v5);
      const s6 = formatCoefficient(v6);
      const s7 = formatCoefficient(v7);
      const s8 = formatCoefficient(v8);
      const s9 = formatCoefficient(v9);
      const s10 = formatCoefficient(v10);

      const eq = [];
      const result = [];
      const final_result = [];

      for (let i = 0; i < uq.length; i++) {
        const uqVal = uq[i];
        // YAHAN PAR MAIN FIX HAI - sahi value use karo
        const mainAns2Val = main_ans2[i];

        switch (parseInt(no_of)) {
          case 2:
            eq.push(`\\( \\text{P}{\\left(x\\right)}=${s1}x^{2}${s2}x${s3}\\)`);
            result.push(
              `\\( \\text{P}{\\left(${uqVal}\\right)}=\\left(${v1}\\right)\\left(${uqVal}\\right)^{2}+\\left(${v2}\\right)\\left(${uqVal}\\right)+${v3}\\)`
            );
            // YAHAN PAR CALCULATION FIX KARO
            const polyValue2 =
              parseFloat(v1) * Math.pow(mainAns2Val, 2) +
              parseFloat(v2) * mainAns2Val +
              parseFloat(v3);
            final_result.push(polyValue2);
            break;
          case 3:
            eq.push(
              `\\( \\text{P}{\\left(x\\right)}=${s1}x^{3}${s2}x^{2}${s3}x${s4}\\)`
            );
            result.push(
              `\\( \\text{P}{\\left(${uqVal}\\right)}=\\left(${v1}\\right)\\left(${uqVal}\\right)^{3}+\\left(${v2}\\right)\\left(${uqVal}\\right)^{2}+\\left(${v3}\\right)\\left(${uqVal}\\right)+${v4}\\)`
            );
            const polyValue3 =
              parseFloat(v1) * Math.pow(mainAns2Val, 3) +
              parseFloat(v2) * Math.pow(mainAns2Val, 2) +
              parseFloat(v3) * mainAns2Val +
              parseFloat(v4);
            final_result.push(polyValue3);
            break;
          case 4:
            eq.push(
              `\\( \\text{P}{\\left(x\\right)}=${s1}x^{4}${s2}x^{3}${s3}x^{2}${s4}x${s5}\\)`
            );
            result.push(
              `\\( \\text{P}{\\left(${uqVal}\\right)}=\\left(${v1}\\right)\\left(${uqVal}\\right)^{4}+\\left(${v2}\\right)\\left(${uqVal}\\right)^{3}+\\left(${v3}\\right)\\left(${uqVal}\\right)^{2}+\\left(${v4}\\right)\\left(${uqVal}\\right)+${v5}\\)`
            );
            const polyValue4 =
              parseFloat(v1) * Math.pow(mainAns2Val, 4) +
              parseFloat(v2) * Math.pow(mainAns2Val, 3) +
              parseFloat(v3) * Math.pow(mainAns2Val, 2) +
              parseFloat(v4) * mainAns2Val +
              parseFloat(v5);
            final_result.push(polyValue4);
            break;
          case 5:
            eq.push(
              `\\( \\text{P}{\\left(x\\right)}=${s1}x^{5}${s2}x^{4}${s3}x^{3}${s4}x^{2}${s5}x${s6}\\)`
            );
            result.push(
              `\\( \\text{P}{\\left(${uqVal}\\right)}=\\left(${v1}\\right)\\left(${uqVal}\\right)^{5}+\\left(${v2}\\right)\\left(${uqVal}\\right)^{4}+\\left(${v3}\\right)\\left(${uqVal}\\right)^{3}+\\left(${v4}\\right)\\left(${uqVal}\\right)^{2}+\\left(${v5}\\right)\\left(${uqVal}\\right)+${v6}\\)`
            );
            const polyValue5 =
              parseFloat(v1) * Math.pow(mainAns2Val, 5) +
              parseFloat(v2) * Math.pow(mainAns2Val, 4) +
              parseFloat(v3) * Math.pow(mainAns2Val, 3) +
              parseFloat(v4) * Math.pow(mainAns2Val, 2) +
              parseFloat(v5) * mainAns2Val +
              parseFloat(v6);
            final_result.push(polyValue5);
            break;
          case 6:
            eq.push(
              `\\( \\text{P}{\\left(x\\right)}=${s1}x^{6}${s2}x^{5}${s3}x^{4}${s4}x^{3}${s5}x^{2}${s6}x${s7}\\)`
            );
            result.push(
              `\\( \\text{P}{\\left(${uqVal}\\right)}=\\left(${v1}\\right)\\left(${uqVal}\\right)^{6}+\\left(${v2}\\right)\\left(${uqVal}\\right)^{5}+\\left(${v3}\\right)\\left(${uqVal}\\right)^{4}+\\left(${v4}\\right)\\left(${uqVal}\\right)^{3}+\\left(${v5}\\right)\\left(${uqVal}\\right)^{2}+\\left(${v6}\\right)\\left(${uqVal}\\right)+${v7}\\)`
            );
            const polyValue6 =
              parseFloat(v1) * Math.pow(mainAns2Val, 6) +
              parseFloat(v2) * Math.pow(mainAns2Val, 5) +
              parseFloat(v3) * Math.pow(mainAns2Val, 4) +
              parseFloat(v4) * Math.pow(mainAns2Val, 3) +
              parseFloat(v5) * Math.pow(mainAns2Val, 2) +
              parseFloat(v6) * mainAns2Val +
              parseFloat(v7);
            final_result.push(polyValue6);
            break;
          case 7:
            eq.push(
              `\\( \\text{P}{\\left(x\\right)}=${s1}x^{7}${s2}x^{6}${s3}x^{5}${s4}x^{4}${s5}x^{3}${s6}x^{2}${s7}x${s8}\\)`
            );
            result.push(
              `\\( \\text{P}{\\left(${uqVal}\\right)}=\\left(${v1}\\right)\\left(${uqVal}\\right)^{7}+\\left(${v2}\\right)\\left(${uqVal}\\right)^{6}+\\left(${v3}\\right)\\left(${uqVal}\\right)^{5}+\\left(${v4}\\right)\\left(${uqVal}\\right)^{4}+\\left(${v5}\\right)\\left(${uqVal}\\right)^{3}+\\left(${v6}\\right)\\left(${uqVal}\\right)^{2}+\\left(${v7}\\right)\\left(${uqVal}\\right)+${v8}\\)`
            );
            const polyValue7 =
              parseFloat(v1) * Math.pow(mainAns2Val, 7) +
              parseFloat(v2) * Math.pow(mainAns2Val, 6) +
              parseFloat(v3) * Math.pow(mainAns2Val, 5) +
              parseFloat(v4) * Math.pow(mainAns2Val, 4) +
              parseFloat(v5) * Math.pow(mainAns2Val, 3) +
              parseFloat(v6) * Math.pow(mainAns2Val, 2) +
              parseFloat(v7) * mainAns2Val +
              parseFloat(v8);
            final_result.push(polyValue7);
            break;
          case 8:
            eq.push(
              `\\( \\text{P}{\\left(x\\right)}=${s1}x^{8}${s2}x^{7}${s3}x^{6}${s4}x^{5}${s5}x^{4}${s6}x^{2}${s7}x^{2}${s8}x${s9}\\)`
            );
            result.push(
              `\\( \\text{P}{\\left(${uqVal}\\right)}=\\left(${v1}\\right)\\left(${uqVal}\\right)^{}+\\left(${v2}\\right)\\left(${uqVal}\\right)^{7}+\\left(${v3}\\right)\\left(${uqVal}\\right)^{6}+\\left(${v4}\\right)\\left(${uqVal}\\right)^{5}+\\left(${v5}\\right)\\left(${uqVal}\\right)^{4}+\\left(${v6}\\right)\\left(${uqVal}\\right)^{3}+\\left(${v7}\\right)\\left(${uqVal}\\right)^{2}+\\left(${v8}\\right)\\left(${uqVal}\\right)+${v9}\\)`
            );
            const polyValue8 =
              parseFloat(v1) * Math.pow(mainAns2Val, 8) +
              parseFloat(v2) * Math.pow(mainAns2Val, 7) +
              parseFloat(v3) * Math.pow(mainAns2Val, 6) +
              parseFloat(v4) * Math.pow(mainAns2Val, 5) +
              parseFloat(v5) * Math.pow(mainAns2Val, 4) +
              parseFloat(v6) * Math.pow(mainAns2Val, 3) +
              parseFloat(v7) * Math.pow(mainAns2Val, 2) +
              parseFloat(v8) * mainAns2Val +
              parseFloat(v9);
            final_result.push(polyValue8);
            break;
          case 9:
            eq.push(
              `\\( \\text{P}{\\left(x\\right)}=${s1}x^{9}${s2}x^{8}${s3}x^{7}${s4}x^{6}${s5}x^{5}${s6}x^{4}${s7}x^{3}${s8}x^{2}${s9}x${s10}\\)`
            );
            result.push(
              `\\( \\text{P}{\\left(${uqVal}\\right)}=\\left(${v1}\\right)\\left(${uqVal}\\right)^{9}+\\left(${v2}\\right)\\left(${uqVal}\\right)^{8}+\\left(${v3}\\right)\\left(${uqVal}\\right)^{7}+\\left(${v4}\\right)\\left(${uqVal}\\right)^{6}+\\left(${v5}\\right)\\left(${uqVal}\\right)^{5}+\\left(${v6}\\right)\\left(${uqVal}\\right)^{4}+\\left(${v7}\\right)\\left(${uqVal}\\right)^{3}+\\left(${v8}\\right)\\left(${uqVal}\\right)^{2}+\\left(${v9}\\right)\\left(${uqVal}\\right)+${v10}\\)`
            );
            const polyValue9 =
              parseFloat(v1) * Math.pow(mainAns2Val, 9) +
              parseFloat(v2) * Math.pow(mainAns2Val, 8) +
              parseFloat(v3) * Math.pow(mainAns2Val, 7) +
              parseFloat(v4) * Math.pow(mainAns2Val, 6) +
              parseFloat(v5) * Math.pow(mainAns2Val, 5) +
              parseFloat(v6) * Math.pow(mainAns2Val, 4) +
              parseFloat(v7) * Math.pow(mainAns2Val, 3) +
              parseFloat(v8) * Math.pow(mainAns2Val, 2) +
              parseFloat(v9) * mainAns2Val +
              parseFloat(v10);
            final_result.push(polyValue9);
            break;
        }
      }

      return {
        tech_v1: parseFloat(v1),
        tech_v2: parseFloat(v2),
        tech_v3: parseFloat(v3),
        tech_v4: parseFloat(v4),
        tech_v5: parseFloat(v5),
        tech_v6: parseFloat(v6),
        tech_v7: parseFloat(v7),
        tech_v8: parseFloat(v8),
        tech_v9: parseFloat(v9),
        tech_v10: parseFloat(v10),
        tech_no_of: parseInt(no_of),
        tech_p: p,
        tech_q: q,
        tech_main_ans: main_ans,
        tech_main_ans2: main_ans2,
        tech_main_ans3: main_ans3,
        tech_ans: ans,
        tech_uq: uq,
        tech_final_p: final_p,
        tech_final_q: final_q,
        tech_eq: eq,
        tech_result: result,
        tech_final_result: final_result,
      };
    } catch (error) {
      console.error("Error in rational zeros calculation:", error);
      return { error: "Please! Check Your Input." };
    }
  }

  /**
   * getCalculationAugmentedMatrixCalculator: Service Method
   * POST: /api/calculators-lol/augmented-matrix-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAugmentedMatrixCalculator(body) {
    const { matrix2, matrix22, ...request } = body;

    // Helper functions
    const gcd22 = (a, b, f) => {
      if (f) {
        if (b <= 1) return a;
      } else {
        if (!b) return a;
      }
      return gcd22(b, a % b, f);
    };

    const roundresult2 = (x) => {
      const y = parseFloat(x);
      return roundnum2(y, 10);
    };

    const toPrecision2 = (number, precision) => {
      if (number == 0) return 0;
      const exponent = Math.floor(Math.log10(Math.abs(number)) + 1);
      const significand =
        Math.round(
          (number / Math.pow(10, exponent)) * Math.pow(10, precision)
        ) / Math.pow(10, precision);
      return significand * Math.pow(10, exponent);
    };

    const roundnum2 = (x, p) => {
      const n = parseFloat(x);
      const m = toPrecision2(n, p + 1);
      const y = String(m);
      const i = y.indexOf("e");
      if (i == -1) return y;
      return y;
    };

    const digits_after_period2 = (x) => {
      const f = String(x);
      const i = f.indexOf(".");
      if (i == -1) return 0;
      return f.length - i - 1;
    };

    const convert2 = (xelem) => {
      let sign = "";
      let sign2 = "+";
      let f = false;
      const x = xelem;
      const x2 = roundresult2(x);
      const absx = Math.abs(x2);
      const y = Math.floor(absx);
      const frac = absx - y;

      if (x2 < 0) {
        sign = sign2 = "-";
      }

      const d = digits_after_period2(absx);
      const den = Math.round(Math.pow(10, d));
      const num = Math.round(frac * den);
      const a12 = String(num);
      const len = a12.length;

      if (len > 8) f = true;

      const g = gcd22(num, den, f);
      const num2 = Math.round(num / g);
      const den2 = Math.round(den / g);

      const top_jawab = sign + (num2 + den2 * y);
      const down_jawab = den2;

      return [top_jawab, down_jawab];
    };

    const new_rref2 = (matrix) => {
      let lead = 0;
      let pz = JSON.parse(JSON.stringify(matrix)); // Deep copy
      const swap = [];
      const swap_line = [];
      const rowCount = matrix.length;

      if (rowCount === 0) return matrix;

      let columnCount = 0;
      if (matrix[0]) {
        columnCount = matrix[0].length;
      }

      let bus;
      if (rowCount > columnCount) {
        bus = rowCount - 2;
      } else if (rowCount < columnCount) {
        bus = rowCount;
      } else if (rowCount == columnCount) {
        bus = rowCount - 1;
      }

      for (let r = 0; r < bus; r++) {
        if (lead >= columnCount) break;

        // Find pivot row
        let i = r;
        while (i < rowCount && matrix[i][lead] == 0) {
          i++;
          if (i == rowCount) {
            i = r;
            lead++;
            if (lead == columnCount) return [matrix, swap, swap_line, pz];
          }
        }

        // Swap rows if needed
        if (i != r) {
          const temp = matrix[r];
          matrix[r] = matrix[i];
          matrix[i] = temp;

          const temp2 = pz[r];
          pz[r] = pz[i];
          pz[i] = temp2;

          // FIX: Use 0-based indexing like Laravel
          swap_line.push("Swap the row " + r + " with row " + i);
          swap.push(JSON.parse(JSON.stringify(pz)));
        }

        // Normalize pivot row
        const lv = matrix[r][lead];
        if (lv != 0) {
          for (let j = 0; j < columnCount; j++) {
            matrix[r][j] = matrix[r][j] / lv;
            pz[r][j] = pz[r][j] / lv;
          }

          const test1 = convert2(lv);
          // FIX: Use 0-based indexing like Laravel
          if (test1[1] == 1) {
            swap_line.push(
              "Divide row " +
                r +
                " by " +
                lv +
                ": R<sub>" +
                r +
                "</sub> = R<sub>" +
                r +
                "</sub>/" +
                lv
            );
          } else if (test1[1] != 1) {
            const lv3 = test1[1] + "/" + test1[0];
            swap_line.push(
              "Multiply row " +
                r +
                " by " +
                lv3 +
                ": R<sub>" +
                r +
                "</sub> = " +
                lv3 +
                " R<sub>" +
                r +
                "</sub>"
            );
          }
          swap.push(JSON.parse(JSON.stringify(pz)));
        }

        // Eliminate other rows
        for (let i = 0; i < rowCount; i++) {
          if (i !== r && matrix[i][lead] !== 0) {
            const lv = matrix[i][lead];
            const lv2 = pz[i][lead];

            for (let j = 0; j < columnCount; j++) {
              matrix[i][j] -= lv * matrix[r][j];
              pz[i][j] -= lv2 * pz[r][j];
            }

            swap.push(JSON.parse(JSON.stringify(pz)));
            const test = convert2(lv);

            let displayLv;
            if (test[1] == 1) {
              displayLv = lv;
            } else {
              displayLv = test[0] + "/" + test[1];
            }

            // FIX: Use 0-based indexing like Laravel
            if (lv < 0) {
              swap_line.push(
                "Add row " +
                  i +
                  " multiplied by " +
                  displayLv +
                  " from row R" +
                  r +
                  ": R<sub>" +
                  i +
                  "</sub> = R<sub>" +
                  i +
                  "</sub> + " +
                  displayLv +
                  "R<sub>" +
                  r +
                  "</sub>"
              );
            } else if (lv >= 0) {
              swap_line.push(
                "Subtract row " +
                  i +
                  " multiplied by " +
                  displayLv +
                  " from row R" +
                  r +
                  ": R<sub>" +
                  i +
                  "</sub> = R<sub>" +
                  i +
                  "</sub> - " +
                  displayLv +
                  "R<sub>" +
                  r +
                  "</sub>"
              );
            }
          }
        }
        lead++;
      }

      return [matrix, swap, swap_line, pz];
    };

    try {
      // Extract matrix data from request
      const second_matrix = [];
      const rows = parseInt(matrix2);
      const cols = parseInt(matrix22);

      for (let i = 1; i <= rows; i++) {
        for (let j = 1; j <= cols; j++) {
          const key = "matrix3" + i + "_" + j;
          if (request[key] !== undefined && !isNaN(parseFloat(request[key]))) {
            second_matrix.push(parseFloat(request[key]));
          }
        }
      }

      // Create matrix from flat array
      const zain = [];
      for (let i = 0; i < second_matrix.length; i += cols) {
        zain.push(second_matrix.slice(i, i + cols));
      }

      const fahad2 = new_rref2(zain);

      return {
        tech_matrix: fahad2[0],
        tech_swap: fahad2[1],
        tech_swap_line: fahad2[2],
        tech_pz: fahad2[3],
      };
    } catch (error) {
      console.error("Error in augmented matrix calculation:", error);
      return { error: "Please! Check Your Input." };
    }
  }

  /**
   * getCalculationElementaryMatrixCalculator: Service Method
   * POST: /api/calculators-lol/elementary-matrix-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationElementaryMatrixCalculator(body) {
    let matrix_size = body.tech_matrix_size;
    let pth_matrix = body.tech_pth_matrix;
    let a = body.tech_a;
    let b = body.tech_b;
    let type = body.tech_type;
    let result_q = body.tech_result_q;

    // Helper function to check if value is numeric
    const isNumeric = (value) => {
      return !isNaN(parseFloat(value)) && isFinite(value);
    };

    // Validate all inputs are numeric
    if (
      !isNumeric(matrix_size) ||
      !isNumeric(pth_matrix) ||
      !isNumeric(a) ||
      !isNumeric(b) ||
      !isNumeric(result_q)
    ) {
      return { error: "Please! Check Your Input." };
    }

    try {
      const size = parseInt(matrix_size);
      const p = parseInt(pth_matrix);
      const q = parseInt(result_q);
      const scalarA = parseFloat(a);
      const scalarB = parseFloat(b);

      if (type == "row") {
        if (q <= size && p <= size && q > 0 && p > 0) {
          if (p != q) {
            // Create identity matrix
            const identity_matrix = [];
            const array = [];

            for (let row = 0; row < size; row++) {
              identity_matrix[row] = [];
              array[row] = [];
              for (let col = 0; col < size; col++) {
                // Checking if row is equal to column
                if (row == col) {
                  identity_matrix[row][col] = 1;
                  array[row][col] = 1;
                } else {
                  identity_matrix[row][col] = 0;
                  array[row][col] = 0;
                }
              }
            }

            // Create multiply matrix (copy of identity)
            const multiply_matrix = JSON.parse(JSON.stringify(identity_matrix));

            // Apply scalar multiplication to rows
            for (let i = 0; i < size; i++) {
              multiply_matrix[p - 1][i] = scalarA * identity_matrix[p - 1][i];
              multiply_matrix[q - 1][i] = scalarB * identity_matrix[q - 1][i];
            }

            // Create addition matrix (copy of multiply_matrix)
            const addition_matrix = JSON.parse(JSON.stringify(multiply_matrix));

            // Perform row addition
            for (let i = 0; i < size; i++) {
              addition_matrix[q - 1][i] =
                addition_matrix[q - 1][i] + addition_matrix[p - 1][i];
            }

            // Create final result array
            const array1 = [];
            const array2 = [];

            for (let i = 0; i < size; i++) {
              array1[0] = array1[0] || [];
              array2[0] = array2[0] || [];
              array1[0][i] = scalarA * identity_matrix[p - 1][i];
              array2[0][i] = scalarB * identity_matrix[q - 1][i];
            }

            // Build final result
            for (let i = 0; i < size; i++) {
              array[q - 1][i] = array1[0][i] + array2[0][i];
            }

            return {
              tech_array: array,
              tech_identity_matrix: identity_matrix,
              tech_multiply_matrix: multiply_matrix,
              tech_addition_matrix: addition_matrix,
            };
          } else {
            return { error: "The row p and q cannot be equal." };
          }
        } else {
          return {
            error: "The row p and q cannot be greater then n or less then 1.",
          };
        }
      } else if (type == "col") {
        if (q <= size && p <= size && q > 0 && p > 0) {
          if (p != q) {
            // Create identity matrix
            const identity_matrix = [];
            const array = [];

            for (let row = 0; row < size; row++) {
              identity_matrix[row] = [];
              array[row] = [];
              for (let col = 0; col < size; col++) {
                // Checking if row is equal to column
                if (row === col) {
                  identity_matrix[row][col] = 1;
                  array[row][col] = 1;
                } else {
                  identity_matrix[row][col] = 0;
                  array[row][col] = 0;
                }
              }
            }

            // Create multiply matrix (copy of identity)
            const multiply_matrix = JSON.parse(JSON.stringify(identity_matrix));

            // Apply scalar multiplication to columns
            for (let i = 0; i < size; i++) {
              multiply_matrix[i][p - 1] = scalarA * identity_matrix[i][p - 1];
              multiply_matrix[i][q - 1] = scalarB * identity_matrix[i][q - 1];
            }

            // Create addition matrix (copy of multiply_matrix)
            const addition_matrix = JSON.parse(JSON.stringify(multiply_matrix));

            // Perform column addition
            for (let i = 0; i < size; i++) {
              addition_matrix[i][q - 1] =
                addition_matrix[i][q - 1] + addition_matrix[i][p - 1];
            }

            // Create final result arrays
            const array1 = [];
            const array2 = [];

            for (let i = 0; i < size; i++) {
              array1[i] = array1[i] || [];
              array2[i] = array2[i] || [];
              array1[i][0] = scalarA * identity_matrix[i][p - 1];
              array2[i][0] = scalarB * identity_matrix[i][q - 1];
            }

            // Build final result
            for (let i = 0; i < size; i++) {
              array[i][q - 1] = array1[i][0] + array2[i][0];
            }

            return {
              tech_array: array,
              tech_identity_matrix: identity_matrix,
              tech_multiply_matrix: multiply_matrix,
              tech_addition_matrix: addition_matrix,
            };
          } else {
            return { error: "The column p and q cannot be equal." };
          }
        } else {
          return {
            error:
              "The column p and q cannot be greater then n or less then 1.",
          };
        }
      } else {
        return { error: "Please! Check Your Input." };
      }
    } catch (error) {
      console.error("Error in elementary matrix calculation:", error);
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationVennDiagramCalculator
   * POST: /api/calculators-lol/venn-diagram-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationVennDiagramCalculator(body) {
    let submit = (body.tech_selection || "").trim();
    let venn_name = (body.tech_venn_name || "").trim();
    let ta = (body.tech_ta || "").trim();
    let tb = (body.tech_tb || "").trim();
    let a = (body.tech_a || "").trim();
    let b = (body.tech_b || "").trim();
    let u = (body.tech_u || "").trim();
    let c = (body.tech_c || "").trim();
    let venn_name3 = (body.tech_venn_name3 || "").trim();
    let ta3 = (body.tech_ta3 || "").trim();
    let tb3 = (body.tech_tb3 || "").trim();
    let tc3 = (body.tech_tc3 || "").trim();
    let a3 = (body.tech_a3 || "").trim();
    let b3 = (body.tech_b3 || "").trim();
    let c3 = (body.tech_c3 || "").trim();
    let u3 = (body.tech_u3 || "").trim();
    let anb3 = (body.tech_anb3 || "").trim();
    let bnc3 = (body.tech_bnc3 || "").trim();
    let cna3 = (body.tech_cna3 || "").trim();
    let anbnc = (body.tech_anbnc || "").trim();

    let param = {};

    if (submit === "twoset") {
      if (
        venn_name &&
        ta &&
        tb &&
        isNumeric(a) &&
        isNumeric(b) &&
        isNumeric(u) &&
        isNumeric(c)
      ) {
        a = parseFloat(a);
        b = parseFloat(b);
        u = parseFloat(u);
        c = parseFloat(c);

        let a_only = a - c;
        let b_only = b - c;
        let res = a_only + b_only + c;
        let res2set = u - res;

        param = {
          tech_res2set: res2set,
          tech_a: a,
          tech_b: b,
          tech_c: c,
          tech_u: u,
          tech_venn_name: venn_name,
          tech_ta: ta,
          tech_tb: tb,
          tech_res: res,
        };
      } else {
        return { error: "Please! Check Your Input" };
      }
    } else if (submit === "threeset") {
      if (
        venn_name3 &&
        ta3 &&
        tb3 &&
        tc3 &&
        isNumeric(a3) &&
        isNumeric(b3) &&
        isNumeric(c3) &&
        isNumeric(u3) &&
        isNumeric(anb3) &&
        isNumeric(bnc3) &&
        isNumeric(cna3) &&
        isNumeric(anbnc)
      ) {
        a3 = parseFloat(a3);
        b3 = parseFloat(b3);
        c3 = parseFloat(c3);
        u3 = parseFloat(u3);
        anb3 = parseFloat(anb3);
        bnc3 = parseFloat(bnc3);
        cna3 = parseFloat(cna3);
        anbnc = parseFloat(anbnc);

        let ab = anb3 - anbnc;
        let bc = bnc3 - anbnc;
        let ca = cna3 - anbnc;

        let a_only = a3 - (ab + anbnc + ca);
        let b_only = b3 - (bc + anbnc + ab);
        let c_only = c3 - (bc + anbnc + ca);
        let res = a_only + b_only + c_only + ab + bc + ca + anbnc;
        let d = u3 - res;

        param = {
          tech_venn_name3: venn_name3,
          tech_ta3: ta3,
          tech_tb3: tb3,
          tech_tc3: tc3,
          tech_a3: a3,
          tech_b3: b3,
          tech_c3: c3,
          tech_u3: u3,
          tech_anb3: anb3,
          tech_bnc3: bnc3,
          tech_cna3: cna3,
          tech_anbnc: anbnc,
          tech_a_only: a_only,
          tech_b_only: b_only,
          tech_c_only: c_only,
          tech_ab: ab,
          tech_bc: bc,
          tech_ca: ca,
          tech_d: d,
          tech_res: res,
        };
      } else {
        return { error: "Please! Check Your Input" };
      }
    } else {
      return { error: "Please! Check Your Input" };
    }

    return param;

    function isNumeric(val) {
      return !isNaN(parseFloat(val)) && isFinite(val);
    }
  }

  /** getCalculationFundamentalCountingPrincipleCalculator
   * POST: /api/calculators-lol/fundamental-counting-principle-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationFundamentalCountingPrincipleCalculator(body) {
    let choices = body.tech_choices; // should be an array

    let result = {};

    if (Array.isArray(choices) && choices.length > 0 && isNumeric(choices[0])) {
      let answer = 1;

      for (let value of choices) {
        if (!isNumeric(value)) {
          return { error: "Please! Check Your Input." };
        }
        answer *= parseFloat(value);
      }

      result.tech_answer = answer;
      result.tech_choices = choices;
      return result;
    } else {
      return { error: "Please! Check Your Input." };
    }

    function isNumeric(val) {
      return !isNaN(parseFloat(val)) && isFinite(val);
    }
  }

  /** getCalculationAveragePercentageCalculator
   * POST: /api/calculators-lol/average-percentage-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationAveragePercentageCalculator(body) {
    let same_sample = body.tech_same_sample;
    let percentage = body.tech_percentage;
    let sample = body.tech_sample;

    let result = {};
    let check = true;

    // Ensure arrays are filtered for non-empty values
    percentage = Array.isArray(percentage)
      ? percentage.filter(
          (val) => val !== "" && val !== null && val !== undefined
        )
      : [];
    sample = Array.isArray(sample)
      ? sample.filter((val) => val !== "" && val !== null && val !== undefined)
      : [];

    if (same_sample === "yes") {
      if (percentage.length < 2) check = false;
    } else {
      if (percentage.length < 2 || sample.length < 2) check = false;
    }

    if (!check) {
      return { error: "Please! Check Your Input.111" };
    }

    let percents_sum, samples_sum, resultValue;

    if (same_sample === "yes") {
      percents_sum = percentage.reduce((sum, val) => sum + parseFloat(val), 0);
      samples_sum = percentage.length;
    } else {
      let percents = [];
      let percents_show = "";
      let percents_show1 = "";

      for (let i = 0; i < percentage.length; i++) {
        let p = parseFloat(percentage[i]);
        let s = parseFloat(sample[i]);
        let product = p * s;
        percents.push(product);

        let plus = i + 1 !== percentage.length ? " + " : "";
        percents_show += `${p}\\% * ${s}${plus}`;
        percents_show1 += `${product}\\%${plus}`;
      }

      percents_sum = percents.reduce((sum, val) => sum + val, 0);
      samples_sum = sample.reduce((sum, val) => sum + parseFloat(val), 0);

      result.tech_percents_show = percents_show;
      result.tech_percents_show1 = percents_show1;
    }

    result.tech_percentage = percentage;
    result.tech_sample = sample;
    result.tech_percents_sum = percents_sum;
    result.tech_samples_sum = samples_sum;
    result.tech_same_sample = same_sample;
    result.tech_result = percents_sum / samples_sum;

    return result;
  }

  /**
   * getCalculationVolumeCalculator: Service Method
   * POST: /api/calculators-lol/volume-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationVolumeCalculator(body) {
    let volume_select = body.tech_volume_select;
    let rec_width = body.tech_rec_width;
    let rec_length = body.tech_rec_length;
    let rec_height = body.tech_rec_height;
    let rec_width_units = body.tech_rec_width_units;
    let rec_length_units = body.tech_rec_length_units;
    let rec_height_units = body.tech_rec_height_units;

    let cub_side = body.tech_cub_side;
    let cub_side_units = body.tech_cub_side_units;

    let cyl_height = body.tech_cyl_height;
    let cyl_height_units = body.tech_cyl_height_units;
    let cyl_diameter = body.tech_cyl_diameter;
    let cyl_diameter_units = body.tech_cyl_diameter_units;

    let con_height = body.tech_con_height;
    let con_height_units = body.tech_con_height_units;
    let con_diameter = body.tech_con_diameter;
    let con_diameter_units = body.tech_con_diameter_units;

    let sph_diameter = body.tech_sph_diameter;
    let sph_diameter_units = body.tech_sph_diameter_units;

    let tri_base = body.tech_tri_base;
    let tri_h = body.tech_tri_h;
    let tri_h_units = body.tech_tri_h_units;
    let tri_base_units = body.tech_tri_base_units;
    let tri_length = body.tech_tri_length;
    let tri_length_units = body.tech_tri_length_units;
    let tri_height = body.tech_tri_height;
    let tri_height_units = body.tech_tri_height_units;

    let pyr_height = body.tech_pyr_height;
    let pyr_height_units = body.tech_pyr_height_units;
    let pyr_side = body.tech_pyr_side;
    let pyr_side_units = body.tech_pyr_side_units;

    let cap_radius = body.tech_cap_radius;
    let cap_radius_units = body.tech_cap_radius_units;
    let cap_height = body.tech_cap_height;
    let cap_height_units = body.tech_cap_height_units;

    let hem_radius = body.tech_hem_radius;
    let hem_radius_units = body.tech_hem_radius_units;

    let hol_height = body.tech_hol_height;
    let hol_height_units = body.tech_hol_height_units;
    let hol_outer_dia = body.tech_hol_outer_dia;
    let hol_outer_dia_units = body.tech_hol_outer_dia_units;
    let hol_inner_dia = body.tech_hol_inner_dia;
    let hol_inner_dia_units = body.tech_hol_inner_dia_units;

    let coni_height = body.tech_coni_height;
    let coni_height_units = body.tech_coni_height_units;
    let coni_bottom_r = body.tech_coni_bottom_r;
    let coni_bottom_r_units = body.tech_coni_bottom_r_units;
    let coni_top_r = body.tech_coni_top_r;
    let coni_top_r_units = body.tech_coni_top_r_units;

    let tru_height = body.tech_tru_height;
    let tru_height_units = body.tech_tru_height_units;
    let tru_top_side = body.tech_tru_top_side;
    let tru_top_side_units = body.tech_tru_top_side_units;
    let tru_base_side = body.tech_tru_base_side;
    let tru_base_side_units = body.tech_tru_base_side_units;

    let ell_sem_a = body.tech_ell_sem_a;
    let ell_sem_a_units = body.tech_ell_sem_a_units;
    let ell_sem_b = body.tech_ell_sem_b;
    let ell_sem_b_units = body.tech_ell_sem_b_units;
    let ell_sem_c = body.tech_ell_sem_c;
    let ell_sem_c_units = body.tech_ell_sem_c_units;

    let square = body.tech_square;
    let square_units = body.tech_square_units;

    let col_height = body.tech_col_height;
    let col_height_units = body.tech_col_height_units;
    let col_radi = body.tech_col_radi;
    let col_radi_units = body.tech_col_radi_units;

    // Helper function to check if value is numeric
    const isNumeric = (value) => {
      return !isNaN(parseFloat(value)) && isFinite(value);
    };

    // Unit conversion function
    const convert_unit = (unit, value) => {
      if (!unit || !isNumeric(value)) return value;

      const conversions = {
        cm: value * 1,
        m: value / 100,
        in: value / 2.54,
        ft: value / 30.48,
        yd: value / 91.44,
      };
      return conversions[unit] || value;
    };

    try {
      const result = {};

      switch (volume_select) {
        case "Rectangular":
          if (
            isNumeric(rec_height) &&
            isNumeric(rec_width) &&
            isNumeric(rec_length)
          ) {
            const height = convert_unit(
              rec_height_units,
              parseFloat(rec_height)
            );
            const width = convert_unit(rec_width_units, parseFloat(rec_width));
            const length = convert_unit(
              rec_length_units,
              parseFloat(rec_length)
            );
            result.tech_rectangular = isNaN(height * width * length)
              ? "NaN"
              : height * width * length;
          } else {
            return { error: "Please! Check Your Input" };
          }
          break;

        case "Cube":
          if (isNumeric(cub_side)) {
            const side = convert_unit(cub_side_units, parseFloat(cub_side));
            result.tech_cube = isNaN(side * side * side)
              ? "NaN"
              : side * side * side;
          } else {
            return { error: "Please! Check Your Input" };
          }
          break;

        case "Cylinder":
          if (isNumeric(cyl_height) && isNumeric(cyl_diameter)) {
            const height = convert_unit(
              cyl_height_units,
              parseFloat(cyl_height)
            );
            const diameter = convert_unit(
              cyl_diameter_units,
              parseFloat(cyl_diameter)
            );
            const radius = diameter / 2;
            result.tech_cylinder = isNaN(Math.PI * Math.pow(radius, 2) * height)
              ? "NaN"
              : Math.PI * Math.pow(radius, 2) * height;
            result.tech_radius = isNaN(radius) ? "NaN" : radius;
          } else {
            return { error: "Please! Check Your Input" };
          }
          break;

        case "Cone":
          if (isNumeric(con_height) && isNumeric(con_diameter)) {
            const height = convert_unit(
              con_height_units,
              parseFloat(con_height)
            );
            const diameter = convert_unit(
              con_diameter_units,
              parseFloat(con_diameter)
            );
            const radius = diameter / 2;
            result.tech_cone = isNaN(
              (1 / 3) * Math.PI * Math.pow(radius, 2) * height
            )
              ? "NaN"
              : (1 / 3) * Math.PI * Math.pow(radius, 2) * height;
            result.tech_radius = isNaN(radius) ? "NaN" : radius;
          } else {
            return { error: "Please! Check Your Input" };
          }
          break;

        case "Sphere":
          if (isNumeric(sph_diameter)) {
            const diameter = convert_unit(
              sph_diameter_units,
              parseFloat(sph_diameter)
            );
            const radius = diameter / 2;
            result.tech_sphere = isNaN((4 / 3) * Math.PI * Math.pow(radius, 3))
              ? "NaN"
              : (4 / 3) * Math.PI * Math.pow(radius, 3);
            result.tech_radius = isNaN(radius) ? "NaN" : radius;
          } else {
            return { error: "Please! Check Your Input" };
          }
          break;

        case "Triangular":
          if (
            isNumeric(tri_height) &&
            isNumeric(tri_base) &&
            isNumeric(tri_length) &&
            isNumeric(tri_h)
          ) {
            const tri_a = convert_unit(tri_base_units, parseFloat(tri_base));
            const tri_b = convert_unit(
              tri_length_units,
              parseFloat(tri_length)
            );
            const tri_c = convert_unit(
              tri_height_units,
              parseFloat(tri_height)
            );
            const tri_d = convert_unit(tri_h_units, parseFloat(tri_h));

            const baseArea =
              (tri_a + tri_b + tri_c) *
              (tri_b + tri_c - tri_a) *
              (tri_c + tri_a - tri_b) *
              (tri_a + tri_b - tri_c);

            result.tech_triangular = isNaN(
              (1 / 4) * tri_d * Math.sqrt(baseArea)
            )
              ? "NaN"
              : (1 / 4) * tri_d * Math.sqrt(baseArea);
            result.tech_baseArea = isNaN(baseArea) ? "NaN" : baseArea;
          } else {
            return { error: "Please! Check Your Input" };
          }
          break;

        case "Capsule":
          if (isNumeric(cap_radius) && isNumeric(cap_height)) {
            const radius = convert_unit(
              cap_radius_units,
              parseFloat(cap_radius)
            );
            const height = convert_unit(
              cap_height_units,
              parseFloat(cap_height)
            );
            result.tech_capsule = isNaN(
              Math.PI * Math.pow(radius, 2) * ((radius * 4) / 3 + height)
            )
              ? "NaN"
              : Math.PI * Math.pow(radius, 2) * ((radius * 4) / 3 + height);
          } else {
            return { error: "Please! Check Your Input" };
          }
          break;

        case "Hemisphere":
          if (isNumeric(hem_radius)) {
            const radius = convert_unit(
              hem_radius_units,
              parseFloat(hem_radius)
            );
            result.tech_hemisphere = isNaN(
              (2 / 3) * Math.PI * Math.pow(radius, 3)
            )
              ? "NaN"
              : (2 / 3) * Math.PI * Math.pow(radius, 3);
          } else {
            return { error: "Please! Check Your Input" };
          }
          break;

        case "Hollow":
          if (
            isNumeric(hol_height) &&
            isNumeric(hol_outer_dia) &&
            isNumeric(hol_inner_dia)
          ) {
            const height = convert_unit(
              hol_height_units,
              parseFloat(hol_height)
            );
            const outerDia = convert_unit(
              hol_outer_dia_units,
              parseFloat(hol_outer_dia)
            );
            const innerDia = convert_unit(
              hol_inner_dia_units,
              parseFloat(hol_inner_dia)
            );

            if (outerDia <= innerDia) {
              return {
                error: "Outer diameter should be greater than inner diameter.",
              };
            }

            const rad = Math.pow(outerDia, 2) - Math.pow(innerDia, 2);
            result.tech_hollow = isNaN((Math.PI * height * rad) / 4)
              ? "NaN"
              : (Math.PI * height * rad) / 4;
          } else {
            return { error: "Please! Check Your Input" };
          }
          break;

        case "Conical":
          if (
            isNumeric(coni_height) &&
            isNumeric(coni_bottom_r) &&
            isNumeric(coni_top_r)
          ) {
            const height = convert_unit(
              coni_height_units,
              parseFloat(coni_height)
            );
            const bottomR = convert_unit(
              coni_bottom_r_units,
              parseFloat(coni_bottom_r)
            );
            const topR = convert_unit(coni_top_r_units, parseFloat(coni_top_r));

            const At = Math.PI * Math.pow(topR, 2);
            const Ab = Math.PI * Math.pow(bottomR, 2);
            result.tech_conical = isNaN(
              (height / 3) * (At + Ab + Math.sqrt(At * Ab))
            )
              ? "NaN"
              : (height / 3) * (At + Ab + Math.sqrt(At * Ab));
          } else {
            return { error: "Please! Check Your Input" };
          }
          break;

        case "Truncated":
          if (
            isNumeric(tru_height) &&
            isNumeric(tru_top_side) &&
            isNumeric(tru_base_side)
          ) {
            const height = convert_unit(
              tru_height_units,
              parseFloat(tru_height)
            );
            const topSide = convert_unit(
              tru_top_side_units,
              parseFloat(tru_top_side)
            );
            const baseSide = convert_unit(
              tru_base_side_units,
              parseFloat(tru_base_side)
            );

            const A1 = topSide * topSide;
            const A2 = baseSide * baseSide;
            result.tech_truncated = isNaN(
              (1 / 3) * height * (A1 + A2 + Math.sqrt(A1 * A2))
            )
              ? "NaN"
              : (1 / 3) * height * (A1 + A2 + Math.sqrt(A1 * A2));
          } else {
            return { error: "Please! Check Your Input" };
          }
          break;

        case "Ellipsoid":
          if (
            isNumeric(ell_sem_a) &&
            isNumeric(ell_sem_b) &&
            isNumeric(ell_sem_c)
          ) {
            const semA = convert_unit(ell_sem_a_units, parseFloat(ell_sem_a));
            const semB = convert_unit(ell_sem_b_units, parseFloat(ell_sem_b));
            const semC = convert_unit(ell_sem_c_units, parseFloat(ell_sem_c));
            result.tech_ellipsoid = isNaN(
              (4 / 3) * Math.PI * semA * semB * semC
            )
              ? "NaN"
              : (4 / 3) * Math.PI * semA * semB * semC;
          } else {
            return { error: "Please! Check Your Input" };
          }
          break;

        case "Pyramid":
          if (isNumeric(pyr_height) && isNumeric(pyr_side)) {
            const height = convert_unit(
              pyr_height_units,
              parseFloat(pyr_height)
            );
            const side = convert_unit(pyr_side_units, parseFloat(pyr_side));
            const baseArea = side * side;
            result.tech_pyramid = isNaN((1 / 3) * baseArea * height)
              ? "NaN"
              : (1 / 3) * baseArea * height;
            result.tech_baseArea = isNaN(baseArea) ? "NaN" : baseArea;
          } else {
            return { error: "Please! Check Your Input" };
          }
          break;

        case "Square":
          if (isNumeric(square)) {
            const side = convert_unit(square_units, parseFloat(square));
            result.tech_square = isNaN(side * side * side)
              ? "NaN"
              : side * side * side;
          } else {
            return { error: "Please! Check Your Input" };
          }
          break;

        case "Column":
          if (isNumeric(col_height) && isNumeric(col_radi)) {
            const height = convert_unit(
              col_height_units,
              parseFloat(col_height)
            );
            const radius = convert_unit(col_radi_units, parseFloat(col_radi));
            result.tech_column = isNaN(Math.PI * Math.pow(radius, 2) * height)
              ? "NaN"
              : Math.PI * Math.pow(radius, 2) * height;
          } else {
            return { error: "Please! Check Your Input" };
          }
          break;

        default:
          return { error: "Please! Check Your Input" };
      }

      return result;
    } catch (error) {
      console.error("Error in volume calculation:", error);
      return { error: "Please! Check Your Input" };
    }
  }

  /**
   * getCalculationSimilarTrianglesCalculator: Service Method
   * POST: /api/calculators-lol/similar-triangles-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationSimilarTrianglesCalculator(body) {
    let type = body.tech_type;
    let similarity = body.tech_similarity;

    let ABC_f = body.tech_ABC_f;
    let ABC_f_unit = body.tech_ABC_f_unit;
    let ABC_f_deg_rad = body.tech_ABC_f_deg_rad;

    let ABC_s = body.tech_ABC_s;
    let ABC_s_unit = body.tech_ABC_s_unit;
    let ABC_s_deg_rad = body.tech_ABC_s_deg_rad;

    let ABC_t = body.tech_ABC_t;
    let ABC_t_unit = body.tech_ABC_t_unit;
    let ABC_t_deg_rad = body.tech_ABC_t_deg_rad;

    let ABC_corresponding = body.tech_ABC_corresponding;
    let ABC_corresponding_unit = body.tech_ABC_corresponding_unit;

    let scale_factor = body.tech_scale_factor;

    let DEF_f = body.tech_DEF_f;
    let DEF_f_unit = body.tech_DEF_f_unit;
    let DEF_f_deg_rad = body.tech_DEF_f_deg_rad;

    let DEF_s = body.tech_DEF_s;
    let DEF_s_unit = body.tech_DEF_s_unit;
    let DEF_s_deg_rad = body.tech_DEF_s_deg_rad;

    let DEF_t = body.tech_DEF_t;
    let DEF_t_unit = body.tech_DEF_t_unit;
    let DEF_t_deg_rad = body.tech_DEF_t_deg_rad;

    let DEF_corresponding = body.tech_DEF_corresponding;
    let DEF_corresponding_unit = body.tech_DEF_corresponding_unit;

    // Helper function to check if value is numeric
    const isNumeric = (value) => {
      return !isNaN(parseFloat(value)) && isFinite(value);
    };

    // Unit conversion function for length
    const imp_unit = (a, b) => {
      const conversions = {
        mm: a / 10,
        cm: a * 1,
        m: a * 100,
        km: a * 100000,
        in: a * 2.54,
        ft: a * 30.48,
        yd: a * 91.44,
        mi: a * 160900,
      };
      return conversions[b] || a;
    };

    // Angle unit conversion function
    const ang_unit = (a, b) => {
      if (b == "rad") {
        return a * 114.592; // Convert radians to degrees (180/π ≈ 57.296, but using 114.592 as in original)
      } else {
        return a * 1; // Degrees remain as is
      }
    };

    try {
      if (type == "1") {
        // Similarity check
        if (similarity == "SSS") {
          if (
            isNumeric(ABC_f) &&
            isNumeric(ABC_s) &&
            isNumeric(ABC_t) &&
            isNumeric(DEF_f) &&
            isNumeric(DEF_s) &&
            isNumeric(DEF_t)
          ) {
            const abc_f = imp_unit(parseFloat(ABC_f), ABC_f_unit);
            const abc_s = imp_unit(parseFloat(ABC_s), ABC_s_unit);
            const abc_t = imp_unit(parseFloat(ABC_t), ABC_t_unit);
            const def_f = imp_unit(parseFloat(DEF_f), DEF_f_unit);
            const def_s = imp_unit(parseFloat(DEF_s), DEF_s_unit);
            const def_t = imp_unit(parseFloat(DEF_t), DEF_t_unit);

            let jawab, symbol;
            if (abc_f == def_f && abc_s == def_s && abc_t == def_t) {
              symbol = "∼";
              jawab = "equal";
            } else {
              jawab = "notequal";
              symbol = "≁";
            }

            return {
              tech_jawab: jawab,
              tech_symbol: symbol,
            };
          } else {
            return { error: "Please Check Your Input." };
          }
        } else if (similarity == "SAS") {
          if (
            isNumeric(ABC_f) &&
            isNumeric(ABC_s) &&
            isNumeric(ABC_t) &&
            isNumeric(DEF_f) &&
            isNumeric(DEF_s) &&
            isNumeric(DEF_t)
          ) {
            const abc_f = imp_unit(parseFloat(ABC_f), ABC_f_unit);
            const abc_s = imp_unit(parseFloat(ABC_s), ABC_s_unit);
            const abc_t = ang_unit(parseFloat(ABC_t), ABC_t_deg_rad);
            const def_f = imp_unit(parseFloat(DEF_f), DEF_f_unit);
            const def_s = imp_unit(parseFloat(DEF_s), DEF_s_unit);
            const def_t = ang_unit(parseFloat(DEF_t), DEF_t_deg_rad);

            let jawab, symbol;
            if (abc_f == def_f && abc_s == def_s && abc_t == def_t) {
              symbol = "∼";
              jawab = "equal";
            } else {
              jawab = "notequal";
              symbol = "≁";
            }

            return {
              tech_jawab: jawab,
              tech_symbol: symbol,
            };
          } else {
            return { error: "Please Check Your Input." };
          }
        } else {
          // AA similarity
          if (
            isNumeric(ABC_f) &&
            isNumeric(ABC_s) &&
            isNumeric(ABC_corresponding) &&
            isNumeric(DEF_f) &&
            isNumeric(DEF_s) &&
            isNumeric(DEF_corresponding)
          ) {
            const abc_f = ang_unit(parseFloat(ABC_f), ABC_f_deg_rad);
            const abc_s = ang_unit(parseFloat(ABC_s), ABC_s_deg_rad);
            const abc_corresponding = imp_unit(
              parseFloat(ABC_corresponding),
              ABC_corresponding_unit
            );
            const def_f = ang_unit(parseFloat(DEF_f), DEF_f_deg_rad);
            const def_s = ang_unit(parseFloat(DEF_s), DEF_s_deg_rad);
            const def_corresponding = imp_unit(
              parseFloat(DEF_corresponding),
              DEF_corresponding_unit
            );

            const ACB_jawab = 180 - (abc_f + abc_s);
            const DEF_jawab = 180 - (def_f + def_s);
            const scale_ans = def_corresponding / abc_corresponding;
            let jawab, symbol;
            if (abc_f == def_f && abc_s == def_s) {
              symbol = "∼";
              jawab = "equal";
            } else {
              jawab = "notequal";
              symbol = "≁";
            }

            return {
              tech_jawab: jawab,
              tech_symbol: symbol,
              tech_ACB_jawab: isNaN(ACB_jawab) ? "NaN" : ACB_jawab,
              tech_DEF_jawab: isNaN(DEF_jawab) ? "NaN" : DEF_jawab,
              tech_scale_ans: isNaN(scale_ans) ? "NaN" : scale_ans,
            };
          } else {
            return { error: "Please Check Your Input." };
          }
        }
      } else {
        // Scale factor calculation
        if (
          isNumeric(ABC_f) &&
          isNumeric(ABC_s) &&
          isNumeric(ABC_t) &&
          isNumeric(scale_factor)
        ) {
          const abc_f = imp_unit(parseFloat(ABC_f), ABC_f_unit);
          const abc_s = imp_unit(parseFloat(ABC_s), ABC_s_unit);
          const abc_t = imp_unit(parseFloat(ABC_t), ABC_t_unit);
          const scale = parseFloat(scale_factor);

          // Calculate ABC triangle properties
          const ABC_perimeter_ans = abc_f + abc_s + abc_t;
          const ABC_semi = ABC_perimeter_ans / 2;
          const ABC_area_ans = Math.sqrt(
            ABC_semi *
              ((ABC_semi - abc_f) * (ABC_semi - abc_s) * (ABC_semi - abc_t))
          );

          // Calculate DEF triangle properties using scale factor
          const DEF_f_ans = abc_f * scale;
          const DEF_s_ans = abc_s * scale;
          const DEF_t_ans = abc_t * scale;
          const DEF_perimeter_ans = DEF_f_ans + DEF_s_ans + DEF_t_ans;
          const DEF_semi = DEF_perimeter_ans / 2;
          const DEF_area_ans = Math.sqrt(
            DEF_semi *
              ((DEF_semi - DEF_f_ans) *
                (DEF_semi - DEF_s_ans) *
                (DEF_semi - DEF_t_ans))
          );

          return {
            tech_ABC_perimeter_ans: isNaN(ABC_perimeter_ans)
              ? "NaN"
              : Math.round(ABC_perimeter_ans * 100) / 100,
            tech_ABC_semi: isNaN(ABC_semi) ? "NaN" : ABC_semi,
            tech_ABC_area_ans: isNaN(ABC_area_ans)
              ? "NaN"
              : Math.round(ABC_area_ans * 100) / 100,
            tech_DEF_f_ans: isNaN(DEF_f_ans) ? "NaN" : DEF_f_ans,
            tech_DEF_s_ans: isNaN(DEF_s_ans) ? "NaN" : DEF_s_ans,
            tech_DEF_t_ans: isNaN(DEF_t_ans) ? "NaN" : DEF_t_ans,
            tech_DEF_perimeter_ans: isNaN(DEF_perimeter_ans)
              ? "NaN"
              : Math.round(DEF_perimeter_ans * 100) / 100,
            tech_DEF_semi: isNaN(DEF_semi) ? "NaN" : DEF_semi,
            tech_DEF_area_ans: isNaN(DEF_area_ans)
              ? "NaN"
              : Math.round(DEF_area_ans * 100) / 100,
          };
        } else {
          return { error: "Please Check Your Input." };
        }
      }
    } catch (error) {
      console.error("Error in similar triangles calculation:", error);
      return { error: "Please Check Your Input." };
    }
  }

  /**
   * getCalculationVolumeOfRectangleCalculator: Service Method
   * POST: /api/calculators-lol/volume-of-a-rectangle
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationVolumeOfRectangleCalculator(body) {
    let choose = body.tech_choose;
    let first = body.tech_first;
    let first_unit = body.tech_first_unit;
    let second = body.tech_second;
    let second_unit = body.tech_second_unit;
    let third = body.tech_third;
    let third_unit = body.tech_third_unit;
    let units = body.tech_units;

    // Helper function to check if value is numeric
    const isNumeric = (value) => {
      return !isNaN(parseFloat(value)) && isFinite(value);
    };

    // Unit conversion function
    const convert_into_cm = (unit, value) => {
      const conversions = {
        mm: value * 0.1,
        cm: value * 1,
        m: value * 100,
        km: value * 1000,
        in: value * 2.54,
        ft: value * 30.48,
        yd: value * 91.44,
        mi: value * 160934,
      };
      return conversions[unit] || value;
    };

    // Validate inputs
    if (!isNumeric(first) || !isNumeric(second) || !isNumeric(third)) {
      return { error: "Please Enter Valid Input." };
    }

    try {
      // Convert inputs to cm
      const first_cm = convert_into_cm(first_unit, parseFloat(first));
      const second_cm = convert_into_cm(second_unit, parseFloat(second));
      const third_cm = convert_into_cm(third_unit, parseFloat(third));

      let length,
        width,
        height,
        diagonal,
        s_tot,
        s_lat,
        s_top,
        s_btm,
        volume_ans;

      // Calculate based on chosen option
      switch (choose) {
        case "hlw": // height, length, width
          length = first_cm;
          width = second_cm;
          height = third_cm;
          diagonal = Math.sqrt(
            Math.pow(length, 2) + Math.pow(width, 2) + Math.pow(height, 2)
          );
          s_tot = 2 * (length * width + length * height + width * height);
          s_lat = 2 * height * (length + width);
          s_top = length * width;
          s_btm = length * width;
          volume_ans = length * width * height;
          break;

        case "slw": // surface area, length, width
          length = first_cm;
          width = second_cm;
          s_tot = third_cm;
          height = (s_tot / 2 - length * width) / (length + width);
          diagonal = Math.sqrt(
            Math.pow(length, 2) + Math.pow(width, 2) + Math.pow(height, 2)
          );
          s_lat = 2 * height * (length + width);
          s_top = length * width;
          s_btm = length * width;
          volume_ans = length * width * height;
          break;

        case "vlw": // volume, length, width
          length = first_cm;
          width = second_cm;
          volume_ans = third_cm;
          height = volume_ans / (length * width);
          diagonal = Math.sqrt(
            Math.pow(length, 2) + Math.pow(width, 2) + Math.pow(height, 2)
          );
          s_tot = 2 * (length * width + length * height + width * height);
          s_lat = 2 * height * (length + width);
          s_top = length * width;
          s_btm = length * width;
          break;

        default: // diagonal, length, width
          length = first_cm;
          width = second_cm;
          diagonal = third_cm;
          height = Math.sqrt(
            Math.pow(diagonal, 2) - Math.pow(length, 2) - Math.pow(width, 2)
          );
          s_tot = 2 * (length * width + length * height + width * height);
          s_lat = 2 * height * (length + width);
          s_top = length * width;
          s_btm = length * width;
          volume_ans = length * width * height;
          break;
      }

      // Unit conversion factors
      const conversionFactors = {
        mm: { single_val: 10, square_val: 100, cube_val: 1000 },
        cm: { single_val: 1, square_val: 1, cube_val: 1 },
        m: { single_val: 0.01, square_val: 0.0001, cube_val: 0.000001 },
        km: {
          single_val: 0.00001,
          square_val: 0.0000000001,
          cube_val: 0.000000000000001,
        },
        in: { single_val: 0.393701, square_val: 0.155, cube_val: 0.0610237 },
        ft: {
          single_val: 0.0328084,
          square_val: 0.0010763888889,
          cube_val: 0.000035315,
        },
        yd: {
          single_val: 0.0109361,
          square_val: 0.00011959876543333333655,
          cube_val: 0.00000130795,
        },
        mi: {
          single_val: 0.0000062137,
          square_val: 0.00000000003861013863421143294,
          cube_val: 0.000000000000000239913,
        },
      };

      const factors = conversionFactors[units] || conversionFactors.cm;

      // Convert results to desired units and round to 2 decimal places
      const result = {
        tech_length: isNaN(length)
          ? "NaN"
          : Math.round(length * factors.single_val * 100) / 100,
        tech_width: isNaN(width)
          ? "NaN"
          : Math.round(width * factors.single_val * 100) / 100,
        tech_height: isNaN(height)
          ? "NaN"
          : Math.round(height * factors.single_val * 100) / 100,
        tech_diagonal: isNaN(diagonal)
          ? "NaN"
          : Math.round(diagonal * factors.single_val * 100) / 100,
        tech_s_tot: isNaN(s_tot)
          ? "NaN"
          : Math.round(s_tot * factors.square_val * 100) / 100,
        tech_s_lat: isNaN(s_lat)
          ? "NaN"
          : Math.round(s_lat * factors.square_val * 100) / 100,
        tech_s_top: isNaN(s_top)
          ? "NaN"
          : Math.round(s_top * factors.square_val * 100) / 100,
        tech_s_btm: isNaN(s_btm)
          ? "NaN"
          : Math.round(s_btm * factors.square_val * 100) / 100,
        tech_volume_ans: isNaN(volume_ans)
          ? "NaN"
          : Math.round(volume_ans * factors.cube_val * 100) / 100,
      };

      return result;
    } catch (error) {
      console.error("Error in rectangular volume calculation:", error);
      return { error: "Please Enter Valid Input." };
    }
  }

  /**
   * getCalculationConicalFrustumVolumeCalculator: Service Method
   * POST: /api/calculators-lol/conical-frustum-volume-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationConicalFrustumVolumeCalculator(body) {
    let choose = body.tech_choose;
    let first = body.tech_first;
    let first_unit = body.tech_first_unit;
    let second = body.tech_second;
    let second_unit = body.tech_second_unit;
    let third = body.tech_third;
    let third_unit = body.tech_third_unit;
    let pi_val = body.tech_pi_val;
    let units = body.tech_units;

    // Helper function to check if value is numeric
    const isNumeric = (value) => {
      return !isNaN(parseFloat(value)) && isFinite(value);
    };

    // Unit conversion function
    const new_convert_into_cm = (unit, value) => {
      const conversions = {
        mm: value * 0.1,
        cm: value * 1,
        m: value * 100,
        km: value * 1000,
        in: value * 2.54,
        ft: value * 30.48,
        yd: value * 91.44,
        mi: value * 160934,
      };
      return conversions[unit] || value;
    };

    // Validate inputs
    if (
      !isNumeric(first) ||
      !isNumeric(second) ||
      !isNumeric(third) ||
      !isNumeric(pi_val)
    ) {
      return { error: "Please Check Your Input." };
    }

    try {
      // Convert inputs to cm
      const first_cm = new_convert_into_cm(first_unit, parseFloat(first));
      const second_cm = new_convert_into_cm(second_unit, parseFloat(second));
      const third_cm = new_convert_into_cm(third_unit, parseFloat(third));
      const pi = parseFloat(pi_val);

      let radius_1, radius_2, height, slant_height, volume, lsa, tsa, bsa, ttsa;

      // Calculate based on chosen option
      switch (choose) {
        case "r_h": // radius and height
          radius_1 = first_cm;
          radius_2 = second_cm;
          height = third_cm;
          slant_height = Math.sqrt(
            Math.pow(radius_1 - radius_2, 2) + Math.pow(height, 2)
          );
          lsa =
            pi *
            (radius_1 + radius_2) *
            Math.sqrt(Math.pow(radius_1 - radius_2, 2) + Math.pow(height, 2));
          tsa = pi * Math.pow(radius_1, 2);
          bsa = pi * Math.pow(radius_2, 2);
          ttsa =
            pi *
            (Math.pow(radius_1, 2) +
              Math.pow(radius_2, 2) +
              (radius_1 + radius_2) *
                Math.sqrt(
                  Math.pow(radius_1 - radius_2, 2) + Math.pow(height, 2)
                ));
          volume =
            (1 / 3) *
            pi *
            height *
            (radius_1 * radius_1 + radius_2 * radius_2 + radius_1 * radius_2);
          break;

        case "r_sh": // radius and slant height
          radius_1 = first_cm;
          radius_2 = second_cm;
          slant_height = third_cm;
          height = Math.sqrt(
            Math.pow(slant_height, 2) - Math.pow(radius_1 - radius_2, 2)
          );
          volume =
            (1 / 3) *
            pi *
            height *
            (radius_1 * radius_1 + radius_2 * radius_2 + radius_1 * radius_2);
          lsa =
            pi *
            (radius_1 + radius_2) *
            Math.sqrt(Math.pow(radius_1 - radius_2, 2) + Math.pow(height, 2));
          tsa = pi * Math.pow(radius_1, 2);
          bsa = pi * Math.pow(radius_2, 2);
          ttsa =
            pi *
            (Math.pow(radius_1, 2) +
              Math.pow(radius_2, 2) +
              (radius_1 + radius_2) *
                Math.sqrt(
                  Math.pow(radius_1 - radius_2, 2) + Math.pow(height, 2)
                ));
          break;

        case "r_v": // radius and volume
          radius_1 = first_cm;
          radius_2 = second_cm;
          volume = third_cm;
          height =
            (volume * 3) /
            (pi *
              (radius_1 * radius_1 +
                radius_2 * radius_2 +
                radius_1 * radius_2));
          slant_height = Math.sqrt(
            Math.pow(radius_1 - radius_2, 2) + Math.pow(height, 2)
          );
          lsa =
            pi *
            (radius_1 + radius_2) *
            Math.sqrt(Math.pow(radius_1 - radius_2, 2) + Math.pow(height, 2));
          tsa = pi * Math.pow(radius_1, 2);
          bsa = pi * Math.pow(radius_2, 2);
          ttsa =
            pi *
            (Math.pow(radius_1, 2) +
              Math.pow(radius_2, 2) +
              (radius_1 + radius_2) *
                Math.sqrt(
                  Math.pow(radius_1 - radius_2, 2) + Math.pow(height, 2)
                ));
          break;

        case "r_l": // radius and lateral surface area
          radius_1 = first_cm;
          radius_2 = second_cm;
          lsa = third_cm;
          height = Math.sqrt(
            Math.pow(lsa / (pi * (radius_1 + radius_2)), 2) -
              Math.pow(radius_1 - radius_2, 2)
          );
          slant_height = Math.sqrt(
            Math.pow(radius_1 - radius_2, 2) + Math.pow(height, 2)
          );
          tsa = pi * Math.pow(radius_1, 2);
          bsa = pi * Math.pow(radius_2, 2);
          ttsa =
            pi *
            (radius_1 + radius_2) *
            Math.sqrt(Math.pow(radius_1 - radius_2, 2) + Math.pow(height, 2));
          volume =
            (1 / 3) *
            pi *
            height *
            (radius_1 * radius_1 + radius_2 * radius_2 + radius_1 * radius_2);
          break;

        default: // radius and total surface area
          radius_1 = first_cm;
          radius_2 = second_cm;
          ttsa = third_cm;
          height = Math.sqrt(
            Math.pow(radius_1 + radius_2, 2) -
              Math.pow(radius_1 - radius_2, 2) -
              Math.pow(ttsa / pi, 2)
          );
          volume =
            (1 / 3) *
            pi *
            height *
            (radius_1 * radius_1 + radius_2 * radius_2 + radius_1 * radius_2);
          lsa =
            pi *
            (radius_1 + radius_2) *
            Math.sqrt(Math.pow(radius_1 - radius_2, 2) + Math.pow(height, 2));
          slant_height = Math.sqrt(
            Math.pow(radius_1 - radius_2, 2) + Math.pow(height, 2)
          );
          tsa = pi * Math.pow(radius_1, 2);
          bsa = pi * Math.pow(radius_2, 2);
          break;
      }

      // Unit conversion factors
      const conversionFactors = {
        mm: { single_val: 10, square_val: 100, cube_val: 1000 },
        cm: { single_val: 1, square_val: 1, cube_val: 1 },
        m: { single_val: 0.01, square_val: 0.0001, cube_val: 0.000001 },
        km: {
          single_val: 0.00001,
          square_val: 0.0000000001,
          cube_val: 0.000000000000001,
        },
        in: { single_val: 0.393701, square_val: 0.155, cube_val: 0.0610237 },
        ft: {
          single_val: 0.0328084,
          square_val: 0.0010763888889,
          cube_val: 0.000035315,
        },
        yd: {
          single_val: 0.0109361,
          square_val: 0.00011959876543333333655,
          cube_val: 0.00000130795,
        },
        mi: {
          single_val: 0.0000062137,
          square_val: 0.00000000003861013863421143294,
          cube_val: 0.000000000000000239913,
        },
      };

      const factors = conversionFactors[units] || conversionFactors.cm;

      // Convert results to desired units and round to 2 decimal places
      const result = {
        tech_radius_1: isNaN(radius_1)
          ? "NaN"
          : Math.round(radius_1 * factors.single_val * 100) / 100,
        tech_radius_2: isNaN(radius_2)
          ? "NaN"
          : Math.round(radius_2 * factors.single_val * 100) / 100,
        tech_height: isNaN(height)
          ? "NaN"
          : Math.round(height * factors.single_val * 100) / 100,
        tech_slant_height: isNaN(slant_height)
          ? "NaN"
          : Math.round(slant_height * factors.single_val * 100) / 100,
        tech_volume: isNaN(volume)
          ? "NaN"
          : Math.round(volume * factors.cube_val * 100) / 100,
        tech_lsa: isNaN(lsa)
          ? "NaN"
          : Math.round(lsa * factors.square_val * 100) / 100,
        tech_tsa: isNaN(tsa)
          ? "NaN"
          : Math.round(tsa * factors.square_val * 100) / 100,
        tech_bsa: isNaN(bsa)
          ? "NaN"
          : Math.round(bsa * factors.square_val * 100) / 100,
        tech_ttsa: isNaN(ttsa)
          ? "NaN"
          : Math.round(ttsa * factors.square_val * 100) / 100,
      };

      return result;
    } catch (error) {
      console.error("Error in conical frustum calculation:", error);
      return { error: "Please Check Your Input." };
    }
  }

  /**
   * getCalculationFibonacciCalculator: Service Method
   * POST: /api/calculators-lol/fibonacci-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationFibonacciCalculator(body) {
    const n = parseFloat(body.tech_n);
    const units = body.tech_units;
    const first_term = parseInt(body.tech_first_term);
    const second_term = parseInt(body.tech_second_term);

    // Helper function to generate Fibonacci sequence
    function generateFibonacci(start, end) {
      const fibonacci = [0, 1];
      for (let i = 2; i <= end; i++) {
        fibonacci[i] = fibonacci[i - 1] + fibonacci[i - 2];
      }
      return fibonacci.slice(start, end + 1);
    }

    let result = {};

    if (units === "A Sequence") {
      if (isNaN(first_term) || isNaN(second_term) || first_term > second_term) {
        result.error = "Please Check Your Input.";
        return result;
      }

      const fibonacci_sequence = generateFibonacci(first_term, second_term);
      result.tech_fibonacci_sequence = fibonacci_sequence;
      return result;
    } else {
      if (!isNaN(n)) {
        if (n < -250) {
          return { error: "n Value is less than -250" };
        }
        if (n >= 251) {
          return { error: "n Value is greater than or equal to 250" };
        }

        const phi = (1 + Math.sqrt(5)) / 2;
        const psi = 1 - phi;
        const answer = (Math.pow(phi, n) - Math.pow(psi, n)) / Math.sqrt(5);
        result.tech_answer = answer;
        return result;
      } else {
        return { error: "Please Check Your Input." };
      }
    }
  }

  /**
   * getCalculationCircumferenceToDiameterCalculator: Service Method
   * POST: /api/calculators-lol/circumference-to-diameter-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCircumferenceToDiameterCalculator(body) {
    const conversionType = body.tech_conversionType;
    let value = parseFloat(body.tech_value);
    const unit = body.tech_unit;

    function convert_unit(unit, value) {
      if (unit === "cm") {
        return value;
      } else if (unit === "mm") {
        return value * 10;
      } else if (unit === "m") {
        return value * 0.01;
      } else if (unit === "km") {
        return value * 0.00001;
      } else if (unit === "in") {
        return value * 0.3937;
      } else if (unit === "ft") {
        return value * 0.0328084;
      } else if (unit === "yd") {
        return value * 0.0109361;
      } else if (unit === "mi") {
        return value * 0.0000062137;
      } else {
        return value;
      }
    }

    if (!isNaN(value)) {
      value = convert_unit(unit, value);
      let result;

      if (conversionType === "circumferenceToDiameter") {
        result = value / Math.PI;
      } else {
        result = value * Math.PI;
      }

      return {
        tech_result: result,
        tech_unit: unit,
      };
    } else {
      return {
        error: "Please Check Your Input.",
      };
    }
  }

  /** getCalculationTaylorSeriesCalculator
   * POST: /api/calculators-lol/taylor-series-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationTaylorSeriesCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let point = body.tech_point;
    let find = body.tech_find ?? "";
    let n = body.tech_n;
    let withVar = body.tech_with;

    let result = {};

    // Input validation
    const unsafePattern = /[<>&]|php|print_r|print|echo|script|=|%/i;
    if (!EnterEq || unsafePattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    if (EnterEq.indexOf(withVar) === -1) {
      return { error: `Variable ${withVar} does not exist in the function` };
    }

    if (!isNumeric(point) || !isNumeric(n)) {
      return { error: "Please! Check Your Input." };
    }

    // Sanitizing the equation
    let parem = EnterEq.replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^x/g, "exp(x)")
      .replace(/e\^y/g, "exp(y)")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    try {
      const response = await axios.get("http://167.172.134.148/taylor", {
        timeout: 120000,
        params: {
          equ: parem,
          wrt: withVar,
          how: n,
          find: find,
          point: point,
        },
      });

      const buffer = response.data.split("@HA_");

      result.tech_eexe = buffer[0];
      result.tech_enter = buffer[1];
      result.tech_res = buffer[2];
      result.tech_series = buffer[3];

      if (isNumeric(find)) {
        result.tech_efun = buffer[4];
        result.tech_eser = buffer[5];
        result.tech_efv = buffer[6];
        result.tech_fsv = buffer[7];
        result.tech_err = buffer[8];
      }

      return result;
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }

    function isNumeric(val) {
      return !isNaN(parseFloat(val)) && isFinite(val);
    }
  }

  /** getCalculationDerivativeCalculator
   * POST: /api/calculators-lol/derivative-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDerivativeCalculator(body) {
    let EnterEq = body.tech_EnterEq;
    let withVar = body.tech_with;
    let how = body.tech_how;

    let result = {};

    // Input validation
    const unsafePattern = /[<>&]|php|print_r|print|echo|script|=|%/i;
    if (!EnterEq || unsafePattern.test(EnterEq)) {
      return { error: "Please! Check Your Input." };
    }

    if (!EnterEq || !withVar || !how) {
      return { error: "Please! Check Your Input." };
    }

    // Equation sanitization
    let parem = EnterEq.replace(/\s+/g, "")
      .replace(/\+/g, "plus")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/e\^sqrt\(x\)/g, "exp(2*x)")
      .replace(/e\^x/g, "exp(x)")
      .replace(/e\^/g, "exp")
      .replace(/exp\^/g, "exp")
      .replace(/\^/g, "**");

    try {
      const response = await axios.get("http://167.172.134.148/derivative", {
        timeout: 120000,
        params: {
          equ: parem,
          wrt: withVar,
          how: how,
        },
      });

      const buffer = response.data.split("@@@");

      if (parseInt(how) > 1) {
        result.tech_enter = buffer[0];
        result.tech_final_res = buffer;
      } else {
        result.tech_buffer = buffer[0];
        result.tech_ans = buffer[1];
        result.tech_enter = buffer[2];
        result.tech_simple = buffer[3];
      }

      return result;
    } catch (err) {
      return { error: "Please! Check Your Input." };
    }
  }

  /**
   * getCalculationDistanceFormulaCalculator: Service Method
   * POST: /api/calculators-lol/distance-formula-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationDistanceFormulaCalculator(body) {
    let type = body.tech_type;
    let dimen = body.tech_dimen;
    let px2 = body["tech_2px2"];
    let px1 = body["tech_2px1"];
    let x1 = body.tech_x1;
    let x2 = body.tech_x2;
    let x3 = body.tech_x3;
    let y1 = body.tech_y1;
    let y2 = body.tech_y2;
    let y3 = body.tech_y3;
    let m = body.tech_m;
    let m2 = body.tech_m2;
    let b = body.tech_b;
    let b2 = body.tech_b2;
    let x31 = body["tech_3x1"];
    let x32 = body["tech_3x2"];
    let x33 = body["tech_3x3"];
    let y31 = body["tech_3y1"];
    let y32 = body["tech_3y2"];
    let y33 = body["tech_3y3"];
    let z31 = body["tech_3z1"];
    let z32 = body["tech_3z2"];
    let z33 = body["tech_3z3"];
    let x41 = body["tech_4x1"];
    let x42 = body["tech_4x2"];
    let x43 = body["tech_4x3"];
    let y41 = body["tech_4y1"];
    let y42 = body["tech_4y2"];
    let y43 = body["tech_4y3"];
    let z41 = body["tech_4z1"];
    let z42 = body["tech_4z2"];
    let z43 = body["tech_4z3"];
    let k41 = body["tech_4k1"];
    let k42 = body["tech_4k2"];
    let k43 = body["tech_4k3"];
    let px31 = body["tech_3px1"];
    let px32 = body["tech_3px2"];
    let px33 = body["tech_3px3"];

    // Helper function to check if value is numeric
    const isNumeric = (value) => {
      return !isNaN(parseFloat(value)) && isFinite(value);
    };

    try {
      if (type == "2P" && dimen == "1D") {
        if (isNumeric(px1) && isNumeric(px2)) {
          const ans = Math.sqrt(Math.pow(px2 - px1, 2));
          return {
            tech_ans: isNaN(ans) ? "NaN" : ans,
          };
        } else {
          return { error: "Please fill all fields" };
        }
      }

      if (type === "2P" && dimen === "2D") {
        if (isNumeric(x1) && isNumeric(x2) && isNumeric(y1) && isNumeric(y2)) {
          const ans =
            Math.round(
              Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)) * 10000
            ) / 10000;
          return {
            tech_ans: isNaN(ans) ? "NaN" : ans,
          };
        } else {
          return { error: "Please fill all fields" };
        }
      }

      if (type == "2P" && dimen == "3D") {
        if (
          isNumeric(x31) &&
          isNumeric(y31) &&
          isNumeric(z31) &&
          isNumeric(x32) &&
          isNumeric(y32) &&
          isNumeric(z32)
        ) {
          const ans =
            Math.round(
              Math.sqrt(
                Math.pow(x32 - x31, 2) +
                  Math.pow(y32 - y31, 2) +
                  Math.pow(z32 - z31, 2)
              ) * 10000
            ) / 10000;
          return {
            tech_ans: isNaN(ans) ? "NaN" : ans,
          };
        } else {
          return { error: "Please fill all fields" };
        }
      }

      if (type == "2P" && dimen == "4D") {
        if (
          isNumeric(x41) &&
          isNumeric(y41) &&
          isNumeric(z41) &&
          isNumeric(k41) &&
          isNumeric(x42) &&
          isNumeric(y42) &&
          isNumeric(z42) &&
          isNumeric(k42)
        ) {
          const ans =
            Math.round(
              Math.sqrt(
                Math.pow(x42 - x41, 2) +
                  Math.pow(y42 - y41, 2) +
                  Math.pow(z42 - z41, 2) +
                  Math.pow(k42 - k41, 2)
              ) * 10000
            ) / 10000;
          return {
            tech_ans: isNaN(ans) ? "NaN" : ans,
          };
        } else {
          return { error: "Please fill all fields" };
        }
      }

      if (type == "3P" && dimen == "1D") {
        if (isNumeric(px31) && isNumeric(px32) && isNumeric(px33)) {
          const ans1 = Math.sqrt(Math.pow(px32 - px31, 2));
          const ans2 = Math.sqrt(Math.pow(px33 - px32, 2));
          const ans3 = Math.sqrt(Math.pow(px33 - px31, 2));
          return {
            tech_ans1: isNaN(ans1) ? "NaN" : ans1,
            tech_ans2: isNaN(ans2) ? "NaN" : ans2,
            tech_ans3: isNaN(ans3) ? "NaN" : ans3,
          };
        } else {
          return { error: "Please fill all fields" };
        }
      }

      if (type == "3P" && dimen == "2D") {
        if (
          isNumeric(x1) &&
          isNumeric(x2) &&
          isNumeric(x3) &&
          isNumeric(y1) &&
          isNumeric(y2) &&
          isNumeric(y3)
        ) {
          const ans1 =
            Math.round(
              Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)) * 10000
            ) / 10000;
          const ans2 =
            Math.round(
              Math.sqrt(Math.pow(x3 - x2, 2) + Math.pow(y3 - y2, 2)) * 10000
            ) / 10000;
          const ans3 =
            Math.round(
              Math.sqrt(Math.pow(x3 - x1, 2) + Math.pow(y3 - y1, 2)) * 10000
            ) / 10000;
          return {
            tech_ans1: isNaN(ans1) ? "NaN" : ans1,
            tech_ans2: isNaN(ans2) ? "NaN" : ans2,
            tech_ans3: isNaN(ans3) ? "NaN" : ans3,
          };
        } else {
          return { error: "Please fill all fields" };
        }
      }

      if (type == "3P" && dimen == "3D") {
        if (
          isNumeric(x31) &&
          isNumeric(y31) &&
          isNumeric(z31) &&
          isNumeric(x32) &&
          isNumeric(y32) &&
          isNumeric(z32) &&
          isNumeric(x33) &&
          isNumeric(y33) &&
          isNumeric(z33)
        ) {
          const ans1 =
            Math.round(
              Math.sqrt(
                Math.pow(x32 - x31, 2) +
                  Math.pow(y32 - y31, 2) +
                  Math.pow(z32 - z31, 2)
              ) * 10000
            ) / 10000;
          const ans2 =
            Math.round(
              Math.sqrt(
                Math.pow(x33 - x32, 2) +
                  Math.pow(y33 - y32, 2) +
                  Math.pow(z33 - z32, 2)
              ) * 10000
            ) / 10000;
          const ans3 =
            Math.round(
              Math.sqrt(
                Math.pow(x33 - x31, 2) +
                  Math.pow(y33 - y31, 2) +
                  Math.pow(z33 - z31, 2)
              ) * 10000
            ) / 10000;
          return {
            tech_ans1: isNaN(ans1) ? "NaN" : ans1,
            tech_ans2: isNaN(ans2) ? "NaN" : ans2,
            tech_ans3: isNaN(ans3) ? "NaN" : ans3,
          };
        } else {
          return { error: "Please fill all fields" };
        }
      }

      if (type == "3P" && dimen == "4D") {
        if (
          isNumeric(x41) &&
          isNumeric(y41) &&
          isNumeric(z41) &&
          isNumeric(k41) &&
          isNumeric(x42) &&
          isNumeric(y42) &&
          isNumeric(z42) &&
          isNumeric(k42) &&
          isNumeric(x43) &&
          isNumeric(y43) &&
          isNumeric(z43) &&
          isNumeric(k43)
        ) {
          const ans1 =
            Math.round(
              Math.sqrt(
                Math.pow(x42 - x41, 2) +
                  Math.pow(y42 - y41, 2) +
                  Math.pow(z42 - z41, 2) +
                  Math.pow(k42 - k41, 2)
              ) * 10000
            ) / 10000;
          const ans2 =
            Math.round(
              Math.sqrt(
                Math.pow(x43 - x42, 2) +
                  Math.pow(y43 - y42, 2) +
                  Math.pow(z43 - z42, 2) +
                  Math.pow(k43 - k42, 2)
              ) * 10000
            ) / 10000;
          const ans3 =
            Math.round(
              Math.sqrt(
                Math.pow(x43 - x41, 2) +
                  Math.pow(y43 - y41, 2) +
                  Math.pow(z43 - z41, 2) +
                  Math.pow(k43 - k41, 2)
              ) * 10000
            ) / 10000;
          return {
            tech_ans1: isNaN(ans1) ? "NaN" : ans1,
            tech_ans2: isNaN(ans2) ? "NaN" : ans2,
            tech_ans3: isNaN(ans3) ? "NaN" : ans3,
          };
        } else {
          return { error: "Please fill all fields" };
        }
      }

      if (type == "PS") {
        if (isNumeric(x1) && isNumeric(y1) && isNumeric(m) && isNumeric(b)) {
          const ans =
            Math.round(
              (Math.abs(m * x1 - y1 + b) / Math.sqrt(Math.pow(m, 2) + 1)) *
                10000
            ) / 10000;
          return {
            tech_ans: isNaN(ans) ? "NaN" : ans,
          };
        } else {
          return { error: "Please fill all fields" };
        }
      }

      if (type == "PL") {
        if (isNumeric(m2) && isNumeric(b2) && isNumeric(m) && isNumeric(b)) {
          if (m2 != m) {
            return { error: "Make sure that lines are parallel (m = m₂)" };
          }
          const ans =
            Math.round(((b2 - b) / Math.sqrt(Math.pow(m, 2) + 1)) * 10000) /
            10000;
          return {
            tech_ans: isNaN(ans) ? "NaN" : ans,
          };
        } else {
          return { error: "Please fill all fields" };
        }
      }

      // If no matching type found
      return { error: "Please! Check Your Input." };
    } catch (error) {
      console.error("Error in distance formula calculation:", error);
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationCircumcenterCalculator
   * POST: /api/calculators-lol/circumcenter-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationCircumcenterCalculator(body) {
    let x1 = body.tech_x1;
    let y1 = body.tech_y1;
    let x2 = body.tech_x2;
    let y2 = body.tech_y2;
    let x3 = body.tech_x3;
    let y3 = body.tech_y3;

    let result = {};

    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }

    if (
      isNumeric(x1) &&
      isNumeric(y1) &&
      isNumeric(x2) &&
      isNumeric(y2) &&
      isNumeric(x3) &&
      isNumeric(y3)
    ) {
      x1 = +x1;
      y1 = +y1;
      x2 = +x2;
      y2 = +y2;
      x3 = +x3;
      y3 = +y3;

      // Midpoints and slopes for AB, BC, CA
      let m1x = (x1 + x2) / 2;
      let m1y = (y1 + y2) / 2;
      let m2x = (x2 + x3) / 2;
      let m2y = (y2 + y3) / 2;
      let m3x = (x3 + x1) / 2;
      let m3y = (y3 + y1) / 2;

      let slopeAB = (y2 - y1) / (x2 - x1);
      let slopeBC = (y3 - y2) / (x3 - x2);
      let slopeCA = (y3 - y1) / (x3 - x1);

      let perpAB = -1 / slopeAB;
      let perpBC = -1 / slopeBC;
      let perpCA = -1 / slopeCA;

      let x, y;

      if (isFinite(perpAB) && isFinite(perpBC)) {
        let b1 = m1y - perpAB * m1x;
        let b2 = m2y - perpBC * m2x;
        x = (b2 - b1) / (perpAB - perpBC);
        y = perpAB * x + b1;
      } else if (isFinite(perpBC) && isFinite(perpCA)) {
        let b2 = m2y - perpBC * m2x;
        let b3 = m3y - perpCA * m3x;
        x = (b3 - b2) / (perpBC - perpCA);
        y = perpBC * x + b2;
      } else if (isFinite(perpAB) && isFinite(perpCA)) {
        let b1 = m1y - perpAB * m1x;
        let b3 = m3y - perpCA * m3x;
        x = (b3 - b1) / (perpAB - perpCA);
        y = perpAB * x + b1;
      } else {
        return {
          error: "Cannot calculate circumcenter due to degenerate triangle.",
        };
      }

      result.tech_x = x;
      result.tech_y = y;
      return result;
    } else {
      return { error: "Please! Check Your Input." };
    }
  }

  /** getCalculationLinearIndependenceCalculator
   * POST: /api/calculators-lol/linear-independence-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationLinearIndependenceCalculator(body) {
    let row = body.tech_row;
    let colum = body.tech_colum;

    let check = true;

    for (let i = 0; i < row; i++) {
      for (let j = 0; j < colum; j++) {
        let key = `tech_matrix_${i}_${j}`;
        if (!isNumeric(body[key])) {
          check = false;
        }
      }
    }

    if (check) {
      return {
        tech_row: row,
        tech_colum: colum,
      };
    } else {
      return {
        error: "Please! Check Your Input.",
      };
    }

    function isNumeric(val) {
      return !isNaN(parseFloat(val)) && isFinite(val);
    }
  }

  /** getCalculationPercentChangeCalculator
   * POST: /api/calculators-lol/percentage-change-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationPercentChangeCalculator(body) {
    let initial_value = body.tech_initial_value;
    let final_value = body.tech_final_value;

    let result = {};

    if (isNumeric(initial_value) && isNumeric(final_value)) {
      initial_value = parseFloat(initial_value);
      final_value = parseFloat(final_value);

      let difference = final_value - initial_value;
      let answer = (difference / Math.abs(initial_value)) * 100;

      result.tech_answer = answer;
      result.tech_difference = difference;
      return result;
    } else {
      return {
        error: "Please provide both the initial and final values to proceed.",
      };
    }

    function isNumeric(val) {
      return !isNaN(parseFloat(val)) && isFinite(val);
    }
  }

  /**
   * getCalculationeUtGpaCalculator: Service Method
   * POST: /api/calculators-lol/ut-gpa-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationeUtGpaCalculator(body) {
    try {
      const { currentCGPA, creditsCompleted, semesters } = body;

      let totalGradePoints = 0;
      let totalCredits = 0;
      let semesterResults = [];

      // Calculate previous coursework if provided
      if (currentCGPA && creditsCompleted) {
        const prevCGPA = parseFloat(currentCGPA);
        const prevCredits = parseFloat(creditsCompleted);
        totalGradePoints += prevCGPA * prevCredits;
        totalCredits += prevCredits;
      }

      // Calculate each semester
      if (semesters && Array.isArray(semesters)) {
        semesters.forEach((semester, semesterIndex) => {
          let semesterGradePoints = 0;
          let semesterCredits = 0;
          let semesterCourses = [];

          if (semester.courses && Array.isArray(semester.courses)) {
            semester.courses.forEach((course, courseIndex) => {
              const credits = parseFloat(course.credits);
              const gradePoint = parseFloat(course.grade); // Direct numeric value from dropdown

              if (!isNaN(credits) && !isNaN(gradePoint)) {
                const courseGradePoints = credits * gradePoint;
                semesterGradePoints += courseGradePoints;
                semesterCredits += credits;

                semesterCourses.push({
                  courseName: course.courseName || `Course ${courseIndex + 1}`,
                  grade: course.grade, // Numeric value
                  gradePoint: gradePoint,
                  credits: credits,
                  gradePoints: parseFloat(courseGradePoints.toFixed(2)),
                });
              }
            });
          }

          // Calculate semester GPA
          let semesterGPA = 0;
          if (semesterCredits > 0) {
            semesterGPA = semesterGradePoints / semesterCredits;
          }

          semesterResults.push({
            semesterName:
              semester.semesterName || `Semester ${semesterIndex + 1}`,
            courses: semesterCourses,
            totalCredits: semesterCredits,
            semesterGPA: parseFloat(semesterGPA.toFixed(2)),
            semesterGradePoints: parseFloat(semesterGradePoints.toFixed(2)),
          });

          // Add to overall totals
          totalGradePoints += semesterGradePoints;
          totalCredits += semesterCredits;
        });
      }

      // Calculate cumulative GPA
      let cumulativeGPA = 0;
      if (totalCredits > 0) {
        cumulativeGPA = totalGradePoints / totalCredits;
      }

      // Format results
      const result = {
        success: true,
        cumulativeGPA: parseFloat(cumulativeGPA.toFixed(2)),
        totalGradePoints: parseFloat(totalGradePoints.toFixed(2)),
        totalCredits: totalCredits,
        semesters: semesterResults,
      };

      return result;
    } catch (error) {
      console.error("Error in UT GPA calculation:", error);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  /**
   * getCalculationVolumeOfCapsuleCalculator: Service Method
   * POST: /api/calculators-lol/volume-of-capsule
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationVolumeOfCapsuleCalculator(body) {
    let choose = body.tech_choose;
    let first = body.tech_first;
    let first_unit = body.tech_first_unit;
    let second = body.tech_second;
    let second_unit = body.tech_second_unit;
    let pi_val = body.tech_pi_val;
    let units = body.tech_units;

    // Helper function to check if value is numeric
    const isNumeric = (value) => {
      return !isNaN(parseFloat(value)) && isFinite(value);
    };

    // Unit conversion function
    const newconvert_into_cm = (unit, value) => {
      const conversions = {
        mm: value * 0.1,
        cm: value * 1,
        m: value * 100,
        km: value * 1000,
        in: value * 2.54,
        ft: value * 30.48,
        yd: value * 91.44,
        mi: value * 160934,
      };
      return conversions[unit] || value;
    };

    // Validate inputs
    if (!isNumeric(first) || !isNumeric(second) || !isNumeric(pi_val)) {
      return { error: "Please Check Your Input." };
    }

    try {
      // Convert inputs to cm
      const first_cm = newconvert_into_cm(first_unit, parseFloat(first));
      const second_cm = newconvert_into_cm(second_unit, parseFloat(second));
      const pi = parseFloat(pi_val);

      let radius, side, volume, surface, circumference;

      // Calculate based on chosen option
      switch (choose) {
        case "a_r": // radius and side
          radius = first_cm;
          side = second_cm;
          volume = pi * Math.pow(radius, 2) * ((4 / 3) * radius + side);
          surface = 2 * pi * radius * (2 * radius + side);
          circumference = 2 * pi * radius;
          console.log(volume, surface, circumference);
          break;

        case "v_r": // radius and volume
          radius = first_cm;
          volume = second_cm;
          side = volume / (pi * Math.pow(radius, 2)) - (4 / 3) * radius;
          surface = 2 * pi * radius * (2 * radius + side);
          circumference = 2 * pi * radius;
          break;

        case "s_r": // radius and surface
          radius = first_cm;
          surface = second_cm;
          side = surface / (2 * pi * radius) - 2 * radius;
          volume = pi * Math.pow(radius, 2) * ((4 / 3) * radius + side);
          circumference = 2 * pi * radius;
          break;

        default: // side and circumference
          side = first_cm;
          circumference = second_cm;
          radius = circumference / (2 * pi);
          volume = pi * Math.pow(radius, 2) * ((4 / 3) * radius + side);
          surface = 2 * pi * radius * (2 * radius + side);
          break;
      }

      // Unit conversion factors
      const conversionFactors = {
        mm: { single_val: 10, square_val: 100, cube_val: 1000 },
        cm: { single_val: 1, square_val: 1, cube_val: 1 },
        m: { single_val: 0.01, square_val: 0.0001, cube_val: 0.000001 },
        km: {
          single_val: 0.00001,
          square_val: 0.0000000001,
          cube_val: 0.000000000000001,
        },
        in: { single_val: 0.393701, square_val: 0.155, cube_val: 0.0610237 },
        ft: {
          single_val: 0.0328084,
          square_val: 0.0010763888889,
          cube_val: 0.000035315,
        },
        yd: {
          single_val: 0.0109361,
          square_val: 0.00011959876543333333655,
          cube_val: 0.00000130795,
        },
        mi: {
          single_val: 0.0000062137,
          square_val: 0.00000000003861013863421143294,
          cube_val: 0.000000000000000239913,
        },
      };

      const factors = conversionFactors[units] || conversionFactors.cm;

      // Convert results to desired units
      const result = {
        tech_radius: isNaN(radius)
          ? "NaN"
          : Math.round(radius * factors.single_val * 100) / 100,
        tech_side: isNaN(side)
          ? "NaN"
          : Math.round(side * factors.single_val * 100) / 100,
        tech_volume: isNaN(volume)
          ? "NaN"
          : Math.round(volume * factors.cube_val * 100) / 100,
        tech_surface: isNaN(surface)
          ? "NaN"
          : Math.round(surface * factors.square_val * 100) / 100,
        tech_circumference: isNaN(circumference)
          ? "NaN"
          : Math.round(circumference * factors.single_val * 100) / 100,
      };

      return result;
    } catch (error) {
      console.error("Error in capsule volume calculation:", error);
      return { error: "Please Check Your Input." };
    }
  }

  /**
   * getCalculationeUfGpaCalculator: Service Method
   * POST: /api/calculators-lol/uf-gpa-calculator
   * @param {Object} body Having Properties for Creating New Roles
   * @returns Object with message property having success method
   */

  async getCalculationeUfGpaCalculator(body) {
    try {
      const { courses } = body;

      // console.log('Input Data:', { courses });

      let s_grade = 0;
      let s_hour = 0;
      let gradePointDeficit = 0;
      let courseResults = [];

      // Calculate each course - EXACTLY like your JavaScript
      if (courses && Array.isArray(courses)) {
        courses.forEach((course, index) => {
          const grade = parseFloat(course.grade);
          const hour = parseFloat(course.credits);

          if (!isNaN(grade) && !isNaN(hour)) {
            const courseGradePoints = hour * grade;
            s_grade += courseGradePoints;
            s_hour += hour;

            courseResults.push({
              credits: hour,
              grade: course.grade,
              gradePoints: parseFloat(courseGradePoints.toFixed(3)),
            });
          }
        });
      }

      // Calculate cumulative GPA - EXACTLY like your JavaScript
      let cumulativeGPA = 0;
      if (s_grade !== 0 && s_hour !== 0) {
        cumulativeGPA = s_grade / s_hour;
        cumulativeGPA = parseFloat(cumulativeGPA.toPrecision(3));

        // If DPC is negative, set to 0 (as deficit cannot be negative)
        if (cumulativeGPA < 2) {
          gradePointDeficit = s_hour * 2 - s_grade;
        }
      }

      // Format results
      const result = {
        success: true,
        cumulativeGPA: cumulativeGPA,
        totalGradePoints: parseFloat(s_grade.toFixed(2)),
        totalCredits: s_hour,
        gradePointDeficit: parseFloat(gradePointDeficit.toFixed(3)),
        courses: courseResults,
      };

      // console.log('Final Result:', result);
      return result;
    } catch (error) {
      console.error("Error in UF GPA calculation:", error);
      return {
        success: false,
        error: error.message,
      };
    }
  }


 async getCalculationeGpaCalculator(body) {

      if (body.type_gpa === 'planning') {
          return calculatePlanningGpa(body);
      } else if (body.type_gpa === 'high_school') {
          return calculateHighSchoolGpa(body);
      } else {
          return {
              success: false,
              message: "Invalid GPA type. Please provide a valid type_gpa.",
              status_code: 400,
              error_code: "INVALID_GPA_TYPE"
          };
      }
       function calculateHighSchoolGpa(data) {

            try {
            const {
              type_gpa,
              current_gpa,
              credits_completed,
              grade_format,
              semesters
            } = body;

            // Validate type_gpa
            // if (type_gpa !== 'high_school') {
            //   return {
            //     success: false,
            //     message: 'Invalid GPA type. Must be "high_school"'
            //   };
            // }

            // Validate grade format
            if (!grade_format || ![1, 2, 3].includes(grade_format)) {
              return {
                success: false,
                message: 'Invalid grade format. Must be 1 (Letter), 2 (Percentage), or 3 (Point Value)'
              };
            }

            // Validate semesters
            if (!semesters || !Array.isArray(semesters) || semesters.length === 0) {
              return {
                success: false,
                message: 'At least one semester with courses is required'
              };
            }

            // Initialize totals
            let totalGradePoints = 0;
            let totalCredits = 0;
            const semesterResults = [];

            // Grade conversion mappings
            const letterGrades = {
              'A+': 4.0, 'A': 4.0, 'A-': 3.7,
              'B+': 3.3, 'B': 3.0, 'B-': 2.7,
              'C+': 2.3, 'C': 2.0, 'C-': 1.7,
              'D+': 1.3, 'D': 1.0, 'D-': 0.7,
              'F': 0.0
            };

            const weightValues = {
              'Regular': 0.0,
              'Honors': 0.5,
              'AP / IB': 1.0,
              'College': 1.0
            };

            // Function to convert percentage to grade point
            const percentageToGrade = (percentage) => {
              if (percentage < 65) return 0.0;
              if (percentage >= 65 && percentage <= 66) return 1.0;
              if (percentage >= 67 && percentage <= 69) return 1.3;
              if (percentage >= 70 && percentage <= 72) return 1.7;
              if (percentage >= 73 && percentage <= 76) return 2.0;
              if (percentage >= 77 && percentage <= 79) return 2.3;
              if (percentage >= 80 && percentage <= 82) return 2.7;
              if (percentage >= 83 && percentage <= 86) return 3.0;
              if (percentage >= 87 && percentage <= 89) return 3.3;
              if (percentage >= 90 && percentage <= 92) return 3.7;
              if (percentage >= 93 && percentage <= 100) return 4.0;
              return 0.0;
            };

            // Process each semester
            semesters.forEach((semester, semesterIndex) => {
              let semesterGradePoints = 0;
              let semesterCredits = 0;
              const courses = [];

              if (!semester.courses || !Array.isArray(semester.courses)) {
                return;
              }

              semester.courses.forEach((course, courseIndex) => {
                const {
                  course_name,
                  credit,
                  grade,
                  weight
                } = course;

                // Validate course data
                if (!credit || grade === undefined || grade === null) {
                  return;
                }

                let gradePoint = 0;
                let finalGrade = 0;

                // Calculate grade point based on format
                if (grade_format == 1) {
                  // Letter Grade Format
                  gradePoint = letterGrades[grade] || 0;
                  // Add weight for letter grades
                  const weightValue = weightValues[weight] || 0;
                  gradePoint = gradePoint + weightValue;
                  finalGrade = grade;
                } else if (grade_format == 2) {
                  // Percentage Format
                  gradePoint = percentageToGrade(parseFloat(grade));
                  // Add weight for percentage grades
                  const weightValue = weightValues[weight] || 0;
                  gradePoint = gradePoint + weightValue;
                  finalGrade = gradePoint;
                } else if (grade_format == 3) {
                  // Point Value Format (weight is NOT added, grade is final point value)
                  gradePoint = parseFloat(grade);
                  finalGrade = parseFloat(grade);
                }

                // Calculate grade points for this course
                const courseGradePoints = parseFloat((credit * gradePoint).toFixed(2));

                // Add to semester totals
                semesterGradePoints += courseGradePoints;
                semesterCredits += parseFloat(credit);

                // Store course result
                courses.push({
                  course: course_name || `Course ${courseIndex + 1}`,
                  grade: finalGrade,
                  credit: parseFloat(credit),
                  grade_point: courseGradePoints
                });
              });

              // Calculate semester GPA
              const semesterGPA = semesterCredits > 0 
                ? parseFloat((semesterGradePoints / semesterCredits).toFixed(2))
                : 0;

              // Add to total
              totalGradePoints += semesterGradePoints;
              totalCredits += semesterCredits;

              // Store semester result
              semesterResults.push({
                semester: `Semester ${semesterIndex + 1}`,
                courses: courses,
                total_credit: parseFloat(semesterCredits.toFixed(1)),
                gpa: semesterGPA
              });
            });

            // Calculate cumulative GPA
            let cumulativeGradePoints = totalGradePoints;
            let cumulativeCredits = totalCredits;

            // Include previous GPA if provided
            if (current_gpa && credits_completed) {
              const previousGradePoints = parseFloat(current_gpa) * parseFloat(credits_completed);
              cumulativeGradePoints += previousGradePoints;
              cumulativeCredits += parseFloat(credits_completed);
            }

            const cumulativeGPA = cumulativeCredits > 0
              ? parseFloat((cumulativeGradePoints / cumulativeCredits).toFixed(2))
              : 0;

            // Prepare response
            const result = {
              success: true,
              data: {
                type_gpa: 'high_school',
                grade_format: grade_format === 1 ? 'Letter' : grade_format === 2 ? 'Percentage' : 'Point Value',
                cumulative_gpa: cumulativeGPA,
                total_grade_points: parseFloat(cumulativeGradePoints.toFixed(2)),
                total_credits: parseFloat(cumulativeCredits.toFixed(1)),
                semesters: semesterResults
              }
            };

            return result;

          } catch (error) {
            return {
              success: false,
              message: 'Error calculating GPA',
              error: error.message
            };
          }

       }
      function calculatePlanningGpa(data) {
          const { current_gpa, credits_completed, target_gpa, additional_credits } = data;

          const totalCredits = credits_completed + additional_credits;
          const totalGradePoints = target_gpa * totalCredits;
          const currentGradePoints = current_gpa * credits_completed;
          const requiredGradePoints = totalGradePoints - currentGradePoints;
          const requiredGpa = requiredGradePoints / additional_credits;

          const roundedRequiredGpa = Math.round(requiredGpa * 1000) / 1000;

          const isAchievable = requiredGpa <= 4.0;

          return {
              success: true,
              type: 'Planning',
              data: {
                  current_gpa: parseFloat(current_gpa),
                  credits_completed: parseInt(credits_completed),
                  target_gpa: parseFloat(target_gpa),
                  additional_credits: parseInt(additional_credits),
                  required_gpa: roundedRequiredGpa,
                  is_achievable: isAchievable,
                  message: generateMessage(
                      target_gpa,
                      additional_credits,
                      roundedRequiredGpa,
                      isAchievable
                  )
              }
          };
      }
      function generateMessage(targetGpa, addCredits, requiredGpa, achievable) {
          const creditText = addCredits == 1 ? "1 credit" : `${addCredits} credits`;

          if (!achievable) {
              return `To attain a target GPA ${targetGpa}, the GPA for the next ${creditText} would need to be ${requiredGpa}, which is not achievable.`;
          }
          return `If you want to attain a target GPA ${targetGpa}, then the GPA for the next ${creditText} needs to be ${requiredGpa} or higher.`;
      }



}



  
    







}

module.exports = new CalculatorsServices();
